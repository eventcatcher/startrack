;Xbios
;Xbios-Erweiterung fÅr Audiokarte StarTrack (PCI)
;Release 23.3.1998 by SWE (Stephan Wilhelm EntwicklungsbÅro)

lfifo          equ 2048
resmagic       equ $31415926
cjar           equ $5a0
resval         equ $426
resvect        equ $42a
savptr         equ $4a2
amount         equ 46
xbiosvec       equ $b8
install        equ 500
ireg_p         equ 1      ; interrupt fÅr play
ireg_r         equ 2      ; interrupt fÅr record
ireg_all       equ 3      ; interrupt fÅr record & play
CR             equ $0000000d
LF             equ $0000000a
ESC            equ 27
_hz_200        equ $4ba   ; 200hz-timer

_int_dsp       equ $3fc   ;Hier wird die IR-Routine (124=$1f0)eingetragen

;Grîûe der Strukturelemente: 12 Bytes; Anzahl: 8
sizeof_subs    equ 96     ;8*12 = 96 Bytes

RXDF           equ $0     ;Bitnummer: ISR Receive Data Register Full (RXDF)
TXDE           equ $1     ;Bitnummer: ISR Transmit Data Register Empty (TXDE
TRDY           equ $2     ;Bitnummer: ISR Transmitter Ready (TRDY)
DSP_HF2        equ $3     ;Bitnummer: Hostflag 2
DSP_HF3        equ $4     ;Bitnummer: Hostflag 3

dsp_irctrl     equ $feff0600            ;Interrupt Ctrl Register
dsp_cmdvec     equ $feff0601            ;Command Vector Register
dsp_irstat     equ $feff0602            ;Interrupt Status Register
dsp_irvec      equ $feff0603            ;Interrupt Vector Register
dsp_longwd     equ $feff0604            ;unbenutztes Byte ->fÅr LONG-Zugriff benutzt
dsp_high       equ $feff0605
dsp_mid        equ $feff0606
dsp_low        equ $feff0607

GEMDOS         equ 1

               move.w     #1,-(sp)
               move.w     #500,-(sp)
               trap       #14
               addq.l     #4,sp
               cmpi.l     #$71273800,d0
               bne        do_inst

letitbe:       clr.w      -(sp)         ;* Ab ins Jenseits
               trap       #1            ;GEMDOS


do_inst:       
               movea.l    4(sp),a0
               lea.l      stack_end,sp
               move.l     #$100,d0
               add.l      $c(a0),d0     ; programmlÑnge
               add.l      $14(a0),d0    ; data
               add.l      $1c(a0),d0    ; bss
               move.l     d0,merklen

;-----------------------------------------------------------
; Interrupt-Vektor 122 (fÅr Play) setzen
;-----------------------------------------------------------

               pea        ihandler_play ; neue Interrupt-Routine
               move.w     #122,-(sp)    ; Vektor Nummer 122
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupt-Vektor 123 (fÅr Record) setzen
;-----------------------------------------------------------

               pea        ihandler_rec  ; neue Interrupt-Routine
               move.w     #123,-(sp)    ; Vektor Nummer 123
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupt-Vektoren 79+77 fÅr Falcon-frames setzen
;-----------------------------------------------------------

               pea        ihandler_mfp  ; neue Interrupt-Routine
               move.w     #15,-(sp)
               move.w     #$d,-(sp)     ; MFP-Vektor Nummer 15 setzen
               trap       #14           ;
               addq.l     #8,sp         ; stack korrigieren

               pea        ihandler_tima ; neue Interrupt-Routine
               move.w     #77,-(sp)     ; Vektor Nummer 77
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupt-Vektor 124 (fÅr DSP-Transfer) setzen
;-----------------------------------------------------------

               pea        ihandler_dsp  ; neue Interrupt-Routine
               move.w     #124,-(sp)    ; Vektor Nummer 124
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupt-Vektor 80 (fÅr PCI-Transfer) setzen
;-----------------------------------------------------------

               pea        ihandler_pci  ; neue Interrupt-Routine
               move.w     #80,-(sp)     ; Vektor Nummer 124
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupts erlauben, SCU programmieren
;-----------------------------------------------------------
               clr.l      -(sp)         ;in Supervisormode
               move.w     #32,-(sp)
               trap       #1
               addq.l     #6,sp
               move.l     d0,-(sp)

               lea.l      midisprung,a1 ; Umleitung von midi_in
               move.l     $54a,(a1)
               lea.l      int_midi,a1
               move.l     a1,$54a

               bsr        getsysbase

;cookiejar-test
               clr.w      d7
               lea.l      vmestart,a2
               lea.l      vmemask,a3
               move.l     #$fedf0000,(a2)         ; VME-Start im ST & STE
               move.l     #$ffdf8e0d,(a3)         ; VME-Intmaske im ST & STE
               tst.l      cjar
               bne.s      cookt1a
               clr.l      d0
               bsr        makecjar
cookt1a:       movea.l    cjar,a1
               clr.l      d6
cookt1:        move.l     (a1)+,d1
               move.l     (a1)+,d2
               addq.l     #1,d6
               tst.l      d1
               beq        cookt4
               cmpi.l     #"_SND",d1
               bne.s      cookt1b
               lea.l      cooksnd,a4
               move.l     d2,(a4)
cookt1b:       cmpi.l     #"_MCH",d1
               bne.s      cookt2
               lea.l      cookmch,a4
               move.l     d2,(a4)
               swap.w     d2
               cmpi.w     #2,d2
               bne.s      cookt2
               move.l     #$feff0000,(a2)         ; VME-Start im TT
               move.l     #$ffff8e0d,(a3)         ; VME-Intmaske im TT
cookt2:        cmpi.l     #"_CPU",d1
               bne.s      cookt2b
               lea.l      cookcpu,a4
               move.l     d2,(a4)
cookt2b:       cmpi.l     #"_VDO",d1
               bne.s      cookt2c
               lea.l      cookvdo,a4
               move.l     d2,(a4)
cookt2c:       cmpi.l     #"_FPU",d1
               bne.s      cookt2d
               lea.l      cookfpu,a4
               move.l     d2,(a4)
cookt2d:       cmpi.l     #"MgMc",d1
               bne.s      cookt2e
               lea.l      cookmgmc,a4
               move.l     d2,(a4)
cookt2e:       cmpi.l     #"hade",d1
               bne        cookt1
               move.w     #-1,d7
               move.l     #$feff0000,(a2)         ; VME-Start im hades
               move.l     #$ffff8717,(a3)         ; VME-Intmaske im hades
               bra        cookt1
cookt4:        addi.l     #$401,(a2)
               cmp.l      d6,d2
               bgt.s      cookt5
               move.l     d6,d0
               subq.l     #1,d0
               bsr        makecjar
               tst.l      d0
               bmi.s      cookt6
               movea.l    a0,a1
               subq.l     #4,a1
               move.l     (a1)+,d2
cookt5:        subq.l     #8,a1
               move.l     #"strk",d1
               move.l     d1,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     d2,(a1)+
               addq.l     #1,d6

cookt6:        move.l     a1,-(sp)
               move.l     d6,-(sp)

               cmpi.l     #0,cookmgmc
               bne        demoset1

               lea.l      berrsprung,a1
               move.l     8,(a1)
               lea.l      Buserror,a1
               move.l     a1,8

               lea.l      cookcpu,a4
               cmpi.l     #30,(a4)
               beq.s      noregtest

               lea.l      vmestart,a0
               movea.l    (a0),a0
               clr.l      d2            ; zaehler max Anzahl Soundkarten
               clr.l      d3            ; zaehler installierte soundkarten
               lea.l      cardlist,a1   ; karten-startadressen-liste

               lea.l      cookcpu,a4
               cmpi.l     #40,(a4)
               beq.s      breg40
               cmpi.l     #60,(a4)
               beq.s      breg40
               cmpi.l     #30,(a4)
               beq.s      breg30
               bra.s      breg00
breg40:        bsr        regtest40
               bra.s      bregend
breg30:        bsr        regtest30
               bra.s      bregend
breg00:        nop        
bregend:       lea.l      cardz,a1
               move.w     d3,(a1)
               lea.l      cardsl,a1
               move.w     #1,(a1)
               bra.s      berrset
noregtest:     lea.l      cardz,a1
               move.w     #1,(a1)
               lea.l      cardsl,a1
               move.w     #1,(a1)

berrset:       lea.l      berrsprung,a1
               move.l     (a1),8

               bsr        cardadr

               lea.l      cardz,a2
               move.w     (a2),d2
               swap.w     d2
               movem.l    d1-d7/a0-a6,-(sp)
               bsr        cardmagic
               movem.l    (sp)+,d1-d7/a0-a6
               bra.s      demoset1e

demoset1:      lea.l      vmemul,a2
               move.l     a2,d0
               addq.l     #1,d0
               lea.l      vmestart,a2
               move.l     d0,(a2)
               lea.l      cardlist,a1   ; karten-startadressen-liste
               move.l     (a2),(a1)
               lea.l      cardz,a1
               move.w     #0,(a1)
               lea.l      cardsl,a1
               move.w     #0,(a1)
               bsr        cardadr
               clr.l      d0

demoset1e:     move.l     (sp)+,d6
               movea.l    (sp)+,a1
               move.w     d0,d2
               suba.l     #16,a1
               move.l     (a1)+,d1
               cmpi.l     #"strk",d1
               bne.s      initmask
               move.l     d2,(a1)+
               move.l     4(a1),d3
               cmp.l      d6,d3
               bgt.s      nocj2
               move.l     d6,d0
               subq.l     #1,d0
               bsr        makecjar
               tst.l      d0
               bmi.s      initmask
               movea.l    a0,a1
               subq.l     #4,a1
               move.l     (a1)+,d3
               suba.l     #8,a1
nocj2:         move.l     #"_DSP",d1
               move.l     #0,d2
               move.w     cardmagc,d4
               btst       #5,d4
               beq.s      nodspfound
               move.l     #56002,d2
nodspfound:    move.l     d1,(a1)+
               move.l     d2,(a1)+
               move.l     #0,(a1)+
               move.l     d3,(a1)+

initmask:      

               cmpi.l     #0,cookmgmc
               bne.s      anfint

               lea.l      vmemask,a0    ; VME-Irq-Mask-Reg
               movea.l    (a0),a0
               andi.b     #$61,(a0)
               ori.b      #32,(a0)      ; alle Int5 erlauben
               move.w     sr,d0         ; INTs ein
               andi.w     #%1111100011111111,d0
               move.w     d0,sr

anfint:        
; Register initialisieren

               lea.l      vmestart,a6
               movea.l    (a6),a6
               lea.l      lowreg,a1
               move.b     #0,(a1)
               move.b     #0,(a6)
               lea.l      hireg,a1
               move.b     #0,(a1)
               move.b     #0,$40(a6)
               lea.l      aesreg,a1
               move.b     #0,(a1)
               move.b     #0,$c0(a6)
               lea.l      dspreg,a1
               move.b     #36,(a1)
               move.b     #36,$80(a6)
               lea.l      dsppath1,a1
               move.b     #6,(a1)
               move.b     #6,$210(a6)
               lea.l      dspport,a1
               move.b     #0,(a1)
               move.b     #0,$212(a6)
               lea.l      dsppath2,a1
               move.b     #1,(a1)
               move.b     #1,$214(a6)
               lea.l      dspconv,a1
               move.b     #0,(a1)
               move.b     #0,$216(a6)
               lea.l      dsppdat,a1
               move.b     #0,(a1)
               move.b     #0,$240(a6)
               lea.l      clkdiv,a1
               move.b     #0,(a1)
               move.b     #0,$242(a6)
               lea.l      intreg,a1
               move.b     #0,(a1)
               move.b     #0,$280(a6)

Xbrweiter:     
               move.l     xbiosvec,sprung+2       ; Xbios-Vektor umbiegen
               move.l     xbiosvec,XBspr          ; Xbios-Vektor in Xbra merken
               move.l     xbiosvec,DXBspr         ; Xbios-Vektor in Xbra merken

               cmpi.w     #0,cardz
               bne.s      nodemo

               lea.l      demo_Xbios,a1
               move.l     a1,xbiosvec
               move.w     #'XB',d0      ; Xbra's setzen
               move.w     d0,DXBI
               move.w     #'RA',d0
               move.w     d0,DXBI+2
               bra.s      xbinitex
nodemo:        lea.l      neu_Xbios,a1
               move.l     a1,xbiosvec
               move.w     #'XB',d0      ; Xbra's setzen
               move.w     d0,XBI
               move.w     #'RA',d0
               move.w     d0,XBI+2
xbinitex:      movem.l    d0-d7/a0-a6,-(sp)
               lea.l      stack,a0
               move.w     #0,(a0)
               bsr        compatible

               cmpi.w     #0,cardz
               beq.s      nodspinit

               bsr        dsp_stdinit   ; DSP-Initialize
               jsr        pcisearch     ; for PCI-Support

nodspinit:     movem.l    (sp)+,d0-d7/a0-a6

               move.w     #32,-(sp)     ;in Usermode
               trap       #1
               addq.l     #6,sp

;               pea        Text          ;Msg ausgeben
;               move.w     #9,-(sp)      ;* ausgeben
;               trap       #1            ;GEMDOS
;               addq.l     #6,sp         ;* Stack sÑubern
;               move.l     #600,d0
;               bsr        pause

               clr.w      -(sp)
               move.l     merklen,d0
               move.l     d0,-(sp)
               move.w     #$31,-(sp)    ;resident halten
               trap       #1
               rts        

XBI:           .DC.b "XXXX"
               .DC.b "STRK"
XBspr:         .DS.l 1    ;Puffer fÅr alten XBIOS-Vektor
neu_Xbios:                ;Anfang des neuen Xbios
               move.l     d7,-(sp)
               move.w     4(sp),d7      ;get SR
               move.l     usp,a0
               btst       #13,d7
               beq.s      neu_Xbios1
               lea.l      6(sp),a0
neu_Xbios1:    
               lea.l      Rlist,a1
               cmpi.w     #0,cardz
               bne.s      nodemo2
               lea.l      Rlistb,a1
nodemo2:       moveq.l    #0,d7
               move.w     (a0),d1
neu_Xbios2:    
               cmp.w      0(a1,d7.w),d1
               beq.s      new_found
               addq.w     #2,d7
               tst.w      0(a1,d7.w)
               bne.s      neu_Xbios2
               move.l     (sp)+,d7
sprung:        jmp        $11111111
new_found:     
               mulu.w     #2,d7
               lea.l      R_addr,a1
               cmpi.w     #0,cardz
               bne.s      nodemo3
               lea.l      R_addrb,a1

nodemo3:       movea.l    0(a1,d7.w),a1
;               suba.l     #neu_Xbios,a1
;               adda.l     $b8,a1
               addq.l     #2,a0
               movem.l    d1-d7/a1-a6,-(sp)
               jsr        (a1)
               movem.l    (sp)+,d1-d7/a1-a6
               move.l     (sp)+,d7
               rte        


DXBI:          .DC.b "XXXX"
               .DC.b "STRK"
DXBspr:        .DS.l 1    ;Puffer fÅr alten XBIOS-Vektor
demo_Xbios:               ;Anfang des neuen Xbios
               move.l     d7,-(sp)
               move.w     4(sp),d7      ;get SR
               move.l     usp,a0
               btst       #13,d7
               beq.s      demo_Xbios1
               lea.l      6(sp),a0
demo_Xbios1:   lea.l      Rlist3,a1
               moveq.l    #0,d7
               move.w     (a0),d1
demo_Xbios2:   cmp.w      0(a1,d7.w),d1
               beq.s      demo_found
               addq.w     #2,d7
               tst.w      0(a1,d7.w)
               bne.s      demo_Xbios2
               move.l     (sp)+,d7
               bra.s      sprung
demo_found:    mulu.w     #2,d7
               lea.l      R_addr3,a1
               movea.l    0(a1,d7.w),a1
               addq.l     #2,a0
               movem.l    d1-d7/a1-a6,-(sp)
               jsr        (a1)
               movem.l    (sp)+,d1-d7/a1-a6
               move.l     (sp)+,d7
               rte        

pause:         movem.l    d1-d3,-(sp)
               move.l     $4ba,d1
paus1:         move.l     $4ba,d2
               sub.l      d1,d2
               tst.l      d2
               bmi.s      overrun
paus2:         cmp.l      d0,d2
               blt.s      paus1
               movem.l    (sp)+,d1-d3
               rts        
overrun:       move.l     #-1,d3
               sub.l      d1,d3
               add.l      d3,d2
               bra.s      paus2

speedtst:      movea.l    (a0)+,a1      ; buffer
               move.l     (a0)+,d7      ; loops
               clr.l      d3
               movea.l    a1,a6
               addq.l     #4,a1
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedmemr:     move.w     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedmemr
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedmemw:     move.w     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedmemw
               move.l     $4ba,d1
               move.l     d1,(a1)+
               lea.l      vmestart,a6
               movea.l    (a6),a6
               adda.l     #$206,a6
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedhostr:    move.b     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedhostr
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedhostw:    move.b     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedhostw
               move.l     $4ba,d1
               move.l     d1,(a1)+
               lea.l      vmestart,a6
               movea.l    (a6),a6
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedregr:     move.b     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedregr
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedregw:     move.b     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedregw
               move.l     $4ba,d1
               move.l     d1,(a1)+
               lea.l      vmestart,a6
               movea.l    (a6),a6
               adda.l     #$100,a6
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedfifor:    move.b     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedfifor
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedfifow:    move.b     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedfifow
               move.l     $4ba,d1
               move.l     d1,(a1)+
               clr.l      d0
               rts        

;-------------------------------------------------------------------------------
;  Buserror abfangen und melden
;-------------------------------------------------------------------------------

regtest40:     move.w     #0,flag
               move.b     (a0),d0
               .DC.w $f4f8              ; flush cache
               move.w     flag,d0
               cmpi.w     #0,d0
               bne.s      regtest40b
               addi.w     #1,d3
               move.l     a0,(a1)+
regtest40b:    adda.l     #$4000,a0
               addi.w     #1,d2
               cmpi.w     #4,d2         ; Anzahl max.Karten
               blt.s      regtest40
               rts        

regtest30:     move.w     #0,flag
               .DC.w $4e7a              ; get cachereg
               .DC.w 2
               ori.w      #$808,d0      ; flush cache
               .DC.w $4e7b              ; put cachereg
               .DC.w 2
               move.b     (a0),d1
               .DC.w $4e7a              ; get cachereg
               .DC.w 2
               ori.w      #$808,d0      ; flush cache
               .DC.w $4e7b              ; put cachereg
               .DC.w 2
               move.w     flag,d1
               cmpi.w     #0,d1
               bne.s      regtest30b
               addi.w     #1,d3
               move.l     a0,(a1)+
regtest30b:    adda.l     #$4000,a0
               addi.w     #1,d2
               cmpi.w     #2,d2         ; Anzahl max.Karten
               blt.s      regtest30
               rts        

Buserror:      move.w     #1,flag
               addq.l     #4,2(sp)
               rte        

               .EVEN 
stack_store:   .DS.l 1    ; 1 Langwort fÅr stack

; DSP1----------------------------DSP-Routinen-----------------------
;
;Xbios 96
;
;void    Dsp_DoBlock(char *data_in,long size_in,char *data_out,long size_out);
;
;Wenn vorhanden, dann Åbertrage zuerst <size_in> Daten von <data_in> zum DSP
;und hole dann soviele Daten <data_out>, wie in <size_out> erfragt.
;
Dsp_DoBlock:   
;lblE050BA:
               movea.l    (a0)+,a1      ;*data_in
               move.l     (a0)+,d0      ;size_in
               beq        lblE050EA
               subq.w     #1,d0
lblE050D2:     
               btst.b     #TXDE,dsp_irstat        ;Sendregister leer?
               beq.s      lblE050D2

lblE050DA:     
               move.b     (a1)+,dsp_high
               move.b     (a1)+,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d0,lblE050DA

lblE050EA:     
               movea.l    (a0)+,a1      ;*data_out
               move.l     (a0),d0       ;size_out
               beq        lblE0510A
               subq.w     #1,d0
lblE050F2:     
               btst.b     #RXDF,dsp_irstat        ;Empfangsregister gefÅllt?
               beq.s      lblE050F2

lblE050FA:     
               move.b     dsp_high,(a1)+
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d0,lblE050FA
lblE0510A:     
               rts        

;
;Xbios 97
;
;void    Dsp_BlkHandShake(char *data_in,long size_in,char *data_out,long size_out);
;
Dsp_BlkHandShake:         
;lblE0510C:
               movea.l    (a0)+,a1      ;*data_in
               move.l     (a0)+,d0      ;size_in
               beq        lblE0513C
               subq.w     #1,d0
lblE05124:     
               btst.b     #TXDE,dsp_irstat        ;Senderegister leer?
               beq.s      lblE05124

               move.b     (a1)+,dsp_high
               move.b     (a1)+,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d0,lblE05124

lblE0513C:     
               movea.l    (a0)+,a1      ;*data_out
               move.l     (a0),d0       ;size_out
               beq        lblE0515C
               subq.w     #1,d0
lblE05144:     
               btst.b     #RXDF,dsp_irstat        ;Empfangsregister gefÅllt?
               beq.s      lblE05144

               move.b     dsp_high,(a1)+
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d0,lblE05144
lblE0515C:     
               rts        

;
;Xbios 98
;
;void    Dsp_BlkUnpacked(long *data_in,long size_in,long *data_out,long size_out);
;
Dsp_BlkUnpacked:          
;lblE0515E:
               movea.l    (a0)+,a1      ;*data_int
               move.l     (a0)+,d0      ;size_in
               beq        lblE05186
               subq.w     #1,d0
lblE05176:     
               btst.b     #TXDE,dsp_irstat        ;Senderegister leer?
               beq.s      lblE05176
lblE0517E:     
               move.b     (a1)+,dsp_longwd
               move.b     (a1)+,dsp_high
               move.b     (a1)+,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d0,lblE0517E

lblE05186:     
               movea.l    (a0)+,a1      ;*data_out
               move.l     (a0),d0       ;size_out
               beq        lblE0519E
               subq.w     #1,d0
lblE0518E:     
               btst.b     #RXDF,dsp_irstat        ;Empfangsregister gefÅllt?
               beq.s      lblE0518E
lblE05196:     
               move.b     dsp_longwd,(a1)+
               move.b     dsp_high,(a1)+
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d0,lblE05196
lblE0519E:     
               rts        

;
;Xbios 99
;
;void    Dsp_InStream(char *data_in,long block_size,long num_blocks,long *blocks_done);
;
Dsp_InStream:  
;lblE05324:
               move.l     (a0)+,_dsp_tmtbuf_ptr   ;*data_in
               move.l     (a0)+,_dsp_tmtsize      ;block_insize
               move.l     (a0)+,_dsp_num_tmtblks  ;num_blocks
               move.l     (a0),_dsp_tmtblks_done_ptr        ;*blocks_done
               movea.l    _dsp_tmtblks_done_ptr,a0
               clr.l      (a0)          ;0 blocks ready
               move.l     _dsp_tmtsize,d0
               beq        lblE0536E     ;keine Sendedaten vorhanden
               move.l     #DSP_Stream_IR,_int_dsp
               move.b     #$ff,dsp_irvec          ;IR freigeben
               ori.b      #2,dsp_irctrl ;TXDE Request
lblE0536E:     
               rts        

;
;Xbios 100
;
;void    Dsp_OutStream(data_out,block_size,num_blocks,blocks_done);
;
Dsp_OutStream: 
;lblE05370:
               move.l     (a0)+,_dsp_rcvbuf_ptr   ;*data_out
               move.l     (a0)+,_dsp_rcvsize      ;block_outsize
               move.l     (a0)+,_dsp_num_rcvblks  ;num_blocks
               move.l     (a0),_dsp_rcvblks_done_ptr        ;*blocks_done
               movea.l    _dsp_rcvblks_done_ptr,a0
               clr.l      (a0)          ;0 blocks ready
               move.l     _dsp_rcvsize,d0
               beq        lblE053BA     ;sollen Daten abgeholt werden?
               move.l     #DSP_Stream_IR,_int_dsp
               move.b     #$ff,dsp_irvec          ;IR freigeben
               ori.b      #1,dsp_irctrl ;RXDF Request
lblE053BA:     
               rts        

;
;DSP-Interrupt-Routine
;
DSP_Stream_IR: 
;lblE053BC:
               movem.l    d0/a0,-(sp)
               btst.b     #RXDF,dsp_irstat
               beq        lblE05412     ;keine Daten im Empfangspuffer -> Daten zum DSP schicken
               move.l     _dsp_rcvsize,d0
               subq.w     #1,d0
               movea.l    _dsp_rcvbuf_ptr,a0
lblE053D8:     
               move.b     dsp_high,(a0)+
               move.b     dsp_mid,(a0)+
               move.b     dsp_low,(a0)+
               dbf        d0,lblE053D8
               move.l     a0,_dsp_rcvbuf_ptr
               movea.l    _dsp_rcvblks_done_ptr,a0
               addq.l     #1,(a0)
               move.l     (a0),d0
               cmp.l      _dsp_num_rcvblks,d0
               bne        lblE05454
               andi.b     #$fe,dsp_irctrl         ;RXDF Request lîschen
               bra        lblE05454

lblE05412:                ;Daten zum DSP schicken
               move.l     _dsp_tmtsize,d0
               subq.w     #1,d0
               movea.l    _dsp_tmtbuf_ptr,a0
lblE05420:     
               move.b     (a0)+,dsp_high
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               dbf        d0,lblE05420
               move.l     a0,_dsp_tmtbuf_ptr      ;neue Adresse des Sendepuffers
               movea.l    _dsp_tmtblks_done_ptr,a0
               addq.l     #1,(a0)       ;Block abgeschickt
               move.l     (a0),d0
               cmp.l      _dsp_num_tmtblks,d0     ;alle Blîcke abgeschickt?
               bne        lblE05454
               andi.b     #$fd,dsp_irctrl         ;TXDE Request lîschen
lblE05454:     
               movem.l    (sp)+,d0/a0
               rte        

;
;Xbios 101
;
;void    Dsp_IOStream(char *data_in,char *data_out,long block_insize,long block_outsize,
;                                                 long num_blocks,long *blocks_done);
Dsp_IOStream:  
;lblE0523C:
               move.l     (a0)+,_dsp_tmtbuf_ptr   ;*data_in
               move.l     (a0)+,_dsp_rcvbuf_ptr   ;*data_out
               move.l     (a0)+,_dsp_tmtsize      ;block_insize
               move.l     (a0)+,_dsp_rcvsize      ;block_outsize
               move.l     (a0)+,_dsp_num_tmtblks  ;num_blocks
               move.l     (a0),_dsp_tmtblks_done_ptr        ;*blocks_done
               movea.l    _dsp_tmtblks_done_ptr,a0
               clr.l      (a0)          ;0 blocks ready
               move.l     _dsp_tmtsize,d0         ;Grîûe des Blocks
               subq.w     #1,d0
               movea.l    _dsp_tmtbuf_ptr,a0      ;*data_in
lblE05286:     
               move.b     (a0)+,dsp_high          ;ersten Datenblock zum DSP schicken
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               dbf        d0,lblE05286

               move.l     a0,_dsp_tmtbuf_ptr      ;nun 1 Byte hinter erstem Datenblock
               move.l     #DSP_IOStream_IR,_int_dsp
               move.b     #$ff,dsp_irvec
               ori.b      #1,dsp_irctrl
               rts        

;
;DSP-Interrupt-Routine
;
DSP_IOStream_IR:          
;lblE052B2:
               movem.l    d0/a0,-(sp)
               move.l     _dsp_rcvsize,d0         ;block_outsize
               subq.w     #1,d0
               movea.l    _dsp_rcvbuf_ptr,a0      ;*data_out
lblE052C4:     
               move.b     dsp_high,(a0)+          ;ersten Datenblock vom DSP abholen
               move.b     dsp_mid,(a0)+
               move.b     dsp_low,(a0)+
               dbf        d0,lblE052C4

               move.l     a0,_dsp_rcvbuf_ptr      ;nÑchste Adresse fÅr Empfangsdatenblock
               movea.l    _dsp_tmtblks_done_ptr,a0          ;blocks_done erhîhen
               addq.l     #1,(a0)
               move.l     (a0),d0
               cmp.l      _dsp_num_tmtblks,d0     ;==num_blocks?
               bne        lblE052FA
               andi.b     #$fe,dsp_irctrl         ;fertig ->IR disablen
               bra        lblE0531E     ;raus

lblE052FA:     
               move.l     _dsp_tmtsize,d0         ;block_insize
               subq.w     #1,d0
               movea.l    _dsp_tmtbuf_ptr,a0      ;Adresse fÅr Sendepuffer holen
lblE05308:     
               move.b     (a0)+,dsp_high
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               dbf        d0,lblE05308
               move.l     a0,_dsp_tmtbuf_ptr      ;neue Adresse fÅr Sendepuffer merken
lblE0531E:     
               movem.l    (sp)+,d0/a0
               rte        

;
;Xbios 102
;
;void    Dsp_RemoveInterrupts(int mask);
;
Dsp_RemoveInterrupts:     
;lblE0545A:
               move.w     (a0),d0
               not.b      d0
               and.b      d0,dsp_irctrl
               rts        

;
;Xbios 103
;
;int     Dsp_GetWordSize(void);
Dsp_GetWordSize:          
;lblE05466:
               moveq.l    #3,d0
               rts        
;
;Xbios 104
;int     Dsp_Lock(void);
Dsp_Lock:      
;lblE05FE0:
               move.w     _dsp_lock,d0
               bne        lblE05FF4
               moveq.l    #-1,d1
               move.w     d1,_dsp_lock
lblE05FF4:     
               rts        

;
;Xbios 105
;void    Dsp_Unlock(void);
;
Dsp_Unlock:    
;lblE05FF6:
               clr.w      _dsp_lock
               rts        

;
;Xbios 106
;void    Dsp_Available(long *xavailable,long *yavailable);
Dsp_Available: 
;lblE06022:
               movea.l    (a0)+,a1      ;*xavailable
               movea.l    (a0),a0       ;*yavailable
               move.l     #$3eff,(a0)   ;4k - 256 Bytes
               move.l     _dsp_avail_pmem,d0
               subi.l     #$4000,d0
               move.l     d0,(a1)
               rts        

;
;Xbios 107
;int Dsp_Reserve(long xreserve, long yreserve);
;
Dsp_Reserve:   
;lblE06040:
               move.l     (a0)+,d0      ;xreserve
               addi.l     #$4000,d0
               move.l     _dsp_avail_pmem,d1
               cmp.l      d1,d0
               bgt        lblE06074
               move.l     d0,_dsp_xreserve        ;Grîûe des reservierten X-Speichers + $4000
               move.l     (a0),d0       ;yreserve
               cmpi.l     #$3eff,d0
               bgt        lblE06074
               moveq.l    #0,d0
               rts        

lblE06074:     
               moveq.l    #-1,d0
               rts        

;
;Xbios 108
;
;int     Dsp_LoadProg(char *file,int ability,char *buffer);
;
Dsp_LoadProg:  
;lblE05888:
               movea.l    (a0)+,a1      ;char *file
               move.w     (a0)+,d0      ;int ability
               movea.l    (a0),a0       ;char *buffer

               move.l     a0,-(sp)      ;sichern
               move.w     d0,-(sp)      ;sichern

               bsr        _Dsp_LodToBinary        ;liefert <codesize> oder -1 zurÅck, ! a0=codeptr, a1=file !

               move.w     (sp)+,d1      ;abitlity
               movea.l    (sp)+,a0      ;char *codeptr
               tst.l      d0            ;codesize
               ble.s      lblE058C2

               move.w     d1,_dsp_ability
               move.w     d1,-(sp)      ;ability
               move.l     d0,-(sp)      ;codesize
               move.l     a0,-(sp)      ;*codeptr
               movea.l    sp,a0
               bsr        _Dsp_ExecProg
               lea.l      10(sp),sp
               moveq.l    #0,d0
               rts        

lblE058C2:     
               moveq.l    #-1,d0
               rts        
;
;Xbios 109
;void    Dsp_ExecProg(char *codeptr,long codesize,int ability);
;
Dsp_ExecProg:  
;lblE058D4:
               bsr.s      _Dsp_ExecProg
               rts        

_Dsp_ExecProg: 
               move.l     a0,-(sp)      ;sichern

               moveq.l    #71,d0        ;codesize (Anzahl der _DSP-Wîrter_)
               lea.l      lblE48DE2,a0  ;*codeptr fÅr Dsp_ExecBoot
               bsr        _Dsp_ExecBoot

               movea.l    (sp)+,a0
               movea.l    (a0)+,a1      ;codeptr
               move.l     (a0)+,d0      ;codesize
               beq        exit_Dsp_Exec
               bsr        tmt_to_DSP

               lea.l      _dsp_codebuf,a1         ;und "interne" exec-Routine anwerfen
               moveq.l    #24,d0        ;24 _DSP-Worte_ senden
               bsr        tmt_to_DSP

               move.w     (a0),_dsp_ability       ;ability merken
exit_Dsp_Exec: 
               rts        

;
; a1.l: Quelle
; d0.w: Anzahl der DSP-Worte
;zerstîrt d0,a1
tmt_to_DSP:    
               subq.w     #1,d0
tmt_req:       
               btst.b     #TXDE,dsp_irstat        ;DSP bereit Sendedaten anzunehmen?
               beq.s      tmt_req

               move.b     (a1)+,dsp_high
               move.b     (a1)+,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d0,tmt_req
               rts        

;
;Xbios 110
;
;void    Dsp_ExecBoot(char *codeptr,long codesize,int ability);
;<ability> wird ignoriert!
;
Dsp_ExecBoot:  
               move.l     4(a0),d0      ;codesize
               movea.l    (a0),a0       ;codeptr
               bsr.s      _Dsp_ExecBoot
               rts        

_Dsp_ExecBoot: 
;               move.w     sr,d2
;               move.w     #$2700,sr
               movem.l    d0-d7/a0-a6,-(sp)
               bsr        dspreset
               move.l     #50,d0
               bsr        pause
               movem.l    (sp)+,d0-d7/a0-a6
;               move.w     d2,sr

               move.l     #512,d1       ;Grîûe des interen DSP-Speichers
               sub.l      d0,d1         ;noch verbleibender interner Speicher
               subq.l     #1,d0
lblE05E8A:     
               move.b     (a0)+,dsp_high
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               dbf        d0,lblE05E8A
               tst.l      d1
               beq        lblE05EBC

               subq.l     #1,d1         ;noch verbleibenden freien internen Speicher ausnullen
lblE05EA6:     
               move.b     #0,dsp_high
               move.b     #0,dsp_mid
               move.b     #0,dsp_low
               dbf        d1,lblE05EA6
lblE05EBC:     
               rts        

;
;Xbios 111
;
;long    Dsp_LodToBinary(char *file,char *codeptr);
;
Dsp_LodToBinary:          
               movea.l    (a0)+,a1      ;file
               movea.l    (a0),a0       ;codeptr
               bsr.s      _Dsp_LodToBinary
               rts        

_Dsp_LodToBinary:         
               move.l     a0,-(sp)      ;codeptr sichern

               movea.l    a1,a0         ;*file
               bsr        read_LODfile  ;Datei einlesen, Pufferspeicher allozieren

               movea.l    (sp)+,a1      ;codeptr

               tst.l      d0            ;Pufferadr
               bne.s      lblE0586A
               moveq.l    #-1,d0        ;Pufferadr == 0
               rts        

lblE0586A:     
               movea.l    a0,a2         ;Endadresse des LOD-Files
               movea.l    d0,a0         ;Startadr des LOD-Files
               move.l     a0,-(sp)      ;Pufferadr der LOD-Datei auf den Stack wg. folgendem Mfree
               bsr        conv_LOD_to_bin         ;LOD-Datei konvertieren, a0 = codeptr, liefert BIN-LÑnge in d0 zurÅck
               movea.l    (sp)+,a0
               move.l     d0,-(sp)      ;_dsp_bin_len sichern

               move.l     a0,-(sp)      ;Pufferadr.
               move.w     #$49,-(sp)    ;Mfree
               trap       #GEMDOS
               addq.l     #6,sp         ;Opcode + Pufferadr abrÑumen

               move.l     (sp)+,d0      ;_dsp_bin_len
               divs.w     #3,d0         ;(--> war .l) LÑnge in DSP-Worten
               andi.l     #$ffff,d0     ; NEU !!!
               rts        

;
;Xbios 112
;void    Dsp_TriggerHC(int vector);
;
Dsp_TriggerHC: 
;lblE05FD2:
               move.w     (a0),d0       ;vector
               ori.b      #$80,d0
               move.b     d0,dsp_cmdvec
               rts        

;
;Xbios 113
;int     Dsp_RequestUniqueAbility(void);
;
Dsp_RequestUniqueAbility: 
;lblE0607A:
               move.w     _dsp_uniqueability,d0
               addq.w     #1,d0
               move.w     d0,_dsp_uniqueability
               rts        

;
;Xbios 114
;int     Dsp_GetProgAbility(void);
;
Dsp_GetProgAbility:       
;lblE0608C:
               move.w     _dsp_ability,d0
               rts        

;
;Xbios 115
;void    Dsp_FlushSubroutines(void);
;
Dsp_FlushSubroutines:     
;lblE056B4:
               lea.l      _dsp_subs,a0
               bra.s      lblE056CC

lblE056C2:     
               clr.l      (a0)          ;Adresse lîschen
               clr.w      10(a0)        ;ability lîschen
               adda.w     #12,a0
lblE056CC:     
               cmpa.l     #_dsp_subs+sizeof_subs,a0
               bcs.s      lblE056C2

               move.l     _dsp_max_avail_mem,_dsp_avail_pmem
               clr.w      _dsp_free_subridx
               rts        

;
;Xbios 116
;int     Dsp_LoadSubroutine(char *ptr,long size, int ability);
;
Dsp_LoadSubroutine:       
               movem.l    d5-d7,-(sp)
               movea.l    (a0)+,a1      ;Adresse der Subroutine
               move.l     (a0)+,d0
               move.w     (a0),d1

               move.l     d0,d7         ;size
               move.w     d1,d6         ;ability
               cmpi.l     #1024,d7
               ble.s      lblE05708

               moveq.l    #0,d0         ;Subroutine ist zu groû -> Fehler
               bra        exit_LdSub

lblE05708:     
               move.l     _dsp_xreserve,d0
               add.l      d7,d0
               move.l     _dsp_avail_pmem,d1
               cmp.l      d1,d0
               ble.s      lblE05720

               moveq.l    #0,d0         ;Subroutine ist zu groû
               bra        exit_LdSub

lblE05720:     
               move.w     _dsp_free_subridx,d0
               muls.w     #12,d0
               lea.l      _dsp_subs,a2
               adda.l     d0,a2
               tst.l      (a2)
               beq        DSP_loadsub_entry_free  ;Eintrag ist noch frei

               move.l     (a2),d0       ;Adresse der vorhandenen Subroutine
               subq.l     #1,d0
               move.l     d0,d2
               sub.l      d1,d0

               move.l     d0,-(sp)
               move.l     _dsp_max_avail_mem,-(sp)
               move.l     d2,-(sp)

;3 DSP-Worte im Handshake-Modus zum DSP
               move.b     #$96,dsp_cmdvec         ;Handshake, Hostvektor 22
lblE05EEA:     
               btst.b     #7,dsp_cmdvec
               bne.s      lblE05EEA
               move.b     1(sp),dsp_high
               move.b     2(sp),dsp_mid
               move.b     3(sp),dsp_low

               move.b     5(sp),dsp_high
               move.b     6(sp),dsp_mid
               move.b     7(sp),dsp_low

               move.b     9(sp),dsp_high
               move.b     10(sp),dsp_mid
               move.b     11(sp),dsp_low

               lea.l      $c(sp),sp     ;Stack kor.

               move.w     _dsp_free_subridx,d0
               muls.w     #12,d0
               lea.l      _dsp_subs,a2
               move.l     4(a2,d0.l),d5 ;size
               bra.s      lblE0578E

lblE0577C:     
               add.l      d5,(a2)       ;Grîûe + Startadresse = Endadresse der DSP-Routine
               move.l     (a2),d0       ;Endadresse
               moveq.l    #-$17,d2
               add.w      8(a2),d2      ;Handle beginnen mit $17 (bis $1e)

               muls.w     #6,d2         ;6 Byte pro Eintrag
               lea.l      _dsp_subr_adr,a0
               move.w     d0,4(a0,d2.w) ;Nur Lo- und Mid-Byte eintragen, Hi-Byte ist null
               lea.l      12(a2),a2
lblE0578E:     
               cmpa.l     #_dsp_subs+sizeof_subs,a2
               bcs.s      lblE0577C

               add.l      d5,_dsp_avail_pmem

DSP_loadsub_entry_free:   
               move.l     _dsp_avail_pmem,d1
               sub.l      d7,d1         ;size
               move.l     d1,_dsp_avail_pmem

               lea.l      _dsp_subs,a0
               move.w     _dsp_free_subridx,d2
               muls.w     #12,d2
               adda.l     d2,a0         ;Adresse der Struktur

               addq.l     #1,d1
               move.l     d1,(a0)       ;Adresse
               move.l     d7,4(a0)      ;size
               move.w     d6,$a(a0)     ;Ability

               lea.l      _dsp_subr_adr,a0
               moveq.l    #-$17,d2
               add.w      8(a0),d2      ;Handle
               muls.w     #6,d2         ;6 Byte pro Eintrag
               move.w     d1,4(a0,d2.w) ;3-Byte-Adresse eintragen - Annahme: High-Byte ist null

lblE05F3A:     
               move.b     #$95,dsp_cmdvec         ;Handshake, Hostvektor 21
lblE05F40:     
               btst.b     #7,dsp_cmdvec
               bne.s      lblE05F40

               moveq.l    #0,d0
               move.b     d0,dsp_high
               move.b     d0,dsp_mid
               move.b     #$2e,dsp_low

               move.b     d0,dsp_high
               move.b     d0,dsp_mid
               move.b     #16,dsp_low   ;16 DSP-Worte senden

               moveq.l    #15,d0
; a0 zeigt noch auf _dsp_subr_adr, Tabelle mit Opcodes und Subr-Adr. an DSP Åbertragen
lblE05F74:     
               move.b     (a0)+,dsp_high
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               dbf        d0,lblE05F74

lblE05F2A:     
               move.b     #$95,dsp_cmdvec         ;Handshake, Hostvektor 21
lblE05F30:     
               btst.b     #7,dsp_cmdvec
               bne.s      lblE05F30

               move.w     _dsp_free_subridx,d0
               muls.w     #12,d0
               lea.l      _dsp_subs,a0
               adda.l     d0,a0
               move.l     4(a0),(sp)    ;size
               move.l     (a0),-(sp)    ;Adr
               move.b     1(sp),dsp_high          ;Adresse in DSP schreiben
               move.b     2(sp),dsp_mid
               move.b     3(sp),dsp_low

               move.b     5(sp),dsp_high          ;Grîûe
               move.b     6(sp),dsp_mid
               move.b     7(sp),dsp_low

               move.l     d7,d0         ;size_in
;Register a1 enthÑlt bereits den Zeiger auf die Subroutine
               bsr        tmt_to_DSP

               move.w     _dsp_free_subridx,d6
               addq.w     #1,_dsp_free_subridx
               cmpi.w     #8,_dsp_free_subridx
               blt.s      lblE05834

               clr.w      _dsp_free_subridx
lblE05834:     
               muls.w     #12,d6
               lea.l      _dsp_subs,a0
               move.w     8(a0,d6.l),d0 ;Handle der Subroutine
exit_LdSub:    
               movem.l    (sp)+,d5-d7
               rts        

;
;Xbios 117
;
;int     Dsp_InqSubrAbility(int ability);
;Liefert das Handle oder 0 zurÅck
;
Dsp_InqSubrAbility:       
;lblE06094:
               move.w     (a0),d1       ;ability
               lea.l      _dsp_subs,a0
               moveq.l    #$16,d0       ;$17 ist das erste Handle fÅr eine Subroutine
lblE060A0:     
               addq.w     #1,d0         ;Handle
               cmp.w      10(a0),d1     ;== Handle der Subroutine?
               beq        lblE060BA     ;dann raus

               lea.l      12(a0),a0
               cmpi.w     #$1e,d0       ;max. 30 ist das Handle
               bne.s      lblE060A0
               moveq.l    #0,d0
lblE060BA:     
               rts        

;
;Xbios 118
;
;int     Dsp_RunSubroutine(int handle);
;0: ok, -1: Subroutine konnte nicht ausgefÅhrt werden
;
;Diese Funktion setzt voraus, daû die gesuchte Subroutine bereits geladen ist
;
Dsp_RunSubroutine:        
;lblE05F86:
               move.w     (a0),d0       ;handle
               move.w     d0,d1
               cmpi.b     #$17,d0       ;ungÅltiges Handle?
               blt        lblE05FCC

               cmpi.b     #$1e,d0       ;ungÅltiges Handle?
               bgt        lblE05FCC

               subi.w     #$17,d1
               muls.w     #6,d1         ;6 Byte pro Eintrag
               addq.w     #3,d1         ;erstes DSP-Wort Åberspringen
               lea.l      _dsp_subr_adr,a0
               adda.w     d1,a0
               move.b     (a0)+,dsp_high
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               ori.b      #$80,d0
               move.b     d0,dsp_cmdvec
               moveq.l    #0,d0
               rts        

lblE05FCC:     
               moveq.l    #-1,d0
               rts        

;
;Xbios 119
;int     Dsp_Hf0(int flag);
;
Dsp_Hf0:       
;lblE060E0:
               move.w     (a0),d1       ;flag
               cmpi.w     #$ffff,d1
               beq        lblE06110     ;Erfragen des Wertes
               cmpi.w     #1,d1
               bne        lblE060FE
               bset.b     #3,dsp_irctrl
               rts        

lblE060FE:     
               cmpi.w     #0,d1
               bne        lblE06122
               bclr.b     #3,dsp_irctrl
               rts        

lblE06110:     
               moveq.l    #0,d0
               btst.b     #3,dsp_irctrl
               beq        lblE06122
               moveq.l    #1,d0
lblE06122:     
               rts        

;
;Xbios 120
;int     Dsp_Hf1(int flag);
;
Dsp_Hf1:       
;lblE06124:
               move.w     (a0),d1       ;flag
               cmpi.w     #$ffff,d1
               beq        lblE06154

               cmpi.w     #1,d1
               bne        lblE06142
               bset.b     #4,dsp_irctrl
               rts        

lblE06142:     
               cmpi.w     #0,d1
               bne        lblE06166
               bclr.b     #4,dsp_irctrl
               rts        

lblE06154:     
               moveq.l    #0,d0
               btst.b     #4,dsp_irctrl
               beq        lblE06166
               moveq.l    #1,d0
lblE06166:     
               rts        

;
;Xbios 121
;int     Dsp_Hf2(int flag);
;
Dsp_Hf2:       
;lblE06168:
               moveq.l    #0,d0
               btst.b     #DSP_HF2,dsp_irstat
               beq        lblE0617A
               moveq.l    #1,d0
lblE0617A:     
               rts        

;
;Xbios 122
;int     Dsp_Hf3(int flag);
;
Dsp_Hf3:       
;lblE0617C:
               moveq.l    #0,d0
               btst.b     #DSP_HF3,dsp_irstat
               beq        lblE0618E
               moveq.l    #1,d0
lblE0618E:     
               rts        

;
;Xbios 123
;
;void    Dsp_BlkWords(int *data_in,long size_in,int *data_out,long size_out);
;
Dsp_BlkWords:  
;lblE051A0:
               movea.l    (a0)+,a1      ;*data_in
               move.l     (a0)+,d0      ;size_in
               beq        lblE051CC
               subq.w     #1,d0
lblE051B8:     
               btst.b     #TXDE,dsp_irstat        ;Senderegister leer?
               beq.s      lblE051B8

lblE051C0:     
               move.w     (a1)+,d2
               ext.l      d2
               move.l     a6,-(sp)
               lea.l      dspvlong,a6
               move.l     d2,(a6)
               move.b     (a6)+,dsp_longwd
               move.b     (a6)+,dsp_high
               move.b     (a6)+,dsp_mid
               move.b     (a6)+,dsp_low
               movea.l    (sp)+,a6
               dbf        d0,lblE051C0

lblE051CC:     
               movea.l    (a0)+,a1      ;*data_out
               move.l     (a0),d0       ;size_out
               beq        lblE051E8
               subq.w     #1,d0
lblE051D4:     
               btst.b     #RXDF,dsp_irstat        ;Empfangsregister gefÅllt?
               beq.s      lblE051D4
lblE051DC:     
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d0,lblE051DC
lblE051E8:     
               rts        

;
;Xbios 124
;
;void    Dps_BlkBytes(long *data_in,long size_in,long *data_out,long size_out);
;
Dsp_BlkBytes:  
;lblE051EA:
               movea.l    (a0)+,a1      ;*data_in
               move.l     (a0)+,d0      ;size_in
               beq        lblE0521E
               subq.w     #1,d0
lblE05202:     
               btst.b     #TXDE,dsp_irstat
               beq.s      lblE05202

lblE0520A:     
               move.b     #0,dsp_high
               move.b     #0,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d0,lblE0520A

lblE0521E:     
               movea.l    (a0)+,a1      ;*data_out
               move.l     (a0),d0       ;size_out
               beq        lblE0523A
               subq.w     #1,d0
lblE05226:     
               btst.b     #RXDF,dsp_irstat
               beq.s      lblE05226

lblE0522E:     
               move.b     dsp_mid,d1
               move.b     dsp_low,(a1)+
               dbf        d0,lblE0522E

lblE0523A:     
               rts        

;
;Xbios 125
;char    Dsp_HStat();
;
Dsp_HStat:     
;lblE06190:
               move.b     dsp_irstat,d0
               move.b     dsp_cmdvec,d1
               rts        

;
;Xbios 126
;void    Dsp_SetVectors(void (*receiver)(),long (*transmitter)() );
;
Dsp_SetVectors:           
;lblE0546C:
               clr.l      _dsp_rcv_ptr
               clr.l      _dsp_tmt_ptr
               move.l     (a0)+,d0      ;*receiver
               beq        lblE054A2
               move.l     d0,_dsp_rcv_ptr
               move.l     #DSP_TRM_RCV_IR,_int_dsp
               move.b     #$ff,dsp_irvec
               ori.b      #1,dsp_irctrl ;Enable RXDF Request

lblE054A2:     
               move.l     (a0),d0       ;*transmitter
               beq        lblE054C4
               move.l     d0,_dsp_tmt_ptr
               move.l     #DSP_TRM_RCV_IR,_int_dsp
               move.b     #$ff,dsp_irvec
               ori.b      #2,dsp_irctrl ;Enable TXDE Request
lblE054C4:     
               rts        

;
;DSP-Interrupt-Routine
;
DSP_TRM_RCV_IR:           
;lblE054C6:
               movem.l    d0-d2/a0-a2,-(sp)
               btst.b     #RXDF,dsp_irstat
               beq        lblE054F8
               move.l     _dsp_rcv_ptr,d0
               beq        lblE054F8
               movea.l    d0,a0
               moveq.l    #0,d0
               move.b     dsp_high,d0
               rol.l      #8,d0
               move.b     dsp_mid,d0
               rol.l      #8,d0
               move.b     dsp_low,d0
               move.l     d0,-(sp)
               jsr        (a0)
               addq.l     #4,sp

lblE054F8:     
               btst.b     #TXDE,dsp_irstat        ;DSP bereit Sendedaten anzunehmen?
               beq        lblE05528
               move.l     _dsp_tmt_ptr,d0
               beq        lblE05528     ;keine Senderoutine installiert
               movea.l    d0,a0
               jsr        (a0)
               tst.l      d0
               beq        lblE05528     ;falls != 0L, dann Daten zum DSP schicken
               swap.w     d0
               move.b     d0,dsp_high
               rol.l      #8,d0
               move.b     d0,dsp_mid
               rol.l      #8,d0
               move.b     d0,dsp_low
lblE05528:     
               movem.l    (sp)+,d0-d2/a0-a2
               rte        

;
;Xbios 127
;void    Dsp_MultBlocks(long numsend,long numreceive,DSPBLOCK *sendblocks,DSPBLOCK *receiveblocks);
;
Dsp_MultBlocks:           
;lblE0552E:
               move.l     (a0),d0       ;numsend
               beq        no_sendblks
lblE05536:     
               btst.b     #TXDE,dsp_irstat
               beq.s      lblE05536
               movea.l    8(a0),a2      ;sendblocks
               subq.w     #1,d0

nxt_sendblk:   
               move.w     (a2)+,d1      ;blocktype
               move.l     (a2)+,d2      ;blocksize
               subq.l     #1,d2
               movea.l    (a2)+,a1      ;blockaddr
               tst.w      d1            ;blocktype == LONG?
               beq        lblE05570
               subq.w     #1,d1         ;WORD?
               beq        lblE0557E
               subq.w     #1,d1         ;UBYTE?
               beq        lblE05590
               bra        no_sendblks

lblE05570:     
               move.b     (a1)+,dsp_longwd
               move.b     (a1)+,dsp_high
               move.b     (a1)+,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d2,lblE05570
               dbf        d0,nxt_sendblk
               bra        no_sendblks

lblE0557E:     
               move.w     (a1)+,d1
               ext.l      d1
               move.l     a6,-(sp)
               lea.l      dspvlong,a6
               move.l     d1,(a6)
               move.b     (a6)+,dsp_longwd
               move.b     (a6)+,dsp_high
               move.b     (a6)+,dsp_mid
               move.b     (a6)+,dsp_low
               movea.l    (sp)+,a6
               dbf        d2,lblE0557E
               dbf        d0,nxt_sendblk
               bra        no_sendblks

lblE05590:     
               move.b     #0,dsp_high
               move.b     #0,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d2,lblE05590
               dbf        d0,nxt_sendblk

no_sendblks:   
               move.l     4(a0),d0      ;num_receive
               beq        lblE05622
lblE055B4:     
               btst.b     #RXDF,dsp_irstat
               beq.s      lblE055B4
               movea.l    12(a0),a0     ;receive_blocks[]
               subq.w     #1,d0

nxt_rcvblk:    
               move.w     (a0)+,d1      ;blocktype
               move.l     (a0)+,d2      ;blocksize
               subq.l     #1,d2
               movea.l    (a0)+,a1      ;blockaddr
               tst.w      d1            ;LONG?
               beq        lblE055EE
               subq.w     #1,d1         ;WORD?
               beq        lblE055FC
               subq.w     #1,d1         ;UBYTE?
               beq        lblE0560E
               bra        lblE05622     ;raus

lblE055EE:     
               move.b     dsp_longwd,(a1)+
               move.b     dsp_high,(a1)+
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d2,lblE055EE
               dbf        d0,nxt_rcvblk
               rts        

lblE055FC:     
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d2,lblE055FC
               dbf        d0,nxt_rcvblk
               rts        

lblE0560E:     
               move.b     dsp_mid,d1
               move.b     dsp_low,(a1)+
               dbf        d2,lblE0560E
               dbf        d0,nxt_rcvblk

lblE05622:     
               rts        

; DSP2----------------------DSP-Supportroutinen-------------------
;
;LÑnge der LOD-Datei Åber Fseek ermitteln (keine DTA notwendig),
;Puffer allozieren und Datei laden
;
;Eingaben
;        a0:     Zeiger auf Dateiname
;
;Ausgabe
;        d0:     Pufferadr oder 0L
;        a0:     LOD-Endadresse
;
read_LODfile:  
               movem.l    d5-d7,-(sp)   ;sichern

               clr.w      -(sp)         ;READ_ONLY
               move.l     a0,-(sp)      ;Zeiger auf den Dateinamen
               move.w     #$3d,-(sp)    ;Fopen
               trap       #GEMDOS
               addq.l     #8,sp
               move.l     d0,d7         ;handle
               bpl.s      get_LOD_len   ;Datei vorhanden
               moveq.l    #0,d0         ;Fehler aufgetreten
               bra.s      exit_read_LODfile

get_LOD_len:   
               move.w     #2,-(sp)      ;ans Dateiende
               move.w     d7,-(sp)      ;handle
               clr.l      -(sp)         ;offset
               move.w     #$42,-(sp)    ;Fseek
               trap       #GEMDOS
               lea.l      10(sp),sp
               move.l     d0,d6         ;DateilÑnge
               bgt.s      seek_LOD_start          ;Datei > 0 Bytes
               moveq.l    #0,d0         ;Fehler aufgetreten
               bra.s      exit_read_LODfile

seek_LOD_start:           
               clr.w      -(sp)         ;an Dateianfang
               move.w     d7,-(sp)      ;handle
               clr.l      -(sp)         ;offset
               move.w     #$42,-(sp)    ;Fseek
               trap       #GEMDOS
               lea.l      10(sp),sp

               move.l     d6,-(sp)      ;DateilÑnge
               move.w     #$48,-(sp)    ;Malloc
               trap       #GEMDOS
               addq.l     #6,sp
               move.l     d0,d5         ;Pufferadresse
               bne.s      _read_LOD
               moveq.l    #0,d0         ;Fehler aufgetreten
               bra.s      exit_read_LODfile

_read_LOD:     
               move.l     d5,-(sp)      ;Puffer
               move.l     d6,-(sp)      ;count
               move.w     d7,-(sp)      ;handle
               move.w     #$3f,-(sp)    ;Fread
               trap       #GEMDOS
               lea.l      12(sp),sp
               cmp.l      d0,d6         ;alle Bytes gelesen?
               beq.s      _close_LOD
               moveq.l    #0,d0         ;Fehler aufgetreten
               bra.s      exit_read_LODfile

_close_LOD:    
               move.w     d7,-(sp)      ;handle
               move.w     #$3e,-(sp)    ;Fclose
               trap       #GEMDOS
               addq.l     #4,sp

               movea.l    d5,a0         ;Pufferadr
               adda.l     d6,a0         ;Puffer + LÑnge = _dsp_LOD_endadr

               move.l     d5,d0         ;Pufferadr != 0: alles ok
exit_read_LODfile:        
               movem.l    (sp)+,d5-d7   ;Register zurÅck
               rts        

;
;LOD-Datei in BinÑrformat konvertieren
;
;Eingaben
;        a0: *LOD-Datei ,aktuelle Dateiposition
;        a1: *codeptr
;        a2: Endadr. des LOD-Files
;
;Ausgabe
;        d0:     _dsp_bin_len
;
conv_LOD_to_bin:          
               move.l     a1,-(sp)      ;_dsp_bin_ptr
               clr.l      -(sp)         ;_dsp_bin_len
               bra.s      lblE05D18

lblE05D02:     
               subq.w     #1,d0         ;Index aus cmp_keyw: SchlÅsselwort 1, DATA?
               bne.s      lblE05D14     ;nein -> Åberspringe Zeile, suche nach SchlÅsselwort ...
               addq.l     #4,a0         ;LÑnge von 'DATA' auf akt. Dateipos.
               move.l     (sp),d0       ;bin_len
               movea.l    4(sp),a1      ;bin_ptr
               bsr        conv_DATA_args          ;wandle Daten hinter DATA-Token, neue Dateiposition in a0
               move.l     d0,(sp)       ;aktuelle LÑnge der DSP-BinÑrdaten
               bra.s      lblE05D20     ;vergleiche mit SchlÅsselworten

lblE05D14:     
               movea.l    a2,a1         ;_dsp_LOD_endadr
               bsr        skip_line     ;Zeilenden ermitteln und Zeile Åberspringen -> neue Pos in a0
lblE05D18:     
               cmpi.b     #'_',(a0)
               bne.s      lblE05D14     ;kein Unterstrich -> nÑchste Zeile
               addq.l     #1,a0         ;aktuelle Dateipos. auf nÑchstes Zeichen

lblE05D20:     
               move.l     a0,-(sp)      ;akt. Dateiposition sichern
               bsr        cmp_keyw      ;Vergleich mit den SchlÅsselworten, aktuelle Dateiposition unverÑndert!
               movea.l    (sp)+,a0
               cmpi.w     #5,d0         ;SchlÅsselwort 5, END?
               bne.s      lblE05D02     ;nein, dann weiter suchen

               move.l     (sp)+,d0      ;_dsp_bin_len
               addq.l     #4,sp
               rts        

;
;Vergleiche ab aktueller Dateiposition mit SchlÅsselwîrtern
;
;Eingabe
;        a0:     Zeiger auf aktuelle Dateiposition
;
;Ausgabe
;        d0: Index (0-5) oder 6 (Fehler)
;zerstîrt a0-a1/d1-d2
;
cmp_keyw:      
               movem.l    d3/a3-a5,-(sp)
               movea.l    a0,a3         ;Zeiger auf aktuelle Dateiposition
               moveq.l    #0,d3
               lea.l      token_adr,a5  ;Tabelle mit Zeigern auf SchlÅsselworte
               lea.l      token_len,a4  ;Tabelle mit LÑngen der SchlÅsselworte
               bra.s      chk_keyw_index

lblE05988:     
               move.w     (a4)+,d0      ;LÑnge des Strings ohne Nullbyte
               movea.l    (a5)+,a1      ;Zeiger auf den String
               movea.l    a3,a0         ;Zeiger auf die aktuelle Zeilenposition
               bsr        strn_cmp      ;vergleiche Zeichen der angegebenen LÑnge
               tst.w      d0            ;Strings gleich?
               bne.s      lblE059AA     ;ja -> raus mit Index in d7 (->d0)

               addq.w     #1,d3         ;Index erhîhen
chk_keyw_index:           
               cmpi.w     #6,d3         ;Index > 5?
               blt.s      lblE05988
lblE059AA:     
               move.l     d3,d0         ;Index des SchlÅsselworts
               movem.l    (sp)+,d3/a3-a5
               rts        

;
;Vergleiche ab aktueller Dateiposition mit SchlÅsselwort der angegebenen LÑnge
;
;Eingaben
;        a0:     Zeiger auf aktuelle Dateiposition
;        a1:     Zeiger auf SchlÅsselwort
;        d0:     LÑnge des SchlÅsselworts (W)
;
;Ausgabe
;        d0: 0 falls Strings unterschiedlich, 1 falls identisch
;zerstîrt a0-a1/d1-d2
;
strn_cmp:      
               bra.s      lblE05940

lblE05926:     
               move.b     (a0)+,d2
               move.b     (a1)+,d1
               cmp.b      d1,d2         ;gleiches Zeichen?
               beq.s      lblE05940
               addi.b     #$20,d1
               cmp.b      d1,d2         ;Zeichen evtl. klein?
               beq.s      lblE05940

               moveq.l    #0,d0         ;unterschiedlicher String
               rts        

lblE05940:     
               subq.w     #1,d0         ;LÑnge dec.
               bpl.s      lblE05926     ;noch nicht alle Zeichen verglichen ...
               moveq.l    #1,d0         ;Strings identisch
               rts        

;
; Suche Zeilenende und Åberspringe diese Zeile
;
;Eingabe
;        a0:     aktuelle Zeilenposition
;        a1:     Endadr. der LOD-Datei
;Ausgabe
;        a0:     neue Dateiposition
;zerstîrt a1
;
skip_line:     
tst_CR:        
               cmpi.b     #13,(a0)+     ;Zeilenende?
               beq.s      tst_endadr
               cmpa.l     a1,a0
               bls.s      tst_CR

tst_endadr:    
               cmpa.l     a1,a0         ;bereits am Dateiende?
               bhi.s      exit_skip_line          ;ja
               addq.l     #1,a0         ;CR/LF Åberspringen
exit_skip_line:           
               rts        

;
;LOD-File: DATA-Instruktion bearbeiten
;                          Speicherbereich erkennen und 4-stellige ASCII-Zahl konvertieren
;
;Eingabe
;        a0:     Zeiger auf Zeichen P/X/Y hinter 'DATA'
;        a1:     Zeiger auf Anfang der DSP-BinÑrdaten
;        a2:     Endadr. des LOD-Files
;        d0:     LÑnge der DSP-BinÑrdaten
;Ausgabe
;        a0:     aktuelle Dateiposition
;        d0:     LÑnge der BinÑrdaten
conv_DATA_args:           
               movem.l    d3-d5/a3,-(sp)
               movea.l    a1,a3
               move.l     d0,d3

_chk_spaces:   
               cmpi.b     #32,(a0)+     ;Leerzeichen?
               beq.s      _chk_spaces   ;Leerzeichen Åberspringen

               move.b     -1(a0),d0     ;Zeichen

               movea.l    a3,a1
               adda.l     d3,a1         ;aktuelle Position
               clr.b      (a1)+
               clr.b      (a1)+

               cmpi.b     #'P',d0       ;Programm-Data?
               bne.s      lblE05ADC

               clr.b      (a1)+
               bra.s      lblE05AFA

lblE05ADC:     
               cmpi.b     #'X',d0       ;X-Mem-Data?
               bne.s      lblE05AEE
               move.b     #1,(a1)+
               bra.s      lblE05AFA

lblE05AEE:     
               move.b     #2,(a1)+      ;dann "muû" es Y-Mem-Data sein ...

lblE05AFA:     

               moveq.l    #4,d0         ;4-stellige ASCII-Zahl ab Dateipos. konvertieren
               addq.l     #1,a0         ;hinter P/X/Y muû ein Leerzeichen stehen, dann die ASCII-Zahl
               bsr        cnv_asci_hex  ;-> Zahl in d0, akt. Pos in a0, a1 unverÑndert!

               clr.b      (a1)+         ;Hi-Byte lîschen
               move.b     d0,1(a1)      ;Lo-Byte eintragen
               asr.w      #8,d0
               move.b     d0,(a1)       ;Mid-Byte eintragen

               addq.l     #6,d3         ;_dsp_bin_len
               move.l     d3,d4         ;Offset zu _dsp_bin_ptr
               clr.w      d5            ;Anzahl der gefunden 6-stelligen Zahlen
               addq.l     #3,d3

               movea.l    a2,a1         ;Endadr. des LOD-Files
               bsr        skip_line     ;aktuelle Dateiposition in a0
               bra.s      lblE05CA0     ;'DATA P/X/Y' konvertieren und zum Anfang der nÑchsten Zeile

lblE05C8A:     
               cmpi.b     #13,(a0)      ;CR?
               bne.s      lblE05C00     ;nein, Leerzeichen Åberspringen, Zahlen konvertieren

               movea.l    a2,a1         ;Endadr. des LOD-Files
               bsr        skip_line
               bra.s      lblE05CA0

lblE05C00:     
               cmpi.b     #32,(a0)+     ;Leerzeichen?
               beq.s      lblE05C00     ;Leerzeichen Åberspringen
               subq.l     #1,a0

               cmpi.b     #13,(a0)      ;CR?
               beq.s      lblE05CA0     ;Zeilenende erreicht

               moveq.l    #6,d0         ;6-stellige ASCII-Zahl in BinÑrdarstellung wandeln
               bsr        cnv_asci_hex  ;-> konvertierte Zahl in d0

               movea.l    a3,a1         ;_dsp_bin_ptr
               addq.l     #3,d3         ;_dsp_bin_len um hinzukommende Bytes erhîhen
               adda.l     d3,a1         ;mit Lo-Byte beginnend eintragen
               move.b     d0,-(a1)      ;Lo-Byte
               lsr.l      #8,d0
               move.b     d0,-(a1)      ;Mid-Byte
               lsr.l      #8,d0
               move.b     d0,-(a1)      ;Hi-Byte
               addq.w     #1,d5         ;Anzahl der eingetragenen 6-stelligen DATA-Werte

lblE05C1C:     
               cmpi.b     #13,(a0)
               bne.s      lblE05C00     ;Zeilenende noch nicht erreicht

lblE05CA0:     
               cmpi.b     #'_',(a0)     ;Unterstrich?
               bne        lblE05C8A     ;kein Unterstrich gefunden

               addq.l     #1,a0         ;nÑchstes Zeichen

               movea.l    a3,a1         ;_dsp_bin_ptr
               adda.l     d4,a1         ;Offset zum Beginn der BinÑrdaten, Anzahld der DATA-Werte eintragen
               clr.b      (a1)+         ;Hi-Byte lîschen
               move.b     d5,1(a1)      ;Lo-Byte eintragen
               lsr.w      #8,d5
               move.b     d5,(a1)       ;Mid-Byte eintragen

               move.l     d3,d0         ;_dsp_bin_len zurÅckliefern
               movem.l    (sp)+,d3-d5/a3
               rts        

;
;Konvertiere Hex-ASCII-Zahl mit 1-8 Ziffern in BinÑrdarstellung
;
;Eingaben
;        a0:     Zeiger auf ASCII-Zahl
;        d0:     Anzahl der Ziffern
;
;Ausgaben
;        d0:     gewandelte Zahl in BinÑrdarstellung
;        a0:     zeigt hinter ASCII-Zahl
;zerstîrt d1-d2
;
cnv_asci_hex:  
               moveq.l    #0,d1         ;lîschen
               bra        cnv_dbra

cnv_loop:      
               lsl.l      #4,d1         ;Platz fÅr die nÑchste Ziffer

               moveq.l    #-'0',d2      ;'0'
               add.b      (a0)+,d2      ;ASCII-Zeichen
               cmpi.b     #'9'-'0',d2   ;Ziffer von '0' bis '9'?
               bls.s      ins_digit

               subi.b     #'A'-'0',d2
               cmpi.b     #'F'-'A',d2   ;Ziffer von 'A' bis 'F'?
               bls.s      ins_cipher

               subi.b     #'a'-'A',d2
               cmpi.b     #'f'-'a',d2   ;Ziffer von 'a' bis 'f'?
               bhi.s      cnv_dbra

ins_cipher:    
               addi.b     #10,d2        ;10 addieren fÅr Bereich a bis f

ins_digit:     
               add.b      d2,d1         ;Ziffer hinzufÅgen

cnv_dbra:      
               dbra       d0,cnv_loop

               move.l     d1,d0         ;der gewandelte BinÑrwert ...
               rts        

;-----------------------------------------
               .EVEN 
tok_strt:      .DC.b 'START',0
tok_data:      .DC.b 'DATA',0
tok_blkdata:   .DC.b 'BLOCKDATA',0
tok_symb:      .DC.b 'SYMBOL',0
tok_comment:   .DC.b 'COMMENT',0
tok_end:       .DC.b 'END',0

               .EVEN 
token_adr:     
;lblE48EE2:
               .DC.l tok_strt
               .DC.l tok_data
               .DC.l tok_blkdata
               .DC.l tok_symb
               .DC.l tok_comment
               .DC.l tok_end

token_len:     
;lblE48EFA:
               .DC.w 5,4,9,6,7,3        ;LÑnge der SchlÅsselworte


               .EVEN 

lblE48B24:                ;246 Bytes = 82 DSP-Worte
               .DC.l $af08000,$400000,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l $bf08000,$7f000bf0,$80007eef
               .DC.l $bf08000,$7edc0bf0,$80007f00
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l $8f4a800,$408f4,$bf000c00
               .DC.l $feb808,$f4a00000,$108f4be
               .DC.l $60,$f400007e,$a9319800
               .DC.l $6d10000,$500aa9,$8000004e
               .DC.l $8586b0c
               .DC.w $5108

               .EVEN 

lblE48C1A:                ;152 DSP-Worte = 456 Bytes
               .DC.l $8f4a000,$108f4,$be000000
               .DC.l $aa98000,$7ead2000,$13084c2b
               .DC.l $45f40000,$32000,$650ea000
               .DC.l $aa98000,$7eb50850,$2b0aa980
lblE48C4A:     
               .DC.l $7eb808,$512b45f4,1
               .DC.l $2000650a,$f0aa007e,$ce45f400
               .DC.w 0
lblE48C64:     
               .DC.l $2200065,$af0aa00,$7ed50af0
               .DC.l $80007ec7,$6d10000,$7ecb0aa9
               .DC.l $80007ec9,$8586b0a,$f080007e
               .DC.l $ad06d100
               .DC.w $7e
lblE48C8E:     
               .DC.l $d20aa980,$7ed008,$58ab0af0
               .DC.l $80007ead,$6d10000,$7ed90aa9
               .DC.l $80007ed7,$858eb0a,$f080007e
               .DC.l $ad08f4a0,$108,$f4be0000
               .DC.l $aa980,$7ee008,$502b0aa9
               .DC.l $80007ee3,$8512b0a,$a980007e
               .DC.l $e608522b,$6d20000,$7eec07d0
               .DC.l $8c07518c,0,$408f4
               .DC.l $a0000001,$8f4be00,$aa9
               .DC.l $80007ef3,$8502b0a,$a980007e
               .DC.l $f608512b,$6d10000,$7efd0aa9
               .DC.l $80007efb,$8586b00
lblE48D1A:     
               .DC.l 0,$408f4a0,$108
               .DC.l $f4be0000,$aa980,$7f0420
               .DC.l $13084c,$2b45f400,$120
               .DC.l $650af0,$aa007f23,$45f40000
               .DC.l $22000,$650af0aa,$7f320a
               .DC.l $f080007f
lblE48D5A:     
               .DC.l $140aa980,$7f1408,$502b0aa9
               .DC.l $80007f17,$8512b06,$d100007f
               .DC.l $2007d88c,$aa98100,$7f1d5470
               .DC.l $ffeb,0,$40aa9
               .DC.l $80007f23,$8502b0a,$a980007f
               .DC.l $2608512b,$6d10000,$7f2f54d8
               .DC.l $aa981,$7f2c54,$700000ff
               .DC.l $eb000000,$40a,$a980007f
               .DC.l $3208502b,$aa98000,$7f350851
               .DC.l $2b06d100,$7f3e5c,$d8000aa9
               .DC.l $81007f3b,$54700000,$ffeb0000
               .DC.l 4


lblE48DE2:                ;213 Bytes = 71 DSP-Worte
               .DC.l $af08000,$400000,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l $8f4a800,$408f4,$bf000c00
               .DC.l $feb80a,$f080007e
               .DC.b $a9


               .EVEN 

lblE48F06:                ;72 Bytes = 24 DSP-Worte
               .DC.l 0,$2a0000,$140bf080
               .DC.l $7eef0b,$f080007e,$dc0bf080
               .DC.l $7f000b,$f0800000,$bf080
               .DC.l $b,$f0800000,$bf080
               .DC.l $b,$f0800000,$bf080
               .DC.l $b,$f0800000,3

; DSP3----------------------DSP-BOOT-Routine-------------------

;INIT-Routine fÅr die DSP-Routinen
dsp_stdinit:   
;lblE05624:
               lea.l      _dsp_codebuf,a0
               lea.l      lblE48F06,a1  ;DSP-Code der internen dspexec-Routine
               moveq.l    #71,d0        ;3*24 Bytes = 24 DSP-Worte in Puffer schreiben
lblE061AA:     
               move.b     (a1)+,(a0)+
               dbf        d0,lblE061AA

               moveq.l    #$17,d0
               lea.l      _dsp_subs,a0  ;Array mit SUBS-Strukturen
               bra.s      lblE05650

lblE0563A:     
               clr.l      (a0)          ;Adresse
               clr.w      10(a0)        ;Ability
               move.w     d0,8(a0)      ;Handle?
               addq.w     #1,d0
               lea.l      12(a0),a0     ;12 Bytes pro Eintrag

lblE05650:                ;Ende des Arrays mit Subroutine-EintrÑgen erreicht?
               cmpa.l     #_dsp_subs+sizeof_subs,a0
               bcs.s      lblE0563A

               move.l     #$7ea8,d0
               move.l     d0,_dsp_max_avail_mem
               move.l     d0,_dsp_avail_pmem
               clr.l      _dsp_xreserve
               clr.w      _dsp_ability
               clr.w      _dsp_free_subridx
               move.w     #$8000,_dsp_uniqueability

               moveq.l    #82,d0        ;codesize (DSP-Wîrter)
               lea.l      lblE48B24,a0  ;*codeptr
               bsr        _Dsp_ExecBoot

               move.w     #152,d0       ;size_in
               lea.l      lblE48C1A,a1  ;*data_in
               bsr        tmt_to_DSP
               rts        
; ----------------------XBIOS-Routinen-------------------

makecjar:      movea.l    cjar,a1
               lea.l      newcjar,a0
               cmpi.l     #0,d0
               beq.s      mknocopy
               add.l      d0,d0
               cmpi.l     #90,d0
               bgt.s      mkcerr
               subq.l     #1,d0
mkcjar2:       move.l     (a1)+,(a0)+
               dbra       d0,mkcjar2
mknocopy:      move.l     #0,(a0)+
               move.l     #51,(a0)+
               lea.l      newcjar,a1
               move.l     a1,d0
               move.l     d0,cjar
               clr.l      d0
               rts        
mkcerr:        move.l     #-1,d0
               rts        

ncookies:      lea.l      ncooksnd,a4
               move.l     #$1f,(a4)
               lea.l      ncookmch,a4
               move.l     #$30000,(a4)
               lea.l      ncookcpu,a4
               move.l     #$1e,(a4)
               lea.l      ncookvdo,a4
               move.l     #$30000,(a4)
               lea.l      ncookfpu,a4
               move.l     #0,(a4)
               rts        

ocookies:      lea.l      cooksnd,a3
               lea.l      ncooksnd,a4
               move.l     (a3),(a4)
               lea.l      cookmch,a3
               lea.l      ncookmch,a4
               move.l     (a3),(a4)
               lea.l      cookcpu,a3
               lea.l      ncookcpu,a4
               move.l     (a3),(a4)
               lea.l      cookvdo,a3
               lea.l      ncookvdo,a4
               move.l     (a3),(a4)
               lea.l      cookfpu,a3
               lea.l      ncookfpu,a4
               move.l     (a3),(a4)
               rts        

cookie:        tst.l      cjar
               beq        ncookt5
               movea.l    cjar,a1
ncookt1:       move.l     (a1)+,d1
               move.l     (a1)+,d2
               tst.l      d1
               beq        ncookt5
               cmpi.l     #"_SND",d1
               bne.s      ncookt1b
               lea.l      ncooksnd,a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1b:      cmpi.l     #"_MCH",d1
               bne.s      ncookt1c
               lea.l      ncookmch,a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1c:      cmpi.l     #"_CPU",d1
               bne.s      ncookt1d
               lea.l      ncookcpu,a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1d:      cmpi.l     #"_VDO",d1
               bne.s      ncookt1e
               lea.l      ncookvdo,a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1e:      cmpi.l     #"_FPU",d1
               bne.s      ncookt1f
               lea.l      ncookfpu,a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1f:      bra        ncookt1
ncookt5:       rts        


memplay:       movea.l    (a0)+,a3      ; von
               move.l     (a0)+,d1      ; bis
               move.w     (a0)+,d4      ; Anzahl der For/Backstep
               cmpi.w     #0,d4
               blt        memperrs
               move.l     a3,d0
               sub.l      d1,d0
               cmpi.l     #0,d0
               beq        memperrs
               ble.s      mpneg8
               moveq.l    #0,d2
               addq.l     #1,d4
               sub.l      d4,d2
               move.l     d2,d4
               add.l      d4,d4
               add.l      d4,d4
               addi.l     #-4,d4
               bra.s      mpplus
mpneg8:        add.l      d4,d4
               add.l      d4,d4
mpplus:        move.w     (a0)+,d3      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi)
               btst       #2,d3
               beq.s      nomidip
               move.w     (a0)+,d0      ; midi
nomidip:       move.l     #lfifo,d2     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               asr.w      #3,d2
               subq.l     #1,d2
               lea.l      vmestart,a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread a5,A1=1
               lea.l      midisuch,a2
               move.w     d0,(a2)
               lea.l      midiw,a2
               move.l     #0,(a2)
               moveq.l    #0,d6         ; LoopzÑhler
               moveq.l    #8,d5
panf:          bsr        play
               tst.w      d0
               bne.s      pweg
pcrostst:      btst       #1,d3
               beq.s      plooptst
               addq.l     #8,d4
               neg.l      d4
               move.l     d1,d0
               subq.l     #4,d0
               move.l     a3,d1
               addq.l     #4,d1
               movea.l    d0,a3
               bsr        play
               tst.w      d0
               bne.s      pweg
               neg.l      d4
               subq.l     #8,d4
               move.l     d1,d0
               subq.l     #4,d0
               move.l     a3,d1
               addq.l     #4,d1
               movea.l    d0,a3
plooptst:      btst       #0,d3
               beq.s      pweg
               bra.s      panf
pweg:          lea.l      playbyte,a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,4(a4)      ; Returnwert Anzahl loops speichern
               move.l     a4,d0
               rts        
play:          movea.l    a3,a2
pfill:         move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      pcopyanf
               bsr        pbrktst
               tst.w      d0
               bne.s      playex
               bra.s      pfill
pcopyanf:      move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
pcopy:         cmpi.w     #0,d4
               blt.s      pcopyneg
               cmpa.l     d1,a2
               bge.s      playend
pcopy2:        move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               cmpa.l     d1,a2
               bge.s      playend
               adda.l     d4,a2
               dbra       d0,pcopy2
               bra.s      pcopytst
pcopyneg:      cmpa.l     d1,a2
               ble.s      playend
pcopyn2:       move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               cmpa.l     d1,a2
               ble.s      playend
               adda.l     d4,a2
               dbra       d0,pcopyn2
pcopytst:      bsr        pbrktst
               tst.w      d0
               bne.s      playex
               btst       #2,d3
               beq.s      pfill
               bsr        pmidi
               tst.w      d0
               bne.s      playex
               bra.s      pfill
playend:       clr.l      d0
               addq.l     #1,d6
playex:        rts        
memperrs:      move.l     (a0)+,d3
               btst       #2,d3
               beq.s      mempers2
               move.l     (a0)+,d0      ; midi
mempers2:      move.l     #-1,d0
               rts        
pmidi:         movem.l    d1-d7/a0-a4,-(sp)
               lea.l      midisuch,a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      pnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw,a0
               btst       #7,d0
               beq.s      pmidi2        ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      pnomidi
pmidi2:        cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      pmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      pnomidi
pmidi3:        move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      pmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      pmidi6
pmidi3b:       move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      pnomidi
pmidi4:        cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      pmidi3        ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      pnomidi
pmidi5:        cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      pmidi3b       ; wenn nein, Datenwort lîschen
               bra.s      pmidiex       ; Abbruch, da NOTE OFF !
pmidi6:        cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      pmidi3b       ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      pmidi3b       ; wenn nein, Datenwort lîschen
               bra.s      pmidiex       ; Abbruch, da NOTE ON und Velo=Null !
pnomidi:       move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               clr.l      d0
               rts        
pmidiex:       move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #-1,d0
               rts        
pbrktst:       movem.l    d1-d7/a0-a4,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a4
               rts        

memrec:        lea.l      firstbuf,a1
               tst.w      (a1)
               bne.s      memre2
               move.w     #1,(a1)
               bsr        killbuf
memre2:        movea.l    (a0)+,a2      ; von
               move.l     (a0)+,d1      ; bis
               lea.l      hireg,a1
               moveq.l    #0,d2
               move.b     (a1),d2       ; Inhalt REGH
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               movea.l    d0,a4         ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart,a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
;               bsr        recreset
               moveq.l    #8,d2
               moveq.l    #2,d3
ranf:          moveq.l    #8,d0
ranf2:         move.w     (a1),d5       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d5
               beq.s      ranf3         ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d4
               beq.s      ranf3         ; fehlerhafte Daten ?
               bra.s      ranf4
ranf3:         dbra       d0,ranf2      ; 8x versuchen zu synchronisieren
               bsr        rbrktst       ; dann abbruch testen
               tst.w      d0
               bne.s      rweg
               bra.s      ranf          ; wiederholen bis synchronisiert
ranf4:         move.b     $20(a0),d0    ; Flag lesen
               and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      rcopy         ; wenn ja, daten einlesen
               bsr        rbrktst       ; dann abbruch testen
               tst.w      d0
               bne.s      rweg
               bra.s      ranf4
rcopy:         move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
rcopy2:        move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      rcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      rcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      rcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      rcopy3        ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      rweg
rcopy3:        dbra       d0,rcopy2
               bsr        rbrktst       ; abbruch testen
               tst.w      d0
               bne.s      rweg
               bra.s      ranf4
rweg:          move.l     a2,d0
               rts        
rbrktst:       movem.l    d1-d7/a0-a4,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a4
               rts        

recplay:       rts        
hrecplay:      rts        

hardplay:      movea.l    (a0)+,a3      ; adr
               movea.l    (a0)+,a5      ; len
               move.l     (a0)+,d2      ; sectors
               movea.l    (a0)+,a6      ; seekbyte
               move.w     (a0)+,d7      ; handle
               clr.l      d5
               move.w     (a0)+,d5      ; Anzahl der For/Backstep
               move.w     (a0)+,d3      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               btst       #2,d3
               beq.s      nohmidip
               move.w     (a0)+,d0      ; midi
nohmidip:      cmpi.w     #0,d7
               beq        hperrs
               blt        hperrs
               cmpa.l     #0,a6
               blt        hperrs
               cmpi.l     #0,d2
               beq        hperrs
               blt        hperrs
               move.l     #lfifo,d4
               asr.w      #3,d4
               subq.l     #1,d4         ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart(pc),a4
               movea.l    (a4),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               cmpi.w     #0,d5
               blt        hperrs
               cmpa.l     #0,a5
               beq        hperrs
               bgt.s      hpneg8
               move.l     a5,d1
               neg.l      d1
               movea.l    d1,a5
               moveq.l    #0,d1
               addq.l     #1,d5
               sub.l      d5,d1
               move.l     d1,d5
               add.l      d5,d5
               add.l      d5,d5
               addi.l     #-4,d5
               bra.s      hpplus
hpneg8:        add.l      d5,d5
               add.l      d5,d5
hpplus:        lea.l      midisuch,a2
               move.w     d0,(a2)
               lea.l      midiw,a2
               move.l     #0,(a2)
               tst.l      d5
               bmi.s      backset
               move.l     a3,d1         ; MEMende
               add.l      a5,d1
               bra.s      hanf0
backset:       move.l     a3,d1
               subq.l     #4,d1
               adda.l     a5,a3
               subq.l     #4,a3
hanf0:         lea.l      playbyte,a4
               move.l     #0,8(a4)      ; Anzahl loops lîschen
               move.l     #0,4(a4)      ; Anzahl sektoren lîschen
               move.l     #0,(a4)       ; playbyte lîschen
hanf:          movem.l    d1-d7/a0-a6,-(sp)
               move.w     #0,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a6,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               bsr        hplay
               tst.w      d0
               bne.s      hweg
hcrostst:      btst       #1,d3
               beq.s      hlooptst
               addq.l     #8,d5
               neg.l      d5
               move.l     d1,d0
               subq.l     #4,d0
               move.l     a3,d1
               addq.l     #4,d1
               movea.l    d0,a3
               bsr        hplay
               tst.w      d0
               bne.s      hweg
               neg.l      d5
               subq.l     #8,d5
               move.l     d1,d0
               subq.l     #4,d0
               move.l     a3,d1
               addq.l     #4,d1
               movea.l    d0,a3
hlooptst:      btst       #0,d3
               beq.s      hweg
               bra.s      hanf
hweg:          lea.l      playbyte,a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,4(a4)      ; Returnwert Anzahl loops speichern
               move.l     a4,d0
               rts        
hplay:         moveq.l    #0,d6
hplay2:        addq.l     #1,d6
               movea.l    a3,a2
               movem.l    d1-d7/a0-a6,-(sp)
               tst.l      d5
               bmi.s      fseek
               bra.s      fread
fseek:         move.w     #1,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a5,d0
               add.l      d0,d0
               neg.l      d0
               move.l     d0,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
fread:         move.l     a3,d0
               tst.l      d5
               bpl.s      readpos
               move.l     d1,d0
               addq.l     #4,d0
readpos:       move.l     d0,-(sp)      ; Fread
               move.l     a5,-(sp)
               move.w     d7,-(sp)
               move.w     #63,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
hfill:         move.b     (a0),d0       ; FIFO halbleer ?
               btst       #1,d0
               bne.s      copyanf
               btst       #3,d3         ; mehr Abbruchabfragen ?
               beq.s      tstrest
               btst       #2,d3
               beq.s      tstrest
               bsr        hmidi
               tst.w      d0
               bne        hplayex
tstrest:       tst.l      d5
               bmi.s      tstmin
               move.l     d1,d0
               sub.l      a2,d0
               bra.s      tstrest2
tstmin:        move.l     a2,d0
               sub.l      d1,d0
tstrest2:      asr.l      #2,d0
               cmp.w      d4,d0
               bgt.s      hfill
restplay:      move.w     d4,-(sp)
               movea.l    a1,a4
               addq.l     #2,a4         ; Playread a4,A1=1
               moveq.l    #4,d4
rest2:         move.b     (a0),d0
               and.b      d4,d0
               beq.s      rest2
               move.b     (a2)+,(a4)    ; Linker Kanal,HighByte senden,A1=1
rest3:         move.b     (a0),d0
               and.b      d4,d0
               beq.s      rest3
               move.b     (a2)+,(a4)    ; Linker Kanal,LowByte senden,A1=1
rest4:         move.b     (a0),d0
               and.b      d4,d0
               beq.s      rest4
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
rest5:         move.b     (a0),d0
               and.b      d4,d0
               beq.s      rest5
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               adda.l     d5,a2
               cmpa.l     d1,a2
               beq.s      bufend
               bra.s      rest2
copyanf:       move.w     d4,d0         ; ...dann FIFO halb-fuellen (fifolen)!
               move.w     d4,-(sp)
               movea.l    a1,a4
               addq.l     #2,a4         ; Playread a4,A1=1
copy:          move.b     (a2)+,(a4)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a4)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
faster:        adda.l     d5,a2
               cmpi.l     #0,d5
               blt.s      hfneg
               cmpa.l     d1,a2
               bge.s      bufend
               bra.s      hfplus
hfneg:         cmpa.l     d1,a2
               ble.s      bufend
hfplus:        dbra       d0,copy
               move.w     (sp)+,d4
               bsr        brktst
               tst.w      d0
               bne.s      hplayex
               btst       #2,d3
               beq        hfill
               bsr        hmidi
               tst.w      d0
               bne.s      hplayex
               bra        hfill
bufend:        move.w     (sp)+,d4
               cmp.l      d2,d6
               beq.s      hplayend
               bsr        brktst
               tst.w      d0
               bne.s      hplayex
               btst       #2,d3
               beq        hplay2
               bsr        hmidi
               tst.w      d0
               bne.s      hplayex
               bra        hplay2
hplayend:      moveq.l    #0,d0
               lea.l      playbyte,a4
               addi.l     #1,8(a4)
hplayex:       rts        
hmidi:         movem.l    d1-d7/a0-a6,-(sp)
               lea.l      midisuch,a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      hnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw,a0
               btst       #7,d0
               beq.s      hmidi2        ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      hnomidi
hmidi2:        cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      hmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      hnomidi
hmidi3:        move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      hmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      hmidi6
hmidi3b:       move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      hnomidi
hmidi4:        cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      hmidi3        ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      hnomidi
hmidi5:        cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      hmidi3b       ; wenn nein, Datenwort lîschen
               bra.s      hmidiex       ; Abbruch, da NOTE OFF !
hmidi6:        cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      hmidi3b       ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      hmidi3b       ; wenn nein, Datenwort lîschen
               bra.s      hmidiex       ; Abbruch, da NOTE ON und Velo=Null !
hnomidi:       move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a6
               moveq.l    #0,d0
               rts        
hmidiex:       move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a6
               moveq.l    #1,d0
               rts        
brktst:        movem.l    d1-d7/a0-a6,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a6
               rts        
hperrs:        move.l     #-1,d0
               rts        

hardrec:       lea.l      firstbuf,a1
               tst.w      (a1)
               bne.s      hardre2
               move.w     #1,(a1)
               bsr        killbuf
hardre2:       movea.l    (a0)+,a3      ; start
               movea.l    (a0)+,a5      ; len
               cmpa.l     #0,a5
               beq        hnerr
               blt        hnerr
               move.l     (a0)+,d2      ; sectors
               lea.l      sectors,a6
               move.l     d2,(a6)
               cmpi.l     #0,d2
               beq        hnerr
               blt        hnerr
               movea.w    (a0)+,a6      ; handle
               cmpa.w     #0,a6
               beq        hnerr
               blt        hnerr
               lea.l      vmestart(pc),a4
               movea.l    (a4),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatxH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               movea.l    d0,a4         ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               move.l     d2,-(sp)      ; sectors
               move.l     a3,d1
               add.l      a5,d1         ; Endadr
               moveq.l    #8,d2
               moveq.l    #2,d3
hnanf:         moveq.l    #8,d0
hnanf2:        move.w     (a1),d5       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d5
               beq.s      hnanf3        ; fehlerhafte Daten ?
               move.w     (a1),d5       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d5
               beq.s      hnanf3        ; fehlerhafte Daten ?
               bra.s      hnholanf
hnanf3:        dbra       d0,hnanf2     ; 8x versuchen zu synchronisieren
               bsr        hnbrktst      ; dann abbruch testen
               tst.w      d0
               bne        hnweg
               bra.s      hnanf         ; wiederholen bis synchronisiert
hnholanf:      movea.l    a3,a2
hnanf4:        bsr        hnbrktst      ; dann abbruch testen
               tst.w      d0
               bne        hnweg
               move.l     d1,d0
               sub.l      a2,d0
               asr.l      #2,d0
               cmp.w      a4,d0         ; Rest kleiner als halber FIFO ?
               ble.s      hnctrl1       ; dann Rest holen und abspeichern
               move.b     (a0),d0       ; Flag lesen
               and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      hncopy        ; wenn ja, daten schnell einlesen
               bra.s      hnanf4
hncopy:        move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
hncopy2:       move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      hncopy3       ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      hncopy3       ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      hncopy3       ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      hncopy3       ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               cmpa.l     d1,a2         ; sektorbuffer voll ?
               beq.s      hnsave
hncopy3:       dbra       d0,hncopy2
               bra.s      hnanf4

hnctrl1:       move.b     (a0),d0       ; Daten gÅltig ?
               andi.b     #1,d0
               beq.s      hnctrl1
               move.w     (a1),d0       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d0
               beq.s      hnctrl1       ; fehlerhafte Daten ?
               move.b     d0,(a2)+
hnctrl2:       move.b     (a0),d0       ; Daten gÅltig ?
               andi.b     #1,d0
               beq.s      hnctrl2
               move.w     (a1),d0       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d0
               beq.s      hnctrl2       ; fehlerhafte Daten ?
               move.b     d0,(a2)+
hnctrl3:       move.b     (a0),d0       ; Daten gÅltig ?
               andi.b     #1,d0
               beq.s      hnctrl3
               move.w     (a1),d0       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d0
               bne.s      hnctrl3       ; fehlerhafte Daten ?
               move.b     d0,(a2)+
hnctrl4:       move.b     (a0),d0       ; Daten gÅltig ?
               andi.b     #1,d0
               beq.s      hnctrl4
               move.w     (a1),d0       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d0
               bne.s      hnctrl4       ; fehlerhafte Daten ?
               move.b     d0,(a2)+
               cmpa.l     d1,a2
               bne.s      hnctrl1
hnsave:        movem.l    d1-d7/a0-a6,-(sp)
               move.l     a3,-(sp)      ; Fwrite
               move.l     a5,-(sp)
               move.w     a6,-(sp)
               move.w     #64,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               bmi.s      hnweg
               cmpa.l     d0,a5
               bne.s      hnweg
               move.l     (sp)+,d0
               subq.l     #1,d0
               move.l     d0,-(sp)
               tst.l      d0            ; alle Sektoren geschrieben ?
               beq.s      hnweg
               bra        hnholanf
hnweg:         lea.l      sectors,a6
               move.l     (a6),d0
               move.l     (sp)+,d2      ; restliche sektoren
               sub.l      d2,d0         ; anzahl komplett geschriebener sektoren
               rts        
hnbrktst:      movem.l    d1-d7/a0-a6,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a6
               rts        
hnerr:         move.l     #-1,d0
               rts        

monitor:       move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               movea.l    d0,a4         ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0
               adda.l     #$ff,a1
               movea.l    a1,a2
               addq.l     #1,a2         ; Playread a2,A1=0
               movea.l    a2,a3
               addq.l     #2,a3         ; Playread a3,A1=1
               moveq.l    #8,d2
fifowait:      move.b     (a0),d0       ; PLAY-FIFO halbleer ?
               andi.b     #2,d0
               bne.s      mcopy         ; wenn ja, halben RECFIFO in PLAYFIFO kopieren
               bsr        mbrktst       ; dann abbruch testen
               tst.w      d0
               bne.s      mweg
               bra.s      fifowait
mcopy:         move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
mcopy2:        move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      mcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      mcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      mcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloscht ?)...
               btst       d2,d4
               bne.s      mcopy3        ; fehlerhafte Daten ?
               move.b     d7,(a3)       ; Linker Kanal,Highbyte senden,A1=1
               move.b     d6,(a3)       ; Linker Kanal,Lowbyte senden,A1=1
               move.b     d5,(a2)       ; Rechter Kanal,Highbyte senden,A1=0
               move.b     d4,(a2)       ; Rechter Kanal,Lowbyte senden,A1=0
mcopy3:        dbra       d0,mcopy2
               bsr        mbrktst       ; abbruch testen
               tst.w      d0
               bne.s      mweg
               bra.s      fifowait
mweg:          clr.l      d0
               rts        
mbrktst:       movem.l    d1-d7/a0-a4,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a4
               rts        

recwait:       move.w     (a0)+,d7      ; treshold
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0
               adda.l     #$ff,a1       ; REC-Read im Wordmode
rwanf1:        move.b     (a0),d0       ; Flag lesen
               btst       #1,d0         ; FIFO mehr als halbvoll ?
               beq.s      rwanf2        ; wenn ja, daten einlesen
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #11,-(sp)
               trap       #1
               addq.l     #2,sp
               movem.l    (sp)+,d1-d7/a0-a6
               tst.l      d0
               bne        rwweg
               bra.s      rwanf1
rwanf2:        moveq.l    #8,d6
               moveq.l    #$ff,d5
               moveq.l    #0,d4
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #11,-(sp)
               trap       #1
               addq.l     #2,sp
               movem.l    (sp)+,d1-d7/a0-a6
               tst.l      d0
               bne.s      rwweg
rwanf4:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf4
               move.w     (a1),d1       ; wenn 0, weiter
               btst       d6,d1
               bne.s      rwanf4
               and.w      d5,d1
               asl.w      d6,d1
rwanf5:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf5
               move.w     (a1),d2       ; wenn 0, weiter
               btst       d6,d2
               bne.s      rwanf4
               and.w      d5,d2
               add.w      d2,d1
rwanf6:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf6
               move.w     (a1),d2       ; wenn 1, weiter
               btst       d6,d2
               beq.s      rwanf4
               and.w      d5,d2
               asl.w      d6,d2
rwanf7:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf7
               move.w     (a1),d3       ; wenn 1, weiter
               btst       d6,d3
               beq.s      rwanf4
               and.w      d5,d3
               add.w      d3,d2
               btst       #15,d1        ; Oberstes Bit da ?
               beq.s      rweiter1      ; dann negieren
               not.w      d1
rweiter1:      btst       #15,d2
               beq.s      rweiter2
               not.w      d2
rweiter2:      cmp.w      d7,d1         ; treshold vergleichen
               bgt.s      rwweg
               cmp.w      d7,d2
               bgt.s      rwweg
               move.b     (a0),d0       ; Flag lesen
               btst       #1,d0         ; FIFO mehr als halbvoll ?
               beq        rwanf4        ; wenn ja, daten einlesen
               bra        rwanf1
rwweg:         clr.l      d0
               rts        


; ---------------------------Anfang der Interrupt-Treiber-----------------------

ihandler_play: movem.l    d0-d7/a0-a6,-(sp)
               lea.l      pimode(pc),a2
               move.l     (a2),d0
               cmpi.l     #27,d0
               beq        scrubbing
               move.l     (a2),d0
               cmpi.l     #28,d0
               beq        adcemu8
               cmpi.l     #21,d0
               beq        xmemplay16
               cmpi.l     #25,d0
               beq        falcplay8
               cmpi.l     #8,d0
               beq        implaymix
               cmpi.l     #3,d0
               beq        ihardplay
               cmpi.l     #1,d0
               beq        imemplay
               cmpi.l     #9,d0
               beq        xmemplay
               cmpi.l     #22,d0
               beq        xmemplay
               cmpi.l     #11,d0
               beq        falcplay
               cmpi.l     #17,d0
               beq        xmemplay8
               cmpi.l     #19,d0
               beq        imemp24
               bra        playdummy
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

ihandler_dsp:  movem.l    d0-d7/a0-a6,-(sp)
               lea.l      drimode(pc),a2
               move.l     (a2),d0
               cmpi.l     #23,d0
               beq        tdsphbr
               cmpi.l     #14,d0
               beq        dsprecord
               cmpi.l     #16,d0
               beq        dsphbr
               lea.l      dpimode(pc),a2
               move.l     (a2),d0
               cmpi.l     #22,d0
               beq        dsphbp
               cmpi.l     #13,d0
               beq        dspplay
               cmpi.l     #15,d0
               beq        dsphbp
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

ihandler_pci:  movem.l    d0-d7/a0-a6,-(sp)
               lea.l      pcimode(pc),a2
               move.l     (a2),d0
               cmpi.l     #1,d0
               beq        sendpci
               cmpi.l     #2,d0
               beq        xmemplay8
               cmpi.l     #3,d0
               beq        xmemplay16
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

ihandler_rec:  movem.l    d0-d7/a0-a6,-(sp)
               lea.l      rimode(pc),a2
               move.l     (a2),d0
               cmpi.l     #26,d0
               beq        falcrec8
               cmpi.l     #23,d0
               beq        txmemrec
               cmpi.l     #24,d0
               beq        cblread
               cmpi.l     #7,d0
               beq        hrecpeak
               cmpi.l     #4,d0
               beq        ihardrec
               cmpi.l     #6,d0
               beq        mrecpeak
               cmpi.l     #2,d0
               beq        imemrec
               cmpi.l     #5,d0
               beq        ipeak
               cmpi.l     #10,d0
               beq        xmemrec
               cmpi.l     #20,d0
               beq        xmemrec8
               cmpi.l     #12,d0
               beq        falcrec
               cmpi.l     #18,d0
               beq        imemr24
               bra        recdummy
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_imemplay: move.w     (a0)+,d0      ; Auswahl
               cmpi.w     #0,d0
               beq.s      aimemplay
               cmpi.w     #1,d0
               beq        aidspplay
               cmpi.w     #2,d0
               beq        aimemplay24
aimemplay:     lea.l      von,a2
               move.l     (a0)+,d2      ; von a3
               move.l     d2,(a2)       ; von a3
               lea.l      bvon,a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      bis,a2
               move.l     (a0)+,d3      ; bis d1
               move.l     d3,(a2)       ; bis d1
               lea.l      bbis,a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      playbyte,a4   ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp,a2
               move.l     d0,(a2)
               clr.l      d4
               move.w     (a0)+,d4      ; Anzahl der For/Backstep d4
               lea.l      mode,a2
               move.w     (a0)+,d0
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      imnmidi
               lea.l      midisuch,a2
               move.w     (a0)+,(a2)    ; midi d0
imnmidi:       lea.l      step,a2
               cmpi.w     #0,d4
               blt        imemperrs
               move.l     d2,d0
               sub.l      d3,d0
               cmpi.l     #0,d0
               beq        imemperrs
               ble.s      impneg8
               moveq.l    #0,d2
               addq.l     #1,d4
               sub.l      d4,d2
               move.l     d2,d4
               add.l      d4,d4
               add.l      d4,d4
               addi.l     #-4,d4
               bra.s      impplus
impneg8:       add.l      d4,d4
               add.l      d4,d4
impplus:       move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo,a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw,a2
               move.l     #0,(a2)
               lea.l      loop,a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag,a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      playbyte,a4   ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; mempos lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      pimode,a2
               move.l     #1,(a2)
               move.l     a4,d0
               rts        
imemperrs:     move.l     #-1,d0
               rts        

imemplay:      lea.l      von,a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis,a2
               move.l     (a2),d1       ; bis d1
               lea.l      step,a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode,a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo,a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch,a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart,a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte,a6   ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq.s      ip_back
ipfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrleer
               move.l     strtp(pc),d0
               cmp.l      24(a6),d0
               beq.s      nowrleer
               addi.l     #1,12(a6)     ;Fehler +1
nowrleer:      move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      ipcopyanf
               bra.s      ipfill
ipcopyanf:     cmpi.l     #0,d4
               blt.s      ipcopyneg
               cmpa.l     d1,a2
               bge.s      iplayend
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopy:        move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               bge.s      iplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,ipcopy
               bra.s      ip_back
ipcopyneg:     cmpa.l     d1,a2
               ble.s      iplayend
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopy2:       move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               ble.s      iplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,ipcopy2
ip_back:       lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ip_back2:      lea.l      playbyte,a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplayend:      moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte,a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      loop,a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von,a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #1,d3         ; crossplay ?
               beq        iplooptst     ; wenn nein, ueberspringen
               lea.l      crosflag,a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      baktofor
fortobak:      addq.l     #8,d4
               neg.l      d4
               lea.l      step,a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von,a4
               move.l     d1,(a4)       ; neue Endposition
               lea.l      bvon,a4
               move.l     (a4),d1
               addq.l     #4,d1
               lea.l      bis,a4
               move.l     d1,(a4)       ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra.s      ip_back2
baktofor:      neg.l      d4
               subq.l     #8,d4
               lea.l      step,a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von,a4
               move.l     d1,(a4)       ; neue Anfangsposition
               lea.l      bbis,a4
               lea.l      bis,a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        ip_back2
iendplay:      lea.l      playbyte,a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplooptst:     btst       #0,d3
               beq.s      iendplay
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        ip_back2
ipmidi:        movem.l    d1-d7/a0-a4,-(sp)
               lea.l      midisuch,a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      ipnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw,a0
               btst       #7,d0
               beq.s      ipmidi2       ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      ipnomidi
ipmidi2:       cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      ipmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      ipnomidi
ipmidi3:       move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      ipmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      ipmidi6
ipmidi3b:      move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      ipnomidi
ipmidi4:       cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      ipmidi3       ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      ipnomidi
ipmidi5:       cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      ipmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      ipmidiex      ; Abbruch, da NOTE OFF !
ipmidi6:       cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      ipmidi3b      ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      ipmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      ipmidiex      ; Abbruch, da NOTE ON und Velo=Null !
ipnomidi:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #0,d0
               rts        
ipmidiex:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #1,d0
               rts        

init_imemrec:  move.w     (a0)+,d0      ; Auswahl
               cmpi.w     #0,d0
               beq.s      aimemrec
               cmpi.w     #2,d0
               beq        aimemrec24
aimemrec:      lea.l      rvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
;               bsr        recreset
               lea.l      recbyte,a4    ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; mempos lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      firstbuf,a6
               move.w     #0,(a6)       ; erster buffer - dann lîschen
               lea.l      rimode,a2
               move.l     #2,(a2)
               move.l     a4,d0
               rts        

killbuf:       lea.l      cadr,a6
               movea.l    (a6),a1       ; Startadresse fifo
               movea.l    4(a6),a2      ; Startadresse recstat
killbu2:       move.w     (a1),d1
               btst       #0,(a2)
               bne.s      killbu2
               rts        

imemrec:       lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      imemre2
               move.w     #1,(a1)
               bsr        killbuf
fbexit:        movem.l    (sp)+,d0-d7/a0-a6
               rte        
imemre2:       lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
iranf:         move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      nordfull
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      nordfull
               addi.l     #1,12(a5)     ;Fehler +1
nordfull:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ircopy        ; wenn ja, daten einlesen
               bra.s      iranf
ircopy:        move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ircopy2:       move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ircopy3       ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               addq.l     #4,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      irweg
ircopy3:       dbra       d0,ircopy2
ir_back:       lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
ir_back2:      move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
irweg:         move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

posmake:       lea.l      von(pc),a2
               lea.l      pos(pc),a3
               move.l     (a2),(a3)
               lea.l      step(pc),a2
               move.l     (a2),d5       ; Anzahl der For/Backstep d5
               tst.l      d5
               bpl.s      ibpset
               lea.l      von(pc),a2
               movea.l    (a2),a3       ; adr a3
               lea.l      len(pc),a2
               movea.l    (a2),a5       ; len a5
               adda.l     a5,a3
               subq.l     #4,a3
               lea.l      pos(pc),a2
               move.l     a3,(a2)       ;aktuelle position setzen (fÅr backplay)
ibpset:        move.w     #1,load       ; daten laden
               rts        

init_hplay:    lea.l      von(pc),a2
               move.l     (a0)+,(a2)    ; adr a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      len(pc),a2
               move.l     (a0)+,(a2)    ; len a5
               lea.l      sectnr(pc),a2
               move.l     (a0)+,(a2)    ; sectors d2
               lea.l      bsectnr(pc),a3
               move.l     (a2),(a3)     ; sectors d2 retten fÅr crossplay und loop
               lea.l      seeknr(pc),a2
               movea.l    (a0)+,a6      ; seekbyte a6
               move.l     a6,(a2)
               lea.l      handle(pc),a2
               move.w     (a0)+,d7      ; handle d7
               move.w     d7,(a2)
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d5
               move.w     d0,(a2)       ; Anzahl der For/Backstep d5
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; d3 mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               move.w     d0,(a2)       ; d3 mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               btst       #2,d0
               beq.s      ihplay2
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
ihplay2:       lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d4
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #0,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a6,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,28(a4)     ; Anzahl loops lîschen
               move.l     #0,4(a4)      ; Anzahl sektoren lîschen
               move.l     #0,(a4)       ; playbyte lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               bsr        posmake
               lea.l      pimode(pc),a2
               move.l     #3,(a2)
               move.l     a4,d0
               rts        

ihardplay:     lea.l      von(pc),a2
               movea.l    (a2),a3       ; adr a3
               lea.l      len(pc),a2
               movea.l    (a2),a5       ; len a5
               lea.l      handle(pc),a2
               move.w     (a2),d7       ; handle d7
               lea.l      seeknr(pc),a2
               movea.l    (a2),a6       ; seekbyte a6
               lea.l      sectnr(pc),a2
               move.l     (a2),d2       ; sectors d2
               lea.l      step(pc),a2
               clr.l      d5
               move.w     (a2),d5       ; Anzahl der For/Backstep d5
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               lea.l      fifo(pc),a2
               move.l     (a2),d4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d4
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a4
               addq.l     #2,a4         ; Playread a4, A1=1
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               tst.l      d5
               bmi.s      ibackset
               move.l     a3,d1         ; MEMende
               add.l      a5,d1
               bra.s      ihplay
ibackset:      move.l     a3,d1
               subq.l     #4,d1
               adda.l     a5,a3
               subq.l     #4,a3
ihplay:        lea.l      pos(pc),a2
               movea.l    (a2),a2       ;aktuelle position holen
               cmpi.w     #1,load
               bne.s      ihfill
               movem.l    d1-d7/a0-a6,-(sp)
               subi.l     #amount,savptr
               tst.l      d5
               bmi.s      ifseek
               bra.s      ifread
ifseek:        move.w     #1,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a5,d0
               add.l      d0,d0
               neg.l      d0
               move.l     d0,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
ifread:        move.l     a3,d0
               tst.l      d5
               bpl.s      ireadpos
               move.l     d1,d0
               addq.l     #4,d0
ireadpos:      move.l     d0,-(sp)      ; Fread
               move.l     a5,-(sp)
               move.w     d7,-(sp)
               move.w     #63,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               addi.l     #amount,savptr
               movem.l    (sp)+,d1-d7/a0-a6
               move.w     #0,load       ; Daten sind geladen
ihfill:        move.b     (a0),d0       ; PLAY-FIFO leer ?
               btst       #0,d0
               bne.s      nowrler2
               move.l     a3,rett
               lea.l      playbyte(pc),a3         ; RÅckgabewerte-Liste
               cmpi.l     #0,(a3)       ; mempos abfragen
               beq.s      nowrler2a
               addi.l     #1,12(a3)     ;Fehler +1
nowrler2a:     movea.l    rett,a3
nowrler2:      move.b     (a0),d0       ; PLAY-FIFO halbleer ?
               btst       #1,d0
               bne.s      icopyanf
itstrest:      bra.s      ihfill
icopyanf:      move.w     fileart(pc),d0
               cmpi.w     #3,d0
               bne.s      normcopy
               move.w     d4,d0         ; ...dann FIFO halb-fuellen (fifolen)!
icwav:         move.b     1(a2),(a4)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2),(a4)     ; Linker Kanal,LowByte senden,A1=1
               addq.l     #2,a2
               move.b     1(a2),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2),(a1)     ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #2,a2
               adda.l     d5,a2
               cmpa.l     d1,a2         ; puffer voll ?
               beq.s      ihplayend
               dbra       d0,icwav      ; fifo-Schleife
               bra.s      normcopy2
normcopy:      move.w     d4,d0         ; ...dann FIFO halb-fuellen (fifolen)!
icopy:         move.b     (a2)+,(a4)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a4)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
ifaster:       adda.l     d5,a2
               cmpa.l     d1,a2         ; puffer voll ?
               beq.s      ihplayend
               dbra       d0,icopy      ; fifo-Schleife
normcopy2:     lea.l      pos(pc),a0
               move.l     a2,(a0)       ; position retten
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihplayend:     lea.l      sectnr(pc),a1
               move.l     (a1),d2
               subq.l     #1,d2
               move.l     d2,(a1)
               cmpi.l     #0,d2
               bne        ihpnoall
ihpall:        lea.l      playbyte(pc),a4
               addi.l     #1,4(a4)      ; ein sektor dazu
               addi.l     #1,28(a4)     ; ein loop dazu
ihcrostst:     btst       #1,d3
               beq.s      ihpltst
               lea.l      crosflag(pc),a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      ihpbtof
ihpftob:       move.b     #1,(a5)       ; backcross
               addq.l     #8,d5
               neg.l      d5
               lea.l      step(pc),a1
               move.l     d5,(a1)       ; Anzahl der For/Backstep d5
               move.l     d1,d0
               subq.l     #4,d0
               lea.l      von(pc),a1
               move.l     d0,(a1)       ; adr a3
               lea.l      sectnr(pc),a1
               lea.l      bsectnr(pc),a0
               move.l     (a0),(a1)
               bra.s      ihpnoall
ihpbtof:       move.b     #0,(a5)       ; forcross
               neg.l      d5
               subq.l     #8,d5
               lea.l      step(pc),a1
               move.l     d5,(a1)       ; Anzahl der For/Backstep d5
               move.l     d1,d0
               subq.l     #4,d0
               lea.l      von(pc),a1
               move.l     d0,(a1)       ; adr a3
ihpltst:       btst       #0,d3         ; loop ?
               beq.s      ihpnoc
               lea.l      sectnr(pc),a1
               lea.l      bsectnr(pc),a0
               move.l     (a0),(a1)
               btst       #1,d3         ; Richtungsflag testen
               bne.s      ihpnoall
               subi.l     #amount,savptr
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #0,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a6,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               addi.l     #amount,savptr
               bra.s      ihpnoall
ihpnoc:        addi.l     #1,4(a4)      ; ein sektor dazu
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     #1,8(a4)      ; break on
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihpnoall:      bsr        posmake
               lea.l      playbyte(pc),a4
               addi.l     #1,4(a4)      ; ein sektor dazu
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihmidi:        movem.l    d1-d7/a0-a6,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      ihnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      ihmidi2       ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      ihnomidi
ihmidi2:       cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      ihmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      ihnomidi
ihmidi3:       move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      ihmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      ihmidi6
ihmidi3b:      move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      ihnomidi
ihmidi4:       cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      ihmidi3       ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      ihnomidi
ihmidi5:       cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      ihmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      ihmidiex      ; Abbruch, da NOTE OFF !
ihmidi6:       cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      ihmidi3b      ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      ihmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      ihmidiex      ; Abbruch, da NOTE ON und Velo=Null !
ihnomidi:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a6
               moveq.l    #0,d0
               rts        
ihmidiex:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a6
               moveq.l    #1,d0
               rts        

init_hrec:     lea.l      rpos(pc),a3
               lea.l      rvon(pc),a2
               move.l     (a0)+,(a3)    ; position a2
               move.l     (a3),(a2)     ; adr a3
               lea.l      rlen(pc),a2
               move.l     (a0)+,(a2)    ; len a5
               lea.l      rsectnr(pc),a2
               move.l     (a0)+,(a2)    ; sectors d2
               lea.l      rhandle(pc),a2
               move.w     (a0)+,(a2)    ; handle a6
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; a4 fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,4(a4)      ; Anzahl sektoren lîschen
               move.l     #0,(a4)       ; playbyte lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      rimode(pc),a2
               move.l     #4,(a2)
               move.l     a4,d0
               rts        

ihardrec:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      ihardre2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihardre2:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; adr a3
               lea.l      rlen(pc),a2
               movea.l    (a2),a5       ; len a5
               lea.l      rhandle(pc),a2
               movea.w    (a2),a6       ; handle a6
               lea.l      rsectnr(pc),a2
               move.l     (a2),d2       ; sectors d2
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; a4 fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               move.l     a3,d1         ; MEMende
               add.l      a5,d1
               moveq.l    #8,d2
               moveq.l    #2,d3
               lea.l      rpos(pc),a2
               movea.l    (a2),a2
ihnanf:        move.b     (a0),d0       ; Flag lesen
               btst       #2,d0         ; REC-FIFO voll ?
               bne.s      nordful2
               move.l     a3,rrett
               lea.l      recbyte(pc),a3          ; RÅckgabewerte-Liste
               cmpi.l     #0,(a3)       ; mempos abfragen
               beq.s      nodful2a
               addi.l     #1,12(a3)     ;Fehler +1
nodful2a:      movea.l    rrett,a3
nordful2:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ihncopy       ; wenn ja, daten schnell einlesen
               bra.s      ihnanf
ihncopy:       move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ihncopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     rfileart(pc),d0
               cmpi.w     #3,d0
               bne.s      normrec
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bra.s      normrec2
normrec:       move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
normrec2:      cmpa.l     d1,a2         ; sektorbuffer voll ?
               beq.s      ihnsave       ;dann speichern
ihncopy3:      dbra       d0,ihncopy2   ; fifolen-Schleife
               lea.l      rpos(pc),a3
               move.l     a2,(a3)       ; position retten
               bra.s      ihrecweg
ihnsave:       lea.l      rpos(pc),a0
               move.l     a3,(a0)       ; position zurÅcksetzen
               subi.l     #amount,savptr
               movem.l    d1-d7/a0-a6,-(sp)
               move.l     a3,-(sp)      ; Fwrite
               move.l     a5,-(sp)
               move.w     a6,-(sp)
               move.w     #64,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               addi.l     #amount,savptr
               bmi.s      ihrecend
               cmpa.l     d0,a5
               bne.s      ihrecend
               lea.l      rsectnr(pc),a0
               move.l     (a0),d2       ; sectors d2
               subq.l     #1,d2
               move.l     d2,(a0)
               tst.l      d2            ; alle Sektoren geschrieben ?
               beq.s      ihrecend
ihrecweg:      lea.l      recbyte(pc),a5
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0
               addq.l     #1,d0
               move.l     d0,4(a5)      ; Returnwert Anzahl sektoren speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihrecend:      lea.l      recbyte(pc),a5
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0
               addq.l     #1,d0
               move.l     d0,4(a5)      ; Returnwert Anzahl sektoren speichern
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        


compatible:    move.w     (a0)+,d0      ; mode
               lea.l      falcmode(pc),a6
               cmpi.w     #-1,d0
               beq        compaget
               move.w     d0,(a6)
               move.w     d0,-(sp)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      lowreg(pc),a1
               move.b     #13,(a1)
               move.b     #13,(a6)
               lea.l      asrc(pc),a6   ; analog oder digital
               move.w     #1,(a6)
               lea.l      dsrc(pc),a6   ; opto,cinch oder xlr
               move.w     #0,(a6)
               lea.l      hireg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$40(a6)
               bsr        recreset
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dmarec
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPIN-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dsprec
               move.w     d0,extrec
               move.w     d0,cardrec
               bsr        matinsel
               lea.l      aesreg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$c0(a6)
               lea.l      dsppath1(pc),a1
               move.b     #7,(a1)
               move.b     #7,$210(a6)
               lea.l      dspport(pc),a1
               move.b     #8,(a1)
               move.b     #8,$212(a6)
               lea.l      dspconv(pc),a1
               move.b     #3,(a1)
               move.b     #3,$216(a6)
               lea.l      dspport(pc),a1
               move.b     #8,(a1)
               move.b     #8,$212(a6)
               lea.l      dsppath2(pc),a1
               move.b     #5,(a1)
               move.b     #5,$214(a6)
               lea.l      dsppdat(pc),a1
               move.b     #0,(a1)
               move.b     #0,$240(a6)
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               move.b     #0,$242(a6)
               lea.l      intreg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$280(a6)
               lea.l      dintreg(pc),a1
               move.b     #0,(a1)
               lea.l      playmod(pc),a1
               move.b     #0,(a1)
               lea.l      recmod(pc),a1
               move.b     #0,(a1)
               lea.l      param(pc),a0
               move.w     #$c0,(a0)+
               move.w     #$c0,(a0)+
               lea.l      param(pc),a0
               bsr        volad
               lea.l      param(pc),a0
               bsr        volda
               move.w     (sp)+,d0
               cmpi.w     #0,d0
               bne.s      ctible
               bsr        putsysorig
               bsr        ocookies
               bsr        cookie
               bra.s      ctibleweg
ctible:        bsr        makesysbase
ctibleweg2:    bsr        ncookies
               bsr        cookie
ctibleweg:     clr.l      d0
               rts        
compaget:      clr.l      d0
               move.w     (a6),d0
               rts        

getsysbase:    movea.l    $4f2,a1
               move.l     a1,d0
               lea.l      csysadr(pc),a2
               move.l     d0,(a2)
               rts        

makesysbase:   move.w     #$7f,d0
               lea.l      csysbase(pc),a2
               lea.l      csysadr(pc),a1
               movea.l    (a1),a1
getsysb2:      move.b     (a1)+,(a2)+
               dbra       d0,getsysb2
               lea.l      csysbase(pc),a1
               move.w     #$404,2(a1)
               move.l     #$3081993,$18(a1)
               move.w     #$1a68,$1e(a1)
               lea.l      csysbase(pc),a1
               move.l     a1,d0
               move.l     d0,$4f2
               rts        

putsysorig:    lea.l      csysadr(pc),a2
               move.l     (a2),d0
               move.l     d0,$4f2
               rts        

peakread:      lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     (a4),d0
               move.l     #0,(a4)       ; RÅckgabewert lîschen
               move.l     #0,8(a4)      ; Break lîschen
               rts        

init_peak:     lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
;               bsr        recreset
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; RÅckgabewert lîschen
               move.l     #0,8(a4)      ; Break lîschen
               lea.l      rimode(pc),a2
               move.l     #5,(a2)
               move.l     a4,d0
               rts        

ipeak:         lea.l      rfifo(pc),a2
               movea.l    (a2),a3       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     (a4),d1
               moveq.l    #8,d2
               moveq.l    #2,d3
ipkanf:        move.b     (a0),d0       ; Flag lesen
               and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ipkcopy       ; wenn ja, daten einlesen
               bra.s      ipkanf
ipkcopy:       move.w     a3,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ipkcopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ipkcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ipkcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ipkcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ipkcopy3      ; fehlerhafte Daten ?
               asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               swap.w     d1
               btst       #15,d7
               beq.s      pnoneg
               not.w      d7
pnoneg:        cmp.w      d1,d7
               blt.s      pnoadd
               move.w     d7,d1
pnoadd:        swap.w     d1
               btst       #15,d5
               beq.s      pnoneg2
               not.w      d5
pnoneg2:       cmp.w      d1,d5
               blt.s      ipkcopy3
               move.w     d5,d1
ipkcopy3:      dbra       d0,ipkcopy2
               move.l     d1,(a4)
               move.l     #1,8(a4)      ; Break setzen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_mplaypeak:           rts           
init_mrppeak:  rts        

init_mrecpeak: move.w     (a0)+,d0      ; Auswahl
               cmpi.w     #0,d0
               beq.s      imrecpeak
               cmpi.w     #1,d0
               beq        idrecpeak
imrecpeak:     lea.l      rvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
;               bsr        recreset
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #6,(a2)
               move.l     a4,d0
               rts        

mrecpeak:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      mrecpea2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
mrecpea2:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               clr.l      a6            ; Peak-RÅckgabewert lîschen
               movea.l    a3,a2
               moveq.l    #2,d3
               moveq.l    #8,d2
miranf:        move.b     (a0),d0       ; Flag lesen
               btst       #2,d0         ; REC-FIFO voll ?
               bne.s      nordful3
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      nordful3
               addi.l     #1,12(a5)     ;Fehler +1
nordful3:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      mircopy       ; wenn ja, daten einlesen
               bra.s      miranf
mircopy:       move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
mircopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      mircopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      mircopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      mircopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      mircopy3      ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               move.l     d1,-(sp)
               move.l     a6,d1
               swap.w     d1
               btst       #15,d7
               beq.s      mpnoneg
               not.w      d7
mpnoneg:       cmp.w      d1,d7
               blt.s      mpnoadd
               move.w     d7,d1
mpnoadd:       swap.w     d1
               btst       #15,d5
               beq.s      mpnoneg2
               not.w      d5
mpnoneg2:      cmp.w      d1,d5
               blt.s      mircop2b
               move.w     d5,d1
mircop2b:      movea.l    d1,a6
               move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      mirweg
mircopy3:      dbra       d0,mircopy2
mir_back:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
mir_back2:     lea.l      recbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Recordbyte speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
mirweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     a6,16(a5)     ; Peak-RÅckgabewert speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_hplaypeak:           rts           
init_hrppeak:  rts        

init_hrecpeak: lea.l      rpos(pc),a3
               lea.l      rvon(pc),a2
               move.l     (a0)+,(a3)    ; position a2
               move.l     (a3),(a2)     ; adr a3
               lea.l      rlen(pc),a2
               move.l     (a0)+,(a2)    ; len a5 (pufferlÑnge)
               lea.l      rsectnr(pc),a2
               move.l     (a0)+,(a2)    ; sectors d2
               lea.l      rhandle(pc),a2
               move.w     (a0)+,(a2)    ; handle a6
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; a4 fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,4(a4)      ; Anzahl sektoren lîschen
               move.l     #0,(a4)       ; playbyte lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      rimode(pc),a2
               move.l     #7,(a2)
               move.l     a4,d0
               rts        

hrecpeak:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      hrecpea2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
hrecpea2:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; adr a3
               lea.l      rlen(pc),a2
               movea.l    (a2),a5       ; len a5
               lea.l      rhandle(pc),a2
               movea.w    (a2),a6       ; handle a6
               lea.l      rsectnr(pc),a2
               move.l     (a2),d2       ; sectors d2
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; a4 fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a2
               move.l     #0,d3         ; Peak-RÅckgabewert lîschen
               move.l     a3,d1         ; MEMende
               add.l      a5,d1
               moveq.l    #8,d2
               lea.l      rpos(pc),a2
               movea.l    (a2),a2
pihnanf:       move.b     (a0),d0       ; Flag lesen
               btst       #2,d0         ; REC-FIFO voll ?
               bne.s      nordful4
               move.l     a3,rrett
               lea.l      recbyte(pc),a3          ; RÅckgabewerte-Liste
               cmpi.l     #0,(a3)       ; mempos abfragen
               beq.s      nordful4a
               addi.l     #1,12(a3)     ;Fehler +1
nordful4a:     movea.l    rrett,a3
nordful4:      andi.b     #2,d0         ; FIFO mehr als halbvoll ?
               beq.s      pihncopy      ; wenn ja, daten schnell einlesen
               bra.s      pihnanf
pihncopy:      move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
pihncopy2:     move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      pihncopy3     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      pihncopy3     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      pihncopy3     ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      pihncopy3     ; fehlerhafte Daten ?
               move.w     rfileart(pc),d0
               cmpi.w     #3,d0
               bne.s      normprec
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bra.s      normprec2
normprec:      move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
normprec2:     asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               swap.w     d3
               btst       #15,d7
               beq.s      hpnoneg
               not.w      d7
hpnoneg:       cmp.w      d3,d7
               blt.s      hpnoadd
               move.w     d7,d3
hpnoadd:       swap.w     d3
               btst       #15,d5
               beq.s      hpnoneg2
               not.w      d5
hpnoneg2:      cmp.w      d3,d5
               blt.s      hircop2b
               move.w     d5,d3
hircop2b:      cmpa.l     d1,a2         ; sektorbuffer voll ?
               beq.s      pihnsave      ;dann speichern
pihncopy3:     dbra       d0,pihncopy2  ; fifolen-Schleife
               lea.l      rpos(pc),a3
               move.l     a2,(a3)       ; position retten
               bra.s      pihrecweg
pihnsave:      lea.l      rpos(pc),a0
               move.l     a3,(a0)       ; position zurÅcksetzen
               subi.l     #amount,savptr
               movem.l    d1-d7/a0-a6,-(sp)
               move.l     a3,-(sp)      ; Fwrite
               move.l     a5,-(sp)
               move.w     a6,-(sp)
               move.w     #64,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               addi.l     #amount,savptr
               bmi.s      pihrecend
               cmpa.l     d0,a5
               bne.s      pihrecend
               lea.l      rsectnr(pc),a0
               move.l     (a0),d2       ; sectors d2
               subq.l     #1,d2
               move.l     d2,(a0)
               tst.l      d2            ; alle Sektoren geschrieben ?
               beq.s      pihrecend
               lea.l      recbyte(pc),a5
               move.l     4(a5),d0
               addq.l     #1,d0
               move.l     d0,4(a5)      ; Returnwert Anzahl sektoren speichern
pihrecweg:     lea.l      recbyte(pc),a5
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     d3,16(a5)     ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
pihrecend:     lea.l      recbyte(pc),a5
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0
               addq.l     #1,d0
               move.l     d0,4(a5)      ; Returnwert Anzahl sektoren speichern
               move.l     #1,8(a5)      ; Break setzen
               move.l     d3,16(a5)     ; Peak-RÅckgabewert speichern
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_ihplaymix:           rts           

init_impmix:   move.w     (a0)+,d0      ; Auswahl
               cmpi.w     #0,d0
               beq.s      aimixplay
               rts        
aimixplay:     lea.l      von(pc),a2
               move.l     (a0)+,d2      ; von a3
               move.l     d2,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      bis(pc),a2
               move.l     (a0)+,d3      ; bis d1
               move.l     d3,(a2)       ; bis d1
               lea.l      bbis(pc),a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               clr.l      d4
               move.w     (a0)+,d4      ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      imixnmidi
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
imixnmidi:     lea.l      step(pc),a2
               cmpi.w     #0,d4
               blt        imemperrs
               move.l     d2,d0
               sub.l      d3,d0
               cmpi.l     #0,d0
               beq        imemperrs
               ble.s      imixpneg8
               moveq.l    #0,d2
               addq.l     #1,d4
               sub.l      d4,d2
               move.l     d2,d4
               add.l      d4,d4
               add.l      d4,d4
               addi.l     #-4,d4
               bra.s      imixpplus
imixpneg8:     add.l      d4,d4
               add.l      d4,d4
imixpplus:     move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; mempos lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      rvon(pc),a2
               move.l     (a2),d0
               lea.l      recmics(pc),a2          ; RÅckgabewerte-Liste
               subi.l     #16384,d0
               move.l     d0,(a2)
               lea.l      pimode(pc),a2
               move.l     #8,(a2)
               move.l     a4,d0
               rts        

implaymix:     clr.l      d5
               lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
               lea.l      recmics(pc),a4          ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq        xip_back
xipfill:       move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      xnowrleer
               move.l     strtp(pc),d0
               cmp.l      24(a6),d0
               beq.s      xnowrleer
               addi.l     #1,12(a6)     ;Fehler +1
xnowrleer:     move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      xipcopyanf
               bra.s      xipfill
xipcopyanf:    cmpi.l     #0,d4
               blt.s      xipcopyneg
               cmpa.l     d1,a2
               bge.s      xiplayend
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
xipcopy:       movea.l    (a4),a3
               move.w     (a2)+,d7      ; linken Kanal holen
               move.w     (a3)+,d6
               bsr        mixer
               move.w     d7,d6
               asr.w      #8,d6
               move.b     d6,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d7,(a5)       ; Linker Kanal,LowByte senden,A1=1
               move.w     (a2)+,d7      ; linken Kanal holen
               move.w     (a3)+,d6
               move.l     a3,(a4)
               bsr        mixer
               move.w     d7,d6
               asr.w      #8,d6
               move.b     d6,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d7,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               bge.s      xiplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,xipcopy
               bra.s      xip_back
xipcopyneg:    cmpa.l     d1,a2
               ble.s      xiplayend
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
xipcopy2:      move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               ble.s      xiplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,xipcopy2
xip_back:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
xip_back2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d5,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xiplayend:     moveq.l    #0,d0
               addq.l     #1,d5
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d5,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      loop(pc),a4
               move.l     d5,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #1,d3         ; crossplay ?
               beq.s      xiplooptst    ; wenn nein, ueberspringen
               lea.l      crosflag(pc),a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      xbaktofor
xfortobak:     addq.l     #8,d4
               neg.l      d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Endposition
               lea.l      bvon(pc),a4
               move.l     (a4),d1
               addq.l     #4,d1
               lea.l      bis(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra.s      xip_back2
xbaktofor:     neg.l      d4
               subq.l     #8,d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               lea.l      bbis(pc),a4
               lea.l      bis(pc),a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        xip_back2
xiendplay:     lea.l      playbyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xiplooptst:    btst       #0,d3
               beq.s      xiendplay
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        xip_back2
xipmidi:       movem.l    d1-d7/a0-a4,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      xipnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      xipmidi2      ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      xipnomidi
xipmidi2:      cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      xipmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      xipnomidi
xipmidi3:      move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      xipmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      xipmidi6
xipmidi3b:     move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      xipnomidi
xipmidi4:      cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      xipmidi3      ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      xipnomidi
xipmidi5:      cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      xipmidi3b     ; wenn nein, Datenwort lîschen
               bra.s      xipmidiex     ; Abbruch, da NOTE OFF !
xipmidi6:      cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      xipmidi3b     ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      xipmidi3b     ; wenn nein, Datenwort lîschen
               bra.s      xipmidiex     ; Abbruch, da NOTE ON und Velo=Null !
xipnomidi:     move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #0,d0
               rts        
xipmidiex:     move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #1,d0
               rts        

init_xmixplay: rts        

init_xmemplay: move.w     (a0)+,d0      ; Code der record-art
               cmpi.w     #0,d0
               beq.s      xplayinit
               cmpi.w     #1,d0
               beq        xdplayinit
               cmpi.w     #2,d0
               beq        xplayinit8
               cmpi.w     #3,d0
               beq        xplayinit16
xplayinit:     lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      bis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      xmem2b
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
xmem2b:        lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      pimode(pc),a2
               move.l     #9,(a2)
               move.l     a4,d0
               rts        

init_xmemp4:   lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von d1
               move.l     d1,(a2)       ; von d1
               lea.l      bvon(pc),a3
               move.l     d1,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang d2
               lea.l      dvon(pc),a2
               move.l     (a0)+,d3      ; von d3
               move.l     d3,(a2)       ; von d3
               lea.l      dbvon(pc),a3
               move.l     d3,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      dvon2(pc),a2
               move.l     (a0)+,d4      ; zweiter Speicherbereich Anfang d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Anfang d4
               move.l     (a0)+,d5      ; lÑnge der Speicherbereiche
               lea.l      bis(pc),a2
               add.l      d5,d1
               move.l     d1,(a2)       ; bis d1
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d5,d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Ende
               lea.l      dbis(pc),a2
               add.l      d5,d3
               move.l     d3,(a2)       ; bis d1
               lea.l      dbbis(pc),a3
               move.l     d3,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      dbis2(pc),a2
               add.l      d5,d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Ende
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               lea.l      dplaybyte(pc),a5        ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen fifo
               move.l     d0,24(a5)     ; Playposition setzen dsp
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               lea.l      dendcount(pc),a5
               move.l     (a0)+,(a2)    ; Zaehler endwert fifo
               move.l     (a2),(a5)     ; Zaehler endwert dsp
               lea.l      fileart(pc),a2
               lea.l      dfileart(pc),a5
               move.w     (a0)+,(a2)    ; fileart=3=WAV fifo
               move.w     (a2),(a5)     ; fileart dsp
               lea.l      dstep(pc),a5
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4 fifo
               move.l     d0,(a5)       ; Anzahl der For/Backstep d4 dsp
               lea.l      dmode(pc),a5
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a5)       ; mode dsp
               btst       #2,d0
               beq.s      xmemv3
               lea.l      midisuch(pc),a2
               lea.l      dmidisuch(pc),a5
               move.w     (a0)+,(a2)    ; midi d0
               move.w     (a2),(a5)
xmemv3:        lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      dfifo(pc),a2
               move.l     #$7ff,(a2)    ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      dmidiw(pc),a2
               move.l     #0,(a2)
               lea.l      dloop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      dcrosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      dplaybyte(pc),a4        ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      pimode(pc),a2
               move.l     #22,(a2)
               lea.l      dpimode(pc),a2
               move.l     #22,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

xmemplay:      lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               clr.l      a6            ; Peak-RÅckgabewert lîschen
               cmpa.l     d1,a2
               beq        xp_back
xpfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrlx
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      nowrlx
               addi.l     #1,12(a5)     ;Fehler +1
nowrlx:        move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      xpcopyanf
               bra.s      xpfill
xpcopyanf:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
xpcopy:        move.l     d4,-(sp)
               move.l     d1,-(sp)
               move.w     fileart(pc),d1
               cmpi.w     #3,d1
               bne.s      xnowave
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               bra.s      xcope
xnowave:       move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
xcope:         move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a5)     ; Playposition
               bsr        ppeakcmp
               move.l     (sp)+,d1
               move.l     (sp)+,d4
               adda.l     d4,a2
               add.l      d4,24(a5)
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendplay2
               cmpa.l     d1,a2
               beq.s      xplayend
               dbra       d0,xpcopy
xp_back:       lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
xp_back2:      lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
;               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xplayend:      moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
;               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      memt1
memt2:         lea.l      von2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      memte
memt1:         lea.l      bvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
memte:         bra        xp_back2
               btst       #1,d3         ; crossplay ?
               beq        xplooptst     ; wenn nein, ueberspringen
               lea.l      crosflag(pc),a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      xbktofor
xfortobk:      addq.l     #8,d4
               neg.l      d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Endposition
               lea.l      bvon(pc),a4
               move.l     (a4),d1
               addq.l     #4,d1
               lea.l      bis(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra        xp_back2
xbktofor:      neg.l      d4
               subq.l     #8,d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               lea.l      bbis(pc),a4
               lea.l      bis(pc),a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        xp_back2
xendplay:      lea.l      playbyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xendplay2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
;               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xplooptst:     btst       #0,d3
               beq.s      xendplay
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        xp_back2
xpmidi:        movem.l    d1-d7/a0-a4,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      xpnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      xpmidi2       ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      xpnomidi
xpmidi2:       cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      xpmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      xpnomidi
xpmidi3:       move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      xpmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      xpmidi6
xpmidi3b:      move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      xpnomidi
xpmidi4:       cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      xpmidi3       ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      xpnomidi
xpmidi5:       cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      xpmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      xpmidiex      ; Abbruch, da NOTE OFF !
xpmidi6:       cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      xpmidi3b      ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      xpmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      xpmidiex      ; Abbruch, da NOTE ON und Velo=Null !
xpnomidi:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #0,d0
               rts        
xpmidiex:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #1,d0
               rts        

recdummy:      move.l     #2047,d0      ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
               subq.l     #1,d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               adda.l     #$ff,a6
recdummy2:     move.w     (a6),d7       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               dbra       d0,recdummy2
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

playdummy:     move.l     #2047,d0      ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
               subq.l     #1,d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               adda.l     #$ff,a6
playdummy2:    move.w     #0,(a6)       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               dbra       d0,playdummy2
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

setadcdac:     move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               lea.l      dmarec(pc),a3 ; DMA-Mode restaurieren
               move.w     (a3),d0
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               lea.l      dacrec(pc),a3 ; DAC-Mode restaurieren
               move.w     (a3),d0
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPCARD-OUT-auswahl
               lea.l      cardrec(pc),a3          ; DSP-Mode restaurieren
               move.w     (a3),d0
               bsr        matinsel
               rts        

init_emuladc8: move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq        getmadc8
               cmpi.w     #0,d0
               bne.s      initadc8a
               bsr        no_emuladc8
               move.w     #0,emuladc
               rts        
initadc8a:     move.w     d0,emuladc
initadc8b:     cmpi.w     #0,emuladc
               beq        no_emuladc8
               move.w     #1,emuladc

               cmpi.w     #2,playmod    ; playmode=Achtkanal?
               bne        exemuladc8    ; wenn nein,fertig und raus hier...
               cmpi.w     #0,recmod     ; recmode=Stereo ?
               bne        exemuladc8    ; wenn nein,fertig und raus hier...

               lea.l      stack,a0
               move.w     #0,(a0)       ; intmode
               bsr        intact
               move.w     #1,emulact8

               move.w     #1,endless
               move.w     #1,nopeaks
               move.w     #0,-(sp)
               move.w     #$86,-(sp)
               trap       #GEMDOS       ; montrack
               addq.l     #4,sp
               move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               bsr        matinsel
;               move.w     #2,dmarec
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; mit DSPCARD-IN verbinden
               bsr        matinsel
;               move.w     #2,dacrec
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPCARD-OUT-auswahl
               move.w     #1,d0         ; mit DMAPLAY verbinden
               bsr        matinsel
;               move.w     #2,dsprec
;               lea.l      vmestart(pc),a6
;               movea.l    (a6),a6
;               move.b     #13,$214(a6)
               lea.l      stack,a0
               move.w     #0,(a0)+      ; select
               lea.l      recbuf,a1
               move.l     a1,(a0)+      ; buffer1
               lea.l      recbuf2,a1
               move.l     a1,(a0)+      ; buffer2
               move.l     #recbuflen,(a0)+        ; bufferlen
               move.l     #4,(a0)+      ; endcount
               move.w     #0,(a0)+      ; fileart
               lea.l      epeakbuf,a1
               move.l     a1,(a0)+      ; peakbuf
               lea.l      stack,a0
               bsr        init_xmemrec
               lea.l      stack,a0
               move.w     #2,(a0)+      ; select
               lea.l      recbuf2,a1
               move.l     a1,(a0)+      ; buffer1
               lea.l      recbuf,a1
               move.l     a1,(a0)+      ; buffer2
               move.l     #recbuflen,(a0)+        ; bufferlen
               move.l     #0,(a0)+      ;count
               move.l     #4,(a0)+      ; endcount
               move.w     #0,(a0)+      ; fileart
               move.w     #0,(a0)+      ; step
               move.w     #0,(a0)+      ; mode
               lea.l      stack,a0
               bsr        init_xmemplay
               lea.l      pimode(pc),a2
               move.l     #28,(a2)
               lea.l      stack,a0
               move.w     #3,(a0)       ; intmode
               bsr        intact
exemuladc8:    lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        
getmadc8:      clr.l      d0
               move.w     emulact8,d0
               swap.w     d0
               move.w     emuladc,d0
               rts        

no_emuladc8:   cmpi.w     #0,emuladc
               beq.s      no_emuladc8b
               lea.l      stack,a0
               move.w     #0,(a0)       ; intmode
               bsr        intact
               bsr        setadcdac
               move.w     #0,emulact8
               rts        
no_emuladc8b:  move.w     #0,emuladc
               lea.l      stack,a0
               move.w     #0,(a0)       ; intmode
               bsr        intact
               move.w     #0,emulact8
               rts        

adcemu8:       lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               clr.l      a6            ; Peak-RÅckgabewert lîschen
               cmpa.l     d1,a2
               beq        aep_back
aepfill:       move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      aenowrlx
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      aenowrlx
               addi.l     #1,12(a5)     ;Fehler +1
aenowrlx:      move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      aepcopyanf
               bra.s      aepfill
aepcopyanf:    move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
aepcopy:       move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               move.w     #0,d7
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d7,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d7,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d7,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d7,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d7,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d7,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a5)     ; Playposition
               cmpi.w     #0,endless
               bne.s      aep_backa
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        aeendplay
aep_backa:     cmpa.l     d1,a2
               beq.s      aeplayend
               dbra       d0,aepcopy
aep_back:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
aep_back2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
aeplayend:     moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      aememt1
aememt2:       lea.l      von2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      aememte
aememt1:       lea.l      bvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
aememte:       bra        aep_back2
aeendplay:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        


init_xmemrec:  move.w     (a0)+,d0      ; Code der record-art
               cmpi.w     #0,d0
               beq.s      xrecinit
               cmpi.w     #1,d0
               beq        xdrecinit
               cmpi.w     #2,d0
               beq        xrecinit8
xrecinit:      lea.l      rvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      rbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      rvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      rbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      rbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      rendcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.l      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
;               bsr        recreset
               lea.l      rpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #10,(a2)
               move.l     a4,d0
               rts        

init_xmemr4:   lea.l      rvon(pc),a2
               move.l     (a0)+,d1      ; von d1
               move.l     d1,(a2)       ; von d1
               lea.l      rbvon(pc),a3
               move.l     d1,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      rvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang d2
               lea.l      rdvon(pc),a2
               move.l     (a0)+,d3      ; von d3
               move.l     d3,(a2)       ; von d3
               lea.l      rdbvon(pc),a3
               move.l     d3,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      rdvon2(pc),a2
               move.l     (a0)+,d4      ; zweiter Speicherbereich Anfang d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Anfang d4
               move.l     (a0)+,d5      ; lÑnge der Speicherbereiche
               lea.l      rbis(pc),a2
               add.l      d5,d1
               move.l     d1,(a2)       ; bis d1
               lea.l      rbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rbis2(pc),a2
               add.l      d5,d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Ende
               lea.l      rdbis(pc),a2
               add.l      d5,d3
               move.l     d3,(a2)       ; bis d1
               lea.l      rdbbis(pc),a3
               move.l     d3,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rdbis2(pc),a2
               add.l      d5,d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Ende
               lea.l      rendcount(pc),a2
               lea.l      rdendcount(pc),a3
               move.l     (a0)+,(a2)    ; Zaehler endwert fuer fifo
               move.l     (a2),(a3)     ; Zaehler endwert fuer dsp
               lea.l      rfileart(pc),a2
               lea.l      rdfileart(pc),a3
               move.w     (a0)+,(a2)    ; fileart=3=WAV fuer fifo
               move.w     (a2),(a3)     ; fileart=3=WAV fuer dsp
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      rdfifo(pc),a2
               move.l     #$1ff,(a2)    ; dspbuffer 2048 (/4=$200) Byte
;               bsr        recreset
               lea.l      rpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      rdpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      drecbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #23,(a2)
               lea.l      drimode(pc),a2
               move.l     #23,(a2)
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

xmemrec:       lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      xmemre2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xmemre2:       lea.l      rpeakmerk(pc),a2
               clr.l      (a2)
               lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
xranf:         move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      xnordful
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      xnordful
               addi.l     #1,12(a5)     ;Fehler +1
xnordful:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      xrstrt        ; wenn ja, daten einlesen
               bra.s      xranf
xrstrt:        clr.l      a0            ; Peak pos/neg left lîschen
               clr.l      a3            ; Peak pos/neg right lîschen
               clr.l      a4
xrcopy:        move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
xrcopy2:       move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      xrcopy3       ; fehlerhafte Daten ?
               move.l     d1,-(sp)
               move.w     rfileart(pc),d1
               cmpi.w     #3,d1
               bne.s      xnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bsr        rpeakcmp
               bra.s      xrcope
xnorwave:      move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               bsr        rpeakcmp
xrcope:        move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               cmpi.w     #0,endless
               bne.s      xrcopeb
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble.s      xendrec2
xrcopeb:       cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      xrweg
xrcopy3:       dbra       d0,xrcopy2
xr_back:       lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
xr_back2:      move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xrweg:         move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      memr1
memr2:         lea.l      rvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      xr_back2
memr1:         lea.l      rbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      xr_back2
xendrec2:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

txmemrec:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      txmemre2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
txmemre2:      lea.l      rpeakmerk(pc),a2
               clr.l      (a2)
               lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
txranf:        move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      txnordful
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      txnordful
               addi.l     #1,12(a5)     ;Fehler +1
txnordful:     and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      txrcopy       ; wenn ja, daten einlesen
               bra.s      txranf
txrcopy:       move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
txrcopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      txrcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      txrcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      txrcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      txrcopy3      ; fehlerhafte Daten ?
               move.l     d1,-(sp)
               move.w     rfileart(pc),d1
               cmpi.w     #3,d1
               bne.s      txnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
;               bsr        rpeakcmp
               bra.s      txrcope
txnorwave:     move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
;               bsr        rpeakcmp
txrcope:       move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble.s      txendrec2
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      txrweg
txrcopy3:      dbra       d0,txrcopy2
txr_back:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
txr_back2:     move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
txrweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      tmemr1
tmemr2:        lea.l      rvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      txr_back2
tmemr1:        lea.l      rbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      txr_back2
txendrec2:     lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

ppeakcmp:      asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               move.l     a6,d1
               swap.w     d1
               btst       #15,d7
               beq.s      pxpnoneg
               not.w      d7
pxpnoneg:      cmp.w      d1,d7
               blt.s      pxpnoadd
               move.w     d7,d1
pxpnoadd:      swap.w     d1
               btst       #15,d5
               beq.s      pxpnoneg2
               not.w      d5
pxpnoneg2:     cmp.w      d1,d5
               blt.s      pxircop2b
               move.w     d5,d1
pxircop2b:     movea.l    d1,a6
               rts        

rpeakcmp:      cmpi.w     #0,nopeaks
               beq.s      rpeakrun
               rts        
rpeakrun:      asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               move.l     a0,d1         ; peak linker Kanal
               btst       #15,d7
               beq.s      xpnoneg
               not.w      d7
               cmp.w      d1,d7
               blt.s      xpnoadd
               move.w     d7,d1
               bra.s      xpnoadd
xpnoneg:       swap.w     d1            ; positive HÑlfte
               cmp.w      d1,d7
               blt.s      xpnoadd2
               move.w     d7,d1
xpnoadd2:      swap.w     d1            ; peak linker Kanal, negative HÑlfte
xpnoadd:       movea.l    d1,a0         ; peak links retten
               move.l     a3,d1         ; peak rechter Kanal
               btst       #15,d5
               beq.s      xpnoneg2
               not.w      d5
               cmp.w      d1,d5
               blt.s      xircop2b
               move.w     d5,d1
               bra.s      xircop2b
xpnoneg2:      swap.w     d1
               cmp.w      d1,d5
               blt.s      xircop2c
               move.w     d5,d1
xircop2c:      swap.w     d1
xircop2b:      movea.l    d1,a3         ;peak rechts retten
               addq.l     #1,a4
               cmpa.l     #512,a4
               bne.s      pbufweg
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a6       ; Peakbuffer-Adresse holen
               move.l     a0,(a6)+      ; Peakwert li im Peakbuffer speichern
               move.l     a3,(a6)+      ; Peakwert re im Peakbuffer speichern
               move.l     a6,(a4)       ; neue Peakbuffer-Adresse retten
               move.l     a0,d6
               move.w     d6,d7
               swap.w     d6
               cmp.w      d7,d6
               blt.s      peakrm1
               move.w     d6,d7
peakrm1:       lea.l      rpeakmerk(pc),a4
               move.l     (a4),d1
               swap.w     d1
               cmp.w      d1,d7
               blt.s      pypnoadd
               move.w     d7,d1
pypnoadd:      swap.w     d1
               move.l     a3,d6
               move.w     d6,d7
               swap.w     d6
               cmp.w      d7,d6
               blt.s      peakrm2
               move.w     d6,d7
peakrm2:       cmp.w      d1,d7
               blt.s      pyircop2b
               move.w     d7,d1
pyircop2b:     move.l     d1,(a4)
               clr.l      a4            ; WertezÑhler lîschen
               clr.l      a0            ; Peakwert re lîschen
               clr.l      a3            ; Peakwert li lîschen
pbufweg:       rts        

peaksuch:      movea.l    (a0)+,a1      ; von
               movea.l    (a0)+,a2      ; bis
               lea.l      peakw(pc),a3
               clr.l      d1
               clr.l      d2
               clr.l      d3
               clr.l      d4
peak1:         move.w     (a1)+,d0
               cmp.w      d1,d0
               blt.s      peak2
               move.w     d0,d1
peak2:         move.w     (a1)+,d0
               cmp.w      d2,d0
               blt.s      peak3
               move.w     d0,d2
peak3:         move.w     (a1)+,d0
               cmp.w      d3,d0
               blt.s      peak4
               move.w     d0,d3
peak4:         move.w     (a1)+,d0
               cmp.w      d4,d0
               blt.s      peak5
               move.w     d0,d4
peak5:         cmpa.l     a2,a1
               bne.s      peak1
               move.w     d1,(a3)       ; maxwert pos links
               move.w     d2,2(a3)      ; maxwert neg links
               move.w     d3,4(a3)      ; maxwert pos rechts
               move.w     d4,6(a3)      ; maxwert neg rechts
               move.l     a3,d0
               rts        


mixit:         move.w     (a0)+,d0      ; Anzahl der MixkanÑle
               cmpi.w     #16,d0
               beq        mix16
               cmpi.w     #12,d0
               beq        mix12
               cmpi.w     #8,d0
               beq.s      mix8
               cmpi.w     #4,d0
               beq.s      mix4
               move.l     #-1,d0
               rts        

; Mixt 2 StereokanÑle (=4 MonokanÑle) zusammen

mix4:          movea.l    (a0)+,a2      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a4      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle2adresse
               clr.l      d2
               clr.l      d5
               move.l     #100,d3
               move.b     (a6)+,d2      ; Volume1
               move.b     (a6),d5       ; Volume2
accu:          move.w     (a2)+,d6      ; source1
               move.w     (a3)+,d7      ; source2
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
               bsr        mixer
               move.w     d7,(a4)+      ; d7,destination
               subq.l     #1,d0
               tst.l      d0
               bne.s      accu
               rts        

mixer:         btst       #15,d6        ; mixt (d6 und d7) nach d7
               beq.s      noneg
               neg.w      d6
               btst       #15,d7
               bne.s      negneg
negplus:       neg.w      d6
               add.w      d6,d7
               bra.s      accuweg
negneg:        neg.w      d7
               add.w      d6,d7
               neg.w      d7
               bra.s      accuweg
noneg:         btst       #15,d7
               beq.s      plusplus
plusneg:       neg.w      d7
               neg.w      d7
               add.w      d6,d7
               bra.s      accuweg
plusplus:      add.w      d6,d7
accuweg:       rts        


; Mixt 4 StereokanÑle (=8 MonokanÑle) zusammen

mix8:          movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
               move.l     #100,d3
               clr.l      d2
               clr.l      d5
accu8:         move.w     (a1)+,d6      ; source1
               move.w     (a2)+,d7      ; source2
               move.b     (a6),d2       ; Volume1
               move.b     1(a6),d5      ; Volume2
               cmp.w      d2,d3
               beq.s      nomul8a
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul8a:       cmp.w      d5,d3
               beq.s      nomul8b
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul8b:       bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,d1
               move.w     (a3)+,d6      ; source3
               move.w     (a4)+,d7      ; source4
               move.b     2(a6),d2      ; Volume3
               move.b     3(a6),d5      ; Volume4
               cmp.w      d2,d3
               beq.s      nomul8c
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul8c:       cmp.w      d5,d3
               beq.s      nomul8d
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul8d:       bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d1,d6
               bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,(a5)+      ; d7,destination
               subq.l     #1,d0
               tst.l      d0
               bne.s      accu8
               rts        


; Mixt 6 StereokanÑle (=12 MonokanÑle) zusammen

mix12:         movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a6      ; zieladresse
               move.l     a6,-(sp)      ; zieladresse retten
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
               movea.l    a4,a5
               adda.l     d1,a5         ; quelle3adresse
               movea.l    a5,a0
               adda.l     d1,a0         ; quelle4adresse
               move.l     #100,d3
               clr.l      d2
               clr.l      d5
accu12:        move.w     (a1)+,d6      ; source1
               move.w     (a2)+,d7      ; source2
               move.b     (a6),d2       ; Volume1
               move.b     1(a6),d5      ; Volume2
               cmp.w      d2,d3
               beq.s      nomul12a
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul12a:      cmp.w      d5,d3
               beq.s      nomul12b
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul12b:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,d1
               move.w     (a3)+,d6      ; source3
               move.w     (a4)+,d7      ; source4
               move.b     2(a6),d2      ; Volume3
               move.b     3(a6),d5      ; Volume4
               cmp.w      d2,d3
               beq.s      nomul12c
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul12c:      cmp.w      d5,d3
               beq.s      nomul12d
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul12d:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d1,d6
               bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,d1
               move.w     (a5)+,d6      ; source5
               move.w     (a0)+,d7      ; source6
               move.b     4(a6),d2      ; Volume5
               move.b     5(a6),d5      ; Volume6
               cmp.w      d2,d3
               beq.s      nomul12e
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul12e:      cmp.w      d5,d3
               beq.s      nomul12f
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul12f:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d1,d6
               bsr        mixer         ; mixt (d6 und d7) nach d7
               movea.l    a6,a0
               movea.l    (sp)+,a6
               move.w     d7,(a6)+      ; d7,destination
               move.l     a6,-(sp)
               movea.l    a0,a6
               subq.l     #1,d0
               tst.l      d0
               bne.s      accu12
               movea.l    (sp)+,a6
               rts        


; Mixt 8 StereokanÑle (=16 MonokanÑle) zusammen

mix16:         movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               move.l     #100,d3
               clr.l      d2
               clr.l      d5
accu16:        movea.l    a1,a2
               move.w     (a2),d6       ; source1
               adda.l     d1,a2
               move.w     (a2),d7       ; source2
               move.b     (a6),d2       ; Volume1
               move.b     1(a6),d5      ; Volume2
               cmp.w      d2,d3
               beq.s      nomul16a
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16a:      cmp.w      d5,d3
               beq.s      nomul16b
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16b:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,-(sp)      ; ergebnis 1+2 retten
               adda.l     d1,a2
               move.w     (a2),d6       ; source3
               adda.l     d1,a2
               move.w     (a2),d7       ; source4
               move.b     2(a6),d2      ; Volume3
               move.b     3(a6),d5      ; Volume4
               cmp.w      d2,d3
               beq.s      nomul16c
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16c:      cmp.w      d5,d3
               beq.s      nomul16d
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16d:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     (sp)+,d6      ; ergebnis 1+2 holen
               bsr        mixer         ; mixt 1+2 und 3+4 zusammen
               move.w     d7,-(sp)
               adda.l     d1,a2
               move.w     (a2),d6       ; source5
               adda.l     d1,a2
               move.w     (a2),d7       ; source6
               move.b     4(a6),d2      ; Volume5
               move.b     5(a6),d5      ; Volume6
               cmp.w      d2,d3
               beq.s      nomul16e
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16e:      cmp.w      d5,d3
               beq.s      nomul16f
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16f:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,-(sp)      ; ergebnis 5+6 retten
               adda.l     d1,a2
               move.w     (a2),d6       ; source7
               adda.l     d1,a2
               move.w     (a2),d7       ; source8
               move.b     6(a6),d2      ; Volume7
               move.b     7(a6),d5      ; Volume8
               cmp.w      d2,d3
               beq.s      nomul16g
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16g:      cmp.w      d5,d3
               beq.s      nomul16h
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16h:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     (sp)+,d6      ; ergebnis 5+6 holen
               bsr        mixer         ; mixt 5+6 und 7+8 zusammen
               move.w     (sp)+,d6      ; ergebnis 1+2+3+4 holen
               bsr        mixer         ; mixt 1+2+3+4 und 5+6+7+8 zusammen
               move.w     d7,(a5)+      ; d7,destination (1-8)
               addq.l     #2,a1
               subq.l     #1,d0
               tst.l      d0
               bne        accu16
               rts        

muster:        movea.l    (a0)+,a1      ; anfadresse
               move.l     (a0)+,d0
               move.l     (a0)+,d1
muster2:       move.l     d1,(a1)+
               cmpa.l     d0,a1
               blt.s      muster2
               clr.l      d0
               rts        

testbits:      movea.l    (a0)+,a1      ; anfadresse
               move.l     (a0)+,d0
               move.l     d0,d2
               sub.l      a1,d2
               asr.l      #8,d2
               move.l     #0,d1
               clr.l      d3
testbit2:      move.l     d1,(a1)+
               addi.l     #1,d3
               cmp.l      d2,d3
               blt.s      testbit2
               clr.l      d3
               move.l     #1,d1
testbit3:      move.l     d1,(a1)+
               addi.l     #1,d3
               cmp.l      d2,d3
               blt.s      testbit3
               clr.l      d3
               cmpi.l     #$80000000,d1
               beq.s      testbit4
               asl.l      #1,d1
               bra.s      testbit3
testbit4:      clr.l      d0
               rts        


fastcut:       movea.l    (a0)+,a1      ; anfadresse
               move.l     (a0)+,d0
               movea.l    d0,a6         ; endadresse
               sub.l      a1,d0         ; ist die Anzahl der Bytes
               clr.l      d2            ; Register lîschen
               moveq.l    #48,d1
               cmp.l      d1,d0
               blt.s      cutrest
               clr.l      d3
               clr.l      d4
               clr.l      d5
               clr.l      d6
               clr.l      d7
               movea.l    d2,a0
               movea.l    a0,a1
               movea.l    a0,a2
               movea.l    a0,a3
               movea.l    a0,a4
               movea.l    a0,a5         ; sind zusammen 13 Register = 52 Bytes
fastcut2:      movem.l    d2-d7/a0-a5,-(a6)
               sub.l      d1,d0
               cmp.l      d1,d0
               bge.s      fastcut2
cutrest:       tst.l      d0
               beq.s      cutend
cutrest2:      lsr.l      #2,d0
               subq.l     #1,d0
cutrest3:      move.l     d2,-(a6)
               dbra       d0,cutrest3
cutend:        clr.l      d0
               rts        

intbreak:      movem.l    a1/a6,-(sp)
               lea.l      intreg(pc),a1
               move.b     (a1),d1
               bclr       d0,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$280(a6)
               movem.l    (sp)+,a1/a6
               rts        

fading:        movea.l    (a0)+,a3      ; data
               move.l     (a0)+,d0      ; werte
               movea.l    (a0)+,a1      ; anfang
               movea.l    (a0)+,a2      ; ende
               movea.l    a3,a0
               move.l     a2,d3
               move.l     a1,d2
               sub.l      d2,d3
               asr.l      #2,d3         ; Sampleanzahl
               andi.l     #$3fffffff,d3
               divu.w     d0,d3         ; Samples/Werte = Anzahl Samples pro Wert
               andi.w     #$ffff,d3
               cmpi.w     #0,d3
               bne.s      fadanf2a
               move.w     #1,d3         ; mind. 1 Sample pro Wert
fadanf2a:      subi.w     #1,d0
fadanf2:       move.w     (a0),d2
               move.w     2(a0),d6      ; erste beiden Datenwerte holen
               sub.w      d2,d6         ; voneinander subtrahieren = Steigung
               andi.l     #$ffff,d6
               btst       #15,d6
               beq.s      fpositiv      ; -> positive Steigung
fnegativ:      neg.w      d6
               cmpi.w     #0,d3
               beq.s      fneg2
               divu.w     d3,d6         ; Steigung/Anzahl Samples pro Wert = SteigungsstÅck
               andi.w     #$ffff,d6
fneg2:         neg.w      d6
               bra.s      fadanf2b
fpositiv:      cmpi.w     #0,d3
               beq.s      fadanf2b
               divu.w     d3,d6         ; Steigung/Anzahl Samples pro Wert
fadanf2b:      andi.w     #$ffff,d6
               bsr        fmax          ; hîchsten Wert suchen, ist in d5
               move.w     d3,d4
               subi.w     #1,d4         ; Anzahl Samples pro Wert holen fÅr Schleife
fadanf3:       move.w     (a1),d1       ; Sample holen
               bsr        fade          ; faden
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
               move.w     (a1),d1       ; Sample holen
               bsr        fade          ; faden
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
               add.w      d6,d2         ; SteigungsstÅck zum Anfangswert dazu
               andi.w     #$ffff,d2
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
               dbra       d4,fadanf3    ; Anzahl Samples pro Wert
               addq.l     #2,a0         ; zum nÑchsten Datenwert
               dbra       d0,fadanf2    ; Anzahl Werte
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
fadanf4:       move.w     (a1),d1
               bsr        fade          ; rest faden
               cmpa.l     a2,a1
               blt.s      fadanf4       ; bis zum Ende ?
fadweg:        clr.l      d0
               rts        
fade:          andi.l     #$ffff,d1     ; aktuelles Sample
               cmpi.w     #0,d5         ; hîchster Wert ist null ?
               beq.s      fweiter       ; dann weg hier
               btst       #15,d1
               beq.s      fnoneg        ; wenn positiv dahin
               not.w      d1
               mulu.w     d2,d1         ; mal aktuelle Steigung
               divu.w     d5,d1         ; geteilt durch Hîchstwert
               not.w      d1
               bra.s      fweiter
fnoneg:        mulu.w     d2,d1         ; mal aktuelle Steigung
               divu.w     d5,d1         ; geteilt durch Hîchstwert
fweiter:       move.w     d1,(a1)+      ; Sample speichern, zum nÑchsten Sample
               rts        
fmax:          move.w     d3,d4
               add.w      d4,d4         ; Samples pro Wert*2
               subi.w     #2,d4         ; und minus 2
               move.w     #0,d5
               movea.l    a1,a3         ; Anfang in a3 merken
fmax2:         move.w     (a1)+,d1
               btst       #15,d1
               beq.s      fnoneg2
               not.w      d1
fnoneg2:       cmp.w      d5,d1
               ble.s      fweiter2
               move.w     d1,d5         ; hîchsten Wert suchen und in d5 merken
fweiter2:      dbra       d4,fmax2
               movea.l    a3,a1         ; Anfang zurÅck in a1
               rts        

zerono:        movea.l    (a0)+,a3      ; anf
               movea.l    (a0)+,a1      ; ende
               move.w     (a0)+,d0      ; Richtung
               movea.l    a3,a0
               cmpi.w     #0,d0
               bne.s      znback
znvor:         move.w     (a0)+,d1
               cmpi.l     #0,d1
               bne.s      znvorweg
               cmpa.l     a1,a0
               blt.s      znvor
               move.l     #-1,d0
               bra.s      znweg
znvorweg:      move.l     a0,d0
               subq.l     #4,d0
               bra.s      znweg
znback:        move.l     -(a1),d1
               cmpi.l     #0,d1
               bne.s      znbackweg
               cmpa.l     a0,a1
               bgt.s      znback
               move.l     #-1,d0
               bra.s      znweg
znbackweg:     move.l     a1,d0
znweg:         rts        

digana:        lea.l      lowreg(pc),a1
               lea.l      asrc(pc),a6
               move.b     (a1),d1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq.s      getdiga
               move.w     d0,(a6)
               cmpi.w     #1,d0
               bgt.s      digerr
               cmpi.w     #0,d0
               blt.s      digerr
               andi.w     #$fe,d1
               add.b      d0,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,(a6)
               cmpi.w     #0,d0
               bne.s      analog
               andi.w     #3,d1
               move.b     d1,(a6)
analog:        clr.l      d0
               rts        
digerr:        move.l     #-1,d0
               rts        
getdiga:       clr.l      d0
               move.w     (a6),d0
               rts        

digcom:        lea.l      lowreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               lea.l      dsrc(pc),a5
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq.s      getdig
               move.w     d0,(a5)
               cmpi.w     #2,d0
               bgt.s      digerr
               cmpi.w     #0,d0
               blt.s      digerr
               bne.s      inkoax
inopto:        bclr       #1,d1
               bra.s      digcom2
inkoax:        cmpi.b     #1,d0
               bne.s      inaes
               bset       #1,d1
digcom2:       move.b     d1,(a1)
               move.b     d1,(a6)
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               bclr       #7,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               clr.l      d0
               rts        
inaes:         bset       #1,d1
               move.b     d1,(a1)
               move.b     d1,(a6)
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               bset       #7,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               clr.l      d0
               rts        
getdig:        clr.l      d0
               move.w     (a5),d0
               rts        

sclock:        lea.l      lowreg(pc),a1
               move.b     (a1),d1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq.s      getsclock
               lea.l      hz(pc),a2
               move.w     d0,(a2)
               cmpi.w     #0,d0
               blt.s      sclocke
               bne.s      sclock1
               andi.w     #3,d1
               bra.s      sclockwr
sclock1:       cmpi.w     #1,d0
               bne.s      sclock2
               andi.w     #3,d1
               bset       #2,d1
               bra.s      sclockwr
sclock2:       cmpi.w     #2,d0
               bne.s      sclock3
               andi.w     #3,d1
               bset       #3,d1
               bra.s      sclockwr
sclock3:       cmpi.w     #3,d0
               bne.s      sclock4
               andi.w     #3,d1
               bset       #2,d1
               bset       #3,d1
               bra.s      sclockwr
sclock4:       cmpi.w     #15,d0
               bgt.s      sclocke
               andi.w     #3,d1
               subi.w     #4,d0
               lea.l      sclockv(pc),a3
               move.b     0(a3,d0.w),d2
               add.b      d2,d1
sclockwr:      move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,(a6)
               clr.l      d0
               rts        
sclocke:       move.l     #-1,d0
               rts        
getsclock:     clr.l      d0
               lea.l      hz(pc),a2
               move.w     (a2),d0
               rts        

errorcode:     lea.l      hireg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               clr.l      d0
               move.b     $20(a6),d0
               andi.w     #7,d0
               rts        

digcode:       lea.l      hireg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               bset       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               clr.l      d0
               move.b     $20(a6),d0
               btst       #7,d0
               bne.s      emphyes
               andi.w     #7,d0
               bra.s      digcod2
emphyes:       andi.w     #7,d0
               bset       #3,d0
digcod2:       bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               bchg       #3,d0
               andi.b     #$0f,d0
               rts        

frecres:       lea.l      snderr(pc),a1
               bclr       #4,(a1)
               bclr       #5,(a1)
               lea.l      stack(pc),a0
               lea.l      falcmode(pc),a6
               move.w     (a6),d0
               move.w     d0,(a0)
;               bsr        compatible   ; soundstatus-reset
               clr.l      d0            ; fÅr Fifo-reset weglassen
               rts                      ; dito

recreset:      movem.l    d0-d7/a0-a6,-(sp)
               lea.l      hireg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               bset       #1,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.l     #2,d0
               bsr        pause
               bclr       #1,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.l     #2,d0
               bsr        pause
               bsr        kickstart
               movem.l    (sp)+,d0-d7/a0-a6
               clr.l      d0
               rts        

kickstart:     lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      dspreg(pc),a2
               move.b     (a2),d2
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               andi.b     #$fb,d1
               move.b     d1,$40(a6)
               addi.w     #4,d1
               move.b     d1,$40(a6)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               move.b     d2,$80(a6)
               lea.l      aesreg(pc),a3
               move.b     (a3),d3
               move.w     #4,d7
toggle:        bset       #3,d3
               move.b     d3,$c0(a6)
               move.b     d3,$c0(a6)
               move.l     #2,d0
               bsr        pause
               bclr       #3,d3
               move.b     d3,$c0(a6)
               move.l     #2,d0
               bsr        pause
               dbra       d7,toggle
               move.l     #2,d0
               bsr        pause
               move.b     (a3),d3
               move.b     d3,$c0(a6)
               move.b     (a2),d2
               move.b     d2,$80(a6)
               andi.b     #$fb,d1
               move.b     d1,$40(a6)
               move.l     #2,d0
               bsr        pause
               lea.l      playmod(pc),a1
               move.w     (a1),d1
               cmpi.w     #2,d1
               ble.s      kickleave
               lea.l      montrack(pc),a1
               move.w     (a1),d0
               clr.w      d7
               bsr        setmontr2
kickleave:     clr.l      d0
               rts        

bypass:        lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d0      ; wert
               cmpi.w     #0,d0
               blt.s      byperr
               cmpi.w     #1,d0
               bgt.s      byperr
               beq.s      fifoplay
               movem.l    d0-d7/a0-a6,-(sp)
               move.w     #0,d3
               bsr        profmake
               movem.l    (sp)+,d0-d7/a0-a6
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; DSP-Out->DAC
               lea.l      dspart(pc),a3
               move.w     (a3),d3
               cmpi.w     #0,d3
               bne.s      bypassx
               move.w     #2,d0         ; A/D->DAC
bypassx:       move.w     d0,dacrec
               bsr        matinsel
               cmpi.w     #2,d3
               bne.s      bypassz
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPIN-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
bypassz:       clr.l      d0
               rts        
byperr:        move.l     #-1,d0
               rts        

fifoplay:      movem.l    d0-d7/a0-a6,-(sp)
               move.w     #1,d3
               bsr        profmake
               movem.l    (sp)+,d0-d7/a0-a6
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               lea.l      dspart(pc),a3
               move.w     (a3),d3
               cmpi.w     #2,d3
               beq.s      fifopla2
               move.w     #1,d0         ; DMAPLAY->DAC
               move.w     d0,dacrec
               bsr        matinsel
               clr.l      d0
               rts        
fifopla2:      move.w     #3,d0         ; DSP-Out->DAC
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSP-Input-auswahl
               move.w     #1,d0         ; DMA-Play->DSP-Input
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
               clr.l      d0
               rts        

profmake:      lea.l      proffm(pc),a2
               move.w     (a2),d2
               cmpi.w     #0,d2
               bne.s      proffja
proffno:       cmpi.w     #0,d3
               bne.s      proffno1
proffno0:      lea.l      bridg3(pc),a3
               move.w     (a3),-(sp)
               bsr        copyone
               lea.l      bridg4(pc),a3
               move.w     (a3),-(sp)
               bsr        prot
               bra.s      profend
proffno1:      lea.l      bridg1(pc),a3
               move.w     (a3),-(sp)
               bsr        copyone
               lea.l      bridg2(pc),a3
               move.w     (a3),-(sp)
               bsr        prot
profend:       rts        
proffja:       cmpi.w     #0,d3
               bne.s      profja1
profja0:       move.w     #0,d2
               move.w     d2,(a2)
               lea.l      cat0(pc),a3
               lea.l      catb0(pc),a4
               move.w     (a4),(a3)
               lea.l      cat1(pc),a3
               lea.l      catb1(pc),a4
               move.w     (a4),(a3)
               lea.l      scms(pc),a3
               move.w     (a3),-(sp)
               bsr        prot
               lea.l      gen(pc),a3
               move.w     (a3),-(sp)
               bsr        genera
               lea.l      cat0(pc),a3
               move.w     (a3),-(sp)
               bsr        categ0
               lea.l      cat1(pc),a3
               move.w     (a3),-(sp)
               bsr        categ1
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      empha(pc),a6
               move.w     (a6),d0       ; wert
               bsr        emphasis2
               lea.l      aesreg(pc),a3
               move.b     (a3),d4
               bclr       #0,d4
               move.b     d4,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d4,$c0(a6)
               rts        
profja1:       move.w     #1,d2
               move.w     d2,(a2)
               lea.l      cat0(pc),a3
               lea.l      catb0(pc),a4
               move.w     (a3),(a4)
               lea.l      cat1(pc),a3
               lea.l      catb1(pc),a4
               move.w     (a3),(a4)
               bsr        proffhz
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      empha(pc),a6
               move.w     (a6),d0       ; wert
               bsr        emphasis2
               move.w     #1,-(sp)
               bsr        genprof
               lea.l      aesreg(pc),a3
               move.b     (a3),d4
               bset       #0,d4
               move.b     d4,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d4,$c0(a6)
               rts        

prot:          move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      prot1
prot0:         bclr       #0,d6
               bra.s      prot2
prot1:         bset       #0,d6
prot2:         move.b     d6,(a6)
               lea.l      scms(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

categ0:        move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      cate1
cate0:         bclr       #6,d6
               bra.s      cate2
cate1:         bset       #6,d6
cate2:         move.b     d6,(a6)
               lea.l      cat0(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

categ1:        move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      cateb1
cateb0:        bclr       #7,d6
               bra.s      cateb2
cateb1:        bset       #7,d6
cateb2:        move.b     d6,(a6)
               lea.l      cat1(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

genera:        move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      genera1
genera0:       bclr       #5,d6
               bra.s      genera2
genera1:       bset       #5,d6
genera2:       move.b     d6,(a6)
               lea.l      gen(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

genprof:       move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      genprof1
genprof0:      bclr       #5,d6
               bra.s      genprof2
genprof1:      bset       #5,d6
genprof2:      move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

emphprof:      move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      emphprof1
emphprof0:     bclr       #4,d6
               bra.s      emphprof2
emphprof1:     bset       #4,d6
emphprof2:     move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

protprof:      move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      protprof1
protprof0:     bclr       #0,d6
               bra.s      protprof2
protprof1:     bset       #0,d6
protprof2:     move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

copyone:       move.l     (sp)+,d5
               lea.l      aesreg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
;               bne.s      copyo1
copyo0:                   ;     bclr       #1,d6
;               bra.s      copyo2
copyo1:                   ;      bset       #1,d6
copyo2:        move.b     d6,(a6)
               lea.l      copyobit(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$c0(a6)
               move.l     d5,-(sp)
               rts        

proffhz:       lea.l      hz(pc),a1
               move.w     (a1),d0
               cmpi.w     #1,d0
               beq.s      proffhz32
               cmpi.w     #2,d0
               beq.s      proffhz44
               cmpi.w     #3,d0
               beq.s      proffhz48
               rts        
proffhz32:     move.w     #1,-(sp)
               bsr        protprof
               move.w     #1,-(sp)
               bsr        emphprof
               move.w     #1,-(sp)
               bsr        genprof
               rts        
proffhz44:     move.w     #1,-(sp)
               bsr        protprof
               move.w     #0,-(sp)
               bsr        emphprof
               move.w     #1,-(sp)
               bsr        genprof
               rts        
proffhz48:     move.w     #0,-(sp)
               bsr        protprof
               move.w     #1,-(sp)
               bsr        emphprof
               move.w     #1,-(sp)
               bsr        genprof
               rts        

playstat:      clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $40(a6),d0
               andi.w     #7,d0
               rts        

recstat:       clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $60(a6),d0
               andi.w     #7,d0
               rts        

dspmode:       lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      dspreg(pc),a2
               move.b     (a2),d2
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getdspm
               cmpi.w     #0,d0
               blt        digerr
               cmpi.w     #2,d0
               bgt        digerr
               lea.l      dspart(pc),a3
               move.w     d0,(a3)
               cmpi.w     #0,d0
               beq.s      dspnoc
               cmpi.w     #1,d0
               beq.s      dspswin
               cmpi.w     #2,d0
               beq        dspswout
               clr.l      d0
               rts        
dspnoc:        move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dmarec
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPIN-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
               clr.l      d0
               rts        
dspswin:       move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #3,d0         ; mit DSP-OUT verbinden
               move.w     d0,dmarec
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; mit DSP-OUT verbinden
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPIN-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               andi.w     #$f9,d0
               move.b     d0,(a1)
               move.b     d0,$214(a6)
               clr.l      d0
               rts        
dspswout:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dmarec
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; mit DSP-OUT verbinden
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPIN-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               andi.w     #$f9,d0
               move.b     d0,(a1)
               move.b     d0,$214(a6)
               clr.l      d0
               rts        
getdspm:       clr.l      d0
               lea.l      dspart(pc),a3
               move.w     (a3),d0
               rts        

digsrate:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.b     $80(a6),d0
               asr.w      #6,d0
               andi.w     #2,d0
               bset       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.b     $80(a6),d2
               asr.w      #7,d2
               andi.w     #1,d2
               add.w      d2,d0
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
dighz44:       cmpi.w     #0,d0
               bne.s      dighz48
               moveq.l    #2,d0
               rts        
dighz48:       cmpi.w     #2,d0
               bne.s      dighz32
               moveq.l    #3,d0
               rts        
dighz32:       cmpi.w     #3,d0
               bne.s      dighzerr
               moveq.l    #1,d0
               rts        
dighzerr:      clr.l      d0
               rts        

dspreset:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath1(pc),a1
               move.b     (a1),d1
               bset       #3,d1
               move.b     d1,(a1)
               move.b     d1,$210(a6)
               move.l     #2,d0
               bsr        pause
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$210(a6)
               move.l     #2,d0
               bsr        pause
               clr.l      d0
               rts        

volad:         lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               move.w     (a0)+,d2      ; wert left
               cmpi.w     #-1,d2
               beq.s      getvolad
               move.w     (a0)+,d3      ; wert right
               cmpi.w     #0,d2
               blt        digerr
               cmpi.w     #0,d3
               blt        digerr
               cmpi.w     #255,d2
               bgt        digerr
               cmpi.w     #255,d3
               bgt        digerr
volad2:        move.l     a6,-(sp)
               move.l     d0,-(sp)
               lea.l      adwert(pc),a6
               move.w     d2,d0
               swap.w     d0
               move.w     d3,d0
               move.l     d0,(a6)
               move.l     (sp)+,d0
               movea.l    (sp)+,a6
               bclr       #3,d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bsr        volclk
               move.w     d2,d3
               bsr        volclk
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               clr.l      d0
               rts        
getvolad:      lea.l      adwert(pc),a6
               move.l     (a6),d0
               rts        

volclk:        move.w     #8,d0
volad0:        subi.w     #1,d0
               btst       d0,d3
               bne.s      volad1
               bclr       #4,d1
               bra.s      volad1b
volad1:        bset       #4,d1
volad1b:       move.b     d1,(a1)
               move.b     d1,$80(a6)
               bset       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               cmpi.w     #0,d0
               bne.s      volad0
               rts        

volda:         lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               move.w     (a0)+,d2      ; wert left
               cmpi.w     #-1,d2
               beq.s      getvolda
               move.w     (a0)+,d3      ; wert right
               cmpi.w     #0,d2
               blt        digerr
               cmpi.w     #0,d3
               blt        digerr
               cmpi.w     #255,d2
               bgt        digerr
               cmpi.w     #255,d3
               bgt        digerr
volda2:        move.l     a6,-(sp)
               move.l     d0,-(sp)
               lea.l      dawert(pc),a6
               move.w     d2,d0
               swap.w     d0
               move.w     d3,d0
               move.l     d0,(a6)
               move.l     (sp)+,d0
               movea.l    (sp)+,a6
               bclr       #3,d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #5,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bsr        volclk
               move.w     d2,d3
               bsr        volclk
               bset       #5,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               clr.l      d0
               rts        
getvolda:      lea.l      dawert(pc),a6
               move.l     (a6),d0
               rts        

intact:        lea.l      intreg(pc),a1
               movea.l    pcio2,a6
               lea.l      intelswap(pc),a2
               move.b     (a1),d3
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq.s      getintact
               cmpi.w     #0,d0
               blt        digerr
               cmpi.w     #3,d0
               bgt        digerr
nodintres:     asl.w      #$3,d0
               andi.w     #$8,d0
               andi.w     #$f7,d3
               add.w      d0,d3
               bset       #7,d3
               bset       #0,d3
               bset       #1,d3
               move.b     d3,(a1)
               move.l     d3,(a2)
               bsr        intel
               move.l     (a2),4(a6)
               clr.l      d0
               rts        
getintact:     clr.l      d0
               move.b     (a1),d0
               rts        

dspintact:     lea.l      dintreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq.s      infodspi
               cmpi.w     #0,d0
               blt        digerr
               cmpi.w     #3,d0
               bgt        digerr
               move.b     d0,(a1)
               cmpi.w     #0,d0
               bne.s      dspintgo
               move.b     $1ff(a6),d0
               andi.w     #$fc,d0
               move.b     d0,$1ff(a6)   ; dspint-stop
               bra.s      dspintex
dspintgo:      move.b     #124,$202(a6) ; dsp-intvector
               move.b     $1ff(a6),d1
               andi.w     #$fc,d1
               add.w      d0,d1
               move.b     d1,$1ff(a6)   ; dspint-start
dspintex:      clr.l      d0
               rts        
infodspi:      clr.l      d0
               move.b     (a1),d0
               rts        

dspcommnd:     move.w     (a0)+,d0      ; wert
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               bset       #7,d0
               addi.b     #18,d0
               move.b     d0,$200(a6)
               clr.l      d0
               rts        

dspclear:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $203(a6),d2
               move.b     $204(a6),d2
               move.b     $205(a6),d2
               move.b     $206(a6),d2
               clr.l      d0
               rts        

exclkmode:     move.w     (a0)+,d0      ; wert
               lea.l      exclkm(pc),a2
               cmpi.w     #-1,d0
               beq.s      exclkstat
               move.w     d0,(a2)
               clr.l      d0
               rts        
exclkstat:     move.w     (a2),d0
               rts        

emphasis:      lea.l      hireg(pc),a1
               move.b     (a1),d1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getemph
               cmpi.w     #1,d0
               bgt        digerr
               cmpi.w     #0,d0
               blt        digerr
emphasis2:     lea.l      proff(pc),a2
               move.b     (a2),d2
               btst       #0,d2         ;professional oder consumer ?
               bne.s      profmode
consmode:      cmpi.w     #0,d0
               bne.s      consmod1
               lea.l      empha(pc),a6
               move.w     #0,(a6)
               bclr       #3,d1
               bra.s      consmod2
consmod1:      bset       #3,d1
               lea.l      empha(pc),a6
               move.w     #1,(a6)
consmod2:      move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$40(a6)
               clr.l      d0
               rts        
profmode:      bclr       #3,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$40(a6)
               cmpi.w     #0,d0
               bne.s      profmod1
               lea.l      empha(pc),a6
               move.w     #0,(a6)
               move.w     #1,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               bra.s      profmod2
profmod1:      move.w     #0,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               lea.l      empha(pc),a6
               move.w     #1,(a6)
profmod2:      clr.l      d0
               rts        
getemph:       clr.l      d0
               lea.l      empha(pc),a1
               move.w     (a1),d0
               rts        

digmode:       lea.l      dgmode(pc),a1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getdigmode
               cmpi.w     #1,d0
               bgt        digerr
               cmpi.w     #0,d0
               blt        digerr
               move.w     d0,(a1)
               cmpi.w     #0,d0
               bne.s      digprof
digcons:       lea.l      proffm(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               beq.s      digcons2
               move.w     #0,d1
               move.w     d1,(a1)
               lea.l      cat0(pc),a3
               lea.l      catb0(pc),a4
               move.w     (a4),(a3)
               lea.l      cat1(pc),a3
               lea.l      catb1(pc),a4
               move.w     (a4),(a3)
               lea.l      scms(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        prot
               lea.l      gen(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        genera
               lea.l      cat0(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        categ0
               lea.l      cat1(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        categ1
               lea.l      empha(pc),a6
               move.w     (a6),d0       ; wert
               bsr        emphasis2
digcons2:      lea.l      aesreg(pc),a1
               move.b     (a1),d1
               bclr       #0,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$c0(a6)
               rts        
digprof:       lea.l      proffm(pc),a1
               move.b     #1,(a1)
               rts        
getdigmode:    clr.l      d0
               lea.l      dgmode(pc),a1
               move.w     (a1),d0       ; wert
               rts        

mycopybit:     lea.l      mcbit(pc),a1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getcbit
               cmpi.w     #0,d0
               beq.s      mycopyno
               cmpi.w     #1,d0
               beq.s      mycopyone
               cmpi.w     #2,d0
               beq        mycopyall
               move.l     #-1,d0
               rts        
mycopyno:      move.w     d0,(a1)
               lea.l      proff(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      proffce
               move.w     #1,-(sp)
               bsr        genera
               move.w     #1,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               lea.l      bridg1(pc),a1
               move.w     #0,(a1)
               lea.l      bridg2(pc),a1
               move.w     #0,(a1)
               lea.l      bridge(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      proffce
               move.w     #0,-(sp)
               bsr        copyone
               move.w     #0,-(sp)
               bsr        prot
proffce:       clr.l      d0
               rts        
mycopyone:     move.w     d0,(a1)
               lea.l      proff(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      proffce
               move.w     #0,-(sp)
               bsr        genera
               move.w     #0,-(sp)
               bsr        categ0
               move.w     #0,-(sp)
               bsr        categ1
               lea.l      bridg1(pc),a1
               move.w     #1,(a1)
               lea.l      bridg2(pc),a1
               move.w     #1,(a1)
               lea.l      bridge(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      proffce
               move.w     #1,-(sp)
               bsr        copyone
               move.w     #1,-(sp)
               bsr        prot
               bra.s      proffce
mycopyall:     move.w     d0,(a1)
               lea.l      proff(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      proffce
               move.w     #1,-(sp)
               bsr        genera
               move.w     #1,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               lea.l      bridg1(pc),a1
               move.w     #0,(a1)
               lea.l      bridg2(pc),a1
               move.w     #1,(a1)
               lea.l      bridge(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne        proffce
               move.w     #0,-(sp)
               bsr        copyone
               move.w     #1,-(sp)
               bsr        prot
               bra        proffce
getcbit:       clr.l      d0
               lea.l      mcbit(pc),a1
               move.w     (a1),d0
               rts        

scmsmode:      move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getscms
               cmpi.w     #1,d0
               bgt        digerr
               cmpi.w     #0,d0
               blt        digerr
               bne.s      scmsclr
scmsbridge:    lea.l      bridge(pc),a1
               move.w     #0,(a1)
               lea.l      bridg3(pc),a1
               lea.l      copyobit(pc),a2
               move.w     (a2),(a1)
               lea.l      bridg4(pc),a1
               lea.l      scms(pc),a2
               move.w     (a2),(a1)
               lea.l      copyobit(pc),a2
               move.w     (a2),d1
               move.w     d1,-(sp)
               bsr        copyone
               lea.l      scms(pc),a2
               move.w     (a2),d1
               move.w     d1,-(sp)
               bsr        prot
               clr.l      d0
               rts        
scmsclr:       lea.l      bridge(pc),a1
               move.w     #1,(a1)
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
;               bset       #1,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$c0(a6)
               lea.l      bridg3(pc),a1
               move.w     #1,(a1)
               lea.l      bridg4(pc),a1
               move.w     #0,(a1)
               lea.l      proff(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      scmse
               lea.l      bridg4(pc),a1
               move.w     (a1),d1
               move.w     d1,-(sp)
               bsr        prot
scmse:         clr.l      d0
               rts        
getscms:       clr.l      d0
               lea.l      bridge(pc),a1
               move.w     (a1),d0
               rts        

readsmp:       clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     #256,d1
               move.w     #8,d2
readsmp2:      move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      readsmp3
               dbra       d1,readsmp2
rdsmperr:      move.l     #-1,d0
               rts        
readsmp3:      lea.l      smpwert(pc),a1
               movea.l    a1,a2
               move.b     d0,(a1)+
               move.w     $ff(a6),d0
               btst       d2,d0
               beq.s      readsmp2
               move.b     d0,(a1)+
               move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      rdsmperr
               move.b     d0,(a1)+
               move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      rdsmperr
               move.b     d0,(a1)+
               move.l     a2,d0
               rts        

highsrate:     lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      highsr(pc),a2
               move.w     (a2),d2
               lea.l      modr24(pc),a3
               move.w     (a3),d3
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq.s      gethighs
               cmpi.w     #1,d0
               bgt.s      higherr
               cmpi.w     #0,d0
               blt.s      higherr
               bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               cmpi.w     #0,d0
               bne.s      srateh
sratel:        move.w     #0,(a2)
               cmpi.w     #0,d3
               beq.s      highok
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               clr.l      d0
               rts        
srateh:        bset       #2,d1
               move.w     #1,(a2)
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               cmpi.w     #0,d3
               beq.s      highok
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
highok:        clr.l      d0
               rts        
higherr:       move.l     #-1,d0
               rts        
gethighs:      clr.l      d0
               move.w     d2,d0
               rts        

mode24:        lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      highsr(pc),a2
               move.w     (a2),d2
               lea.l      modr24(pc),a3
               move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq.s      getmod24
               cmpi.w     #1,d0
               bgt.s      errmd24
               cmpi.w     #0,d0
               blt.s      errmd24
               bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               cmpi.w     #0,d0
               bne.s      mdh24
               move.w     #0,(a3)
               cmpi.w     #0,d2
               beq.s      mdcweg
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               clr.l      d0
               rts        
mdh24:         move.w     #1,(a3)
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
mdclr24:       move.b     d1,$c0(a6)
               cmpi.w     #0,d2
               beq.s      mdcweg
               move.b     d1,$c0(a6)
mdcweg:        clr.l      d0
               rts        
errmd24:       move.l     #-1,d0
               rts        
getmod24:      clr.l      d0
               move.w     (a3),d0
               rts        


writesmp:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     #8,d2
               move.w     (a0)+,d0
               move.w     d0,d1
               asr.w      d2,d0
               bset       d2,d0
               move.w     d0,$101(a6)
               bset       d2,d1
               move.w     d1,$101(a6)
               move.w     (a0)+,d0
               move.w     d0,d1
               asr.w      d2,d0
               bclr       d2,d0
               move.w     d0,$ff(a6)
               bclr       d2,d1
               move.w     d1,$ff(a6)
               clr.l      d0
               rts        

read_rlow:     clr.l      d0
               lea.l      lowreg(pc),a1
               move.b     (a1),d0
               rts        

read_rhi:      clr.l      d0
               lea.l      hireg(pc),a1
               move.b     (a1),d0
               rts        

read_raes:     clr.l      d0
               lea.l      aesreg(pc),a1
               move.b     (a1),d0
               rts        

read_rdsp:     clr.l      d0
               lea.l      dspreg(pc),a1
               move.b     (a1),d0
               andi.b     #$3f,d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $80(a6),d1
               andi.b     #$c0,d1
               add.b      d1,d0
               rts        

read_rint:     clr.l      d0
               lea.l      intreg(pc),a1
               move.b     (a1),d0
               rts        

read_dpath1:   clr.l      d0
               lea.l      dsppath1(pc),a1
               move.b     (a1),d0
               rts        

read_dpath2:   clr.l      d0
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               rts        

read_dport:    clr.l      d0
               lea.l      dspport(pc),a1
               move.b     (a1),d0
               rts        

read_dconv:    clr.l      d0
               lea.l      dspconv(pc),a1
               move.b     (a1),d0
               rts        

read_dpdat:    clr.l      d0
               lea.l      dsppdat(pc),a1
               move.b     (a1),d0
               rts        

read_dclk:     clr.l      d0
               lea.l      clkdiv(pc),a1
               move.b     (a1),d0
               rts        

point_dreg:    lea.l      matin(pc),a1
               move.l     a1,d0
               rts        

setconnects2:  lea.l      vmestart,a6
               movea.l    (a6),a6
               move.w     (a0)+,d0
               move.b     dsppath2(pc),d2
               andi.w     #1,d2
               andi.w     #3,d0
               lsl.w      #1,d0
               or.w       d0,d2
               move.w     (a0)+,d0
               move.b     dsppdat(pc),d1
               andi.w     #4,d1
               andi.w     #3,d0
               or.w       d0,d1
               move.w     (a0)+,d0
               andi.w     #1,d0
               lsl.w      #3,d0
               or.w       d0,d1
               move.b     d1,dsppdat
               move.b     d1,$240(a6)
               move.w     (a0)+,d0
               andi.w     #1,d0
               lsl.w      #3,d0
               or.w       d0,d2
               move.b     d2,dsppath2
               move.b     d2,$214(a6)
               clr.l      d0
               rts        


showconnects:  move.w     #13,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               lea.l      matin(pc),a1
               move.w     (a1)+,d0
               cmpi.w     #0,d0
               beq.s      shrec0
               cmpi.w     #1,d0
               beq.s      shrec1
               cmpi.w     #2,d0
               beq.s      shrec2
               lea.l      showt2(pc),a2
               bra.s      showcon2
shrec0:        lea.l      showt0(pc),a2
               bra.s      showcon2
shrec1:        lea.l      showt1(pc),a2
               bra.s      showcon2
shrec2:        lea.l      showt3(pc),a2
showcon2:      move.w     (a1)+,d0
               cmpi.w     #0,d0
               beq.s      shdac0
               cmpi.w     #1,d0
               beq.s      shdac1
               cmpi.w     #2,d0
               beq.s      shdac2
               lea.l      showt2(pc),a3
               bra.s      showcon3
shdac0:        lea.l      showt0(pc),a3
               bra.s      showcon3
shdac1:        lea.l      showt1(pc),a3
               bra.s      showcon3
shdac2:        lea.l      showt3(pc),a3
showcon3:      move.w     (a1)+,d0
               cmpi.w     #0,d0
               beq.s      shxo0
               cmpi.w     #1,d0
               beq.s      shxo1
               cmpi.w     #2,d0
               beq.s      shxo2
               lea.l      showt2(pc),a4
               bra.s      showcon4
shxo0:         lea.l      showt0(pc),a4
               bra.s      showcon4
shxo1:         lea.l      showt1(pc),a4
               bra.s      showcon4
shxo2:         lea.l      showt3(pc),a4
showcon4:      move.l     a2,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showr0(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.l     a4,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showr1(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.l     a3,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showr2(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               btst       #3,d0
               beq.s      shconvn
               lea.l      showcvj(pc),a5
               bra.s      showcon4b
shconvn:       lea.l      showcvn(pc),a5
showcon4b:     lsr.b      #1,d0
               andi.b     #3,d0
               cmpi.w     #0,d0
               beq.s      shbxo0
               cmpi.w     #1,d0
               beq.s      shbxo1
               lea.l      showbt1(pc),a2
               bra.s      showcon5
shbxo0:        lea.l      showbt2(pc),a2
               bra.s      showcon5
shbxo1:        lea.l      showbt3(pc),a2
showcon5:      lea.l      dsppdat(pc),a1
               move.b     (a1),d0
               andi.b     #3,d0
               cmpi.w     #0,d0
               beq.s      shbex0
               cmpi.w     #1,d0
               beq.s      shbex1
               lea.l      showbt3(pc),a3
               bra.s      showcon6
shbex0:        lea.l      showbt1(pc),a3
               bra.s      showcon6
shbex1:        lea.l      showbt2(pc),a3
showcon6:      move.b     (a1),d0
               btst       #3,d0
               beq.s      shbdr0
               lea.l      showbt3(pc),a4
               bra.s      showcon7
shbdr0:        lea.l      showbt1(pc),a4
showcon7:      move.l     a3,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showbr0(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.l     a4,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showbr1(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.l     a2,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showbr2(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.l     a5,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               lea.l      playmod(pc),a3
               move.w     (a3),d0
               move.w     #2,d7
               lsl.w      d0,d7
               cmpi.w     #16,d7
               bne.s      showpnorm
               pea        showpm16(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               bra.s      showcon8
showpnorm:     pea        showpm(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               addi.w     #48,d7
               move.w     d7,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     #32,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
showcon8:      lea.l      recmod(pc),a3
               move.w     (a3),d0
               move.w     #2,d7
               lsl.w      d0,d7
               pea        showrm(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               addi.w     #48,d7
               move.w     d7,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     #32,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               pea        showeadc(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.w     emuladc,d0
               addi.w     #48,d0
               move.w     d0,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     #32,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     modr24,d0
               cmpi.w     #0,d0
               beq.s      showcon9
               pea        showm24(pc)
               bra.s      showcon10
showcon9:      pea        showm16(pc)
showcon10:     move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.w     #13,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               clr.l      d0
               rts        

setconnects1:  move.w     (a0),d0
               cmpi.w     #-1,d0
               beq        point_dreg
               move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     (a0)+,d0
               move.w     d0,dmarec
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     (a0)+,d0
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPCARD-IN-auswahl
               move.w     (a0)+,d0
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
               clr.l      d0
               rts        

wr_dpath1:     move.w     (a0)+,d0
               lea.l      dsppath1(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$210(a6)
               clr.l      d0
               rts        

wr_dpath2:     move.w     (a0)+,d0
               lea.l      dsppath2(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$214(a6)
               clr.l      d0
               rts        

wr_dport:      move.w     (a0)+,d0
               lea.l      dspport(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$212(a6)
               clr.l      d0
               rts        

wr_dconv:      move.w     (a0)+,d0
               lea.l      dspconv(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$216(a6)
               clr.l      d0
               rts        

wr_dpdat:      move.w     (a0)+,d0
               lea.l      dsppdat(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$240(a6)
               clr.l      d0
               rts        

wr_dclk:       move.w     (a0)+,d0
               lea.l      clkdiv(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$242(a6)
               clr.l      d0
               rts        

wr_rlow:       move.w     (a0)+,d0
               lea.l      lowreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,(a6)
               clr.l      d0
               rts        

wr_rhi:        move.w     (a0)+,d0
               lea.l      hireg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$40(a6)
               clr.l      d0
               rts        

wr_raes:       move.w     (a0)+,d0
               lea.l      aesreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$c0(a6)
               clr.l      d0
               rts        

wr_rdsp:       move.w     (a0)+,d0
               lea.l      dspreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$80(a6)
               clr.l      d0
               rts        

wr_rint:       move.w     (a0)+,d0
               lea.l      intreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$280(a6)
               clr.l      d0
               rts        

cardmagic:     clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a6),d0
               andi.w     #$c7,d0
               btst       #6,d0
               beq.s      cardm2
               bset       #3,d0
cardm2:        btst       #7,d0
               beq.s      cardm3
               bset       #4,d0
cardm3:        move.b     $1ff(a6),d1
               cmpi.b     #$ff,d1
               bne.s      cardm4
               move.b     $200(a6),d2
               cmpi.b     #$ff,d2
               bne.s      cardm4
               move.b     $201(a6),d3
               cmpi.b     #$ff,d3
               bne.s      cardm4
               move.b     $202(a6),d4
               cmpi.b     #$ff,d4
               bne.s      cardm4
               move.b     $203(a6),d5
               cmpi.b     #$ff,d5
               bne.s      cardm4
               move.b     $204(a6),d6
               cmpi.b     #$ff,d6
               bne.s      cardm4
               move.b     $205(a6),d7
               cmpi.b     #$ff,d7
               bne.s      cardm4
               move.b     $206(a6),d7
               cmpi.b     #$ff,d7
               beq.s      cardm5
cardm4:        bset       #5,d0
cardm5:        andi.w     #$3f,d0
               lea.l      cardmagc(pc),a1
               move.w     d0,(a1)
               rts        

cardslot:      clr.l      d0
               lea.l      cardz(pc),a1
               move.w     (a1),d0
               rts        

cardsel:       clr.l      d0
               move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq.s      getcard
               lea.l      cardz(pc),a1
               move.w     (a1),d1
               cmp.w      d1,d0
               ble.s      cardsel2
cardsex:       move.l     #-1,d0
               rts        
cardsel2:      cmpi.w     #1,d0
               blt.s      cardsex
cardsel3:      cmpi.w     #4,d0
               bgt.s      cardsex
               lea.l      cardsl(pc),a1
               move.w     d0,(a1)
               clr.l      d1
               move.w     d0,d1
               add.w      d1,d1
               add.w      d1,d1
               subi.w     #4,d1
               lea.l      vmestart(pc),a0
               lea.l      cardlist(pc),a1
               move.l     0(a1,d1.w),(a0)
               bsr        cardadr
               move.l     #0,d0
               rts        
getcard:       clr.l      d0
               lea.l      cardsl(pc),a0
               move.w     (a0),d0
               rts        

cardadr:       lea.l      cadr(pc),a1
               move.l     a1,d0
               lea.l      vmestart(pc),a6
               move.l     (a6),d1
               addi.l     #$ff,d1
               move.l     d1,(a1)+
               move.l     (a6),d1
               addi.l     #$60,d1
               move.l     d1,(a1)+
               move.l     (a6),d1
               addi.l     #$40,d1
               move.l     d1,(a1)+
               move.l     (a6),d1
               addi.l     #$1ff,d1
               move.l     d1,(a1)
               rts        

; ----------------------------Falcon-Routinen-----------------------

locksnd:       lea.l      lock(pc),a1
               move.w     (a1),d1
               tst.w      d1
               beq.s      lockja
               move.l     #-129,d0
               rts        
lockja:        move.w     #1,(a1)
               move.l     #1,d0
               rts        

unlocksnd:     lea.l      lock(pc),a1
               move.w     (a1),d1
               tst.w      d1
               bne.s      unlockja
               move.l     #-128,d0
               rts        
unlockja:      move.w     #0,(a1)
               move.l     #0,d0
               rts        

soundcmd:      move.w     (a0)+,d0
               move.w     (a0)+,d1
               cmpi.w     #0,d0
               beq.s      ltatten
               cmpi.w     #1,d0
               beq.s      rtatten
               cmpi.w     #2,d0
               beq        ltgain
               cmpi.w     #3,d0
               beq        rtgain
               cmpi.w     #4,d0
               beq        addrin
               cmpi.w     #5,d0
               beq        adcinput
               cmpi.w     #6,d0
               beq        setprescale
               clr.l      d0
               rts        
ltatten:       tst.w      d1
               bmi.s      ltstat
               lea.l      ltatt(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               lea.l      ltatt(pc),a2
               move.w     (a2),d2
               asr.w      #2,d2
               andi.w     #$3f,d2
               move.w     #192,d0
               sub.w      d2,d0
               move.w     d0,d2         ; wert left
               lea.l      rtatt(pc),a2
               move.w     (a2),d3
               asr.w      #2,d3
               andi.w     #$3f,d3
               move.w     #192,d0
               sub.w      d3,d0
               move.w     d0,d3         ; wert right
               bsr        volda2
ltstat:        lea.l      ltatt(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
rtatten:       tst.w      d1
               bmi.s      rtstat
               lea.l      rtatt(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               lea.l      ltatt(pc),a2
               move.w     (a2),d2
               asr.w      #2,d2
               andi.w     #$3f,d2
               move.w     #192,d0
               sub.w      d2,d0
               move.w     d0,d2         ; wert left
               lea.l      rtatt(pc),a2
               move.w     (a2),d3
               asr.w      #2,d3
               andi.w     #$3f,d3
               move.w     #192,d0
               sub.w      d3,d0
               move.w     d0,d3         ; wert right
               bsr        volda2
rtstat:        lea.l      rtatt(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
ltgain:        tst.w      d1
               bmi.s      lgstat
               lea.l      lgain(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               lea.l      lgain(pc),a2
               move.w     (a2),d2
               asr.w      #4,d2
               andi.w     #$f,d2
               mulu.w     #3,d2
               bset       #7,d2
               bset       #6,d2         ; wert left
               lea.l      rgain(pc),a2
               move.w     (a2),d3
               asr.w      #4,d3
               andi.w     #$f,d3
               mulu.w     #3,d3
               bset       #7,d3
               bset       #6,d3         ; wert right
               bsr        volad2
lgstat:        lea.l      lgain(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
rtgain:        tst.w      d1
               bmi.s      rgstat
               lea.l      rgain(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               lea.l      lgain(pc),a2
               move.w     (a2),d2
               asr.w      #4,d2
               andi.w     #$f,d2
               mulu.w     #3,d2
               bset       #7,d2
               bset       #6,d2         ; wert left
               lea.l      rgain(pc),a2
               move.w     (a2),d3
               asr.w      #4,d3
               andi.w     #$f,d3
               mulu.w     #3,d3
               bset       #7,d3
               bset       #6,d3         ; wert right
               bsr        volad2
rgstat:        lea.l      rgain(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
addrin:        lea.l      cmdaddr(pc),a1
               tst.w      d1
               bmi        getaddr
               andi.w     #3,d1
               move.w     d1,(a1)
getaddr:       move.w     (a1),d0
               rts        
adcinput:      lea.l      cmdadcinp(pc),a1
               tst.w      d1
               bmi        getadcinp
               andi.w     #3,d1
               move.w     d1,(a1)
getadcinp:     move.w     (a1),d0
               rts        
setprescale:   lea.l      cmdpresc(pc),a1
               tst.w      d1
               bmi        getpresc
               andi.w     #3,d1
               move.w     d1,(a1)
getpresc:      move.w     (a1),d0
               rts        

setbuffer:     move.w     (a0)+,d0
               move.l     (a0)+,d1
               move.l     (a0)+,d2
               cmpi.w     #0,d0
               beq.s      setpbuf
               cmpi.w     #1,d0
               beq.s      setrbuf
               clr.l      d0
               rts        
setpbuf:       lea.l      pbufstrt(pc),a1
               move.l     d1,(a1)
               lea.l      pbufptr(pc),a1
               move.l     d1,(a1)
               lea.l      pbufend(pc),a1
               move.l     d2,(a1)
               clr.l      d0
               rts        
setrbuf:       lea.l      rbufstrt(pc),a1
               move.l     d1,(a1)
               lea.l      rbufptr(pc),a1
               move.l     d1,(a1)
               lea.l      rbufend(pc),a1
               move.l     d2,(a1)
               clr.l      d0
               rts        

setsndmode:    move.w     (a0)+,d1
               lea.l      sndmode(pc),a1
               cmpi.w     #-1,d1
               beq.s      getsndmode
               move.w     d1,(a1)
               clr.l      d0
               rts        
getsndmode:    clr.l      d0
               move.w     (a1),d0
               rts        

settrack:      move.w     (a0)+,d1
               cmpi.w     #-1,d1
               beq.s      gettrack
               move.w     (a0)+,d2
               lea.l      ptracks(pc),a1
               lea.l      rtracks(pc),a2
               move.w     d1,(a1)
               move.w     d2,(a2)
               clr.l      d0
               rts        
gettrack:      lea.l      ptracks(pc),a1
               lea.l      rtracks(pc),a2
               move.w     (a1),d0
               swap.w     d0
               move.w     (a2),d0
               rts        

setmontrack:   lea.l      montrack(pc),a1
               move.w     (a1),d7
               move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq        getmontr
setmontr2:     move.w     d0,(a1)
               cmpi.w     #0,d0
               blt        monterr
               cmpi.w     #3,d0
               bgt        monterr
               move.w     d0,d6
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      playmod(pc),a3
               move.w     (a3),d3
               cmpi.w     #2,d3
               bge.s      isma128
               lea.l      recmod(pc),a3
               move.w     (a3),d3
               cmpi.w     #2,d3
               bge.s      isma128
               bra.s      montok
isma128:       lea.l      aesreg(pc),a1
               move.b     (a1),d1
               btst       #3,d1
               bne.s      ism128
               bclr       #3,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               bset       #3,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
ism128:        cmp.w      d7,d0
               beq.s      montgo
               bgt.s      ism128b
               addi.w     #4,d0
ism128b:       sub.w      d7,d0
               cmpi.w     #0,d0
               beq.s      montgo
               move.b     d1,$c0(a6)
               cmpi.w     #1,d0
               beq.s      montgo
               move.b     d1,$c0(a6)
               cmpi.w     #2,d0
               beq.s      montgo
               move.b     d1,$c0(a6)
montgo:        lea.l      dspconv(pc),a2
               move.b     (a2),d2
               asl.w      #2,d6
               andi.w     #$c,d6
               andi.w     #$f3,d2
               add.b      d6,d2
               move.b     d2,(a2)
               move.b     d2,$216(a6)
montok:        clr.l      d0
               rts        
monterr:       move.l     #-1,d0
               rts        
getmontr:      clr.l      d0
               move.w     d7,d0
               rts        

setinterrupt:  move.w     (a0)+,d1
               cmpi.w     #-1,d1
               beq.s      getints
               lea.l      src_inter(pc),a1
               move.w     d1,(a1)
               move.w     (a0)+,d1
               lea.l      cause(pc),a1
               move.w     d1,(a1)
               clr.l      d0
               rts        
getints:       lea.l      src_inter(pc),a1
               move.w     (a1),d0
               swap.w     d0
               lea.l      cause(pc),a1
               move.w     (a1),d0
               rts        

bufop40:       move.l     $13c,d0
               .DC.w $f4f8              ; flush cache
               move.l     d0,imfpadr+2
               move.l     $134,d0
               .DC.w $f4f8              ; flush cache
               move.l     d0,itimadr+2
               rts        

bufop30:       move.l     $13c,d1
               .DC.w $4e7a              ; get cachereg
               .DC.w 2
               ori.w      #$808,d0      ; flush cache
               .DC.w $4e7b              ; put cachereg
               .DC.w 2
               move.l     d1,imfpadr+2
               move.l     $134,d1
               .DC.w $4e7a              ; get cachereg
               .DC.w 2
               ori.w      #$808,d0      ; flush cache
               .DC.w $4e7b              ; put cachereg
               .DC.w 2
               move.l     d1,itimadr+2
               rts        

buffoper:      lea.l      cookcpu,a4
               cmpi.l     #30,(a4)
               beq.s      bop30
               cmpi.l     #40,(a4)
               beq.s      bop40
               cmpi.l     #60,(a4)
               beq.s      bop40
bop00:         move.l     $13c,d0
               move.l     d0,imfpadr+2
               move.l     $134,d0
               move.l     d0,itimadr+2
               bra.s      boflushed
bop40:         bsr        bufop40
               bra.s      boflushed
bop30:         bsr        bufop30
boflushed:     move.w     (a0)+,d1
               lea.l      bufop(pc),a1
               cmpi.w     #-1,d1
               beq.s      bufopstat
               move.w     d1,(a1)
               btst       #0,d1
               bne.s      fplaystrt
               lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #0,d0         ; play-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               lea.l      pbufptr(pc),a1
               lea.l      pbufstrt(pc),a2
               move.l     (a2),(a1)
buffop2:       btst       #2,d1
               bne        frecstrt
               lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #1,d0         ; rec-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               lea.l      rbufptr(pc),a1
               lea.l      rbufstrt(pc),a2
               move.l     (a2),(a1)
               clr.l      d0
               rts        
bufopstat:     move.w     (a1),d0
               rts        

fplaystrt:     move.w     d1,-(sp)
               lea.l      pbufstrt(pc),a1
               lea.l      von(pc),a2
               move.l     (a1),(a2)
               lea.l      playmod(pc),a6
               move.w     (a6),d0
               cmpi.w     #2,d0
               bge.s      fplaystart2
               lea.l      montrack(pc),a1
               clr.l      d1
               move.w     (a1),d1
               add.w      d1,d1
               add.w      d1,d1
               add.l      d1,(a2)
fplaystart2:   lea.l      pbufend(pc),a1
               lea.l      bis(pc),a2
               move.l     (a1),(a2)
               lea.l      pimode(pc),a2
               move.w     (a6),d0
               cmpi.w     #2,d0
               bge.s      fplaystart3
               move.l     #11,(a2)
fplaystart4:   lea.l      intreg(pc),a1
               move.b     (a1),d0
               bset       #0,d0         ; play-INT-setzen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               move.w     (sp)+,d1
               bra        buffop2
fplaystart3:   move.l     #25,(a2)
               bra.s      fplaystart4

frecstrt:      lea.l      rbufstrt(pc),a1
               lea.l      rvon(pc),a2
               move.l     (a1),(a2)
               lea.l      rbufend(pc),a1
               lea.l      rbis(pc),a2
               move.l     (a1),(a2)
               lea.l      rimode(pc),a2
               lea.l      recmod(pc),a6
               move.w     (a6),d0
               cmpi.w     #2,d0
               beq.s      frecstrt3
               move.l     #12,(a2)
frecstrt4:     lea.l      intreg(pc),a1
               move.b     (a1),d0
               bset       #1,d0         ; rec-INT-setzen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               clr.l      d0
               rts        
frecstrt3:     move.l     #26,(a2)
               bra.s      frecstrt4

dsptristate:   
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath1(pc),a2
               move.b     (a2),d2
               lea.l      dsppath2(pc),a3
               move.b     (a3),d3
               move.w     (a0)+,d0
               move.w     (a0)+,d1
               cmpi.w     #0,d0
               blt.s      trierr
               cmpi.w     #1,d0
               bgt.s      trierr
               cmpi.w     #0,d1
               blt.s      trierr
               cmpi.w     #1,d1
               bgt.s      trierr
               andi.b     #$f9,d2
               cmpi.w     #0,d0
               beq.s      triplay
               addi.b     #6,d2
triplay:       move.b     d2,(a2)
               move.b     d2,$210(a6)
               andi.b     #$fe,d2
               andi.b     #$fe,d3
               cmpi.w     #0,d1
               beq.s      trirec
               addi.b     #1,d2
               addi.b     #1,d3
trirec:        move.b     d2,(a2)
               move.b     d2,$210(a6)
               move.b     d3,(a3)
               move.b     d3,$214(a6)
triweg:        clr.l      d0
               rts        
trierr:        move.l     #-1,d0
               rts        

gpio:          lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d1
               cmpi.w     #1,d1
               beq.s      gprd
               move.w     (a0)+,d2
               cmpi.w     #0,d1
               beq.s      gpdir
               cmpi.w     #2,d1
               beq.s      gpwr
               move.l     #-1,d0
               rts        
gpdir:         lea.l      dspport(pc),a1
               move.b     (a1),d0
               bclr       #3,d0
               move.w     d2,d4
               asl.w      #3,d4
               andi.w     #8,d4
               add.b      d4,d0
               move.b     d0,$212(a6)
               move.b     d0,(a1)
               lea.l      dspconv(pc),a1
               move.b     (a1),d0
               andi.b     #$fc,d0
               asr.w      #1,d2
               andi.w     #3,d2
               add.b      d2,d0
               move.b     d0,$216(a6)
               move.b     d0,(a1)
               clr.l      d0
               rts        
gprd:          move.b     $212(a6),d0
               andi.l     #7,d0
               rts        
gpwr:          lea.l      dspport(pc),a1
               move.b     (a1),d0
               andi.w     #8,d0
               andi.b     #7,d2
               lea.l      gpiodat(pc),a1
               move.w     d2,(a1)
               bsr        gpiofreq
               add.b      d0,d2
               move.b     d2,$212(a6)
               clr.l      d0
               rts        

gpiofreq:      movem.l    d0-d7/a0-a6,-(sp)
               lea.l      srcclk(pc),a0
               move.w     (a0),d0
               cmpi.w     #1,d0
               beq.s      isextclk
               movem.l    (sp)+,d0-d7/a0-a6
               rts        
isextclk:      btst       #2,d2
               bne.s      adatfreq
               btst       #1,d2
               bne.s      adfreq
freqspdif:     lea.l      stack(pc),a0
               move.w     #0,(a0)
               bsr        sclock
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     #0,$242(a6)
               lea.l      stack(pc),a0
               move.w     #0,(a0)
               bsr        digana
               movem.l    (sp)+,d0-d7/a0-a6
               rts        
adfreq:        lea.l      stack(pc),a0
               move.w     #2,(a0)
               btst       #0,d2
               beq.s      adf44
               move.w     #3,(a0)
adf44:         bsr        sclock
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     #0,$242(a6)
               lea.l      stack(pc),a0
               move.w     #1,(a0)
               bsr        digana
               movem.l    (sp)+,d0-d7/a0-a6
               rts        
adatfreq:      lea.l      stack(pc),a0
               move.w     #13,(a0)
               bsr        sclock
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     #0,$242(a6)
               lea.l      stack(pc),a0
               move.w     #1,(a0)
               bsr        digana
               movem.l    (sp)+,d0-d7/a0-a6
               rts        

devconnect:    move.w     (a0)+,d1
               lea.l      src(pc),a1
               move.w     d1,(a1)
               move.w     (a0)+,d2
               lea.l      dst(pc),a1
               move.w     d2,(a1)
               move.w     (a0)+,d3
               lea.l      srcclk(pc),a1
               move.w     d3,(a1)
               move.w     (a0)+,d4
               lea.l      prescale(pc),a1
               move.w     d4,(a1)
               move.w     (a0)+,d5
               lea.l      protocol(pc),a1
               move.w     d5,(a1)
               cmpi.w     #0,d1
               beq        dmaout        ; source ist dmaplay
               cmpi.w     #1,d1
               beq        dspout        ; source ist dsp-transmit
               cmpi.w     #2,d1
               beq        extout        ; source ist ext-input (RDATA)
               cmpi.w     #3,d1
               beq        adout         ; source ist a/d
               move.l     #-1,d0
               rts        
devcone:       lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a3
               move.b     (a3),d3
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               move.w     playmod(pc),d0
               cmpi.w     #1,d0
               beq.s      devc4
               move.w     recmod(pc),d0
               cmpi.w     #1,d0
               bne.s      devcone2
devc4:         move.w     #4,d0
               bsr        matoutsel     ; zu 4Kanal-Mode
devcone2:      lea.l      srcclk(pc),a1
               move.w     (a1),d0
               cmpi.w     #1,d0
               beq.s      srccext
               cmpi.w     #2,d0
               beq.s      clkextall
               lea.l      exclkm(pc),a2
               move.w     (a2),d2
               tst.w      d2
               bne.s      devcfalc
               cmpi.w     #0,d0
               beq.s      srcint
               cmpi.w     #3,d0
               beq.s      clkofalc
               bra.s      srcint
devcfalc:      cmpi.w     #0,d0
               beq.s      clkofalc
               cmpi.w     #3,d0
               beq        srcint
srcint:        lea.l      prescale(pc),a1
               move.w     (a1),d2
               lea.l      stack(pc),a0
               move.w     d2,(a0)
               bsr        sclock
               clr.l      d0
               rts        
srccext:       lea.l      gpiodat(pc),a1
               move.w     (a1),d2
               bsr        gpiofreq
               clr.l      d0
               rts        
clkextall:     lea.l      prescale(pc),a1
               move.w     (a1),d0
               clr.l      d1
               move.w     d0,d1
               divu.w     #15,d1
               andi.l     #3,d1
               move.w     #15,d2
               sub.w      d1,d2         ; sclock-wert
               mulu.w     #15,d1
               sub.w      d1,d0
               cmpi.w     #0,d0
               beq.s      clkea2
               addq.w     #1,d0         ; clkdiv-wert
clkea2:        move.w     d0,-(sp)
               lea.l      stack(pc),a0
               move.w     d2,(a0)
               bsr        sclock
               move.w     (sp)+,d0
               lea.l      stack(pc),a0
               move.w     d0,(a0)
               bsr        clkdivide
               rts        
clkofalc:      lea.l      prescale(pc),a1
               move.w     (a1),d0
               cmpi.w     #0,d0
               beq.s      clkofdig
               addq.w     #1,d0
               lea.l      stack(pc),a0
               move.w     d0,(a0)
               bsr        clkdivide
               lea.l      stack(pc),a0
               move.w     #15,(a0)
               bsr        sclock
               rts        
clkofdig:      lea.l      stack(pc),a0
               move.w     #0,(a0)
               bsr        clkdivide
               lea.l      stack(pc),a0
               move.w     #0,(a0)
               bsr        sclock
               rts        

; Zielkomponente(n) mit DMAPLAY-Source verbinden
dmaout:        lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d7
               btst       #0,d2         ; ist DMAREC unser ziel ?
               bne.s      dmarset       ; wenn ja: DMAPLAY->DMAREC
               cmpi.w     #1,d7         ; DMAREC-quelle ist DMAPLAY(1) gewesen ?
               beq.s      dmamy         ; dann DMAREC-quelle entfernen
               cmpi.w     #0,d7         ; DMAREC-quelle ist geloescht ?
               beq.s      dmamy         ; dann DMAREC-quelle entfernen
               bra.s      dmaout1       ; nÑchstes ziel abfragen
dmamy:         move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #0,d0         ; DMAREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      dmaout1       ; nÑchstes ziel abfragen
dmarset:       move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; externen Matrix_input bestimmen:
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #2,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dmarset1b     ; dann matrix_input von dsp-transmit
               bset       #2,d7         ; sonst matrix_input von matrix_out
dmarset1b:     bclr       #1,d7
               move.b     d7,(a0)
               move.b     d7,$214(a6)   ; externen Matrix_input schreiben
dmaout1:       lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               move.w     (a0),d7
               btst       #1,d2         ; ist DSPREC unser ziel ?
               bne.s      dsprset       ; wenn ja: DMAPLAY->DSPREC
               cmpi.w     #1,d7         ; DSPREC-quelle ist DMAPLAY(1) gewesen ?
; fÅr Trakcom testweise entfernt !
;               beq.s      dmamy2        ; dann DSPREC-quelle entfernen
; fÅr Trakcom testweise entfernt !
               cmpi.w     #0,d7         ; DSPREC-quelle ist geloescht ?
               beq.s      dmamy2        ; dann DSPREC-quelle entfernen
               bra.s      dmaout2       ; nÑchstes ziel abfragen
dmamy2:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; DSPREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      extrec(pc),a0 ; quelle von EXTOUT holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat EXTOUT eine quelle ?
               bne.s      dmaout2       ; wenn ja,nÑchstes ziel abfragen
               move.w     d0,cardrec
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      dmaout2       ; nÑchstes ziel abfragen
dsprset:       move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bclr       #3,d7         ; quelle ist matrix_out
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
dmaout2:       lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     (a0),d7
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               bne.s      extrset       ; wenn ja: DMAPLAY->EXTOUT
               cmpi.w     #1,d7         ; EXTOUT-quelle ist dmaplay(1) gewesen ?
               beq.s      dmamy3        ; dann EXTOUT-quelle entfernen
               cmpi.w     #0,d7         ; EXTOUT-quelle ist geloescht ?
               beq.s      dmamy3        ; dann EXTOUT-quelle entfernen
               bra.s      dmaout3       ; nÑchstes ziel abfragen
dmamy3:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; EXTOUT-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      dsprec(pc),a0 ; quelle von DSPREC holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat DSPREC eine quelle ?
               bne.s      dmaout3       ; wenn ja,nÑchstes ziel abfragen
               move.w     d0,cardrec
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      dmaout3       ; nÑchstes ziel abfragen
extrset:       move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bclr       #1,d7         ; quelle ist Matrix_out
               bclr       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
dmaout3:       lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a0),d7
               btst       #3,d2         ; ist DAC unser ziel ?
               bne.s      dacrset       ; wenn ja: DMAPLAY->DAC
               cmpi.w     #1,d7         ; DAC-quelle ist dmaplay(1) gewesen ?
               beq.s      dmamy4        ; dann DAC-quelle entfernen
               cmpi.w     #0,d7         ; DAC-quelle ist geloescht ?
               beq.s      dmamy4        ; dann DAC-quelle entfernen
               bra        dmaout4       ; nÑchstes ziel abfragen
dmamy4:        move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      dmaout4       ; nÑchstes ziel abfragen
dacrset:       move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #1,d0
               lea.l      playmod(pc),a2
               move.w     (a2),d7       ; playmode holen
               cmpi.w     #2,d7         ; playmode ist Vierkanal oder Stereo ?
               blt.s      dacrsetb      ; dann DMAPLAY->DAC
               move.w     #3,d0         ; sonst Matrix_in->DAC
dacrsetb:      move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; quelle von Matrix_in holen
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #2,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dacrsetb2     ; dann DSP_Transceive->Matrix_in
               bset       #2,d7         ; sonst Matrix_Out->Matrix_in
dacrsetb2:     bclr       #1,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
               lea.l      playmod(pc),a2
               move.w     (a2),d7       ; playmode holen
               cmpi.w     #2,d7         ; playmode ist Vierkanal oder Stereo ?
               blt.s      dmaout4       ; dann nÑchstes ziel abfragen
               move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; quelle DMAPLAY auswÑhlen(Sync/Takt)
               lea.l      extrec(pc),a0 ; als quelle von EXTOUT(ziel) setzen
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; und setzen
dmaout4:       bsr        adc8tst
               bra        devcone       ; fertig und raus hier...

; Zielkomponente(n) mit DSPXMIT-Source verbinden
dspout:        lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d7
               btst       #0,d2         ; ist DMAREC unser ziel ?
               bne.s      dmarset2      ; wenn ja: DSPXMIT->DMAREC
               cmpi.w     #3,d7         ; DMAREC-quelle ist DSPXMIT(3) gewesen ?
               beq.s      dspmy         ; dann DMAREC-quelle entfernen
               cmpi.w     #0,d7         ; DMAREC-quelle ist geloescht ?
               beq.s      dspmy         ; dann DMAREC-quelle entfernen
               bra.s      dspout1       ; nÑchstes ziel abfragen
dspmy:         move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #0,d0         ; DMAREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      dspout1       ; nÑchstes ziel abfragen
dmarset2:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #3,d0         ; mit quelle Matrix_in verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu Matrix_in setzen
               lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung !!!???!!!
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; externen Matrix-input bestimmen:
               bclr       #2,d7         ; dsp_transmit->Matrix_input
               bclr       #1,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
dspout1:       lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               move.w     (a0),d7
               btst       #1,d2         ; ist DSPREC unser ziel ?
               bne.s      dsprset2      ; wenn ja: DSPXMIT->DSPREC
               cmpi.w     #3,d7         ; DSPREC-quelle ist DSPXMIT(3) gewesen ?
               beq.s      dspmy2        ; dann DSPREC-quelle entfernen
               cmpi.w     #0,d7         ; DSPREC-quelle ist geloescht ?
               beq.s      dspmy2        ; dann DSPREC-quelle entfernen
               bra.s      dspout2       ; nÑchstes ziel abfragen
dspmy2:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; DSPREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      extrec(pc),a0 ; quelle von EXTOUT holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat EXTOUT eine quelle ?
               bne.s      dspout2       ; wenn ja,nÑchstes ziel abfragen
               move.w     d0,cardrec
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      dspout2       ; nÑchstes ziel abfragen
dsprset2:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #3,d0         ; mit quelle DSPXMIT verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DSPXMIT setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bclr       #3,d7         ; quelle ist matrix_out
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
dspout2:       lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     (a0),d7
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               bne.s      extrset2      ; wenn ja: DSPXMIT->EXTOUT
               cmpi.w     #3,d7         ; EXTOUT-quelle ist DSPXMIT(3) gewesen ?
               beq.s      dspmy3        ; dann EXTOUT-quelle entfernen
               cmpi.w     #0,d7         ; EXTOUT-quelle ist geloescht ?
               beq.s      dspmy3        ; dann EXTOUT-quelle entfernen
               bra.s      dspout3       ; nÑchstes ziel abfragen
dspmy3:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; EXTOUT-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      dsprec(pc),a0 ; quelle von DSPREC holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat DSPREC eine quelle ?
               bne.s      dspout3       ; wenn ja,nÑchstes ziel abfragen
               move.w     d0,cardrec
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      dspout3       ; nÑchstes ziel abfragen
extrset2:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #3,d0         ; quelle DSPXMIT setzen(vermerk)
               move.w     d0,(a0)       ; und sichern
               move.w     #1,d0
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung DMAPLAY->Matrix_out setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bclr       #1,d7         ; quelle ist DSP_Transmit
               bset       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
dspout3:       lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a0),d7
               btst       #3,d2         ; ist DAC unser ziel ?
               bne.s      dacrset2      ; wenn ja: DSPXMIT->DAC
               cmpi.w     #3,d7         ; DAC-quelle ist DSPXMIT(3) gewesen ?
; fÅr Zero-X testweise entfernt !
;               beq.s      dspmy4        ; dann DAC-quelle entfernen
; fÅr Zero-X testweise entfernt !
               cmpi.w     #0,d7         ; DAC-quelle ist geloescht ?
               beq.s      dspmy4        ; dann DAC-quelle entfernen
               bra.s      dspout4       ; nÑchstes ziel abfragen
dspmy4:        move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      dspout4       ; nÑchstes ziel abfragen
dacrset2:      move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; Matrix_in->DAC
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DSPXMIT setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; quelle von Matrix_in holen
               bclr       #2,d7         ; DSP-Transceive->Matrix_in
               bclr       #1,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
dspout4:       bsr        adc8tst
               bra        devcone       ; fertig und raus hier...

; Zielkomponente(n) mit EXTINP-Source verbinden
extout:        lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d7
               btst       #0,d2         ; ist DMAREC unser ziel ?
               bne.s      dmarset3      ; wenn ja: EXTINP->DMAREC
               cmpi.w     #0,d7         ; DMAREC-quelle ist geloescht ?
               beq.s      extmy         ; dann DMAREC-quelle entfernen
;               cmpi.w     #3,d7         ; DMAREC-quelle ist EXTINP(3) gewesen ?
;               beq.s      extmy         ; dann DMAREC-quelle entfernen
               bra        extout1       ; nÑchstes ziel abfragen
extmy:         move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #0,d0         ; DMAREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      extout1       ; nÑchstes ziel abfragen
dmarset3:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #3,d0         ; mit quelle Matrix_in verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu Matrix_in setzen
               lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; externen Matrix_input bestimmen:
               bclr       #2,d7
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #1,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dmarset3b     ; dann matrix_input von dsp_transmit
               bset       #1,d7         ; sonst matrix_input von EXTINP (RDATA)
dmarset3b:     move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; externen Matrix-input schreiben
extout1:       lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               move.w     (a0),d7
               btst       #1,d2         ; ist DSPREC unser ziel ?
               bne.s      dsprset3      ; wenn ja: EXTINP->DSPREC
               cmpi.w     #3,d7         ; DSPREC-quelle ist EXTINP(3) gewesen ?
               beq.s      extmy2        ; dann DSPREC-quelle entfernen
               cmpi.w     #0,d7         ; DSPREC-quelle ist geloescht ?
               beq.s      extmy2        ; dann DSPREC-quelle entfernen
               bra.s      extout2       ; nÑchstes ziel abfragen
extmy2:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; DSPREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      extrec(pc),a0 ; quelle von EXTOUT holen
               move.w     (a0),d7       ; extout-quelle holen
               cmpi.w     #0,d7         ; hat EXTOUT eine quelle ?
               bne.s      extout2       ; wenn ja,nÑchstes ziel abfragen
               move.w     d0,cardrec
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      extout2       ; nÑchstes ziel abfragen
dsprset3:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bset       #3,d7         ; quelle ist EXTINP
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
extout2:       lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     (a0),d7
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               bne.s      extrset3      ; wenn ja: EXTINP->EXTOUT
               cmpi.w     #0,d7         ; EXTOUT-quelle ist geloescht ?
               beq.s      extmy3        ; dann EXTOUT-quelle entfernen
               lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d0
               cmpi.w     #3,d0         ; DMAREC-quelle ist Matrix_in ?
               beq.s      extout3       ; dann nÑchstes ziel abfragen
               cmpi.w     #3,d7         ; EXTOUT-quelle ist EXTINP(3) gewesen?
               beq.s      extmy3        ; dann EXTOUT-quelle entfernen
               bra.s      extout3       ; nÑchstes ziel abfragen
extmy3:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; EXTOUT-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      dsprec(pc),a0 ; quelle von DSPREC holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat DSPREC eine quelle ?
               bne.s      extout3       ; wenn ja,nÑchstes ziel abfragen
               move.w     d0,cardrec
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      extout3       ; nÑchstes ziel abfragen
extrset3:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #3,d0         ; EXTOUT mit quelle EXTINP verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     #1,d0
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bset       #1,d7         ; quelle ist EXTINP(RDATA)
               bclr       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
extout3:       lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a0),d7
               btst       #3,d2         ; ist DAC unser ziel ?
               bne.s      dacrset3      ; wenn ja: EXTINP->DAC
               cmpi.w     #3,d7         ; DAC-quelle ist EXTINP(3) gewesen ?
               beq.s      extmy4        ; dann DAC-quelle entfernen
               cmpi.w     #0,d7         ; DAC-quelle ist geloescht ?
               beq.s      extmy4        ; dann DAC-quelle entfernen
               bra.s      extout4       ; nÑchstes ziel abfragen
extmy4:        move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      extout4       ; nÑchstes ziel abfragen
dacrset3:      move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; Matrix_in->DAC
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; quelle von Matrix_in holen
               bclr       #2,d7
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #1,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dacrset3b     ; dann DSP_Transceive->Matrix_in
               bset       #1,d7         ; sonst EXTINP->Matrix_in
dacrset3b:     move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
extout4:       bsr        adc8tst
               bra        devcone       ; fertig und raus hier...

adout:         lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d7
               btst       #0,d2         ; ist DMAREC unser ziel ?
               bne.s      dmarset4      ; wenn ja: ADC->DMAREC
               cmpi.w     #2,d7         ; DMAREC-quelle ist ADC(2) gewesen ?
               beq.s      admy          ; dann DMAREC-quelle entfernen
               cmpi.w     #0,d7         ; DMAREC-quelle ist geloescht ?
               beq.s      admy          ; dann DMAREC-quelle entfernen
               bra.s      adout1        ; nÑchstes ziel abfragen
admy:          move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #0,d0         ; DMAREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      adout1        ; nÑchstes ziel abfragen
dmarset4:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC setzen
adout1:        lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               move.w     (a0),d7
               btst       #1,d2         ; ist DSPREC unser ziel ?
               bne.s      dsprset4      ; wenn ja: ADC->DSPREC
               cmpi.w     #2,d7         ; DSPREC-quelle ist ADC(2) gewesen ?
               beq.s      admy2         ; dann DSPREC-quelle entfernen
               cmpi.w     #0,d7         ; DSPREC-quelle ist geloescht ?
               beq.s      admy2         ; dann DSPREC-quelle entfernen
               bra.s      adout2        ; nÑchstes ziel abfragen
admy2:         move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; DSPREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      extrec(pc),a0 ; quelle von EXTOUT holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat EXTOUT eine quelle ?
               bne.s      adout2        ; wenn ja,nÑchstes ziel abfragen
               move.w     d0,cardrec
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      adout2        ; nÑchstes ziel abfragen
dsprset4:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu ADC setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bclr       #3,d7         ; quelle ist matrix_out
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
adout2:        lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     (a0),d7
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               bne.s      extrset4      ; wenn ja: ADC->EXTOUT
               cmpi.w     #2,d7         ; EXTREC-quelle ist ADC(2) gewesen ?
               beq.s      admy3         ; dann EXTOUT-quelle entfernen
               cmpi.w     #0,d7         ; EXTOUT-quelle ist geloescht ?
               beq.s      admy3         ; dann EXTOUT-quelle entfernen
               bra.s      adout3        ; nÑchstes ziel abfragen
admy3:         move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; EXTOUT-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      dsprec(pc),a0 ; quelle von DSPREC holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat DSPREC eine quelle ?
               bne.s      adout3        ; wenn ja,nÑchstes ziel abfragen
               move.w     d0,cardrec
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      adout3        ; nÑchstes ziel abfragen
extrset4:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu ADC setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bclr       #1,d7         ; quelle ist Matrix_out
               bclr       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
adout3:        lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a0),d7
               btst       #3,d2         ; ist DAC unser ziel ?
               bne.s      dacrset4      ; wenn ja: ADC->DAC
               cmpi.w     #2,d7         ; DAC-quelle ist ADC(2) gewesen ?
               beq.s      admy4         ; dann DAC-quelle entfernen
               cmpi.w     #0,d7         ; DAC-quelle ist geloescht ?
               beq.s      admy4         ; dann DAC-quelle entfernen
               bra.s      adout4        ; nÑchstes ziel abfragen
admy4:         move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      adout4        ; nÑchstes ziel abfragen
dacrset4:      move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC
adout4:        bsr        adc8tst
               bra        devcone       ; fertig und raus hier...

adc8tst:       cmpi.w     #2,playmod    ; playmode=Achtkanal?
               bne.s      adctst3       ; wenn nein,fertig und raus hier...
               cmpi.w     #0,recmod     ; recmode=Stereo ?
               bne.s      adctst3       ; wenn nein,fertig und raus hier...
               move.w     dacrec,d7
               cmpi.w     #2,d7         ; quelle von DAC(ziel) holen
               beq.s      adctst1
               move.w     extrec,d7
               cmpi.w     #2,d7         ; quelle von EXTOUT(ziel) holen
;               beq.s      adctst1
               move.w     dsprec,d7
               cmpi.w     #2,d7         ; quelle von DSPREC(ziel) holen
;               beq.s      adctst1       ; nur ADC->DMAREC dann lîschen...
               bra.s      adctst3       ; oder ADC keine Quelle, dann lîschen
adctst1:       lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; gibt es eine Quelle fÅr DMAREC ?
               beq.s      adctst2       ; wenn ja, dann kein ADC-Emulmode
               cmpi.w     #2,d7         ; gibt es eine Quelle fÅr DMAREC ?
               beq.s      adctst2       ; wenn ja, dann kein ADC-Emulmode
               bra.s      adctst4
adctst2:       bsr        initadc8b     ; sonst ADC-EmulMode einschalten
               rts        
adctst3:       bsr        no_emuladc8   ; dann dorthin
adctst4:       rts                      ; fertig und raus hier...

matoutsel:     movem.l    d3/a3/a6,-(sp)
               move.w     d0,matout
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a3
               move.b     (a3),d3
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               cmpi.w     #0,d0
               beq.s      matoutgo
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               cmpi.w     #1,d0
               beq.s      matoutgo
               move.b     d3,$40(a6)
               cmpi.w     #2,d0
               beq.s      matoutgo
               move.b     d3,$40(a6)
               cmpi.w     #3,d0
               beq.s      matoutgo
               move.b     d3,$40(a6)
matoutgo:      movem.l    (sp)+,d3/a3/a6
               rts        

matinsel:      movem.l    d3/a3/a6,-(sp)
               move.l     d7,-(sp)
               lea.l      matin(pc),a6
               move.w     matout,d7
               lsl.w      #1,d7
               subq.w     #2,d7
               cmpi.w     #0,d7
               blt.s      nomatin
               cmpi.w     #8,d7
               bgt.s      nomatin
               move.w     d0,0(a6,d7.w)
nomatin:       move.l     (sp)+,d7
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               andi.w     #$fc,d3
               andi.w     #3,d0
               add.b      d0,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               movem.l    (sp)+,d3/a3/a6
               rts        

sndstatus:     move.w     (a0)+,d1
               cmpi.w     #$dd02,d1
               beq.s      fdicook
               cmpi.w     #1,d1
               beq        frecres
sndstat2:      clr.l      d0
               lea.l      snderr(pc),a1
               move.w     (a1),d0
               bclr       #4,(a1)
               bclr       #5,(a1)
               rts        
fdicook:       move.l     #$4711,d0
               rts        

buffptr:       movea.l    (a0)+,a1
               lea.l      pbufptr(pc),a2
               move.l     (a2),(a1)+
               lea.l      rbufptr(pc),a2
               move.l     (a2),(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)
               clr.l      d0
               rts        

falcplay:      lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      ptracks(pc),a2
               clr.l      d4
               move.w     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      sndmode(pc),a6
               cmpi.w     #0,(a6)       ; sndmode stereo8
               bne.s      ptstereo16
               add.w      d4,d4
ptstereo16:    cmpi.w     #1,(a6)       ; sndmode stereo16
               bne.s      ptmono8
               add.w      d4,d4
               add.w      d4,d4
ptmono8:       move.l     #lfifo,d2     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               asr.w      #3,d2
               subi.w     #1,d2
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               adda.l     #$40,a0
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               adda.l     #$100,a1
               lea.l      pbufptr(pc),a5
               movea.l    a3,a2
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        fplayend
fpfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrf
               lea.l      snderr(pc),a4
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
nowrf:         move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      fpcopyanf
               bra.s      fpfill
fpcopyanf:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
fpcopy:        move.l     d4,-(sp)
               cmpi.w     #0,(a6)       ; sndmode
               beq.s      stereo8
               cmpi.w     #1,(a6)       ; sndmode
               beq.s      stereo16
               cmpi.w     #2,(a6)       ; sndmode
               beq.s      mono8
               bra.s      stereo16
mono8:         move.b     (a2)+,d7      ; MonoKanal,Byte holen
               clr.w      d6
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra.s      fpcopy2
stereo8:       move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               clr.w      d6
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra.s      fpcopy2
stereo16:      move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
fpcopy2:       move.l     (sp)+,d4
               adda.l     d4,a2
               move.l     a2,(a5)       ; Playposition
               cmpa.l     d1,a2
               beq.s      fplayend
               dbra       d0,fpcopy
fp_back:       lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
fplayend:      moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      bufop(pc),a2
               move.w     (a2),d3       ; mode (Bit1=Loop ein/aus) d3
               btst       #1,d3
               beq        fendplay      ; kein loop
               lea.l      pbufstrt(pc),a1
               lea.l      von(pc),a2
               move.l     (a1),(a2)
               lea.l      montrack(pc),a1
               clr.l      d1
               move.w     (a1),d1
               add.w      d1,d1
               add.w      d1,d1
               add.l      d1,(a2)
               lea.l      pbufend(pc),a1
               lea.l      bis(pc),a2
               move.l     (a1),(a2)
               bra.s      intptest
fendplay:      lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #0,d0         ; play-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
intptest:      lea.l      cause(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               beq.s      intee
               btst       #0,d1
               beq.s      intee
               lea.l      src_inter(pc),a1
               move.w     (a1),d1
               btst       #0,d1
               beq.s      timera

mfpint:        movem.l    (sp)+,d0-d7/a0-a6
imfpadr:       jmp        $ffffffff

timera:        movem.l    (sp)+,d0-d7/a0-a6
itimadr:       jmp        $ffffffff

intee:         movem.l    (sp)+,d0-d7/a0-a6
               rte        

falcrec:       lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               adda.l     #$60,a0
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               adda.l     #$ff,a1
               lea.l      rbufptr(pc),a5          ; pointer record
               lea.l      rtracks(pc),a2
               move.w     (a2),d4       ; Anzahl der For/Backstep d4
               mulu.w     #4,d4
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        frecend
franf:         move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      fnordful
               lea.l      snderr(pc),a4
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
fnordful:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      frcopy        ; wenn ja, daten einlesen
               bra.s      franf
frcopy:        move.l     #lfifo,d0     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               divu.w     #8,d0
               subi.w     #1,d0
frcopy2:       move.l     d4,-(sp)
               move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      frcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      frcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      frcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      frcopy3a      ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
frcopy3a:      move.l     (sp)+,d4
               adda.l     d4,a2
               move.l     a2,(a5)       ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      frecend
frcopy3:       dbra       d0,frcopy2
fr_back:       lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; recposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
frecend:       moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Recbyte speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      bufop(pc),a2
               move.w     (a2),d3       ; mode (Bit1=Loop ein/aus) d3
               btst       #3,d3
               beq        fendrec       ; kein loop
               lea.l      rbufstrt(pc),a1
               lea.l      rvon(pc),a2
               move.l     (a1),(a2)
               lea.l      rbufend(pc),a1
               lea.l      rbis(pc),a2
               move.l     (a1),(a2)
               bra.s      intrtest
fendrec:       lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #1,d0         ; rec-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
intrtest:      lea.l      cause(pc),a1
               move.w     (a1),d1
               btst       #1,d1
               beq.s      intee2
               lea.l      src_inter(pc),a1
               move.w     (a1),d1
               btst       #0,d1
               beq        timera
               bra        mfpint
intee2:        movem.l    (sp)+,d0-d7/a0-a6
               rte        

falcplay8:     lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      sndmode(pc),a6
ptmono8b:      move.l     #lfifo,d2     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               asr.w      #5,d2
               subq.w     #1,d2
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               adda.l     #$40,a0
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               adda.l     #$100,a1
               lea.l      pbufptr(pc),a5
               movea.l    a3,a2
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        fplayendb
fpfillb:       move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrfb
               lea.l      snderr(pc),a4
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
nowrfb:        move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      fpcopyanfb
               bra.s      fpfillb
fpcopyanfb:    move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
fpcopyb:       cmpi.w     #0,(a6)       ; sndmode
               beq.s      stereo8b
               cmpi.w     #1,(a6)       ; sndmode
               beq        stereo16b
               cmpi.w     #2,(a6)       ; sndmode
               beq.s      mono8b
               bra        stereo16b
mono8b:        clr.w      d6
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #0,ptracks
               beq        fpcopy2b
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #1,ptracks
               beq        fpcopy2b
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #2,ptracks
               beq        fpcopy2b
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra        fpcopy2b
stereo8b:      clr.w      d6
               move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #0,ptracks
               beq        fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #1,ptracks
               beq        fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #2,ptracks
               beq.s      fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra.s      fpcopy2b
stereo16b:     move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #0,ptracks
               beq.s      fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #1,ptracks
               beq.s      fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #2,ptracks
               beq.s      fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
fpcopy2b:      move.l     a2,(a5)       ; Playposition
               cmpa.l     d1,a2
               beq.s      fplayendb
               dbra       d0,fpcopyb
fp_backb:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
fplayendb:     moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      bufop(pc),a2
               move.w     (a2),d3       ; mode (Bit1=Loop ein/aus) d3
               btst       #1,d3
               beq        fendplayb     ; kein loop
               lea.l      pbufstrt(pc),a1
               lea.l      von(pc),a2
               move.l     (a1),(a2)
               lea.l      pbufend(pc),a1
               lea.l      bis(pc),a2
               move.l     (a1),(a2)
               bra.s      intptestb
fendplayb:     lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #0,d0         ; play-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
intptestb:     lea.l      cause(pc),a1
               move.w     (a1),d1
               btst       #0,d1
               beq.s      inteeb
               lea.l      src_inter(pc),a1
               move.w     (a1),d1
               btst       #0,d1
               beq        timera
               bra        mfpint
inteeb:        movem.l    (sp)+,d0-d7/a0-a6
               rte        

falcrec8:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               adda.l     #$60,a0
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               adda.l     #$ff,a1
               lea.l      rbufptr(pc),a5          ; pointer record
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        frecendb
franfb:        move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      fnordfulb
               lea.l      snderr(pc),a4
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
fnordfulb:     and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      frcopyb       ; wenn ja, daten einlesen
               bra.s      franfb
frcopyb:       move.l     #lfifo,d0     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               divu.w     #8,d0
               subi.w     #1,d0
frcopy2b:      move.w     (a1),d7       ; High-Byte, Kanal1 (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      frcopy3ab     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte, Kanal1 (Bit 8 geloescht ?)...
               btst       d2,d6
               bne.s      frcopy3ab     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      frcopy3ab     ; fehlerhafte Daten ?
               move.b     d7,(a2)+      ; Kanal1-High
               move.b     d6,(a2)+      ; Kanal1-Low
               move.b     d5,(a2)+      ; Kanal2-High
               move.w     (a1),d4
               move.b     d4,(a2)+      ; Kanal2-Low
               move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #0,rtracks
               beq.s      frcopyn0
               move.b     d7,(a2)+      ; Kanal3-High
               move.b     d6,(a2)+      ; Kanal3-Low
               move.b     d5,(a2)+      ; Kanal4-High
               move.b     d4,(a2)+      ; Kanal4-Low
frcopyn0:      move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #1,rtracks
               ble.s      frcopyn1
               move.b     d7,(a2)+      ; Kanal5-High
               move.b     d6,(a2)+      ; Kanal5-Low
               move.b     d5,(a2)+      ; Kanal6-High
               move.b     d4,(a2)+      ; Kanal6-Low
frcopyn1:      move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #2,rtracks
               ble.s      frcopy3ab
               move.b     d7,(a2)+      ; Kanal7-High
               move.b     d6,(a2)+      ; Kanal7-Low
               move.b     d5,(a2)+      ; Kanal8-High
               move.b     d4,(a2)+      ; Kanal8-Low
frcopy3ab:     move.l     a2,(a5)       ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      frecendb
frcopy3b:      dbra       d0,frcopy2b
fr_backb:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; recposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
frecendb:      moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Recbyte speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      bufop(pc),a2
               move.w     (a2),d3       ; mode (Bit1=Loop ein/aus) d3
               btst       #3,d3
               beq        fendrecb      ; kein loop
               lea.l      rbufstrt(pc),a1
               lea.l      rvon(pc),a2
               move.l     (a1),(a2)
               lea.l      rbufend(pc),a1
               lea.l      rbis(pc),a2
               move.l     (a1),(a2)
               bra.s      intrtestb
fendrecb:      lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #1,d0         ; rec-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
intrtestb:     lea.l      cause(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               beq.s      intee2b
               btst       #1,d1
               beq.s      intee2b
               lea.l      src_inter(pc),a1
               move.w     (a1),d1
               btst       #0,d1
               beq        timera
               bra        mfpint
intee2b:       movem.l    (sp)+,d0-d7/a0-a6
               rte        

ihandler_mfp:  rte        

ihandler_tima: rte        

myxbios:       lea.l      Rlist2,a1
               moveq.l    #0,d0
               move.w     (a0),d1
my_Xbios:      cmp.w      0(a1,d0.w),d1
               beq.s      my_found
               addq.w     #2,d0
               tst.w      0(a1,d0.w)
               bne.s      my_Xbios
               rts        
my_found:      mulu.w     #2,d0
               lea.l      R_addr2,a1
               movea.l    0(a1,d0.w),a1
;               suba.l     #neu_Xbios,a1
;               adda.l     $b8,a1
               addq.l     #2,a0
               jsr        (a1)
               rts        

demoxbios:     lea.l      Rlist2,a1
               moveq.l    #0,d0
               move.w     (a0),d1
my_DXbios:     cmp.w      0(a1,d0.w),d1
               beq.s      my_Dfound
               addq.w     #2,d0
               tst.w      0(a1,d0.w)
               bne.s      my_DXbios
               rts        
my_Dfound:     mulu.w     #2,d0
               lea.l      R_addr4,a1
               movea.l    0(a1,d0.w),a1
               addq.l     #2,a0
               jsr        (a1)
               rts        

aidspplay:     lea.l      dvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      dbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      dbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      dbbis(pc),a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      dplaybyte(pc),a4        ; RÅckgabewerte-Liste
               move.l     (a0)+,24(a4)  ; Anfang Playzaehler
               lea.l      dstep(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      dmode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      dfifo(pc),a2
               move.l     #$7ff,(a2)    ; dspbuffer 8192Byte (/4=$7FF)
               btst       #2,d0
               beq.s      nodspmidi
               lea.l      dmidisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
nodspmidi:     lea.l      dmidiw(pc),a2
               move.l     #0,(a2)
               lea.l      dloop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      dcrosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      drimode(pc),a2
               move.l     #0,(a2)
               lea.l      dpimode(pc),a2
               move.l     #13,(a2)
               move.l     a4,d0
               rts        

dspplay:       lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     7(a6),d0
               lea.l      dvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      dbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      dstep(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      dmode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      dfifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      dmidisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               movea.l    a6,a0
               adda.l     #2,a0         ; Adresse DSP-Receive-Status
               movea.l    a6,a1
               adda.l     #4,a1         ; Adresse DSP-Daten
               movea.l    a3,a2
               lea.l      dplaybyte(pc),a6        ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq        dsp_pback
dspcopyanf:    move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
dspcopy:       btst       #2,(a0)       ; DSP empfangsbereit ?
               beq.s      dspcopy
               move.b     (a2)+,1(a1)   ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,2(a1)   ; Rechter Kanal,LowByte senden,A1=0
               move.b     #0,3(a1)
dspcopy2:      btst       #2,(a0)       ; DSP empfangsbereit ?
               beq.s      dspcopy2
               move.b     (a2)+,1(a1)   ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,2(a1)   ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,3(a1)
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               beq.s      dspplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,dspcopy
dsp_pback:     lea.l      dvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
dsp_pback2:    lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dspplayend:    moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      dloop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      dvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #0,d3
               beq.s      dspendplay
               lea.l      dvon(pc),a4
               lea.l      dbvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        dsp_pback2
dspendplay:    lea.l      dplaybyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

dspbreak:      lea.l      cadr(pc),a0
               lea.l      dintreg(pc),a1
               move.b     (a1),d0
               andi.w     #$fc,d0
               movea.l    12(a0),a0     ; Startadresse DSP
               move.b     d0,(a0)       ; Interrupt disabled
               move.b     #146,1(a0)    ; Command Vektor $12
               rts        

dspmix:        move.w     (a0)+,d0      ; Anzahl KanÑle
               cmpi.w     #4,d0
               beq.s      dspmix4
               cmpi.w     #8,d0
               beq        dspmix8
               cmpi.w     #16,d0
               beq        dspmix16
               move.l     #-1,d0
               rts        

dspmix4:       movea.l    (a0)+,a2      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a4      ; zieladresse
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle2adresse
dspaccu:       move.l     (a2)+,(a4)+   ; source1
               move.l     (a3)+,(a4)+   ; source2
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccu
               clr.l      d0
               rts        

dspmix8:       movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
dspaccu8:      move.l     (a1)+,(a5)+   ; source1
               move.l     (a2)+,(a5)+   ; source2
               move.l     (a3)+,(a5)+   ; source3
               move.l     (a4)+,(a5)+   ; source4
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccu8
               clr.l      d0
               rts        

dspmix16:      movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    a5,a6
               adda.l     #16,a6
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
               movea.l    a4,a0
dspaccu16:     move.l     (a1)+,(a5)+   ; source1
               move.l     (a2)+,(a5)+   ; source2
               move.l     (a3)+,(a5)+   ; source3
               move.l     (a4)+,(a5)+   ; source4
               adda.l     #16,a5
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccu16
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a0,a1
               adda.l     d1,a1         ; quelle5adresse
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle6adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle7adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle8adresse
dspaccub16:    move.l     (a1)+,(a6)+   ; source5
               move.l     (a2)+,(a6)+   ; source6
               move.l     (a3)+,(a6)+   ; source7
               move.l     (a4)+,(a6)+   ; source8
               adda.l     #16,a6
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccub16
               clr.l      d0
               rts        

xdplayinit:    lea.l      dvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      dbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      dvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      dbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      dbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      dbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      dplaybyte(pc),a4        ; RÅckgabewerte-Liste
               move.l     (a0)+,24(a4)  ; Anfang Playzaehler
               lea.l      dendcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert dsp
               lea.l      dfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      dstep(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      dmode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      dspmem2b
               lea.l      dmidisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
dspmem2b:      lea.l      dfifo(pc),a2
               move.l     #$7ff,(a2)    ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      dmidiw(pc),a2
               move.l     #0,(a2)
               lea.l      dloop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      dcrosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      drimode(pc),a2
               move.l     #0,(a2)
               lea.l      dpimode(pc),a2
               move.l     #15,(a2)
               move.l     a4,d0
               rts        

dsphbp:        lea.l      cadr(pc),a0
               movea.l    12(a0),a0     ; Startadresse DSP
               move.b     7(a0),d0
               lea.l      dvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      dbis(pc),a2
               move.l     (a2),d2       ; bis d2
               lea.l      dfifo(pc),a2
               move.l     (a2),d0       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               movea.l    a3,a2
               lea.l      dplaybyte(pc),a5        ; RÅckgabewerte-Liste
               cmpa.l     d2,a2
               beq        dsp_back
dspcopy4:      move.b     (a2)+,d7      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d6      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,HighByte holen
dspcope:       btst       #2,2(a0)      ; DSP empfangsbereit ?
               beq.s      dspcope
               move.b     d7,5(a0)      ; Linker Kanal,LowByte
               move.b     d6,6(a0)      ; Linker Kanal,HighByte
               move.b     #0,7(a0)
dspcope2:      btst       #2,2(a0)      ; DSP empfangsbereit ?
               beq.s      dspcope2
               move.b     d5,5(a0)      ; Rechter Kanal,LowByte
               move.b     d4,6(a0)      ; Rechter Kanal,HighByte
               move.b     #0,7(a0)
               addq.l     #4,24(a5)     ; Playposition
               move.l     dendcount(pc),d7
               cmp.l      24(a5),d7
               ble        dspendp4
               cmpa.l     d2,a2
               beq.s      dsplayend
               dbra       d0,dspcopy4
dsp_back:      lea.l      dvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      dplaybyte(pc),a4
dsp_back2:     move.l     a2,(a4)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dsplayend:     lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               lea.l      dvon(pc),a5
               move.l     a2,(a5)       ; Playposition retten
               move.l     4(a4),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      dspmemt1
dspmemt2:      lea.l      dvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      dvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      dbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      dbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a4)      ; Status zweiter Memblock
               bra.s      dspmemte
dspmemt1:      lea.l      dbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      dvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      dbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      dbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a4)      ; Status erster Memblock
dspmemte:      bra        dsp_back2
dspendp4:      lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xplayinit8:    lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      bis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #5,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      emem2b
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
emem2b:        lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      intelswap(pc),a2
               movea.l    pcio2,a3
               move.l     #1,(a2)
               bsr        intel
               move.l     (a2),(a3)     ; enable stream #1
               lea.l      pcimode(pc),a1
               move.l     #2,(a1)
               move.b     #0,$fffffa91  ; interrupt service lîschen
               bset.b     #0,$fffffa89  ; int enable
               bset.b     #0,$fffffa95  ; int mask
               movea.l    pcimem,a0
               move.l     $68(a0),(a2)
               bsr        intel
               move.l     (a2),d0
               bset       #11,d0
               move.l     d0,(a2)
               bsr        intel
               move.l     (a2),$68(a0)
               move.l     a4,d0
               rts        

xmemplay8:     
               lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      pcio2(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$80,a1       ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               clr.l      a6            ; Peak-RÅckgabewert lîschen
               cmpa.l     d1,a2
               beq        ep_back
;epfill:        move.b     (a0),d0       ; FIFO leer ?
;               btst       #0,d0
;               bne.s      enowrlx
;               move.l     strtp(pc),d0
;               cmp.l      24(a5),d0
;               beq.s      enowrlx
;               addi.l     #1,12(a5)     ;Fehler +1
;enowrlx:       move.b     (a0),d0       ; FIFO halbleer ?
;               andi.b     #2,d0
;               bne.s      epcopyanf
;               bra.s      epfill
epcopyanf:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
epcopy:        move.l     (a2)+,$40(a1) ; Linker Kanal,HighByte holen
               move.l     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.l     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.l     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               addq.l     #4,24(a5)     ; Playposition
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        eendplay
               cmpa.l     d1,a2
               beq.s      eplayend
               dbra       d0,epcopy
ep_back:       lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ep_back2:      lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               move.b     #$fe,$fffffa91
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
eplayend:      moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      ememt1
ememt2:        lea.l      von2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      ememte
ememt1:        lea.l      bvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
ememte:        bra        ep_back2
eendplay:      lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xrecinit8:     lea.l      xrch(pc),a2
               move.w     (a0)+,d1      ; Kanalnummer
               move.w     d1,(a2)
               lea.l      rvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      rbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      rvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      rbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      rbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      rendcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #5,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
;               bsr        recreset
               lea.l      rpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #20,(a2)
               move.l     a4,d0
               rts        

xmemrec8:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      xmemre8b
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xmemre8b:      lea.l      rpeakmerk(pc),a2
               clr.l      (a2)
               lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
xranf8:        move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      xnordfu8
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      xnordfu8
               addi.l     #1,12(a5)     ;Fehler +1
xnordfu8:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      xrstrt8       ; wenn ja, daten einlesen
               bra.s      xranf8
xrstrt8:       clr.l      a0            ; Peak pos/neg left lîschen
               clr.l      a3            ; Peak pos/neg right lîschen
               clr.l      a4
xrcopy8:       move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
xrcopy8b:      move.w     (a1),d7       ; High-Byte, Kanal1 (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        xrcopya3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte, Kanal1 (Bit 8 geloescht ?)...
               btst       d2,d6
               bne        xrcopya3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      xrcopya3      ; fehlerhafte Daten ?
               move.w     (a1),d4
               cmpi.w     #0,xrch
               bne.s      xrecm1
               move.b     d7,(a2)+      ; Kanal1-High
               move.b     d6,(a2)+      ; Kanal1-Low
               move.b     d5,(a2)+      ; Kanal2-High
               move.b     d4,(a2)+      ; Kanal2-Low
xrecm1:        move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #1,xrch
               bne.s      xrecm2
               move.b     d7,(a2)+      ; Kanal3-High
               move.b     d6,(a2)+      ; Kanal3-Low
               move.b     d5,(a2)+      ; Kanal4-High
               move.b     d4,(a2)+      ; Kanal4-Low
xrecm2:        move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #2,xrch
               bne.s      xrecm3
               move.b     d7,(a2)+      ; Kanal5-High
               move.b     d6,(a2)+      ; Kanal5-Low
               move.b     d5,(a2)+      ; Kanal6-High
               move.b     d4,(a2)+      ; Kanal6-Low
xrecm3:        move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #3,xrch
               bne.s      xrecm4
               move.b     d7,(a2)+      ; Kanal7-High
               move.b     d6,(a2)+      ; Kanal7-Low
               move.b     d5,(a2)+      ; Kanal8-High
               move.b     d4,(a2)+      ; Kanal8-Low
xrecm4:        addq.l     #4,24(a5)     ; Recposition
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble.s      xendrea2
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      xrweg8
xrcopya3:      dbra       d0,xrcopy8b
xr_back8:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
xr_back8b:     move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xrweg8:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      memra1
memra2:        lea.l      rvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      xr_back8b
memra1:        lea.l      rbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      xr_back8b
xendrea2:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xplayinit16:   lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      bis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      ememb3
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
ememb3:        lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #6,d0

;               asr.w      #3,d0         ; testweise eingefÅgt !!!

               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      intelswap(pc),a2
               movea.l    pcio2,a3
               move.l     #3,(a2)
               bsr        intel
               move.l     (a2),(a3)     ; enable stream #1 and #2
               lea.l      pcimode(pc),a1
               move.l     #3,(a1)
               move.b     #0,$fffffa91  ; interrupt service lîschen
               bset.b     #0,$fffffa89  ; int enable
               bset.b     #0,$fffffa95  ; int mask
               movea.l    pcimem,a0
               move.l     $68(a0),(a2)
               bsr        intel
               move.l     (a2),d0
               bset       #11,d0
               move.l     d0,(a2)
               bsr        intel
               move.l     (a2),$68(a0)
               move.l     a4,d0
               rts        

xmemplay16:    lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      pcio2(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$80,a1       ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               clr.l      a6            ; Peak-RÅckgabewert lîschen
               cmpa.l     d1,a2
               beq        ep_backb
epfill16:                 ;     move.b     (a0),d0       ; FIFO leer ?
;               btst       #0,d0
;               bne.s      enowrlx16
;               move.l     strtp(pc),d0
;               cmp.l      24(a5),d0
;               beq.s      enowrlx16
;               addi.l     #1,12(a5)     ;Fehler +1
enowrlx16:                ;   move.b     (a0),d0       ; FIFO halbleer ?
;               andi.b     #2,d0
;               bne.s      epcopya16
;               bra.s      epfill16
epcopya16:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
epcopy16:      move.l     (a2)+,$40(a1) ; Kanal1 holen
               move.l     (a2)+,(a1)    ; Kanal1 holen
               move.l     (a2)+,(a1)    ; Kanal1 holen
               move.l     (a2)+,(a1)    ; Kanal1 holen
               move.l     (a2)+,(a1)    ; Kanal1 holen
               move.l     (a2)+,(a1)    ; Kanal1 holen
               move.l     (a2)+,(a1)    ; Kanal1 holen
               move.l     (a2)+,(a1)    ; Kanal1 holen
               addq.l     #4,24(a5)     ; Playposition
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        eendplay16
               cmpa.l     d1,a2
               beq.s      eplayend16
               dbra       d0,epcopy16
ep_backb:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ep_backb2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               move.b     #$fe,$fffffa91
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
eplayend16:    moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      ememtb1
ememtb2:       lea.l      von2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      ememte16
ememtb1:       lea.l      bvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
ememte16:      bra        ep_backb2
eendplay16:    lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

idrecpeak:     lea.l      rdvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rdbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rdfifo(pc),a2
               move.l     #$1000,(a2)   ; dspbuffer 16384 (/4=$1000) Byte
;               bsr        recreset
               lea.l      drecbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      dpimode(pc),a2
               move.l     #0,(a2)
               lea.l      drimode(pc),a2
               move.l     #14,(a2)
               move.l     a4,d0
               rts        

dsprecord:     lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #0,(a6)       ; weitere Interrupts sperren
               move.b     6(a6),d0      ; Anforderung lîschen
               move.b     7(a6),d0      ; Anforderung lîschen
               lea.l      rdvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rdbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rdfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               movea.l    a6,a0
               adda.l     #2,a0         ; Adresse DSP-Receive-Status
               movea.l    a6,a1
               adda.l     #4,a1         ; Adresse DSP-Daten
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    #0,a6         ; Peak-RÅckgabewert lîschen
               movea.l    a3,a2
dircopy:       move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
dircopy2:      move.b     #0,2(a1)      ; Daten anfordern
               move.b     #0,3(a1)      ; Daten anfordern
dirlok1:       btst       #0,(a0)       ; DSP empfangsbereit ?
               beq.s      dirlok1
               move.b     1(a1),d7      ; Daten lesen
               move.b     2(a1),d6      ; Daten lesen
               move.b     3(a1),d2      ; Daten lesen
               move.b     #0,2(a1)      ; Daten anfordern
               move.b     #0,3(a1)      ; Daten anfordern
dirlok2:       btst       #0,(a0)       ; DSP empfangsbereit ?
               beq.s      dirlok2
               move.b     1(a1),d5      ; Daten lesen
               move.b     2(a1),d4      ; Daten lesen
               move.b     3(a1),d2      ; Daten lesen
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               move.l     d1,-(sp)
               move.l     a6,d1
               swap.w     d1
               btst       #15,d7
               beq.s      dpnoneg
               not.w      d7
dpnoneg:       cmp.w      d1,d7
               blt.s      dpnoadd
               move.w     d7,d1
dpnoadd:       swap.w     d1
               btst       #15,d5
               beq.s      dpnoneg2
               not.w      d5
dpnoneg2:      cmp.w      d1,d5
               blt.s      dircop2b
               move.w     d5,d1
dircop2b:      movea.l    d1,a6
               move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      dirweg
dircopy3:      dbra       d0,dircopy2
dir_back:      lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
dir_back2:     lea.l      drecbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Recordbyte speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #1,(a6)       ; weitere Interrupts erlauben
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dirweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     a6,16(a5)     ; Peak-RÅckgabewert speichern
               lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xdrecinit:     lea.l      rdvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      rdbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      rdvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      rdbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      rdbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rdbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      rdendcount(pc),a2
               move.l     (a0)+,(a2)    ; Anzahl der FIFO-Blîcke
               lea.l      rdfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rdfifo(pc),a2
               move.l     #$1000,(a2)   ; dspbuffer 16384 (/4=$1000) Byte
               lea.l      rdpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      drecbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      dpimode(pc),a2
               move.l     #0,(a2)
               lea.l      drimode(pc),a2
               move.l     #16,(a2)
               move.l     a4,d0
               rts        

dsphbr:        lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #0,(a6)       ; weitere Interrupts sperren
               move.b     7(a6),d0      ; Anforderung lîschen
               lea.l      rdpeakmerk(pc),a2
               clr.l      (a2)
               lea.l      rdvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rdbis(pc),a2
               move.l     (a2),d1       ; bis d1
               movea.l    a6,a1
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    a3,a2
drstrt:        clr.l      a0            ; Peak pos/neg left lîschen
               clr.l      a3            ; Peak pos/neg right lîschen
               clr.l      a4
drcopy:        move.l     rdfifo(pc),d0 ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
drcopy2:       move.b     #0,7(a1)      ; Daten anfordern
drlok1:        btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      drlok1
               move.b     5(a1),d7      ; Daten lesen
               move.b     6(a1),d6      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.b     #0,7(a1)      ; Daten anfordern
drlok2:        btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      drlok2
               move.b     5(a1),d5      ; Daten lesen
               move.b     6(a1),d4      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.l     d1,-(sp)
               move.w     rdfileart(pc),d1
               cmpi.w     #3,d1
               bne.s      dnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
;               bsr        rpeakcmp
               bra.s      drcope
dnorwave:      move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
;               bsr        rpeakcmp
drcope:        move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               move.l     rdendcount(pc),d7
               cmp.l      24(a5),d7
               ble        dendrec2
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      drweg
drcopy3:       dbra       d0,drcopy2
dr_back:       lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
dr_back2:      move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rdpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rdpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #1,(a6)       ; weitere Interrupts erlauben
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
drweg:         move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      dmemr1
dmemr2:        lea.l      rdvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      dr_back2
dmemr1:        lea.l      rdbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra        dr_back2
dendrec2:      lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rdpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rdpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               move.l     #1,8(a5)      ; Break setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

tdsphbr:       lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #0,(a6)       ; weitere Interrupts sperren
               move.b     7(a6),d0      ; Anforderung lîschen
               lea.l      rdvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rdbis(pc),a2
               movea.l    (a2),a0       ; bis a0
               movea.l    a6,a1
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    a3,a2
tdrcopy:       move.l     rdfifo(pc),d0 ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
tdrcopy2:      move.b     #0,7(a1)      ; Daten anfordern
tdrlok1:       btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      tdrlok1
               move.b     5(a1),d7      ; Daten lesen
               move.b     6(a1),d6      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.b     #0,7(a1)      ; Daten anfordern
tdrlok2:       btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      tdrlok2
               move.b     5(a1),d5      ; Daten lesen
               move.b     6(a1),d4      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.w     rdfileart(pc),d1
               cmpi.w     #3,d1
               bne.s      tdnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bra.s      tdrcope
tdnorwave:     move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
tdrcope:       addq.l     #4,24(a5)     ; Recposition
               move.l     rdendcount(pc),d7
               cmp.l      24(a5),d7
               ble        tdendrec2
               cmpa.l     a0,a2         ; Speicher voll ?
               beq.s      tdrweg
tdrcopy3:      dbra       d0,tdrcopy2
tdr_back:      lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
tdr_back2:     move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #1,(a6)       ; weitere Interrupts erlauben
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
tdrweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      tdmemr1
tdmemr2:       lea.l      rdvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      tdr_back2
tdmemr1:       lea.l      rdbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra        tdr_back2
tdendrec2:     lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               move.l     #1,8(a5)      ; Break setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

aimemrec24:    lea.l      rvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #4,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; nochmal dividiert durch 2
;               bsr        recreset
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #18,(a2)
               move.l     a4,d0
               rts        

imemr24:       lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      imemr24b
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
imemr24b:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
iranf24:       move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      nordfu24
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      nordfu24
               addi.l     #1,12(a5)     ;Fehler +1
nordfu24:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ircopy24      ; wenn ja, daten einlesen
               bra.s      iranf24
ircopy24:      move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ircopy24b:     move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Mid-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d5
               beq.s      ircopy24c     ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               addq.l     #3,24(a5)     ; Recposition
               move.w     (a1),d7       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d7
               bne.s      ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; Mid-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ircopy24c     ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               addq.l     #3,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               bge.s      irweg24
ircopy24c:     dbra       d0,ircopy24b
ir_back24:     lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
ir_back24b:    move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
irweg24:       move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

aimemplay24:   lea.l      von(pc),a2
               move.l     (a0)+,d2      ; von a3
               move.l     d2,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      bis(pc),a2
               move.l     (a0)+,d3      ; bis d1
               move.l     d3,(a2)       ; bis d1
               lea.l      bbis(pc),a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               clr.l      d4
               move.w     (a0)+,d4      ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      nomidi24
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
nomidi24:      lea.l      step(pc),a2
               cmpi.w     #0,d4
               blt        imemperr24
               move.l     d2,d0
               sub.l      d3,d0
               cmpi.l     #0,d0
               beq        imemperr24
               ble.s      impneg24
               mulu.w     #6,d4
               andi.l     #$ffff,d4
               moveq.l    #0,d2
               sub.l      d4,d2
               move.l     d2,d4
               subq.l     #6,d4
               bra.s      impplus24
impneg24:      mulu.w     #6,d4
               andi.l     #$ffff,d4
impplus24:     move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #4,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; dividiert durch 2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      pimode(pc),a2
               move.l     #19,(a2)
               move.l     a4,d0
               rts        
imemperr24:    move.l     #-1,d0
               rts        

imemp24:       lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq.s      ip_back24
ipfill24:      move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrleer24
               move.l     strtp(pc),d0
               cmp.l      24(a6),d0
               beq.s      nowrleer24
               addi.l     #1,12(a6)     ;Fehler +1
nowrleer24:    move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      ipcopyanf24
               bra.s      ipfill24
ipcopyanf24:   cmpi.l     #0,d4
               blt.s      ipcopyn24
               cmpa.l     d1,a2
               bge.s      iplayend24
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopy24:      move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,MidByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,MidByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #6,24(a6)     ; Playposition
               cmpa.l     d1,a2
               bge.s      iplayend24
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,ipcopy24
               bra.s      ip_back24
ipcopyn24:     cmpa.l     d1,a2
               ble.s      iplayend24
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopyb24:     move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,MidByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,MidByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #6,24(a6)     ; Playposition
               cmpa.l     d1,a2
               ble.s      iplayend24
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,ipcopyb24
ip_back24:     lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ip_back224:    lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplayend24:    moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
iplooptst24:   btst       #0,d3
               beq.s      iendplay24
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        ip_back224
iendplay24:    lea.l      playbyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

cblmode:       lea.l      cblm(pc),a1
               move.w     (a0)+,d2      ; cblstatus
               cmpi.w     #-1,d2
               beq.s      getcblm
               cmpi.w     #0,d2
               blt.s      cblerr
               cmpi.w     #1,d2
               bgt.s      cblerr
               move.w     d2,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               lea.l      rec128(pc),a2
               move.b     (a1),d1
               move.w     d1,d0
               bclr       #4,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               cmpi.w     #0,d2
               bne.s      cblja
               tst.w      (a2)
               beq.s      cblweg
               bset       #4,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               bra.s      cblweg
cblja:         asr.w      #4,d0
               andi.w     #1,d0
               move.w     d0,(a2)       ; status rec128 retten
               bset       #4,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
cblweg:        clr.l      d0
               rts        
cblerr:        move.l     #-1,d0
               rts        
getcblm:       clr.l      d0
               move.w     (a1),d0
               rts        

init_cbl:      lea.l      rimode(pc),a2
               move.l     #24,(a2)
               lea.l      cblbits(pc),a2
               move.l     a2,d0
               rts        

cblread:       move.l     #lfifo,d4     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               move.l     #8,d2
               lea.l      cblbits(pc),a2
cblcopy:       asr.w      #1,d4
cblcopy2:      move.w     (a1),d6       ; cbl-anfang (geloescht) ?
               subq.w     #1,d4
               tst.w      d4
               beq.s      cblex
               btst       d2,d6
               bne.s      cblcopy2      ; fehlerhafte Daten ?
cblcopy2b:     move.w     (a1),d6       ; cbl-anfang (geloescht) ?
               subq.w     #1,d4
               tst.w      d4
               beq.s      cblex
               btst       d2,d6
               beq.s      cblcopy2b     ; fehlerhafte Daten ?
               move.b     d6,(a2)+
               move.l     #23,d1
cblcopy3:      move.w     (a1),d6
               subq.w     #1,d4
               tst.w      d4
               beq.s      cblex
               move.b     d6,(a2)+
               dbra       d1,cblcopy3
cblcopy4:      move.w     (a1),d6
               dbra       d4,cblcopy4
cblex:         movem.l    (sp)+,d0-d7/a0-a6
               rte        

recmode:       move.w     (a0)+,d2
               cmpi.w     #-1,d2
               beq        getrmode
               cmpi.w     #0,d2
               blt        rmerr
               cmpi.w     #2,d2
               bgt        rmerr
               lea.l      dsppath2(pc),a3
               move.b     (a3),d3
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               bclr       #3,d3
               lea.l      playmod(pc),a4
               movem.l    d0-d7/a0-a6,-(sp)
               move.w     (a4),d2
               bsr        playmode2
               movem.l    (sp)+,d0-d7/a0-a6
               cmpi.w     #2,d2
               blt.s      qconvm2
               move.w     (a4),d4
               movem.l    d0-d7/a0-a6,-(sp)
               move.w     #2,d2
               bsr        playmode2
               movem.l    (sp)+,d0-d7/a0-a6
               move.w     d4,(a4)
               bra.s      norconvm
qconvm2:       lea.l      playmod(pc),a4
               move.w     (a4),d4
               cmpi.w     #2,d4
               blt.s      norconvm
doconvm:       bset       #3,d3
norconvm:      move.b     d3,(a3)
               move.b     d3,$214(a6)
               lea.l      recmod(pc),a3
               move.w     d2,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      hireg(pc),a3
               move.b     (a3),d3
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               bclr       #0,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               bclr       #4,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               cmpi.w     #0,d2
               beq.s      rmweg
               cmpi.w     #1,d2
               bgt.w      recm2
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               bset       #0,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               bra.s      rmweg
recm2:         bset       #4,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
rmweg:         bsr        adc8tst
               clr.l      d0
               rts        
rmerr:         move.l     #-1,d0
               rts        
getrmode:      clr.l      d0
               lea.l      recmod(pc),a3
               move.w     (a3),d0
               rts        

playmode:      move.w     (a0)+,d2
playmode2:     cmpi.w     #-1,d2
               beq        getpmode
               cmpi.w     #0,d2
               blt        pmerr
               cmpi.w     #3,d2
               bgt        pmerr
               lea.l      dsppath2(pc),a4
               move.b     (a4),d4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               bclr       #3,d4
               cmpi.w     #2,d2
               blt.s      noconvm
               bset       #3,d4
noconvm:       cmpi.w     #1,d2
               bne.s      noconvm2
               bclr       #1,d4
               bclr       #2,d4
noconvm2:      move.b     d4,(a4)
               move.b     d4,$214(a6)
               lea.l      playmod(pc),a3
               move.w     d2,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      hireg(pc),a3
               move.b     (a3),d3
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               bclr       #1,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               bclr       #3,d1
               bclr       #1,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               cmpi.w     #0,d2
               beq.s      pmweg
               cmpi.w     #1,d2
               bgt.w      playm2
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               bset       #1,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               bra.s      pmweg
playm2:        bset       #3,d1
               cmpi.w     #2,d2
               beq.s      noplaym3
               bset       #1,d1
noplaym3:      move.b     d1,$c0(a6)
               move.b     d1,(a1)
               lea.l      montrack(pc),a1
               move.w     (a1),d0
               clr.w      d7
               bsr        setmontr2
pmweg:         bsr        adc8tst
               clr.l      d0
               rts        
pmerr:         move.l     #-1,d0
               rts        
getpmode:      clr.l      d0
               lea.l      playmod(pc),a3
               move.w     (a3),d0
               rts        

dspmem:        lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dspm(pc),a5
               lea.l      dsppdat(pc),a1
               move.b     (a1),d1
               move.w     (a0)+,d2
               cmpi.w     #-1,d2
               beq.s      getdspmem
               move.w     d2,(a5)
               cmpi.w     #0,d2
               beq.s      dmem0
               cmpi.w     #1,d2
               beq.s      dmem1
               move.l     #-1,d0
               rts        
dmem0:         bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$240(a6)
               bra.s      dmweg
dmem1:         bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$240(a6)
dmweg:         clr.l      d0
               rts        
getdspmem:     clr.l      d0
               move.w     (a5),d0
               rts        


clkdivide:     lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      clkdiv(pc),a1
               move.w     (a0)+,d2
               cmpi.w     #-1,d2
               beq.s      getclkdiv
               cmpi.w     #0,d2
               blt.s      clkderr
               cmpi.w     #15,d2
               bgt.s      clkderr
               move.b     d2,(a1)
               move.b     d2,$242(a6)
               clr.l      d0
               rts        
clkderr:       move.l     #-1,d0
               rts        
getclkdiv:     clr.l      d0
               move.b     (a1),d0
               rts        

pathset:       lea.l      dpathw(pc),a2
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath1(pc),a1
               move.w     (a0)+,d2
               cmpi.w     #-1,d2
               beq.s      getpath
               cmpi.w     #0,d2
               blt.s      patherr
               cmpi.w     #15,d2
               bgt.s      patherr
               move.w     d2,(a2)
               move.w     d2,d3
               andi.w     #7,d2
               move.b     (a1),d0
               andi.b     #$f8,d0
               add.b      d2,d0
               move.b     d0,(a1)
               move.b     d0,$210(a6)
               asr.w      #3,d3
               andi.w     #1,d3
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               andi.b     #$fe,d0
               add.b      d3,d0
               move.b     d0,(a1)
               move.b     d0,$214(a6)
               clr.l      d0
               rts        
patherr:       move.l     #-1,d0
               rts        
getpath:       clr.l      d0
               move.w     (a2),d0
               rts        

pcisend:       lea.l      $b0001180,a4
               lea.l      $b00011c0,a3
               move.w     (a0)+,d3
               move.w     (a0)+,d2
               swap.w     d2
               asl.l      #8,d2
               andi.l     #$ff000000,d2
               swap.w     d3
               asl.l      #8,d3
               andi.l     #$ff000000,d3

               lea.l      recbuf(pc),a1
               move.l     d3,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+

               move.l     #63,d0
pcisend2:      lea.l      recbuf(pc),a1
               move.l     (a1)+,(a3)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               dbra       d0,pcisend2
               rts        

pcisendb:      lea.l      $b0001180,a4
               lea.l      $b00011c0,a3
               lea.l      $b0001104,a2
               move.w     (a0)+,d3
               move.w     (a0)+,d2
               swap.w     d2
               asl.l      #8,d2
               andi.l     #$ff000000,d2
               swap.w     d3
               asl.l      #8,d3
               andi.l     #$ff000000,d3
pciwait:       move.l     (a2),d0
               btst       #25,d0
               bne.s      pciwait

               lea.l      recbuf(pc),a1
               move.l     d3,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+

               move.l     #63,d0
pcisendb2:     lea.l      recbuf(pc),a1
               move.l     (a1)+,(a3)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               dbra       d0,pcisendb2
               bra        pciwait

pcisendc:      lea.l      $b0001180,a4
               lea.l      $b00011c0,a3
               lea.l      $b0001104,a2
               lea.l      0,a1
pciwaitc:      move.l     (a2),d0
               btst       #25,d0
               bne.s      pciwaitc

               lea.l      recbuf(pc),a1
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #$01000000,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+

               move.l     #63,d0
pcisendc2:     lea.l      recbuf(pc),a1
               move.l     (a1)+,(a3)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               dbra       d0,pcisendc2
               bra        pciwaitc

pcisearch:     lea.l      $a0000000,a0
               move.l     #$10000,d0
               lea.l      intelswap(pc),a2
               move.w     #3,d4
pcisnext:      movea.l    a0,a1
               adda.l     d0,a1
               move.l     (a1),(a2)
               bsr        intel
               cmpi.l     #$906010b5,(a2)
               beq.s      pcisrch2
               add.l      d0,d0
               dbra       d4,pcisnext
               move.w     #0,foundpci
               clr.l      d0
               rts        
pcisrch2:      move.l     a1,d0
               move.l     d0,config     ; config-space
               move.w     #1,foundpci
               move.b     #3,4(a1)      ; enable cs for mem and io-space
               move.l     $10(a1),(a2)
               bsr        intel
               move.l     #$80000000,d7
               add.l      (a2),d7
               move.l     d7,pcimem
               move.l     $14(a1),(a2)
               bsr        intel
               move.l     #$b0000000,d6
               add.l      (a2),d6
               bclr       #0,d6
               move.l     d6,pcio1
               move.l     $18(a1),(a2)
               bsr        intel
               move.l     #$b0000000,d5
               add.l      (a2),d5
               bclr       #0,d5
               move.l     d5,pcio2
               movea.l    d7,a3
               move.l     #$2000001,(a2)
               bsr        intel
               move.l     (a2),4(a3)    ; remap to /selm
               bsr        pcisetup
               lea.l      config(pc),a0
               move.l     a0,d0
               rts        

pcisetup:      movea.l    pcio2,a3
               move.l     #1,(a2)
               bsr        intel
               move.l     (a2),(a3)
               move.l     #0,4(a3)
               move.l     #$ffffffff,$80(a3)
               move.l     #0,$80(a3)
               move.l     #0,$80(a3)
               move.l     #$07070707,$80(a3)
               move.l     #$83,(a2)
               bsr        intel
               move.l     (a2),4(a3)
               lea.l      intreg(pc),a1
               move.b     #$83,(a1)
               rts        

intel:         move.b     (a2),d2
               move.b     1(a2),d3
               move.b     2(a2),1(a2)
               move.b     3(a2),(a2)
               move.b     d3,2(a2)
               move.b     d2,3(a2)
               rts        

init_pci:      clr.l      d3
               clr.l      d2
               move.w     (a0)+,d3
               move.w     (a0)+,d2
               swap.w     d2
               asl.l      #8,d2
               andi.l     #$ff000000,d2
               swap.w     d3
               asl.l      #8,d3
               andi.l     #$ff000000,d3
               lea.l      recbuf(pc),a1
               move.l     d3,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               move.l     d2,(a1)+
               lea.l      pcimode(pc),a2
               move.l     #1,(a2)
               move.b     #$fe,$fffffa91
               bset.b     #0,$fffffa89
               bset.b     #0,$fffffa95
               lea.l      intelswap(pc),a2
               movea.l    pcimem,a0
               move.l     $68(a0),(a2)
               bsr        intel
               move.l     (a2),d0
               bset       #11,d0
               move.l     d0,(a2)
               bsr        intel
               move.l     (a2),$68(a0)
               clr.l      d0
               rts        

sendpci:       lea.l      $b0001180,a4
               lea.l      $b00011c0,a3
               move.l     #63,d0
sendpci2:      lea.l      recbuf(pc),a1
               move.l     (a1)+,(a3)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               move.l     (a1)+,(a4)
               dbra       d0,sendpci2
               move.b     #$fe,$fffffa91
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_scrub:    lea.l      von(pc),a2
               move.l     (a0)+,(a2)    ; memstart
               lea.l      bbis(pc),a3
               move.l     (a2),(a3)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a2),8(a4)    ; memend
               move.l     #0,(a4)       ; mempos lîschen
               move.l     (a0)+,d0      ; samplerate holen
               move.l     d0,4(a4)      ; samplerate
               lea.l      step(pc),a2
               move.l     #0,(a2)
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      pimode(pc),a2
               move.l     #27,(a2)
               move.l     $4ba,d6       ; 200hz-timer
               lea.l      time(pc),a5
               move.l     d6,(a5)       ; zeit sichern
               move.l     a4,d0
               rts        
iscruberrs:    move.l     #-1,d0
               rts        

scrubbing:     lea.l      von(pc),a2
               movea.l    (a2),a3       ; startwert a3
               lea.l      step(pc),a2
               move.l     (a2),d6
               move.l     a3,d2         ; und startwert d2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
               move.l     8(a6),d1      ; endwert d1
               lea.l      fifo(pc),a5
               move.l     (a5),d5       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               clr.l      d4            ; distance
               lea.l      slowmode(pc),a4
               lea.l      bbis(pc),a5
               cmp.l      (a5),d1
               bne.s      scloopa
               tst.w      (a4)
               beq        iscdifgo
               bra        scrubslgo
scloopa:       clr.w      (a4)
               move.l     d1,(a5)
               move.l     $4ba,d6       ; 200hz-timer
               lea.l      time(pc),a5
               move.l     (a5),d5       ; alte zeit
               move.l     d6,(a5)       ; neue zeit sichern
               sub.l      d5,d6         ; zeitdifferenz
               move.l     d6,(a2)       ; dif sichern
scloop:        move.l     d1,d3         ; und endwert d3
               lea.l      fifo(pc),a5
               move.l     (a5),d5       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               clr.l      d4            ; distance
               move.l     d3,d0
               sub.l      d2,d0
               bmi.s      iscnegdif
               lea.l      slowmode(pc),a5
               move.w     #0,(a5)
               tst.l      d0
               beq        iscdifgo
iscpldif:      move.l     4(a6),d7      ; samplerate
               divu.w     #200,d7       ; /200->ergebnis
               tst.w      d7            ; divide by zero ?
               beq        scrubpslow
               divu.w     d7,d0         ; block/ergebnis
               tst.w      d6            ; divide by zero ?
               beq        scrubpslow
               divu.w     d6,d0         ; /timer
               cmpi.w     #4,d0
               blt        scrubpslow
               andi.l     #$fffc,d0
               move.l     d0,d4
               bra.s      iscdifgo
iscnegdif:     move.l     d2,d0
               sub.l      d3,d0
               move.l     4(a6),d7      ; samplerate
               divu.w     #200,d7       ; /200->ergebnis
               tst.w      d7            ; divide by zero ?
               beq        scrubnslow
               divu.w     d7,d0         ; block/ergebnis
               tst.w      d6            ; divide by zero ?
               beq        scrubnslow
               divu.w     d6,d0         ; /timer
               cmpi.w     #4,d0
               blt.s      scrubnslow
               andi.l     #$fffc,d0
               neg.l      d0
               move.l     d0,d4
iscdifgo:      move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
iscfill:       move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      iscopy1
               bra.s      iscfill
iscopy1:       move.w     d5,d0         ; ...dann FIFO halb-fuellen (fifolen)!
iscopy2:       move.b     (a2),(a5)     ; Linker Kanal,HighByte senden,A1=1
               move.b     1(a2),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(a2),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(a2),(a1)    ; Rechter Kanal,LowByte senden,A1=0
               adda.l     d4,a2
               tst.l      d4
               beq.s      iscopynxt
iscopye:       btst       #31,d4
               beq.s      isistp
               cmpa.l     d1,a2
               ble.s      isc_backv
               bra.s      iscopynxt
isistp:        cmpa.l     d1,a2
               bge.s      isc_backv
iscopynxt:     dbra       d0,iscopy2
               bra.s      isc_back
isc_backv:     movea.l    d1,a2
isc_back:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
isc_back2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
scloop2:       movem.l    (sp)+,d0-d7/a0-a6
               rte        
scrubnslow:    move.l     4(a6),d7      ; samplerate
               divu.w     #50,d7        ; /50->ergebnis
               tst.w      d6            ; divide by zero ?
               beq.s      scrubns1
               divu.w     d6,d0         ; mem/timer>ergebnis2
               andi.l     #$ffff,d7
               tst.w      d0            ; divide by zero ?
               beq.s      scrubns1
               divu.w     d0,d7         ; ergebnis/ergebnis2
               andi.l     #$ffff,d7
               tst.l      d7
               bne.s      scrubns2
scrubns1:      moveq.l    #1,d7
scrubns2:      move.l     d7,d6
               move.l     #4,d4
               neg.l      d4
               bra.s      scrubslgo
scrubpslow:    move.l     4(a6),d7      ; samplerate
               divu.w     #50,d7        ; /50->ergebnis
               tst.w      d6            ; divide by zero ?
               beq.s      scrubps1
               divu.w     d6,d0         ; mem/timer>ergebnis2
               andi.l     #$ffff,d7
               tst.w      d0            ; divide by zero ?
               beq.s      scrubps1
               divu.w     d0,d7         ; ergebnis/ergebnis2
               andi.l     #$ffff,d7
               tst.l      d7
               bne.s      scrubps2
scrubps1:      moveq.l    #1,d7
scrubps2:      move.l     d7,d6
               move.l     #4,d4
scrubslgo:     move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
islfill:       move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      islcopy1
               bra.s      islfill
islcopy1:      lea.l      slowmode(pc),a4
               move.w     #1,(a4)
               move.w     d5,d0         ; ...dann FIFO halb-fuellen (fifolen)!
islcopy2:      move.b     (a2),(a5)     ; Linker Kanal,HighByte senden,A1=1
               move.b     1(a2),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(a2),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(a2),(a1)    ; Rechter Kanal,LowByte senden,A1=0
               subq.l     #1,d6
               tst.l      d6
               bne.s      islnoadd
               adda.l     d4,a2
               cmpa.l     d1,a2
               beq        isc_back
               move.l     d7,d6
islnoadd:      dbra       d0,islcopy2
               bra        isc_back


mtc_mode:      lea.l      mtcmod(pc),a2
               move.w     (a0)+,d7      ; mtc-modus
               cmpi.w     #-1,d7
               beq.s      getmtcm
               cmpi.w     #0,d7
               beq.s      mtcm2
               cmpi.w     #1,d7
               beq.s      mtcm2
               move.l     #-1,d0
               rts        
mtcm2:         move.w     d7,(a2)
               clr.l      d0
               rts        
getmtcm:       clr.l      d0
               move.w     (a2),d0
               rts        

mtc_wait:      move.l     (a0)+,d6      ; wait to frames
               lea.l      framediv(pc),a2
               move.w     (a0)+,d7      ; frames/sec
               move.w     d7,(a2)
               bsr        mtc_clr
mtcw2:         movem.l    d6/d7,-(sp)
mtcw3:         move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               cmpi.l     #0,d0
               bne.s      mtc_break
               move.w     #3,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               cmpi.l     #0,d0
               beq.s      mtcw3
               move.w     #3,-(sp)
               move.w     #2,-(sp)
               trap       #13
               addq.l     #4,sp
               move.l     (sp)+,d6
               bsr        mtc_tim2
               move.l     (sp)+,d7
               btst       #31,d0
               beq.s      mtcw2
               bclr       #31,d0
               cmp.l      d6,d0
               blt.s      mtcw2
               sub.l      d6,d0
               cmpi.l     #10,d0
               bgt.s      mtcw2
               clr.l      d0
               rts        
mtc_break:     move.l     (sp)+,d6
               move.l     (sp)+,d7
               clr.l      d0
               rts        

mtc_time:      lea.l      framediv(pc),a2
               move.w     (a0)+,d7      ; frames/sec
               move.w     d7,(a2)
mtc_tim2:      lea.l      mtclist(pc),a5
               clr.l      d0
               move.b     (a5)+,d0
               move.b     (a5)+,d1
               lsl.b      #4,d1
               add.b      d1,d0         ; ms frames
               clr.l      d1
               move.b     (a5)+,d1
               move.b     (a5)+,d2
               lsl.b      #4,d2
               add.b      d2,d1
               mulu.w     d7,d1
               add.l      d1,d0         ; sekundenframes dazu
               clr.l      d1
               move.b     (a5)+,d1
               move.b     (a5)+,d2
               lsl.b      #4,d2
               add.b      d2,d1
               mulu.w     d7,d1
               mulu.w     #60,d1
               add.l      d1,d0         ; minutenframes dazu
               clr.l      d1
               move.b     (a5)+,d1
               move.b     (a5),d2
               btst       #7,d2         ; Kennung
               beq.s      mtc_tim3
               bset       #31,d0        ; Kennung einfÅgen
               lsl.b      #4,d2
               add.b      d2,d1
               mulu.w     d7,d1
               mulu.w     #60,d1
               mulu.w     #60,d1
               add.l      d1,d0         ; stundenframes dazu
               lea.l      frames(pc),a2
               move.l     d0,(a2)
               move.b     (a5),d2
               bclr       #7,d2
               move.b     d2,(a5)
               rts        
mtc_tim3:      lsl.b      #4,d2
               add.b      d2,d1
               mulu.w     d7,d1
               mulu.w     #60,d1
               mulu.w     #60,d1
               add.l      d1,d0         ; stundenframes dazu
               lea.l      frames(pc),a2
               move.l     d0,(a2)
               rts        

mtc_clr:       movem.l    d1-d7/a0-a6,-(sp)
               lea.l      frames(pc),a2
               clr.l      d0
               move.l     d0,(a2)
               lea.l      mtclist(pc),a6
               move.l     #-1,(a6)
               move.l     #-1,4(a6)
               move.b     d0,7(a6)
               movem.l    (sp)+,d1-d7/a0-a6
               clr.l      d0
               rts        

int_midi:      lea.l      midisprung,a1
               movea.l    (a1),a1
               jsr        (a1)
               lea.l      mtcmod(pc),a2
               move.w     (a2),d6       ; mtc modus
               cmpi.w     #1,d6
               beq.s      intmidi2
               rts        
intmidi2:      lea.l      mword(pc),a5
               cmpi.b     #$f1,d0
               bne.s      miditst
               move.b     d0,(a5)
               rts        
miditst:       move.b     (a5),d1
               cmpi.b     #$f1,d1
               bne.s      miditst2
               move.w     d0,d2
               move.b     d2,d1
               lsr.b      #4,d1
               andi.w     #7,d1         ; locator
               andi.b     #$f,d2        ; wert
               cmpi.b     #7,d1
               bne.s      nomiwo7
               andi.b     #1,d2
               bset       #7,d2         ; Kennung
nomiwo7:       lea.l      mtclist(pc),a6
               move.b     d2,0(a6,d1.w)
miditst2:      clr.w      (a5)
intmiex:       rts        

getfclocks:    lea.l      srcclk(pc),a1
               move.w     (a1),d0
               swap.w     d0
               lea.l      prescale(pc),a1
               move.w     (a1),d0
               rts        

none:          rts        

; ---------------------------Sprungtabelle-----------------------


installed:     
               move.l     #$71273800,d0 ;magic
               rts        

Rlist:         .DC.w 96,97,98,99
               .DC.w 100,101,102,103,104,105,106,107,108,109          ; DSP
               .DC.w 110,111,112,113,114,115,116,117,118,119
               .DC.w 120,121,122,123,124,125,126,127

               .DC.w $80,$81,$82,$83,$84,$85,$86,$87,$88,$89
               .DC.w $8a,$8b,$8c,$8d    ; Falcon-XBIOS

Rlistb:        .DC.w 500  ; my-XBIOS
               .DC.w 0


; Anmerkung: Beim senden oder lesen des DSP wird nur am Anfang getestet
; ob Sende oder Empfangsbereit. Das mag am Falcon gehen, nicht jedoch am Hades
; da der zu schnell ist. Nachfragen ob okay und gegebenenfalls Ñndern !

R_addr:        .DC.l Dsp_DoBlock        ; tested
               .DC.l Dsp_BlkHandShake   ; tested
               .DC.l Dsp_BlkUnpacked    ; tested
               .DC.l Dsp_InStream       ; tested
               .DC.l Dsp_OutStream      ; tested
               .DC.l Dsp_IOStream       ; hauptteil angesehen,scheint okay,int ?
               .DC.l Dsp_RemoveInterrupts         ; tested
               .DC.l Dsp_GetWordSize    ; tested
               .DC.l Dsp_Lock           ; tested
               .DC.l Dsp_Unlock         ; tested
               .DC.l Dsp_Available      ; tested
               .DC.l Dsp_Reserve        ; tested
               .DC.l Dsp_LoadProg       ; tested
               .DC.l Dsp_ExecProg       ; tested
               .DC.l Dsp_ExecBoot       ; tested
               .DC.l Dsp_LodToBinary    ; tested
               .DC.l Dsp_TriggerHC      ; tested
               .DC.l Dsp_RequestUniqueAbility     ; tested
               .DC.l Dsp_GetProgAbility ; tested
               .DC.l Dsp_FlushSubroutines
               .DC.l Dsp_LoadSubroutine
               .DC.l Dsp_InqSubrAbility
               .DC.l Dsp_RunSubroutine
               .DC.l Dsp_Hf0            ; tested
               .DC.l Dsp_Hf1            ; tested
               .DC.l Dsp_Hf2            ; tested
               .DC.l Dsp_Hf3            ; tested
               .DC.l Dsp_BlkWords       ; tested
               .DC.l Dsp_BlkBytes       ; tested
               .DC.l Dsp_HStat          ; tested
               .DC.l Dsp_SetVectors     ; angesehen, scheint okay
               .DC.l Dsp_MultBlocks     ; tested

               .DC.l locksnd            ; sperre Audiosub,tested
               .DC.l unlocksnd          ; freigeben des Audiosub,tested
               .DC.l soundcmd           ; vol-controller,in a/d,vorteiler
               .DC.l setbuffer          ; set play & recbuffer,tested
               .DC.l setsndmode         ; 8bit Stereo/16bit/8bit mono,tested
               .DC.l settrack           ; Kanalzahl
               .DC.l setmontrack        ; playtrack
               .DC.l setinterrupt       ; welcher Int bei play/rec
               .DC.l buffoper           ; rec/play-start,tested
               .DC.l dsptristate        ; Multiplexer abkoppeln
               .DC.l gpio ; DSP-AnschlÅsse setzen,tested
               .DC.l devconnect         ; Multiplexer setzen,tested
               .DC.l sndstatus          ; Codec-init
               .DC.l buffptr            ; rec/play-position,tested

R_addrb:       .DC.l myxbios

Rlist2:        .DC.w 1    ; cookie
               .DC.w 10,11,12,13        ; card
               .DC.w 20,21,22,23,24,25,26,27,28   ; select
               .DC.w 30,31,32,33        ; digital-modes
               .DC.w 40,41,42,43,44,45,46         ; status
               .DC.w 50,51,52,53,54,55  ; vol/exec
               .DC.w 60,61              ; reset
               .DC.w 70,71,72,73,74,75  ; dsp-modes
               .DC.w 100,101            ; mix
               .DC.w 110,111,112,113,114,115,116,117        ; none_int
               .DC.w 120,121,122,123,124,125,126  ; int
               .DC.w 130,131,132,133,134,135      ; peak & int
               .DC.w 140,141,142,143,144          ; halfbuffer
               .DC.w 150  ; peakwert abholen
               .DC.w 160,161,162,163,164,165      ; Falconmode,mtc

               .DC.w 200,201,202,203,204          ; read_reg
               .DC.w 210,211,212,213,214          ; write_reg
               .DC.w 220,221,222,223,224          ; dsp-register lesen
               .DC.w 225,226,227,228,229          ; infos lesen
               .DC.w 230,231,232,233,234,235      ; dsp-register schreiben

               .DC.w 300,301,302,303,304,305,306,307        ; function

               .DC.w 310,311,312        ; pcisend
               .DC.w 320,321

               .DC.w 0    ; end

R_addr2:       .DC.l installed          ; cookie XBIOS-Treiber

               .DC.l cardslot           ; Anzahl Soundkarten im System
               .DC.l cardsel            ; Soundkarte auswaehlen
               .DC.l cardmagic          ; Soundkarten-magic auslesen
               .DC.l cardadr            ; Adressen sample/recstat/playstat/dsp

               .DC.l digana             ; Digital/Analogeingang
               .DC.l digcom             ; Digitalquelle
               .DC.l dspmode            ; dsprouting no/input/output
               .DC.l sclock             ; Samplerate
               .DC.l highsrate          ; samplerate-verdopplung
               .DC.l bypass             ; bypass/sampleplay
               .DC.l recmode            ; rec normal,4ch,8ch
               .DC.l playmode           ; play normal,4ch,8ch,16ch
               .DC.l mode24             ; 16Bit/24Bit

               .DC.l digmode            ; digitaloutput consumer/professional
               .DC.l scmsmode           ; clear copybit fuer Kopierdecoder-mode
               .DC.l mycopybit          ; eigener SCMS-Kopierschutz no/one/all
               .DC.l emphasis           ; de-emphasis

               .DC.l digsrate           ; samplerate-erkennung vom digitalinput
               .DC.l digcode            ; Digitalinput-Aufnahmeart-Code
               .DC.l errorcode          ; Digitalinput-Fehlercode
               .DC.l cblmode            ; set cbl-mode
               .DC.l init_cbl           ; Read 192 Bit Channel Status
               .DC.l recstat            ; rec-FIFO-status
               .DC.l playstat           ; play-FIFO-status

               .DC.l volad              ; volume-controller fuer input
               .DC.l volda              ; volume-controller fuer output
               .DC.l readsmp            ; sample lesen
               .DC.l writesmp           ; sample schreiben
               .DC.l intact             ; interrupt-freigabe fÅr fifo
               .DC.l dspintact          ; interrupt-freigabe fÅr dsp

               .DC.l recreset           ; record-FIFO loeschen
               .DC.l dspreset           ; reset fuer DSP

               .DC.l dspmem             ; 32Kx24,128Kx24 DSP-Memory
               .DC.l clkdivide          ; DSP-Clockdivider
               .DC.l pathset            ; dsp-verbindung zur matrix
               .DC.l dspcommnd          ; dsp-kommando
               .DC.l dspclear           ; dsp-receive auslesen (muell loeschen)
               .DC.l exclkmode          ; extclock-mode ja/nein (25.175 MHz)

               .DC.l mixit              ; mixt 2-8 StereokanÑle (4-16 Tracks)
               .DC.l dspmix             ; mixt 4,8,16 Tracks fuer Falconmode

               .DC.l monitor            ; record&play-bypass
               .DC.l recwait            ; warten auf autorecord-schwellwert
               .DC.l memrec             ; memory-record ohne Interrupt
               .DC.l memplay            ; memory-play ohne Interrupt
               .DC.l recplay            ;!memory record- und play ohne Interrupt
               .DC.l hardrec            ; HD-record ohne Interrupt
               .DC.l hardplay           ; HD-play ohne Interrupt
               .DC.l hrecplay           ;!HD record- und play ohne Interrupt

               .DC.l init_peak          ; peakwert-ausgabe im Interrupt
               .DC.l init_imemrec       ; memory-record im Interrupt
               .DC.l init_imemplay      ; memory-play im Interrupt
               .DC.l init_impmix        ; memory-play mit rec-mix im Interrupt
               .DC.l init_hrec          ; HD-record im Interrupt
               .DC.l init_hplay         ; HD-play im Interrupt
               .DC.l init_ihplaymix     ;!HD-play mit rec-mix im Interrupt

               .DC.l init_mrecpeak      ; memory-rec & peakausgabe im Interrupt
               .DC.l init_mplaypeak     ;!memory-play & peakausgabe im Interrupt
               .DC.l init_mrppeak       ;!mem-play&rec-mix&peakausgabe im Int
               .DC.l init_hrecpeak      ; HD-rec & peakausgabe im Interrupt
               .DC.l init_hplaypeak     ;!HD-play & peakausgabe im Interrupt
               .DC.l init_hrppeak       ;!HD-play&rec-mix&peakausgabe im Int

               .DC.l init_xmemrec       ; record im HalfBuffer-System
               .DC.l init_xmemplay      ; play im HalfBuffer-System
               .DC.l init_xmixplay      ; play&mix-rec im HalfBuffer-System
               .DC.l init_xmemr4        ; 4Ch-mode rec im HalfBuffer-System
               .DC.l init_xmemp4        ; 4Ch-mode play im HalfBuffer-System

               .DC.l peakread           ; aktuellen peakwert abholen

               .DC.l compatible         ; Falcon-TOS (emulation) ja/nein
               .DC.l mtc_clr            ; mtc-framezaehler loeschen
               .DC.l mtc_mode           ; midi-timecode erzeugung an/aus
               .DC.l mtc_time           ; midi-frames holen
               .DC.l mtc_wait           ; auf mtc-framewert warten
               .DC.l init_emuladc8      ; Emulation ADC64->DAC128

               .DC.l read_rlow          ; low-register lesen
               .DC.l read_rhi           ; high-register lesen
               .DC.l read_rdsp          ; dsp-register lesen
               .DC.l read_raes          ; aes-register lesen
               .DC.l read_rint          ; interrupt-register lesen

               .DC.l wr_rlow            ; low-register schreiben
               .DC.l wr_rhi             ; high-register schreiben
               .DC.l wr_rdsp            ; dsp-register schreiben
               .DC.l wr_raes            ; aes-register schreiben
               .DC.l wr_rint            ; interrupt-register schreiben

               .DC.l read_dpath1        ; dsppfad1-register lesen
               .DC.l read_dpath2        ; dsppfad2-register lesen
               .DC.l read_dport         ; dsp-port-register lesen
               .DC.l read_dconv         ; dsp-convert-register lesen
               .DC.l read_dpdat         ; dsp-pdat-register lesen
               .DC.l read_dclk          ; dsp-clkdiv-register lesen
               .DC.l setconnects1       ; read/write matrixwerte StarTrack
               .DC.l setconnects2       ; read/write matrixwerte dsp
               .DC.l showconnects       ; Ausgabe der matrixwerte u.a.
               .DC.l getfclocks         ; Ausgabe der devconnect-clocks

               .DC.l wr_dpath1          ; dsppfad1-register schreiben
               .DC.l wr_dpath2          ; dsppfad2-register schreiben
               .DC.l wr_dport           ; dsp-port-register schreiben
               .DC.l wr_dconv           ; dsp-convert-register schreiben
               .DC.l wr_dpdat           ; dsp-pdat-register schreiben
               .DC.l wr_dclk            ; dsp-clkdiv-register schreiben

               .DC.l fastcut            ; speicherbereich loeschen im samplemem
               .DC.l peaksuch           ; peakwert-suche im samplemem
               .DC.l zerono             ; nullstellen-suche im samplemem
               .DC.l fading             ; sample-fading im samplemem
               .DC.l muster             ; speicherbereich mit Muster fÅllen
               .DC.l testbits           ; RAM->bitmuster (1,2..$80000000) fÅllen
               .DC.l speedtst           ; testet Interface-speed
               .DC.l init_scrub         ; scrubbing

               .DC.l pcisend
               .DC.l pcisendb
               .DC.l pcisendc

               .DC.l pcisearch
               .DC.l init_pci


Rlist3:        .DC.w 500  ; my-XBIOS
               .DC.w 0
R_addr3:       .DC.l demoxbios

R_addr4:       .DC.l installed          ; cookie XBIOS-Treiber

               .DC.l cardslot           ; Anzahl Soundkarten im System
               .DC.l none ; Soundkarte auswaehlen
               .DC.l none ; Soundkarten-magic auslesen
               .DC.l none ; Adressen sample/recstat/playstat/dsp

               .DC.l none ; Digital/Analogeingang
               .DC.l none ; Digitalquelle
               .DC.l none ; dsprouting no/input/output
               .DC.l none ; Samplerate
               .DC.l none ; samplerate-verdopplung
               .DC.l none ; bypass/sampleplay
               .DC.l none ; rec normal,4ch,8ch
               .DC.l none ; play normal,4ch,8ch,16ch
               .DC.l none ; 16Bit/24Bit

               .DC.l none ; digitaloutput consumer/professional
               .DC.l none ; clear copybit fuer Kopierdecoder-mode
               .DC.l none ; eigener SCMS-Kopierschutz no/one/all
               .DC.l none ; de-emphasis

               .DC.l none ; samplerate-erkennung vom digitalinput
               .DC.l none ; Digitalinput-Aufnahmeart-Code
               .DC.l none ; Digitalinput-Fehlercode
               .DC.l none ; set cbl-mode
               .DC.l none ; Read 192 Bit Channel Status
               .DC.l none ; rec-FIFO-status
               .DC.l none ; play-FIFO-status

               .DC.l none ; volume-controller fuer input
               .DC.l none ; volume-controller fuer output
               .DC.l none ; sample lesen
               .DC.l none ; sample schreiben
               .DC.l none ; interrupt-freigabe fÅr fifo
               .DC.l none ; interrupt-freigabe fÅr dsp

               .DC.l none ; record-FIFO loeschen
               .DC.l none ; reset fuer DSP

               .DC.l none ; 32Kx24,128Kx24 DSP-Memory
               .DC.l none ; DSP-Clockdivider
               .DC.l none ; dsp-verbindung zur matrix
               .DC.l none ; dsp-kommando
               .DC.l none ; dsp-receive auslesen (muell loeschen)
               .DC.l none ; extclock-mode ja/nein (25.175 MHz)

               .DC.l mixit              ; mixt 2-8 StereokanÑle (4-16 Tracks)
               .DC.l dspmix             ; mixt 4,8,16 Tracks fuer Falconmode

               .DC.l none ; record&play-bypass
               .DC.l none ; warten auf autorecord-schwellwert
               .DC.l none ; memory-record ohne Interrupt
               .DC.l none ; memory-play ohne Interrupt
               .DC.l none ;!memory record- und play ohne Interrupt
               .DC.l none ; HD-record ohne Interrupt
               .DC.l none ; HD-play ohne Interrupt
               .DC.l none ;!HD record- und play ohne Interrupt

               .DC.l none ; peakwert-ausgabe im Interrupt
               .DC.l none ; memory-record im Interrupt
               .DC.l none ; memory-play im Interrupt
               .DC.l none ; memory-play mit rec-mix im Interrupt
               .DC.l none ; HD-record im Interrupt
               .DC.l none ; HD-play im Interrupt
               .DC.l none ;!HD-play mit rec-mix im Interrupt

               .DC.l none ; memory-rec & peakausgabe im Interrupt
               .DC.l none ;!memory-play & peakausgabe im Interrupt
               .DC.l none ;!mem-play&rec-mix&peakausgabe im Int
               .DC.l none ; HD-rec & peakausgabe im Interrupt
               .DC.l none ;!HD-play & peakausgabe im Interrupt
               .DC.l none ;!HD-play&rec-mix&peakausgabe im Int

               .DC.l none ; record im HalfBuffer-System
               .DC.l none ; play im HalfBuffer-System
               .DC.l none ; play&mix-rec im HalfBuffer-System
               .DC.l none ; 4Ch-mode rec im HalfBuffer-System
               .DC.l none ; 4Ch-mode play im HalfBuffer-System

               .DC.l none ; aktuellen peakwert abholen

               .DC.l none ; Falcon-TOS (emulation) ja/nein
               .DC.l mtc_clr            ; mtc-framezaehler loeschen
               .DC.l mtc_mode           ; midi-timecode erzeugung an/aus
               .DC.l mtc_time           ; midi-frames holen
               .DC.l mtc_wait           ; auf mtc-framewert warten
               .DC.l none ; Emulation ADC64->DAC128

               .DC.l none ; low-register lesen
               .DC.l none ; high-register lesen
               .DC.l none ; dsp-register lesen
               .DC.l none ; aes-register lesen
               .DC.l none ; interrupt-register lesen

               .DC.l none ; low-register schreiben
               .DC.l none ; high-register schreiben
               .DC.l none ; dsp-register schreiben
               .DC.l none ; aes-register schreiben
               .DC.l none ; interrupt-register schreiben

               .DC.l none ; dsppfad1-register lesen
               .DC.l none ; dsppfad2-register lesen
               .DC.l none ; dsp-port-register lesen
               .DC.l none ; dsp-convert-register lesen
               .DC.l none ; dsp-pdat-register lesen
               .DC.l none ; dsp-clkdiv-register lesen
               .DC.l none ; read/write matrixwerte StarTrack
               .DC.l none ; read/write matrixwerte dsp
               .DC.l showconnects       ; Ausgabe der matrixwerte u.a.
               .DC.l getfclocks         ; Ausgabe der devconnect-clocks

               .DC.l none ; dsppfad1-register schreiben
               .DC.l none ; dsppfad2-register schreiben
               .DC.l none ; dsp-port-register schreiben
               .DC.l none ; dsp-convert-register schreiben
               .DC.l none ; dsp-pdat-register schreiben
               .DC.l none ; dsp-clkdiv-register schreiben

               .DC.l fastcut            ; speicherbereich loeschen im samplemem
               .DC.l peaksuch           ; peakwert-suche im samplemem
               .DC.l zerono             ; nullstellen-suche im samplemem
               .DC.l fading             ; sample-fading im samplemem
               .DC.l muster             ; speicherbereich mit Muster fÅllen
               .DC.l testbits           ; RAM->bitmuster (1,2..$80000000) fÅllen
               .DC.l none ; testet Interface-speed
               .DC.l none ; scrubbing

               .DATA 
               .EVEN 
newcook:       .DC.l 0,40
               .DCB.l 78,0
magic:         .DC.l $12233445
               .EVEN 
matin:         .DC.w 0,0,0,0
lowreg:        .DC.b 0
hireg:         .DC.b 0
aesreg:        .DC.b 0
dspreg:        .DC.b 0
dsppath1:      .DC.b 0
dspport:       .DC.b 0
dspconv:       .DC.b 0
dsppdat:       .DC.b 0
dsppath2:      .DC.b 0
clkdiv:        .DC.b 0
               .EVEN 
dmarec:        .DC.w 0
dsprec:        .DC.w 0
extrec:        .DC.w 0
dacrec:        .DC.w 0
cardrec:       .DC.w 0
playmod:       .DC.w 0
recmod:        .DC.w 0
smpte:         .DC.b 0
intreg:        .DC.b 0
dintreg:       .DC.b 0
               .EVEN 
dspart:        .DC.w 0
proff:         .DC.w 0
proffm:        .DC.w 0
bridg1:        .DC.w 0
bridg2:        .DC.w 0
bridg3:        .DC.w 0
bridg4:        .DC.w 0
bridge:        .DC.w 0
cat0:          .DC.w 0
catb0:         .DC.w 0
cat1:          .DC.w 0
catb1:         .DC.w 0
gen:           .DC.w 0
copyobit:      .DC.w 0
scms:          .DC.w 0
empha:         .DC.w 0
dpathw:        .DC.w 0
cblm:          .DC.w 0
hz:            .DC.w 0
rec128:        .DC.w 0
pcimode:       .DC.l 0
rimode:        .DC.l 0
pimode:        .DC.l 0
adwert:        .DC.l 0
dawert:        .DC.l 0
asrc:          .DC.w 0
dsrc:          .DC.w 0
cmdaddr:       .DC.w 0
cmdadcinp:     .DC.w 0
cmdpresc:      .DC.w 0
mcbit:         .DC.w 0
dspm:          .DC.w 0
falcmode:      .DC.w 0
dgmode:        .DC.w 0
drimode:       .DC.l 0
dpimode:       .DC.l 0
int_reg:       .DC.l 0
vmestart:      .DC.l 0
vmemask:       .DC.l 0
strtp:         .DC.l 0
sclockv:       .DC.b $d4,84,208,148,80,20,144,16,116,112,52,48
falctab:       .DC.b 0,3,2,1,11,10,9,8,7,6,5,4,15,14,13,12
cblbits:       .DS.b 2400
cardlist:      .DS.l 8
oldval:        .DS.l 1
berrsprung:    .DS.l 1
midisprung:    .DS.l 1
mword:         .DC.b 0,0
smpwert:       .DS.l 1
cardz:         .DC.w 0
cardsl:        .DC.w 0
cadr:          .DS.l 4
pos:           .DS.l 1
rpos:          .DS.l 1
von:           .DS.l 1
bvon:          .DS.l 1
rvon:          .DS.l 1
rbvon:         .DS.l 1
bis:           .DS.l 1
bbis:          .DS.l 1
rbis:          .DS.l 1
rbbis:         .DS.l 1
von2:          .DS.l 1
bis2:          .DS.l 1
rvon2:         .DS.l 1
rbis2:         .DS.l 1
dvon:          .DS.l 1
rdvon:         .DS.l 1
dbvon:         .DS.l 1
rdbvon:        .DS.l 1
dvon2:         .DS.l 1
rdvon2:        .DS.l 1
dbis2:         .DS.l 1
rdbis2:        .DS.l 1
dbis:          .DS.l 1
rdbis:         .DS.l 1
dbbis:         .DS.l 1
rdbbis:        .DS.l 1
len:           .DS.l 1
rlen:          .DS.l 1
step:          .DS.l 1
mode:          .DS.l 1
dstep:         .DS.l 1
dmode:         .DS.l 1
fifo:          .DS.l 1
rfifo:         .DS.l 1
dfifo:         .DS.l 1
rdfifo:        .DS.l 1
stath:         .DS.l 1
regh:          .DS.l 1
playread:      .DS.l 1
playstart:     .DS.l 1
dstath:        .DS.l 1
dregh:         .DS.l 1
dplayread:     .DS.l 1
dplaystart:    .DS.l 1
peakbuf:       .DS.l 1
rpeakbuf:      .DS.l 1
peakmerk:      .DS.l 1
rpeakmerk:     .DS.l 1
dpeakbuf:      .DS.l 1
rdpeakbuf:     .DS.l 1
dpeakmerk:     .DS.l 1
rdpeakmerk:    .DS.l 1
sectors:       .DS.l 1
endcount:      .DS.l 1
rendcount:     .DS.l 1
dendcount:     .DS.l 1
rdendcount:    .DS.l 1
dsectors:      .DS.l 1
fileart:       .DS.l 1
rfileart:      .DS.l 1
loop:          .DS.l 1
crosflag:      .DS.l 1
dfileart:      .DS.l 1
rdfileart:     .DS.l 1
dloop:         .DS.l 1
dcrosflag:     .DS.l 1
dendflag:      .DS.l 1
rdendflag:     .DS.l 1
handle:        .DS.l 1
rhandle:       .DS.l 1
seeknr:        .DS.l 1
sectnr:        .DS.l 1
rsectnr:       .DS.l 1
bsectnr:       .DS.l 1
load:          .DS.w 1
Text:          .DC.b 13,10,10
               .DC.b "Xbios-Erweiterung fÅr Star-Track installiert...     ",13,10,10,0
               .EVEN 
Text2:         .DC.b 13,10
               .DC.b "Xbios-Erweiterung wurde schon installiert !!!",13,10,0
textint:       .DC.b 13,"Interrupt...",13,10,0
               .EVEN 
showc:         .DC.b 13,10
showt0:        .DC.b "/",0
showt1:        .DC.b "P",0
showt2:        .DC.b "MI",0
showt3:        .DC.b "AD",0
showr0:        .DC.b "->R ",0
showr1:        .DC.b "->MX ",0
showr2:        .DC.b "->DA ",0
showbt1:       .DC.b "MI",0
showbt2:       .DC.b "DX",0
showbt3:       .DC.b "EI",0
showbr0:       .DC.b "->EX ",0
showbr1:       .DC.b "->DI ",0
showbr2:       .DC.b "->MX ",0
showcvn:       .DC.b "CVT0 ",0
showcvj:       .DC.b "CVT1 ",0
showpm:        .DC.b "PM",0
showpm16:      .DC.b "PM16 ",0
showrm:        .DC.b "RM",0
showeadc:      .DC.b "EADC",0
showm16:       .DC.b "16b      ",0
showm24:       .DC.b "24b      ",0
               .EVEN 
rett:          .DC.l 0
rrett:         .DC.l 0
midisuch:      .DC.w 0
midiw:         .DC.l 0
dmidisuch:     .DC.w 0
dmidiw:        .DC.l 0
peakw:         .DC.l 2
playbyte:      .DS.l 8
dplaybyte:     .DS.l 8
recbyte:       .DS.l 8
drecbyte:      .DS.l 8
lock:          .DC.w 0
firstbuf:      .DC.w 0
pbufstrt:      .DS.l 1
pbufend:       .DS.l 1
rbufstrt:      .DS.l 1
rbufend:       .DS.l 1
recmics:       .DS.l 1
merklen:       .DC.l 0
flag:          .DC.w 0
framediv:      .DC.w 0
frames:        .DC.l 0
mtcmod:        .DC.w 0
mtclist:       .DC.b 0,0,0,0,0,0,0,0
sndmode:       .DC.w 1
highsr:        .DC.w 0
modr24:        .DC.w 0
ptracks:       .DC.w 0
rtracks:       .DC.w 0
montrack:      .DC.w 0
src_inter:     .DC.w 0
cause:         .DC.w 0
bufop:         .DC.w 0
pbufptr:       .DS.l 1
rbufptr:       .DS.l 1
snderr:        .DC.w 0
ltatt:         .DC.w 0
rtatt:         .DC.w 0
cardmagc:      .DC.w 0
lgain:         .DC.w 0
rgain:         .DC.w 0
xrch:          .DC.w 0
src:           .DC.w 0
dst:           .DC.w 0
srcclk:        .DC.w 0
prescale:      .DC.w 0
tosv1:         .DS.w 1
tosv2:         .DS.l 1
tosv3:         .DS.w 1
cooksnd:       .DC.l 0
ncooksnd:      .DC.l 0
cookmch:       .DC.l 0
ncookmch:      .DC.l 0
cookcpu:       .DC.l 0
ncookcpu:      .DC.l 0
dspvlong:      .DC.l 0
cookvdo:       .DC.l 0
ncookvdo:      .DC.l 0
cookfpu:       .DC.l 0
ncookfpu:      .DC.l 0
emuladc:       .DC.w 0
emulact8:      .DC.w 0
cookmgmc:      .DC.l 0
matout:        .DC.w 0
time:          .DC.l 0
slowmode:      .DC.w 0
protocol:      .DC.w 0
gpiodat:       .DC.w 0
exclkm:        .DC.w 0
endless:       .DC.w 0
nopeaks:       .DC.w 0
csysadr:       .DC.l 0
demo:          .DC.w 0
intelswap:     .DC.l 0
foundpci:      .DC.w 0
config:        .DC.l 0
pcimem:        .DC.l 0
pcio1:         .DC.l 0
pcio2:         .DC.l 0
csysbase:      .DS.b 128
param:         .DS.l 8
vmemul:        .DS.b 1024
stack:         .DS.b 512

;--------------------------------
_dsp_codebuf:  .DS.b 72
               .EVEN 
_dsp_subs:     .DS.b 96
               .EVEN 
_dsp_max_avail_mem:       .DC.l 0
_dsp_avail_pmem:          .DC.l 0
_dsp_xreserve: .DC.l 0
_dsp_ability:  .DC.w 0
_dsp_free_subridx:        .DC.w 0
_dsp_uniqueability:       .DC.w 0
_dsp_tmtbuf_ptr:          .DC.l 0
_dsp_tmtsize:  .DC.l 0
_dsp_num_tmtblks:         .DC.l 0
_dsp_tmtblks_done_ptr:    .DC.l 0
_dsp_rcvbuf_ptr:          .DC.l 0
_dsp_rcvsize:  .DC.l 0
_dsp_num_rcvblks:         .DC.l 0
_dsp_rcvblks_done_ptr:    .DC.l 0
_dsp_lock:     .DC.w 0
_snd_lock:     .DC.b 0

               .EVEN 
_dsp_subr_adr: .DC.l 0
_dsp_rcv_ptr:  .DC.l 0
_dsp_tmt_ptr:  .DC.l 0
_snd_ch_att:   .DC.w 0
newcjar:       .DS.l 102
recbuf:        .DS.b 8192
recbuf2:       .DS.b 8192
recbuf3:       
recbuflen      equ 8192
epeakbuf:      .DS.b 4
program_end:   
;--------------------------------

               .BSS 
mystack:       .DS.l 512
stack_end:     
               .END 
;ENDE

