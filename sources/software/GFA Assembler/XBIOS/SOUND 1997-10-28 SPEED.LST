;Xbios
;Xbios-Erweiterung fÅr Sound-Sampler StarTrack
;Release 28.10.1997

demo           equ 0

lfifo          equ 4096
resmagic       equ $31415926
cjar           equ $5a0
resval         equ $426
resvect        equ $42a
savptr         equ $4a2
amount         equ 46
xbiosvec       equ $b8
install        equ 500
ireg_p         equ 1      ; interrupt fÅr play
ireg_r         equ 2      ; interrupt fÅr record
ireg_all       equ 3      ; interrupt fÅr record & play
CR             equ $0000000d
LF             equ $0000000a
ESC            equ 27


               move.w     #1,-(sp)
               move.w     #500,-(sp)
               trap       #14
               addq.l     #4,sp
               cmpi.l     #$71273800,d0
               bne        do_inst

letitbe:       clr.w      -(sp)         ;* Ab ins Jenseits
               trap       #1            ;GEMDOS

;-----------------------------------------------------------
; Interrupt-Vektor 122 (fÅr Play) setzen
;-----------------------------------------------------------
do_inst:       
               pea        ihandler_play ; neue Interrupt-Routine
               move.w     #122,-(sp)    ; Vektor Nummer 122
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupt-Vektor 123 (fÅr Record) setzen
;-----------------------------------------------------------

               pea        ihandler_rec  ; neue Interrupt-Routine
               move.w     #123,-(sp)    ; Vektor Nummer 123
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;               pea        ihandler_mfp  ; neue Interrupt-Routine
;               move.w     #71,-(sp)     ; Vektor Nummer 71
;               move.w     #5,-(sp)      ; BIOS #5
;               trap       #13           ;
;               addq.l     #8,sp         ; stack korrigieren

;               pea        ihandler_tima ; neue Interrupt-Routine
;               move.w     #77,-(sp)     ; Vektor Nummer 77
;               move.w     #5,-(sp)      ; BIOS #5
;               trap       #13           ;
;               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupt-Vektor 124 (fÅr DSP-Transfer) setzen
;-----------------------------------------------------------

               pea        ihandler_dsp  ; neue Interrupt-Routine
               move.w     #124,-(sp)    ; Vektor Nummer 124
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupts erlauben, SCU programmieren
;-----------------------------------------------------------
               clr.l      -(sp)         ;in Supervisormode
               move.w     #32,-(sp)
               trap       #1
               addq.l     #6,sp
               move.l     d0,-(sp)

               bsr        getsysbase

;cookiejar-test
               lea.l      vmestart(pc),a2
               lea.l      vmemask(pc),a3
               move.l     #$fedf0000,(a2)         ; VME-Start im ST & STE
               move.l     #$ffdf8e0d,(a3)         ; VME-Intmaske im ST & STE
               tst.l      cjar
               beq        cookt5
               movea.l    cjar,a1
cookt1:        move.l     (a1)+,d1
               move.l     (a1)+,d2
               tst.l      d1
               beq        cookt4
               cmpi.l     #"_SND",d1
               bne.s      cookt1b
               lea.l      cooksnd(pc),a4
               move.l     d2,(a4)
               suba.l     #4,a1
               move.l     d2,(a1)+
cookt1b:       cmpi.l     #"_MCH",d1
               bne.s      cookt2
               lea.l      cookmch(pc),a4
               move.l     d2,(a4)
               swap.w     d2
               cmpi.w     #2,d2
               bne.s      cookt2
               move.l     #$feff0000,(a2)         ; VME-Start im TT
               move.l     #$ffff8e0d,(a3)         ; VME-Intmaske im TT
cookt2:        cmpi.l     #"_CPU",d1
               bne.s      cookt2b
               lea.l      cookcpu(pc),a4
               move.l     d2,(a4)
cookt2b:       cmpi.l     #"_VDO",d1
               bne.s      cookt2c
               lea.l      cookvdo(pc),a4
               move.l     d2,(a4)
cookt2c:       cmpi.l     #"_FPU",d1
               bne.s      cookt2d
               lea.l      cookfpu(pc),a4
               move.l     d2,(a4)
cookt2d:       cmpi.l     #"hade",d1
               bne.s      cookt1
               move.l     #$feff0000,(a2)         ; VME-Start im hades
               move.l     #$ffff8717,(a3)         ; VME-Intmaske im hades
cookt3:        move.l     (a1)+,d1
               move.l     (a1)+,d2
               tst.l      d1
               beq.s      cookt4
               cmpi.l     #"_SND",d1
               bne.s      cookt3
               lea.l      cooksnd(pc),a4
               move.l     d2,(a4)
               suba.l     #4,a1
               move.l     d2,(a1)+
cookt4:        addi.l     #$401,(a2)
cookt5:        .IF demo=0
               lea.l      berrsprung,a1
               move.l     8,(a1)
               lea.l      Buserror,a1
               move.l     a1,8

               lea.l      cookcpu(pc),a4
               cmpi.l     #30,(a4)
               ble.s      noregtest
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               clr.l      d2            ; zaehler max Anzahl Soundkarten
               clr.l      d3            ; zaehler installierte soundkarten
               lea.l      cardlist(pc),a1         ; karten-startadressen-liste
regtest:       move.w     #0,flag
               .DC.w $f4f8              ; flush cache
               move.b     (a0),d0
               .DC.w $f4f8              ; flush cache
               move.w     flag,d0
               cmpi.w     #0,d0
               bne.s      regtest2
               addi.w     #1,d3
               move.l     a0,(a1)+
regtest2:      adda.l     #$4000,a0
               addi.w     #1,d2
               cmpi.w     #4,d2         ; Anzahl max.Karten
               blt.s      regtest
               lea.l      cardz(pc),a1
               move.w     #0,(a1)
               lea.l      cardz2(pc),a1
               move.w     d3,(a1)
               bra.s      berrset
noregtest:     lea.l      cardz(pc),a1
               move.w     #0,(a1)
               lea.l      cardz2(pc),a1
               move.w     #1,(a1)

berrset:       lea.l      berrsprung,a1
               move.l     (a1),8

               bsr        cardadr

initmask:      lea.l      vmemask(pc),a0          ; VME-Irq-Mask-Reg
               movea.l    (a0),a0
               andi.b     #$61,(a0)
               ori.b      #32,(a0)      ; alle Int5 erlauben
               move.w     sr,d0         ; INTs ein
               andi.w     #%1111100011111111,d0
               move.w     d0,sr
               .ELSE 
               lea.l      vmestart(pc),a2
               move.l     #$feff0401,(a2)
               lea.l      cardlist(pc),a1         ; karten-startadressen-liste
               move.l     (a2),(a1)
               lea.l      cardz(pc),a1
               move.w     #0,(a1)
               lea.l      cardz2(pc),a1
               move.w     #0,(a1)
               .ENDIF 

anfint:        
; Register initialisieren

               lea.l      cardz(pc),a1
               move.w     (a1),d0
               cmpi.w     #0,d0
               beq        Xbrweiter
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      lowreg(pc),a1
               move.b     #0,(a1)
               move.b     #0,(a6)
               lea.l      hireg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$40(a6)
               lea.l      aesreg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$c0(a6)
               lea.l      dspreg(pc),a1
               move.b     #36,(a1)
               move.b     #36,$80(a6)
               lea.l      dsppath1(pc),a1
               move.b     #6,(a1)
               move.b     #6,$210(a6)
               lea.l      dspport(pc),a1
               move.b     #0,(a1)
               move.b     #0,$212(a6)
               lea.l      dsppath2(pc),a1
               move.b     #1,(a1)
               move.b     #1,$214(a6)
               lea.l      dspconv(pc),a1
               move.b     #0,(a1)
               move.b     #0,$216(a6)
               lea.l      dsppdat(pc),a1
               move.b     #0,(a1)
               move.b     #0,$240(a6)
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               move.b     #0,$242(a6)
               lea.l      intreg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$280(a6)

Xbrweiter:     
               move.l     xbiosvec,sprung+2       ; Xbios-Vektor umbiegen
               move.l     xbiosvec,XBspr          ; Xbios-Vektor in Xbra merken
               lea.l      neu_Xbios,a1
               move.l     a1,xbiosvec

               move.w     #'XB',d0      ; Xbra's setzen
               move.w     d0,XBI
               move.w     #'RA',d0
               move.w     d0,XBI+2

               movem.l    d0-d7/a0-a6,-(sp)
               lea.l      stack(pc),a0
               move.w     #1,(a0)
               bsr        compatible
               movem.l    (sp)+,d0-d7/a0-a6

               move.w     #32,-(sp)     ;in Usermode
               trap       #1
               addq.l     #6,sp

;               pea        Text          ;Msg ausgeben
;               move.w     #9,-(sp)      ;* ausgeben
;               trap       #1            ;GEMDOS
;               addq.l     #6,sp         ;* Stack sÑubern
;               move.l     #600,d0
;               bsr        pause

               movea.l    4(sp),a0
               move.l     #$100,d0
               add.l      $c(a0),d0     ; programmlÑnge
               add.l      $14(a0),d0    ; data
               add.l      $1c(a0),d0    ; bss

               clr.w      -(sp)
               move.l     d0,-(sp)
               move.w     #$31,-(sp)    ;resident halten
               trap       #1
               rts        

XBI:           .DC.b "XXXX"
               .DC.b "STRK"
XBspr:         .DS.l 1    ;Puffer fÅr alten XBIOS-Vektor
neu_Xbios:                ;Anfang des neuen Xbios
               move.w     (sp),d0       ;get SR
               move.l     usp,a0
               btst       #13,d0
               beq.s      neu_Xbios1
               lea.l      6(sp),a0
neu_Xbios1:    
               lea.l      Rlist,a1
               moveq.l    #0,d0
               move.w     (a0),d1
neu_Xbios2:    
               cmp.w      0(a1,d0.w),d1
               beq.s      new_found
               addq.w     #2,d0
               tst.w      0(a1,d0.w)
               bne.s      neu_Xbios2
sprung:        jmp        $11111111
new_found:     
               mulu.w     #2,d0
               lea.l      R_addr,a1
               movea.l    0(a1,d0.w),a1
;               suba.l     #neu_Xbios,a1
;               adda.l     $b8,a1
               addq.l     #2,a0
               movem.l    d1-d7/a1-a6,-(sp)
               jsr        (a1)
               movem.l    (sp)+,d1-d7/a1-a6
               rte        

pause:         movem.l    d1-d3,-(sp)
               move.l     $4ba,d1
paus1:         move.l     $4ba,d2
               sub.l      d1,d2
               tst.l      d2
               bmi.s      overrun
paus2:         cmp.l      d0,d2
               blt.s      paus1
               movem.l    (sp)+,d1-d3
               rts        
overrun:       move.l     #-1,d3
               sub.l      d1,d3
               add.l      d3,d2
               bra.s      paus2

speedtst:      movea.l    (a0)+,a1      ; buffer
               move.l     (a0)+,d7      ; loops
               clr.l      d3
               movea.l    a1,a6
               addq.l     #4,a1
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedmemr:     move.w     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedmemr
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedmemw:     move.w     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedmemw
               move.l     $4ba,d1
               move.l     d1,(a1)+
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               adda.l     #$206,a6
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedhostr:    move.b     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedhostr
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedhostw:    move.b     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedhostw
               move.l     $4ba,d1
               move.l     d1,(a1)+
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedregr:     move.b     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedregr
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedregw:     move.b     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedregw
               move.l     $4ba,d1
               move.l     d1,(a1)+
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               adda.l     #$100,a6
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedfifor:    move.b     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedfifor
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedfifow:    move.b     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedfifow
               move.l     $4ba,d1
               move.l     d1,(a1)+
               clr.l      d0
               rts        

;-------------------------------------------------------------------------------
;  Buserror abfangen und melden
;-------------------------------------------------------------------------------

Buserror:      move.w     #1,flag
               addq.l     #4,2(sp)
               rte        

instcook:      move.l     #newcook,cjar
               move.l     resval,oldval
               move.l     #resmagic,resval
               move.l     resvect,oldreset
               move.l     #newreset,resvect
               rts        
               .DC.b "XBRACKJR"         ; XBRA-Struktur
oldreset:      .DC.l 0
newreset:      clr.l      cjar
               move.l     oldreset,resvect
               move.l     oldval,resval
               jmp        (a6)

               .EVEN 
stack_store:   .DS.l 1    ; 1 Langwort fÅr stack

; ----------------------------Anfang der Abfrage-Treiber-----------------------

ncookies:      lea.l      ncooksnd(pc),a4
               move.l     #$1f,(a4)
               lea.l      ncookmch(pc),a4
               move.l     #$30000,(a4)
               lea.l      ncookcpu(pc),a4
               move.l     #$1e,(a4)
               lea.l      ncookvdo(pc),a4
               move.l     #$30000,(a4)
               lea.l      ncookfpu(pc),a4
               move.l     #0,(a4)
               rts        

ocookies:      lea.l      cooksnd(pc),a3
               lea.l      ncooksnd(pc),a4
               move.l     (a3),(a4)
               lea.l      cookmch(pc),a3
               lea.l      ncookmch(pc),a4
               move.l     (a3),(a4)
               lea.l      cookcpu(pc),a3
               lea.l      ncookcpu(pc),a4
               move.l     (a3),(a4)
               lea.l      cookvdo(pc),a3
               lea.l      ncookvdo(pc),a4
               move.l     (a3),(a4)
               lea.l      cookfpu(pc),a3
               lea.l      ncookfpu(pc),a4
               move.l     (a3),(a4)
               rts        

cookie:        tst.l      cjar
               beq        ncookt5
               movea.l    cjar,a1
ncookt1:       move.l     (a1)+,d1
               move.l     (a1)+,d2
               tst.l      d1
               beq        ncookt5
               cmpi.l     #"_SND",d1
               bne.s      ncookt1b
               lea.l      ncooksnd(pc),a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1b:      cmpi.l     #"_MCH",d1
               bne.s      ncookt1c
               lea.l      ncookmch(pc),a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1c:      cmpi.l     #"_CPU",d1
               bne.s      ncookt1d
               lea.l      ncookcpu(pc),a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1d:      cmpi.l     #"_VDO",d1
               bne.s      ncookt1e
               lea.l      ncookvdo(pc),a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1e:      cmpi.l     #"_FPU",d1
               bne.s      ncookt1f
               lea.l      ncookfpu(pc),a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1f:      bra.s      ncookt1
ncookt5:       rts        


memplay:       movea.l    (a0)+,a3      ; von
               move.l     (a0)+,d1      ; bis
               move.w     (a0)+,d4      ; Anzahl der For/Backstep
               cmpi.w     #0,d4
               blt        memperrs
               move.l     a3,d0
               sub.l      d1,d0
               cmpi.l     #0,d0
               beq        memperrs
               ble.s      mpneg8
               moveq.l    #0,d2
               addq.l     #1,d4
               sub.l      d4,d2
               move.l     d2,d4
               add.l      d4,d4
               add.l      d4,d4
               addi.l     #-4,d4
               bra.s      mpplus
mpneg8:        add.l      d4,d4
               add.l      d4,d4
mpplus:        move.w     (a0)+,d3      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi)
               btst       #2,d3
               beq.s      nomidip
               move.w     (a0)+,d0      ; midi
nomidip:       move.l     #lfifo,d2     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               asr.w      #3,d2
               subq.l     #1,d2
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread a5,A1=1
               lea.l      midisuch(pc),a2
               move.w     d0,(a2)
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               moveq.l    #0,d6         ; LoopzÑhler
               moveq.l    #8,d5
panf:          bsr        play
               tst.w      d0
               bne.s      pweg
pcrostst:      btst       #1,d3
               beq.s      plooptst
               addq.l     #8,d4
               neg.l      d4
               move.l     d1,d0
               subq.l     #4,d0
               move.l     a3,d1
               addq.l     #4,d1
               movea.l    d0,a3
               bsr        play
               tst.w      d0
               bne.s      pweg
               neg.l      d4
               subq.l     #8,d4
               move.l     d1,d0
               subq.l     #4,d0
               move.l     a3,d1
               addq.l     #4,d1
               movea.l    d0,a3
plooptst:      btst       #0,d3
               beq.s      pweg
               bra.s      panf
pweg:          lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,4(a4)      ; Returnwert Anzahl loops speichern
               move.l     a4,d0
               rts        
play:          movea.l    a3,a2
pfill:         move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      pcopyanf
               bsr        pbrktst
               tst.w      d0
               bne.s      playex
               bra.s      pfill
pcopyanf:      move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
pcopy:         cmpi.w     #0,d4
               blt.s      pcopyneg
               cmpa.l     d1,a2
               bge.s      playend
pcopy2:        move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               cmpa.l     d1,a2
               bge.s      playend
               adda.l     d4,a2
               dbra       d0,pcopy2
               bra.s      pcopytst
pcopyneg:      cmpa.l     d1,a2
               ble.s      playend
pcopyn2:       move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               cmpa.l     d1,a2
               ble.s      playend
               adda.l     d4,a2
               dbra       d0,pcopyn2
pcopytst:      bsr        pbrktst
               tst.w      d0
               bne.s      playex
               btst       #2,d3
               beq.s      pfill
               bsr        pmidi
               tst.w      d0
               bne.s      playex
               bra.s      pfill
playend:       clr.l      d0
               addq.l     #1,d6
playex:        rts        
memperrs:      move.l     (a0)+,d3
               btst       #2,d3
               beq.s      mempers2
               move.l     (a0)+,d0      ; midi
mempers2:      move.l     #-1,d0
               rts        
pmidi:         movem.l    d1-d7/a0-a4,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      pnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      pmidi2        ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      pnomidi
pmidi2:        cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      pmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      pnomidi
pmidi3:        move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      pmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      pmidi6
pmidi3b:       move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      pnomidi
pmidi4:        cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      pmidi3        ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      pnomidi
pmidi5:        cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      pmidi3b       ; wenn nein, Datenwort lîschen
               bra.s      pmidiex       ; Abbruch, da NOTE OFF !
pmidi6:        cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      pmidi3b       ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      pmidi3b       ; wenn nein, Datenwort lîschen
               bra.s      pmidiex       ; Abbruch, da NOTE ON und Velo=Null !
pnomidi:       move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               clr.l      d0
               rts        
pmidiex:       move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #-1,d0
               rts        
pbrktst:       movem.l    d1-d7/a0-a4,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a4
               rts        

memrec:        lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      memre2
               move.w     #1,(a1)
               bsr        killbuf
memre2:        movea.l    (a0)+,a2      ; von
               move.l     (a0)+,d1      ; bis
               lea.l      hireg(pc),a1
               moveq.l    #0,d2
               move.b     (a1),d2       ; Inhalt REGH
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               movea.l    d0,a4         ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
;               bsr        recreset
               moveq.l    #8,d2
               moveq.l    #2,d3
ranf:          moveq.l    #8,d0
ranf2:         move.w     (a1),d5       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d5
               beq.s      ranf3         ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d4
               beq.s      ranf3         ; fehlerhafte Daten ?
               bra.s      ranf4
ranf3:         dbra       d0,ranf2      ; 8x versuchen zu synchronisieren
               bsr        rbrktst       ; dann abbruch testen
               tst.w      d0
               bne.s      rweg
               bra.s      ranf          ; wiederholen bis synchronisiert
ranf4:         move.b     $20(a0),d0    ; Flag lesen
               and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      rcopy         ; wenn ja, daten einlesen
               bsr        rbrktst       ; dann abbruch testen
               tst.w      d0
               bne.s      rweg
               bra.s      ranf4
rcopy:         move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
rcopy2:        move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      rcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      rcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      rcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      rcopy3        ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      rweg
rcopy3:        dbra       d0,rcopy2
               bsr        rbrktst       ; abbruch testen
               tst.w      d0
               bne.s      rweg
               bra.s      ranf4
rweg:          move.l     a2,d0
               rts        
rbrktst:       movem.l    d1-d7/a0-a4,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a4
               rts        

recplay:       rts        
hrecplay:      rts        

hardplay:      movea.l    (a0)+,a3      ; adr
               movea.l    (a0)+,a5      ; len
               move.l     (a0)+,d2      ; sectors
               movea.l    (a0)+,a6      ; seekbyte
               move.w     (a0)+,d7      ; handle
               clr.l      d5
               move.w     (a0)+,d5      ; Anzahl der For/Backstep
               move.w     (a0)+,d3      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               btst       #2,d3
               beq.s      nohmidip
               move.w     (a0)+,d0      ; midi
nohmidip:      cmpi.w     #0,d7
               beq        hperrs
               blt        hperrs
               cmpa.l     #0,a6
               blt        hperrs
               cmpi.l     #0,d2
               beq        hperrs
               blt        hperrs
               move.l     #lfifo,d4
               asr.w      #3,d4
               subq.l     #1,d4         ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart(pc),a4
               movea.l    (a4),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               cmpi.w     #0,d5
               blt        hperrs
               cmpa.l     #0,a5
               beq        hperrs
               bgt.s      hpneg8
               move.l     a5,d1
               neg.l      d1
               movea.l    d1,a5
               moveq.l    #0,d1
               addq.l     #1,d5
               sub.l      d5,d1
               move.l     d1,d5
               add.l      d5,d5
               add.l      d5,d5
               addi.l     #-4,d5
               bra.s      hpplus
hpneg8:        add.l      d5,d5
               add.l      d5,d5
hpplus:        lea.l      midisuch(pc),a2
               move.w     d0,(a2)
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               tst.l      d5
               bmi.s      backset
               move.l     a3,d1         ; MEMende
               add.l      a5,d1
               bra.s      hanf0
backset:       move.l     a3,d1
               subq.l     #4,d1
               adda.l     a5,a3
               subq.l     #4,a3
hanf0:         lea.l      playbyte(pc),a4
               move.l     #0,8(a4)      ; Anzahl loops lîschen
               move.l     #0,4(a4)      ; Anzahl sektoren lîschen
               move.l     #0,(a4)       ; playbyte lîschen
hanf:          movem.l    d1-d7/a0-a6,-(sp)
               move.w     #0,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a6,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               bsr        hplay
               tst.w      d0
               bne.s      hweg
hcrostst:      btst       #1,d3
               beq.s      hlooptst
               addq.l     #8,d5
               neg.l      d5
               move.l     d1,d0
               subq.l     #4,d0
               move.l     a3,d1
               addq.l     #4,d1
               movea.l    d0,a3
               bsr        hplay
               tst.w      d0
               bne.s      hweg
               neg.l      d5
               subq.l     #8,d5
               move.l     d1,d0
               subq.l     #4,d0
               move.l     a3,d1
               addq.l     #4,d1
               movea.l    d0,a3
hlooptst:      btst       #0,d3
               beq.s      hweg
               bra.s      hanf
hweg:          lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,4(a4)      ; Returnwert Anzahl loops speichern
               move.l     a4,d0
               rts        
hplay:         moveq.l    #0,d6
hplay2:        addq.l     #1,d6
               movea.l    a3,a2
               movem.l    d1-d7/a0-a6,-(sp)
               tst.l      d5
               bmi.s      fseek
               bra.s      fread
fseek:         move.w     #1,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a5,d0
               add.l      d0,d0
               neg.l      d0
               move.l     d0,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
fread:         move.l     a3,d0
               tst.l      d5
               bpl.s      readpos
               move.l     d1,d0
               addq.l     #4,d0
readpos:       move.l     d0,-(sp)      ; Fread
               move.l     a5,-(sp)
               move.w     d7,-(sp)
               move.w     #63,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
hfill:         move.b     (a0),d0       ; FIFO halbleer ?
               btst       #1,d0
               bne.s      copyanf
               btst       #3,d3         ; mehr Abbruchabfragen ?
               beq.s      tstrest
               btst       #2,d3
               beq.s      tstrest
               bsr        hmidi
               tst.w      d0
               bne        hplayex
tstrest:       tst.l      d5
               bmi.s      tstmin
               move.l     d1,d0
               sub.l      a2,d0
               bra.s      tstrest2
tstmin:        move.l     a2,d0
               sub.l      d1,d0
tstrest2:      asr.l      #2,d0
               cmp.w      d4,d0
               bgt.s      hfill
restplay:      move.w     d4,-(sp)
               movea.l    a1,a4
               addq.l     #2,a4         ; Playread a4,A1=1
               moveq.l    #4,d4
rest2:         move.b     (a0),d0
               and.b      d4,d0
               beq.s      rest2
               move.b     (a2)+,(a4)    ; Linker Kanal,HighByte senden,A1=1
rest3:         move.b     (a0),d0
               and.b      d4,d0
               beq.s      rest3
               move.b     (a2)+,(a4)    ; Linker Kanal,LowByte senden,A1=1
rest4:         move.b     (a0),d0
               and.b      d4,d0
               beq.s      rest4
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
rest5:         move.b     (a0),d0
               and.b      d4,d0
               beq.s      rest5
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               adda.l     d5,a2
               cmpa.l     d1,a2
               beq.s      bufend
               bra.s      rest2
copyanf:       move.w     d4,d0         ; ...dann FIFO halb-fuellen (fifolen)!
               move.w     d4,-(sp)
               movea.l    a1,a4
               addq.l     #2,a4         ; Playread a4,A1=1
copy:          move.b     (a2)+,(a4)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a4)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
faster:        adda.l     d5,a2
               cmpi.l     #0,d5
               blt.s      hfneg
               cmpa.l     d1,a2
               bge.s      bufend
               bra.s      hfplus
hfneg:         cmpa.l     d1,a2
               ble.s      bufend
hfplus:        dbra       d0,copy
               move.w     (sp)+,d4
               bsr        brktst
               tst.w      d0
               bne.s      hplayex
               btst       #2,d3
               beq        hfill
               bsr        hmidi
               tst.w      d0
               bne.s      hplayex
               bra        hfill
bufend:        move.w     (sp)+,d4
               cmp.l      d2,d6
               beq.s      hplayend
               bsr        brktst
               tst.w      d0
               bne.s      hplayex
               btst       #2,d3
               beq        hplay2
               bsr        hmidi
               tst.w      d0
               bne.s      hplayex
               bra        hplay2
hplayend:      moveq.l    #0,d0
               lea.l      playbyte(pc),a4
               addi.l     #1,8(a4)
hplayex:       rts        
hmidi:         movem.l    d1-d7/a0-a6,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      hnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      hmidi2        ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      hnomidi
hmidi2:        cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      hmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      hnomidi
hmidi3:        move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      hmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      hmidi6
hmidi3b:       move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      hnomidi
hmidi4:        cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      hmidi3        ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      hnomidi
hmidi5:        cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      hmidi3b       ; wenn nein, Datenwort lîschen
               bra.s      hmidiex       ; Abbruch, da NOTE OFF !
hmidi6:        cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      hmidi3b       ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      hmidi3b       ; wenn nein, Datenwort lîschen
               bra.s      hmidiex       ; Abbruch, da NOTE ON und Velo=Null !
hnomidi:       move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a6
               moveq.l    #0,d0
               rts        
hmidiex:       move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a6
               moveq.l    #1,d0
               rts        
brktst:        movem.l    d1-d7/a0-a6,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a6
               rts        
hperrs:        move.l     #-1,d0
               rts        

hardrec:       lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      hardre2
               move.w     #1,(a1)
               bsr        killbuf
hardre2:       movea.l    (a0)+,a3      ; start
               movea.l    (a0)+,a5      ; len
               cmpa.l     #0,a5
               beq        hnerr
               blt        hnerr
               move.l     (a0)+,d2      ; sectors
               lea.l      sectors(pc),a6
               move.l     d2,(a6)
               cmpi.l     #0,d2
               beq        hnerr
               blt        hnerr
               movea.w    (a0)+,a6      ; handle
               cmpa.w     #0,a6
               beq        hnerr
               blt        hnerr
               lea.l      vmestart(pc),a4
               movea.l    (a4),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatxH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               movea.l    d0,a4         ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               move.l     d2,-(sp)      ; sectors
               move.l     a3,d1
               add.l      a5,d1         ; Endadr
               moveq.l    #8,d2
               moveq.l    #2,d3
hnanf:         moveq.l    #8,d0
hnanf2:        move.w     (a1),d5       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d5
               beq.s      hnanf3        ; fehlerhafte Daten ?
               move.w     (a1),d5       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d5
               beq.s      hnanf3        ; fehlerhafte Daten ?
               bra.s      hnholanf
hnanf3:        dbra       d0,hnanf2     ; 8x versuchen zu synchronisieren
               bsr        hnbrktst      ; dann abbruch testen
               tst.w      d0
               bne        hnweg
               bra.s      hnanf         ; wiederholen bis synchronisiert
hnholanf:      movea.l    a3,a2
hnanf4:        bsr        hnbrktst      ; dann abbruch testen
               tst.w      d0
               bne        hnweg
               move.l     d1,d0
               sub.l      a2,d0
               asr.l      #2,d0
               cmp.w      a4,d0         ; Rest kleiner als halber FIFO ?
               ble.s      hnctrl1       ; dann Rest holen und abspeichern
               move.b     (a0),d0       ; Flag lesen
               and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      hncopy        ; wenn ja, daten schnell einlesen
               bra.s      hnanf4
hncopy:        move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
hncopy2:       move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      hncopy3       ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      hncopy3       ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      hncopy3       ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      hncopy3       ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               cmpa.l     d1,a2         ; sektorbuffer voll ?
               beq.s      hnsave
hncopy3:       dbra       d0,hncopy2
               bra.s      hnanf4

hnctrl1:       move.b     (a0),d0       ; Daten gÅltig ?
               andi.b     #1,d0
               beq.s      hnctrl1
               move.w     (a1),d0       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d0
               beq.s      hnctrl1       ; fehlerhafte Daten ?
               move.b     d0,(a2)+
hnctrl2:       move.b     (a0),d0       ; Daten gÅltig ?
               andi.b     #1,d0
               beq.s      hnctrl2
               move.w     (a1),d0       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d0
               beq.s      hnctrl2       ; fehlerhafte Daten ?
               move.b     d0,(a2)+
hnctrl3:       move.b     (a0),d0       ; Daten gÅltig ?
               andi.b     #1,d0
               beq.s      hnctrl3
               move.w     (a1),d0       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d0
               bne.s      hnctrl3       ; fehlerhafte Daten ?
               move.b     d0,(a2)+
hnctrl4:       move.b     (a0),d0       ; Daten gÅltig ?
               andi.b     #1,d0
               beq.s      hnctrl4
               move.w     (a1),d0       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d0
               bne.s      hnctrl4       ; fehlerhafte Daten ?
               move.b     d0,(a2)+
               cmpa.l     d1,a2
               bne.s      hnctrl1
hnsave:        movem.l    d1-d7/a0-a6,-(sp)
               move.l     a3,-(sp)      ; Fwrite
               move.l     a5,-(sp)
               move.w     a6,-(sp)
               move.w     #64,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               bmi.s      hnweg
               cmpa.l     d0,a5
               bne.s      hnweg
               move.l     (sp)+,d0
               subq.l     #1,d0
               move.l     d0,-(sp)
               tst.l      d0            ; alle Sektoren geschrieben ?
               beq.s      hnweg
               bra        hnholanf
hnweg:         lea.l      sectors(pc),a6
               move.l     (a6),d0
               move.l     (sp)+,d2      ; restliche sektoren
               sub.l      d2,d0         ; anzahl komplett geschriebener sektoren
               rts        
hnbrktst:      movem.l    d1-d7/a0-a6,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a6
               rts        
hnerr:         move.l     #-1,d0
               rts        

monitor:       move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               movea.l    d0,a4         ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0
               adda.l     #$ff,a1
               movea.l    a1,a2
               addq.l     #1,a2         ; Playread a2,A1=0
               movea.l    a2,a3
               addq.l     #2,a3         ; Playread a3,A1=1
               moveq.l    #8,d2
fifowait:      move.b     (a0),d0       ; PLAY-FIFO halbleer ?
               andi.b     #2,d0
               bne.s      mcopy         ; wenn ja, halben RECFIFO in PLAYFIFO kopieren
               bsr        mbrktst       ; dann abbruch testen
               tst.w      d0
               bne.s      mweg
               bra.s      fifowait
mcopy:         move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
mcopy2:        move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      mcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      mcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      mcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloscht ?)...
               btst       d2,d4
               bne.s      mcopy3        ; fehlerhafte Daten ?
               move.b     d7,(a3)       ; Linker Kanal,Highbyte senden,A1=1
               move.b     d6,(a3)       ; Linker Kanal,Lowbyte senden,A1=1
               move.b     d5,(a2)       ; Rechter Kanal,Highbyte senden,A1=0
               move.b     d4,(a2)       ; Rechter Kanal,Lowbyte senden,A1=0
mcopy3:        dbra       d0,mcopy2
               bsr        mbrktst       ; abbruch testen
               tst.w      d0
               bne.s      mweg
               bra.s      fifowait
mweg:          clr.l      d0
               rts        
mbrktst:       movem.l    d1-d7/a0-a4,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a4
               rts        

recwait:       move.w     (a0)+,d7      ; treshold
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0
               adda.l     #$ff,a1       ; REC-Read im Wordmode
rwanf1:        move.b     (a0),d0       ; Flag lesen
               btst       #1,d0         ; FIFO mehr als halbvoll ?
               beq.s      rwanf2        ; wenn ja, daten einlesen
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #11,-(sp)
               trap       #1
               addq.l     #2,sp
               movem.l    (sp)+,d1-d7/a0-a6
               tst.l      d0
               bne        rwweg
               bra.s      rwanf1
rwanf2:        moveq.l    #8,d6
               moveq.l    #$ff,d5
               moveq.l    #0,d4
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #11,-(sp)
               trap       #1
               addq.l     #2,sp
               movem.l    (sp)+,d1-d7/a0-a6
               tst.l      d0
               bne.s      rwweg
rwanf4:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf4
               move.w     (a1),d1       ; wenn 0, weiter
               btst       d6,d1
               bne.s      rwanf4
               and.w      d5,d1
               asl.w      d6,d1
rwanf5:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf5
               move.w     (a1),d2       ; wenn 0, weiter
               btst       d6,d2
               bne.s      rwanf4
               and.w      d5,d2
               add.w      d2,d1
rwanf6:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf6
               move.w     (a1),d2       ; wenn 1, weiter
               btst       d6,d2
               beq.s      rwanf4
               and.w      d5,d2
               asl.w      d6,d2
rwanf7:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf7
               move.w     (a1),d3       ; wenn 1, weiter
               btst       d6,d3
               beq.s      rwanf4
               and.w      d5,d3
               add.w      d3,d2
               btst       #15,d1        ; Oberstes Bit da ?
               beq.s      rweiter1      ; dann negieren
               not.w      d1
rweiter1:      btst       #15,d2
               beq.s      rweiter2
               not.w      d2
rweiter2:      cmp.w      d7,d1         ; treshold vergleichen
               bgt.s      rwweg
               cmp.w      d7,d2
               bgt.s      rwweg
               move.b     (a0),d0       ; Flag lesen
               btst       #1,d0         ; FIFO mehr als halbvoll ?
               beq        rwanf4        ; wenn ja, daten einlesen
               bra        rwanf1
rwweg:         clr.l      d0
               rts        


; ---------------------------Anfang der Interrupt-Treiber-----------------------

ihandler_play: movem.l    d0-d7/a0-a6,-(sp)
               lea.l      pimode(pc),a2
               move.l     (a2),d0
               cmpi.l     #21,d0
               beq        xmemplay16
               cmpi.l     #25,d0
               beq        falcplay8
               cmpi.l     #8,d0
               beq        implaymix
               cmpi.l     #3,d0
               beq        ihardplay
               cmpi.l     #1,d0
               beq        imemplay
               cmpi.l     #9,d0
               beq        xmemplay
               cmpi.l     #22,d0
               beq        xmemplay
               cmpi.l     #11,d0
               beq        falcplay
               cmpi.l     #17,d0
               beq        xmemplay8
               cmpi.l     #19,d0
               beq        imemp24
               bra        playdummy
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

ihandler_dsp:  movem.l    d0-d7/a0-a6,-(sp)
               lea.l      drimode(pc),a2
               move.l     (a2),d0
               cmpi.l     #23,d0
               beq        tdsphbr
               cmpi.l     #14,d0
               beq        dsprecord
               cmpi.l     #16,d0
               beq        dsphbr
               lea.l      dpimode(pc),a2
               move.l     (a2),d0
               cmpi.l     #22,d0
               beq        dsphbp
               cmpi.l     #13,d0
               beq        dspplay
               cmpi.l     #15,d0
               beq        dsphbp
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

ihandler_rec:  movem.l    d0-d7/a0-a6,-(sp)
               lea.l      rimode(pc),a2
               move.l     (a2),d0
               cmpi.l     #26,d0
               beq        falcrec8
               cmpi.l     #23,d0
               beq        txmemrec
               cmpi.l     #24,d0
               beq        cblread
               cmpi.l     #7,d0
               beq        hrecpeak
               cmpi.l     #4,d0
               beq        ihardrec
               cmpi.l     #6,d0
               beq        mrecpeak
               cmpi.l     #2,d0
               beq        imemrec
               cmpi.l     #5,d0
               beq        ipeak
               cmpi.l     #10,d0
               beq        xmemrec
               cmpi.l     #20,d0
               beq        xmemrec8
               cmpi.l     #12,d0
               beq        falcrec
               cmpi.l     #18,d0
               beq        imemr24
               bra        recdummy
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_imemplay: move.w     (a0)+,d0      ; Auswahl
               cmpi.w     #0,d0
               beq.s      aimemplay
               cmpi.w     #1,d0
               beq        aidspplay
               cmpi.w     #2,d0
               beq        aimemplay24
aimemplay:     lea.l      von(pc),a2
               move.l     (a0)+,d2      ; von a3
               move.l     d2,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      bis(pc),a2
               move.l     (a0)+,d3      ; bis d1
               move.l     d3,(a2)       ; bis d1
               lea.l      bbis(pc),a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               clr.l      d4
               move.w     (a0)+,d4      ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      imnmidi
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
imnmidi:       lea.l      step(pc),a2
               cmpi.w     #0,d4
               blt        imemperrs
               move.l     d2,d0
               sub.l      d3,d0
               cmpi.l     #0,d0
               beq        imemperrs
               ble.s      impneg8
               moveq.l    #0,d2
               addq.l     #1,d4
               sub.l      d4,d2
               move.l     d2,d4
               add.l      d4,d4
               add.l      d4,d4
               addi.l     #-4,d4
               bra.s      impplus
impneg8:       add.l      d4,d4
               add.l      d4,d4
impplus:       move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; mempos lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      pimode(pc),a2
               move.l     #1,(a2)
               move.l     a4,d0
               rts        
imemperrs:     move.l     #-1,d0
               rts        

imemplay:      lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq.s      ip_back
ipfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrleer
               move.l     strtp(pc),d0
               cmp.l      24(a6),d0
               beq.s      nowrleer
               addi.l     #1,12(a6)     ;Fehler +1
nowrleer:      move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      ipcopyanf
               bra.s      ipfill
ipcopyanf:     cmpi.l     #0,d4
               blt.s      ipcopyneg
               cmpa.l     d1,a2
               bge.s      iplayend
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopy:        move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               bge.s      iplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,ipcopy
               bra.s      ip_back
ipcopyneg:     cmpa.l     d1,a2
               ble.s      iplayend
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopy2:       move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               ble.s      iplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,ipcopy2
ip_back:       lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ip_back2:      lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplayend:      moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #1,d3         ; crossplay ?
               beq.s      iplooptst     ; wenn nein, ueberspringen
               lea.l      crosflag(pc),a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      baktofor
fortobak:      addq.l     #8,d4
               neg.l      d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Endposition
               lea.l      bvon(pc),a4
               move.l     (a4),d1
               addq.l     #4,d1
               lea.l      bis(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra.s      ip_back2
baktofor:      neg.l      d4
               subq.l     #8,d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               lea.l      bbis(pc),a4
               lea.l      bis(pc),a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        ip_back2
iendplay:      lea.l      playbyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplooptst:     btst       #0,d3
               beq.s      iendplay
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        ip_back2
ipmidi:        movem.l    d1-d7/a0-a4,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      ipnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      ipmidi2       ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      ipnomidi
ipmidi2:       cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      ipmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      ipnomidi
ipmidi3:       move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      ipmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      ipmidi6
ipmidi3b:      move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      ipnomidi
ipmidi4:       cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      ipmidi3       ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      ipnomidi
ipmidi5:       cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      ipmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      ipmidiex      ; Abbruch, da NOTE OFF !
ipmidi6:       cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      ipmidi3b      ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      ipmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      ipmidiex      ; Abbruch, da NOTE ON und Velo=Null !
ipnomidi:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #0,d0
               rts        
ipmidiex:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #1,d0
               rts        

init_imemrec:  move.w     (a0)+,d0      ; Auswahl
               cmpi.w     #0,d0
               beq.s      aimemrec
               cmpi.w     #2,d0
               beq        aimemrec24
aimemrec:      lea.l      rvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
;               bsr        recreset
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; mempos lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      firstbuf(pc),a6
               move.w     #0,(a6)       ; erster buffer - dann lîschen
               lea.l      rimode(pc),a2
               move.l     #2,(a2)
               move.l     a4,d0
               rts        

killbuf:       lea.l      cadr(pc),a6
               movea.l    (a6),a1       ; Startadresse fifo
               movea.l    4(a6),a2      ; Startadresse recstat
killbu2:       move.w     (a1),d1
               btst       #0,(a2)
               bne.s      killbu2
               rts        

imemrec:       lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      imemre2
               move.w     #1,(a1)
               bsr        killbuf
fbexit:        movem.l    (sp)+,d0-d7/a0-a6
               rte        
imemre2:       lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
iranf:         move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      nordfull
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      nordfull
               addi.l     #1,12(a5)     ;Fehler +1
nordfull:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ircopy        ; wenn ja, daten einlesen
               bra.s      iranf
ircopy:        move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ircopy2:       move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ircopy3       ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               addq.l     #4,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      irweg
ircopy3:       dbra       d0,ircopy2
ir_back:       lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
ir_back2:      move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
irweg:         move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

posmake:       lea.l      von(pc),a2
               lea.l      pos(pc),a3
               move.l     (a2),(a3)
               lea.l      step(pc),a2
               move.l     (a2),d5       ; Anzahl der For/Backstep d5
               tst.l      d5
               bpl.s      ibpset
               lea.l      von(pc),a2
               movea.l    (a2),a3       ; adr a3
               lea.l      len(pc),a2
               movea.l    (a2),a5       ; len a5
               adda.l     a5,a3
               subq.l     #4,a3
               lea.l      pos(pc),a2
               move.l     a3,(a2)       ;aktuelle position setzen (fÅr backplay)
ibpset:        move.w     #1,load       ; daten laden
               rts        

init_hplay:    lea.l      von(pc),a2
               move.l     (a0)+,(a2)    ; adr a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      len(pc),a2
               move.l     (a0)+,(a2)    ; len a5
               lea.l      sectnr(pc),a2
               move.l     (a0)+,(a2)    ; sectors d2
               lea.l      bsectnr(pc),a3
               move.l     (a2),(a3)     ; sectors d2 retten fÅr crossplay und loop
               lea.l      seeknr(pc),a2
               movea.l    (a0)+,a6      ; seekbyte a6
               move.l     a6,(a2)
               lea.l      handle(pc),a2
               move.w     (a0)+,d7      ; handle d7
               move.w     d7,(a2)
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d5
               move.w     d0,(a2)       ; Anzahl der For/Backstep d5
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; d3 mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               move.w     d0,(a2)       ; d3 mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               btst       #2,d0
               beq.s      ihplay2
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
ihplay2:       lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d4
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #0,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a6,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,28(a4)     ; Anzahl loops lîschen
               move.l     #0,4(a4)      ; Anzahl sektoren lîschen
               move.l     #0,(a4)       ; playbyte lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               bsr        posmake
               lea.l      pimode(pc),a2
               move.l     #3,(a2)
               move.l     a4,d0
               rts        

ihardplay:     lea.l      von(pc),a2
               movea.l    (a2),a3       ; adr a3
               lea.l      len(pc),a2
               movea.l    (a2),a5       ; len a5
               lea.l      handle(pc),a2
               move.w     (a2),d7       ; handle d7
               lea.l      seeknr(pc),a2
               movea.l    (a2),a6       ; seekbyte a6
               lea.l      sectnr(pc),a2
               move.l     (a2),d2       ; sectors d2
               lea.l      step(pc),a2
               clr.l      d5
               move.w     (a2),d5       ; Anzahl der For/Backstep d5
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               lea.l      fifo(pc),a2
               move.l     (a2),d4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d4
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a4
               addq.l     #2,a4         ; Playread a4, A1=1
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               tst.l      d5
               bmi.s      ibackset
               move.l     a3,d1         ; MEMende
               add.l      a5,d1
               bra.s      ihplay
ibackset:      move.l     a3,d1
               subq.l     #4,d1
               adda.l     a5,a3
               subq.l     #4,a3
ihplay:        lea.l      pos(pc),a2
               movea.l    (a2),a2       ;aktuelle position holen
               cmpi.w     #1,load
               bne.s      ihfill
               movem.l    d1-d7/a0-a6,-(sp)
               subi.l     #amount,savptr
               tst.l      d5
               bmi.s      ifseek
               bra.s      ifread
ifseek:        move.w     #1,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a5,d0
               add.l      d0,d0
               neg.l      d0
               move.l     d0,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
ifread:        move.l     a3,d0
               tst.l      d5
               bpl.s      ireadpos
               move.l     d1,d0
               addq.l     #4,d0
ireadpos:      move.l     d0,-(sp)      ; Fread
               move.l     a5,-(sp)
               move.w     d7,-(sp)
               move.w     #63,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               addi.l     #amount,savptr
               movem.l    (sp)+,d1-d7/a0-a6
               move.w     #0,load       ; Daten sind geladen
ihfill:        move.b     (a0),d0       ; PLAY-FIFO leer ?
               btst       #0,d0
               bne.s      nowrler2
               move.l     a3,rett
               lea.l      playbyte(pc),a3         ; RÅckgabewerte-Liste
               cmpi.l     #0,(a3)       ; mempos abfragen
               beq.s      nowrler2a
               addi.l     #1,12(a3)     ;Fehler +1
nowrler2a:     movea.l    rett,a3
nowrler2:      move.b     (a0),d0       ; PLAY-FIFO halbleer ?
               btst       #1,d0
               bne.s      icopyanf
itstrest:      bra.s      ihfill
icopyanf:      move.w     fileart(pc),d0
               cmpi.w     #3,d0
               bne.s      normcopy
               move.w     d4,d0         ; ...dann FIFO halb-fuellen (fifolen)!
icwav:         move.b     1(a2),(a4)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2),(a4)     ; Linker Kanal,LowByte senden,A1=1
               addq.l     #2,a2
               move.b     1(a2),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2),(a1)     ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #2,a2
               adda.l     d5,a2
               cmpa.l     d1,a2         ; puffer voll ?
               beq.s      ihplayend
               dbra       d0,icwav      ; fifo-Schleife
               bra.s      normcopy2
normcopy:      move.w     d4,d0         ; ...dann FIFO halb-fuellen (fifolen)!
icopy:         move.b     (a2)+,(a4)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a4)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
ifaster:       adda.l     d5,a2
               cmpa.l     d1,a2         ; puffer voll ?
               beq.s      ihplayend
               dbra       d0,icopy      ; fifo-Schleife
normcopy2:     lea.l      pos(pc),a0
               move.l     a2,(a0)       ; position retten
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihplayend:     lea.l      sectnr(pc),a1
               move.l     (a1),d2
               subq.l     #1,d2
               move.l     d2,(a1)
               cmpi.l     #0,d2
               bne        ihpnoall
ihpall:        lea.l      playbyte(pc),a4
               addi.l     #1,4(a4)      ; ein sektor dazu
               addi.l     #1,28(a4)     ; ein loop dazu
ihcrostst:     btst       #1,d3
               beq.s      ihpltst
               lea.l      crosflag(pc),a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      ihpbtof
ihpftob:       move.b     #1,(a5)       ; backcross
               addq.l     #8,d5
               neg.l      d5
               lea.l      step(pc),a1
               move.l     d5,(a1)       ; Anzahl der For/Backstep d5
               move.l     d1,d0
               subq.l     #4,d0
               lea.l      von(pc),a1
               move.l     d0,(a1)       ; adr a3
               lea.l      sectnr(pc),a1
               lea.l      bsectnr(pc),a0
               move.l     (a0),(a1)
               bra.s      ihpnoall
ihpbtof:       move.b     #0,(a5)       ; forcross
               neg.l      d5
               subq.l     #8,d5
               lea.l      step(pc),a1
               move.l     d5,(a1)       ; Anzahl der For/Backstep d5
               move.l     d1,d0
               subq.l     #4,d0
               lea.l      von(pc),a1
               move.l     d0,(a1)       ; adr a3
ihpltst:       btst       #0,d3         ; loop ?
               beq.s      ihpnoc
               lea.l      sectnr(pc),a1
               lea.l      bsectnr(pc),a0
               move.l     (a0),(a1)
               btst       #1,d3         ; Richtungsflag testen
               bne.s      ihpnoall
               subi.l     #amount,savptr
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #0,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a6,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               addi.l     #amount,savptr
               bra.s      ihpnoall
ihpnoc:        addi.l     #1,4(a4)      ; ein sektor dazu
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     #1,8(a4)      ; break on
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihpnoall:      bsr        posmake
               lea.l      playbyte(pc),a4
               addi.l     #1,4(a4)      ; ein sektor dazu
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihmidi:        movem.l    d1-d7/a0-a6,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      ihnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      ihmidi2       ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      ihnomidi
ihmidi2:       cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      ihmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      ihnomidi
ihmidi3:       move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      ihmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      ihmidi6
ihmidi3b:      move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      ihnomidi
ihmidi4:       cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      ihmidi3       ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      ihnomidi
ihmidi5:       cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      ihmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      ihmidiex      ; Abbruch, da NOTE OFF !
ihmidi6:       cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      ihmidi3b      ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      ihmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      ihmidiex      ; Abbruch, da NOTE ON und Velo=Null !
ihnomidi:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a6
               moveq.l    #0,d0
               rts        
ihmidiex:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a6
               moveq.l    #1,d0
               rts        

init_hrec:     lea.l      rpos(pc),a3
               lea.l      rvon(pc),a2
               move.l     (a0)+,(a3)    ; position a2
               move.l     (a3),(a2)     ; adr a3
               lea.l      rlen(pc),a2
               move.l     (a0)+,(a2)    ; len a5
               lea.l      rsectnr(pc),a2
               move.l     (a0)+,(a2)    ; sectors d2
               lea.l      rhandle(pc),a2
               move.w     (a0)+,(a2)    ; handle a6
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; a4 fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,4(a4)      ; Anzahl sektoren lîschen
               move.l     #0,(a4)       ; playbyte lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      rimode(pc),a2
               move.l     #4,(a2)
               move.l     a4,d0
               rts        

ihardrec:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      ihardre2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihardre2:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; adr a3
               lea.l      rlen(pc),a2
               movea.l    (a2),a5       ; len a5
               lea.l      rhandle(pc),a2
               movea.w    (a2),a6       ; handle a6
               lea.l      rsectnr(pc),a2
               move.l     (a2),d2       ; sectors d2
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; a4 fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               move.l     a3,d1         ; MEMende
               add.l      a5,d1
               moveq.l    #8,d2
               moveq.l    #2,d3
               lea.l      rpos(pc),a2
               movea.l    (a2),a2
ihnanf:        move.b     (a0),d0       ; Flag lesen
               btst       #2,d0         ; REC-FIFO voll ?
               bne.s      nordful2
               move.l     a3,rrett
               lea.l      recbyte(pc),a3          ; RÅckgabewerte-Liste
               cmpi.l     #0,(a3)       ; mempos abfragen
               beq.s      nodful2a
               addi.l     #1,12(a3)     ;Fehler +1
nodful2a:      movea.l    rrett,a3
nordful2:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ihncopy       ; wenn ja, daten schnell einlesen
               bra.s      ihnanf
ihncopy:       move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ihncopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     rfileart(pc),d0
               cmpi.w     #3,d0
               bne.s      normrec
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bra.s      normrec2
normrec:       move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
normrec2:      cmpa.l     d1,a2         ; sektorbuffer voll ?
               beq.s      ihnsave       ;dann speichern
ihncopy3:      dbra       d0,ihncopy2   ; fifolen-Schleife
               lea.l      rpos(pc),a3
               move.l     a2,(a3)       ; position retten
               bra.s      ihrecweg
ihnsave:       lea.l      rpos(pc),a0
               move.l     a3,(a0)       ; position zurÅcksetzen
               subi.l     #amount,savptr
               movem.l    d1-d7/a0-a6,-(sp)
               move.l     a3,-(sp)      ; Fwrite
               move.l     a5,-(sp)
               move.w     a6,-(sp)
               move.w     #64,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               addi.l     #amount,savptr
               bmi.s      ihrecend
               cmpa.l     d0,a5
               bne.s      ihrecend
               lea.l      rsectnr(pc),a0
               move.l     (a0),d2       ; sectors d2
               subq.l     #1,d2
               move.l     d2,(a0)
               tst.l      d2            ; alle Sektoren geschrieben ?
               beq.s      ihrecend
ihrecweg:      lea.l      recbyte(pc),a5
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0
               addq.l     #1,d0
               move.l     d0,4(a5)      ; Returnwert Anzahl sektoren speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihrecend:      lea.l      recbyte(pc),a5
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0
               addq.l     #1,d0
               move.l     d0,4(a5)      ; Returnwert Anzahl sektoren speichern
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        


compatible:    move.w     (a0)+,d0      ; mode
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      lowreg(pc),a1
               move.b     #13,(a1)
               move.b     #13,(a6)
               lea.l      hireg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$40(a6)
               move.w     d0,-(sp)
               bsr        recreset
               move.w     (sp)+,d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$40(a6)
               move.b     #$4,$40(a6)
               move.b     #$26,$80(a6)  ; A/D->DMAREC
               move.b     #$4,$40(a6)
               move.b     #$26,$80(a6)  ; A/D->D/A
               move.b     #$4,$40(a6)
               move.b     #$26,$80(a6)  ; A/D->DSPREC
               move.b     #0,$40(a6)
               lea.l      dspreg(pc),a1
               move.b     #$26,(a1)     ; A/D->DMAREC
               lea.l      aesreg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$c0(a6)
               lea.l      dsppath1(pc),a1
               move.b     #7,(a1)
               move.b     #7,$210(a6)
               lea.l      dspport(pc),a1
               move.b     #8,(a1)
               move.b     #8,$212(a6)
               lea.l      dspconv(pc),a1
               move.b     #3,(a1)
               move.b     #3,$216(a6)
               lea.l      dspport(pc),a1
               move.b     #8,(a1)
               move.b     #8,$212(a6)
               lea.l      dsppath2(pc),a1
               move.b     #5,(a1)
               move.b     #5,$214(a6)
               lea.l      dsppdat(pc),a1
               move.b     #0,(a1)
               move.b     #0,$240(a6)
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               move.b     #0,$242(a6)
               lea.l      intreg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$280(a6)
               lea.l      dintreg(pc),a1
               move.b     #0,(a1)
               lea.l      playmod(pc),a1
               move.b     #0,(a1)
               lea.l      recmod(pc),a1
               move.b     #0,(a1)
               move.w     d0,-(sp)
               lea.l      param(pc),a0
               move.w     #$c0,(a0)+
               move.w     #$c0,(a0)+
               lea.l      param(pc),a0
               bsr        volad
               lea.l      param(pc),a0
               bsr        volda
               move.w     (sp)+,d0
               cmpi.w     #0,d0
               bne.s      ctible
               bsr        putsysorig
               bsr        ocookies
               bsr        cookie
               bra.s      ctibleweg
ctible:        bsr        makesysbase
ctibleweg2:    bsr        ncookies
               bsr        cookie
ctibleweg:     clr.l      d0
               rts        

getsysbase:    movea.l    $4f2,a1
               move.l     a1,d0
               lea.l      csysadr(pc),a2
               move.l     d0,(a2)
               rts        

makesysbase:   move.w     #$7f,d0
               lea.l      csysbase(pc),a2
               lea.l      csysadr(pc),a1
               movea.l    (a1),a1
getsysb2:      move.b     (a1)+,(a2)+
               dbra       d0,getsysb2
               lea.l      csysbase(pc),a1
               move.w     #$404,2(a1)
               move.l     #$3081993,$18(a1)
               move.w     #$1a68,$1e(a1)
               lea.l      csysbase(pc),a1
               move.l     a1,d0
               move.l     d0,$4f2
               rts        

putsysorig:    lea.l      csysadr(pc),a2
               move.l     (a2),d0
               move.l     d0,$4f2
               rts        

peakread:      lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     (a4),d0
               move.l     #0,(a4)       ; RÅckgabewert lîschen
               move.l     #0,8(a4)      ; Break lîschen
               rts        

init_peak:     lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
;               bsr        recreset
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; RÅckgabewert lîschen
               move.l     #0,8(a4)      ; Break lîschen
               lea.l      rimode(pc),a2
               move.l     #5,(a2)
               move.l     a4,d0
               rts        

ipeak:         lea.l      rfifo(pc),a2
               movea.l    (a2),a3       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     (a4),d1
               moveq.l    #8,d2
               moveq.l    #2,d3
ipkanf:        move.b     (a0),d0       ; Flag lesen
               and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ipkcopy       ; wenn ja, daten einlesen
               bra.s      ipkanf
ipkcopy:       move.w     a3,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ipkcopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ipkcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ipkcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ipkcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ipkcopy3      ; fehlerhafte Daten ?
               asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               swap.w     d1
               btst       #15,d7
               beq.s      pnoneg
               not.w      d7
pnoneg:        cmp.w      d1,d7
               blt.s      pnoadd
               move.w     d7,d1
pnoadd:        swap.w     d1
               btst       #15,d5
               beq.s      pnoneg2
               not.w      d5
pnoneg2:       cmp.w      d1,d5
               blt.s      ipkcopy3
               move.w     d5,d1
ipkcopy3:      dbra       d0,ipkcopy2
               move.l     d1,(a4)
               move.l     #1,8(a4)      ; Break setzen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_mplaypeak:           rts           
init_mrppeak:  rts        

init_mrecpeak: move.w     (a0)+,d0      ; Auswahl
               cmpi.w     #0,d0
               beq.s      imrecpeak
               cmpi.w     #1,d0
               beq        idrecpeak
imrecpeak:     lea.l      rvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
;               bsr        recreset
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #6,(a2)
               move.l     a4,d0
               rts        

mrecpeak:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      mrecpea2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
mrecpea2:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               clr.l      a6            ; Peak-RÅckgabewert lîschen
               movea.l    a3,a2
               moveq.l    #2,d3
               moveq.l    #8,d2
miranf:        move.b     (a0),d0       ; Flag lesen
               btst       #2,d0         ; REC-FIFO voll ?
               bne.s      nordful3
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      nordful3
               addi.l     #1,12(a5)     ;Fehler +1
nordful3:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      mircopy       ; wenn ja, daten einlesen
               bra.s      miranf
mircopy:       move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
mircopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      mircopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      mircopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      mircopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      mircopy3      ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               move.l     d1,-(sp)
               move.l     a6,d1
               swap.w     d1
               btst       #15,d7
               beq.s      mpnoneg
               not.w      d7
mpnoneg:       cmp.w      d1,d7
               blt.s      mpnoadd
               move.w     d7,d1
mpnoadd:       swap.w     d1
               btst       #15,d5
               beq.s      mpnoneg2
               not.w      d5
mpnoneg2:      cmp.w      d1,d5
               blt.s      mircop2b
               move.w     d5,d1
mircop2b:      movea.l    d1,a6
               move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      mirweg
mircopy3:      dbra       d0,mircopy2
mir_back:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
mir_back2:     lea.l      recbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Recordbyte speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
mirweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     a6,16(a5)     ; Peak-RÅckgabewert speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_hplaypeak:           rts           
init_hrppeak:  rts        

init_hrecpeak: lea.l      rpos(pc),a3
               lea.l      rvon(pc),a2
               move.l     (a0)+,(a3)    ; position a2
               move.l     (a3),(a2)     ; adr a3
               lea.l      rlen(pc),a2
               move.l     (a0)+,(a2)    ; len a5 (pufferlÑnge)
               lea.l      rsectnr(pc),a2
               move.l     (a0)+,(a2)    ; sectors d2
               lea.l      rhandle(pc),a2
               move.w     (a0)+,(a2)    ; handle a6
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; a4 fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,4(a4)      ; Anzahl sektoren lîschen
               move.l     #0,(a4)       ; playbyte lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      rimode(pc),a2
               move.l     #7,(a2)
               move.l     a4,d0
               rts        

hrecpeak:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      hrecpea2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
hrecpea2:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; adr a3
               lea.l      rlen(pc),a2
               movea.l    (a2),a5       ; len a5
               lea.l      rhandle(pc),a2
               movea.w    (a2),a6       ; handle a6
               lea.l      rsectnr(pc),a2
               move.l     (a2),d2       ; sectors d2
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; a4 fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a2
               move.l     #0,d3         ; Peak-RÅckgabewert lîschen
               move.l     a3,d1         ; MEMende
               add.l      a5,d1
               moveq.l    #8,d2
               lea.l      rpos(pc),a2
               movea.l    (a2),a2
pihnanf:       move.b     (a0),d0       ; Flag lesen
               btst       #2,d0         ; REC-FIFO voll ?
               bne.s      nordful4
               move.l     a3,rrett
               lea.l      recbyte(pc),a3          ; RÅckgabewerte-Liste
               cmpi.l     #0,(a3)       ; mempos abfragen
               beq.s      nordful4a
               addi.l     #1,12(a3)     ;Fehler +1
nordful4a:     movea.l    rrett,a3
nordful4:      andi.b     #2,d0         ; FIFO mehr als halbvoll ?
               beq.s      pihncopy      ; wenn ja, daten schnell einlesen
               bra.s      pihnanf
pihncopy:      move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
pihncopy2:     move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      pihncopy3     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      pihncopy3     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      pihncopy3     ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      pihncopy3     ; fehlerhafte Daten ?
               move.w     rfileart(pc),d0
               cmpi.w     #3,d0
               bne.s      normprec
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bra.s      normprec2
normprec:      move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
normprec2:     asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               swap.w     d3
               btst       #15,d7
               beq.s      hpnoneg
               not.w      d7
hpnoneg:       cmp.w      d3,d7
               blt.s      hpnoadd
               move.w     d7,d3
hpnoadd:       swap.w     d3
               btst       #15,d5
               beq.s      hpnoneg2
               not.w      d5
hpnoneg2:      cmp.w      d3,d5
               blt.s      hircop2b
               move.w     d5,d3
hircop2b:      cmpa.l     d1,a2         ; sektorbuffer voll ?
               beq.s      pihnsave      ;dann speichern
pihncopy3:     dbra       d0,pihncopy2  ; fifolen-Schleife
               lea.l      rpos(pc),a3
               move.l     a2,(a3)       ; position retten
               bra.s      pihrecweg
pihnsave:      lea.l      rpos(pc),a0
               move.l     a3,(a0)       ; position zurÅcksetzen
               subi.l     #amount,savptr
               movem.l    d1-d7/a0-a6,-(sp)
               move.l     a3,-(sp)      ; Fwrite
               move.l     a5,-(sp)
               move.w     a6,-(sp)
               move.w     #64,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               addi.l     #amount,savptr
               bmi.s      pihrecend
               cmpa.l     d0,a5
               bne.s      pihrecend
               lea.l      rsectnr(pc),a0
               move.l     (a0),d2       ; sectors d2
               subq.l     #1,d2
               move.l     d2,(a0)
               tst.l      d2            ; alle Sektoren geschrieben ?
               beq.s      pihrecend
               lea.l      recbyte(pc),a5
               move.l     4(a5),d0
               addq.l     #1,d0
               move.l     d0,4(a5)      ; Returnwert Anzahl sektoren speichern
pihrecweg:     lea.l      recbyte(pc),a5
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     d3,16(a5)     ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
pihrecend:     lea.l      recbyte(pc),a5
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0
               addq.l     #1,d0
               move.l     d0,4(a5)      ; Returnwert Anzahl sektoren speichern
               move.l     #1,8(a5)      ; Break setzen
               move.l     d3,16(a5)     ; Peak-RÅckgabewert speichern
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_ihplaymix:           rts           

init_impmix:   move.w     (a0)+,d0      ; Auswahl
               cmpi.w     #0,d0
               beq.s      aimixplay
               rts        
aimixplay:     lea.l      von(pc),a2
               move.l     (a0)+,d2      ; von a3
               move.l     d2,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      bis(pc),a2
               move.l     (a0)+,d3      ; bis d1
               move.l     d3,(a2)       ; bis d1
               lea.l      bbis(pc),a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               clr.l      d4
               move.w     (a0)+,d4      ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      imixnmidi
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
imixnmidi:     lea.l      step(pc),a2
               cmpi.w     #0,d4
               blt        imemperrs
               move.l     d2,d0
               sub.l      d3,d0
               cmpi.l     #0,d0
               beq        imemperrs
               ble.s      imixpneg8
               moveq.l    #0,d2
               addq.l     #1,d4
               sub.l      d4,d2
               move.l     d2,d4
               add.l      d4,d4
               add.l      d4,d4
               addi.l     #-4,d4
               bra.s      imixpplus
imixpneg8:     add.l      d4,d4
               add.l      d4,d4
imixpplus:     move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; mempos lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      rvon(pc),a2
               move.l     (a2),d0
               lea.l      recmics(pc),a2          ; RÅckgabewerte-Liste
               subi.l     #16384,d0
               move.l     d0,(a2)
               lea.l      pimode(pc),a2
               move.l     #8,(a2)
               move.l     a4,d0
               rts        

implaymix:     clr.l      d5
               lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
               lea.l      recmics(pc),a4          ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq        xip_back
xipfill:       move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      xnowrleer
               move.l     strtp(pc),d0
               cmp.l      24(a6),d0
               beq.s      xnowrleer
               addi.l     #1,12(a6)     ;Fehler +1
xnowrleer:     move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      xipcopyanf
               bra.s      xipfill
xipcopyanf:    cmpi.l     #0,d4
               blt.s      xipcopyneg
               cmpa.l     d1,a2
               bge.s      xiplayend
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
xipcopy:       movea.l    (a4),a3
               move.w     (a2)+,d7      ; linken Kanal holen
               move.w     (a3)+,d6
               bsr        mixer
               move.w     d7,d6
               asr.w      #8,d6
               move.b     d6,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d7,(a5)       ; Linker Kanal,LowByte senden,A1=1
               move.w     (a2)+,d7      ; linken Kanal holen
               move.w     (a3)+,d6
               move.l     a3,(a4)
               bsr        mixer
               move.w     d7,d6
               asr.w      #8,d6
               move.b     d6,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d7,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               bge.s      xiplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,xipcopy
               bra.s      xip_back
xipcopyneg:    cmpa.l     d1,a2
               ble.s      xiplayend
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
xipcopy2:      move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               ble.s      xiplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,xipcopy2
xip_back:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
xip_back2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d5,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xiplayend:     moveq.l    #0,d0
               addq.l     #1,d5
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d5,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      loop(pc),a4
               move.l     d5,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #1,d3         ; crossplay ?
               beq.s      xiplooptst    ; wenn nein, ueberspringen
               lea.l      crosflag(pc),a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      xbaktofor
xfortobak:     addq.l     #8,d4
               neg.l      d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Endposition
               lea.l      bvon(pc),a4
               move.l     (a4),d1
               addq.l     #4,d1
               lea.l      bis(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra.s      xip_back2
xbaktofor:     neg.l      d4
               subq.l     #8,d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               lea.l      bbis(pc),a4
               lea.l      bis(pc),a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        xip_back2
xiendplay:     lea.l      playbyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xiplooptst:    btst       #0,d3
               beq.s      xiendplay
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        xip_back2
xipmidi:       movem.l    d1-d7/a0-a4,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      xipnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      xipmidi2      ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      xipnomidi
xipmidi2:      cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      xipmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      xipnomidi
xipmidi3:      move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      xipmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      xipmidi6
xipmidi3b:     move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      xipnomidi
xipmidi4:      cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      xipmidi3      ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      xipnomidi
xipmidi5:      cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      xipmidi3b     ; wenn nein, Datenwort lîschen
               bra.s      xipmidiex     ; Abbruch, da NOTE OFF !
xipmidi6:      cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      xipmidi3b     ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      xipmidi3b     ; wenn nein, Datenwort lîschen
               bra.s      xipmidiex     ; Abbruch, da NOTE ON und Velo=Null !
xipnomidi:     move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #0,d0
               rts        
xipmidiex:     move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #1,d0
               rts        

init_xmixplay: rts        

init_xmemplay: move.w     (a0)+,d0      ; Code der record-art
               cmpi.w     #0,d0
               beq.s      xplayinit
               cmpi.w     #1,d0
               beq        xdplayinit
               cmpi.w     #2,d0
               beq        xplayinit8
               cmpi.w     #3,d0
               beq        xplayinit16
xplayinit:     lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      bis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      xmem2b
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
xmem2b:        lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      pimode(pc),a2
               move.l     #9,(a2)
               move.l     a4,d0
               rts        

init_xmemp4:   lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von d1
               move.l     d1,(a2)       ; von d1
               lea.l      bvon(pc),a3
               move.l     d1,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang d2
               lea.l      dvon(pc),a2
               move.l     (a0)+,d3      ; von d3
               move.l     d3,(a2)       ; von d3
               lea.l      dbvon(pc),a3
               move.l     d3,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      dvon2(pc),a2
               move.l     (a0)+,d4      ; zweiter Speicherbereich Anfang d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Anfang d4
               move.l     (a0)+,d5      ; lÑnge der Speicherbereiche
               lea.l      bis(pc),a2
               add.l      d5,d1
               move.l     d1,(a2)       ; bis d1
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d5,d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Ende
               lea.l      dbis(pc),a2
               add.l      d5,d3
               move.l     d3,(a2)       ; bis d1
               lea.l      dbbis(pc),a3
               move.l     d3,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      dbis2(pc),a2
               add.l      d5,d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Ende
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               lea.l      dplaybyte(pc),a5        ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen fifo
               move.l     d0,24(a5)     ; Playposition setzen dsp
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               lea.l      dendcount(pc),a5
               move.l     (a0)+,(a2)    ; Zaehler endwert fifo
               move.l     (a2),(a5)     ; Zaehler endwert dsp
               lea.l      fileart(pc),a2
               lea.l      dfileart(pc),a5
               move.w     (a0)+,(a2)    ; fileart=3=WAV fifo
               move.w     (a2),(a5)     ; fileart dsp
               lea.l      dstep(pc),a5
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4 fifo
               move.l     d0,(a5)       ; Anzahl der For/Backstep d4 dsp
               lea.l      dmode(pc),a5
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a5)       ; mode dsp
               btst       #2,d0
               beq.s      xmemv3
               lea.l      midisuch(pc),a2
               lea.l      dmidisuch(pc),a5
               move.w     (a0)+,(a2)    ; midi d0
               move.w     (a2),(a5)
xmemv3:        lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      dfifo(pc),a2
               move.l     #$7ff,(a2)    ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      dmidiw(pc),a2
               move.l     #0,(a2)
               lea.l      dloop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      dcrosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      dplaybyte(pc),a4        ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      pimode(pc),a2
               move.l     #22,(a2)
               lea.l      dpimode(pc),a2
               move.l     #22,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

xmemplay:      lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               clr.l      a6            ; Peak-RÅckgabewert lîschen
               cmpa.l     d1,a2
               beq        xp_back
xpfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrlx
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      nowrlx
               addi.l     #1,12(a5)     ;Fehler +1
nowrlx:        move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      xpcopyanf
               bra.s      xpfill
xpcopyanf:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
xpcopy:        move.l     d4,-(sp)
               move.l     d1,-(sp)
               move.w     fileart(pc),d1
               cmpi.w     #3,d1
               bne.s      xnowave
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               bra.s      xcope
xnowave:       move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
xcope:         move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a5)     ; Playposition
               bsr        ppeakcmp
               move.l     (sp)+,d1
               move.l     (sp)+,d4
               adda.l     d4,a2
               add.l      d4,24(a5)
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendplay2
               cmpa.l     d1,a2
               beq.s      xplayend
               dbra       d0,xpcopy
xp_back:       lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
xp_back2:      lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
;               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xplayend:      moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
;               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      memt1
memt2:         lea.l      von2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      memte
memt1:         lea.l      bvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
memte:         bra        xp_back2
               btst       #1,d3         ; crossplay ?
               beq        xplooptst     ; wenn nein, ueberspringen
               lea.l      crosflag(pc),a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      xbktofor
xfortobk:      addq.l     #8,d4
               neg.l      d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Endposition
               lea.l      bvon(pc),a4
               move.l     (a4),d1
               addq.l     #4,d1
               lea.l      bis(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra        xp_back2
xbktofor:      neg.l      d4
               subq.l     #8,d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               lea.l      bbis(pc),a4
               lea.l      bis(pc),a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        xp_back2
xendplay:      lea.l      playbyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xendplay2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
;               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xplooptst:     btst       #0,d3
               beq.s      xendplay
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        xp_back2
xpmidi:        movem.l    d1-d7/a0-a4,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               cmpi.w     #0,d0
               beq.s      xpnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      xpmidi2       ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      xpnomidi
xpmidi2:       cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      xpmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      xpnomidi
xpmidi3:       move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      xpmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      xpmidi6
xpmidi3b:      move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      xpnomidi
xpmidi4:       cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      xpmidi3       ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      xpnomidi
xpmidi5:       cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      xpmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      xpmidiex      ; Abbruch, da NOTE OFF !
xpmidi6:       cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      xpmidi3b      ; wenn nein, Datenwort lîschen
               cmpi.b     #0,2(a0)      ; Velocity ist Null ?
               bne.s      xpmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      xpmidiex      ; Abbruch, da NOTE ON und Velo=Null !
xpnomidi:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #0,d0
               rts        
xpmidiex:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #1,d0
               rts        

recdummy:      move.l     #2047,d0      ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
               subq.l     #1,d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               adda.l     #$ff,a6
recdummy2:     move.w     (a6),d7       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               dbra       d0,recdummy2
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

playdummy:     move.l     #2047,d0      ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
               subq.l     #1,d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               adda.l     #$ff,a6
playdummy2:    move.w     #0,(a6)       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               dbra       d0,playdummy2
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_xmemrec:  move.w     (a0)+,d0      ; Code der record-art
               cmpi.w     #0,d0
               beq.s      xrecinit
               cmpi.w     #1,d0
               beq        xdrecinit
               cmpi.w     #2,d0
               beq        xrecinit8
xrecinit:      lea.l      rvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      rbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      rvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      rbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      rbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      rendcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.l      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
;               bsr        recreset
               lea.l      rpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #10,(a2)
               move.l     a4,d0
               rts        

init_xmemr4:   lea.l      rvon(pc),a2
               move.l     (a0)+,d1      ; von d1
               move.l     d1,(a2)       ; von d1
               lea.l      rbvon(pc),a3
               move.l     d1,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      rvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang d2
               lea.l      rdvon(pc),a2
               move.l     (a0)+,d3      ; von d3
               move.l     d3,(a2)       ; von d3
               lea.l      rdbvon(pc),a3
               move.l     d3,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      rdvon2(pc),a2
               move.l     (a0)+,d4      ; zweiter Speicherbereich Anfang d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Anfang d4
               move.l     (a0)+,d5      ; lÑnge der Speicherbereiche
               lea.l      rbis(pc),a2
               add.l      d5,d1
               move.l     d1,(a2)       ; bis d1
               lea.l      rbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rbis2(pc),a2
               add.l      d5,d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Ende
               lea.l      rdbis(pc),a2
               add.l      d5,d3
               move.l     d3,(a2)       ; bis d1
               lea.l      rdbbis(pc),a3
               move.l     d3,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rdbis2(pc),a2
               add.l      d5,d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Ende
               lea.l      rendcount(pc),a2
               lea.l      rdendcount(pc),a3
               move.l     (a0)+,(a2)    ; Zaehler endwert fuer fifo
               move.l     (a2),(a3)     ; Zaehler endwert fuer dsp
               lea.l      rfileart(pc),a2
               lea.l      rdfileart(pc),a3
               move.w     (a0)+,(a2)    ; fileart=3=WAV fuer fifo
               move.w     (a2),(a3)     ; fileart=3=WAV fuer dsp
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      rdfifo(pc),a2
               move.l     #$1ff,(a2)    ; dspbuffer 2048 (/4=$200) Byte
;               bsr        recreset
               lea.l      rpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      rdpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      drecbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #23,(a2)
               lea.l      drimode(pc),a2
               move.l     #23,(a2)
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

xmemrec:       lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      xmemre2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xmemre2:       lea.l      rpeakmerk(pc),a2
               clr.l      (a2)
               lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
xranf:         move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      xnordful
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      xnordful
               addi.l     #1,12(a5)     ;Fehler +1
xnordful:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      xrstrt        ; wenn ja, daten einlesen
               bra.s      xranf
xrstrt:        clr.l      a0            ; Peak pos/neg left lîschen
               clr.l      a3            ; Peak pos/neg right lîschen
               clr.l      a4
xrcopy:        move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
xrcopy2:       move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      xrcopy3       ; fehlerhafte Daten ?
               move.l     d1,-(sp)
               move.w     rfileart(pc),d1
               cmpi.w     #3,d1
               bne.s      xnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bsr        rpeakcmp
               bra.s      xrcope
xnorwave:      move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               bsr        rpeakcmp
xrcope:        move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble.s      xendrec2
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      xrweg
xrcopy3:       dbra       d0,xrcopy2
xr_back:       lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
xr_back2:      move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xrweg:         move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      memr1
memr2:         lea.l      rvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      xr_back2
memr1:         lea.l      rbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      xr_back2
xendrec2:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

txmemrec:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      txmemre2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
txmemre2:      lea.l      rpeakmerk(pc),a2
               clr.l      (a2)
               lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
txranf:        move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      txnordful
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      txnordful
               addi.l     #1,12(a5)     ;Fehler +1
txnordful:     and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      txrcopy       ; wenn ja, daten einlesen
               bra.s      txranf
txrcopy:       move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
txrcopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      txrcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      txrcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      txrcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      txrcopy3      ; fehlerhafte Daten ?
               move.l     d1,-(sp)
               move.w     rfileart(pc),d1
               cmpi.w     #3,d1
               bne.s      txnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
;               bsr        rpeakcmp
               bra.s      txrcope
txnorwave:     move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
;               bsr        rpeakcmp
txrcope:       move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble.s      txendrec2
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      txrweg
txrcopy3:      dbra       d0,txrcopy2
txr_back:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
txr_back2:     move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
txrweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      tmemr1
tmemr2:        lea.l      rvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      txr_back2
tmemr1:        lea.l      rbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      txr_back2
txendrec2:     lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

ppeakcmp:      asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               move.l     a6,d1
               swap.w     d1
               btst       #15,d7
               beq.s      pxpnoneg
               not.w      d7
pxpnoneg:      cmp.w      d1,d7
               blt.s      pxpnoadd
               move.w     d7,d1
pxpnoadd:      swap.w     d1
               btst       #15,d5
               beq.s      pxpnoneg2
               not.w      d5
pxpnoneg2:     cmp.w      d1,d5
               blt.s      pxircop2b
               move.w     d5,d1
pxircop2b:     movea.l    d1,a6
               rts        

rpeakcmp:      asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               move.l     a0,d1         ; peak linker Kanal
               btst       #15,d7
               beq.s      xpnoneg
               not.w      d7
               cmp.w      d1,d7
               blt.s      xpnoadd
               move.w     d7,d1
               bra.s      xpnoadd
xpnoneg:       swap.w     d1            ; positive HÑlfte
               cmp.w      d1,d7
               blt.s      xpnoadd2
               move.w     d7,d1
xpnoadd2:      swap.w     d1            ; peak linker Kanal, negative HÑlfte
xpnoadd:       movea.l    d1,a0         ; peak links retten
               move.l     a3,d1         ; peak rechter Kanal
               btst       #15,d5
               beq.s      xpnoneg2
               not.w      d5
               cmp.w      d1,d5
               blt.s      xircop2b
               move.w     d5,d1
               bra.s      xircop2b
xpnoneg2:      swap.w     d1
               cmp.w      d1,d5
               blt.s      xircop2c
               move.w     d5,d1
xircop2c:      swap.w     d1
xircop2b:      movea.l    d1,a3         ;peak rechts retten
               addq.l     #1,a4
               cmpa.l     #512,a4
               bne.s      pbufweg
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a6       ; Peakbuffer-Adresse holen
               move.l     a0,(a6)+      ; Peakwert li im Peakbuffer speichern
               move.l     a3,(a6)+      ; Peakwert re im Peakbuffer speichern
               move.l     a6,(a4)       ; neue Peakbuffer-Adresse retten
               move.l     a0,d6
               move.w     d6,d7
               swap.w     d6
               cmp.w      d7,d6
               blt.s      peakrm1
               move.w     d6,d7
peakrm1:       lea.l      rpeakmerk(pc),a4
               move.l     (a4),d1
               swap.w     d1
               cmp.w      d1,d7
               blt.s      pypnoadd
               move.w     d7,d1
pypnoadd:      swap.w     d1
               move.l     a3,d6
               move.w     d6,d7
               swap.w     d6
               cmp.w      d7,d6
               blt.s      peakrm2
               move.w     d6,d7
peakrm2:       cmp.w      d1,d7
               blt.s      pyircop2b
               move.w     d7,d1
pyircop2b:     move.l     d1,(a4)
               clr.l      a4            ; WertezÑhler lîschen
               clr.l      a0            ; Peakwert re lîschen
               clr.l      a3            ; Peakwert li lîschen
pbufweg:       rts        

peaksuch:      movea.l    (a0)+,a1      ; von
               movea.l    (a0)+,a2      ; bis
               lea.l      peakw(pc),a3
               clr.l      d1
               clr.l      d2
               clr.l      d3
               clr.l      d4
peak1:         move.w     (a1)+,d0
               cmp.w      d1,d0
               blt.s      peak2
               move.w     d0,d1
peak2:         move.w     (a1)+,d0
               cmp.w      d2,d0
               blt.s      peak3
               move.w     d0,d2
peak3:         move.w     (a1)+,d0
               cmp.w      d3,d0
               blt.s      peak4
               move.w     d0,d3
peak4:         move.w     (a1)+,d0
               cmp.w      d4,d0
               blt.s      peak5
               move.w     d0,d4
peak5:         cmpa.l     a2,a1
               bne.s      peak1
               move.w     d1,(a3)       ; maxwert pos links
               move.w     d2,2(a3)      ; maxwert neg links
               move.w     d3,4(a3)      ; maxwert pos rechts
               move.w     d4,6(a3)      ; maxwert neg rechts
               move.l     a3,d0
               rts        


mixit:         move.w     (a0)+,d0      ; Anzahl der MixkanÑle
               cmpi.w     #16,d0
               beq        mix16
               cmpi.w     #12,d0
               beq        mix12
               cmpi.w     #8,d0
               beq.s      mix8
               cmpi.w     #4,d0
               beq.s      mix4
               move.l     #-1,d0
               rts        

; Mixt 2 StereokanÑle (=4 MonokanÑle) zusammen

mix4:          movea.l    (a0)+,a2      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a4      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle2adresse
               clr.l      d2
               clr.l      d5
               move.l     #100,d3
               move.b     (a6)+,d2      ; Volume1
               move.b     (a6),d5       ; Volume2
accu:          move.w     (a2)+,d6      ; source1
               move.w     (a3)+,d7      ; source2
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
               bsr        mixer
               move.w     d7,(a4)+      ; d7,destination
               subq.l     #1,d0
               tst.l      d0
               bne.s      accu
               rts        

mixer:         btst       #15,d6        ; mixt (d6 und d7) nach d7
               beq.s      noneg
               neg.w      d6
               btst       #15,d7
               bne.s      negneg
negplus:       neg.w      d6
               add.w      d6,d7
               bra.s      accuweg
negneg:        neg.w      d7
               add.w      d6,d7
               neg.w      d7
               bra.s      accuweg
noneg:         btst       #15,d7
               beq.s      plusplus
plusneg:       neg.w      d7
               neg.w      d7
               add.w      d6,d7
               bra.s      accuweg
plusplus:      add.w      d6,d7
accuweg:       rts        


; Mixt 4 StereokanÑle (=8 MonokanÑle) zusammen

mix8:          movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
               move.l     #100,d3
               clr.l      d2
               clr.l      d5
accu8:         move.w     (a1)+,d6      ; source1
               move.w     (a2)+,d7      ; source2
               move.b     (a6),d2       ; Volume1
               move.b     1(a6),d5      ; Volume2
               cmp.w      d2,d3
               beq.s      nomul8a
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul8a:       cmp.w      d5,d3
               beq.s      nomul8b
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul8b:       bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,d1
               move.w     (a3)+,d6      ; source3
               move.w     (a4)+,d7      ; source4
               move.b     2(a6),d2      ; Volume3
               move.b     3(a6),d5      ; Volume4
               cmp.w      d2,d3
               beq.s      nomul8c
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul8c:       cmp.w      d5,d3
               beq.s      nomul8d
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul8d:       bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d1,d6
               bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,(a5)+      ; d7,destination
               subq.l     #1,d0
               tst.l      d0
               bne.s      accu8
               rts        


; Mixt 6 StereokanÑle (=12 MonokanÑle) zusammen

mix12:         movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a6      ; zieladresse
               move.l     a6,-(sp)      ; zieladresse retten
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
               movea.l    a4,a5
               adda.l     d1,a5         ; quelle3adresse
               movea.l    a5,a0
               adda.l     d1,a0         ; quelle4adresse
               move.l     #100,d3
               clr.l      d2
               clr.l      d5
accu12:        move.w     (a1)+,d6      ; source1
               move.w     (a2)+,d7      ; source2
               move.b     (a6),d2       ; Volume1
               move.b     1(a6),d5      ; Volume2
               cmp.w      d2,d3
               beq.s      nomul12a
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul12a:      cmp.w      d5,d3
               beq.s      nomul12b
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul12b:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,d1
               move.w     (a3)+,d6      ; source3
               move.w     (a4)+,d7      ; source4
               move.b     2(a6),d2      ; Volume3
               move.b     3(a6),d5      ; Volume4
               cmp.w      d2,d3
               beq.s      nomul12c
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul12c:      cmp.w      d5,d3
               beq.s      nomul12d
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul12d:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d1,d6
               bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,d1
               move.w     (a5)+,d6      ; source5
               move.w     (a0)+,d7      ; source6
               move.b     4(a6),d2      ; Volume5
               move.b     5(a6),d5      ; Volume6
               cmp.w      d2,d3
               beq.s      nomul12e
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul12e:      cmp.w      d5,d3
               beq.s      nomul12f
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul12f:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d1,d6
               bsr        mixer         ; mixt (d6 und d7) nach d7
               movea.l    a6,a0
               movea.l    (sp)+,a6
               move.w     d7,(a6)+      ; d7,destination
               move.l     a6,-(sp)
               movea.l    a0,a6
               subq.l     #1,d0
               tst.l      d0
               bne.s      accu12
               movea.l    (sp)+,a6
               rts        


; Mixt 8 StereokanÑle (=16 MonokanÑle) zusammen

mix16:         movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               move.l     #100,d3
               clr.l      d2
               clr.l      d5
accu16:        movea.l    a1,a2
               move.w     (a2),d6       ; source1
               adda.l     d1,a2
               move.w     (a2),d7       ; source2
               move.b     (a6),d2       ; Volume1
               move.b     1(a6),d5      ; Volume2
               cmp.w      d2,d3
               beq.s      nomul16a
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16a:      cmp.w      d5,d3
               beq.s      nomul16b
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16b:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,-(sp)      ; ergebnis 1+2 retten
               adda.l     d1,a2
               move.w     (a2),d6       ; source3
               adda.l     d1,a2
               move.w     (a2),d7       ; source4
               move.b     2(a6),d2      ; Volume3
               move.b     3(a6),d5      ; Volume4
               cmp.w      d2,d3
               beq.s      nomul16c
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16c:      cmp.w      d5,d3
               beq.s      nomul16d
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16d:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     (sp)+,d6      ; ergebnis 1+2 holen
               bsr        mixer         ; mixt 1+2 und 3+4 zusammen
               move.w     d7,-(sp)
               adda.l     d1,a2
               move.w     (a2),d6       ; source5
               adda.l     d1,a2
               move.w     (a2),d7       ; source6
               move.b     4(a6),d2      ; Volume5
               move.b     5(a6),d5      ; Volume6
               cmp.w      d2,d3
               beq.s      nomul16e
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16e:      cmp.w      d5,d3
               beq.s      nomul16f
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16f:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,-(sp)      ; ergebnis 5+6 retten
               adda.l     d1,a2
               move.w     (a2),d6       ; source7
               adda.l     d1,a2
               move.w     (a2),d7       ; source8
               move.b     6(a6),d2      ; Volume7
               move.b     7(a6),d5      ; Volume8
               cmp.w      d2,d3
               beq.s      nomul16g
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16g:      cmp.w      d5,d3
               beq.s      nomul16h
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16h:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     (sp)+,d6      ; ergebnis 5+6 holen
               bsr        mixer         ; mixt 5+6 und 7+8 zusammen
               move.w     (sp)+,d6      ; ergebnis 1+2+3+4 holen
               bsr        mixer         ; mixt 1+2+3+4 und 5+6+7+8 zusammen
               move.w     d7,(a5)+      ; d7,destination (1-8)
               addq.l     #2,a1
               subq.l     #1,d0
               tst.l      d0
               bne        accu16
               rts        

muster:        movea.l    (a0)+,a1      ; anfadresse
               move.l     (a0)+,d0
               move.l     (a0)+,d1
muster2:       move.l     d1,(a1)+
               cmpa.l     d0,a1
               blt.s      muster2
               rts        

testbits:      movea.l    (a0)+,a1      ; anfadresse
               move.l     (a0)+,d0
               move.l     d0,d2
               sub.l      a1,d2
               asr.l      #8,d2
               move.l     #0,d1
               clr.l      d3
testbit2:      move.l     d1,(a1)+
               addi.l     #1,d3
               cmp.l      d2,d3
               blt.s      testbit2
               clr.l      d3
               move.l     #1,d1
testbit3:      move.l     d1,(a1)+
               addi.l     #1,d3
               cmp.l      d2,d3
               blt.s      testbit3
               clr.l      d3
               cmpi.l     #$80000000,d1
               beq.s      testbit4
               asl.l      #1,d1
               bra.s      testbit3
testbit4:      rts        


fastcut:       movea.l    (a0)+,a1      ; anfadresse
               move.l     (a0)+,d0
               movea.l    d0,a6         ; endadresse
               sub.l      a1,d0         ; ist die Anzahl der Bytes
               clr.l      d2            ; Register lîschen
               moveq.l    #48,d1
               cmp.l      d1,d0
               blt.s      cutrest
               clr.l      d3
               clr.l      d4
               clr.l      d5
               clr.l      d6
               clr.l      d7
               movea.l    d2,a0
               movea.l    a0,a1
               movea.l    a0,a2
               movea.l    a0,a3
               movea.l    a0,a4
               movea.l    a0,a5         ; sind zusammen 13 Register = 52 Bytes
fastcut2:      movem.l    d2-d7/a0-a5,-(a6)
               sub.l      d1,d0
               cmp.l      d1,d0
               bge.s      fastcut2
cutrest:       tst.l      d0
               beq.s      cutend
cutrest2:      lsr.l      #2,d0
               subq.l     #1,d0
cutrest3:      move.l     d2,-(a6)
               dbra       d0,cutrest3
cutend:        rts        

intbreak:      movem.l    a1/a6,-(sp)
               lea.l      intreg(pc),a1
               move.b     (a1),d1
               bclr       d0,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$280(a6)
               movem.l    (sp)+,a1/a6
               rts        

fading:        movea.l    (a0)+,a3      ; data
               move.l     (a0)+,d0      ; werte
               movea.l    (a0)+,a1      ; anfang
               movea.l    (a0)+,a2      ; ende
               movea.l    a3,a0
               move.l     a2,d3
               move.l     a1,d2
               sub.l      d2,d3
               asr.l      #2,d3         ; Sampleanzahl
               andi.l     #$3fffffff,d3
               divu.w     d0,d3         ; Samples/Werte = Anzahl Samples pro Wert
               andi.w     #$ffff,d3
               cmpi.w     #0,d3
               bne.s      fadanf2a
               move.w     #1,d3         ; mind. 1 Sample pro Wert
fadanf2a:      subi.w     #1,d0
fadanf2:       move.w     (a0),d2
               move.w     2(a0),d6      ; erste beiden Datenwerte holen
               sub.w      d2,d6         ; voneinander subtrahieren = Steigung
               andi.l     #$ffff,d6
               btst       #15,d6
               beq.s      fpositiv      ; -> positive Steigung
fnegativ:      neg.w      d6
               cmpi.w     #0,d3
               beq.s      fneg2
               divu.w     d3,d6         ; Steigung/Anzahl Samples pro Wert = SteigungsstÅck
               andi.w     #$ffff,d6
fneg2:         neg.w      d6
               bra.s      fadanf2b
fpositiv:      cmpi.w     #0,d3
               beq.s      fadanf2b
               divu.w     d3,d6         ; Steigung/Anzahl Samples pro Wert
fadanf2b:      andi.w     #$ffff,d6
               bsr        fmax          ; hîchsten Wert suchen, ist in d5
               move.w     d3,d4
               subi.w     #1,d4         ; Anzahl Samples pro Wert holen fÅr Schleife
fadanf3:       move.w     (a1),d1       ; Sample holen
               bsr        fade          ; faden
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
               move.w     (a1),d1       ; Sample holen
               bsr        fade          ; faden
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
               add.w      d6,d2         ; SteigungsstÅck zum Anfangswert dazu
               andi.w     #$ffff,d2
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
               dbra       d4,fadanf3    ; Anzahl Samples pro Wert
               addq.l     #2,a0         ; zum nÑchsten Datenwert
               dbra       d0,fadanf2    ; Anzahl Werte
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
fadanf4:       move.w     (a1),d1
               bsr        fade          ; rest faden
               cmpa.l     a2,a1
               blt.s      fadanf4       ; bis zum Ende ?
fadweg:        rts        
fade:          andi.l     #$ffff,d1     ; aktuelles Sample
               cmpi.w     #0,d5         ; hîchster Wert ist null ?
               beq.s      fweiter       ; dann weg hier
               btst       #15,d1
               beq.s      fnoneg        ; wenn positiv dahin
               not.w      d1
               mulu.w     d2,d1         ; mal aktuelle Steigung
               divu.w     d5,d1         ; geteilt durch Hîchstwert
               not.w      d1
               bra.s      fweiter
fnoneg:        mulu.w     d2,d1         ; mal aktuelle Steigung
               divu.w     d5,d1         ; geteilt durch Hîchstwert
fweiter:       move.w     d1,(a1)+      ; Sample speichern, zum nÑchsten Sample
               rts        
fmax:          move.w     d3,d4
               add.w      d4,d4         ; Samples pro Wert*2
               subi.w     #2,d4         ; und minus 2
               move.w     #0,d5
               movea.l    a1,a3         ; Anfang in a3 merken
fmax2:         move.w     (a1)+,d1
               btst       #15,d1
               beq.s      fnoneg2
               not.w      d1
fnoneg2:       cmp.w      d5,d1
               ble.s      fweiter2
               move.w     d1,d5         ; hîchsten Wert suchen und in d5 merken
fweiter2:      dbra       d4,fmax2
               movea.l    a3,a1         ; Anfang zurÅck in a1
               rts        

zerono:        movea.l    (a0)+,a3      ; anf
               movea.l    (a0)+,a1      ; ende
               move.w     (a0)+,d0      ; Richtung
               movea.l    a3,a0
               cmpi.w     #0,d0
               bne.s      znback
znvor:         move.w     (a0)+,d1
               cmpi.l     #0,d1
               bne.s      znvorweg
               cmpa.l     a1,a0
               blt.s      znvor
               move.l     #-1,d0
               bra.s      znweg
znvorweg:      move.l     a0,d0
               subq.l     #4,d0
               bra.s      znweg
znback:        move.l     -(a1),d1
               cmpi.l     #0,d1
               bne.s      znbackweg
               cmpa.l     a0,a1
               bgt.s      znback
               move.l     #-1,d0
               bra.s      znweg
znbackweg:     move.l     a1,d0
znweg:         rts        

digana:        lea.l      lowreg(pc),a1
               move.b     (a1),d1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #1,d0
               bgt.s      digerr
               cmpi.w     #0,d0
               blt.s      digerr
               andi.w     #$fe,d1
               add.b      d0,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,(a6)
               cmpi.w     #0,d0
               bne.s      analog
               andi.w     #3,d1
               move.b     d1,(a6)
analog:        clr.l      d0
               rts        
digerr:        move.l     #-1,d0
               rts        

digcom:        lea.l      lowreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #2,d0
               bgt.s      digerr
               cmpi.w     #0,d0
               blt.s      digerr
               bne.s      inkoax
inopto:        bclr       #1,d1
               bra.s      digcom2
inkoax:        cmpi.b     #1,d0
               bne.s      inaes
               bset       #1,d1
digcom2:       move.b     d1,(a1)
               move.b     d1,(a6)
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               bclr       #7,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               clr.l      d0
               rts        
inaes:         bset       #1,d1
               move.b     d1,(a1)
               move.b     d1,(a6)
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               bset       #7,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               clr.l      d0
               rts        

sclock:        lea.l      lowreg(pc),a1
               move.b     (a1),d1
               move.w     (a0)+,d0      ; wert
               lea.l      hz(pc),a2
               move.w     d0,(a2)
               cmpi.w     #0,d0
               blt.s      sclocke
               bne.s      sclock1
               andi.w     #3,d1
               bra.s      sclockwr
sclock1:       cmpi.w     #1,d0
               bne.s      sclock2
               andi.w     #3,d1
               bset       #2,d1
               bra.s      sclockwr
sclock2:       cmpi.w     #2,d0
               bne.s      sclock3
               andi.w     #3,d1
               bset       #3,d1
               bra.s      sclockwr
sclock3:       cmpi.w     #3,d0
               bne.s      sclock4
               andi.w     #3,d1
               bset       #2,d1
               bset       #3,d1
               bra.s      sclockwr
sclock4:       cmpi.w     #15,d0
               bgt.s      sclocke
               andi.w     #3,d1
               subi.w     #4,d0
               lea.l      sclockv(pc),a3
               move.b     0(a3,d0.w),d2
               add.b      d2,d1
sclockwr:      move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,(a6)
               clr.l      d0
               rts        
sclocke:       move.l     #-1,d0
               rts        

errorcode:     lea.l      hireg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               clr.l      d0
               move.b     $20(a6),d0
               andi.w     #7,d0
               rts        

digcode:       lea.l      hireg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               bset       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               clr.l      d0
               move.b     $20(a6),d0
               btst       #7,d0
               bne.s      emphyes
               andi.w     #7,d0
               bra.s      digcod2
emphyes:       andi.w     #7,d0
               bset       #3,d0
digcod2:       bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               bchg       #3,d0
               andi.b     #$0f,d0
               rts        

frecres:       lea.l      snderr(pc),a1
               bclr       #4,(a1)
               bclr       #5,(a1)
               lea.l      stack(pc),a0
               move.w     #1,(a0)
               bsr        compatible
               clr.l      d0            ; fÅr Fifo-reset weglassen
               rts                      ; dito

recreset:      movem.l    d0-d7/a0-a6,-(sp)
               lea.l      hireg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               bset       #1,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.l     #2,d0
               bsr        pause
               bclr       #1,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.l     #2,d0
               bsr        pause
               bsr        kickstart
               movem.l    (sp)+,d0-d7/a0-a6
               clr.l      d0
               rts        

kickstart:     lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      dspreg(pc),a2
               move.b     (a2),d2
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               andi.b     #$fb,d1
               move.b     d1,$40(a6)
               addi.w     #4,d1
               move.b     d1,$40(a6)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               move.b     d2,$80(a6)
               lea.l      aesreg(pc),a3
               move.b     (a3),d3
               move.w     #4,d7
toggle:        bset       #3,d3
               move.b     d3,$c0(a6)
               move.b     d3,$c0(a6)
               move.l     #2,d0
               bsr        pause
               bclr       #3,d3
               move.b     d3,$c0(a6)
               move.l     #2,d0
               bsr        pause
               dbra       d7,toggle
               move.l     #2,d0
               bsr        pause
               move.b     (a3),d3
               move.b     d3,$c0(a6)
               move.b     (a2),d2
               move.b     d2,$80(a6)
               andi.b     #$fb,d1
               move.b     d1,$40(a6)
               move.l     #2,d0
               bsr        pause
               lea.l      playmod(pc),a1
               move.w     (a1),d1
               cmpi.w     #2,d1
               ble.s      kickleave
               lea.l      montrack(pc),a1
               move.w     (a1),d0
               clr.w      d7
               bsr        setmontr2
kickleave:     clr.l      d0
               rts        


bypass:        lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      dspreg(pc),a2
               move.b     (a2),d2
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d0      ; wert
               cmpi.w     #0,d0
               blt.s      byperr
               cmpi.w     #1,d0
               bgt.s      byperr
               beq.s      fifoplay
               movem.l    d0-d7/a0-a6,-(sp)
               move.w     #0,d3
               bsr        profmake
               movem.l    (sp)+,d0-d7/a0-a6
               andi.b     #$fb,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               addi.w     #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               lea.l      dspart(pc),a3
               move.w     (a3),d3
               cmpi.w     #0,d3
               bne.s      bypass2
               addi.b     #2,d2         ; A/D->D/A
               bra.s      bypassx
bypass2:       addi.w     #3,d2         ; DSP-Out->D/A
bypassx:       move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      damod(pc),a3  ; DA-Mode
               andi.b     #3,d2
               move.b     d2,(a3)
               cmpi.w     #2,d3
               bne.s      bypassz
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #2,d2         ; A/D->DSP-Input
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      dspmod(pc),a3 ; DSP-Mode
               move.b     #2,(a3)
bypassz:       clr.l      d0
               rts        
byperr:        move.l     #-1,d0
               rts        

fifoplay:      movem.l    d0-d7/a0-a6,-(sp)
               move.w     #1,d3
               bsr        profmake
               movem.l    (sp)+,d0-d7/a0-a6
               andi.b     #$fb,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               addi.w     #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               lea.l      damod(pc),a4  ; DA-Mode
               lea.l      dspart(pc),a3
               move.w     (a3),d3
               cmpi.w     #2,d3
               beq.s      fifopla2
               addi.b     #1,d2         ; DMA-Play->D/A
               move.b     #1,(a4)
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               clr.l      d0
               rts        
fifopla2:      addi.b     #3,d2         ; DSP-Out->D/A
               move.b     #3,(a4)
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #1,d2         ; DMA-Play->DSP-Input
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      dspmod(pc),a3 ; DSP-Mode
               move.b     #1,(a3)
               clr.l      d0
               rts        

profmake:      lea.l      proffm(pc),a2
               move.w     (a2),d2
               cmpi.w     #0,d2
               bne.s      proffja
proffno:       cmpi.w     #0,d3
               bne.s      proffno1
proffno0:      lea.l      bridg3(pc),a3
               move.w     (a3),-(sp)
               bsr        copyone
               lea.l      bridg4(pc),a3
               move.w     (a3),-(sp)
               bsr        prot
               bra.s      profend
proffno1:      lea.l      bridg1(pc),a3
               move.w     (a3),-(sp)
               bsr        copyone
               lea.l      bridg2(pc),a3
               move.w     (a3),-(sp)
               bsr        prot
profend:       rts        
proffja:       cmpi.w     #0,d3
               bne.s      profja1
profja0:       move.w     #0,d2
               move.w     d2,(a2)
               lea.l      cat0(pc),a3
               lea.l      catb0(pc),a4
               move.w     (a4),(a3)
               lea.l      cat1(pc),a3
               lea.l      catb1(pc),a4
               move.w     (a4),(a3)
               lea.l      scms(pc),a3
               move.w     (a3),-(sp)
               bsr        prot
               lea.l      gen(pc),a3
               move.w     (a3),-(sp)
               bsr        genera
               lea.l      cat0(pc),a3
               move.w     (a3),-(sp)
               bsr        categ0
               lea.l      cat1(pc),a3
               move.w     (a3),-(sp)
               bsr        categ1
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      empha(pc),a6
               move.w     (a6),d0       ; wert
               bsr        emphasis2
               lea.l      aesreg(pc),a3
               move.b     (a3),d4
               bclr       #0,d4
               move.b     d4,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d4,$c0(a6)
               rts        
profja1:       move.w     #1,d2
               move.w     d2,(a2)
               lea.l      cat0(pc),a3
               lea.l      catb0(pc),a4
               move.w     (a3),(a4)
               lea.l      cat1(pc),a3
               lea.l      catb1(pc),a4
               move.w     (a3),(a4)
               bsr        proffhz
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      empha(pc),a6
               move.w     (a6),d0       ; wert
               bsr        emphasis2
               move.w     #1,-(sp)
               bsr        genprof
               lea.l      aesreg(pc),a3
               move.b     (a3),d4
               bset       #0,d4
               move.b     d4,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d4,$c0(a6)
               rts        

prot:          move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      prot1
prot0:         bclr       #0,d6
               bra.s      prot2
prot1:         bset       #0,d6
prot2:         move.b     d6,(a6)
               lea.l      scms(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

categ0:        move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      cate1
cate0:         bclr       #6,d6
               bra.s      cate2
cate1:         bset       #6,d6
cate2:         move.b     d6,(a6)
               lea.l      cat0(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

categ1:        move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      cateb1
cateb0:        bclr       #7,d6
               bra.s      cateb2
cateb1:        bset       #7,d6
cateb2:        move.b     d6,(a6)
               lea.l      cat1(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

genera:        move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      genera1
genera0:       bclr       #5,d6
               bra.s      genera2
genera1:       bset       #5,d6
genera2:       move.b     d6,(a6)
               lea.l      gen(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

genprof:       move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      genprof1
genprof0:      bclr       #5,d6
               bra.s      genprof2
genprof1:      bset       #5,d6
genprof2:      move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

emphprof:      move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      emphprof1
emphprof0:     bclr       #4,d6
               bra.s      emphprof2
emphprof1:     bset       #4,d6
emphprof2:     move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

protprof:      move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
               bne.s      protprof1
protprof0:     bclr       #0,d6
               bra.s      protprof2
protprof1:     bset       #0,d6
protprof2:     move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

copyone:       move.l     (sp)+,d5
               lea.l      aesreg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               cmpi.w     #0,d7
;               bne.s      copyo1
copyo0:                   ;     bclr       #1,d6
;               bra.s      copyo2
copyo1:                   ;      bset       #1,d6
copyo2:        move.b     d6,(a6)
               lea.l      copyobit(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$c0(a6)
               move.l     d5,-(sp)
               rts        

proffhz:       lea.l      hz(pc),a1
               move.w     (a1),d0
               cmpi.w     #1,d0
               beq.s      proffhz32
               cmpi.w     #2,d0
               beq.s      proffhz44
               cmpi.w     #3,d0
               beq.s      proffhz48
               rts        
proffhz32:     move.w     #1,-(sp)
               bsr        protprof
               move.w     #1,-(sp)
               bsr        emphprof
               move.w     #1,-(sp)
               bsr        genprof
               rts        
proffhz44:     move.w     #1,-(sp)
               bsr        protprof
               move.w     #0,-(sp)
               bsr        emphprof
               move.w     #1,-(sp)
               bsr        genprof
               rts        
proffhz48:     move.w     #0,-(sp)
               bsr        protprof
               move.w     #1,-(sp)
               bsr        emphprof
               move.w     #1,-(sp)
               bsr        genprof
               rts        

playstat:      clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $40(a6),d0
               andi.w     #7,d0
               rts        

recstat:       clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $60(a6),d0
               andi.w     #7,d0
               rts        

dspmode:       
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      dspreg(pc),a2
               move.b     (a2),d2
               move.w     (a0)+,d0      ; wert
               cmpi.w     #0,d0
               blt        digerr
               cmpi.w     #2,d0
               bgt        digerr
               lea.l      dspart(pc),a3
               move.w     d0,(a3)
               cmpi.w     #0,d0
               beq.s      dspnoc
               cmpi.w     #1,d0
               beq.s      dspswin
               cmpi.w     #2,d0
               beq        dspswout
               clr.l      d0
               rts        
dspnoc:        andi.b     #$fb,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               addi.b     #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #2,d2         ; A/D->DMA-Rec
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      dmamod(pc),a3 ; DMA-Mode
               move.b     #2,(a3)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #2,d2         ; A/D->D/A
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      damod(pc),a3  ; D/A-Mode
               move.b     #2,(a3)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #2,d2
               move.b     d2,(a2)
               move.b     d2,$80(a6)    ; A/D->DSP-Input
               lea.l      dspmod(pc),a3 ; DSP-Mode
               move.b     #2,(a3)
               andi.b     #$fb,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               clr.l      d0
               rts        
dspswin:       andi.b     #$fb,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               addi.b     #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #3,d2         ; DSP-Output->DMA-Rec
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      dmamod(pc),a3 ; DMA-Mode
               move.b     #3,(a3)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #3,d2         ; DSP-Output->D/A
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      damod(pc),a3  ; D/A-Mode
               move.b     #3,(a3)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #2,d2         ; A/D->DSP-Input
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      dspmod(pc),a3 ; DSP-Mode
               move.b     #2,(a3)
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               andi.w     #$f9,d0
               move.b     d0,(a1)
               move.b     d0,$214(a6)
               clr.l      d0
               rts        
dspswout:      andi.b     #$fb,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               addi.b     #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #2,d2         ; A/D->DMA-Rec
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      dmamod(pc),a3 ; DMA-Mode
               move.b     #2,(a3)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #3,d2         ; DSP-Output->D/A
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      damod(pc),a3  ; D/A-Mode
               move.b     #3,(a3)
               move.b     d1,$40(a6)
               andi.b     #$fc,d2
               addi.b     #2,d2         ; A/D->DSP-Input
               move.b     d2,(a2)
               move.b     d2,$80(a6)
               lea.l      dspmod(pc),a3 ; DSP-Mode
               move.b     #2,(a3)
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               andi.w     #$f9,d0
               move.b     d0,(a1)
               move.b     d0,$214(a6)
               clr.l      d0
               rts        

digsrate:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.b     $80(a6),d0
               asr.w      #6,d0
               andi.w     #2,d0
               bset       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.b     $80(a6),d2
               asr.w      #7,d2
               andi.w     #1,d2
               add.w      d2,d0
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
dighz44:       cmpi.w     #0,d0
               bne.s      dighz48
               moveq.l    #2,d0
               rts        
dighz48:       cmpi.w     #2,d0
               bne.s      dighz32
               moveq.l    #3,d0
               rts        
dighz32:       cmpi.w     #3,d0
               bne.s      dighzerr
               moveq.l    #1,d0
               rts        
dighzerr:      clr.l      d0
               rts        

dspreset:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath1(pc),a1
               move.b     (a1),d1
               bset       #3,d1
               move.b     d1,(a1)
               move.b     d1,$210(a6)
               move.l     #2,d0
               bsr        pause
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$210(a6)
               move.l     #2,d0
               bsr        pause
               clr.l      d0
               rts        

volad:         lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               move.w     (a0)+,d2      ; wert left
               move.w     (a0)+,d3      ; wert right
               cmpi.w     #0,d2
               blt        digerr
               cmpi.w     #0,d3
               blt        digerr
               cmpi.w     #255,d2
               bgt        digerr
               cmpi.w     #255,d3
               bgt        digerr
volad2:        bclr       #3,d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bsr        volclk
               move.w     d2,d3
               bsr        volclk
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               clr.l      d0
               rts        

volclk:        move.w     #8,d0
volad0:        subi.w     #1,d0
               btst       d0,d3
               bne.s      volad1
               bclr       #4,d1
               bra.s      volad1b
volad1:        bset       #4,d1
volad1b:       move.b     d1,(a1)
               move.b     d1,$80(a6)
               bset       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               cmpi.w     #0,d0
               bne.s      volad0
               rts        

volda:         lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               move.w     (a0)+,d2      ; wert left
               move.w     (a0)+,d3      ; wert right
               cmpi.w     #0,d2
               blt        digerr
               cmpi.w     #0,d3
               blt        digerr
               cmpi.w     #255,d2
               bgt        digerr
               cmpi.w     #255,d3
               bgt        digerr
volda2:        bclr       #3,d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #5,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bsr        volclk
               move.w     d2,d3
               bsr        volclk
               bset       #5,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               clr.l      d0
               rts        

intact:        lea.l      intreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d3
               move.w     (a0)+,d0      ; wert
               cmpi.w     #0,d0
               blt        digerr
               cmpi.w     #3,d0
               bgt        digerr
nodintres:     move.b     d0,(a1)
               andi.w     #3,d0
               move.b     d0,$280(a6)
               clr.l      d0
               rts        

dspintact:     lea.l      dintreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq.s      infodspi
               cmpi.w     #0,d0
               blt        digerr
               cmpi.w     #3,d0
               bgt        digerr
               move.b     d0,(a1)
               cmpi.w     #0,d0
               bne.s      dspintgo
               move.b     $1ff(a6),d0
               andi.w     #$fc,d0
               move.b     d0,$1ff(a6)   ; dspint-stop
               bra.s      dspintex
dspintgo:      move.b     #124,$202(a6) ; dsp-intvector
               move.b     $1ff(a6),d1
               andi.w     #$fc,d1
               add.w      d0,d1
               move.b     d1,$1ff(a6)   ; dspint-start
dspintex:      clr.l      d0
               rts        
infodspi:      clr.l      d0
               move.b     $1ff(a6),d0
               andi.w     #3,d0
               rts        

dspcommnd:     move.w     (a0)+,d0      ; wert
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               bset       #7,d0
               addi.b     #18,d0
               move.b     d0,$200(a6)
               clr.l      d0
               rts        

dspclear:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $203(a6),d2
               move.b     $204(a6),d2
               move.b     $205(a6),d2
               move.b     $206(a6),d2
               clr.l      d0
               rts        

exclkmode:     move.w     (a0)+,d0      ; wert
               lea.l      exclkm(pc),a2
               cmpi.w     #-1,d0
               beq.s      exclkstat
               move.w     d0,(a2)
               clr.l      d0
               rts        
exclkstat:     move.w     (a2),d0
               rts        

emphasis:      lea.l      hireg(pc),a1
               move.b     (a1),d1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #1,d0
               bgt        digerr
               cmpi.w     #0,d0
               blt        digerr
emphasis2:     lea.l      proff(pc),a2
               move.b     (a2),d2
               btst       #0,d2         ;professional oder consumer ?
               bne.s      profmode
consmode:      cmpi.w     #0,d0
               bne.s      consmod1
               lea.l      empha(pc),a6
               move.w     #0,(a6)
               bclr       #3,d1
               bra.s      consmod2
consmod1:      bset       #3,d1
               lea.l      empha(pc),a6
               move.w     #1,(a6)
consmod2:      move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$40(a6)
               clr.l      d0
               rts        
profmode:      bclr       #3,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$40(a6)
               cmpi.w     #0,d0
               bne.s      profmod1
               lea.l      empha(pc),a6
               move.w     #0,(a6)
               move.w     #1,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               bra.s      profmod2
profmod1:      move.w     #0,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               lea.l      empha(pc),a6
               move.w     #1,(a6)
profmod2:      clr.l      d0
               rts        

digmode:       move.w     (a0)+,d0      ; wert
               cmpi.w     #1,d0
               bgt        digerr
               cmpi.w     #0,d0
               blt        digerr
               bne.s      digprof
digcons:       lea.l      proffm(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               beq.s      digcons2
               move.w     #0,d1
               move.w     d1,(a1)
               lea.l      cat0(pc),a3
               lea.l      catb0(pc),a4
               move.w     (a4),(a3)
               lea.l      cat1(pc),a3
               lea.l      catb1(pc),a4
               move.w     (a4),(a3)
               lea.l      scms(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        prot
               lea.l      gen(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        genera
               lea.l      cat0(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        categ0
               lea.l      cat1(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        categ1
               lea.l      empha(pc),a6
               move.w     (a6),d0       ; wert
               bsr        emphasis2
digcons2:      lea.l      aesreg(pc),a1
               move.b     (a1),d1
               bclr       #0,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$c0(a6)
               rts        
digprof:       lea.l      proffm(pc),a1
               move.b     #1,(a1)
               rts        

mycopybit:     move.w     (a0)+,d0      ; wert
               cmpi.w     #0,d0
               beq.s      mycopyno
               cmpi.w     #1,d0
               beq.s      mycopyone
               cmpi.w     #2,d0
               beq        mycopyall
               move.l     #-1,d0
               rts        
mycopyno:      lea.l      proff(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      proffce
               move.w     #1,-(sp)
               bsr        genera
               move.w     #1,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               lea.l      bridg1(pc),a1
               move.w     #0,(a1)
               lea.l      bridg2(pc),a1
               move.w     #0,(a1)
               lea.l      bridge(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      proffce
               move.w     #0,-(sp)
               bsr        copyone
               move.w     #0,-(sp)
               bsr        prot
proffce:       clr.l      d0
               rts        
mycopyone:     lea.l      proff(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      proffce
               move.w     #0,-(sp)
               bsr        genera
               move.w     #0,-(sp)
               bsr        categ0
               move.w     #0,-(sp)
               bsr        categ1
               lea.l      bridg1(pc),a1
               move.w     #1,(a1)
               lea.l      bridg2(pc),a1
               move.w     #1,(a1)
               lea.l      bridge(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      proffce
               move.w     #1,-(sp)
               bsr        copyone
               move.w     #1,-(sp)
               bsr        prot
               bra.s      proffce
mycopyall:     lea.l      proff(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      proffce
               move.w     #1,-(sp)
               bsr        genera
               move.w     #1,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               lea.l      bridg1(pc),a1
               move.w     #0,(a1)
               lea.l      bridg2(pc),a1
               move.w     #1,(a1)
               lea.l      bridge(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne        proffce
               move.w     #0,-(sp)
               bsr        copyone
               move.w     #1,-(sp)
               bsr        prot
               bra        proffce

scmsmode:      move.w     (a0)+,d0      ; wert
               cmpi.w     #1,d0
               bgt        digerr
               cmpi.w     #0,d0
               blt        digerr
               bne.s      scmsclr
scmsbridge:    lea.l      bridge(pc),a1
               move.w     #0,(a1)
               lea.l      bridg3(pc),a1
               lea.l      copyobit(pc),a2
               move.w     (a2),(a1)
               lea.l      bridg4(pc),a1
               lea.l      scms(pc),a2
               move.w     (a2),(a1)
               lea.l      copyobit(pc),a2
               move.w     (a2),d1
               move.w     d1,-(sp)
               bsr        copyone
               lea.l      scms(pc),a2
               move.w     (a2),d1
               move.w     d1,-(sp)
               bsr        prot
               clr.l      d0
               rts        
scmsclr:       lea.l      bridge(pc),a1
               move.w     #1,(a1)
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
;               bset       #1,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$c0(a6)
               lea.l      bridg3(pc),a1
               move.w     #1,(a1)
               lea.l      bridg4(pc),a1
               move.w     #0,(a1)
               lea.l      proff(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               bne.s      scmse
               lea.l      bridg4(pc),a1
               move.w     (a1),d1
               move.w     d1,-(sp)
               bsr        prot
scmse:         clr.l      d0
               rts        

readsmp:       clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     #256,d1
               move.w     #8,d2
readsmp2:      move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      readsmp3
               dbra       d1,readsmp2
rdsmperr:      move.l     #-1,d0
               rts        
readsmp3:      lea.l      smpwert(pc),a1
               movea.l    a1,a2
               move.b     d0,(a1)+
               move.w     $ff(a6),d0
               btst       d2,d0
               beq.s      readsmp2
               move.b     d0,(a1)+
               move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      rdsmperr
               move.b     d0,(a1)+
               move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      rdsmperr
               move.b     d0,(a1)+
               move.l     a2,d0
               rts        

highsrate:     lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      highsr(pc),a2
               move.w     (a2),d2
               lea.l      modr24(pc),a3
               move.w     (a3),d3
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d0
               cmpi.w     #1,d0
               bgt.s      higherr
               cmpi.w     #0,d0
               blt.s      higherr
               bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               cmpi.w     #0,d0
               bne.s      srateh
sratel:        move.w     #0,(a2)
               cmpi.w     #0,d3
               beq.s      highok
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               clr.l      d0
               rts        
srateh:        bset       #2,d1
               move.w     #1,(a2)
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               cmpi.w     #0,d3
               beq.s      highok
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
highok:        clr.l      d0
               rts        
higherr:       move.l     #-1,d0
               rts        

mode24:        lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      highsr(pc),a2
               move.w     (a2),d2
               lea.l      modr24(pc),a3
               move.w     (a0)+,d0
               cmpi.w     #1,d0
               bgt.s      errmd24
               cmpi.w     #0,d0
               blt.s      errmd24
               bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               cmpi.w     #0,d0
               bne.s      mdh24
               move.w     #0,(a3)
               cmpi.w     #0,d2
               beq.s      mdcweg
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               clr.l      d0
               rts        
mdh24:         move.w     #1,(a3)
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
mdclr24:       move.b     d1,$c0(a6)
               cmpi.w     #0,d2
               beq.s      mdcweg
               move.b     d1,$c0(a6)
mdcweg:        clr.l      d0
               rts        
errmd24:       move.l     #-1,d0
               rts        

writesmp:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     #8,d2
               move.w     (a0)+,d0
               move.w     d0,d1
               asr.w      d2,d0
               bset       d2,d0
               move.w     d0,$101(a6)
               bset       d2,d1
               move.w     d1,$101(a6)
               move.w     (a0)+,d0
               move.w     d0,d1
               asr.w      d2,d0
               bclr       d2,d0
               move.w     d0,$ff(a6)
               bclr       d2,d1
               move.w     d1,$ff(a6)
               clr.l      d0
               rts        

read_rlow:     clr.l      d0
               lea.l      lowreg(pc),a1
               move.b     (a1),d0
               rts        

read_rhi:      clr.l      d0
               lea.l      hireg(pc),a1
               move.b     (a1),d0
               rts        

read_raes:     clr.l      d0
               lea.l      aesreg(pc),a1
               move.b     (a1),d0
               rts        

read_rdsp:     clr.l      d0
               lea.l      dspreg(pc),a1
               move.b     (a1),d0
               andi.b     #$3f,d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $80(a6),d1
               andi.b     #$c0,d1
               add.b      d1,d0
               rts        

read_rint:     clr.l      d0
               lea.l      intreg(pc),a1
               move.b     (a1),d0
               rts        

read_dpath1:   clr.l      d0
               lea.l      dsppath1(pc),a1
               move.b     (a1),d0
               rts        

read_dpath2:   clr.l      d0
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               rts        

read_dport:    clr.l      d0
               lea.l      dspport(pc),a1
               move.b     (a1),d0
               rts        

read_dconv:    clr.l      d0
               lea.l      dspconv(pc),a1
               move.b     (a1),d0
               rts        

read_dpdat:    clr.l      d0
               lea.l      dsppdat(pc),a1
               move.b     (a1),d0
               rts        

read_dclk:     clr.l      d0
               lea.l      clkdiv(pc),a1
               move.b     (a1),d0
               rts        

point_dreg:    lea.l      dmarec(pc),a1
               move.l     a1,d0
               rts        

wr_dpath1:     move.w     (a0)+,d0
               lea.l      dsppath1(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$210(a6)
               clr.l      d0
               rts        

wr_dpath2:     move.w     (a0)+,d0
               lea.l      dsppath2(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$214(a6)
               clr.l      d0
               rts        

wr_dport:      move.w     (a0)+,d0
               lea.l      dspport(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$212(a6)
               clr.l      d0
               rts        

wr_dconv:      move.w     (a0)+,d0
               lea.l      dspconv(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$216(a6)
               clr.l      d0
               rts        

wr_dpdat:      move.w     (a0)+,d0
               lea.l      dsppdat(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$240(a6)
               clr.l      d0
               rts        

wr_dclk:       move.w     (a0)+,d0
               lea.l      clkdiv(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$242(a6)
               clr.l      d0
               rts        

wr_rlow:       move.w     (a0)+,d0
               lea.l      lowreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,(a6)
               clr.l      d0
               rts        

wr_rhi:        move.w     (a0)+,d0
               lea.l      hireg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$40(a6)
               clr.l      d0
               rts        

wr_raes:       move.w     (a0)+,d0
               lea.l      aesreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$c0(a6)
               clr.l      d0
               rts        

wr_rdsp:       move.w     (a0)+,d0
               lea.l      dspreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$80(a6)
               clr.l      d0
               rts        

wr_rint:       move.w     (a0)+,d0
               lea.l      intreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$280(a6)
               clr.l      d0
               rts        

cardmagic:     clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a6),d0
               andi.w     #$c7,d0
               btst       #6,d0
               beq.s      cardm2
               bset       #3,d0
cardm2:        btst       #7,d0
               beq.s      cardm3
               bset       #4,d0
cardm3:        move.b     $1ff(a6),d1
               cmpi.b     #$ff,d1
               bne.s      cardm4
               move.b     $200(a6),d2
               cmpi.b     #$ff,d2
               bne.s      cardm4
               move.b     $201(a6),d3
               cmpi.b     #$ff,d3
               bne.s      cardm4
               move.b     $202(a6),d4
               cmpi.b     #$ff,d4
               bne.s      cardm4
               move.b     $203(a6),d5
               cmpi.b     #$ff,d5
               bne.s      cardm4
               move.b     $204(a6),d6
               cmpi.b     #$ff,d6
               bne.s      cardm4
               move.b     $205(a6),d7
               cmpi.b     #$ff,d7
               bne.s      cardm4
               move.b     $206(a6),d7
               cmpi.b     #$ff,d7
               beq.s      cardm5
cardm4:        bset       #5,d0
cardm5:        andi.w     #$3f,d0
               rts        

cardslot:      clr.l      d0
               lea.l      cardz2(pc),a1
               move.w     (a1),d0
               rts        

cardsel:       clr.l      d0
               move.w     (a0)+,d0
               lea.l      cardz(pc),a1
               move.w     (a1),d1
               cmp.w      d1,d0
               ble.s      cardsel2
cardsex:       move.l     #-1,d0
               rts        
cardsel2:      cmpi.w     #1,d0
               blt.s      cardsex
cardsel3:      cmpi.w     #4,d0
               bgt.s      cardsex
               clr.l      d1
               move.w     d0,d1
               add.w      d1,d1
               add.w      d1,d1
               subi.w     #4,d1
               lea.l      vmestart(pc),a0
               lea.l      cardlist(pc),a1
               move.l     0(a1,d1.w),(a0)
               bsr        cardadr
               move.l     #0,d0
               rts        

cardadr:       lea.l      cadr(pc),a1
               move.l     a1,d0
               lea.l      vmestart(pc),a6
               move.l     (a6),d1
               addi.l     #$ff,d1
               move.l     d1,(a1)+
               move.l     (a6),d1
               addi.l     #$60,d1
               move.l     d1,(a1)+
               move.l     (a6),d1
               addi.l     #$40,d1
               move.l     d1,(a1)+
               move.l     (a6),d1
               addi.l     #$1ff,d1
               move.l     d1,(a1)
               rts        

; ----------------------------Falcon-Routinen-----------------------

locksnd:       lea.l      lock(pc),a1
               move.w     (a1),d1
               tst.w      d1
               beq.s      lockja
               move.l     #-129,d0
               rts        
lockja:        move.w     #1,(a1)
               move.l     #1,d0
               rts        

unlocksnd:     lea.l      lock(pc),a1
               move.w     (a1),d1
               tst.w      d1
               bne.s      unlockja
               move.l     #-128,d0
               rts        
unlockja:      move.w     #0,(a1)
               move.l     #0,d0
               rts        

soundcmd:      move.w     (a0)+,d0
               move.w     (a0)+,d1
               cmpi.w     #0,d0
               beq.s      ltatten
               cmpi.w     #1,d0
               beq.s      rtatten
               cmpi.w     #2,d0
               beq        ltgain
               cmpi.w     #3,d0
               beq        rtgain
               rts        
ltatten:       cmpi.w     #-1,d1
               beq.s      ltstat
               lea.l      ltatt(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               lea.l      ltatt(pc),a2
               move.w     (a2),d2
               asr.w      #2,d2
               andi.w     #$3f,d2
               move.w     #192,d0
               sub.w      d2,d0
               move.w     d0,d2         ; wert left
               lea.l      rtatt(pc),a2
               move.w     (a2),d3
               asr.w      #2,d3
               andi.w     #$3f,d3
               move.w     #192,d0
               sub.w      d3,d0
               move.w     d0,d3         ; wert right
               bsr        volda2
ltstat:        lea.l      ltatt(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
rtatten:       cmpi.w     #-1,d1
               beq.s      rtstat
               lea.l      rtatt(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               lea.l      ltatt(pc),a2
               move.w     (a2),d2
               asr.w      #2,d2
               andi.w     #$3f,d2
               move.w     #192,d0
               sub.w      d2,d0
               move.w     d0,d2         ; wert left
               lea.l      rtatt(pc),a2
               move.w     (a2),d3
               asr.w      #2,d3
               andi.w     #$3f,d3
               move.w     #192,d0
               sub.w      d3,d0
               move.w     d0,d3         ; wert right
               bsr        volda2
rtstat:        lea.l      rtatt(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
ltgain:        cmpi.w     #-1,d1
               beq.s      lgstat
               lea.l      lgain(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               lea.l      lgain(pc),a2
               move.w     (a2),d2
               asr.w      #4,d2
               andi.w     #$f,d2
               mulu.w     #3,d2
               bset       #7,d2
               bset       #6,d2         ; wert left
               lea.l      rgain(pc),a2
               move.w     (a2),d3
               asr.w      #4,d3
               andi.w     #$f,d3
               mulu.w     #3,d3
               bset       #7,d3
               bset       #6,d3         ; wert right
               bsr        volad2
lgstat:        lea.l      lgain(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
rtgain:        cmpi.w     #-1,d1
               beq.s      rgstat
               lea.l      rgain(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               lea.l      lgain(pc),a2
               move.w     (a2),d2
               asr.w      #4,d2
               andi.w     #$f,d2
               mulu.w     #3,d2
               bset       #7,d2
               bset       #6,d2         ; wert left
               lea.l      rgain(pc),a2
               move.w     (a2),d3
               asr.w      #4,d3
               andi.w     #$f,d3
               mulu.w     #3,d3
               bset       #7,d3
               bset       #6,d3         ; wert right
               bsr        volad2
rgstat:        lea.l      rgain(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        

setbuffer:     move.w     (a0)+,d0
               move.l     (a0)+,d1
               move.l     (a0)+,d2
               cmpi.w     #0,d0
               beq.s      setpbuf
               cmpi.w     #1,d0
               beq.s      setrbuf
               clr.l      d0
               rts        
setpbuf:       lea.l      pbufstrt(pc),a1
               move.l     d1,(a1)
               lea.l      pbufptr(pc),a1
               move.l     d1,(a1)
               lea.l      pbufend(pc),a1
               move.l     d2,(a1)
               clr.l      d0
               rts        
setrbuf:       lea.l      rbufstrt(pc),a1
               move.l     d1,(a1)
               lea.l      rbufptr(pc),a1
               move.l     d1,(a1)
               lea.l      rbufend(pc),a1
               move.l     d2,(a1)
               clr.l      d0
               rts        

setsndmode:    move.w     (a0)+,d1
               lea.l      sndmode(pc),a1
               move.w     d1,(a1)
               clr.l      d0
               rts        

settrack:      move.w     (a0)+,d1
               move.w     (a0)+,d2
               lea.l      ptracks(pc),a1
               lea.l      rtracks(pc),a2
               move.w     d1,(a1)
               move.w     d2,(a2)
               clr.l      d0
               rts        

setmontrack:   lea.l      montrack(pc),a1
               move.w     (a1),d7
               move.w     (a0)+,d0
setmontr2:     move.w     d0,(a1)
               cmpi.w     #0,d0
               blt        monterr
               cmpi.w     #3,d0
               bgt        monterr
               move.w     d0,d6
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      playmod(pc),a3
               move.w     (a3),d3
               cmpi.w     #2,d3
               bge.s      isma128
               lea.l      recmod(pc),a3
               move.w     (a3),d3
               cmpi.w     #2,d3
               bge.s      isma128
               bra.s      montok
isma128:       lea.l      aesreg(pc),a1
               move.b     (a1),d1
               btst       #3,d1
               bne.s      ism128
               bclr       #3,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               bset       #3,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
ism128:        cmp.w      d7,d0
               beq.s      montgo
               bgt.s      ism128b
               addi.w     #4,d0
ism128b:       sub.w      d7,d0
               cmpi.w     #0,d0
               beq.s      montgo
               move.b     d1,$c0(a6)
               cmpi.w     #1,d0
               beq.s      montgo
               move.b     d1,$c0(a6)
               cmpi.w     #2,d0
               beq.s      montgo
               move.b     d1,$c0(a6)
montgo:        lea.l      dspconv(pc),a2
               move.b     (a2),d2
               asl.w      #2,d6
               andi.w     #$c,d6
               andi.w     #$f3,d2
               add.b      d6,d2
               move.b     d2,(a2)
               move.b     d2,$216(a6)
montok:        clr.l      d0
               rts        
monterr:       move.l     #-1,d0
               rts        

setinterrupt:  move.w     (a0)+,d1
               lea.l      src_inter(pc),a1
               move.w     d1,(a1)
               move.w     (a0)+,d1
               lea.l      cause(pc),a1
               move.w     d1,(a1)
               clr.l      d0
               rts        

buffoper:      move.w     (a0)+,d1
               lea.l      bufop(pc),a1
               cmpi.w     #-1,d1
               beq.s      bufopstat
               move.w     d1,(a1)
               btst       #0,d1
               bne.s      fplaystrt
               lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #0,d0         ; play-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               lea.l      pbufptr(pc),a1
               lea.l      pbufstrt(pc),a2
               move.l     (a2),(a1)
buffop2:       btst       #2,d1
               bne        frecstrt
               lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #1,d0         ; rec-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               lea.l      rbufptr(pc),a1
               lea.l      rbufstrt(pc),a2
               move.l     (a2),(a1)
               clr.l      d0
               rts        
bufopstat:     move.w     (a1),d0
               rts        

fplaystrt:     move.w     d1,-(sp)
               lea.l      pbufstrt(pc),a1
               lea.l      von(pc),a2
               move.l     (a1),(a2)
               lea.l      playmod(pc),a6
               move.w     (a6),d0
               cmpi.w     #2,d0
               bge.s      fplaystart2
               lea.l      montrack(pc),a1
               clr.l      d1
               move.w     (a1),d1
               add.w      d1,d1
               add.w      d1,d1
               add.l      d1,(a2)
fplaystart2:   lea.l      pbufend(pc),a1
               lea.l      bis(pc),a2
               move.l     (a1),(a2)
               lea.l      pimode(pc),a2
               move.w     (a6),d0
               cmpi.w     #2,d0
               bge.s      fplaystart3
               move.l     #11,(a2)
fplaystart4:   lea.l      intreg(pc),a1
               move.b     (a1),d0
               bset       #0,d0         ; play-INT-setzen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               move.w     (sp)+,d1
               bra        buffop2
fplaystart3:   move.l     #25,(a2)
               bra.s      fplaystart4

frecstrt:      lea.l      rbufstrt(pc),a1
               lea.l      rvon(pc),a2
               move.l     (a1),(a2)
               lea.l      rbufend(pc),a1
               lea.l      rbis(pc),a2
               move.l     (a1),(a2)
               lea.l      rimode(pc),a2
               lea.l      recmod(pc),a6
               move.w     (a6),d0
               cmpi.w     #2,d0
               beq.s      frecstrt3
               move.l     #12,(a2)
frecstrt4:     lea.l      intreg(pc),a1
               move.b     (a1),d0
               bset       #1,d0         ; rec-INT-setzen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               clr.l      d0
               rts        
frecstrt3:     move.l     #26,(a2)
               bra.s      frecstrt4

dsptristate:   lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath1(pc),a2
               move.w     (a2),d2
               lea.l      dsppath2(pc),a3
               move.w     (a3),d3
               move.w     (a0)+,d0
               move.w     (a0)+,d1
               cmpi.w     #0,d0
               blt.s      trierr
               cmpi.w     #1,d0
               bgt.s      trierr
               cmpi.w     #0,d1
               blt.s      trierr
               cmpi.w     #1,d1
               bgt.s      trierr
               andi.w     #$f9,d2
               cmpi.w     #0,d0
               beq.s      triplay
               addi.b     #6,d2
triplay:       move.b     d2,(a2)
               move.b     d2,$210(a6)
               andi.w     #$fe,d2
               andi.w     #$fe,d3
               cmpi.w     #0,d1
               beq.s      trirec
               addi.b     #1,d2
               addi.b     #1,d3
trirec:        move.b     d2,(a2)
               move.b     d2,$210(a6)
               move.b     d3,(a3)
               move.b     d3,$214(a6)
triweg:        clr.l      d0
               rts        
trierr:        move.l     #-1,d0
               rts        

gpio:          lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d1
               move.w     (a0)+,d2
               cmpi.w     #0,d1
               beq.s      gpdir
               cmpi.w     #1,d1
               beq.s      gprd
               cmpi.w     #2,d1
               beq.s      gpwr
               move.l     #-1,d0
               rts        
gpdir:         lea.l      dspport(pc),a1
               move.b     (a1),d0
               bclr       #3,d0
               move.w     d2,d4
               asl.w      #3,d4
               andi.w     #8,d4
               add.b      d4,d0
               move.b     d0,$212(a6)
               move.b     d0,(a1)
               lea.l      dspconv(pc),a1
               move.b     (a1),d0
               andi.b     #$fc,d0
               asr.w      #1,d2
               andi.w     #3,d2
               add.b      d2,d0
               move.b     d0,$216(a6)
               move.b     d0,(a1)
               clr.l      d0
               rts        
gprd:          move.b     $212(a6),d0
               andi.l     #7,d0
               rts        
gpwr:          lea.l      dspport(pc),a1
               move.b     (a1),d0
               andi.w     #8,d0
               andi.b     #7,d2
               lea.l      gpiodat(pc),a1
               move.w     d2,(a1)
               bsr        gpiofreq
               add.b      d0,d2
               move.b     d2,$212(a6)
               clr.l      d0
               rts        

gpiofreq:      movem.l    d0-d7/a0-a6,-(sp)
               lea.l      srcclk(pc),a0
               move.w     (a0),d0
               cmpi.w     #1,d0
               beq.s      isextclk
               movem.l    (sp)+,d0-d7/a0-a6
               rts        
isextclk:      btst       #2,d2
               bne.s      adatfreq
               btst       #1,d2
               bne.s      adfreq
freqspdif:     lea.l      stack(pc),a0
               move.w     #0,(a0)
               bsr        sclock
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     #0,$242(a6)
               lea.l      stack(pc),a0
               move.w     #0,(a0)
               bsr        digana
               movem.l    (sp)+,d0-d7/a0-a6
               rts        
adfreq:        lea.l      stack(pc),a0
               move.w     #2,(a0)
               btst       #0,d2
               beq.s      adf44
               move.w     #3,(a0)
adf44:         bsr        sclock
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     #0,$242(a6)
               lea.l      stack(pc),a0
               move.w     #1,(a0)
               bsr        digana
               movem.l    (sp)+,d0-d7/a0-a6
               rts        
adatfreq:      lea.l      stack(pc),a0
               move.w     #13,(a0)
               bsr        sclock
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     #0,$242(a6)
               lea.l      stack(pc),a0
               move.w     #1,(a0)
               bsr        digana
               movem.l    (sp)+,d0-d7/a0-a6
               rts        

devconnect:    move.w     (a0)+,d1
               lea.l      src(pc),a1
               move.w     d1,(a1)
               move.w     (a0)+,d2
               lea.l      dst(pc),a1
               move.w     d2,(a1)
               move.w     (a0)+,d3
               lea.l      srcclk(pc),a1
               move.w     d3,(a1)
               move.w     (a0)+,d4
               lea.l      prescale(pc),a1
               move.w     d4,(a1)
               move.w     (a0)+,d5
               lea.l      protocol(pc),a1
               move.w     d5,(a1)
               cmpi.w     #0,d1
               beq        dmaout        ; source ist dmaplay
               cmpi.w     #1,d1
               beq        dspout        ; source ist dsp-transmit
               cmpi.w     #2,d1
               beq        extout        ; source ist ext-input (RDATA)
               cmpi.w     #3,d1
               beq        adout         ; source ist a/d
               move.l     #-1,d0
               rts        
devcone:       lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a3
               move.b     (a3),d3
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               move.w     playmod(pc),d0
               cmpi.w     #1,d0
               beq.s      devc4
               move.w     recmod(pc),d0
               cmpi.w     #1,d0
               bne.s      devcone2
devc4:         move.w     #4,d0
               bsr        matoutsel     ; zu 4Kanal-Mode
devcone2:      lea.l      srcclk(pc),a1
               move.w     (a1),d0
               cmpi.w     #1,d0
               beq.s      srccext
               cmpi.w     #2,d0
               beq.s      clkextall
               lea.l      exclkm(pc),a2
               move.w     (a2),d2
               tst.w      d2
               bne.s      devcfalc
               cmpi.w     #0,d0
               beq.s      srcint
               cmpi.w     #3,d0
               beq.s      clkofalc
               bra.s      srcint
devcfalc:      cmpi.w     #0,d0
               beq.s      clkofalc
               cmpi.w     #3,d0
               beq        srcint
srcint:        lea.l      prescale(pc),a1
               move.w     (a1),d2
               lea.l      stack(pc),a0
               move.w     d2,(a0)
               bsr        sclock
               clr.l      d0
               rts        
srccext:       lea.l      gpiodat(pc),a1
               move.w     (a1),d2
               bsr        gpiofreq
               clr.l      d0
               rts        
clkextall:     lea.l      prescale(pc),a1
               move.w     (a1),d0
               clr.l      d1
               move.w     d0,d1
               divu.w     #15,d1
               andi.l     #3,d1
               move.w     #15,d2
               sub.w      d1,d2         ; sclock-wert
               mulu.w     #15,d1
               sub.w      d1,d0
               cmpi.w     #0,d0
               beq.s      clkea2
               addq.w     #1,d0         ; clkdiv-wert
clkea2:        move.w     d0,-(sp)
               lea.l      stack(pc),a0
               move.w     d2,(a0)
               bsr        sclock
               move.w     (sp)+,d0
               lea.l      stack(pc),a0
               move.w     d0,(a0)
               bsr        clkdivide
               rts        
clkofalc:      lea.l      prescale(pc),a1
               move.w     (a1),d0
               cmpi.w     #0,d0
               beq.s      clkofdig
               addq.w     #1,d0
               lea.l      stack(pc),a0
               move.w     d0,(a0)
               bsr        clkdivide
               lea.l      stack(pc),a0
               move.w     #15,(a0)
               bsr        sclock
               rts        
clkofdig:      lea.l      stack(pc),a0
               move.w     #0,(a0)
               bsr        clkdivide
               lea.l      stack(pc),a0
               move.w     #0,(a0)
               bsr        sclock
               rts        

; Zielkomponente(n) mit DMAPLAY-Source verbinden
dmaout:        lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d7
               btst       #0,d2         ; ist DMAREC unser ziel ?
               bne.s      dmarset       ; wenn ja: DMAPLAY->DMAREC
               cmpi.w     #1,d7         ; DMAREC-quelle ist DMAPLAY(1) gewesen ?
               beq.s      dmamy         ; dann DMAREC-quelle entfernen
               cmpi.w     #0,d7         ; DMAREC-quelle ist geloescht ?
               beq.s      dmamy         ; dann DMAREC-quelle entfernen
               bra.s      dmaout1       ; nÑchstes ziel abfragen
dmamy:         move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #0,d0         ; DMAREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      dmaout1       ; nÑchstes ziel abfragen
dmarset:       move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; externen Matrix_input bestimmen:
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #2,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dmarset1b     ; dann matrix_input von dsp-transmit
               bset       #2,d7         ; sonst matrix_input von matrix_out
dmarset1b:     bclr       #1,d7
               move.b     d7,(a0)
               move.b     d7,$214(a6)   ; externen Matrix_input schreiben
dmaout1:       lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               move.w     (a0),d7
               btst       #1,d2         ; ist DSPREC unser ziel ?
               bne.s      dsprset       ; wenn ja: DMAPLAY->DSPREC
               cmpi.w     #1,d7         ; DSPREC-quelle ist DMAPLAY(1) gewesen ?
               beq.s      dmamy2        ; dann DSPREC-quelle entfernen
               cmpi.w     #0,d7         ; DSPREC-quelle ist geloescht ?
               beq.s      dmamy2        ; dann DSPREC-quelle entfernen
               bra.s      dmaout2       ; nÑchstes ziel abfragen
dmamy2:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; DSPREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      extrec(pc),a0 ; quelle von EXTOUT holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat EXTOUT eine quelle ?
               bne.s      dmaout2       ; wenn ja,nÑchstes ziel abfragen
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      dmaout2       ; nÑchstes ziel abfragen
dsprset:       move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bclr       #3,d7         ; quelle ist matrix_out
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
dmaout2:       lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     (a0),d7
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               bne.s      extrset       ; wenn ja: DMAPLAY->EXTOUT
               cmpi.w     #1,d7         ; EXTOUT-quelle ist dmaplay(1) gewesen ?
               beq.s      dmamy3        ; dann EXTOUT-quelle entfernen
               cmpi.w     #0,d7         ; EXTOUT-quelle ist geloescht ?
               beq.s      dmamy3        ; dann EXTOUT-quelle entfernen
               bra.s      dmaout3       ; nÑchstes ziel abfragen
dmamy3:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; EXTOUT-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      dsprec(pc),a0 ; quelle von DSPREC holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat DSPREC eine quelle ?
               bne.s      dmaout3       ; wenn ja,nÑchstes ziel abfragen
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      dmaout3       ; nÑchstes ziel abfragen
extrset:       move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bclr       #1,d7         ; quelle ist Matrix_out
               bclr       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
dmaout3:       lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a0),d7
               btst       #3,d2         ; ist DAC unser ziel ?
               bne.s      dacrset       ; wenn ja: DMAPLAY->DAC
               cmpi.w     #1,d7         ; DAC-quelle ist dmaplay(1) gewesen ?
               beq.s      dmamy4        ; dann DAC-quelle entfernen
               cmpi.w     #0,d7         ; DAC-quelle ist geloescht ?
               beq.s      dmamy4        ; dann DAC-quelle entfernen
               bra        dmaout4       ; nÑchstes ziel abfragen
dmamy4:        move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      dmaout4       ; nÑchstes ziel abfragen
dacrset:       move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #1,d0
               lea.l      playmod(pc),a2
               move.w     (a2),d7       ; playmode holen
               cmpi.w     #2,d7         ; playmode ist Vierkanal oder Stereo ?
               blt.s      dacrsetb      ; dann DMAPLAY->DAC
               move.w     #3,d0         ; sonst Matrix_in->DAC
dacrsetb:      move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; quelle von Matrix_in holen
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #2,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dacrsetb2     ; dann DSP_Transceive->Matrix_in
               bset       #2,d7         ; sonst Matrix_Out->Matrix_in
dacrsetb2:     bclr       #1,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
               lea.l      playmod(pc),a2
               move.w     (a2),d7       ; playmode holen
               cmpi.w     #2,d7         ; playmode ist Vierkanal oder Stereo ?
               blt.s      dmaout4       ; dann nÑchstes ziel abfragen
               move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; quelle DMAPLAY auswÑhlen(Sync/Takt)
               lea.l      extrec(pc),a0 ; als quelle von EXTOUT(ziel) setzen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; und setzen
dmaout4:       bra        devcone       ; fertig und raus hier...

; Zielkomponente(n) mit DSPXMIT-Source verbinden
dspout:        lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d7
               btst       #0,d2         ; ist DMAREC unser ziel ?
               bne.s      dmarset2      ; wenn ja: DSPXMIT->DMAREC
               cmpi.w     #3,d7         ; DMAREC-quelle ist DSPXMIT(3) gewesen ?
               beq.s      dspmy         ; dann DMAREC-quelle entfernen
               cmpi.w     #0,d7         ; DMAREC-quelle ist geloescht ?
               beq.s      dspmy         ; dann DMAREC-quelle entfernen
               bra.s      dspout1       ; nÑchstes ziel abfragen
dspmy:         move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #0,d0         ; DMAREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      dspout1       ; nÑchstes ziel abfragen
dmarset2:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #3,d0         ; mit quelle Matrix_in verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu Matrix_in setzen
               lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; externen Matrix-input bestimmen:
               bclr       #2,d7         ; dsp_transmit->Matrix_input
               bclr       #1,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
dspout1:       lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               move.w     (a0),d7
               btst       #1,d2         ; ist DSPREC unser ziel ?
               bne.s      dsprset2      ; wenn ja: DSPXMIT->DSPREC
               cmpi.w     #3,d7         ; DSPREC-quelle ist DSPXMIT(3) gewesen ?
               beq.s      dspmy2        ; dann DSPREC-quelle entfernen
               cmpi.w     #0,d7         ; DSPREC-quelle ist geloescht ?
               beq.s      dspmy2        ; dann DSPREC-quelle entfernen
               bra.s      dspout2       ; nÑchstes ziel abfragen
dspmy2:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; DSPREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      extrec(pc),a0 ; quelle von EXTOUT holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat EXTOUT eine quelle ?
               bne.s      dspout2       ; wenn ja,nÑchstes ziel abfragen
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      dspout2       ; nÑchstes ziel abfragen
dsprset2:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #3,d0         ; mit quelle DSPXMIT verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DSPXMIT setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bclr       #3,d7         ; quelle ist matrix_out
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
dspout2:       lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     (a0),d7
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               bne.s      extrset2      ; wenn ja: DSPXMIT->EXTOUT
               cmpi.w     #3,d7         ; EXTOUT-quelle ist DSPXMIT(3) gewesen ?
               beq.s      dspmy3        ; dann EXTOUT-quelle entfernen
               cmpi.w     #0,d7         ; EXTOUT-quelle ist geloescht ?
               beq.s      dspmy3        ; dann EXTOUT-quelle entfernen
               bra.s      dspout3       ; nÑchstes ziel abfragen
dspmy3:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; EXTOUT-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      dsprec(pc),a0 ; quelle von DSPREC holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat DSPREC eine quelle ?
               bne.s      dspout3       ; wenn ja,nÑchstes ziel abfragen
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      dspout3       ; nÑchstes ziel abfragen
extrset2:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #3,d0         ; quelle DSPXMIT setzen(vermerk)
               move.w     d0,(a0)       ; und sichern
               move.w     #1,d0
               bsr        matinsel      ; Verbindung DMAPLAY->Matrix_out setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bclr       #1,d7         ; quelle ist DSP_Transmit
               bset       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
dspout3:       lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a0),d7
               btst       #3,d2         ; ist DAC unser ziel ?
               bne.s      dacrset2      ; wenn ja: DSPXMIT->DAC
               cmpi.w     #3,d7         ; DAC-quelle ist DSPXMIT(3) gewesen ?
               beq.s      dspmy4        ; dann DAC-quelle entfernen
               cmpi.w     #0,d7         ; DAC-quelle ist geloescht ?
               beq.s      dspmy4        ; dann DAC-quelle entfernen
               bra.s      dspout4       ; nÑchstes ziel abfragen
dspmy4:        move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      dspout4       ; nÑchstes ziel abfragen
dacrset2:      move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; Matrix_in->DAC
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DSPXMIT setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; quelle von Matrix_in holen
               bclr       #2,d7         ; DSP-Transceive->Matrix_in
               bclr       #1,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
dspout4:       bra        devcone       ; fertig und raus hier...

; Zielkomponente(n) mit EXTINP-Source verbinden
extout:        lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d7
               btst       #0,d2         ; ist DMAREC unser ziel ?
               bne.s      dmarset3      ; wenn ja: EXTINP->DMAREC
               cmpi.w     #0,d7         ; DMAREC-quelle ist geloescht ?
               beq.s      extmy         ; dann DMAREC-quelle entfernen
;               cmpi.w     #3,d7         ; DMAREC-quelle ist EXTINP(3) gewesen ?
;               beq.s      extmy         ; dann DMAREC-quelle entfernen
               bra        extout1       ; nÑchstes ziel abfragen
extmy:         move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #0,d0         ; DMAREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      extout1       ; nÑchstes ziel abfragen
dmarset3:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #3,d0         ; mit quelle Matrix_in verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu Matrix_in setzen
               lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; externen Matrix_input bestimmen:
               bclr       #2,d7
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #1,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dmarset3b     ; dann matrix_input von dsp_transmit
               bset       #1,d7         ; sonst matrix_input von EXTINP (RDATA)
dmarset3b:     move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; externen Matrix-input schreiben
extout1:       lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               move.w     (a0),d7
               btst       #1,d2         ; ist DSPREC unser ziel ?
               bne.s      dsprset3      ; wenn ja: EXTINP->DSPREC
               cmpi.w     #3,d7         ; DSPREC-quelle ist EXTINP(3) gewesen ?
               beq.s      extmy2        ; dann DSPREC-quelle entfernen
               cmpi.w     #0,d7         ; DSPREC-quelle ist geloescht ?
               beq.s      extmy2        ; dann DSPREC-quelle entfernen
               bra.s      extout2       ; nÑchstes ziel abfragen
extmy2:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; DSPREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      extrec(pc),a0 ; quelle von EXTOUT holen
               move.w     (a0),d7       ; extout-quelle holen
               cmpi.w     #0,d7         ; hat EXTOUT eine quelle ?
               bne.s      extout2       ; wenn ja,nÑchstes ziel abfragen
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      extout2       ; nÑchstes ziel abfragen
dsprset3:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bset       #3,d7         ; quelle ist EXTINP
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
extout2:       lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     (a0),d7
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               bne.s      extrset3      ; wenn ja: EXTINP->EXTOUT
               cmpi.w     #0,d7         ; EXTOUT-quelle ist geloescht ?
               beq.s      extmy3        ; dann EXTOUT-quelle entfernen
               lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d0
               cmpi.w     #3,d0         ; DMAREC-quelle ist Matrix_in ?
               beq.s      extout3       ; dann nÑchstes ziel abfragen
               cmpi.w     #3,d7         ; EXTOUT-quelle ist EXTINP(3) gewesen?
               beq.s      extmy3        ; dann EXTOUT-quelle entfernen
               bra.s      extout3       ; nÑchstes ziel abfragen
extmy3:        move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; EXTOUT-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      dsprec(pc),a0 ; quelle von DSPREC holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat DSPREC eine quelle ?
               bne.s      extout3       ; wenn ja,nÑchstes ziel abfragen
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      extout3       ; nÑchstes ziel abfragen
extrset3:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #3,d0         ; EXTOUT mit quelle EXTINP verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     #1,d0
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bset       #1,d7         ; quelle ist EXTINP(RDATA)
               bclr       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
extout3:       lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a0),d7
               btst       #3,d2         ; ist DAC unser ziel ?
               bne.s      dacrset3      ; wenn ja: EXTINP->DAC
               cmpi.w     #3,d7         ; DAC-quelle ist EXTINP(3) gewesen ?
               beq.s      extmy4        ; dann DAC-quelle entfernen
               cmpi.w     #0,d7         ; DAC-quelle ist geloescht ?
               beq.s      extmy4        ; dann DAC-quelle entfernen
               bra.s      extout4       ; nÑchstes ziel abfragen
extmy4:        move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      extout4       ; nÑchstes ziel abfragen
dacrset3:      move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; Matrix_in->DAC
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; quelle von Matrix_in holen
               bclr       #2,d7
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #1,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dacrset3b     ; dann DSP_Transceive->Matrix_in
               bset       #1,d7         ; sonst EXTINP->Matrix_in
dacrset3b:     move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
extout4:       bra        devcone       ; fertig und raus hier...

adout:         lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d7
               btst       #0,d2         ; ist DMAREC unser ziel ?
               bne.s      dmarset4      ; wenn ja: ADC->DMAREC
               cmpi.w     #2,d7         ; DMAREC-quelle ist ADC(2) gewesen ?
               beq.s      admy          ; dann DMAREC-quelle entfernen
               cmpi.w     #0,d7         ; DMAREC-quelle ist geloescht ?
               beq.s      admy          ; dann DMAREC-quelle entfernen
               bra.s      adout1        ; nÑchstes ziel abfragen
admy:          move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #0,d0         ; DMAREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      adout1        ; nÑchstes ziel abfragen
dmarset4:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC setzen
adout1:        lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               move.w     (a0),d7
               btst       #1,d2         ; ist DSPREC unser ziel ?
               bne.s      dsprset4      ; wenn ja: ADC->DSPREC
               cmpi.w     #2,d7         ; DSPREC-quelle ist ADC(2) gewesen ?
               beq.s      admy2         ; dann DSPREC-quelle entfernen
               cmpi.w     #0,d7         ; DSPREC-quelle ist geloescht ?
               beq.s      admy2         ; dann DSPREC-quelle entfernen
               bra.s      adout2        ; nÑchstes ziel abfragen
admy2:         move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; DSPREC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      extrec(pc),a0 ; quelle von EXTOUT holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat EXTOUT eine quelle ?
               bne.s      adout2        ; wenn ja,nÑchstes ziel abfragen
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      adout2        ; nÑchstes ziel abfragen
dsprset4:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bclr       #3,d7         ; quelle ist matrix_out
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
adout2:        lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     (a0),d7
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               bne.s      extrset4      ; wenn ja: ADC->EXTOUT
               cmpi.w     #2,d7         ; EXTREC-quelle ist ADC(2) gewesen ?
               beq.s      admy3         ; dann EXTOUT-quelle entfernen
               cmpi.w     #0,d7         ; EXTOUT-quelle ist geloescht ?
               beq.s      admy3         ; dann EXTOUT-quelle entfernen
               bra.s      adout3        ; nÑchstes ziel abfragen
admy3:         move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #0,d0         ; EXTOUT-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               lea.l      dsprec(pc),a0 ; quelle von DSPREC holen
               move.w     (a0),d7
               cmpi.w     #0,d7         ; hat DSPREC eine quelle ?
               bne.s      adout3        ; wenn ja,nÑchstes ziel abfragen
               bsr        matinsel      ; quelle von Matrix_out loeschen
               bra.s      adout3        ; nÑchstes ziel abfragen
extrset4:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bclr       #1,d7         ; quelle ist Matrix_out
               bclr       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
adout3:        lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a0),d7
               btst       #3,d2         ; ist DAC unser ziel ?
               bne.s      dacrset4      ; wenn ja: ADC->DAC
               cmpi.w     #2,d7         ; DAC-quelle ist ADC(2) gewesen ?
               beq.s      admy4         ; dann DAC-quelle entfernen
               cmpi.w     #0,d7         ; DAC-quelle ist geloescht ?
               beq.s      admy4         ; dann DAC-quelle entfernen
               bra.s      adout4        ; nÑchstes ziel abfragen
admy4:         move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               bra.s      adout4        ; nÑchstes ziel abfragen
dacrset4:      move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC
adout4:        bra        devcone       ; fertig und raus hier...

matoutsel:     movem.l    d3/a3/a6,-(sp)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a3
               move.b     (a3),d3
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               cmpi.w     #0,d0
               beq.s      matoutgo
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               cmpi.w     #1,d0
               beq.s      matoutgo
               move.b     d3,$40(a6)
               cmpi.w     #2,d0
               beq.s      matoutgo
               move.b     d3,$40(a6)
               cmpi.w     #3,d0
               beq.s      matoutgo
               move.b     d3,$40(a6)
matoutgo:      movem.l    (sp)+,d3/a3/a6
               rts        

matinsel:      movem.l    d3/a3/a6,-(sp)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               andi.w     #$fc,d3
               andi.w     #3,d0
               add.b      d0,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               movem.l    (sp)+,d3/a3/a6
               rts        

sndstatus:     move.w     (a0)+,d1
               cmpi.w     #$dd02,d1
               beq.s      fdicook
               cmpi.w     #1,d1
               beq        frecres
sndstat2:      clr.l      d0
               lea.l      snderr(pc),a1
               move.w     (a1),d0
               bclr       #4,(a1)
               bclr       #5,(a1)
               rts        
fdicook:       move.l     #$4711,d0
               rts        

buffptr:       movea.l    (a0)+,a1
               lea.l      pbufptr(pc),a2
               move.l     (a2),(a1)+
               lea.l      rbufptr(pc),a2
               move.l     (a2),(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)
               clr.l      d0
               rts        

falcplay:      lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      ptracks(pc),a2
               clr.l      d4
               move.w     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      sndmode(pc),a6
               cmpi.w     #0,(a6)       ; sndmode stereo8
               bne.s      ptstereo16
               add.w      d4,d4
ptstereo16:    cmpi.w     #1,(a6)       ; sndmode stereo16
               bne.s      ptmono8
               add.w      d4,d4
               add.w      d4,d4
ptmono8:       move.l     #lfifo,d2     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               asr.w      #3,d2
               subi.w     #1,d2
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               adda.l     #$40,a0
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               adda.l     #$100,a1
               lea.l      pbufptr(pc),a5
               movea.l    a3,a2
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        fplayend
fpfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrf
               lea.l      snderr(pc),a4
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
nowrf:         move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      fpcopyanf
               bra.s      fpfill
fpcopyanf:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
fpcopy:        move.l     d4,-(sp)
               cmpi.w     #0,(a6)       ; sndmode
               beq.s      stereo8
               cmpi.w     #1,(a6)       ; sndmode
               beq.s      stereo16
               cmpi.w     #2,(a6)       ; sndmode
               beq.s      mono8
               bra.s      stereo16
mono8:         move.b     (a2)+,d7      ; MonoKanal,Byte holen
               clr.w      d6
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra.s      fpcopy2
stereo8:       move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               clr.w      d6
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra.s      fpcopy2
stereo16:      move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
fpcopy2:       move.l     (sp)+,d4
               adda.l     d4,a2
               move.l     a2,(a5)       ; Playposition
               cmpa.l     d1,a2
               beq.s      fplayend
               dbra       d0,fpcopy
fp_back:       lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
fplayend:      moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      bufop(pc),a2
               move.w     (a2),d3       ; mode (Bit1=Loop ein/aus) d3
               btst       #1,d3
               beq        fendplay      ; kein loop
               lea.l      pbufstrt(pc),a1
               lea.l      von(pc),a2
               move.l     (a1),(a2)
               lea.l      montrack(pc),a1
               clr.l      d1
               move.w     (a1),d1
               add.w      d1,d1
               add.w      d1,d1
               add.l      d1,(a2)
               lea.l      pbufend(pc),a1
               lea.l      bis(pc),a2
               move.l     (a1),(a2)
               bra.s      intptest
fendplay:      lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #0,d0         ; play-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
intptest:      lea.l      cause(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               beq.s      intee
               btst       #0,d1
               beq.s      intee
               lea.l      src_inter(pc),a1
               move.w     (a1),d1
               btst       #0,d1
               beq.s      timera
mfpint:        movem.l    (sp)+,d0-d7/a0-a6
               movea.l    $11c,a0
mfpint2:       jmp        (a0)
timera:        movem.l    (sp)+,d0-d7/a0-a6
               movea.l    $134,a0
timera2:       jmp        (a0)
intee:         movem.l    (sp)+,d0-d7/a0-a6
               rte        

falcrec:       lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               adda.l     #$60,a0
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               adda.l     #$ff,a1
               lea.l      rbufptr(pc),a5          ; pointer record
               lea.l      rtracks(pc),a2
               move.w     (a2),d4       ; Anzahl der For/Backstep d4
               mulu.w     #4,d4
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        frecend
franf:         move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      fnordful
               lea.l      snderr(pc),a4
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
fnordful:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      frcopy        ; wenn ja, daten einlesen
               bra.s      franf
frcopy:        move.l     #lfifo,d0     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               divu.w     #8,d0
               subi.w     #1,d0
frcopy2:       move.l     d4,-(sp)
               move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      frcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      frcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      frcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      frcopy3a      ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
frcopy3a:      move.l     (sp)+,d4
               adda.l     d4,a2
               move.l     a2,(a5)       ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      frecend
frcopy3:       dbra       d0,frcopy2
fr_back:       lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; recposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
frecend:       moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Recbyte speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      bufop(pc),a2
               move.w     (a2),d3       ; mode (Bit1=Loop ein/aus) d3
               btst       #3,d3
               beq        fendrec       ; kein loop
               lea.l      rbufstrt(pc),a1
               lea.l      rvon(pc),a2
               move.l     (a1),(a2)
               lea.l      rbufend(pc),a1
               lea.l      rbis(pc),a2
               move.l     (a1),(a2)
               bra.s      intrtest
fendrec:       lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #1,d0         ; rec-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
intrtest:      lea.l      cause(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               beq.s      intee2
               btst       #1,d1
               beq.s      intee2
               lea.l      src_inter(pc),a1
               move.w     (a1),d1
               btst       #0,d1
               beq        timera
               bra        mfpint
intee2:        movem.l    (sp)+,d0-d7/a0-a6
               rte        

falcplay8:     lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      sndmode(pc),a6
ptmono8b:      move.l     #lfifo,d2     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               asr.w      #5,d2
               subq.w     #1,d2
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               adda.l     #$40,a0
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               adda.l     #$100,a1
               lea.l      pbufptr(pc),a5
               movea.l    a3,a2
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        fplayendb
fpfillb:       move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrfb
               lea.l      snderr(pc),a4
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
nowrfb:        move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      fpcopyanfb
               bra.s      fpfillb
fpcopyanfb:    move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
fpcopyb:       cmpi.w     #0,(a6)       ; sndmode
               beq.s      stereo8b
               cmpi.w     #1,(a6)       ; sndmode
               beq        stereo16b
               cmpi.w     #2,(a6)       ; sndmode
               beq.s      mono8b
               bra        stereo16b
mono8b:        clr.w      d6
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #0,ptracks
               beq        fpcopy2b
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #1,ptracks
               beq        fpcopy2b
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #2,ptracks
               beq        fpcopy2b
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra        fpcopy2b
stereo8b:      clr.w      d6
               move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #0,ptracks
               beq        fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #1,ptracks
               beq        fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #2,ptracks
               beq.s      fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra.s      fpcopy2b
stereo16b:     move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #0,ptracks
               beq.s      fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #1,ptracks
               beq.s      fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #2,ptracks
               beq.s      fpcopy2b
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
fpcopy2b:      move.l     a2,(a5)       ; Playposition
               cmpa.l     d1,a2
               beq.s      fplayendb
               dbra       d0,fpcopyb
fp_backb:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
fplayendb:     moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      bufop(pc),a2
               move.w     (a2),d3       ; mode (Bit1=Loop ein/aus) d3
               btst       #1,d3
               beq        fendplayb     ; kein loop
               lea.l      pbufstrt(pc),a1
               lea.l      von(pc),a2
               move.l     (a1),(a2)
               lea.l      pbufend(pc),a1
               lea.l      bis(pc),a2
               move.l     (a1),(a2)
               bra.s      intptestb
fendplayb:     lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #0,d0         ; play-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
intptestb:     lea.l      cause(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               beq.s      inteeb
               btst       #0,d1
               beq.s      inteeb
               lea.l      src_inter(pc),a1
               move.w     (a1),d1
               btst       #0,d1
               beq.s      timerab
mfpintb:       movem.l    (sp)+,d0-d7/a0-a6
               movea.l    $11c,a0
mfpint2b:      jmp        (a0)
timerab:       movem.l    (sp)+,d0-d7/a0-a6
               movea.l    $134,a0
timera2b:      jmp        (a0)
inteeb:        movem.l    (sp)+,d0-d7/a0-a6
               rte        

falcrec8:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               adda.l     #$60,a0
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               adda.l     #$ff,a1
               lea.l      rbufptr(pc),a5          ; pointer record
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        frecendb
franfb:        move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      fnordfulb
               lea.l      snderr(pc),a4
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
fnordfulb:     and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      frcopyb       ; wenn ja, daten einlesen
               bra.s      franfb
frcopyb:       move.l     #lfifo,d0     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               divu.w     #8,d0
               subi.w     #1,d0
frcopy2b:      move.w     (a1),d7       ; High-Byte, Kanal1 (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      frcopy3ab     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte, Kanal1 (Bit 8 geloescht ?)...
               btst       d2,d6
               bne.s      frcopy3ab     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      frcopy3ab     ; fehlerhafte Daten ?
               move.b     d7,(a2)+      ; Kanal1-High
               move.b     d6,(a2)+      ; Kanal1-Low
               move.b     d5,(a2)+      ; Kanal2-High
               move.w     (a1),d4
               move.b     d4,(a2)+      ; Kanal2-Low
               move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #0,rtracks
               beq.s      frcopyn0
               move.b     d7,(a2)+      ; Kanal3-High
               move.b     d6,(a2)+      ; Kanal3-Low
               move.b     d5,(a2)+      ; Kanal4-High
               move.b     d4,(a2)+      ; Kanal4-Low
frcopyn0:      move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #1,rtracks
               ble.s      frcopyn1
               move.b     d7,(a2)+      ; Kanal5-High
               move.b     d6,(a2)+      ; Kanal5-Low
               move.b     d5,(a2)+      ; Kanal6-High
               move.b     d4,(a2)+      ; Kanal6-Low
frcopyn1:      move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #2,rtracks
               ble.s      frcopy3ab
               move.b     d7,(a2)+      ; Kanal7-High
               move.b     d6,(a2)+      ; Kanal7-Low
               move.b     d5,(a2)+      ; Kanal8-High
               move.b     d4,(a2)+      ; Kanal8-Low
frcopy3ab:     move.l     a2,(a5)       ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      frecendb
frcopy3b:      dbra       d0,frcopy2b
fr_backb:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; recposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
frecendb:      moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Recbyte speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      bufop(pc),a2
               move.w     (a2),d3       ; mode (Bit1=Loop ein/aus) d3
               btst       #3,d3
               beq        fendrecb      ; kein loop
               lea.l      rbufstrt(pc),a1
               lea.l      rvon(pc),a2
               move.l     (a1),(a2)
               lea.l      rbufend(pc),a1
               lea.l      rbis(pc),a2
               move.l     (a1),(a2)
               bra.s      intrtestb
fendrecb:      lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #1,d0         ; rec-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
intrtestb:     lea.l      cause(pc),a1
               move.w     (a1),d1
               cmpi.w     #0,d1
               beq.s      intee2b
               btst       #1,d1
               beq.s      intee2b
               lea.l      src_inter(pc),a1
               move.w     (a1),d1
               btst       #0,d1
               beq        timerab
               bra        mfpintb
intee2b:       movem.l    (sp)+,d0-d7/a0-a6
               rte        

dsp_doblock:   rts        

dsp_blkhandshake:         rts           

dsp_blkunpacked:          rts           

dsp_instream:  rts        

dsp_outstream: rts        

dsp_removeint: rts        

dsp_iostream:  rts        

dsp_getwordsize:          moveq.l       #3,d0
               rts        

dsp_lock:      lea.l      dsplock(pc),a1
               move.w     (a1),d0
               cmpi.w     #0,d0
               bne.s      dspisl
               move.w     #1,(a1)
               clr.l      d0
               rts        
dspisl:        moveq.l    #-1,d0
               rts        

dsp_unlock:    lea.l      dsplock(pc),a1
               move.w     #0,(a1)
               clr.l      d0
               rts        

dsp_available: move.l     #16384,d0     ;danger !!!
               rts        

dsp_reserve:   clr.l      d0            ;danger !!!
               rts        

dsp_loadprog:  clr.l      d0            ; danger !!!
               rts        

dsp_execboot:  rts        

dsp_execprog:  rts        

dsp_triggerhc: rts        

dsp_lodtobinary:          rts           

dsp_requestuniqueability: moveq.l       #1,d0     ; danger !!!
               rts        

dsp_getprogability:       moveq.l       #1,d0     ; danger !!!
               rts        

dsp_flushsubroutines:     rts           

dsp_loadsubroutine:       move.l        #2,d0     ; danger !!!
               rts        

dsp_inqsubrability:       move.l        #2,d0     ; danger !!!
               rts        

dsp_runsubroutine:        clr.l         d0        ; danger !!!
               rts        

dsp_hf0:       rts        
dsp_hf1:       rts        
dsp_hf2:       rts        
dsp_hf3:       rts        

dsp_blkwords:  rts        

dsp_hstat:     rts        

dsp_blkbytes:  rts        

dsp_setvectors:           rts           

dsp_multblocks:           rts           

ihandler_mfp:  rte        

ihandler_tima: rte        

myxbios:       lea.l      Rlist2,a1
               moveq.l    #0,d0
               move.w     (a0),d1
my_Xbios:      cmp.w      0(a1,d0.w),d1
               beq.s      my_found
               addq.w     #2,d0
               tst.w      0(a1,d0.w)
               bne.s      my_Xbios
               rts        
my_found:      mulu.w     #2,d0
               lea.l      R_addr2,a1
               movea.l    0(a1,d0.w),a1
;               suba.l     #neu_Xbios,a1
;               adda.l     $b8,a1
               addq.l     #2,a0
               jsr        (a1)
               rts        

aidspplay:     lea.l      dvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      dbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      dbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      dbbis(pc),a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      dplaybyte(pc),a4        ; RÅckgabewerte-Liste
               move.l     (a0)+,24(a4)  ; Anfang Playzaehler
               lea.l      dstep(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      dmode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      dfifo(pc),a2
               move.l     #$7ff,(a2)    ; dspbuffer 8192Byte (/4=$7FF)
               btst       #2,d0
               beq.s      nodspmidi
               lea.l      dmidisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
nodspmidi:     lea.l      dmidiw(pc),a2
               move.l     #0,(a2)
               lea.l      dloop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      dcrosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      drimode(pc),a2
               move.l     #0,(a2)
               lea.l      dpimode(pc),a2
               move.l     #13,(a2)
               move.l     a4,d0
               rts        

dspplay:       lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     7(a6),d0
               lea.l      dvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      dbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      dstep(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      dmode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      dfifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      dmidisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               movea.l    a6,a0
               adda.l     #2,a0         ; Adresse DSP-Receive-Status
               movea.l    a6,a1
               adda.l     #4,a1         ; Adresse DSP-Daten
               movea.l    a3,a2
               lea.l      dplaybyte(pc),a6        ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq        dsp_pback
dspcopyanf:    move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
dspcopy:       btst       #2,(a0)       ; DSP empfangsbereit ?
               beq.s      dspcopy
               move.b     (a2)+,1(a1)   ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,2(a1)   ; Rechter Kanal,LowByte senden,A1=0
               move.b     #0,3(a1)
dspcopy2:      btst       #2,(a0)       ; DSP empfangsbereit ?
               beq.s      dspcopy2
               move.b     (a2)+,1(a1)   ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,2(a1)   ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,3(a1)
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               beq.s      dspplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,dspcopy
dsp_pback:     lea.l      dvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
dsp_pback2:    lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dspplayend:    moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      dloop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      dvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #0,d3
               beq.s      dspendplay
               lea.l      dvon(pc),a4
               lea.l      dbvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        dsp_pback2
dspendplay:    lea.l      dplaybyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

dspbreak:      lea.l      cadr(pc),a0
               lea.l      dintreg(pc),a1
               move.b     (a1),d0
               andi.w     #$fc,d0
               movea.l    12(a0),a0     ; Startadresse DSP
               move.b     d0,(a0)       ; Interrupt disabled
               move.b     #146,1(a0)    ; Command Vektor $12
               rts        

dspmix:        move.w     (a0)+,d0      ; Anzahl KanÑle
               cmpi.w     #4,d0
               beq.s      dspmix4
               cmpi.w     #8,d0
               beq        dspmix8
               cmpi.w     #16,d0
               beq        dspmix16
               move.l     #-1,d0
               rts        

dspmix4:       movea.l    (a0)+,a2      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a4      ; zieladresse
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle2adresse
dspaccu:       move.l     (a2)+,(a4)+   ; source1
               move.l     (a3)+,(a4)+   ; source2
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccu
               clr.l      d0
               rts        

dspmix8:       movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
dspaccu8:      move.l     (a1)+,(a5)+   ; source1
               move.l     (a2)+,(a5)+   ; source2
               move.l     (a3)+,(a5)+   ; source3
               move.l     (a4)+,(a5)+   ; source4
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccu8
               clr.l      d0
               rts        

dspmix16:      movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    a5,a6
               adda.l     #16,a6
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
               movea.l    a4,a0
dspaccu16:     move.l     (a1)+,(a5)+   ; source1
               move.l     (a2)+,(a5)+   ; source2
               move.l     (a3)+,(a5)+   ; source3
               move.l     (a4)+,(a5)+   ; source4
               adda.l     #16,a5
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccu16
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a0,a1
               adda.l     d1,a1         ; quelle5adresse
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle6adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle7adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle8adresse
dspaccub16:    move.l     (a1)+,(a6)+   ; source5
               move.l     (a2)+,(a6)+   ; source6
               move.l     (a3)+,(a6)+   ; source7
               move.l     (a4)+,(a6)+   ; source8
               adda.l     #16,a6
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccub16
               clr.l      d0
               rts        

xdplayinit:    lea.l      dvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      dbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      dvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      dbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      dbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      dbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      dplaybyte(pc),a4        ; RÅckgabewerte-Liste
               move.l     (a0)+,24(a4)  ; Anfang Playzaehler
               lea.l      dendcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert dsp
               lea.l      dfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      dstep(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      dmode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      dspmem2b
               lea.l      dmidisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
dspmem2b:      lea.l      dfifo(pc),a2
               move.l     #$7ff,(a2)    ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      dmidiw(pc),a2
               move.l     #0,(a2)
               lea.l      dloop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      dcrosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      drimode(pc),a2
               move.l     #0,(a2)
               lea.l      dpimode(pc),a2
               move.l     #15,(a2)
               move.l     a4,d0
               rts        

dsphbp:        lea.l      cadr(pc),a0
               movea.l    12(a0),a0     ; Startadresse DSP
               move.b     7(a0),d0
               lea.l      dvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      dbis(pc),a2
               move.l     (a2),d2       ; bis d2
               lea.l      dfifo(pc),a2
               move.l     (a2),d0       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               movea.l    a3,a2
               lea.l      dplaybyte(pc),a5        ; RÅckgabewerte-Liste
               cmpa.l     d2,a2
               beq        dsp_back
dspcopy4:      move.b     (a2)+,d7      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d6      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,HighByte holen
dspcope:       btst       #2,2(a0)      ; DSP empfangsbereit ?
               beq.s      dspcope
               move.b     d7,5(a0)      ; Linker Kanal,LowByte
               move.b     d6,6(a0)      ; Linker Kanal,HighByte
               move.b     #0,7(a0)
dspcope2:      btst       #2,2(a0)      ; DSP empfangsbereit ?
               beq.s      dspcope2
               move.b     d5,5(a0)      ; Rechter Kanal,LowByte
               move.b     d4,6(a0)      ; Rechter Kanal,HighByte
               move.b     #0,7(a0)
               addq.l     #4,24(a5)     ; Playposition
               move.l     dendcount(pc),d7
               cmp.l      24(a5),d7
               ble        dspendp4
               cmpa.l     d2,a2
               beq.s      dsplayend
               dbra       d0,dspcopy4
dsp_back:      lea.l      dvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      dplaybyte(pc),a4
dsp_back2:     move.l     a2,(a4)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dsplayend:     lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               lea.l      dvon(pc),a5
               move.l     a2,(a5)       ; Playposition retten
               move.l     4(a4),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      dspmemt1
dspmemt2:      lea.l      dvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      dvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      dbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      dbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a4)      ; Status zweiter Memblock
               bra.s      dspmemte
dspmemt1:      lea.l      dbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      dvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      dbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      dbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a4)      ; Status erster Memblock
dspmemte:      bra        dsp_back2
dspendp4:      lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xplayinit8:    lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      bis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #5,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      emem2b
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
emem2b:        lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      pimode(pc),a2
               move.l     #17,(a2)
               move.l     a4,d0
               rts        

xmemplay8:     lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               clr.l      a6            ; Peak-RÅckgabewert lîschen
               cmpa.l     d1,a2
               beq        ep_back
epfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      enowrlx
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      enowrlx
               addi.l     #1,12(a5)     ;Fehler +1
enowrlx:       move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      epcopyanf
               bra.s      epfill
epcopyanf:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
epcopy:        move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a5)     ; Playposition
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        eendplay
               cmpa.l     d1,a2
               beq.s      eplayend
               dbra       d0,epcopy
ep_back:       lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ep_back2:      lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
eplayend:      moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      ememt1
ememt2:        lea.l      von2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      ememte
ememt1:        lea.l      bvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
ememte:        bra        ep_back2
eendplay:      lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xrecinit8:     lea.l      xrch(pc),a2
               move.w     (a0)+,d1      ; Kanalnummer
               move.w     d1,(a2)
               lea.l      rvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      rbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      rvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      rbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      rbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      rendcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #5,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
;               bsr        recreset
               lea.l      rpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #20,(a2)
               move.l     a4,d0
               rts        

xmemrec8:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      xmemre8b
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xmemre8b:      lea.l      rpeakmerk(pc),a2
               clr.l      (a2)
               lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
xranf8:        move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      xnordfu8
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      xnordfu8
               addi.l     #1,12(a5)     ;Fehler +1
xnordfu8:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      xrstrt8       ; wenn ja, daten einlesen
               bra.s      xranf8
xrstrt8:       clr.l      a0            ; Peak pos/neg left lîschen
               clr.l      a3            ; Peak pos/neg right lîschen
               clr.l      a4
xrcopy8:       move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
xrcopy8b:      move.w     (a1),d7       ; High-Byte, Kanal1 (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        xrcopya3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte, Kanal1 (Bit 8 geloescht ?)...
               btst       d2,d6
               bne        xrcopya3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      xrcopya3      ; fehlerhafte Daten ?
               move.w     (a1),d4
               cmpi.w     #0,xrch
               bne.s      xrecm1
               move.b     d7,(a2)+      ; Kanal1-High
               move.b     d6,(a2)+      ; Kanal1-Low
               move.b     d5,(a2)+      ; Kanal2-High
               move.b     d4,(a2)+      ; Kanal2-Low
xrecm1:        move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #1,xrch
               bne.s      xrecm2
               move.b     d7,(a2)+      ; Kanal3-High
               move.b     d6,(a2)+      ; Kanal3-Low
               move.b     d5,(a2)+      ; Kanal4-High
               move.b     d4,(a2)+      ; Kanal4-Low
xrecm2:        move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #2,xrch
               bne.s      xrecm3
               move.b     d7,(a2)+      ; Kanal5-High
               move.b     d6,(a2)+      ; Kanal5-Low
               move.b     d5,(a2)+      ; Kanal6-High
               move.b     d4,(a2)+      ; Kanal6-Low
xrecm3:        move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #3,xrch
               bne.s      xrecm4
               move.b     d7,(a2)+      ; Kanal7-High
               move.b     d6,(a2)+      ; Kanal7-Low
               move.b     d5,(a2)+      ; Kanal8-High
               move.b     d4,(a2)+      ; Kanal8-Low
xrecm4:        addq.l     #4,24(a5)     ; Recposition
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble.s      xendrea2
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      xrweg8
xrcopya3:      dbra       d0,xrcopy8b
xr_back8:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
xr_back8b:     move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xrweg8:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      memra1
memra2:        lea.l      rvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      xr_back8b
memra1:        lea.l      rbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      xr_back8b
xendrea2:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xplayinit16:   lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      bis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      ememb3
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
ememb3:        lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #6,d0

               asr.w      #3,d0         ; testweise eingefÅgt !!!

               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      pimode(pc),a2
               move.l     #21,(a2)
               move.l     a4,d0
               rts        

xmemplay16:    lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               clr.l      a6            ; Peak-RÅckgabewert lîschen
               cmpa.l     d1,a2
               beq        ep_backb
epfill16:      move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      enowrlx16
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      enowrlx16
               addi.l     #1,12(a5)     ;Fehler +1
enowrlx16:     move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      epcopya16
               bra.s      epfill16
epcopya16:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
epcopy16:      move.b     (a2)+,d7      ; Linker Kanal1,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal1,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Linker Kanal2,HighByte holen
               move.b     (a2)+,d4      ; Linker Kanal2,LowByte holen
               move.b     d7,2(a1)      ; Linker Kanal1,HighByte senden,A1=1
               move.b     d5,(a1)       ; Linker Kanal2,HighByte senden,A1=0
               move.b     d6,(a1)       ; Linker Kanal1,LowByte senden,A1=0
               move.b     d4,(a1)       ; Linker Kanal2,LowByte senden,A1=0
               subq.l     #4,a2
               move.b     (a2)+,d7      ; Rechter Kanal1,HighByte holen
               move.b     (a2)+,d6      ; Rechter Kanal1,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Rechter Kanal2,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal2,LowByte holen
               move.b     d7,(a1)       ; Rechter Kanal1,HighByte senden,A1=0
               move.b     d5,(a1)       ; Rechter Kanal2,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal1,LowByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal2,LowByte senden,A1=0
               move.b     (a2)+,d7      ; Linker Kanal3,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal3,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Linker Kanal4,HighByte holen
               move.b     (a2)+,d4      ; Linker Kanal4,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal3,HighByte senden,A1=1
               move.b     d5,(a1)       ; Linker Kanal4,HighByte senden,A1=0
               move.b     d6,(a1)       ; Linker Kanal3,LowByte senden,A1=0
               move.b     d4,(a1)       ; Linker Kanal4,LowByte senden,A1=0
               subq.l     #4,a2
               move.b     (a2)+,d7      ; Rechter Kanal3,HighByte holen
               move.b     (a2)+,d6      ; Rechter Kanal3,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Rechter Kanal4,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal4,LowByte holen
               move.b     d7,(a1)       ; Rechter Kanal3,HighByte senden,A1=0
               move.b     d5,(a1)       ; Rechter Kanal4,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal3,LowByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal4,LowByte senden,A1=0
               move.b     (a2)+,d7      ; Linker Kanal5,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal5,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Linker Kanal6,HighByte holen
               move.b     (a2)+,d4      ; Linker Kanal6,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal5,HighByte senden,A1=1
               move.b     d5,(a1)       ; Linker Kanal6,HighByte senden,A1=0
               move.b     d6,(a1)       ; Linker Kanal5,LowByte senden,A1=0
               move.b     d4,(a1)       ; Linker Kanal6,LowByte senden,A1=0
               subq.l     #4,a2
               move.b     (a2)+,d7      ; Rechter Kanal5,HighByte holen
               move.b     (a2)+,d6      ; Rechter Kanal5,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Rechter Kanal6,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal6,LowByte holen
               move.b     d7,(a1)       ; Rechter Kanal5,HighByte senden,A1=0
               move.b     d5,(a1)       ; Rechter Kanal6,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal5,LowByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal6,LowByte senden,A1=0
               move.b     (a2)+,d7      ; Linker Kanal7,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal7,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Linker Kanal8,HighByte holen
               move.b     (a2)+,d4      ; Linker Kanal8,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal7,HighByte senden,A1=1
               move.b     d5,(a1)       ; Linker Kanal8,HighByte senden,A1=0
               move.b     d6,(a1)       ; Linker Kanal7,LowByte senden,A1=0
               move.b     d4,(a1)       ; Linker Kanal8,LowByte senden,A1=0
               subq.l     #4,a2
               move.b     (a2)+,d7      ; Rechter Kanal7,HighByte holen
               move.b     (a2)+,d6      ; Rechter Kanal7,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Rechter Kanal8,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal8,LowByte holen
               move.b     d7,(a1)       ; Rechter Kanal7,HighByte senden,A1=0
               move.b     d5,(a1)       ; Rechter Kanal8,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal7,LowByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal8,LowByte senden,A1=0
               addq.l     #4,24(a5)     ; Playposition
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        eendplay16
               cmpa.l     d1,a2
               beq.s      eplayend16
               dbra       d0,epcopy16
ep_backb:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ep_backb2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
eplayend16:    moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      ememtb1
ememtb2:       lea.l      von2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      ememte16
ememtb1:       lea.l      bvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
ememte16:      bra        ep_backb2
eendplay16:    lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

idrecpeak:     lea.l      rdvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rdbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rdfifo(pc),a2
               move.l     #$1000,(a2)   ; dspbuffer 16384 (/4=$1000) Byte
;               bsr        recreset
               lea.l      drecbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      dpimode(pc),a2
               move.l     #0,(a2)
               lea.l      drimode(pc),a2
               move.l     #14,(a2)
               move.l     a4,d0
               rts        

dsprecord:     lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #0,(a6)       ; weitere Interrupts sperren
               move.b     6(a6),d0      ; Anforderung lîschen
               move.b     7(a6),d0      ; Anforderung lîschen
               lea.l      rdvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rdbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rdfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               movea.l    a6,a0
               adda.l     #2,a0         ; Adresse DSP-Receive-Status
               movea.l    a6,a1
               adda.l     #4,a1         ; Adresse DSP-Daten
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    #0,a6         ; Peak-RÅckgabewert lîschen
               movea.l    a3,a2
dircopy:       move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
dircopy2:      move.b     #0,2(a1)      ; Daten anfordern
               move.b     #0,3(a1)      ; Daten anfordern
dirlok1:       btst       #0,(a0)       ; DSP empfangsbereit ?
               beq.s      dirlok1
               move.b     1(a1),d7      ; Daten lesen
               move.b     2(a1),d6      ; Daten lesen
               move.b     3(a1),d2      ; Daten lesen
               move.b     #0,2(a1)      ; Daten anfordern
               move.b     #0,3(a1)      ; Daten anfordern
dirlok2:       btst       #0,(a0)       ; DSP empfangsbereit ?
               beq.s      dirlok2
               move.b     1(a1),d5      ; Daten lesen
               move.b     2(a1),d4      ; Daten lesen
               move.b     3(a1),d2      ; Daten lesen
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               move.l     d1,-(sp)
               move.l     a6,d1
               swap.w     d1
               btst       #15,d7
               beq.s      dpnoneg
               not.w      d7
dpnoneg:       cmp.w      d1,d7
               blt.s      dpnoadd
               move.w     d7,d1
dpnoadd:       swap.w     d1
               btst       #15,d5
               beq.s      dpnoneg2
               not.w      d5
dpnoneg2:      cmp.w      d1,d5
               blt.s      dircop2b
               move.w     d5,d1
dircop2b:      movea.l    d1,a6
               move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      dirweg
dircopy3:      dbra       d0,dircopy2
dir_back:      lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
dir_back2:     lea.l      drecbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Recordbyte speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #1,(a6)       ; weitere Interrupts erlauben
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dirweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     a6,16(a5)     ; Peak-RÅckgabewert speichern
               lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xdrecinit:     lea.l      rdvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      rdbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      rdvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      rdbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      rdbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rdbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      rdendcount(pc),a2
               move.l     (a0)+,(a2)    ; Anzahl der FIFO-Blîcke
               lea.l      rdfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rdfifo(pc),a2
               move.l     #$1000,(a2)   ; dspbuffer 16384 (/4=$1000) Byte
               lea.l      rdpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      drecbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      dpimode(pc),a2
               move.l     #0,(a2)
               lea.l      drimode(pc),a2
               move.l     #16,(a2)
               move.l     a4,d0
               rts        

dsphbr:        lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #0,(a6)       ; weitere Interrupts sperren
               move.b     7(a6),d0      ; Anforderung lîschen
               lea.l      rdpeakmerk(pc),a2
               clr.l      (a2)
               lea.l      rdvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rdbis(pc),a2
               move.l     (a2),d1       ; bis d1
               movea.l    a6,a1
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    a3,a2
drstrt:        clr.l      a0            ; Peak pos/neg left lîschen
               clr.l      a3            ; Peak pos/neg right lîschen
               clr.l      a4
drcopy:        move.l     rdfifo(pc),d0 ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
drcopy2:       move.b     #0,7(a1)      ; Daten anfordern
drlok1:        btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      drlok1
               move.b     5(a1),d7      ; Daten lesen
               move.b     6(a1),d6      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.b     #0,7(a1)      ; Daten anfordern
drlok2:        btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      drlok2
               move.b     5(a1),d5      ; Daten lesen
               move.b     6(a1),d4      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.l     d1,-(sp)
               move.w     rdfileart(pc),d1
               cmpi.w     #3,d1
               bne.s      dnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
;               bsr        rpeakcmp
               bra.s      drcope
dnorwave:      move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
;               bsr        rpeakcmp
drcope:        move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               move.l     rdendcount(pc),d7
               cmp.l      24(a5),d7
               ble        dendrec2
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      drweg
drcopy3:       dbra       d0,drcopy2
dr_back:       lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
dr_back2:      move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rdpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rdpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #1,(a6)       ; weitere Interrupts erlauben
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
drweg:         move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      dmemr1
dmemr2:        lea.l      rdvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      dr_back2
dmemr1:        lea.l      rdbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra        dr_back2
dendrec2:      lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rdpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rdpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               move.l     #1,8(a5)      ; Break setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

tdsphbr:       lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #0,(a6)       ; weitere Interrupts sperren
               move.b     7(a6),d0      ; Anforderung lîschen
               lea.l      rdvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rdbis(pc),a2
               movea.l    (a2),a0       ; bis a0
               movea.l    a6,a1
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    a3,a2
tdrcopy:       move.l     rdfifo(pc),d0 ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
tdrcopy2:      move.b     #0,7(a1)      ; Daten anfordern
tdrlok1:       btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      tdrlok1
               move.b     5(a1),d7      ; Daten lesen
               move.b     6(a1),d6      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.b     #0,7(a1)      ; Daten anfordern
tdrlok2:       btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      tdrlok2
               move.b     5(a1),d5      ; Daten lesen
               move.b     6(a1),d4      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.w     rdfileart(pc),d1
               cmpi.w     #3,d1
               bne.s      tdnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bra.s      tdrcope
tdnorwave:     move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
tdrcope:       addq.l     #4,24(a5)     ; Recposition
               move.l     rdendcount(pc),d7
               cmp.l      24(a5),d7
               ble        tdendrec2
               cmpa.l     a0,a2         ; Speicher voll ?
               beq.s      tdrweg
tdrcopy3:      dbra       d0,tdrcopy2
tdr_back:      lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
tdr_back2:     move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #1,(a6)       ; weitere Interrupts erlauben
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
tdrweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      tdmemr1
tdmemr2:       lea.l      rdvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      tdr_back2
tdmemr1:       lea.l      rdbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra        tdr_back2
tdendrec2:     lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               move.l     #1,8(a5)      ; Break setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

aimemrec24:    lea.l      rvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #4,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; nochmal dividiert durch 2
;               bsr        recreset
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #18,(a2)
               move.l     a4,d0
               rts        

imemr24:       lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      imemr24b
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
imemr24b:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
iranf24:       move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      nordfu24
               cmpi.l     #0,24(a5)     ; Recposition abfragen
               beq.s      nordfu24
               addi.l     #1,12(a5)     ;Fehler +1
nordfu24:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ircopy24      ; wenn ja, daten einlesen
               bra.s      iranf24
ircopy24:      move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ircopy24b:     move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Mid-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d5
               beq.s      ircopy24c     ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               addq.l     #3,24(a5)     ; Recposition
               move.w     (a1),d7       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d7
               bne.s      ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; Mid-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ircopy24c     ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               addq.l     #3,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               bge.s      irweg24
ircopy24c:     dbra       d0,ircopy24b
ir_back24:     lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
ir_back24b:    move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
irweg24:       move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

aimemplay24:   lea.l      von(pc),a2
               move.l     (a0)+,d2      ; von a3
               move.l     d2,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      bis(pc),a2
               move.l     (a0)+,d3      ; bis d1
               move.l     d3,(a2)       ; bis d1
               lea.l      bbis(pc),a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               clr.l      d4
               move.w     (a0)+,d4      ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      nomidi24
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
nomidi24:      lea.l      step(pc),a2
               cmpi.w     #0,d4
               blt        imemperr24
               move.l     d2,d0
               sub.l      d3,d0
               cmpi.l     #0,d0
               beq        imemperr24
               ble.s      impneg24
               mulu.w     #6,d4
               andi.l     #$ffff,d4
               moveq.l    #0,d2
               sub.l      d4,d2
               move.l     d2,d4
               subq.l     #6,d4
               bra.s      impplus24
impneg24:      mulu.w     #6,d4
               andi.l     #$ffff,d4
impplus24:     move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #4,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; dividiert durch 2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      pimode(pc),a2
               move.l     #19,(a2)
               move.l     a4,d0
               rts        
imemperr24:    move.l     #-1,d0
               rts        

imemp24:       lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq.s      ip_back24
ipfill24:      move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrleer24
               move.l     strtp(pc),d0
               cmp.l      24(a6),d0
               beq.s      nowrleer24
               addi.l     #1,12(a6)     ;Fehler +1
nowrleer24:    move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      ipcopyanf24
               bra.s      ipfill24
ipcopyanf24:   cmpi.l     #0,d4
               blt.s      ipcopyn24
               cmpa.l     d1,a2
               bge.s      iplayend24
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopy24:      move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,MidByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,MidByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #6,24(a6)     ; Playposition
               cmpa.l     d1,a2
               bge.s      iplayend24
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,ipcopy24
               bra.s      ip_back24
ipcopyn24:     cmpa.l     d1,a2
               ble.s      iplayend24
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopyb24:     move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,MidByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,MidByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #6,24(a6)     ; Playposition
               cmpa.l     d1,a2
               ble.s      iplayend24
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,ipcopyb24
ip_back24:     lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ip_back224:    lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplayend24:    moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
iplooptst24:   btst       #0,d3
               beq.s      iendplay24
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        ip_back224
iendplay24:    lea.l      playbyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

cblmode:       move.w     (a0)+,d2      ; cblstatus
               cmpi.w     #0,d2
               blt.s      cblerr
               cmpi.w     #1,d2
               bgt.s      cblerr
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               lea.l      rec128(pc),a2
               move.b     (a1),d1
               move.w     d1,d0
               bclr       #4,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               cmpi.w     #0,d2
               bne.s      cblja
               tst.w      (a2)
               beq.s      cblweg
               bset       #4,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               bra.s      cblweg
cblja:         asr.w      #4,d0
               andi.w     #1,d0
               move.w     d0,(a2)       ; status rec128 retten
               bset       #4,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
cblweg:        clr.l      d0
               rts        
cblerr:        move.l     #-1,d0
               rts        

init_cbl:      lea.l      rimode(pc),a2
               move.l     #24,(a2)
               lea.l      cblbits(pc),a2
               move.l     a2,d0
               rts        

cblread:       move.l     #lfifo,d4     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               move.l     #8,d2
               lea.l      cblbits(pc),a2
cblcopy:       asr.w      #1,d4
cblcopy2:      move.w     (a1),d6       ; cbl-anfang (geloescht) ?
               subq.w     #1,d4
               tst.w      d4
               beq.s      cblex
               btst       d2,d6
               bne.s      cblcopy2      ; fehlerhafte Daten ?
cblcopy2b:     move.w     (a1),d6       ; cbl-anfang (geloescht) ?
               subq.w     #1,d4
               tst.w      d4
               beq.s      cblex
               btst       d2,d6
               beq.s      cblcopy2b     ; fehlerhafte Daten ?
               move.b     d6,(a2)+
               move.l     #23,d1
cblcopy3:      move.w     (a1),d6
               subq.w     #1,d4
               tst.w      d4
               beq.s      cblex
               move.b     d6,(a2)+
               dbra       d1,cblcopy3
cblcopy4:      move.w     (a1),d6
               dbra       d4,cblcopy4
cblex:         movem.l    (sp)+,d0-d7/a0-a6
               rte        

recmode:       move.w     (a0)+,d2
               cmpi.w     #0,d2
               blt        rmerr
               cmpi.w     #2,d2
               bgt        rmerr
               lea.l      dsppath2(pc),a3
               move.b     (a3),d3
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               bclr       #3,d3
               lea.l      playmod(pc),a4
               movem.l    d0-d7/a0-a6,-(sp)
               move.w     (a4),d2
               bsr        playmode2
               movem.l    (sp)+,d0-d7/a0-a6
               cmpi.w     #2,d2
               blt.s      qconvm2
               move.w     (a4),d4
               movem.l    d0-d7/a0-a6,-(sp)
               move.w     #2,d2
               bsr        playmode2
               movem.l    (sp)+,d0-d7/a0-a6
               move.w     d4,(a4)
               bra.s      norconvm
qconvm2:       lea.l      playmod(pc),a4
               move.w     (a4),d4
               cmpi.w     #2,d4
               blt.s      norconvm
doconvm:       bset       #3,d3
norconvm:      move.b     d3,(a3)
               move.b     d3,$214(a6)
               lea.l      recmod(pc),a3
               move.w     d2,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      hireg(pc),a3
               move.b     (a3),d3
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               bclr       #0,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               bclr       #4,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               cmpi.w     #0,d2
               beq.s      rmweg
               cmpi.w     #1,d2
               bgt.w      recm2
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               bset       #0,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               bra.s      rmweg
recm2:         bset       #4,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
rmweg:         clr.l      d0
               rts        
rmerr:         move.l     #-1,d0
               rts        

playmode:      move.w     (a0)+,d2
playmode2:     cmpi.w     #0,d2
               blt        pmerr
               cmpi.w     #3,d2
               bgt        pmerr
               lea.l      dsppath2(pc),a4
               move.b     (a4),d4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               bclr       #3,d4
               cmpi.w     #2,d2
               blt.s      noconvm
               bset       #3,d4
noconvm:       cmpi.w     #1,d2
               bne.s      noconvm2
               bclr       #1,d4
               bclr       #2,d4
noconvm2:      move.b     d4,(a4)
               move.b     d4,$214(a6)
               lea.l      playmod(pc),a3
               move.w     d2,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      hireg(pc),a3
               move.b     (a3),d3
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               bclr       #1,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               bclr       #3,d1
               bclr       #1,d1
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               cmpi.w     #0,d2
               beq.s      pmweg
               cmpi.w     #1,d2
               bgt.w      playm2
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               move.b     d3,$40(a6)
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               bset       #1,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               bra.s      pmweg
playm2:        bset       #3,d1
               cmpi.w     #2,d2
               beq.s      noplaym3
               bset       #1,d1
noplaym3:      move.b     d1,$c0(a6)
               move.b     d1,(a1)
               lea.l      montrack(pc),a1
               move.w     (a1),d0
               clr.w      d7
               bsr        setmontr2
pmweg:         clr.l      d0
               rts        
pmerr:         move.l     #-1,d0
               rts        

dspmem:        lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a1
               move.b     (a1),d1
               move.w     (a0)+,d2
               cmpi.w     #0,d2
               beq.s      dmem0
               cmpi.w     #1,d2
               beq.s      dmem1
               move.l     #-1,d0
               rts        
dmem0:         bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$240(a6)
               bra.s      dmweg
dmem1:         bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$240(a6)
dmweg:         clr.l      d0
               rts        

clkdivide:     lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      clkdiv(pc),a1
               move.w     (a0)+,d2
               cmpi.w     #0,d2
               blt.s      clkderr
               cmpi.w     #15,d2
               bgt.s      clkderr
               move.b     d2,(a1)
               move.b     d2,$242(a6)
               clr.l      d0
               rts        
clkderr:       move.l     #-1,d0
               rts        

pathset:       lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath1(pc),a1
               move.w     (a0)+,d2
               cmpi.w     #0,d2
               blt.s      patherr
               cmpi.w     #15,d2
               bgt.s      patherr
               move.w     d2,d3
               andi.w     #7,d2
               move.b     (a1),d0
               andi.b     #$f8,d0
               add.b      d2,d0
               move.b     d0,(a1)
               move.b     d0,$210(a6)
               asr.w      #3,d3
               andi.w     #1,d3
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               andi.b     #$fe,d0
               add.b      d3,d0
               move.b     d0,(a1)
               move.b     d0,$214(a6)
               clr.l      d0
               rts        
patherr:       move.l     #-1,d0
               rts        


; ----------------------------Ende der Treiber-----------------------


installed:     
               move.l     #$71273800,d0 ;magic
               rts        

Rlist:         .IF demo=0
               .DC.w 96,97,98,99
               .DC.w 100,101,102,103,104,105,106,107,108,109          ; DSP
               .DC.w 110,111,112,113,114,115,116,117,118,119
               .DC.w 120,121,122,123,124,125,126,127

               .DC.w $80,$81,$82,$83,$84,$85,$86,$87,$88,$89
               .DC.w $8a,$8b,$8c,$8d    ; Falcon-XBIOS
               .ENDIF 

               .DC.w 500  ; my-XBIOS
               .DC.w 0

R_addr:        .IF demo=0
               .DC.l dsp_doblock
               .DC.l dsp_blkhandshake
               .DC.l dsp_blkunpacked
               .DC.l dsp_instream
               .DC.l dsp_outstream
               .DC.l dsp_iostream
               .DC.l dsp_removeint
               .DC.l dsp_getwordsize
               .DC.l dsp_lock
               .DC.l dsp_unlock
               .DC.l dsp_available
               .DC.l dsp_reserve
               .DC.l dsp_loadprog
               .DC.l dsp_execprog
               .DC.l dsp_execboot
               .DC.l dsp_lodtobinary
               .DC.l dsp_triggerhc
               .DC.l dsp_requestuniqueability
               .DC.l dsp_getprogability
               .DC.l dsp_flushsubroutines
               .DC.l dsp_loadsubroutine
               .DC.l dsp_inqsubrability
               .DC.l dsp_runsubroutine
               .DC.l dsp_hf0
               .DC.l dsp_hf1
               .DC.l dsp_hf2
               .DC.l dsp_hf3
               .DC.l dsp_blkwords
               .DC.l dsp_blkbytes
               .DC.l dsp_hstat
               .DC.l dsp_setvectors
               .DC.l dsp_multblocks

               .DC.l locksnd            ; sperre Audiosub,tested
               .DC.l unlocksnd          ; freigeben des Audiosub,tested
               .DC.l soundcmd           ; vol-controller,in a/d,vorteiler
               .DC.l setbuffer          ; set play & recbuffer,tested
               .DC.l setsndmode         ; 8bit Stereo/16bit/8bit mono,tested
               .DC.l settrack           ; Kanalzahl
               .DC.l setmontrack        ; playtrack
               .DC.l setinterrupt       ; welcher Int bei play/rec
               .DC.l buffoper           ; rec/play-start,tested
               .DC.l dsptristate        ; Multiplexer abkoppeln
               .DC.l gpio ; DSP-AnschlÅsse setzen,tested
               .DC.l devconnect         ; Multiplexer setzen,tested
               .DC.l sndstatus          ; Codec-init
               .DC.l buffptr            ; rec/play-position,tested
               .ENDIF 

               .DC.l myxbios

Rlist2:        .DC.w 1    ; cookie
               .DC.w 10,11,12,13        ; card
               .DC.w 20,21,22,23,24,25,26,27,28   ; select
               .DC.w 30,31,32,33        ; digital-modes
               .DC.w 40,41,42,43,44,45,46         ; status
               .DC.w 50,51,52,53,54,55  ; vol/exec
               .DC.w 60,61              ; reset
               .DC.w 70,71,72,73,74,75  ; dsp-modes
               .DC.w 100,101            ; mix
               .DC.w 110,111,112,113,114,115,116,117        ; none_int
               .DC.w 120,121,122,123,124,125,126  ; int
               .DC.w 130,131,132,133,134,135      ; peak & int
               .DC.w 140,141,142,143,144          ; halfbuffer
               .DC.w 150  ; peakwert abholen
               .DC.w 160  ; Falconmode

               .DC.w 200,201,202,203,204          ; read_reg
               .DC.w 210,211,212,213,214          ; write_reg
               .DC.w 220,221,222,223,224,225,226  ; dsp-register lesen
               .DC.w 230,231,232,233,234,235      ; dsp-register schreiben

               .DC.w 300,301,302,303,304,305,306  ; function

               .DC.w 0    ; end

R_addr2:       .DC.l installed          ; cookie XBIOS-Treiber

               .DC.l cardslot           ; Anzahl Soundkarten im System
               .DC.l cardsel            ; Soundkarte auswaehlen
               .DC.l cardmagic          ; Soundkarten-magic auslesen
               .DC.l cardadr            ; Adressen sample/recstat/playstat/dsp

               .DC.l digana             ; Digital/Analogeingang
               .DC.l digcom             ; Digitalquelle
               .DC.l dspmode            ; dsprouting no/input/output
               .DC.l sclock             ; Samplerate
               .DC.l highsrate          ; samplerate-verdopplung
               .DC.l bypass             ; bypass/sampleplay
               .DC.l recmode            ; rec normal,4ch,8ch
               .DC.l playmode           ; play normal,4ch,8ch,16ch
               .DC.l mode24             ; 16Bit/24Bit

               .DC.l digmode            ; digitaloutput consumer/professional
               .DC.l scmsmode           ; clear copybit fuer Kopierdecoder-mode
               .DC.l mycopybit          ; eigener SCMS-Kopierschutz no/one/all
               .DC.l emphasis           ; de-emphasis

               .DC.l digsrate           ; samplerate-erkennung vom digitalinput
               .DC.l digcode            ; Digitalinput-Aufnahmeart-Code
               .DC.l errorcode          ; Digitalinput-Fehlercode
               .DC.l cblmode            ; set cbl-mode
               .DC.l init_cbl           ; Read 192 Bit Channel Status
               .DC.l recstat            ; rec-FIFO-status
               .DC.l playstat           ; play-FIFO-status

               .DC.l volad              ; volume-controller fuer input
               .DC.l volda              ; volume-controller fuer output
               .DC.l readsmp            ; sample lesen
               .DC.l writesmp           ; sample schreiben
               .DC.l intact             ; interrupt-freigabe fÅr fifo
               .DC.l dspintact          ; interrupt-freigabe fÅr dsp

               .DC.l recreset           ; record-FIFO loeschen
               .DC.l dspreset           ; reset fuer DSP

               .DC.l dspmem             ; 32Kx24,128Kx24 DSP-Memory
               .DC.l clkdivide          ; DSP-Clockdivider
               .DC.l pathset            ; dsp-verbindung zur matrix
               .DC.l dspcommnd          ; dsp-kommando
               .DC.l dspclear           ; dsp-receive auslesen (muell loeschen)
               .DC.l exclkmode          ; extclock-mode ja/nein (25.175 MHz)

               .DC.l mixit              ; mixt 2-8 StereokanÑle (4-16 Tracks)
               .DC.l dspmix             ; mixt 4,8,16 Tracks fuer Falconmode

               .DC.l monitor            ; record&play-bypass
               .DC.l recwait            ; warten auf autorecord-schwellwert
               .DC.l memrec             ; memory-record ohne Interrupt
               .DC.l memplay            ; memory-play ohne Interrupt
               .DC.l recplay            ;!memory record- und play ohne Interrupt
               .DC.l hardrec            ; HD-record ohne Interrupt
               .DC.l hardplay           ; HD-play ohne Interrupt
               .DC.l hrecplay           ;!HD record- und play ohne Interrupt

               .DC.l init_peak          ; peakwert-ausgabe im Interrupt
               .DC.l init_imemrec       ; memory-record im Interrupt
               .DC.l init_imemplay      ; memory-play im Interrupt
               .DC.l init_impmix        ; memory-play mit rec-mix im Interrupt
               .DC.l init_hrec          ; HD-record im Interrupt
               .DC.l init_hplay         ; HD-play im Interrupt
               .DC.l init_ihplaymix     ;!HD-play mit rec-mix im Interrupt

               .DC.l init_mrecpeak      ; memory-rec & peakausgabe im Interrupt
               .DC.l init_mplaypeak     ;!memory-play & peakausgabe im Interrupt
               .DC.l init_mrppeak       ;!mem-play&rec-mix&peakausgabe im Int
               .DC.l init_hrecpeak      ; HD-rec & peakausgabe im Interrupt
               .DC.l init_hplaypeak     ;!HD-play & peakausgabe im Interrupt
               .DC.l init_hrppeak       ;!HD-play&rec-mix&peakausgabe im Int

               .DC.l init_xmemrec       ; record im HalfBuffer-System
               .DC.l init_xmemplay      ; play im HalfBuffer-System
               .DC.l init_xmixplay      ; play&mix-rec im HalfBuffer-System
               .DC.l init_xmemr4        ; 4Ch-mode rec im HalfBuffer-System
               .DC.l init_xmemp4        ; 4Ch-mode play im HalfBuffer-System

               .DC.l peakread           ; aktuellen peakwert abholen

               .DC.l compatible         ; Falcon-Mode (emulation) ja/nein

               .DC.l read_rlow          ; low-register lesen
               .DC.l read_rhi           ; high-register lesen
               .DC.l read_rdsp          ; dsp-register lesen
               .DC.l read_raes          ; aes-register lesen
               .DC.l read_rint          ; interrupt-register lesen

               .DC.l wr_rlow            ; low-register schreiben
               .DC.l wr_rhi             ; high-register schreiben
               .DC.l wr_rdsp            ; dsp-register schreiben
               .DC.l wr_raes            ; aes-register schreiben
               .DC.l wr_rint            ; interrupt-register schreiben

               .DC.l read_dpath1        ; dsppfad1-register lesen
               .DC.l read_dpath2        ; dsppfad2-register lesen
               .DC.l read_dport         ; dsp-port-register lesen
               .DC.l read_dconv         ; dsp-convert-register lesen
               .DC.l read_dpdat         ; dsp-pdat-register lesen
               .DC.l read_dclk          ; dsp-clkdiv-register lesen
               .DC.l point_dreg         ; pointer auf weitere dsp-regs

               .DC.l wr_dpath1          ; dsppfad1-register schreiben
               .DC.l wr_dpath2          ; dsppfad2-register schreiben
               .DC.l wr_dport           ; dsp-port-register schreiben
               .DC.l wr_dconv           ; dsp-convert-register schreiben
               .DC.l wr_dpdat           ; dsp-pdat-register schreiben
               .DC.l wr_dclk            ; dsp-clkdiv-register schreiben

               .DC.l fastcut            ; speicherbereich loeschen im samplemem
               .DC.l peaksuch           ; peakwert-suche im samplemem
               .DC.l zerono             ; nullstellen-suche im samplemem
               .DC.l fading             ; sample-fading im samplemem
               .DC.l muster             ; speicherbereich mit Muster fÅllen
               .DC.l testbits           ; RAM->bitmuster (1,2..$80000000) fÅllen
               .DC.l speedtst           ; testet Interface-speed

               .DATA 
               .EVEN 
newcook:       .DC.l 0,40
               .DCB.l 78,0
magic:         .DC.l $12233445
dspmod:        .DC.b 0
damod:         .DC.b 0
dmamod:        .DC.b 0
lowreg:        .DC.b 0
hireg:         .DC.b 0
aesreg:        .DC.b 0
dspreg:        .DC.b 0
dsppath1:      .DC.b 0
dsppath2:      .DC.b 0
dspport:       .DC.b 0
dspconv:       .DC.b 0
dsppdat:       .DC.b 0
clkdiv:        .DC.b 0
               .EVEN 
dmarec:        .DC.w 0
dsprec:        .DC.w 0
extrec:        .DC.w 0
dacrec:        .DC.w 0
playmod:       .DC.w 0
recmod:        .DC.w 0
smpte:         .DC.b 0
intreg:        .DC.b 0
dintreg:       .DC.b 0
               .EVEN 
dspart:        .DC.w 0
proff:         .DC.w 0
proffm:        .DC.w 0
bridg1:        .DC.w 0
bridg2:        .DC.w 0
bridg3:        .DC.w 0
bridg4:        .DC.w 0
bridge:        .DC.w 0
cat0:          .DC.w 0
catb0:         .DC.w 0
cat1:          .DC.w 0
catb1:         .DC.w 0
gen:           .DC.w 0
copyobit:      .DC.w 0
scms:          .DC.w 0
empha:         .DC.w 0
hz:            .DC.w 0
rec128:        .DC.w 0
rimode:        .DC.l 0
pimode:        .DC.l 0
drimode:       .DC.l 0
dpimode:       .DC.l 0
int_reg:       .DC.l 0
vmestart:      .DC.l 0
vmemask:       .DC.l 0
strtp:         .DC.l 0
sclockv:       .DC.b $d4,84,208,148,80,20,144,16,116,112,52,48
falctab:       .DC.b 0,3,2,1,11,10,9,8,7,6,5,4,15,14,13,12
cblbits:       .DS.b 2400
cardlist:      .DS.l 8
oldval:        .DS.l 1
berrsprung:    .DS.l 1
smpwert:       .DS.l 1
cardz:         .DC.w 0
cardz2:        .DC.w 0
cadr:          .DS.l 4
pos:           .DS.l 1
rpos:          .DS.l 1
von:           .DS.l 1
bvon:          .DS.l 1
rvon:          .DS.l 1
rbvon:         .DS.l 1
bis:           .DS.l 1
bbis:          .DS.l 1
rbis:          .DS.l 1
rbbis:         .DS.l 1
von2:          .DS.l 1
bis2:          .DS.l 1
rvon2:         .DS.l 1
rbis2:         .DS.l 1
dvon:          .DS.l 1
rdvon:         .DS.l 1
dbvon:         .DS.l 1
rdbvon:        .DS.l 1
dvon2:         .DS.l 1
rdvon2:        .DS.l 1
dbis2:         .DS.l 1
rdbis2:        .DS.l 1
dbis:          .DS.l 1
rdbis:         .DS.l 1
dbbis:         .DS.l 1
rdbbis:        .DS.l 1
len:           .DS.l 1
rlen:          .DS.l 1
step:          .DS.l 1
mode:          .DS.l 1
dstep:         .DS.l 1
dmode:         .DS.l 1
fifo:          .DS.l 1
rfifo:         .DS.l 1
dfifo:         .DS.l 1
rdfifo:        .DS.l 1
stath:         .DS.l 1
regh:          .DS.l 1
playread:      .DS.l 1
playstart:     .DS.l 1
dstath:        .DS.l 1
dregh:         .DS.l 1
dplayread:     .DS.l 1
dplaystart:    .DS.l 1
peakbuf:       .DS.l 1
rpeakbuf:      .DS.l 1
peakmerk:      .DS.l 1
rpeakmerk:     .DS.l 1
dpeakbuf:      .DS.l 1
rdpeakbuf:     .DS.l 1
dpeakmerk:     .DS.l 1
rdpeakmerk:    .DS.l 1
sectors:       .DS.l 1
endcount:      .DS.l 1
rendcount:     .DS.l 1
dendcount:     .DS.l 1
rdendcount:    .DS.l 1
dsectors:      .DS.l 1
fileart:       .DS.l 1
rfileart:      .DS.l 1
loop:          .DS.l 1
crosflag:      .DS.l 1
dfileart:      .DS.l 1
rdfileart:     .DS.l 1
dloop:         .DS.l 1
dcrosflag:     .DS.l 1
dendflag:      .DS.l 1
rdendflag:     .DS.l 1
handle:        .DS.l 1
rhandle:       .DS.l 1
seeknr:        .DS.l 1
sectnr:        .DS.l 1
rsectnr:       .DS.l 1
bsectnr:       .DS.l 1
load:          .DS.w 1
Text:          .DC.b 13,10,10
               .DC.b "Xbios-Erweiterung fÅr Star-Track installiert...     ",13,10,10,0
               .EVEN 
Text2:         .DC.b 13,10
               .DC.b "Xbios-Erweiterung wurde schon installiert !!!",13,10,0
rett:          .DC.l 0
rrett:         .DC.l 0
midisuch:      .DC.w 0
midiw:         .DC.l 0
dmidisuch:     .DC.w 0
dmidiw:        .DC.l 0
peakw:         .DC.l 2
playbyte:      .DS.l 8
dplaybyte:     .DS.l 8
recbyte:       .DS.l 8
drecbyte:      .DS.l 8
lock:          .DC.w 0
firstbuf:      .DC.w 0
pbufstrt:      .DS.l 1
pbufend:       .DS.l 1
rbufstrt:      .DS.l 1
rbufend:       .DS.l 1
recmics:       .DS.l 1
flag:          .DC.w 0
sndmode:       .DC.w 1
highsr:        .DC.w 0
modr24:        .DC.w 0
ptracks:       .DC.w 0
rtracks:       .DC.w 0
montrack:      .DC.w 0
src_inter:     .DC.w 0
cause:         .DC.w 0
bufop:         .DC.w 0
pbufptr:       .DS.l 1
rbufptr:       .DS.l 1
snderr:        .DC.w 0
ltatt:         .DC.w 0
rtatt:         .DC.w 0
lgain:         .DC.w 0
rgain:         .DC.w 0
dsplock:       .DC.w 0
xrch:          .DC.w 0
src:           .DC.w 0
dst:           .DC.w 0
srcclk:        .DC.w 0
prescale:      .DC.w 0
tosv1:         .DS.w 1
tosv2:         .DS.l 1
tosv3:         .DS.w 1
cooksnd:       .DS.l 1
ncooksnd:      .DS.l 1
cookmch:       .DS.l 1
ncookmch:      .DS.l 1
cookcpu:       .DS.l 1
ncookcpu:      .DS.l 1
cookvdo:       .DS.l 1
ncookvdo:      .DS.l 1
cookfpu:       .DS.l 1
ncookfpu:      .DS.l 1
protocol:      .DC.w 0
gpiodat:       .DC.w 0
exclkm:        .DC.w 0
csysadr:       .DC.l 0
csysbase:      .DS.b 128
param:         .DS.l 8
stack:         .DS.b 512
program_end:   
               .BSS 
               .END 

