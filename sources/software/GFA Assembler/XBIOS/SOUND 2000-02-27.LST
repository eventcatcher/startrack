; Xbios
; Xbios-Erweiterung fÅr Audiokarte StarTrack (VME)
; Release 27.02.2000 by SWE (Stephan Wilhelm EntwicklungsbÅro)
; for Milan,Hades,Medusa,TT and Mega STE

; +Directstream-Support
; +Special 16Channel Multiplex-Mode & 24Bit-EightChannel-Support
; for old and new hardware-release

               bra        startprog

               .EVEN 
creturn:       .DC.b 13,10,0
infotext1:     .DC.b "StarTrack Xbios-Driver ",0
infotext2:     .DC.b "Copyright by SWE,Stephan Wilhelm",13,10,10,0

vtxt:          .DC.b "V2.21 / 27.02.2000",0
               .EVEN 

cpu68k         equ 0      ; 1=68000er, 0=030er,040er,060er

myxcall        equ 500    ; xbios basecall-number
recbuflen      equ 8192
lfifo          equ 4096   ; fifo depth
resmagic       equ $31415926
cjar           equ $5a0
resval         equ $426
resvect        equ $42a
savptr         equ $4a2
amount         equ 46
xbiosvec       equ $b8
install        equ 500
ireg_p         equ 1      ; interrupt fÅr play
ireg_r         equ 2      ; interrupt fÅr record
ireg_all       equ 3      ; interrupt fÅr record & play
CR             equ $0000000d
LF             equ $0000000a
ESC            equ 27
_hz_200        equ $4ba   ; 200hz-timer

_int_dsp       equ $3fc   ;Hier wird die IR-Routine (124=$1f0)eingetragen

;Grîûe der Strukturelemente: 12 Bytes; Anzahl: 8
sizeof_subs    equ 96     ;8*12 = 96 Bytes

RXDF           equ $0     ;Bitnummer: ISR Receive Data Register Full (RXDF)
TXDE           equ $1     ;Bitnummer: ISR Transmit Data Register Empty (TXDE
TRDY           equ $2     ;Bitnummer: ISR Transmitter Ready (TRDY)
DSP_HF2        equ $3     ;Bitnummer: Hostflag 2
DSP_HF3        equ $4     ;Bitnummer: Hostflag 3

               .IF cpu68k
dsp_irctrl     equ $fedf0600            ;Interrupt Ctrl Register
dsp_cmdvec     equ $fedf0601            ;Command Vector Register
dsp_irstat     equ $fedf0602            ;Interrupt Status Register
dsp_irvec      equ $fedf0603            ;Interrupt Vector Register
dsp_longwd     equ $fedf0604            ;unbenutztes Byte ->fÅr LONG-Zugriff benutzt
dsp_high       equ $fedf0605
dsp_mid        equ $fedf0606
dsp_low        equ $fedf0607
               .ELSE 
dsp_irctrl     equ $feff0600            ;Interrupt Ctrl Register
dsp_cmdvec     equ $feff0601            ;Command Vector Register
dsp_irstat     equ $feff0602            ;Interrupt Status Register
dsp_irvec      equ $feff0603            ;Interrupt Vector Register
dsp_longwd     equ $feff0604            ;unbenutztes Byte ->fÅr LONG-Zugriff benutzt
dsp_high       equ $feff0605
dsp_mid        equ $feff0606
dsp_low        equ $feff0607
               .ENDIF 

GEMDOS         equ 1

startprog:     move.w     #1,-(sp)
               move.w     #myxcall,-(sp)
               trap       #14
               addq.l     #4,sp
               cmpi.l     #$71273800,d0
               bne        do_inst

letitbe:       clr.w      -(sp)         ;* Ab ins Jenseits
               trap       #1            ;GEMDOS


do_inst:       
               movea.l    4(sp),a0
               lea.l      stack_end,sp
               move.l     #$100,d0
               add.l      $c(a0),d0     ; programmlÑnge
               add.l      $14(a0),d0    ; data
               add.l      $1c(a0),d0    ; bss
               move.l     d0,merklen

               move.w     #0,global
               bsr        aes_test
               move.w     global,d0
               move.w     d0,gem

               tst.w      gem
               bne.s      noinfo

               pea        creturn       ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        infotext1     ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        vtxt          ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        creturn       ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        infotext2     ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern

;-----------------------------------------------------------
; Interrupt-Vektor 122 (fÅr Play) setzen
;-----------------------------------------------------------

noinfo:        pea        ihandler_play ; neue Interrupt-Routine
               move.w     #122,-(sp)    ; Vektor Nummer 122
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupt-Vektor 123 (fÅr Record) setzen
;-----------------------------------------------------------

               pea        ihandler_rec  ; neue Interrupt-Routine
               move.w     #123,-(sp)    ; Vektor Nummer 123
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupt-Vektor 124 (fÅr DSP-Transfer) setzen
;-----------------------------------------------------------

               pea        ihandler_dsp  ; neue Interrupt-Routine
               move.w     #124,-(sp)    ; Vektor Nummer 124
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

;-----------------------------------------------------------
; Interrupts erlauben, SCU programmieren
;-----------------------------------------------------------

               clr.l      -(sp)         ;in Supervisormode
               move.w     #32,-(sp)
               trap       #1
               addq.l     #6,sp
               move.l     d0,-(sp)

               lea.l      midisprung,a1 ; Umleitung von midi_in
               move.l     $54a,(a1)
               lea.l      int_midi,a1
               move.l     a1,$54a

               move.w     #34,-(sp)     ; kbdvbase
               trap       #14
               addq.l     #2,sp
               movea.l    d0,a2
               move.l     (a2),d1       ; alter midivector
               move.l     d1,midikjmp+2

               lea.l      intmidikey,a1
               move.l     a1,d0
               move.l     d0,(a2)       ; midivec setzen

;               bsr        getsysbase

;cookiejar-test
               clr.w      d7
               lea.l      vmestart,a2
               lea.l      vmemask,a3
               move.l     #$fedf0000,(a2)         ; VME-Start im ST & STE
               move.l     #$ffff8e0d,(a3)         ; VME-Intmaske im ST & STE
               tst.l      cjar
               bne.s      cookt1a
               clr.l      d0
               bsr        makecjar
cookt1a:       movea.l    cjar,a1
               clr.l      d6
cookt1:        move.l     (a1)+,d1
               move.l     (a1)+,d2
               addq.l     #1,d6
               tst.l      d1
               beq        cookt4
               cmpi.l     #"_SND",d1
               bne.s      cookt1b
               lea.l      cooksnd,a4
               move.l     d2,(a4)
cookt1b:       cmpi.l     #"_MCH",d1
               bne.s      cookt2
               lea.l      cookmch,a4
               move.l     d2,(a4)
               swap.w     d2
               cmpi.w     #2,d2
               bne.s      cookt2
               move.l     #$feff0000,(a2)         ; VME-Start im TT
               move.l     #$ffff8e0d,(a3)         ; VME-Intmaske im TT
cookt2:        cmpi.l     #"_CPU",d1
               bne.s      cookt2b
               lea.l      cookcpu,a4
               move.l     d2,(a4)
cookt2b:       cmpi.l     #"_VDO",d1
               bne.s      cookt2c
               lea.l      cookvdo,a4
               move.l     d2,(a4)
cookt2c:       cmpi.l     #"_FPU",d1
               bne.s      cookt2d
               lea.l      cookfpu,a4
               move.l     d2,(a4)
cookt2d:       cmpi.l     #"MgMc",d1
               bne.s      cookt2e
               lea.l      cookmgmc,a4
               move.l     d2,(a4)
cookt2e:       cmpi.l     #"_MIL",d1
               bne.s      cookt2f
               lea.l      cookmilan,a4
               move.l     d2,(a4)
               move.l     #$feff0000,(a2)         ; VME-Start im TT
               move.l     #$ffff8e0d,(a3)         ; VME-Intmaske im TT
cookt2f:       cmpi.l     #"hade",d1
               bne        cookt1
               move.w     #-1,d7
               move.l     #$feff0000,(a2)         ; VME-Start im hades
               move.l     #$ffff8717,(a3)         ; VME-Intmaske im hades
               bra        cookt1
cookt4:        addi.l     #$401,(a2)
               cmp.l      d6,d2
               bgt.s      cookt5
               move.l     d6,d0
               subq.l     #1,d0
               bsr        makecjar
               tst.l      d0
               bmi.s      cookt6
               movea.l    a0,a1
               subq.l     #4,a1
               move.l     (a1)+,d2
cookt5:        subq.l     #8,a1
               move.l     #"strk",d1
               move.l     d1,(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)+
               move.l     d2,(a1)+
               addq.l     #1,d6

cookt6:        move.l     a1,-(sp)
               move.l     d6,-(sp)

               tst.l      cookmgmc      ; lÑuft unter MagicMac ?
               bne        demoset1
               cmpi.l     #$1f,cooksnd  ; lÑuft unter Falcon ?
               beq        demoset1

;-----------------------------------------------------------
; Interrupt-Vektoren 79+77 fÅr Falcon-frames setzen
;-----------------------------------------------------------

               pea        ihandler_mfp  ; neue Interrupt-Routine
               move.w     #15,-(sp)
               move.w     #$d,-(sp)     ; MFP-Vektor Nummer 15 setzen
               trap       #14           ;
               addq.l     #8,sp         ; stack korrigieren

               pea        ihandler_tima ; neue Interrupt-Routine
               move.w     #77,-(sp)     ; Vektor Nummer 77
               move.w     #5,-(sp)      ; BIOS #5
               trap       #13           ;
               addq.l     #8,sp         ; stack korrigieren

               lea.l      berrsprung,a1 ; Original Buserror-Einsprung retten
               move.l     8,(a1)
               lea.l      gotoBuserr,a1 ; auf neue Routine setzen
               move.l     a1,8
               nop        
               move.l     sp,berrspreg  ; Stackpointer retten

               lea.l      vmestart,a0
               movea.l    (a0),a0
               clr.l      d2            ; zaehler max Anzahl Soundkarten
               clr.l      d3            ; zaehler installierte soundkarten
               lea.l      cardlist,a1   ; karten-startadressen-liste

regtest:       moveq.l    #1,d0         ; Flag setzen
               tst.b      (a0)          ; Buszugriff
               clr.w      d0            ; Flag lîschen, wenn kein Buserror
gotoBuserr:    movea.l    berrspreg,sp  ; Stackpointer korrigieren
               tst.w      d0            ; durchgekommen ohne Buserror ?
               beq.s      regtesta      ; ja, zugriff war erlaubt
               bsr        ncardtxt      ; Meldung das keine Karte im Slot
               bra.s      regtestb      ; weiter mit nÑchster Karte
regtesta:      addi.w     #1,d3         ; wieder eine Karte gefunden
               move.l     a0,(a1)+      ; Startadresse in Liste speichern
               bsr        ycardtxt      ; Meldung das Karte gefunden wurde
regtestb:      adda.l     #$4000,a0     ; zur nÑchsten Karte
               addi.w     #1,d2         ; Versuch nr.+1 erhîhen
               cmpi.w     #1,d2         ; Anzahl max.Karten erreicht ?
               blt.s      regtest       ; wenn nicht, nochmal

               lea.l      cardz,a1
               move.w     d3,(a1)
               lea.l      cardsl,a1
               move.w     #1,(a1)
               bra.s      berrset
               lea.l      cardz,a1
               move.w     #0,(a1)
               lea.l      cardsl,a1
               move.w     #0,(a1)

berrset:       lea.l      berrsprung,a1 ; Original Buserror-Handler
               move.l     (a1),8
               nop        

               lea.l      cardz,a1
               tst.w      (a1)          ; keine Audiokarte ?
               beq.s      demoset1      ; dann demo-mode

               bsr        cardadr

               lea.l      cardz,a2
               move.w     (a2),d2
               swap.w     d2
               movem.l    d1-d7/a0-a6,-(sp)
               bsr        cardmagic     ; dsp vorhanden ?
               movem.l    (sp)+,d1-d7/a0-a6
               bra.s      demoset1e

demoset1:      lea.l      vmemul,a2
               move.l     a2,d0
               addq.l     #1,d0
               lea.l      vmestart,a2
               move.l     d0,(a2)
               lea.l      cardlist,a1   ; karten-startadressen-liste
               move.l     (a2),(a1)
               lea.l      cardz,a1
               move.w     #0,(a1)
               lea.l      cardsl,a1
               move.w     #0,(a1)
               bsr        cardadr
               clr.l      d0

demoset1e:     move.l     (sp)+,d6
               movea.l    (sp)+,a1
               move.w     d0,d2
               suba.l     #16,a1
               move.l     (a1)+,d1
               cmpi.l     #"strk",d1
               bne.s      initmask
               move.l     d2,(a1)+
               move.l     4(a1),d3
               cmp.l      d6,d3
               bgt.s      nocj2
               move.l     d6,d0
               subq.l     #1,d0
               bsr        makecjar
               tst.l      d0
               bmi.s      initmask
               movea.l    a0,a1
               subq.l     #4,a1
               move.l     (a1)+,d3
               suba.l     #8,a1
nocj2:         move.l     #"_DSP",d1
               move.l     #0,d2
               move.w     cardmagc,d4
               btst       #5,d4
               beq.s      nodspfound
               move.l     #56002,d2
nodspfound:    move.l     d1,(a1)+
               move.l     d2,(a1)+
               move.l     #0,(a1)+
               move.l     d3,(a1)+

initmask:      tst.l      cookmgmc      ; lÑuft unter MagicMac ?
               bne.s      anfint
               cmpi.l     #$1f,cooksnd  ; lÑuft auf Falcon ?
               beq.s      anfint

               lea.l      vmemask,a0    ; VME-Irq-Mask-Reg
               movea.l    (a0),a0
               andi.b     #$61,(a0)
               ori.b      #32,(a0)      ; alle Int5 erlauben
               move.w     sr,d0         ; INTs ein
               andi.w     #%1111100011111111,d0
               move.w     d0,sr

anfint:        

Xbrweiter:     
               move.l     xbiosvec,XBspr          ; Xbios-Vektor in Xbra merken
               move.l     xbiosvec,DXBspr         ; Xbios-Vektor in Xbra merken

               tst.w      cardz
               bne.s      nodemo

               lea.l      demo_Xbios,a1
               move.l     a1,xbiosvec
               move.w     #'XB',d0      ; Xbra's setzen
               move.w     d0,DXBI
               move.w     #'RA',d0
               move.w     d0,DXBI+2
               bra.s      xbinitex
nodemo:        lea.l      neu_Xbios,a1
               move.l     a1,xbiosvec
               move.w     #'XB',d0      ; Xbra's setzen
               move.w     d0,XBI
               move.w     #'RA',d0
               move.w     d0,XBI+2
xbinitex:      movem.l    d0-d7/a0-a6,-(sp)

               cmpi.l     #$1f,cooksnd  ; lÑuft unter Falcon ?
               beq.s      nocookchng

               bsr        getspecs      ; initfile laden

               lea.l      stack,a0
               move.w     #1,(a0)
               bsr        compatible    ; KompatibilitÑtsmodus ein
nocookchng:    bsr        initregs      ; Register initialisieren
               cmpi.l     #$1f,cooksnd  ; lÑuft unter Falcon ?
               beq.s      nodspinit

               tst.w      cardz
               beq.s      nodspinit

               bsr        dsp_stdinit   ; DSP-Initialize

nodspinit:     movem.l    (sp)+,d0-d7/a0-a6

               move.w     #32,-(sp)     ;in Usermode
               trap       #1
               addq.l     #6,sp

               tst.w      gem
               bne.s      nogem
               pea        Text          ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               tst.w      cardz
               bne.s      nogem
               pea        demotxt       ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern

nogem:         clr.w      -(sp)
               move.l     merklen,d0
               move.l     d0,-(sp)
               move.w     #$31,-(sp)    ;resident halten
               trap       #1
               rts        

XBI:           .DC.b "XXXX"
               .DC.b "STRK"
XBspr:         .DS.l 1    ;Puffer fÅr alten XBIOS-Vektor

neu_Xbios:                ;Anfang des neuen Xbios
               move.w     (sp),d0       ;get SR
               move.l     usp,a0
               btst       #13,d0        ; test supervisor
               beq.s      neu_Xbios1
               lea.l      8(sp),a0      ; >68000er
               tst.w      $59e          ; longframe ?
               bne.s      neu_Xbios1
               lea.l      6(sp),a0      ; ist 68000er
neu_Xbios1:    lea.l      Rlist,a1
               tst.w      cardz
               bne.s      nodemo2
               lea.l      Rlistb,a1
nodemo2:       moveq.l    #0,d2
               move.w     (a0),d0
neu_Xbios2:    cmp.w      0(a1,d2.w),d0
               beq.s      copylist
               addq.w     #2,d2
               tst.w      0(a1,d2.w)
               bne.s      neu_Xbios2
sprung:        movea.l    XBspr(pc),a0
               jmp        (a0)
copylist:      movem.l    d3-d7/a3-a7,-(sp)
               move.w     d2,d3
               tst.w      cardz
               beq        nodemo3
               move.w     falcxmov,d2
               btst       #0,d2         ; XBIOS soundcalls protokollieren ?
               beq        nodemo3       ; nein, dann raus...
               cmpi.w     #myxcall,d0   ; eigene XBIOS nicht protokollieren
               beq        nodemo3
               btst       #1,d2         ; XBIOS DSP-Calls protokollieren ?
               bne.s      copylst1      ; wenn ja, dorthin...
               cmpi.w     #127,d0       ; >DSP-Calls ?
               bgt.s      copylst1b
               bra.s      nodemo3       ; DSP-Calls nicht protokollieren
copylst1:      cmpi.w     #128,d0       ; <soundcalls ?
               blt.s      copylst3
copylst1b:     cmpi.w     #141,d0       ; buffptr-Abfrage nicht protokollieren
               beq.s      nodemo3
               cmpi.w     #130,d0       ; >soundcall = soundcmd ?
               bne.s      copylst2
               move.w     4(a0),d2
               cmpi.w     #-1,d2        ; Abfragefunktion soundcmd ?
               beq.s      nodemo3       ; dann nicht protokollieren
               bra.s      copylst3
copylst2:      move.w     2(a0),d2
               cmpi.w     #-1,d2        ; Abfragefunktion ?
               beq.s      nodemo3       ; dann nicht protokollieren
copylst3:      movem.l    d3/a0,-(sp)
               lea.l      falcxlen,a6
               move.w     0(a6,d3.w),d2
               lea.l      falcxlist,a6
               move.w     falcxnr,d6
               movea.l    a0,a5
               move.w     (a5)+,0(a6,d6.w)
               addq.w     #2,d6
foundlst:      tst.w      d2
               beq.s      foundlst3
               subq.w     #1,d2
foundl1b:      move.w     (a5)+,0(a6,d6.w)
               addq.w     #2,d6
               cmpi.w     #3000,d6
               blt.s      foundlst2
               move.w     #0,d6
               bra.s      foundlst3
foundlst2:     dbra       d2,foundl1b
foundlst3:     move.w     d6,falcxnr
               movem.l    (sp)+,d3/a0
nodemo3:       cmpi.w     #myxcall,d0   ; myxbios ?
               beq        myxbios
               lsl.w      #1,d3
               lea.l      R_addr,a1
               tst.w      cardz
               bne.s      nodemo4
               lea.l      R_addrb,a1
nodemo4:       movea.l    0(a1,d3.w),a1
               addq.l     #2,a0
               movem.l    d1-d7/a1-a6,-(sp)
               jsr        (a1)
               movem.l    (sp)+,d1-d7/a1-a6
               movem.l    (sp)+,d3-d7/a3-a7
               rte        

DXBI:          .DC.b "XXXX"
               .DC.b "STRK"
DXBspr:        .DS.l 1    ;Puffer fÅr alten XBIOS-Vektor
demo_Xbios:               ;Anfang des neuen Xbios
               move.w     (sp),d0       ;get SR
               move.l     usp,a0
               btst       #13,d0
               beq.s      demo_Xbios1
               lea.l      8(sp),a0      ; >68000er
               tst.w      $59e          ; longframe ?
               bne.s      demo_Xbios1
               lea.l      6(sp),a0      ; ist 68000er
demo_Xbios1:   lea.l      Rlist3,a1
               moveq.l    #0,d2

               move.w     (a0),d0
demo_Xbios2:   cmp.w      0(a1,d2.w),d0
               beq.s      demo_found
               addq.w     #2,d2
               tst.w      0(a1,d2.w)
               bne.s      demo_Xbios2
               movea.l    DXBspr(pc),a0
               jmp        (a0)

demo_found:    movem.l    d3-d7/a3-a7,-(sp)
               cmpi.w     #myxcall,d0   ; myxbios als demo ?
               beq.s      demoxbios
               lsl.w      #1,d2
               lea.l      R_addr3,a1
               movea.l    0(a1,d2.w),a1
               addq.l     #2,a0
               jsr        (a1)
               movem.l    (sp)+,d3-d7/a3-a7
               rte        

myxbios:       lea.l      Rlist2,a1
               moveq.l    #0,d2
               move.w     2(a0),d1
my_Xbios:      cmp.w      0(a1,d2.w),d1
               beq.s      my_found
               addq.w     #2,d2
               tst.w      0(a1,d2.w)
               bne.s      my_Xbios
               movem.l    (sp)+,d3-d7/a3-a7
               bra        sprung
my_found:      lsl.w      #1,d2
               lea.l      R_addr2,a1
               movea.l    0(a1,d2.w),a1
               addq.l     #4,a0
               jsr        (a1)
               movem.l    (sp)+,d3-d7/a3-a7
               rte        

demoxbios:     lea.l      Rlist2,a1
               moveq.l    #0,d2
               move.w     2(a0),d1
my_DXbios:     cmp.w      0(a1,d2.w),d1
               beq.s      my_Dfound
               addq.w     #2,d2
               tst.w      0(a1,d2.w)
               bne.s      my_DXbios
               movem.l    (sp)+,d3-d7/a3-a7
               rte        
               bra        sprung
my_Dfound:     lsl.w      #1,d2
               lea.l      R_addr4,a1
               movea.l    0(a1,d2.w),a1
               addq.l     #4,a0
               jsr        (a1)
               movem.l    (sp)+,d3-d7/a3-a7
               rte        

spcinp:        .DC.b "insrc="           ; analog,opto,cinch
spcout:        .DC.b "outsrc="          ; input,dma,ext
spcmode:       .DC.b "mode="            ; stereo, falcon,0-3
spcvoli:       .DC.b "invol="           ; $00-$ff
spcvolo:       .DC.b "outvol="          ; $00-$ff
spcbt:         .DC.b "bitres="          ; normal,extended

spcinpt0:      .DC.b "insource=",0
spcinpt1:      .DC.b "analog",CR,LF,0
spcinpt2:      .DC.b "opto",CR,LF,0
spcinpt3:      .DC.b "cinch",CR,LF,0
spcopt0:       .DC.b "outsource=",0
spcopt1:       .DC.b "input",CR,LF,0
spcopt2:       .DC.b "dma",CR,LF,0
spcopt3:       .DC.b "external",CR,LF,0
spcmdt0:       .DC.b "mode=",0
spcmdt1:       .DC.b "stereo",CR,LF,0
spcmdt2:       .DC.b "falcon",CR,LF,0
spcmont0:      .DC.b "monitor",0
spcmont1:      .DC.b "=",0
spcivt0:       .DC.b "involume",0
spcivt1:       .DC.b "=$",0
spcovt0:       .DC.b "outvolume",0
spcbtt0:       .DC.b "bitres=",0
spcbtt1:       .DC.b "normal",CR,LF,0
spcbtt2:       .DC.b "extended",CR,LF,0
spcbyet0:      .DC.b CR,LF,"configfile SOUND.INF not found! ",CR,LF,0
spcbyet1:      .DC.b "set to standard falconmode...(analog/out=inp/44.1kHz)",CR,LF,0
               .EVEN 

specout:       tst.w      gem
               bne.s      nospectex
               movem.l    d0-d7/a0-a4,-(sp)
               move.l     a6,-(sp)      ; Msgtext specific
               move.l     a5,-(sp)      ; Msgtext main
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               movem.l    (sp)+,d0-d7/a0-a4
nospectex:     rts        

getspecs:      tst.w      cardz
               beq        nospex
               lea.l      asrc(pc),a6   ; asrc=analog
               move.w     #1,(a6)
               move.l     #0,montrack
               lea.l      dsrc(pc),a6   ; digital source=opto
               move.w     #0,(a6)       ; wert
               lea.l      adwert(pc),a6
               move.l     #0,(a6)       ; adc still
               lea.l      dawert(pc),a6
               move.l     #0,(a6)       ; dac still
               bsr        setupvol
               lea.l      adwert(pc),a6
               move.w     #$c0,(a6)+
               move.w     #$c0,(a6)
               lea.l      dawert(pc),a6
               move.w     #$c0,(a6)+
               move.w     #$c0,(a6)
               lea.l      osrc(pc),a6   ; source is adc
               move.w     #0,(a6)
               lea.l      modr24(pc),a3
               move.b     #0,(a3)
               lea.l      playmod(pc),a6
               move.w     #2,(a6)
               clr.w      -(sp)
               lea.l      specnam(pc),a0
               move.l     a0,-(sp)
               move.w     #61,-(sp)
               trap       #1
               addq.l     #8,sp
               cmpi.l     #0,d0
               bmi        nospecs
               movem.l    d0/a0,-(sp)
               pea        creturn       ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               movem.l    (sp)+,d0/a0
               lea.l      filebuf,a0
               move.l     a0,-(sp)
               move.l     #512,-(sp)    ; ein sektor
               move.w     d0,-(sp)
               move.w     d0,handle
               move.w     #63,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               lea.l      filebuf,a0
spcnxt1:       moveq.l    #0,d2
spcnxt2:       move.b     (a0),d0
               cmpi.b     #"=",d0
               beq        spcfrdy
               bset       #5,d0
               move.w     #0,d7
               move.w     #1,d6
               lea.l      spcinp(pc),a1
               cmp.b      0(a1,d2.w),d0
               beq.s      spcfnd
               move.w     #2,d6
               lea.l      spcout(pc),a1
               cmp.b      0(a1,d2.w),d0
               beq.s      spcfnd
               move.w     #3,d6
               lea.l      spcmode(pc),a1
               cmp.b      0(a1,d2.w),d0
               beq.s      spcfnd
               move.w     #4,d6
               lea.l      spcvoli(pc),a1
               cmp.b      0(a1,d2.w),d0
               beq.s      spcfnd
               move.w     #5,d6
               lea.l      spcvolo(pc),a1
               cmp.b      0(a1,d2.w),d0
               beq.s      spcfnd
               move.w     #6,d6
               lea.l      spcbt(pc),a1
               cmp.b      0(a1,d2.w),d0
               beq.s      spcfnd
               addq.l     #1,a0
               cmpa.l     #filebuf+512,a0
               blt.s      spcnxt1
               move.w     handle,-(sp)
               move.w     #62,-(sp)
               trap       #1
               addq.l     #4,sp
               clr.l      d0
               rts        
nospecs:       lea.l      spcbyet0(pc),a5
               lea.l      spcbyet1(pc),a6
               bsr        specout
nospex:        move.l     #-1,d0
               rts        
spcfnd:        addi.w     #1,d2
               addq.l     #1,a0
               move.w     d6,d7
               bra        spcnxt2
spcfrdy:       addq.l     #1,a0
               cmpi.w     #1,d7
               beq.s      spcfnd1
               cmpi.w     #2,d7
               beq        spcfnd2
               cmpi.w     #3,d7
               beq        spcfnd3
               cmpi.w     #4,d7
               beq        spcfnd4
               cmpi.w     #5,d7
               beq        spcfnd5
               cmpi.w     #6,d7
               beq        spcfnd6
               bra        spcnxt1

spcfnd1:       move.b     (a0),d1
               bclr       #5,d1
               cmpi.b     #"A",d1
               beq.s      spc11
               cmpi.b     #"O",d1
               beq.s      spc12
               cmpi.b     #"C",d1
               beq.s      spc13
               bra        spcnxte
spc11:         lea.l      asrc(pc),a6   ; asrc=analog
               move.w     #1,(a6)
               lea.l      spcinpt0(pc),a5
               lea.l      spcinpt1(pc),a6
               bsr        specout
               bra        spcnxte

spc12:         lea.l      asrc(pc),a6   ; asrc=digi
               move.w     #0,(a6)
               lea.l      dsrc(pc),a6   ; digital source=opto
               move.w     #0,(a6)       ; wert
               lea.l      spcinpt0(pc),a5
               lea.l      spcinpt2(pc),a6
               bsr        specout
               bra        spcnxte
spc13:         lea.l      asrc(pc),a6   ; asrc=digi
               move.w     #0,(a6)
               lea.l      dsrc(pc),a6   ; digital source=coax
               move.w     #1,(a6)       ; wert
               lea.l      spcinpt0(pc),a5
               lea.l      spcinpt3(pc),a6
               bsr        specout
               bra        spcnxte

spcfnd2:       move.b     (a0),d1
               bclr       #5,d1
               cmpi.b     #"I",d1
               beq.s      spc21
               cmpi.b     #"D",d1
               beq.s      spc22
               cmpi.b     #"E",d1
               beq.s      spc23
               bra        spcnxte
spc21:         move.w     #0,osrc
               lea.l      spcopt0(pc),a5
               lea.l      spcopt1(pc),a6
               bsr        specout
               bra        spcnxte
spc22:         move.w     #1,osrc
               lea.l      spcopt0(pc),a5
               lea.l      spcopt2(pc),a6
               bsr        specout
               bra        spcnxte
spc23:         move.w     #2,osrc
               lea.l      spcopt0(pc),a5
               lea.l      spcopt3(pc),a6
               bsr        specout
               bra        spcnxte

spcfnd3:       lea.l      playmod(pc),a6
               move.b     (a0),d1
               bclr       #5,d1
               cmpi.b     #"S",d1
               beq.s      spc31
               cmpi.b     #"F",d1
               beq.s      spc32
               bra        spcnxte
spc31:         move.w     #0,(a6)
               lea.l      spcmdt0(pc),a5
               lea.l      spcmdt1(pc),a6
               bsr        specout
               bra        spcnxte
spc32:         move.w     #2,(a6)
               lea.l      spcmdt0(pc),a5
               lea.l      spcmdt2(pc),a6
               bsr        specout
               adda.l     #6,a0
spc33:         move.b     (a0)+,d1
               cmpi.b     #",",d1
               bne        spcnxte
               move.b     (a0)+,d1
               andi.w     #$ff,d1
               move.l     a0,-(sp)
               move.w     d1,-(sp)
               subi.b     #48,d1
               andi.w     #3,d1
               move.w     d1,montrack
               lea.l      spcmont0(pc),a5
               lea.l      spcmont1(pc),a6
               bsr        specout
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               pea        creturn       ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               movea.l    (sp)+,a0
               bra        spcnxte

spcfnd4:       lea.l      adwert(pc),a6
               lea.l      spcivt0(pc),a5
spcfnd4a:      move.b     (a0)+,d1
               cmpi.b     #"$",d1
               bne        spcnxt1
               move.l     a6,-(sp)
               lea.l      spcivt1(pc),a6
               bsr        specout
               movea.l    (sp)+,a6
               move.b     (a0)+,d1
               move.l     a0,-(sp)
               move.w     d1,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #2,sp
               move.w     (sp)+,d1
               movea.l    (sp)+,a0
               subi.b     #48,d1
               cmpi.b     #9,d1
               ble.s      nohex1
               subi.b     #7,d1
               cmpi.b     #15,d1
               ble.s      nohex1
               subi.b     #32,d1
nohex1:        move.w     d1,d3
               lsl.w      #4,d3
               move.b     (a0)+,d1
               move.l     a0,-(sp)
               move.w     d1,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #2,sp
               move.w     (sp)+,d1
               movea.l    (sp)+,a0
               cmpi.w     #48,d1
               blt.s      spcfnd4b
               subi.b     #48,d1
               cmpi.b     #9,d1
               ble.s      nohex2
               subi.b     #7,d1
               cmpi.b     #15,d1
               ble.s      nohex2
               subi.b     #32,d1
nohex2:        andi.w     #$f,d1
               or.b       d1,d3
spcfnd4b:      move.w     d3,(a6)+
               move.w     d3,(a6)
               move.l     a0,-(sp)
               pea        creturn       ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               movea.l    (sp)+,a0
               bra        spcnxte

spcfnd5:       lea.l      dawert(pc),a6
               lea.l      spcovt0(pc),a5
               bra        spcfnd4a

spcfnd6:       move.b     (a0),d1
               lea.l      modr24(pc),a3
               bclr       #5,d1
               cmpi.b     #"N",d1
               beq.s      spc61
               cmpi.b     #"E",d1
               beq.s      spc62
               bra        spcnxte
spc61:         move.b     #0,(a3)
               lea.l      spcbtt0(pc),a5
               lea.l      spcbtt1(pc),a6
               bsr        specout
               bra        spcnxte
spc62:         move.b     #1,(a3)
               lea.l      spcbtt0(pc),a5
               lea.l      spcbtt2(pc),a6
               bsr        specout

spcnxte:       move.b     (a0)+,d1
               cmpi.b     #0,d1
               beq        spcnxt1
               cmpi.b     #CR,d1
               bne.s      spcnxte
               bra        spcnxt1

speedtst:      movea.l    (a0)+,a1      ; buffer
               move.l     (a0)+,d7      ; loops
               clr.l      d3
               movea.l    a1,a6
               addq.l     #4,a1
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedmemr:     move.w     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedmemr
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedmemw:     move.w     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedmemw
               move.l     $4ba,d1
               move.l     d1,(a1)+
               lea.l      vmestart,a6
               movea.l    (a6),a6
               adda.l     #$206,a6
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedhostr:    move.b     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedhostr
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedhostw:    move.b     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedhostw
               move.l     $4ba,d1
               move.l     d1,(a1)+
               lea.l      vmestart,a6
               movea.l    (a6),a6
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedregr:     move.b     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedregr
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedregw:     move.b     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedregw
               move.l     $4ba,d1
               move.l     d1,(a1)+
               lea.l      vmestart,a6
               movea.l    (a6),a6
               adda.l     #$100,a6
               move.l     d7,d0
               move.l     $4ba,d1
               move.l     d1,(a1)+
speedfifor:    move.b     (a6),d2
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedfifor
               move.l     $4ba,d1
               move.l     d1,(a1)+
               move.l     d7,d0
speedfifow:    move.b     d3,(a6)
               subq.l     #1,d0
;               tst.l      d0
               bne.s      speedfifow
               move.l     $4ba,d1
               move.l     d1,(a1)+
               clr.l      d0
               rts        

;-------------------------------------------------------------------------------

cardmagic:     clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a6),d0
               andi.w     #$c7,d0
               btst       #6,d0
               beq.s      cardm2
               bset       #3,d0
cardm2:        btst       #7,d0
               beq.s      cardm3
               bset       #4,d0
cardm3:        move.b     $1ff(a6),d1
               cmpi.b     #$ff,d1
               bne.s      cardm4
               move.b     $200(a6),d2
               cmpi.b     #$ff,d2
               bne.s      cardm4
               move.b     $201(a6),d3
               cmpi.b     #$ff,d3
               bne.s      cardm4
               move.b     $202(a6),d4
               cmpi.b     #$ff,d4
               bne.s      cardm4
               move.b     $203(a6),d5
               cmpi.b     #$ff,d5
               bne.s      cardm4
               move.b     $204(a6),d6
               cmpi.b     #$ff,d6
               bne.s      cardm4
               move.b     $205(a6),d7
               cmpi.b     #$ff,d7
               bne.s      cardm4
               move.b     $206(a6),d7
               cmpi.b     #$ff,d7
               beq.s      cardm5
cardm4:        bset       #5,d0
cardm5:        andi.w     #$3f,d0
               lea.l      cardmagc,a1
               move.w     d0,(a1)
               rts        

cardslot:      clr.l      d0
               lea.l      cardz,a1
               move.w     (a1),d0
               rts        

cardadr:       lea.l      cadr,a1
               move.l     a1,d0
               lea.l      vmestart(pc),a6
               move.l     (a6),d1
               addi.l     #$ff,d1
               move.l     d1,(a1)+
               move.l     (a6),d1
               addi.l     #$60,d1
               move.l     d1,(a1)+
               move.l     (a6),d1
               addi.l     #$40,d1
               move.l     d1,(a1)+
               move.l     (a6),d1
               addi.l     #$1ff,d1
               move.l     d1,(a1)
               rts        

cardsel:       clr.l      d0
               move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq.s      getcard
               lea.l      cardz(pc),a1
               move.w     (a1),d1
               cmp.w      d1,d0
               ble.s      cardsel2
cardsex:       move.l     #-1,d0
               rts        
cardsel2:      cmpi.w     #1,d0
               blt.s      cardsex
cardsel3:      cmpi.w     #4,d0
               bgt.s      cardsex
               lea.l      cardsl(pc),a1
               move.w     d0,(a1)
               clr.l      d1
               move.w     d0,d1
               add.w      d1,d1
               add.w      d1,d1
               subi.w     #4,d1
               lea.l      vmestart(pc),a0
               lea.l      cardlist(pc),a1
               move.l     0(a1,d1.w),(a0)
               jsr        cardadr
               move.l     #0,d0
               rts        
getcard:       clr.l      d0
               lea.l      cardsl(pc),a0
               move.w     (a0),d0
               rts        

ycardtxt:      tst.w      gem
               bne        textexit
               movem.l    d0-d7/a0-a6,-(sp)
               move.w     d2,-(sp)
               pea        yfoundtxt     ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.w     (sp)+,d2
               clr.w      d0
               move.b     d2,d0
               addi.b     #49,d0
               move.w     d0,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     #13,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     #10,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               movem.l    (sp)+,d0-d7/a0-a6
               rts        

ncardtxt:      tst.w      gem
               bne.s      textexit
               movem.l    d0-d7/a0-a6,-(sp)
               move.w     d2,-(sp)
               pea        nfoundtxt     ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.w     (sp)+,d2
               clr.w      d0
               move.b     d2,d0
               addi.b     #49,d0
               move.w     d0,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     #13,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     #10,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               movem.l    (sp)+,d0-d7/a0-a6
textexit:      rts        

               .EVEN 
stack_store:   .DS.l 1    ; 1 Langwort fÅr stack

aes_test:      lea.l      control,a1
               move.w     #10,(a1)+     ;store the op code
               move.w     #0,(a1)+      ;do control1
               move.w     #1,(a1)+      ;and control2
               move.w     #0,(a1)+      ;and control3
               clr.w      (a1)          ;assumes control4=0
               move.l     #aes_params,d1
               move.w     #200,d0       ;function number
               trap       #2
               move.w     int_out,d0    ;usually a returned value
               rts        

intmidikey:    movem.l    d0-d7/a0-a6,-(sp)
               move.w     midikey,d6    ; midikey-modus
               cmpi.w     #1,d6         ; midi-erkennung an ?
               bne        knomidi       ; dann eben nicht....
               lea.l      midiw,a0
               btst       #7,d0
               beq.s      kmididat      ; Daten oder Befehl ?
               move.b     d0,d2

               cmpi.b     #$f8,d2       ; midi time-code (sys realtime msg)?
               beq        knomidi

               andi.b     #$f0,d2
               cmpi.b     #$90,d2       ; note on ?
               beq        note_ok
               cmpi.b     #$80,d2       ; note off ?
               beq        note_ok
               move.b     d2,(a0)       ; befehl speichern
               bra        knomidi
note_ok:       move.b     d2,(a0)       ; note_on($90)/note_off($80)
               andi.b     #$f,d0
               move.b     d0,1(a0)      ; channel(0-15) schreiben
               move.b     #$ff,2(a0)    ; neuer Befehl -> note lîschen
               move.b     #$ff,3(a0)    ; neuer Befehl -> velocity lîschen
               bra        knomidi
kmididat:      cmpi.b     #$90,(a0)     ; letzer Befehl war note_on ?
               beq.s      note_ok2
               cmpi.b     #$80,(a0)     ; letzer Befehl war note_off ?
               beq.s      note_ok2
               bra        knomidi       ; dann anderer Befehl
note_ok2:      cmpi.b     #$ff,2(a0)    ; Noten-DATA gelîscht ?
               bne.s      kmidivelo     ; dann ist es notenwert,sonst velocity
kmidinote:     move.b     d0,2(a0)      ; Notenwert schreiben
               bra        knomidi
kmidivelo:     cmpi.b     #$ff,3(a0)    ; Velocity-DATA gelîscht ?
               bne        knomidi       ; velocity wert schon vorhanden->weg
               move.b     d0,3(a0)      ; Velocitywert schreiben
               clr.w      d0
               clr.w      d1
               move.b     2(a0),d1      ; note holen
               andi.b     #$7f,d1
               lsl.w      #5,d1         ; note*32
               move.b     1(a0),d0      ; channel holen
               add.w      d0,d1         ; + channel
               add.w      d0,d1         ; + channel
               lea.l      midilist,a1
               cmpi.b     #$80,(a0)     ; note_off ?
               beq.s      noteoffset
               tst.b      3(a0)         ; note_on und velocity=0 ?
               beq.s      noteoffset
               move.b     #$ff,2(a0)    ; vor neuem Befehl -> note lîschen
               move.b     #$ff,3(a0)    ; vor neuem Befehl -> velocity lîschen

kmidion:       move.b     #1,0(a1,d1.w) ; midilist =note_on(1) eintragen
               move.b     3(a0),1(a1,d1.w)        ; velocity in liste eintragen
               lea.l      midionpipe,a2
               move.b     midioncount,d3
               clr.w      d2
               move.b     d3,d2
               add.w      d2,d2
               move.w     d1,0(a2,d2.w) ; listenoffset in on_pipe schreiben
               addi.b     #1,d3         ; playliste erweitern
               move.b     d3,midioncount
               bra.s      kmidiex       ; Abbruch, da NOTE ON !
noteoffset:    move.b     #$ff,2(a0)    ; vor neuem Befehl -> note lîschen
               move.b     #$ff,3(a0)    ; vor neuem Befehl -> velocity lîschen
               tst.b      0(a1,d1.w)    ; midilist-entry ist frei ?
               beq.s      kmidiex
               move.b     #3,0(a1,d1.w) ; note_off(3) in liste eintragen
               lea.l      midioffpipe,a2
               move.b     midioffcount,d3
               clr.w      d2
               move.b     d3,d2
               add.w      d2,d2
               move.w     d1,0(a2,d2.w) ; listenoffset in off_pipe schreiben
               addi.b     #1,d3         ; playliste erweitern
               move.b     d3,midioffcount
               bra.s      kmidiex       ; Abbruch, da NOTE OFF !
knomidi:       movem.l    (sp)+,d0-d7/a0-a6
midikjmp:      jmp        $11223344
kmidiex:       addi.w     #1,midiktest  ; neuer notenwert angekommen
               movem.l    (sp)+,d0-d7/a0-a6
               bra.s      midikjmp

midikeyinit:   move.w     (a0)+,d0
               move.w     d0,midikey
               move.w     #0,midiktest
               rts        

midikeyrst:    move.w     #0,midiktest
               rts        

;midilist:      2048 list of pressed or unpressed keys
;midipipe:       256 midikey pipeline
;midicount:          midi pipeline-counter

midiplaymix:   move.w     (a0)+,midimax ; max entrys
               move.l     (a0)+,midix   ; midi (ch,note)
               move.l     (a0)+,midipath
               move.l     (a0)+,midistart
               move.l     (a0)+,midiend
               move.l     (a0)+,midisrate
               move.l     (a0)+,midiloop
               move.l     (a0)+,miditri
               move.b     #0,midicount  ; pipelinecounter lîschen
               move.b     #0,midioncount
               move.b     #0,vmidioncount
               move.b     #0,midioffcount
               move.b     #0,vmidioffcount
               lea.l      step,a2
               move.l     #0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      mode,a2
               move.w     #0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo,a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      pimode,a2
               move.l     #30,(a2)      ; mplaymix
               jsr        initplugp
               lea.l      recbuf,a0
               move.w     #4095,d0
rbufclr:       move.l     #0,(a0)+      ; dummybuffer lîschen
               dbra       d0,rbufclr
               lea.l      midilist,a0
               move.w     #2047,d0
rbufclr2:      move.w     #0,(a0)+      ; dummybuffer lîschen
               dbra       d0,rbufclr2
               lea.l      stack,a0
               move.w     #1,(a0)       ; INT-Registerinhalt
               jsr        intact
midiwait:      lea.l      midioncount,a1
               lea.l      vmidioncount,a2
               lea.l      midioffcount,a3
               lea.l      vmidioffcount,a4
midiwait2:     bsr        pbrktst       ; break-taste gedrÅckt ?
               tst.w      d0
               bne.s      midiwaitend
               move.b     (a3),d0
               cmp.b      (a4),d0
               bne        miditstoff
midiwait3:     move.b     (a1),d0
               cmp.b      (a2),d0
               bne.s      miditston
               bra.s      midiwait2
midiwaitend:   lea.l      stack,a0
               move.w     #0,(a0)       ; Interrupt lîschen
               jsr        intact
               lea.l      midicount,a1
               move.l     a1,d0
               rts                      ; ende des programms

miditston:     lea.l      midionpipe,a5
               clr.w      d0
               move.b     (a2),d0       ; vmidioncount holen
               add.w      d0,d0
               move.w     0(a5,d0.w),d1 ; midioffset aus pipe holen
               addi.b     #1,(a2)       ; vmidioncounter erhîhen

;(.....load and init playchannel
               movea.l    midix(pc),a5
               move.w     0(a5,d1.w),d6 ; array-nummer holen
               cmpi.w     #-1,d6        ; ist die Taste erlaubt ?
               bne.s      corrkey
               lea.l      midilist,a5
               move.b     #2,0(a5,d1.w) ; midiliste auf 2 (work_ok)
               jmp        midiwait2     ; zurÅck zur testschleife

corrkey:       add.w      d6,d6
               add.w      d6,d6
               clr.w      d0
               move.b     midicount,d0
               move.b     d0,d7
               add.w      d0,d0
               lea.l      midipipe,a6
               move.w     d1,0(a6,d0.w) ; listoffset in midipipe einfÅgen

               lea.l      midismpte(pc),a6
               movea.l    midistart(pc),a5
               move.l     0(a5,d6.w),0(a6,d6.w)   ; startwert initialisieren
;).....load and init playchannel
               addi.b     #1,midicount  ; pipecounter erhîhen
               lea.l      pipefind,a5
               move.b     d7,0(a5,d1.w) ; midilisten-location (midicount) merken

               lea.l      midilist,a5
               move.b     #2,0(a5,d1.w) ; midiliste auf 2 (work_ok)
               bra        midiwait2     ; zurÅck zur testschleife

miditstoff:    lea.l      midioffpipe,a5
               lea.l      midilist,a6
               clr.w      d0
               move.b     (a4),d2       ; vmidioffcount holen
               move.b     d2,d3         ; retten fÅr vergleich (x1)
               move.b     d2,d0
               add.w      d0,d0
               move.w     d0,d4         ; retten fÅr vergleich (x2)
miditstoff2:   move.w     0(a5,d0.w),d1 ; midioffset aus pipe holen
               cmpi.b     #4,0(a6,d1.w) ; midiliste ist 4 (work_closing) ?
               beq.s      midiclose

               movea.l    midix(pc),a5
               move.w     0(a5,d1.w),d6 ; array-nummer holen
               cmpi.w     #-1,d6        ; ist die Taste erlaubt ?
               beq.s      midiclose

               addi.w     #2,d0         ; zum nÑ. midioffset
               addi.b     #1,d2         ; counter erhîhen
               cmp.b      (a3),d2       ; midioffcount-ende erreicht ?
               bne.s      miditstoff2   ; dann nÑ. pipeentry testen
               bra        midiwait3     ; zurÅck zur testschleife
midiclose:     cmp.b      d3,d2         ; einziger pipe-eintrag ?
               beq.s      midiclose2
               move.w     0(a5,d4.w),0(a5,d0.w)   ; midioff_pipe verschieben
               move.w     #0,0(a5,d4.w) ; aus midioff_pipe entfernen
               move.b     d3,d2
               bra.s      midiclose3
midiclose2:    move.w     #0,0(a5,d0.w) ; aus midioff_pipe entfernen
midiclose3:    
               movea.l    midix(pc),a5
               move.w     0(a5,d1.w),d6 ; array-nummer holen
               cmpi.w     #-1,d6        ; ist die Taste erlaubt ?
               beq.s      nocorrkey

corrkey2:      lea.l      pipefind,a5   ; midilist-location(midicount)
               clr.w      d7
               move.b     0(a5,d1.w),d7 ; midilisten-location holen
               add.w      d7,d7
               lea.l      midipipe,a5
               move.w     #-1,0(a5,d7.w)          ; entry aus midipipe entfernen
               subi.b     #1,midicount  ; pipecounter erniedrigen

; close playchannel....
nocorrkey:     
               move.w     #0,0(a6,d1.w) ; midilisten-entry entfernen
               addi.b     #1,(a4)       ;vmidioffcount erhîhen
               addi.b     #1,d2
               cmp.b      (a3),d2
               beq        midiwait3
               addi.w     #2,d0         ; zum nÑchsten pipe-entry
               move.b     d2,d3         ; zeiger merken
               bra        miditstoff2

miditexja:     .DC.b "NOTE ON",13,10,0
miditexno:     .DC.b "NOTE OFF",13,10,0
               .EVEN 

midioff:       movem.l    d1/a3-a5,-(sp)
               lea.l      midioffcount,a3
               lea.l      vmidioffcount,a4
midioff2:      move.b     (a3),d0
               cmp.b      (a4),d0
               bne.s      midioff3
               clr.w      d0
               movem.l    (sp)+,d1/a3-a5
               rts        
midioff3:      lea.l      midioffpipe,a5
               clr.w      d1
               move.b     (a4),d1
               add.w      d1,d1
               move.w     0(a5,d1.w),d1 ; midioffset aus pipe holen
               lea.l      midilist,a5
               addi.b     #1,(a4)       ; vmidicounter erhîhen
               cmpi.b     #3,0(a5,d1.w) ; midiliste ist 3 (midi_off) ?
               bne.s      midioff2
               move.b     #0,0(a5,d1.w) ; midilisten-entry lîschen
               move.w     #-1,d0
               movem.l    (sp)+,d1/a3-a5
               rts        

;XXL
mplaymix:      clr.w      d2
               move.b     midicount,d2
               add.w      d2,d2
               tst.b      d2
               bne.s      mplaymix2     ; zum ende
mplaymix1b:    lea.l      recbuf2,a3
               move.l     a3,d1         ; ende
               lea.l      recbuf,a3     ; anfang
               clr.l      d4            ; step
               clr.w      d3            ; mode
               bra.s      mplaymix3
mplaymix2:     clr.w      d0            ; offset erster pipe-entry
               lea.l      midipipe,a6
mplaymix2b:    move.w     0(a6,d0.w),d1 ; listoffset aus pipe holen
               cmpi.w     #-1,d1        ; wurde gelîscht ?
               bne.s      mplaymfnd
               addi.w     #2,d0
               cmp.b      d0,d2
               blt.s      mplaymix2b
               bra.s      mplaymix1b    ; dummy-play

mplaymfnd:     lea.l      midilist,a5
               cmpi.b     #2,0(a5,d1.w) ; midiliste auf 2 (work_ok) ?
               bne.s      mplaymix1b    ; dummy-play
               movea.l    midix(pc),a5
               move.w     0(a5,d1.w),d0 ; array-nummer holen
               move.w     d0,d7
               add.w      d7,d7
               add.w      d7,d7
               lea.l      midismpte(pc),a5
               movea.l    0(a5,d7.w),a3 ; aktueller startwert (a3)
               movea.l    midiend(pc),a5
               move.l     0(a5,d7.w),d1 ; lÑnge
               add.l      a3,d1         ; start+lÑnge=endwert (d1)
               lea.l      step,a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode,a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
mplaymix3:     lea.l      fifo,a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      vmestart,a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               cmpa.l     d1,a2
               beq        mp_back
mpfill:        move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      mpcopyanf
               bra.s      mpfill
mpcopyanf:     tst.l      d4
               blt        mpcopyneg
               cmpa.l     d1,a2
               bge        mplayend
               move.w     d2,d5         ; ...dann FIFO halb-fuellen (fifolen)!
mpcopy:        tst.w      pluglistp
               bne.s      mpuseplug
               move.b     (a2)+,(a5)
               move.b     (a2)+,(a5)
               move.b     (a2)+,(a1)
               move.b     (a2)+,(a1)
               bra.s      mpnoplug
mpuseplug:     move.w     (a2)+,-(sp)
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.w     (a2)+,-(sp)
               move.w     #0,-(sp)      ; Rechter Kanal holen
               jsr        workplugsp    ; plugins aufrufen
               move.b     6(sp),(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     7(sp),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(sp),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(sp),(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #8,sp
mpnoplug:      tst.b      midicount
               beq        mpcopy1b
               lea.l      vmidioffcount,a4
               move.b     (a4),d0
               lea.l      midioffcount,a4
               cmp.b      (a4),d0
               beq.s      mpcopy1b
               lea.l      midipipe,a4
               clr.w      d0
               move.w     0(a4,d0.w),d0 ; listoffset aus pipe holen
               lea.l      midilist,a4
               cmpi.b     #3,0(a4,d0.w) ; midiliste auf 3 (stopped) ?
               beq        mendplay      ; zum ende
mpcopy1b:      cmpa.l     d1,a2
               bge        mplayend
               adda.l     d4,a2
               dbra       d5,mpcopy
               bra        mp_back
mpcopyneg:     cmpa.l     d1,a2
               ble        mplayend
               move.w     d2,d5         ; ...dann FIFO halb-fuellen (fifolen)!
mpcopy2:       tst.w      pluglistp
               bne.s      mpuseplug2
               move.b     (a2)+,(a5)
               move.b     (a2)+,(a5)
               move.b     (a2)+,(a1)
               move.b     (a2)+,(a1)
               bra.s      mpnoplug2
mpuseplug2:    move.w     (a2)+,-(sp)   ; Linker Kanal holen
               move.w     #0,-(sp)
               move.w     (a2)+,-(sp)   ; Rechter Kanal holen
               move.w     #0,-(sp)
               jsr        workplugsp    ; plugins aufrufen
               move.b     6(sp),(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     7(sp),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(sp),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(sp),(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #8,sp
mpnoplug2:     tst.b      midicount
               beq        mpcopy2b
               lea.l      vmidioffcount,a4
               move.b     (a4),d0
               lea.l      midioffcount,a4
               cmp.b      (a4),d0
               beq.s      mpcopy2b
               lea.l      midipipe,a4
               move.w     0(a4,d0.w),d0 ; listoffset aus pipe holen
               lea.l      midilist,a4
               clr.w      d0
               cmpi.b     #3,0(a4,d0.w) ; midiliste auf 3 (stopped) ?
               beq        mendplay      ; zum ende
mpcopy2b:      cmpa.l     d1,a2
               ble.s      mplayend
               adda.l     d4,a2
               dbra       d5,mpcopy2
mp_back:       lea.l      midismpte(pc),a5
               move.l     a2,0(a5,d7.w) ; playposition retten
mp_back2:      movem.l    (sp)+,d0-d7/a0-a6
               rte        
mplayend:      moveq.l    #0,d0
               lea.l      von,a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #1,d3         ; crossplay ?
               beq        mplooptst     ; wenn nein, ueberspringen
               lea.l      crosflag,a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      mbaktofor
mfortobak:     addq.l     #8,d4
               neg.l      d4
               lea.l      step,a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von,a4
               move.l     d1,(a4)       ; neue Endposition
               lea.l      bvon,a4
               move.l     (a4),d1
               addq.l     #4,d1
               lea.l      bis,a4
               move.l     d1,(a4)       ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra.s      mp_back2
mbaktofor:     neg.l      d4
               subq.l     #8,d4
               lea.l      step,a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von,a4
               move.l     d1,(a4)       ; neue Anfangsposition
               lea.l      bbis,a4
               lea.l      bis,a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        mp_back2
mendplay:      tst.b      midicount
               beq        mendplay2
               tst.w      d0            ; offset erster pipe-entry
               lea.l      midipipe,a6
               move.w     0(a6,d0.w),d1 ; listoffset aus pipe holen
               lea.l      midilist,a5
               move.b     #4,0(a5,d1.w) ; midiliste auf 4 (closed) setzen
mendplay2:     movem.l    (sp)+,d0-d7/a0-a6       ; sample am ende angelangt...
               rte        
mplooptst:     btst       #0,d3
               beq.s      mendplay
               lea.l      von,a4
               lea.l      bvon,a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        mp_back2

; DSP1----------------------------DSP-Routinen-----------------------
;
;Xbios 96
;
;void    Dsp_DoBlock(char *data_in,long size_in,char *data_out,long size_out);
;
;Wenn vorhanden, dann Åbertrage zuerst <size_in> Daten von <data_in> zum DSP
;und hole dann soviele Daten <data_out>, wie in <size_out> erfragt.
;
Dsp_DoBlock:   
;lblE050BA:
               movea.l    (a0)+,a1      ;*data_in
               move.l     (a0)+,d0      ;size_in
               beq        lblE050EA
               subq.w     #1,d0
lblE050D2:     
               btst.b     #TXDE,dsp_irstat        ;Sendregister leer?
               beq.s      lblE050D2

lblE050DA:     
               move.b     (a1)+,dsp_high
               move.b     (a1)+,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d0,lblE050DA

lblE050EA:     
               movea.l    (a0)+,a1      ;*data_out
               move.l     (a0),d0       ;size_out
               beq        lblE0510A
               subq.w     #1,d0
lblE050F2:     
               btst.b     #RXDF,dsp_irstat        ;Empfangsregister gefÅllt?
               beq.s      lblE050F2

lblE050FA:     
               move.b     dsp_high,(a1)+
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d0,lblE050FA
lblE0510A:     
               rts        

;
;Xbios 97
;
;void    Dsp_BlkHandShake(char *data_in,long size_in,char *data_out,long size_out);
;
Dsp_BlkHandShake:         
;lblE0510C:
               movea.l    (a0)+,a1      ;*data_in
               move.l     (a0)+,d0      ;size_in
               beq        lblE0513C
               subq.w     #1,d0
lblE05124:     
               btst.b     #TXDE,dsp_irstat        ;Senderegister leer?
               beq.s      lblE05124

               move.b     (a1)+,dsp_high
               move.b     (a1)+,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d0,lblE05124

lblE0513C:     
               movea.l    (a0)+,a1      ;*data_out
               move.l     (a0),d0       ;size_out
               beq        lblE0515C
               subq.w     #1,d0
lblE05144:     
               btst.b     #RXDF,dsp_irstat        ;Empfangsregister gefÅllt?
               beq.s      lblE05144

               move.b     dsp_high,(a1)+
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d0,lblE05144
lblE0515C:     
               rts        

;
;Xbios 98
;
;void    Dsp_BlkUnpacked(long *data_in,long size_in,long *data_out,long size_out);
;
Dsp_BlkUnpacked:          
;lblE0515E:
               movea.l    (a0)+,a1      ;*data_int
               move.l     (a0)+,d0      ;size_in
               beq        lblE05186
               subq.w     #1,d0
lblE05176:     
               btst.b     #TXDE,dsp_irstat        ;Senderegister leer?
               beq.s      lblE05176
lblE0517E:     
               move.b     (a1)+,dsp_longwd
               move.b     (a1)+,dsp_high
               move.b     (a1)+,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d0,lblE0517E

lblE05186:     
               movea.l    (a0)+,a1      ;*data_out
               move.l     (a0),d0       ;size_out
               beq        lblE0519E
               subq.w     #1,d0
lblE0518E:     
               btst.b     #RXDF,dsp_irstat        ;Empfangsregister gefÅllt?
               beq.s      lblE0518E
lblE05196:     
               move.b     dsp_longwd,(a1)+
               move.b     dsp_high,(a1)+
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d0,lblE05196
lblE0519E:     
               rts        

;
;Xbios 99
;
;void    Dsp_InStream(char *data_in,long block_size,long num_blocks,long *blocks_done);
;
Dsp_InStream:  
;lblE05324:
               move.l     (a0)+,_dsp_tmtbuf_ptr   ;*data_in
               move.l     (a0)+,_dsp_tmtsize      ;block_insize
               move.l     (a0)+,_dsp_num_tmtblks  ;num_blocks
               move.l     (a0),_dsp_tmtblks_done_ptr        ;*blocks_done
               movea.l    _dsp_tmtblks_done_ptr,a0
               clr.l      (a0)          ;0 blocks ready
               move.l     _dsp_tmtsize,d0
               beq        lblE0536E     ;keine Sendedaten vorhanden
               move.l     #DSP_Stream_IR,_int_dsp
               move.b     #$ff,dsp_irvec          ;IR freigeben
               ori.b      #2,dsp_irctrl ;TXDE Request
lblE0536E:     
               rts        

;
;Xbios 100
;
;void    Dsp_OutStream(data_out,block_size,num_blocks,blocks_done);
;
Dsp_OutStream: 
;lblE05370:
               move.l     (a0)+,_dsp_rcvbuf_ptr   ;*data_out
               move.l     (a0)+,_dsp_rcvsize      ;block_outsize
               move.l     (a0)+,_dsp_num_rcvblks  ;num_blocks
               move.l     (a0),_dsp_rcvblks_done_ptr        ;*blocks_done
               movea.l    _dsp_rcvblks_done_ptr,a0
               clr.l      (a0)          ;0 blocks ready
               move.l     _dsp_rcvsize,d0
               beq        lblE053BA     ;sollen Daten abgeholt werden?
               move.l     #DSP_Stream_IR,_int_dsp
               move.b     #$ff,dsp_irvec          ;IR freigeben
               ori.b      #1,dsp_irctrl ;RXDF Request
lblE053BA:     
               rts        

;
;DSP-Interrupt-Routine
;
DSP_Stream_IR: 
;lblE053BC:
               movem.l    d0/a0,-(sp)
               btst.b     #RXDF,dsp_irstat
               beq        lblE05412     ;keine Daten im Empfangspuffer -> Daten zum DSP schicken
               move.l     _dsp_rcvsize,d0
               subq.w     #1,d0
               movea.l    _dsp_rcvbuf_ptr,a0
lblE053D8:     
               move.b     dsp_high,(a0)+
               move.b     dsp_mid,(a0)+
               move.b     dsp_low,(a0)+
               dbf        d0,lblE053D8
               move.l     a0,_dsp_rcvbuf_ptr
               movea.l    _dsp_rcvblks_done_ptr,a0
               addq.l     #1,(a0)
               move.l     (a0),d0
               cmp.l      _dsp_num_rcvblks,d0
               bne        lblE05454
               andi.b     #$fe,dsp_irctrl         ;RXDF Request lîschen
               bra        lblE05454

lblE05412:                ;Daten zum DSP schicken
               move.l     _dsp_tmtsize,d0
               subq.w     #1,d0
               movea.l    _dsp_tmtbuf_ptr,a0
lblE05420:     
               move.b     (a0)+,dsp_high
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               dbf        d0,lblE05420
               move.l     a0,_dsp_tmtbuf_ptr      ;neue Adresse des Sendepuffers
               movea.l    _dsp_tmtblks_done_ptr,a0
               addq.l     #1,(a0)       ;Block abgeschickt
               move.l     (a0),d0
               cmp.l      _dsp_num_tmtblks,d0     ;alle Blîcke abgeschickt?
               bne        lblE05454
               andi.b     #$fd,dsp_irctrl         ;TXDE Request lîschen
lblE05454:     
               movem.l    (sp)+,d0/a0
               rte        

;
;Xbios 101
;
;void    Dsp_IOStream(char *data_in,char *data_out,long block_insize,long block_outsize,
;                                                 long num_blocks,long *blocks_done);
Dsp_IOStream:  
;lblE0523C:
               move.l     (a0)+,_dsp_tmtbuf_ptr   ;*data_in
               move.l     (a0)+,_dsp_rcvbuf_ptr   ;*data_out
               move.l     (a0)+,_dsp_tmtsize      ;block_insize
               move.l     (a0)+,_dsp_rcvsize      ;block_outsize
               move.l     (a0)+,_dsp_num_tmtblks  ;num_blocks
               move.l     (a0),_dsp_tmtblks_done_ptr        ;*blocks_done
               movea.l    _dsp_tmtblks_done_ptr,a0
               clr.l      (a0)          ;0 blocks ready
               move.l     _dsp_tmtsize,d0         ;Grîûe des Blocks
               subq.w     #1,d0
               movea.l    _dsp_tmtbuf_ptr,a0      ;*data_in
lblE05286:     
               move.b     (a0)+,dsp_high          ;ersten Datenblock zum DSP schicken
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               dbf        d0,lblE05286

               move.l     a0,_dsp_tmtbuf_ptr      ;nun 1 Byte hinter erstem Datenblock
               move.l     #DSP_IOStream_IR,_int_dsp
               move.b     #$ff,dsp_irvec
               ori.b      #1,dsp_irctrl
               rts        

;
;DSP-Interrupt-Routine
;
DSP_IOStream_IR:          
;lblE052B2:
               movem.l    d0/a0,-(sp)
               move.l     _dsp_rcvsize,d0         ;block_outsize
               subq.w     #1,d0
               movea.l    _dsp_rcvbuf_ptr,a0      ;*data_out
lblE052C4:     
               move.b     dsp_high,(a0)+          ;ersten Datenblock vom DSP abholen
               move.b     dsp_mid,(a0)+
               move.b     dsp_low,(a0)+
               dbf        d0,lblE052C4

               move.l     a0,_dsp_rcvbuf_ptr      ;nÑchste Adresse fÅr Empfangsdatenblock
               movea.l    _dsp_tmtblks_done_ptr,a0          ;blocks_done erhîhen
               addq.l     #1,(a0)
               move.l     (a0),d0
               cmp.l      _dsp_num_tmtblks,d0     ;==num_blocks?
               bne        lblE052FA
               andi.b     #$fe,dsp_irctrl         ;fertig ->IR disablen
               bra        lblE0531E     ;raus

lblE052FA:     
               move.l     _dsp_tmtsize,d0         ;block_insize
               subq.w     #1,d0
               movea.l    _dsp_tmtbuf_ptr,a0      ;Adresse fÅr Sendepuffer holen
lblE05308:     
               move.b     (a0)+,dsp_high
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               dbf        d0,lblE05308
               move.l     a0,_dsp_tmtbuf_ptr      ;neue Adresse fÅr Sendepuffer merken
lblE0531E:     
               movem.l    (sp)+,d0/a0
               rte        

;
;Xbios 102
;
;void    Dsp_RemoveInterrupts(int mask);
;
Dsp_RemoveInterrupts:     
;lblE0545A:
               move.w     (a0),d0
               not.b      d0
               and.b      d0,dsp_irctrl
               rts        

;
;Xbios 103
;
;int     Dsp_GetWordSize(void);
Dsp_GetWordSize:          
;lblE05466:
               moveq.l    #3,d0
               rts        
;
;Xbios 104
;int     Dsp_Lock(void);
Dsp_Lock:      
;lblE05FE0:
               move.w     _dsp_lock,d0
               bne        lblE05FF4
               moveq.l    #-1,d1
               move.w     d1,_dsp_lock
lblE05FF4:     
               rts        

;
;Xbios 105
;void    Dsp_Unlock(void);
;
Dsp_Unlock:    
;lblE05FF6:
               clr.w      _dsp_lock
               rts        

;
;Xbios 106
;void    Dsp_Available(long *xavailable,long *yavailable);
Dsp_Available: 
;lblE06022:
               movea.l    (a0)+,a1      ;*xavailable
               movea.l    (a0),a0       ;*yavailable
               move.l     #$3eff,(a0)   ;4k - 256 Bytes
               move.l     _dsp_avail_pmem,d0
               subi.l     #$4000,d0
               move.l     d0,(a1)
               rts        

;
;Xbios 107
;int Dsp_Reserve(long xreserve, long yreserve);
;
Dsp_Reserve:   
;lblE06040:
               move.l     (a0)+,d0      ;xreserve
               addi.l     #$4000,d0
               move.l     _dsp_avail_pmem,d1
               cmp.l      d1,d0
               bgt        lblE06074
               move.l     d0,_dsp_xreserve        ;Grîûe des reservierten X-Speichers + $4000
               move.l     (a0),d0       ;yreserve
               cmpi.l     #$3eff,d0
               bgt        lblE06074
               moveq.l    #0,d0
               rts        

lblE06074:     
               moveq.l    #-1,d0
               rts        

;
;Xbios 108
;
;int     Dsp_LoadProg(char *file,int ability,char *buffer);
;
Dsp_LoadProg:  
;lblE05888:
               movea.l    (a0)+,a1      ;char *file
               move.w     (a0)+,d0      ;int ability
               movea.l    (a0),a0       ;char *buffer

               move.l     a0,-(sp)      ;sichern
               move.w     d0,-(sp)      ;sichern

               bsr        _Dsp_LodToBinary        ;liefert <codesize> oder -1 zurÅck, ! a0=codeptr, a1=file !

               move.w     (sp)+,d1      ;abitlity
               movea.l    (sp)+,a0      ;char *codeptr
               tst.l      d0            ;codesize
               ble.s      lblE058C2

               move.w     d1,_dsp_ability
               move.w     d1,-(sp)      ;ability
               move.l     d0,-(sp)      ;codesize
               move.l     a0,-(sp)      ;*codeptr
               movea.l    sp,a0
               bsr        _Dsp_ExecProg
               lea.l      10(sp),sp
               moveq.l    #0,d0
               rts        

lblE058C2:     
               moveq.l    #-1,d0
               rts        
;
;Xbios 109
;void    Dsp_ExecProg(char *codeptr,long codesize,int ability);
;
Dsp_ExecProg:  
;lblE058D4:
               bsr.s      _Dsp_ExecProg
               rts        

_Dsp_ExecProg: 
               move.l     a0,-(sp)      ;sichern

               moveq.l    #71,d0        ;codesize (Anzahl der _DSP-Wîrter_)
               lea.l      lblE48DE2,a0  ;*codeptr fÅr Dsp_ExecBoot
               bsr        _Dsp_ExecBoot

               movea.l    (sp)+,a0
               movea.l    (a0)+,a1      ;codeptr
               move.l     (a0)+,d0      ;codesize
               cmpi.l     #0,d0
               beq        exit_Dsp_Exec
               bsr        tmt_to_DSP

               lea.l      _dsp_codebuf,a1         ;und "interne" exec-Routine anwerfen
               moveq.l    #24,d0        ;24 _DSP-Worte_ senden
               bsr        tmt_to_DSP

               move.w     (a0),_dsp_ability       ;ability merken
exit_Dsp_Exec: 
               rts        

;
; a1.l: Quelle
; d0.w: Anzahl der DSP-Worte
;zerstîrt d0,a1
tmt_to_DSP:    
               subq.w     #1,d0
tmt_req:       
               btst.b     #TXDE,dsp_irstat        ;DSP bereit Sendedaten anzunehmen?
               beq.s      tmt_req

               move.b     (a1)+,dsp_high
               move.b     (a1)+,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d0,tmt_req
               rts        

;
;Xbios 110
;
;void    Dsp_ExecBoot(char *codeptr,long codesize,int ability);
;<ability> wird ignoriert!
;
Dsp_ExecBoot:  
               move.l     4(a0),d0      ;codesize
               movea.l    (a0),a0       ;codeptr
               bsr.s      _Dsp_ExecBoot
               rts        

_Dsp_ExecBoot: 
;               move.w     sr,d2
;               move.w     #$2700,sr
               movem.l    d0-d7/a0-a6,-(sp)
               jsr        dspreset
               movem.l    (sp)+,d0-d7/a0-a6
;               move.w     d2,sr

               move.l     #512,d1       ;Grîûe des interen DSP-Speichers
               sub.l      d0,d1         ;noch verbleibender interner Speicher
               subq.l     #1,d0
lblE05E8A:     
               move.b     (a0)+,dsp_high
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               dbf        d0,lblE05E8A
               tst.l      d1
               beq        lblE05EBC

               subq.l     #1,d1         ;noch verbleibenden freien internen Speicher ausnullen
lblE05EA6:     
               move.b     #0,dsp_high
               move.b     #0,dsp_mid
               move.b     #0,dsp_low
               dbf        d1,lblE05EA6
lblE05EBC:     
               rts        

;
;Xbios 111
;
;long    Dsp_LodToBinary(char *file,char *codeptr);
;
Dsp_LodToBinary:          
               movea.l    (a0)+,a1      ;file
               movea.l    (a0),a0       ;codeptr
               bsr.s      _Dsp_LodToBinary
               rts        

_Dsp_LodToBinary:         
               move.l     a0,-(sp)      ;codeptr sichern

               movea.l    a1,a0         ;*file
               bsr        read_LODfile  ;Datei einlesen, Pufferspeicher allozieren

               movea.l    (sp)+,a1      ;codeptr

               tst.l      d0            ;Pufferadr
               bne.s      lblE0586A
               moveq.l    #-1,d0        ;Pufferadr == 0
               rts        

lblE0586A:     
               movea.l    a0,a2         ;Endadresse des LOD-Files
               movea.l    d0,a0         ;Startadr des LOD-Files
               move.l     a0,-(sp)      ;Pufferadr der LOD-Datei auf den Stack wg. folgendem Mfree
               bsr        conv_LOD_to_bin         ;LOD-Datei konvertieren, a0 = codeptr, liefert BIN-LÑnge in d0 zurÅck
               movea.l    (sp)+,a0
               move.l     d0,-(sp)      ;_dsp_bin_len sichern

               move.l     a0,-(sp)      ;Pufferadr.
               move.w     #$49,-(sp)    ;Mfree
               trap       #GEMDOS
               addq.l     #6,sp         ;Opcode + Pufferadr abrÑumen

               move.l     (sp)+,d0      ;_dsp_bin_len
               divs.w     #3,d0         ;(--> war .l) LÑnge in DSP-Worten
               andi.l     #$ffff,d0     ; NEU !!!
               rts        

;
;Xbios 112
;void    Dsp_TriggerHC(int vector);
;
Dsp_TriggerHC: 
;lblE05FD2:
               move.w     (a0),d0       ;vector
               ori.b      #$80,d0
               move.b     d0,dsp_cmdvec
               rts        

;
;Xbios 113
;int     Dsp_RequestUniqueAbility(void);
;
Dsp_RequestUniqueAbility: 
;lblE0607A:
               move.w     _dsp_uniqueability,d0
               addq.w     #1,d0
               move.w     d0,_dsp_uniqueability
               rts        

;
;Xbios 114
;int     Dsp_GetProgAbility(void);
;
Dsp_GetProgAbility:       
;lblE0608C:
               move.w     _dsp_ability,d0
               rts        

;
;Xbios 115
;void    Dsp_FlushSubroutines(void);
;
Dsp_FlushSubroutines:     
;lblE056B4:
               lea.l      _dsp_subs,a0
               bra.s      lblE056CC

lblE056C2:     
               clr.l      (a0)          ;Adresse lîschen
               clr.w      10(a0)        ;ability lîschen
               adda.w     #12,a0
lblE056CC:     
               cmpa.l     #_dsp_subs+sizeof_subs,a0
               bcs.s      lblE056C2

               move.l     _dsp_max_avail_mem,_dsp_avail_pmem
               clr.w      _dsp_free_subridx
               rts        

;
;Xbios 116
;int     Dsp_LoadSubroutine(char *ptr,long size, int ability);
;
Dsp_LoadSubroutine:       
               movem.l    d5-d7,-(sp)
               movea.l    (a0)+,a1      ;Adresse der Subroutine
               move.l     (a0)+,d0
               move.w     (a0),d1

               move.l     d0,d7         ;size
               move.w     d1,d6         ;ability
               cmpi.l     #1024,d7
               ble.s      lblE05708

               moveq.l    #0,d0         ;Subroutine ist zu groû -> Fehler
               bra        exit_LdSub

lblE05708:     
               move.l     _dsp_xreserve,d0
               add.l      d7,d0
               move.l     _dsp_avail_pmem,d1
               cmp.l      d1,d0
               ble.s      lblE05720

               moveq.l    #0,d0         ;Subroutine ist zu groû
               bra        exit_LdSub

lblE05720:     
               move.w     _dsp_free_subridx,d0
               muls.w     #12,d0
               lea.l      _dsp_subs,a2
               adda.l     d0,a2
               tst.l      (a2)
               beq        DSP_loadsub_entry_free  ;Eintrag ist noch frei

               move.l     (a2),d0       ;Adresse der vorhandenen Subroutine
               subq.l     #1,d0
               move.l     d0,d2
               sub.l      d1,d0

               move.l     d0,-(sp)
               move.l     _dsp_max_avail_mem,-(sp)
               move.l     d2,-(sp)

;3 DSP-Worte im Handshake-Modus zum DSP
               move.b     #$96,dsp_cmdvec         ;Handshake, Hostvektor 22
lblE05EEA:     
               btst.b     #7,dsp_cmdvec
               bne.s      lblE05EEA
               move.b     1(sp),dsp_high
               move.b     2(sp),dsp_mid
               move.b     3(sp),dsp_low

               move.b     5(sp),dsp_high
               move.b     6(sp),dsp_mid
               move.b     7(sp),dsp_low

               move.b     9(sp),dsp_high
               move.b     10(sp),dsp_mid
               move.b     11(sp),dsp_low

               lea.l      $c(sp),sp     ;Stack kor.

               move.w     _dsp_free_subridx,d0
               muls.w     #12,d0
               lea.l      _dsp_subs,a2
               move.l     4(a2,d0.l),d5 ;size
               bra.s      lblE0578E

lblE0577C:     
               add.l      d5,(a2)       ;Grîûe + Startadresse = Endadresse der DSP-Routine
               move.l     (a2),d0       ;Endadresse
               moveq.l    #-$17,d2
               add.w      8(a2),d2      ;Handle beginnen mit $17 (bis $1e)

               muls.w     #6,d2         ;6 Byte pro Eintrag
               lea.l      _dsp_subr_adr,a0
               move.w     d0,4(a0,d2.w) ;Nur Lo- und Mid-Byte eintragen, Hi-Byte ist null
               lea.l      12(a2),a2
lblE0578E:     
               cmpa.l     #_dsp_subs+sizeof_subs,a2
               bcs.s      lblE0577C

               add.l      d5,_dsp_avail_pmem

DSP_loadsub_entry_free:   
               move.l     _dsp_avail_pmem,d1
               sub.l      d7,d1         ;size
               move.l     d1,_dsp_avail_pmem

               lea.l      _dsp_subs,a0
               move.w     _dsp_free_subridx,d2
               muls.w     #12,d2
               adda.l     d2,a0         ;Adresse der Struktur

               addq.l     #1,d1
               move.l     d1,(a0)       ;Adresse
               move.l     d7,4(a0)      ;size
               move.w     d6,$a(a0)     ;Ability

               lea.l      _dsp_subr_adr,a0
               moveq.l    #-$17,d2
               add.w      8(a0),d2      ;Handle
               muls.w     #6,d2         ;6 Byte pro Eintrag
               move.w     d1,4(a0,d2.w) ;3-Byte-Adresse eintragen - Annahme: High-Byte ist null

lblE05F3A:     
               move.b     #$95,dsp_cmdvec         ;Handshake, Hostvektor 21
lblE05F40:     
               btst.b     #7,dsp_cmdvec
               bne.s      lblE05F40

               moveq.l    #0,d0
               move.b     d0,dsp_high
               move.b     d0,dsp_mid
               move.b     #$2e,dsp_low

               move.b     d0,dsp_high
               move.b     d0,dsp_mid
               move.b     #16,dsp_low   ;16 DSP-Worte senden

               moveq.l    #15,d0
; a0 zeigt noch auf _dsp_subr_adr, Tabelle mit Opcodes und Subr-Adr. an DSP Åbertragen
lblE05F74:     
               move.b     (a0)+,dsp_high
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               dbf        d0,lblE05F74

lblE05F2A:     
               move.b     #$95,dsp_cmdvec         ;Handshake, Hostvektor 21
lblE05F30:     
               btst.b     #7,dsp_cmdvec
               bne.s      lblE05F30

               move.w     _dsp_free_subridx,d0
               muls.w     #12,d0
               lea.l      _dsp_subs,a0
               adda.l     d0,a0
               move.l     4(a0),(sp)    ;size
               move.l     (a0),-(sp)    ;Adr
               move.b     1(sp),dsp_high          ;Adresse in DSP schreiben
               move.b     2(sp),dsp_mid
               move.b     3(sp),dsp_low

               move.b     5(sp),dsp_high          ;Grîûe
               move.b     6(sp),dsp_mid
               move.b     7(sp),dsp_low

               move.l     d7,d0         ;size_in
;Register a1 enthÑlt bereits den Zeiger auf die Subroutine
               bsr        tmt_to_DSP

               move.w     _dsp_free_subridx,d6
               addq.w     #1,_dsp_free_subridx
               cmpi.w     #8,_dsp_free_subridx
               blt.s      lblE05834

               clr.w      _dsp_free_subridx
lblE05834:     
               muls.w     #12,d6
               lea.l      _dsp_subs,a0
               move.w     8(a0,d6.l),d0 ;Handle der Subroutine
exit_LdSub:    
               movem.l    (sp)+,d5-d7
               rts        

;
;Xbios 117
;
;int     Dsp_InqSubrAbility(int ability);
;Liefert das Handle oder 0 zurÅck
;
Dsp_InqSubrAbility:       
;lblE06094:
               move.w     (a0),d1       ;ability
               lea.l      _dsp_subs,a0
               moveq.l    #$16,d0       ;$17 ist das erste Handle fÅr eine Subroutine
lblE060A0:     
               addq.w     #1,d0         ;Handle
               cmp.w      10(a0),d1     ;== Handle der Subroutine?
               beq        lblE060BA     ;dann raus

               lea.l      12(a0),a0
               cmpi.w     #$1e,d0       ;max. 30 ist das Handle
               bne.s      lblE060A0
               moveq.l    #0,d0
lblE060BA:     
               rts        

;
;Xbios 118
;
;int     Dsp_RunSubroutine(int handle);
;0: ok, -1: Subroutine konnte nicht ausgefÅhrt werden
;
;Diese Funktion setzt voraus, daû die gesuchte Subroutine bereits geladen ist
;
Dsp_RunSubroutine:        
;lblE05F86:
               move.w     (a0),d0       ;handle
               move.w     d0,d1
               cmpi.b     #$17,d0       ;ungÅltiges Handle?
               blt        lblE05FCC

               cmpi.b     #$1e,d0       ;ungÅltiges Handle?
               bgt        lblE05FCC

               subi.w     #$17,d1
               muls.w     #6,d1         ;6 Byte pro Eintrag
               addq.w     #3,d1         ;erstes DSP-Wort Åberspringen
               lea.l      _dsp_subr_adr,a0
               adda.w     d1,a0
               move.b     (a0)+,dsp_high
               move.b     (a0)+,dsp_mid
               move.b     (a0)+,dsp_low
               ori.b      #$80,d0
               move.b     d0,dsp_cmdvec
               moveq.l    #0,d0
               rts        

lblE05FCC:     
               moveq.l    #-1,d0
               rts        

;
;Xbios 119
;int     Dsp_Hf0(int flag);
;
Dsp_Hf0:       
;lblE060E0:
               move.w     (a0),d1       ;flag
               cmpi.w     #$ffff,d1
               beq        lblE06110     ;Erfragen des Wertes
               cmpi.w     #1,d1
               bne        lblE060FE
               bset.b     #3,dsp_irctrl
               rts        

lblE060FE:     
               tst.w      d1
               bne        lblE06122
               bclr.b     #3,dsp_irctrl
               rts        

lblE06110:     
               moveq.l    #0,d0
               btst.b     #3,dsp_irctrl
               beq        lblE06122
               moveq.l    #1,d0
lblE06122:     
               rts        

;
;Xbios 120
;int     Dsp_Hf1(int flag);
;
Dsp_Hf1:       
;lblE06124:
               move.w     (a0),d1       ;flag
               cmpi.w     #$ffff,d1
               beq        lblE06154

               cmpi.w     #1,d1
               bne        lblE06142
               bset.b     #4,dsp_irctrl
               rts        

lblE06142:     
               tst.w      d1
               bne        lblE06166
               bclr.b     #4,dsp_irctrl
               rts        

lblE06154:     
               moveq.l    #0,d0
               btst.b     #4,dsp_irctrl
               beq        lblE06166
               moveq.l    #1,d0
lblE06166:     
               rts        

;
;Xbios 121
;int     Dsp_Hf2(int flag);
;
Dsp_Hf2:       
;lblE06168:
               moveq.l    #0,d0
               btst.b     #DSP_HF2,dsp_irstat
               beq        lblE0617A
               moveq.l    #1,d0
lblE0617A:     
               rts        

;
;Xbios 122
;int     Dsp_Hf3(int flag);
;
Dsp_Hf3:       
;lblE0617C:
               moveq.l    #0,d0
               btst.b     #DSP_HF3,dsp_irstat
               beq        lblE0618E
               moveq.l    #1,d0
lblE0618E:     
               rts        

;
;Xbios 123
;
;void    Dsp_BlkWords(int *data_in,long size_in,int *data_out,long size_out);
;
Dsp_BlkWords:  
;lblE051A0:
               movea.l    (a0)+,a1      ;*data_in
               move.l     (a0)+,d0      ;size_in
               beq        lblE051CC
               subq.w     #1,d0
lblE051B8:     
               btst.b     #TXDE,dsp_irstat        ;Senderegister leer?
               beq.s      lblE051B8

lblE051C0:     
               move.w     (a1)+,d2
               ext.l      d2
               move.l     a6,-(sp)
               lea.l      dspvlong,a6
               move.l     d2,(a6)
               move.b     (a6)+,dsp_longwd
               move.b     (a6)+,dsp_high
               move.b     (a6)+,dsp_mid
               move.b     (a6)+,dsp_low
               movea.l    (sp)+,a6
               dbf        d0,lblE051C0

lblE051CC:     
               movea.l    (a0)+,a1      ;*data_out
               move.l     (a0),d0       ;size_out
               beq        lblE051E8
               subq.w     #1,d0
lblE051D4:     
               btst.b     #RXDF,dsp_irstat        ;Empfangsregister gefÅllt?
               beq.s      lblE051D4
lblE051DC:     
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d0,lblE051DC
lblE051E8:     
               rts        

;
;Xbios 124
;
;void    Dps_BlkBytes(long *data_in,long size_in,long *data_out,long size_out);
;
Dsp_BlkBytes:  
;lblE051EA:
               movea.l    (a0)+,a1      ;*data_in
               move.l     (a0)+,d0      ;size_in
               beq        lblE0521E
               subq.w     #1,d0
lblE05202:     
               btst.b     #TXDE,dsp_irstat
               beq.s      lblE05202

lblE0520A:     
               move.b     #0,dsp_high
               move.b     #0,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d0,lblE0520A

lblE0521E:     
               movea.l    (a0)+,a1      ;*data_out
               move.l     (a0),d0       ;size_out
               beq        lblE0523A
               subq.w     #1,d0
lblE05226:     
               btst.b     #RXDF,dsp_irstat
               beq.s      lblE05226

lblE0522E:     
               move.b     dsp_mid,d1
               move.b     dsp_low,(a1)+
               dbf        d0,lblE0522E

lblE0523A:     
               rts        

;
;Xbios 125
;char    Dsp_HStat();
;
Dsp_HStat:     
;lblE06190:
               move.b     dsp_irstat,d0
               move.b     dsp_cmdvec,d1
               rts        

;
;Xbios 126
;void    Dsp_SetVectors(void (*receiver)(),long (*transmitter)() );
;
Dsp_SetVectors:           
;lblE0546C:
               clr.l      _dsp_rcv_ptr
               clr.l      _dsp_tmt_ptr
               move.l     (a0)+,d0      ;*receiver
               beq        lblE054A2
               move.l     d0,_dsp_rcv_ptr
               move.l     #DSP_TRM_RCV_IR,_int_dsp
               move.b     #$ff,dsp_irvec
               ori.b      #1,dsp_irctrl ;Enable RXDF Request

lblE054A2:     
               move.l     (a0),d0       ;*transmitter
               beq        lblE054C4
               move.l     d0,_dsp_tmt_ptr
               move.l     #DSP_TRM_RCV_IR,_int_dsp
               move.b     #$ff,dsp_irvec
               ori.b      #2,dsp_irctrl ;Enable TXDE Request
lblE054C4:     
               rts        

;
;DSP-Interrupt-Routine
;
DSP_TRM_RCV_IR:           
;lblE054C6:
               movem.l    d0-d2/a0-a2,-(sp)
               btst.b     #RXDF,dsp_irstat
               beq        lblE054F8
               move.l     _dsp_rcv_ptr,d0
               beq        lblE054F8
               movea.l    d0,a0
               moveq.l    #0,d0
               move.b     dsp_high,d0
               rol.l      #8,d0
               move.b     dsp_mid,d0
               rol.l      #8,d0
               move.b     dsp_low,d0
               move.l     d0,-(sp)
               jsr        (a0)
               addq.l     #4,sp

lblE054F8:     
               btst.b     #TXDE,dsp_irstat        ;DSP bereit Sendedaten anzunehmen?
               beq        lblE05528
               move.l     _dsp_tmt_ptr,d0
               beq        lblE05528     ;keine Senderoutine installiert
               movea.l    d0,a0
               jsr        (a0)
               tst.l      d0
               beq        lblE05528     ;falls != 0L, dann Daten zum DSP schicken
               swap.w     d0
               move.b     d0,dsp_high
               rol.l      #8,d0
               move.b     d0,dsp_mid
               rol.l      #8,d0
               move.b     d0,dsp_low
lblE05528:     
               movem.l    (sp)+,d0-d2/a0-a2
               rte        

;
;Xbios 127
;void    Dsp_MultBlocks(long numsend,long numreceive,DSPBLOCK *sendblocks,DSPBLOCK *receiveblocks);
;
Dsp_MultBlocks:           
;lblE0552E:
               move.l     (a0),d0       ;numsend
               beq        no_sendblks
lblE05536:     
               btst.b     #TXDE,dsp_irstat
               beq.s      lblE05536
               movea.l    8(a0),a2      ;sendblocks
               subq.w     #1,d0

nxt_sendblk:   
               move.w     (a2)+,d1      ;blocktype
               move.l     (a2)+,d2      ;blocksize
               subq.l     #1,d2
               movea.l    (a2)+,a1      ;blockaddr
               tst.w      d1            ;blocktype == LONG?
               beq        lblE05570
               subq.w     #1,d1         ;WORD?
               beq        lblE0557E
               subq.w     #1,d1         ;UBYTE?
               beq        lblE05590
               bra        no_sendblks

lblE05570:     
               move.b     (a1)+,dsp_longwd
               move.b     (a1)+,dsp_high
               move.b     (a1)+,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d2,lblE05570
               dbf        d0,nxt_sendblk
               bra        no_sendblks

lblE0557E:     
               move.w     (a1)+,d1
               ext.l      d1
               move.l     a6,-(sp)
               lea.l      dspvlong,a6
               move.l     d1,(a6)
               move.b     (a6)+,dsp_longwd
               move.b     (a6)+,dsp_high
               move.b     (a6)+,dsp_mid
               move.b     (a6)+,dsp_low
               movea.l    (sp)+,a6
               dbf        d2,lblE0557E
               dbf        d0,nxt_sendblk
               bra        no_sendblks

lblE05590:     
               move.b     #0,dsp_high
               move.b     #0,dsp_mid
               move.b     (a1)+,dsp_low
               dbf        d2,lblE05590
               dbf        d0,nxt_sendblk

no_sendblks:   
               move.l     4(a0),d0      ;num_receive
               beq        lblE05622
lblE055B4:     
               btst.b     #RXDF,dsp_irstat
               beq.s      lblE055B4
               movea.l    12(a0),a0     ;receive_blocks[]
               subq.w     #1,d0

nxt_rcvblk:    
               move.w     (a0)+,d1      ;blocktype
               move.l     (a0)+,d2      ;blocksize
               subq.l     #1,d2
               movea.l    (a0)+,a1      ;blockaddr
               tst.w      d1            ;LONG?
               beq        lblE055EE
               subq.w     #1,d1         ;WORD?
               beq        lblE055FC
               subq.w     #1,d1         ;UBYTE?
               beq        lblE0560E
               bra        lblE05622     ;raus

lblE055EE:     
               move.b     dsp_longwd,(a1)+
               move.b     dsp_high,(a1)+
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d2,lblE055EE
               dbf        d0,nxt_rcvblk
               rts        

lblE055FC:     
               move.b     dsp_mid,(a1)+
               move.b     dsp_low,(a1)+
               dbf        d2,lblE055FC
               dbf        d0,nxt_rcvblk
               rts        

lblE0560E:     
               move.b     dsp_mid,d1
               move.b     dsp_low,(a1)+
               dbf        d2,lblE0560E
               dbf        d0,nxt_rcvblk

lblE05622:     
               rts        

; DSP2----------------------DSP-Supportroutinen-------------------
;
;LÑnge der LOD-Datei Åber Fseek ermitteln (keine DTA notwendig),
;Puffer allozieren und Datei laden
;
;Eingaben
;        a0:     Zeiger auf Dateiname
;
;Ausgabe
;        d0:     Pufferadr oder 0L
;        a0:     LOD-Endadresse
;
read_LODfile:  
               movem.l    d5-d7,-(sp)   ;sichern

               clr.w      -(sp)         ;READ_ONLY
               move.l     a0,-(sp)      ;Zeiger auf den Dateinamen
               move.w     #$3d,-(sp)    ;Fopen
               trap       #GEMDOS
               addq.l     #8,sp
               move.l     d0,d7         ;handle
               bpl.s      get_LOD_len   ;Datei vorhanden
               moveq.l    #0,d0         ;Fehler aufgetreten
               bra.s      exit_read_LODfile

get_LOD_len:   
               move.w     #2,-(sp)      ;ans Dateiende
               move.w     d7,-(sp)      ;handle
               clr.l      -(sp)         ;offset
               move.w     #$42,-(sp)    ;Fseek
               trap       #GEMDOS
               lea.l      10(sp),sp
               move.l     d0,d6         ;DateilÑnge
               bgt.s      seek_LOD_start          ;Datei > 0 Bytes
               moveq.l    #0,d0         ;Fehler aufgetreten
               bra.s      exit_read_LODfile

seek_LOD_start:           
               clr.w      -(sp)         ;an Dateianfang
               move.w     d7,-(sp)      ;handle
               clr.l      -(sp)         ;offset
               move.w     #$42,-(sp)    ;Fseek
               trap       #GEMDOS
               lea.l      10(sp),sp

               move.l     d6,-(sp)      ;DateilÑnge
               move.w     #$48,-(sp)    ;Malloc
               trap       #GEMDOS
               addq.l     #6,sp
               move.l     d0,d5         ;Pufferadresse
               bne.s      _read_LOD
               moveq.l    #0,d0         ;Fehler aufgetreten
               bra.s      exit_read_LODfile

_read_LOD:     
               move.l     d5,-(sp)      ;Puffer
               move.l     d6,-(sp)      ;count
               move.w     d7,-(sp)      ;handle
               move.w     #$3f,-(sp)    ;Fread
               trap       #GEMDOS
               lea.l      12(sp),sp
               cmp.l      d0,d6         ;alle Bytes gelesen?
               beq.s      _close_LOD
               moveq.l    #0,d0         ;Fehler aufgetreten
               bra.s      exit_read_LODfile

_close_LOD:    
               move.w     d7,-(sp)      ;handle
               move.w     #$3e,-(sp)    ;Fclose
               trap       #GEMDOS
               addq.l     #4,sp

               movea.l    d5,a0         ;Pufferadr
               adda.l     d6,a0         ;Puffer + LÑnge = _dsp_LOD_endadr

               move.l     d5,d0         ;Pufferadr != 0: alles ok
exit_read_LODfile:        
               movem.l    (sp)+,d5-d7   ;Register zurÅck
               rts        

;
;LOD-Datei in BinÑrformat konvertieren
;
;Eingaben
;        a0: *LOD-Datei ,aktuelle Dateiposition
;        a1: *codeptr
;        a2: Endadr. des LOD-Files
;
;Ausgabe
;        d0:     _dsp_bin_len
;
conv_LOD_to_bin:          
               move.l     a1,-(sp)      ;_dsp_bin_ptr
               clr.l      -(sp)         ;_dsp_bin_len
               bra.s      lblE05D18

lblE05D02:     
               subq.w     #1,d0         ;Index aus cmp_keyw: SchlÅsselwort 1, DATA?
               bne.s      lblE05D14     ;nein -> Åberspringe Zeile, suche nach SchlÅsselwort ...
               addq.l     #4,a0         ;LÑnge von 'DATA' auf akt. Dateipos.
               move.l     (sp),d0       ;bin_len
               movea.l    4(sp),a1      ;bin_ptr
               bsr        conv_DATA_args          ;wandle Daten hinter DATA-Token, neue Dateiposition in a0
               move.l     d0,(sp)       ;aktuelle LÑnge der DSP-BinÑrdaten
               bra.s      lblE05D20     ;vergleiche mit SchlÅsselworten

lblE05D14:     
               movea.l    a2,a1         ;_dsp_LOD_endadr
               bsr        skip_line     ;Zeilenden ermitteln und Zeile Åberspringen -> neue Pos in a0
lblE05D18:     
               cmpi.b     #'_',(a0)
               bne.s      lblE05D14     ;kein Unterstrich -> nÑchste Zeile
               addq.l     #1,a0         ;aktuelle Dateipos. auf nÑchstes Zeichen

lblE05D20:     
               move.l     a0,-(sp)      ;akt. Dateiposition sichern
               bsr        cmp_keyw      ;Vergleich mit den SchlÅsselworten, aktuelle Dateiposition unverÑndert!
               movea.l    (sp)+,a0
               cmpi.w     #5,d0         ;SchlÅsselwort 5, END?
               bne.s      lblE05D02     ;nein, dann weiter suchen

               move.l     (sp)+,d0      ;_dsp_bin_len
               addq.l     #4,sp
               rts        

;
;Vergleiche ab aktueller Dateiposition mit SchlÅsselwîrtern
;
;Eingabe
;        a0:     Zeiger auf aktuelle Dateiposition
;
;Ausgabe
;        d0: Index (0-5) oder 6 (Fehler)
;zerstîrt a0-a1/d1-d2
;
cmp_keyw:      
               movem.l    d3/a3-a5,-(sp)
               movea.l    a0,a3         ;Zeiger auf aktuelle Dateiposition
               moveq.l    #0,d3
               lea.l      token_adr,a5  ;Tabelle mit Zeigern auf SchlÅsselworte
               lea.l      token_len,a4  ;Tabelle mit LÑngen der SchlÅsselworte
               bra.s      chk_keyw_index

lblE05988:     
               move.w     (a4)+,d0      ;LÑnge des Strings ohne Nullbyte
               movea.l    (a5)+,a1      ;Zeiger auf den String
               movea.l    a3,a0         ;Zeiger auf die aktuelle Zeilenposition
               bsr        strn_cmp      ;vergleiche Zeichen der angegebenen LÑnge
               tst.w      d0            ;Strings gleich?
               bne.s      lblE059AA     ;ja -> raus mit Index in d7 (->d0)

               addq.w     #1,d3         ;Index erhîhen
chk_keyw_index:           
               cmpi.w     #6,d3         ;Index > 5?
               blt.s      lblE05988
lblE059AA:     
               move.l     d3,d0         ;Index des SchlÅsselworts
               movem.l    (sp)+,d3/a3-a5
               rts        

;
;Vergleiche ab aktueller Dateiposition mit SchlÅsselwort der angegebenen LÑnge
;
;Eingaben
;        a0:     Zeiger auf aktuelle Dateiposition
;        a1:     Zeiger auf SchlÅsselwort
;        d0:     LÑnge des SchlÅsselworts (W)
;
;Ausgabe
;        d0: 0 falls Strings unterschiedlich, 1 falls identisch
;zerstîrt a0-a1/d1-d2
;
strn_cmp:      
               bra.s      lblE05940

lblE05926:     
               move.b     (a0)+,d2
               move.b     (a1)+,d1
               cmp.b      d1,d2         ;gleiches Zeichen?
               beq.s      lblE05940
               addi.b     #$20,d1
               cmp.b      d1,d2         ;Zeichen evtl. klein?
               beq.s      lblE05940

               moveq.l    #0,d0         ;unterschiedlicher String
               rts        

lblE05940:     
               subq.w     #1,d0         ;LÑnge dec.
               bpl.s      lblE05926     ;noch nicht alle Zeichen verglichen ...
               moveq.l    #1,d0         ;Strings identisch
               rts        

;
; Suche Zeilenende und Åberspringe diese Zeile
;
;Eingabe
;        a0:     aktuelle Zeilenposition
;        a1:     Endadr. der LOD-Datei
;Ausgabe
;        a0:     neue Dateiposition
;zerstîrt a1
;
skip_line:     
tst_CR:        
               cmpi.b     #13,(a0)+     ;Zeilenende?
               beq.s      tst_endadr
               cmpa.l     a1,a0
               bls.s      tst_CR

tst_endadr:    
               cmpa.l     a1,a0         ;bereits am Dateiende?
               bhi.s      exit_skip_line          ;ja
               addq.l     #1,a0         ;CR/LF Åberspringen
exit_skip_line:           
               rts        

;
;LOD-File: DATA-Instruktion bearbeiten
;                          Speicherbereich erkennen und 4-stellige ASCII-Zahl konvertieren
;
;Eingabe
;        a0:     Zeiger auf Zeichen P/X/Y hinter 'DATA'
;        a1:     Zeiger auf Anfang der DSP-BinÑrdaten
;        a2:     Endadr. des LOD-Files
;        d0:     LÑnge der DSP-BinÑrdaten
;Ausgabe
;        a0:     aktuelle Dateiposition
;        d0:     LÑnge der BinÑrdaten
conv_DATA_args:           
               movem.l    d3-d5/a3,-(sp)
               movea.l    a1,a3
               move.l     d0,d3

_chk_spaces:   
               cmpi.b     #32,(a0)+     ;Leerzeichen?
               beq.s      _chk_spaces   ;Leerzeichen Åberspringen

               move.b     -1(a0),d0     ;Zeichen

               movea.l    a3,a1
               adda.l     d3,a1         ;aktuelle Position
               clr.b      (a1)+
               clr.b      (a1)+

               cmpi.b     #'P',d0       ;Programm-Data?
               bne.s      lblE05ADC

               clr.b      (a1)+
               bra.s      lblE05AFA

lblE05ADC:     
               cmpi.b     #'X',d0       ;X-Mem-Data?
               bne.s      lblE05AEE
               move.b     #1,(a1)+
               bra.s      lblE05AFA

lblE05AEE:     
               move.b     #2,(a1)+      ;dann "muû" es Y-Mem-Data sein ...

lblE05AFA:     

               moveq.l    #4,d0         ;4-stellige ASCII-Zahl ab Dateipos. konvertieren
               addq.l     #1,a0         ;hinter P/X/Y muû ein Leerzeichen stehen, dann die ASCII-Zahl
               bsr        cnv_asci_hex  ;-> Zahl in d0, akt. Pos in a0, a1 unverÑndert!

               clr.b      (a1)+         ;Hi-Byte lîschen
               move.b     d0,1(a1)      ;Lo-Byte eintragen
               asr.w      #8,d0
               move.b     d0,(a1)       ;Mid-Byte eintragen

               addq.l     #6,d3         ;_dsp_bin_len
               move.l     d3,d4         ;Offset zu _dsp_bin_ptr
               clr.w      d5            ;Anzahl der gefunden 6-stelligen Zahlen
               addq.l     #3,d3

               movea.l    a2,a1         ;Endadr. des LOD-Files
               bsr        skip_line     ;aktuelle Dateiposition in a0
               bra.s      lblE05CA0     ;'DATA P/X/Y' konvertieren und zum Anfang der nÑchsten Zeile

lblE05C8A:     
               cmpi.b     #13,(a0)      ;CR?
               bne.s      lblE05C00     ;nein, Leerzeichen Åberspringen, Zahlen konvertieren

               movea.l    a2,a1         ;Endadr. des LOD-Files
               bsr        skip_line
               bra.s      lblE05CA0

lblE05C00:     
               cmpi.b     #32,(a0)+     ;Leerzeichen?
               beq.s      lblE05C00     ;Leerzeichen Åberspringen
               subq.l     #1,a0

               cmpi.b     #13,(a0)      ;CR?
               beq.s      lblE05CA0     ;Zeilenende erreicht

               moveq.l    #6,d0         ;6-stellige ASCII-Zahl in BinÑrdarstellung wandeln
               bsr        cnv_asci_hex  ;-> konvertierte Zahl in d0

               movea.l    a3,a1         ;_dsp_bin_ptr
               addq.l     #3,d3         ;_dsp_bin_len um hinzukommende Bytes erhîhen
               adda.l     d3,a1         ;mit Lo-Byte beginnend eintragen
               move.b     d0,-(a1)      ;Lo-Byte
               lsr.l      #8,d0
               move.b     d0,-(a1)      ;Mid-Byte
               lsr.l      #8,d0
               move.b     d0,-(a1)      ;Hi-Byte
               addq.w     #1,d5         ;Anzahl der eingetragenen 6-stelligen DATA-Werte

lblE05C1C:     
               cmpi.b     #13,(a0)
               bne.s      lblE05C00     ;Zeilenende noch nicht erreicht

lblE05CA0:     
               cmpi.b     #'_',(a0)     ;Unterstrich?
               bne        lblE05C8A     ;kein Unterstrich gefunden

               addq.l     #1,a0         ;nÑchstes Zeichen

               movea.l    a3,a1         ;_dsp_bin_ptr
               adda.l     d4,a1         ;Offset zum Beginn der BinÑrdaten, Anzahld der DATA-Werte eintragen
               clr.b      (a1)+         ;Hi-Byte lîschen
               move.b     d5,1(a1)      ;Lo-Byte eintragen
               lsr.w      #8,d5
               move.b     d5,(a1)       ;Mid-Byte eintragen

               move.l     d3,d0         ;_dsp_bin_len zurÅckliefern
               movem.l    (sp)+,d3-d5/a3
               rts        

;
;Konvertiere Hex-ASCII-Zahl mit 1-8 Ziffern in BinÑrdarstellung
;
;Eingaben
;        a0:     Zeiger auf ASCII-Zahl
;        d0:     Anzahl der Ziffern
;
;Ausgaben
;        d0:     gewandelte Zahl in BinÑrdarstellung
;        a0:     zeigt hinter ASCII-Zahl
;zerstîrt d1-d2
;
cnv_asci_hex:  
               moveq.l    #0,d1         ;lîschen
               bra        cnv_dbra

cnv_loop:      
               lsl.l      #4,d1         ;Platz fÅr die nÑchste Ziffer

               moveq.l    #-'0',d2      ;'0'
               add.b      (a0)+,d2      ;ASCII-Zeichen
               cmpi.b     #'9'-'0',d2   ;Ziffer von '0' bis '9'?
               bls.s      ins_digit

               subi.b     #'A'-'0',d2
               cmpi.b     #'F'-'A',d2   ;Ziffer von 'A' bis 'F'?
               bls.s      ins_cipher

               subi.b     #'a'-'A',d2
               cmpi.b     #'f'-'a',d2   ;Ziffer von 'a' bis 'f'?
               bhi.s      cnv_dbra

ins_cipher:    
               addi.b     #10,d2        ;10 addieren fÅr Bereich a bis f

ins_digit:     
               add.b      d2,d1         ;Ziffer hinzufÅgen

cnv_dbra:      
               dbra       d0,cnv_loop

               move.l     d1,d0         ;der gewandelte BinÑrwert ...
               rts        

;-----------------------------------------
               .EVEN 
tok_strt:      .DC.b 'START',0
tok_data:      .DC.b 'DATA',0
tok_blkdata:   .DC.b 'BLOCKDATA',0
tok_symb:      .DC.b 'SYMBOL',0
tok_comment:   .DC.b 'COMMENT',0
tok_end:       .DC.b 'END',0

               .EVEN 
token_adr:     
;lblE48EE2:
               .DC.l tok_strt
               .DC.l tok_data
               .DC.l tok_blkdata
               .DC.l tok_symb
               .DC.l tok_comment
               .DC.l tok_end

token_len:     
;lblE48EFA:
               .DC.w 5,4,9,6,7,3        ;LÑnge der SchlÅsselworte


               .EVEN 

lblE48B24:                ;246 Bytes = 82 DSP-Worte
               .DC.l $af08000,$400000,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l $bf08000,$7f000bf0,$80007eef
               .DC.l $bf08000,$7edc0bf0,$80007f00
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l $8f4a800,$408f4,$bf000c00
               .DC.l $feb808,$f4a00000,$108f4be
               .DC.l $60,$f400007e,$a9319800
               .DC.l $6d10000,$500aa9,$8000004e
               .DC.l $8586b0c
               .DC.w $5108

               .EVEN 

lblE48C1A:                ;152 DSP-Worte = 456 Bytes
               .DC.l $8f4a000,$108f4,$be000000
               .DC.l $aa98000,$7ead2000,$13084c2b
               .DC.l $45f40000,$32000,$650ea000
               .DC.l $aa98000,$7eb50850,$2b0aa980
lblE48C4A:     
               .DC.l $7eb808,$512b45f4,1
               .DC.l $2000650a,$f0aa007e,$ce45f400
               .DC.w 0
lblE48C64:     
               .DC.l $2200065,$af0aa00,$7ed50af0
               .DC.l $80007ec7,$6d10000,$7ecb0aa9
               .DC.l $80007ec9,$8586b0a,$f080007e
               .DC.l $ad06d100
               .DC.w $7e
lblE48C8E:     
               .DC.l $d20aa980,$7ed008,$58ab0af0
               .DC.l $80007ead,$6d10000,$7ed90aa9
               .DC.l $80007ed7,$858eb0a,$f080007e
               .DC.l $ad08f4a0,$108,$f4be0000
               .DC.l $aa980,$7ee008,$502b0aa9
               .DC.l $80007ee3,$8512b0a,$a980007e
               .DC.l $e608522b,$6d20000,$7eec07d0
               .DC.l $8c07518c,0,$408f4
               .DC.l $a0000001,$8f4be00,$aa9
               .DC.l $80007ef3,$8502b0a,$a980007e
               .DC.l $f608512b,$6d10000,$7efd0aa9
               .DC.l $80007efb,$8586b00
lblE48D1A:     
               .DC.l 0,$408f4a0,$108
               .DC.l $f4be0000,$aa980,$7f0420
               .DC.l $13084c,$2b45f400,$120
               .DC.l $650af0,$aa007f23,$45f40000
               .DC.l $22000,$650af0aa,$7f320a
               .DC.l $f080007f
lblE48D5A:     
               .DC.l $140aa980,$7f1408,$502b0aa9
               .DC.l $80007f17,$8512b06,$d100007f
               .DC.l $2007d88c,$aa98100,$7f1d5470
               .DC.l $ffeb,0,$40aa9
               .DC.l $80007f23,$8502b0a,$a980007f
               .DC.l $2608512b,$6d10000,$7f2f54d8
               .DC.l $aa981,$7f2c54,$700000ff
               .DC.l $eb000000,$40a,$a980007f
               .DC.l $3208502b,$aa98000,$7f350851
               .DC.l $2b06d100,$7f3e5c,$d8000aa9
               .DC.l $81007f3b,$54700000,$ffeb0000
               .DC.l 4


lblE48DE2:                ;213 Bytes = 71 DSP-Worte
               .DC.l $af08000,$400000,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l 0,0,0
               .DC.l $8f4a800,$408f4,$bf000c00
               .DC.l $feb80a,$f080007e
               .DC.b $a9


               .EVEN 

lblE48F06:                ;72 Bytes = 24 DSP-Worte
               .DC.l 0,$2a0000,$140bf080
               .DC.l $7eef0b,$f080007e,$dc0bf080
               .DC.l $7f000b,$f0800000,$bf080
               .DC.l $b,$f0800000,$bf080
               .DC.l $b,$f0800000,$bf080
               .DC.l $b,$f0800000,3

; DSP3----------------------DSP-BOOT-Routine-------------------

;INIT-Routine fÅr die DSP-Routinen
dsp_stdinit:   
;lblE05624:
               lea.l      _dsp_codebuf,a0
               lea.l      lblE48F06,a1  ;DSP-Code der internen dspexec-Routine
               moveq.l    #71,d0        ;3*24 Bytes = 24 DSP-Worte in Puffer schreiben
lblE061AA:     
               move.b     (a1)+,(a0)+
               dbf        d0,lblE061AA

               moveq.l    #$17,d0
               lea.l      _dsp_subs,a0  ;Array mit SUBS-Strukturen
               bra.s      lblE05650

lblE0563A:     
               clr.l      (a0)          ;Adresse
               clr.w      10(a0)        ;Ability
               move.w     d0,8(a0)      ;Handle?
               addq.w     #1,d0
               lea.l      12(a0),a0     ;12 Bytes pro Eintrag

lblE05650:                ;Ende des Arrays mit Subroutine-EintrÑgen erreicht?
               cmpa.l     #_dsp_subs+sizeof_subs,a0
               bcs.s      lblE0563A

               move.l     #$7ea8,d0
               move.l     d0,_dsp_max_avail_mem
               move.l     d0,_dsp_avail_pmem
               clr.l      _dsp_xreserve
               clr.w      _dsp_ability
               clr.w      _dsp_free_subridx
               move.w     #$8000,_dsp_uniqueability

               moveq.l    #82,d0        ;codesize (DSP-Wîrter)
               lea.l      lblE48B24,a0  ;*codeptr
               bsr        _Dsp_ExecBoot

               move.w     #152,d0       ;size_in
               lea.l      lblE48C1A,a1  ;*data_in
               bsr        tmt_to_DSP
               rts        
; ----------------------XBIOS-Routinen-------------------

makecjar:      movea.l    cjar,a1
               lea.l      newcjar,a0
               tst.l      d0
               beq.s      mknocopy
               add.l      d0,d0
               cmpi.l     #90,d0
               bgt.s      mkcerr
               subq.l     #1,d0
mkcjar2:       move.l     (a1)+,(a0)+
               dbra       d0,mkcjar2
mknocopy:      move.l     #0,(a0)+
               move.l     #51,(a0)+
               lea.l      newcjar,a1
               move.l     a1,d0
               move.l     d0,cjar
               clr.l      d0
               rts        
mkcerr:        move.l     #-1,d0
               rts        

winrec:        lea.l      prgemul,a2
               move.w     (a0)+,d7      ; Winrec-Emulationsmode
               tst.w      d7
               beq.s      del_winrec
               move.w     (a2),d7
               bset       #1,d7
               move.w     d7,(a2)
               bsr        ncookies
               bsr        cookie
               rts        
del_winrec:    move.w     (a2),d7
               bclr       #1,d7
               move.w     d7,(a2)
               bsr        ncookies
               bsr        cookie
               rts        

startup_exit:  move.l     (a0)+,startupmem        ; memory
               rts        

startupmex:    move.l     startupmem(pc),-(sp)
               move.w     #73,-(sp)
               trap       #1
               addq.l     #6,sp
               bsr        initregs
               rts        

ncookies:      lea.l      ncooksnd,a4
               move.l     #$1d,(a4)     ; war $1f(1d)
               lea.l      ncookmch,a4
               move.l     #$30000,(a4)  ; war $30000
               lea.l      ncookcpu,a4
               move.l     #$1e,(a4)     ; war $1e
               lea.l      ncookvdo,a4
               move.l     #$30000,(a4)  ; war $30000
               lea.l      ncookfpu,a4
               move.l     #0,(a4)       ; war $0
               rts        

ocookies:      lea.l      cooksnd,a3
               lea.l      ncooksnd,a4
               move.l     (a3),(a4)
               lea.l      cookmch,a3
               lea.l      ncookmch,a4
               move.l     (a3),(a4)
               lea.l      cookcpu,a3
               lea.l      ncookcpu,a4
               move.l     (a3),(a4)
               lea.l      cookvdo,a3
               lea.l      ncookvdo,a4
               move.l     (a3),(a4)
               lea.l      cookfpu,a3
               lea.l      ncookfpu,a4
               move.l     (a3),(a4)
               rts        

cookie:        tst.l      cjar
               beq        ncookt5
               movea.l    cjar,a1
ncookt1:       move.l     (a1)+,d1
               move.l     (a1)+,d2
               tst.l      d1
               beq        ncookt5
               cmpi.l     #"_SND",d1
               bne.s      ncookt1b
               lea.l      ncooksnd,a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1b:      move.w     prgemul,d3
               btst       #1,d3
               beq.s      ncookt1f
               cmpi.l     #"_MCH",d1
               bne.s      ncookt1f
               lea.l      ncookmch,a4
               move.l     (a4),d2
               suba.l     #4,a1
               move.l     d2,(a1)+
ncookt1f:      bra        ncookt1
ncookt5:       rts        

pbrktst:       movem.l    d1-d7/a0-a4,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a4
               rts        

pluginit:      bsr        initplugp
               bsr        initplugr
               rts        

monitor:       move.l     #lfifo,d0
               lsr.w      #3,d0
               btst       #0,modr24
               beq.s      monito2
               lsr.w      #1,d0
monito2:       subq.l     #1,d0
               movea.l    d0,a4         ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
               clr.l      dummy
               lea.l      vmestart,a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0
               adda.l     #$ff,a1
               movea.l    a1,a2
               addq.l     #1,a2         ; Playread a2,A1=0
               movea.l    a2,a3
               addq.l     #2,a3         ; Playread a3,A1=1
               moveq.l    #8,d2
fifowait:      move.b     (a0),d0       ; PLAY-FIFO halbleer ?
               andi.b     #2,d0
               bne.s      mcopy         ; wenn ja, halben RECFIFO in PLAYFIFO kopieren
               bsr        mbrktst       ; dann abbruch testen
               tst.w      d0
               bne        mweg
               bra.s      fifowait
mcopy:         move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
               btst       #0,modr24
               bne        mcopy24
mcopy2:        move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      mcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      mcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      mcopy3        ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloscht ?)...
               btst       d2,d4
               bne.s      mcopy3        ; fehlerhafte Daten ?
               tst.w      pluglistr
               bne.s      mouseplug
               tst.w      pluglistp
               bne.s      mouseplug
               move.b     d7,(a3)
               move.b     d6,(a3)
               move.b     d5,(a2)
               move.b     d4,(a2)
               bra.s      mcopy3
mouseplug:     move.b     d7,dummy
               move.b     d6,dummy+1
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.b     d5,dummy
               move.b     d4,dummy+1
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bsr        workplugsr    ; rec-plugins aufrufen
               bsr        workplugsp    ; play-plugins aufrufen
               move.b     6(sp),(a3)    ; Linker Kanal,HighByte senden,A1=1
               move.b     7(sp),(a3)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(sp),(a2)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(sp),(a2)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #8,sp
mcopy3:        dbra       d0,mcopy2
               bra        mcopy4
mcopy24:       move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        mcopy24b      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq        mcopy24b      ; fehlerhafte Daten ?
               move.w     (a1),d3       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d3
               beq        mcopy24b      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      mcopy24b      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloscht ?)...
               btst       d2,d4
               bne.s      mcopy24b      ; fehlerhafte Daten ?
               move.w     (a1),d1       ; Low-Byte,Rechter Kanal (Bit 8 geloscht ?)...
               btst       d2,d1
               bne.s      mcopy24b      ; fehlerhafte Daten ?
               tst.w      pluglistr
               bne.s      mouseplug2
               tst.w      pluglistp
               bne.s      mouseplug2
               move.b     d7,(a3)       ; Linker Kanal,Highbyte senden,A1=1
               move.b     d6,(a3)       ; Linker Kanal,Lowbyte senden,A1=1
               move.b     d3,(a3)       ; Linker Kanal,Lowbyte senden,A1=1
               move.b     d5,(a2)       ; Rechter Kanal,Highbyte senden,A1=0
               move.b     d4,(a2)       ; Rechter Kanal,Lowbyte senden,A1=0
               move.b     d1,(a2)       ; Rechter Kanal,Lowbyte senden,A1=0
               bra.s      mcopy24b
mouseplug2:    move.b     d7,dummy+1
               move.b     d6,dummy+2
               move.b     d3,dummy+3
               move.l     dummy,-(sp)   ; linken Kanal holen
               move.b     d5,dummy+1
               move.b     d4,dummy+2
               move.b     d1,dummy+3
               move.l     dummy,-(sp)   ; rechten Kanal holen
               bsr        workplugsr    ; rec-plugins aufrufen
               bsr        workplugsp    ; play-plugins aufrufen
               move.b     5(sp),(a3)    ; Linker Kanal,HighByte senden,A1=1
               move.b     6(sp),(a3)    ; Linker Kanal,MidByte senden,A1=1
               move.b     7(sp),(a3)    ; Linker Kanal,LowByte senden,A1=1
               move.b     1(sp),(a2)    ; Linker Kanal,HighByte senden,A1=0
               move.b     2(sp),(a2)    ; Linker Kanal,MidByte senden,A1=0
               move.b     3(sp),(a2)    ; Linker Kanal,LowByte senden,A1=0
               addq.l     #8,sp
mcopy24b:      dbra       d0,mcopy24
mcopy4:        bsr        mbrktst       ; abbruch testen
               tst.w      d0
               bne.s      mweg
               bra        fifowait
mweg:          clr.l      d0
               rts        
mbrktst:       movem.l    d1-d7/a0-a4,-(sp)
               move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               movem.l    (sp)+,d1-d7/a0-a4
               rts        

recwait:       move.l     (a0)+,d7      ; treshold
               lea.l      vmestart,a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0
               adda.l     #$ff,a1       ; REC-Read im Wordmode
rwanf1:        move.b     (a0),d0       ; Flag lesen
               btst       #1,d0         ; FIFO mehr als halbvoll ?
               beq.s      rwanf2        ; wenn ja, daten einlesen
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #11,-(sp)
               trap       #1
               addq.l     #2,sp
               movem.l    (sp)+,d1-d7/a0-a6
               tst.l      d0
               bne        rwweg
               bra.s      rwanf1
rwanf2:        moveq.l    #8,d6
               moveq.l    #$ff,d5
               moveq.l    #0,d4
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #11,-(sp)
               trap       #1
               addq.l     #2,sp
               movem.l    (sp)+,d1-d7/a0-a6
               tst.l      d0
               bne        rwweg
rwanf4:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf4
               move.w     (a1),d1       ; wenn 0, weiter
               btst       d6,d1
               bne.s      rwanf4
               and.l      d5,d1
               lsl.l      d6,d1
rwanf5:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf5
               move.w     (a1),d2       ; wenn 0, weiter
               btst       d6,d2
               bne.s      rwanf4
               move.b     d2,d1
               btst       #0,modr24
               bne.s      rwanf6
               lsl.l      d6,d1
rwanf5b:       move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf5b
               move.w     (a1),d2       ; wenn 0, weiter
               btst       d6,d2
               bne.s      rwanf4
               move.b     d2,d1
rwanf6:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf6
               move.w     (a1),d2       ; wenn 1, weiter
               btst       d6,d2
               beq.s      rwanf4
               and.l      d5,d2
               lsl.l      d6,d2
rwanf7:        move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf7
               move.w     (a1),d3       ; wenn 1, weiter
               btst       d6,d3
               beq.s      rwanf4
               move.b     d3,d2
               btst       #0,modr24
               beq.s      rwanf8
               lsl.l      d6,d2
rwanf7b:       move.b     (a0),d0       ; Flag lesen,FIFO leer ?
               btst       d4,d0
               beq.s      rwanf7b
               move.w     (a1),d3       ; wenn 1, weiter
               btst       d6,d3
               beq.s      rwanf4
               move.b     d3,d2
               btst       #23,d1        ; Oberstes Bit da ?
               beq.s      rweiter24     ; dann negieren
               ori.l      #$ff000000,d1
               not.l      d1
rweiter24:     btst       #23,d2
               beq.s      rweiter2
               ori.l      #$ff000000,d2
               not.l      d2
               bra.s      rweiter2
rwanf8:        andi.l     #$ffff,d1
               btst       #15,d1        ; Oberstes Bit da ?
               beq.s      rweiter1      ; dann negieren
               ori.l      #$ffff0000,d1
               not.l      d1
rweiter1:      andi.l     #$ffff,d2
               btst       #15,d2
               beq.s      rweiter2
               ori.l      #$ffff0000,d2
               not.l      d2
rweiter2:      cmp.l      d7,d1         ; treshold vergleichen
               bgt.s      rwweg
               cmp.l      d7,d2
               bgt.s      rwweg
               move.b     (a0),d0       ; Flag lesen
               btst       #1,d0         ; FIFO mehr als halbvoll ?
               beq        rwanf4        ; wenn ja, daten einlesen
               bra        rwanf1
rwweg:         clr.l      d0
               rts        

aimemplay24:   lea.l      pimode(pc),a2
               move.l     #19,(a2)
aimemplay24b:  lea.l      von(pc),a2
               move.l     (a0)+,d2      ; von a3
               move.l     d2,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      bis(pc),a2
               move.l     (a0)+,d3      ; bis d1
               move.l     d3,(a2)       ; bis d1
               lea.l      bbis(pc),a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               clr.l      d4
               move.w     (a0)+,d4      ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      nomidi24
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
nomidi24:      lea.l      step(pc),a2
               tst.w      d4
               blt        imemperr24
               move.l     d2,d0
               sub.l      d3,d0
               tst.l      d0
               beq        imemperr24
               ble.s      impneg24
               addi.w     #1,d4
               mulu.w     #6,d4
               andi.l     #$ffff,d4
               moveq.l    #0,d2
               sub.l      d4,d2
               move.l     d2,d4
               subq.l     #6,d4
               bra.s      impplus24
impneg24:      mulu.w     #6,d4
               andi.l     #$ffff,d4
impplus24:     move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #4,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; dividiert durch 2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               bsr        initplugp
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        
imemperr24:    move.l     #-1,d0
               rts        

aidspplay:     lea.l      dvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      dbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      dbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      dbbis(pc),a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      dplaybyte(pc),a4        ; RÅckgabewerte-Liste
               move.l     (a0)+,24(a4)  ; Anfang Playzaehler
               lea.l      dstep(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      dmode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      dfifo(pc),a2
               move.l     #$7ff,(a2)    ; dspbuffer 8192Byte (/4=$7FF)
               btst       #2,d0
               beq.s      nodspmidi
               lea.l      dmidisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
nodspmidi:     lea.l      dmidiw(pc),a2
               move.l     #0,(a2)
               lea.l      dloop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      dcrosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      drimode(pc),a2
               move.l     #0,(a2)
               lea.l      dpimode(pc),a2
               move.l     #13,(a2)
               move.l     a4,d0
               rts        

init_mplaypeak:           
               move.w     (a0)+,d0      ; Auswahl
               lea.l      pimode,a2
               move.l     #31,(a2)
               tst.w      d0
               beq.s      aimempl2
               move.l     #32,(a2)
               cmpi.w     #2,d0
               beq        aimemplay24b
               rts        

init_imemplay: move.w     (a0)+,d0      ; Auswahl
               tst.w      d0
               beq.s      aimemplay
               cmpi.w     #1,d0
               beq        aidspplay
               cmpi.w     #2,d0
               beq        aimemplay24
               cmpi.w     #99,d0
               beq.s      aimemstart
               rts        
aimemstart:    lea.l      pimode,a2
               move.l     #35,(a2)
               bra.s      aimempl2
aimemplay:     lea.l      pimode,a2
               move.l     #1,(a2)
aimempl2:      lea.l      von,a2
               move.l     (a0)+,d2      ; von a3
               move.l     d2,(a2)       ; von a3
               lea.l      bvon,a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      bis,a2
               move.l     (a0)+,d3      ; bis d1
               move.l     d3,(a2)       ; bis d1
               lea.l      bbis,a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      playbyte,a4   ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               clr.l      d4
               move.w     (a0)+,d4      ; Anzahl der For/Backstep d4
               lea.l      mode,a2
               move.w     (a0)+,d0
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      imnmidi
               lea.l      midisuch,a2
               move.w     (a0)+,(a2)    ; midi d0
imnmidi:       lea.l      step,a2
               tst.w      d4
               blt        imemperrs
               move.l     d2,d0
               sub.l      d3,d0
               tst.l      d0
               beq        imemperrs
               ble.s      impneg8
               moveq.l    #0,d2
               addq.l     #1,d4
               sub.l      d4,d2
               move.l     d2,d4
               add.l      d4,d4
               add.l      d4,d4
               addi.l     #-4,d4
               bra.s      impplus
impneg8:       add.l      d4,d4
               add.l      d4,d4
impplus:       move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo,a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw,a2
               move.l     #0,(a2)
               lea.l      loop,a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag,a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      playbyte,a4   ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; mempos lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,60(a4)     ; wenn 1, dann neue start und endpos
               lea.l      bvon,a3
               move.l     (a3),64(a4)   ; startpos fÅr compare retten
               lea.l      bbis,a3
               move.l     (a3),68(a4)   ; endpos fÅr compare retten
               bsr        initplugp
               lea.l      playbyte,a4   ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        
imemperrs:     move.l     #-1,d0
               rts        

initplugp:     lea.l      pluglistp(pc),a1
               lea.l      plugs(pc),a2
iniplug1:      move.w     (a1)+,d0      ; plugin-nummer
               tst.w      d0
               beq.s      iniplgend1
               subq.w     #1,d0
               mulu.w     #24,d0
               movea.l    4(a2,d0.w),a3
               jsr        (a3)          ; plugin init aufrufen
               bra.s      iniplug1
iniplgend1:    rts        

initplugr:     lea.l      pluglistr(pc),a1
               lea.l      plugs(pc),a2
iniplug2:      move.w     (a1)+,d0      ; plugin-nummer
               tst.w      d0
               beq.s      iniplgend2
               subq.w     #1,d0
               mulu.w     #24,d0
               movea.l    4(a2,d0.w),a3
               jsr        (a3)          ; plugin init aufrufen
               bra.s      iniplug2
iniplgend2:    rts        

imemplay:      lea.l      von,a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis,a2
               move.l     (a2),d1       ; bis d1
               lea.l      step,a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode,a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo,a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      vmestart,a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte,a6   ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq        ip_back
ipfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrleer
               move.l     strtp,d0
               cmp.l      24(a6),d0
               beq.s      nowrleer
               addi.l     #1,12(a6)     ;Fehler +1
nowrleer:      move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      ipcopyanf
               bra.s      ipfill
ipcopyanf:     tst.l      d4
               blt        ipcopyneg
               cmpa.l     d1,a2
               bge        iplayend
               move.w     d2,d5         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopy:        tst.w      pluglistp
               bne.s      ipuseplug
               btst       #0,playch
               bne.s      imemputl0
               move.b     #0,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a5)       ; Linker Kanal,LowByte senden,A1=1
               addq.l     #2,a2
               bra.s      imemputl0b
imemputl0:     move.b     (a2)+,(a5)
               move.b     (a2)+,(a5)
imemputl0b:    btst       #1,playch
               bne.s      imemputl0c
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               addq.l     #2,a2
               bra.s      imemputr3
imemputl0c:    move.b     (a2)+,(a1)
               move.b     (a2)+,(a1)
               bra.s      imemputr3
ipuseplug:     move.w     (a2)+,-(sp)
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.w     (a2)+,-(sp)
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bsr        workplugsp    ; plugins aufrufen
               btst       #0,playch
               bne.s      imemputl
               move.b     #0,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a5)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      imemputl2
imemputl:      move.b     6(sp),(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     7(sp),(a5)    ; Linker Kanal,LowByte senden,A1=1
imemputl2:     btst       #1,playch
               bne.s      imemputr
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      imemputr2
imemputr:      move.b     2(sp),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(sp),(a1)    ; Rechter Kanal,LowByte senden,A1=0
imemputr2:     addq.l     #8,sp
imemputr3:     addq.l     #4,24(a6)     ; Playposition
               btst       #2,d3         ; midi ?
               beq.s      ipcopy1b
               bsr        midioff
               tst.w      d0
               bne        iendplay1b
ipcopy1b:      cmpa.l     d1,a2
               bge        iplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d5,ipcopy
               bra        ip_back
ipcopyneg:     cmpa.l     d1,a2
               ble        iplayend
               move.w     d2,d5         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopy2:       tst.w      pluglistp
               bne.s      ipuseplug2
               btst       #0,playch
               bne.s      imemputlb0
               move.b     #0,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a5)       ; Linker Kanal,LowByte senden,A1=1
               addq.l     #2,a2
               bra.s      imemputlb0b
imemputlb0:    move.b     (a2)+,(a5)
               move.b     (a2)+,(a5)
imemputlb0b:   btst       #1,playch
               bne.s      imemputlb0c
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               addq.l     #2,a2
               bra.s      imemputr3b
imemputlb0c:   move.b     (a2)+,(a1)
               move.b     (a2)+,(a1)
               bra.s      imemputr3b
ipuseplug2:    move.w     (a2)+,-(sp)
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.w     (a2)+,-(sp)
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bsr        workplugsp    ; plugins aufrufen
               btst       #0,playch
               bne.s      imemputlb
               move.b     #0,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a5)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      imemputl2b
imemputlb:     move.b     6(sp),(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     7(sp),(a5)    ; Linker Kanal,LowByte senden,A1=1
imemputl2b:    btst       #1,playch
               bne.s      imemputrb
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      imemputr2b
imemputrb:     move.b     2(sp),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(sp),(a1)    ; Rechter Kanal,LowByte senden,A1=0
imemputr2b:    addq.l     #8,sp
imemputr3b:    addq.l     #4,24(a6)     ; Playposition
               btst       #2,d3         ; midi ?
               beq.s      ipcopy2b
               bsr        midioff
               tst.w      d0
               bne        iendplay1b
ipcopy2b:      cmpa.l     d1,a2
               ble.s      iplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d5,ipcopy2
ip_back:       lea.l      von,a4
               move.l     a2,(a4)       ; Playposition retten
ip_back2:      lea.l      playbyte,a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplayend:      moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte,a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      loop,a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von,a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #1,d3         ; crossplay ?
               beq        iplooptst     ; wenn nein, ueberspringen
               lea.l      crosflag,a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      baktofor
fortobak:      addq.l     #8,d4
               neg.l      d4
               lea.l      step,a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von,a4
               move.l     d1,(a4)       ; neue Endposition
               lea.l      bvon,a4
               move.l     (a4),d1
               addq.l     #4,d1
               lea.l      bis,a4
               move.l     d1,(a4)       ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra.s      ip_back2
baktofor:      neg.l      d4
               subq.l     #8,d4
               lea.l      step,a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von,a4
               move.l     d1,(a4)       ; neue Anfangsposition
               lea.l      bbis,a4
               lea.l      bis,a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        ip_back2
iendplay:      lea.l      playbyte,a4
               tst.l      60(a4)        ; wenn 1, dann neue start und endpos
               beq.s      iendplay1b
               lea.l      von,a3
               move.l     64(a4),(a3)   ; startpos fÅr compare retten
               lea.l      bis,a3
               move.l     68(a4),(a3)   ; endpos fÅr compare retten
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     #0,60(a4)     ; cuewerteÅbernommen-Flag
               bra.s      iendplay1c
iendplay1b:    lea.l      playbyte,a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
iendplay1c:    cmpi.l     #35,pimode
               bne.s      iendplay2
               bsr        startupmex
iendplay2:     movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplooptst:     btst       #0,d3
               beq.s      iendplay
               lea.l      von,a4
               lea.l      bvon,a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        ip_back2

imempeakp:     movea.l    von,a2        ; von a2
               move.l     bis,d1        ; bis d1
               move.l     step,d4       ; Anzahl der For/Backstep d4
               move.w     mode,d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.l     fifo,d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               movea.l    vmestart,a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               lea.l      playbyte,a4   ; RÅckgabewerte-Liste
               movea.l    16(a4),a6     ; Peak-RÅckgabewert holen
               cmpa.l     d1,a2
               beq        ip_backp
ipfillp:       move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrleerp
               move.l     strtp,d0
               cmp.l      24(a4),d0
               beq.s      nowrleerp
               addq.l     #1,12(a4)     ;Fehler +1
nowrleerp:     move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               beq.s      ipfillp
ipcopyanfp:    tst.l      d4
               blt        ipcopynegp    ; rÅckwÑrts ?
               cmpa.l     d1,a2
               bge        iplayendp
               move.w     d2,d5         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopyp:       tst.w      pluglistp     ; plugins ?
               bne.s      ipkuseplug
ipcopypf:      movem.l    d1/d4-d6,-(sp)
               move.b     playch,d1
               move.b     (a2)+,d7      ; vorwÑrts ohne plugins
               move.b     (a2)+,d6
               move.b     (a2)+,d5
               move.b     (a2)+,d4
               btst       #0,d1
               bne.s      ipkputl0
               move.b     #0,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a5)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      ipkputl0b
ipkputl0:      move.b     d7,(a5)
               move.b     d6,(a5)
ipkputl0b:     btst       #1,d1
               bne.s      ipkputl0c
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      ipkputl0d
ipkputl0c:     move.b     d5,(a1)
               move.b     d4,(a1)
ipkputl0d:     bsr        ppeakcmps
               movem.l    (sp)+,d1/d4-d6
               addq.l     #4,24(a4)     ; Playposition
               btst       #2,d3         ; midi ?
               beq.s      ipcopyp1bf
               bsr        midioff
               tst.w      d0
               bne        iendplayp1b
ipcopyp1bf:    cmpa.l     d1,a2
               bge        iplayendp
               adda.l     d4,a2
               add.l      d4,24(a4)     ; Playposition
               dbra       d5,ipcopypf
               bra        ip_backp

ipkuseplug:    movem.l    d4-d6,-(sp)
               move.w     (a2),-(sp)    ; vorwÑrts mit plugins
               move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.w     (a2),-(sp)
               move.b     (a2)+,d5
               move.b     (a2)+,d4
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bsr        ppeakcmp
               bsr        workplugsp    ; plugins aufrufen
               btst       #0,playch
               bne.s      imempkl
               move.b     #0,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a5)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      imempkl2
imempkl:       move.b     6(sp),(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     7(sp),(a5)    ; Linker Kanal,LowByte senden,A1=1
imempkl2:      btst       #1,playch
               bne.s      imempkr
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      imempkr2
imempkr:       move.b     2(sp),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(sp),(a1)    ; Rechter Kanal,LowByte senden,A1=0
imempkr2:      addq.l     #8,sp
imempkr3:      movem.l    (sp)+,d4-d6
               addq.l     #4,24(a4)     ; Playposition
               btst       #2,d3         ; midi ?
               beq.s      ipcopyp1b
               bsr        midioff
               tst.w      d0
               bne        iendplayp1b
ipcopyp1b:     cmpa.l     d1,a2
               bge        iplayendp
               adda.l     d4,a2
               add.l      d4,24(a4)     ; Playposition
               dbra       d5,ipkuseplug
               bra        ip_backp
ipcopynegp:    cmpa.l     d1,a2
               ble        iplayendp
               move.w     d2,d5         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopyp2:      tst.w      pluglistp
               bne.s      ipkuseplug2
ipcopyp2b:     movem.l    d1/d4-d6,-(sp)          ; rÅckwÑrts ohne plugins
               move.b     playch,d1
               move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.b     (a2)+,d5
               move.b     (a2)+,d4
               btst       #0,d1
               bne.s      ipkputlb0
               move.b     #0,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a5)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      ipkputlb0b
ipkputlb0:     move.b     d7,(a5)
               move.b     d6,(a5)
ipkputlb0b:    btst       #1,d1
               bne.s      ipkputlb0c
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      ipkputlb0d
ipkputlb0c:    move.b     d5,(a1)
               move.b     d4,(a1)
ipkputlb0d:    bsr        ppeakcmps
               movem.l    (sp)+,d1/d4-d6
               addq.l     #4,24(a4)     ; Playposition
               btst       #2,d3         ; midi ?
               beq.s      ipcopyp2bn
               bsr        midioff
               tst.w      d0
               bne        iendplayp1b
ipcopyp2bn:    cmpa.l     d1,a2
               ble        iplayendp
               adda.l     d4,a2
               add.l      d4,24(a4)     ; Playposition
               dbra       d5,ipcopyp2b
               bra        ip_backp
ipkuseplug2:   movem.l    d4-d6,-(sp)
               move.w     (a2),-(sp)    ; rÅckwÑrts mit plugins
               move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.w     (a2),-(sp)
               move.b     (a2)+,d5
               move.b     (a2)+,d4
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bsr        ppeakcmp
               bsr        workplugsp    ; plugins aufrufen
               btst       #0,playch
               bne.s      imempklb
               move.b     #0,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a5)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      imempkl2b
imempklb:      move.b     6(sp),(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     7(sp),(a5)    ; Linker Kanal,LowByte senden,A1=1
imempkl2b:     btst       #1,playch
               bne.s      imempkrb
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      imempkr2b
imempkrb:      move.b     2(sp),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(sp),(a1)    ; Rechter Kanal,LowByte senden,A1=0
imempkr2b:     addq.l     #8,sp
               movem.l    (sp)+,d4-d6
               addq.l     #4,24(a4)     ; Playposition
               btst       #2,d3         ; midi ?
               beq.s      ipcopyp2bb
               bsr        midioff
               tst.w      d0
               bne        iendplayp1b
ipcopyp2bb:    cmpa.l     d1,a2
               ble.s      iplayendp
               adda.l     d4,a2
               add.l      d4,24(a4)     ; Playposition
               dbra       d5,ipkuseplug2
ip_backp:      move.l     a2,von        ; Playposition retten
ip_backp2:     lea.l      playbyte,a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      ip_backpb2    ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
ip_backpb2:    movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplayendp:     moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte,a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      iplayendpb    ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
iplayendpb:    move.l     d6,loop       ; Anzahl loops sichern
               move.l     a2,von        ; Playposition retten
               btst       #1,d3         ; crossplay ?
               beq        iplooptstp    ; wenn nein, ueberspringen
               lea.l      crosflag,a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      baktoforp
fortobakp:     addq.l     #8,d4
               neg.l      d4
               move.l     d4,step       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               move.l     d1,von        ; neue Endposition
               move.l     bvon,d1
               addq.l     #4,d1
               move.l     d1,bis        ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra        ip_backp2
baktoforp:     neg.l      d4
               subq.l     #8,d4
               move.l     d4,step       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               move.l     d1,von        ; neue Anfangsposition
               lea.l      bbis,a4
               lea.l      bis,a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        ip_backp2
iendplayp:     lea.l      playbyte,a4
               tst.l      60(a4)        ; wenn 1, dann neue start und endpos
               beq.s      iendplayp1b
               lea.l      von,a3
               move.l     64(a4),(a3)   ; startpos fÅr compare retten
               lea.l      bis,a3
               move.l     68(a4),(a3)   ; endpos fÅr compare retten
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     #0,60(a4)     ; cuewerteÅbernommen-Flag
               bra.s      iendplayp1c
iendplayp1b:   lea.l      playbyte,a4
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      iendplayp1bb  ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
iendplayp1bb:  move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
iendplayp1c:   cmpi.l     #35,pimode
               bne.s      iendplayp2
               bsr        startupmex
iendplayp2:    movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplooptstp:    btst       #0,d3
               beq.s      iendplayp
               lea.l      von,a4
               lea.l      bvon,a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        ip_backp2

aimemrec24:    lea.l      rvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #4,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; nochmal dividiert durch 2
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               move.l     #0,ustartp
               move.l     #0,ustartm
               move.w     #0,usyncz
               lea.l      rimode(pc),a2
               move.l     #18,(a2)
               bsr        initplugr
               lea.l      recbyte,a4    ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

aimemrecu:     lea.l      rvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #4,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; nochmal dividiert durch 2
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #36,(a2)
               move.l     a4,d0
               rts        

init_imemrec:  move.w     (a0)+,d0      ; Auswahl
               tst.w      d0
               beq.s      aimemrec
               cmpi.w     #2,d0
               beq        aimemrec24
               cmpi.w     #99,d0
               beq        aimemrecu
aimemrec:      lea.l      rvon,a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rbis,a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rfifo,a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               btst       #0,modr24
               beq.s      aimemr24
               asr.w      #1,d0
aimemr24:      subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      recbyte,a4    ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; mempos lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      firstbuf,a6
               move.w     #0,(a6)       ; erster buffer - dann lîschen
               lea.l      rimode,a2
               move.l     #2,(a2)
               bsr        initplugr
               lea.l      recbyte,a4    ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

imemrec:       lea.l      firstbuf,a1
               tst.w      (a1)
               bne.s      imemre2
               move.w     #1,(a1)
               bsr        killbuf
fbexit:        movem.l    (sp)+,d0-d7/a0-a6
               rte        
imemre2:       lea.l      rvon,a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis,a2
               move.l     (a2),d1       ; bis d1
               lea.l      rfifo,a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               clr.l      dummy
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte,a5    ; RÅckgabewerte-Liste
               movea.l    a3,a2
iranf:         move.b     (a0),d0       ; Flag lesen
               btst       #2,d0         ; RECORD-FIFO voll ?
               bne.s      nordfull
               tst.l      24(a5)        ; Recposition abfragen
               beq.s      nordfull
               addi.l     #1,12(a5)     ;Fehler +1
nordfull:      andi.b     #2,d0         ; FIFO mehr als halbvoll ?
               beq.s      ircopy        ; wenn ja, daten einlesen
               bra.s      iranf
ircopy:        move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ircopy2:       btst       #0,modr24
               bne.s      irecopy24
               move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       #8,d7
               beq        ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       #8,d6
               beq        ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       #8,d5
               bne        ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       #8,d4
               bne        ircopy3       ; fehlerhafte Daten ?
               tst.w      pluglistr
               bne.s      imemruse
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               bra.s      imemrnouse
imemruse:      move.b     d7,dummy
               move.b     d6,dummy+1
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.b     d5,dummy
               move.b     d4,dummy+1
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bsr        workplugsr    ; plugins aufrufen
               move.w     6(sp),(a2)+   ; Linker Kanal,HighByte senden,A1=1
               move.w     2(sp),(a2)+   ; Rechter Kanal,HighByte senden,A1=0
               addq.l     #8,sp
imemrnouse:    addq.l     #4,24(a5)     ; Recposition
               bra        irecopy24x
irecopy24:     move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       #8,d7
               beq        ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Mid-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       #8,d6
               beq        ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d3       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       #8,d3
               beq        ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       #8,d5
               bne.s      ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       #8,d4
               bne.s      ircopy3       ; fehlerhafte Daten ?
               move.w     (a1),d2       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       #8,d2
               bne.s      ircopy3       ; fehlerhafte Daten ?
               tst.w      pluglistr
               bne.s      imemruse2
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d3,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               move.b     d2,(a2)+
               bra.s      imemrnouse2
imemruse2:     move.b     d7,dummy+1
               move.b     d6,dummy+2
               move.b     d3,dummy+3
               move.l     dummy,-(sp)   ; linken Kanal holen
               move.b     d5,dummy+1
               move.b     d4,dummy+2
               move.b     d2,dummy+3
               move.l     dummy,-(sp)   ; rechten Kanal holen
               bsr        workplugsr    ; plugins aufrufen
               move.b     5(sp),(a2)+   ; Linker Kanal,HighByte
               move.b     6(sp),(a2)+   ; Linker Kanal,MidByte
               move.b     7(sp),(a2)+   ; Linker Kanal,LowByte
               move.b     1(sp),(a2)+   ; Linker Kanal,HighByte
               move.b     2(sp),(a2)+   ; Linker Kanal,MidByte
               move.b     3(sp),(a2)+   ; Linker Kanal,LowByte
               addq.l     #8,sp
imemrnouse2:   addq.l     #6,24(a5)     ; Recposition
irecopy24x:    cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      irweg
ircopy3:       dbra       d0,ircopy2
ir_back:       lea.l      rvon,a4
               move.l     a2,(a4)       ; Recposition retten
ir_back2:      move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
irweg:         move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      rvon,a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

posmake:       lea.l      von,a2
               lea.l      pos,a3
               move.l     (a2),(a3)
               lea.l      step,a2
               move.l     (a2),d5       ; Anzahl der For/Backstep d5
               tst.l      d5
               bpl.s      ibpset
               lea.l      von,a2
               movea.l    (a2),a3       ; adr a3
               lea.l      len,a2
               movea.l    (a2),a5       ; len a5
               adda.l     a5,a3
               subq.l     #4,a3
               lea.l      pos,a2
               move.l     a3,(a2)       ;aktuelle position setzen (fÅr backplay)
ibpset:        move.w     #1,load       ; daten laden
               rts        

init_hplay:    lea.l      von,a2
               move.l     (a0)+,(a2)    ; adr a3
               lea.l      bvon,a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      len,a2
               move.l     (a0)+,(a2)    ; len a5
               lea.l      sectnr,a2
               move.l     (a0)+,(a2)    ; sectors d2
               lea.l      bsectnr,a3
               move.l     (a2),(a3)     ; sectors d2 retten fÅr crossplay und loop
               lea.l      seeknr,a2
               movea.l    (a0)+,a6      ; seekbyte a6
               move.l     a6,(a2)
               lea.l      handle,a2
               move.w     (a0)+,d7      ; handle d7
               move.w     d7,(a2)
               lea.l      fileart,a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step,a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d5
               move.w     d0,(a2)       ; Anzahl der For/Backstep d5
               lea.l      mode,a2
               move.w     (a0)+,d0      ; d3 mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               move.w     d0,(a2)       ; d3 mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               btst       #2,d0
               beq.s      ihplay2
               lea.l      midisuch,a2
               move.w     (a0)+,(a2)    ; midi d0
ihplay2:       lea.l      fifo,a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d4
               lea.l      midiw,a2
               move.l     #0,(a2)
               lea.l      loop,a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag,a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #0,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a6,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               lea.l      playbyte,a4   ; RÅckgabewerte-Liste
               move.l     #0,28(a4)     ; Anzahl loops lîschen
               move.l     #0,4(a4)      ; Anzahl sektoren lîschen
               move.l     #0,(a4)       ; playbyte lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               bsr        posmake
               lea.l      pimode(pc),a2
               move.l     #3,(a2)
               bsr        initplugp
               lea.l      playbyte,a4   ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

ihardplay:     lea.l      von,a2
               movea.l    (a2),a3       ; adr a3
               lea.l      len,a2
               movea.l    (a2),a5       ; len a5
               lea.l      handle,a2
               move.w     (a2),d7       ; handle d7
               lea.l      seeknr,a2
               movea.l    (a2),a6       ; seekbyte a6
               lea.l      step,a2
               clr.l      d5
               move.w     (a2),d5       ; Anzahl der For/Backstep d5
               lea.l      mode,a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzliche brkabfrage)
               lea.l      fifo,a2
               move.l     (a2),d4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d4
               lea.l      vmestart,a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a4
               addq.l     #2,a4         ; Playread a4, A1=1
               lea.l      midiw,a2
               move.l     #0,(a2)
               tst.l      d5
               bmi.s      ibackset
               move.l     a3,d1         ; MEMende
               add.l      a5,d1
               bra.s      ihplay
ibackset:      move.l     a3,d1
               subq.l     #4,d1
               adda.l     a5,a3
               subq.l     #4,a3
ihplay:        lea.l      pos,a2
               movea.l    (a2),a2       ;aktuelle position holen
               cmpi.w     #1,load
               bne.s      ihfill
               movem.l    d1-d7/a0-a6,-(sp)
               subi.l     #amount,savptr
               tst.l      d5
               bmi.s      ifseek
               bra.s      ifread
ifseek:        move.w     #1,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a5,d0
               add.l      d0,d0
               neg.l      d0
               move.l     d0,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
ifread:        move.l     a3,d0
               tst.l      d5
               bpl.s      ireadpos
               move.l     d1,d0
               addq.l     #4,d0
ireadpos:      move.l     d0,-(sp)      ; Fread
               move.l     a5,-(sp)
               move.w     d7,-(sp)
               move.w     #63,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               addi.l     #amount,savptr
               movem.l    (sp)+,d1-d7/a0-a6
               move.w     #0,load       ; Daten sind geladen
ihfill:        move.b     (a0),d0       ; PLAY-FIFO leer ?
               btst       #0,d0
               bne.s      nowrler2
               move.l     a3,rett
               lea.l      playbyte,a3   ; RÅckgabewerte-Liste
               tst.l      (a3)          ; mempos abfragen
               beq.s      nowrler2a
               addi.l     #1,12(a3)     ;Fehler +1
nowrler2a:     movea.l    rett,a3
nowrler2:      move.b     (a0),d0       ; PLAY-FIFO halbleer ?
               btst       #1,d0
               bne.s      icopyanf
itstrest:      bra.s      ihfill
icopyanf:      cmpi.w     #3,fileart
               bne.s      normcopy
               move.w     d4,d2         ; ...dann FIFO halb-fuellen (fifolen)!
;               clr.w      d0
icwav:         tst.w      pluglistp
               bne.s      ihrduseplug
               move.b     1(a2),(a4)
               move.b     (a2),(a4)
               move.b     3(a2),(a1)
               move.b     2(a2),(a1)
               addq.l     #4,a2
               bra.s      ihrdnouse
ihrduseplug:   move.b     1(a2),dummy
               move.b     (a2),dummy
               addq.l     #2,a2
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.b     1(a2),dummy
               move.b     (a2),dummy
               addq.l     #2,a2
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bsr        workplugsp    ; plugins aufrufen
               move.b     6(sp),(a4)    ; Linker Kanal,HighByte senden,A1=1
               move.b     7(sp),(a4)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(sp),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(sp),(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #8,sp
ihrdnouse:     adda.l     d5,a2
;               btst       #2,d3
;               beq.s      nohcopy
;               addq.w     #1,d0
;               cmpi.w     #256,d0
;               bne.s      nohcopy
;               bsr        ihmidi
;               tst.l      d0
;               bne        ihpnoc
;               clr.w      d0
nohcopy:       cmpa.l     d1,a2         ; puffer voll ?
               beq.s      ihplayend
               dbra       d2,icwav      ; fifo-Schleife
               bra.s      normcopy2
normcopy:      move.w     d4,d2         ; ...dann FIFO halb-fuellen (fifolen)!
               clr.w      d0
icopy:         tst.w      pluglistp
               bne.s      ihrduseplug2
               move.b     (a2)+,(a4)
               move.b     (a2)+,(a4)
               move.b     (a2)+,(a1)
               move.b     (a2)+,(a1)
               bra.s      ifaster
ihrduseplug2:  move.w     (a2)+,-(sp)
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.w     (a2)+,-(sp)
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bsr        workplugsp    ; plugins aufrufen
               move.b     6(sp),(a4)    ; Linker Kanal,HighByte senden,A1=1
               move.b     7(sp),(a4)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(sp),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(sp),(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #8,sp
ifaster:       adda.l     d5,a2
;               btst       #2,d3
;               beq.s      ifaster2
               addq.w     #1,d0
               cmpi.w     #64,d0
               bne.s      ifaster2
               bsr        ihmidi
               tst.l      d0
               bne        ihpnoc
               clr.w      d0
ifaster2:      cmpa.l     d1,a2         ; puffer voll ?
               bge.s      ihplayend     ; war beq
               dbra       d2,icopy      ; fifo-Schleife
normcopy2:     lea.l      pos,a0
               move.l     a2,(a0)       ; position retten
               lea.l      playbyte,a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihplayend:     lea.l      sectnr,a1
               move.l     (a1),d2
               subq.l     #1,d2
               move.l     d2,(a1)
               tst.l      d2
               bne        ihpnoall
ihpall:        lea.l      playbyte,a4
               addi.l     #1,4(a4)      ; ein sektor dazu
               addi.l     #1,28(a4)     ; ein loop dazu
ihcrostst:     btst       #1,d3
               beq.s      ihpltst
               lea.l      crosflag,a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      ihpbtof
ihpftob:       move.b     #1,(a5)       ; backcross
               addq.l     #8,d5
               neg.l      d5
               lea.l      step,a1
               move.l     d5,(a1)       ; Anzahl der For/Backstep d5
               move.l     d1,d0
               subq.l     #4,d0
               lea.l      von,a1
               move.l     d0,(a1)       ; adr a3
               lea.l      sectnr,a1
               lea.l      bsectnr,a0
               move.l     (a0),(a1)
               bra        ihpnoall
ihpbtof:       move.b     #0,(a5)       ; forcross
               neg.l      d5
               subq.l     #8,d5
               lea.l      step,a1
               move.l     d5,(a1)       ; Anzahl der For/Backstep d5
               move.l     d1,d0
               subq.l     #4,d0
               lea.l      von,a1
               move.l     d0,(a1)       ; adr a3
ihpltst:       btst       #0,d3         ; loop ?
               beq.s      ihpnoc
               lea.l      sectnr,a1
               lea.l      bsectnr,a0
               move.l     (a0),(a1)
               btst       #1,d3         ; Richtungsflag testen
               bne.s      ihpnoall
               subi.l     #amount,savptr
               movem.l    d1-d7/a0-a6,-(sp)
               move.w     #0,-(sp)      ; Fseek
               move.w     d7,-(sp)
               move.l     a6,-(sp)
               move.w     #66,-(sp)
               trap       #1
               lea.l      $a(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               addi.l     #amount,savptr
               bra.s      ihpnoall
ihpnoc:        lea.l      playbyte,a4
               addi.l     #1,4(a4)      ; ein sektor dazu
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     #1,8(a4)      ; break on
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihpnoall:      bsr        posmake
               lea.l      playbyte,a4
               addi.l     #1,4(a4)      ; ein sektor dazu
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihmidi:        movem.l    d1-d7/a0-a6,-(sp)
               lea.l      midisuch,a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               tst.w      d0
               beq.s      ihnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw,a0
               btst       #7,d0
               beq.s      ihmidi2       ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      ihnomidi
ihmidi2:       cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      ihmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      ihnomidi
ihmidi3:       move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      ihmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      ihmidi6
ihmidi3b:      move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      ihnomidi
ihmidi4:       cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      ihmidi3       ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      ihnomidi
ihmidi5:       cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      ihmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      ihmidiex      ; Abbruch, da NOTE OFF !
ihmidi6:       cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      ihmidi3b      ; wenn nein, Datenwort lîschen
               tst.b      2(a0)         ; Velocity ist Null ?
               bne.s      ihmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      ihmidiex      ; Abbruch, da NOTE ON und Velo=Null !
ihnomidi:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a6
               moveq.l    #0,d0
               rts        
ihmidiex:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a6
               moveq.l    #1,d0
               rts        

init_hrec:     lea.l      rpos(pc),a3
               lea.l      rvon(pc),a2
               move.l     (a0)+,(a3)    ; position a2
               move.l     (a3),(a2)     ; adr a3
               lea.l      rlen(pc),a2
               move.l     (a0)+,(a2)    ; len a5
               lea.l      rsectnr,a2
               move.l     (a0)+,(a2)    ; sectors d2
               lea.l      rhandle,a2
               move.w     (a0)+,(a2)    ; handle a6
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; a4 fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      recbyte,a4    ; RÅckgabewerte-Liste
               move.l     #0,4(a4)      ; Anzahl sektoren lîschen
               move.l     #0,(a4)       ; playbyte lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      rimode,a2
               move.l     #4,(a2)
               move.l     a4,d0
               rts        

ihardrec:      lea.l      firstbuf,a1
               tst.w      (a1)
               bne.s      ihardre2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihardre2:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; adr a3
               lea.l      rlen(pc),a2
               movea.l    (a2),a5       ; len a5
               lea.l      rhandle(pc),a2
               movea.w    (a2),a6       ; handle a6
               lea.l      rsectnr(pc),a2
               move.l     (a2),d2       ; sectors d2
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; a4 fifolen  (len/2/4-1) bei 8192Byte=$3FF
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               move.l     a3,d1         ; MEMende
               add.l      a5,d1
               moveq.l    #8,d2
               moveq.l    #2,d3
               lea.l      rpos(pc),a2
               movea.l    (a2),a2
ihnanf:        move.b     (a0),d0       ; Flag lesen
               btst       #2,d0         ; REC-FIFO voll ?
               bne.s      nordful2
               move.l     a3,rrett
               lea.l      recbyte,a3    ; RÅckgabewerte-Liste
               tst.l      (a3)          ; mempos abfragen
               beq.s      nodful2a
               addi.l     #1,12(a3)     ;Fehler +1
nodful2a:      movea.l    rrett,a3
nordful2:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ihncopy       ; wenn ja, daten schnell einlesen
               bra.s      ihnanf
ihncopy:       move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ihncopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ihncopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ihncopy3      ; fehlerhafte Daten ?
               cmpi.w     #3,rfileart
               bne.s      normrec
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bra.s      normrec2
normrec:       move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
normrec2:      cmpa.l     d1,a2         ; sektorbuffer voll ?
               beq.s      ihnsave       ;dann speichern
ihncopy3:      dbra       d0,ihncopy2   ; fifolen-Schleife
               lea.l      rpos(pc),a3
               move.l     a2,(a3)       ; position retten
               bra.s      ihrecweg
ihnsave:       lea.l      rpos(pc),a0
               move.l     a3,(a0)       ; position zurÅcksetzen
               subi.l     #amount,savptr
               movem.l    d1-d7/a0-a6,-(sp)
               move.l     a3,-(sp)      ; Fwrite
               move.l     a5,-(sp)
               move.w     a6,-(sp)
               move.w     #64,-(sp)
               trap       #1
               lea.l      $c(sp),sp
               movem.l    (sp)+,d1-d7/a0-a6
               addi.l     #amount,savptr
               bmi.s      ihrecend
               cmpa.l     d0,a5
               bne.s      ihrecend
               lea.l      rsectnr(pc),a0
               move.l     (a0),d2       ; sectors d2
               subq.l     #1,d2
               move.l     d2,(a0)
               tst.l      d2            ; alle Sektoren geschrieben ?
               beq.s      ihrecend
ihrecweg:      lea.l      recbyte,a5
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0
               addq.l     #1,d0
               move.l     d0,4(a5)      ; Returnwert Anzahl sektoren speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ihrecend:      lea.l      recbyte,a5
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0
               addq.l     #1,d0
               move.l     d0,4(a5)      ; Returnwert Anzahl sektoren speichern
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

compatible:    move.w     (a0)+,d0      ; mode
               lea.l      falcmode(pc),a6
               cmpi.w     #-1,d0
               beq        compaget
               move.w     d0,(a6)
               tst.w      d0
               bne.s      ctible
;               bsr        putsysorig
               bsr        ocookies
               bsr        cookie
               bra.s      ctibleweg
ctible:                   ;   bsr        makesysbase
ctibleweg2:    bsr        ncookies
               bsr        cookie
ctibleweg:     clr.l      d0
               rts        
compaget:      clr.l      d0
               move.w     (a6),d0
               rts        

initregs:      move.b     #3,playch
               move.w     #0,gpdirect
               move.w     #0,nopkbuf
               move.w     #0,pluglistp
               move.w     #0,pluglistr
               move.w     #0,plugcnt

               lea.l      stack,a0
               move.w     #1,(a0)       ; scms-decode on
               bsr        scmsmode

               lea.l      plugs(pc),a1
               clr.w      d2
               clr.w      d3
delplugs:      move.w     #0,0(a1,d2.w)
               addi.w     #24,d2
               addi.w     #1,d3
               cmpi.w     #10,d3
               bne.s      delplugs
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a1
               move.b     #1,(a1)
               move.b     #1,$40(a6)
               lea.l      dspreg,a1
               move.b     #36,(a1)
               move.b     #36,$80(a6)
               move.w     #1,matout
               lea.l      matin,a2
               clr.w      (a2)
               lea.l      aesreg,a1
               move.b     #0,(a1)
               move.b     #0,$c0(a6)
               bsr        recreset
               lea.l      cmdaddr(pc),a1          ; adderin=matrix
               move.w     #2,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$c0(a6)
               lea.l      dsppath1(pc),a1
               move.b     #7,(a1)
               move.b     #7,$210(a6)
               lea.l      dspport(pc),a1
               move.b     #8,(a1)
               move.b     #8,$212(a6)
               lea.l      dsppath2(pc),a1
               move.b     #5,(a1)
               move.b     #5,$214(a6)
               lea.l      dspconv(pc),a1
               move.b     #3,(a1)
               move.b     #3,$216(a6)
               move.b     #3,$216(a6)
               move.b     #3,$216(a6)
               lea.l      dsppdat(pc),a1
               move.b     #0,(a1)
               move.b     #0,$240(a6)
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               move.b     #0,$242(a6)
               lea.l      intreg(pc),a1
               move.b     #0,(a1)
               move.b     #0,$280(a6)
               lea.l      dintreg(pc),a1
               move.b     #0,(a1)

               lea.l      playmod(pc),a5
               cmpi.w     #2,(a5)
               bge.s      inimodus
               bsr        nmodus
               bra.s      iclrbuf
inimodus:      bsr        falcmodus
iclrbuf:       bsr        clearbuffers

               bsr        pushaesr

               move.w     #2,d7
               lea.l      asrc(pc),a5   ; analog oder digital
               cmpi.w     #1,(a5)
               beq.s      igtclk
               move.w     #0,d7         ; clock is spdif

igtclk:        cmpi.w     #1,osrc
               beq.s      osrc1
               cmpi.w     #2,osrc
               beq.s      osrc2
               lea.l      stack,a0
               move.w     #3,(a0)+      ; source=converter (adc or digin)
               move.w     #$f,(a0)+     ; dest
               move.w     #0,(a0)+      ; srcclk
               move.w     d7,(a0)+      ; prescale
               move.w     #1,(a0)       ; protocol
               lea.l      stack,a0
               bsr        devconnect
               bra.s      osrc0
osrc1:         lea.l      stack,a0
               move.w     #0,(a0)+      ; source=dma
               move.w     #$f,(a0)+     ; dest
               move.w     #0,(a0)+      ; srcclk
               move.w     d7,(a0)+      ; prescale
               move.w     #1,(a0)       ; protocol
               lea.l      stack,a0
               bsr        devconnect
               bra.s      osrc0
osrc2:         lea.l      stack,a0
               move.w     #2,(a0)+      ; source=external
               move.w     #$f,(a0)+     ; dest
               move.w     #0,(a0)+      ; srcclk
               move.w     d7,(a0)+      ; prescale
               move.w     #1,(a0)       ; protocol
               lea.l      stack,a0
               bsr        devconnect
osrc0:         lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      asrc(pc),a5   ; analog oder digital
               move.w     #9,d0
               cmpi.w     #1,(a5)
               beq.s      idigi
               move.w     #0,d0
idigi:         lea.l      dsrc(pc),a5   ; opto,cinch oder xlr
               cmpi.w     #0,(a5)
               beq.s      ikoax
               bset       #1,d0
ikoax:         lea.l      lowreg(pc),a1
               move.b     d0,(a1)
               move.b     d0,(a6)
setupvol:      lea.l      adwert(pc),a6
               lea.l      param,a0
               move.w     (a6)+,(a0)+
               move.w     (a6),(a0)
               lea.l      param,a0
               bsr        volad
               lea.l      dawert(pc),a6
               lea.l      param,a0
               move.w     (a6)+,(a0)+
               move.w     (a6),(a0)
               lea.l      param,a0
               bsr        volda
               rts        

falcmodus:     move.w     #2,d2
               bsr        playmode2
;               move.w     #2,d2
;               bsr        recmode2
               lea.l      asrc(pc),a5   ; analog oder digital
               lea.l      stack,a0
               move.w     #2,(a0)+      ; schreiben
               move.w     #0,d1
               cmpi.w     #0,(a5)
               beq.s      fmodus2
               move.w     #2,d1
fmodus2:       move.w     d1,(a0)       ; gpio1=1
               lea.l      stack,a0
               bsr        gpio
               lea.l      stack,a0
               move.w     #3,(a0)+      ; source=adc
               move.w     #15,(a0)+     ; dest
               move.w     #0,d1         ; clock is spdif
               cmpi.w     #0,(a5)
               beq.s      fmodus3
               move.w     #2,d1         ; clock is 44.1k
fmodus3:       move.w     d1,(a0)+      ; srcclk
               move.w     #0,(a0)+      ; srcclk=normal
               move.w     #2,d0         ; clock is 44.1k
               lea.l      asrc(pc),a5   ; analog oder digital
               cmpi.w     #1,(a5)
               beq.s      iniaflc
               move.w     #0,d0         ; clock is spdif
iniaflc:       move.w     d0,(a0)+      ; prescale=44.1k or spdif
               move.w     #1,(a0)       ; protocol
               lea.l      stack,a0
               bsr        devconnect
               lea.l      stack,a0
               move.w     montrack,d0
               move.w     d0,(a0)       ; schreiben
               bsr        setmontrack
               rts        

nmodus:        move.w     #0,d2
               bsr        playmode2
               lea.l      playmod(pc),a1
               move.b     #0,(a1)
               lea.l      recmod(pc),a1
               move.b     #0,(a1)
               lea.l      asrc(pc),a5   ; analog oder digital
               lea.l      stack,a0
               move.w     #3,(a0)+      ; source=adc
               move.w     #$f,(a0)+     ; dest
nmodus2:       move.w     #0,(a0)+      ; srcclk
               move.w     #0,d1         ; clock is spdif
               cmpi.w     #0,(a5)
               beq.s      nmodus3
               move.w     #2,d1         ; clock is 44.1k
nmodus3:       move.w     d1,(a0)+      ; prescale
               move.w     #1,(a0)       ; protocol
               lea.l      stack,a0
               bsr        devconnect
               move.w     #0,d0         ; clock is spdif
               lea.l      asrc(pc),a5   ; analog oder digital
               cmpi.w     #0,(a5)
               beq.s      nmodus4
               move.w     #2,d0         ; clock is 44.1k
nmodus4:       bsr        dclock
               rts        

clearbuffers:  lea.l      recbuf,a3
               move.l     a3,d1
               lea.l      recbuf2,a2
               move.l     a2,d2
               lea.l      recbuf3,a2
               move.l     a2,d3
               lea.l      pbufstrt,a1
               move.l     d1,(a1)
               lea.l      pbufptr,a1
               move.l     d1,(a1)
               lea.l      pbufend,a1
               move.l     d2,(a1)
               lea.l      rbufstrt,a1
               move.l     d2,(a1)
               lea.l      rbufptr,a1
               move.l     d2,(a1)
               lea.l      rbufend,a1
               move.l     d3,(a1)
               move.w     #recbuflen,d0
               asr.w      #2,d0
               subq.w     #1,d0
killbuff:      move.l     #0,(a3)+
               dbra       d0,killbuff
               rts        

playmode:      move.w     (a0)+,d2
playmode2:     cmpi.w     #-1,d2
               beq        getpmode
               tst.w      d2
               blt        pmerr
               cmpi.w     #3,d2
               bgt        pmerr
               lea.l      dsppath2(pc),a4
               move.b     (a4),d4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               bclr       #3,d4
               cmpi.w     #2,d2
               blt.s      noconvm
               bset       #3,d4
noconvm:       cmpi.w     #1,d2
               bne.s      noconvm2
               bclr       #1,d4
               bclr       #2,d4
noconvm2:      move.b     d4,(a4)
               move.b     d4,$214(a6)
               lea.l      playmod(pc),a3
               move.w     d2,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               move.w     #4,d0
               bsr        matoutsel     ; zur Vierkanalauswahl
               lea.l      matin(pc),a2
               move.w     matout,d7
               lsl.w      #1,d7
               subq.w     #2,d7
               move.w     0(a2,d7.w),d0
               andi.w     #3,d0
               lea.l      dspreg(pc),a5
               move.b     (a5),d5
               andi.w     #$fc,d5
               add.w      d0,d5
               bclr       #1,d5         ; play4
               move.b     d5,(a5)
               move.b     d5,$80(a6)    ; play4-mode loeschen
               move.w     d5,d0
               andi.w     #3,d0
               move.w     d0,0(a2,d7.w)
               bclr       #3,d1
               bclr       #1,d1         ; 16kanalmode und 128bitmode entfernen
               move.b     d1,$c0(a6)    ; normalmode
               move.b     d1,(a1)
               move.w     #0,montrack2  ; alten montrack-wert aktualisieren
               cmpi.w     #1,d2         ; ist fourchannel mode ?
               beq.s      playm1b
               cmpi.w     #1,recmod     ; recmode ist Vierkanal ?
               beq.s      playm1a       ; dann raus
               move.w     #1,d0
               bsr        matoutsel     ; zur DMAREC auswahl
               lea.l      matin(pc),a2
               move.w     matout,d7
               lsl.w      #1,d7
               subq.w     #2,d7
               move.w     0(a2,d7.w),d0
               andi.w     #3,d0
               lea.l      dspreg(pc),a5
               move.b     (a5),d5
               andi.w     #$fc,d5
               add.w      d0,d5
               move.b     d5,(a5)
               move.b     d5,$80(a6)    ; in normalmode (nicht vierkanalmode)
playm1a:       tst.w      d2            ; ist normalmode ?
               beq.s      pmweg
               bra.s      playm2        ; ist also 128Bit mode
playm1b:       bset       #1,d5         ; playmode fourchannel an
               move.b     d5,(a5)
               move.b     d5,$80(a6)
               move.w     d5,d0
               andi.w     #3,d0
               move.w     d0,0(a2,d7.w)
               bra.s      pmweg
playm2:        bset       #3,d1         ; 8 und 16kanalplay einstellen
               cmpi.w     #2,d2
               beq.s      noplaym3
               bset       #1,d1
noplaym3:      move.b     d1,$c0(a6)
               move.b     d1,(a1)
               lea.l      montrack(pc),a1
               move.w     #0,2(a1)      ; alten montrack-wert aktualisieren
               bsr        pushaesr
pmweg:         bsr        adc8tst
               clr.l      d0
               rts        
pmerr:         move.l     #-1,d0
               rts        
getpmode:      clr.l      d0
               lea.l      playmod(pc),a3
               move.w     (a3),d0
               rts        

getsysbase:    movea.l    $4f2,a1
               move.l     a1,d0
               lea.l      csysadr(pc),a2
               move.l     d0,(a2)
               rts        

makesysbase:   move.w     #$7f,d0
               lea.l      csysbase,a2
               lea.l      csysadr,a1
               movea.l    (a1),a1
getsysb2:      move.b     (a1)+,(a2)+
               dbra       d0,getsysb2
               lea.l      csysbase,a1
               move.w     #$404,2(a1)
               move.l     #$3081993,$18(a1)
               move.w     #$1a68,$1e(a1)
               lea.l      csysbase,a1
               move.l     a1,d0
               move.l     d0,$4f2
               rts        

putsysorig:    lea.l      csysadr(pc),a2
               move.l     (a2),d0
               move.l     d0,$4f2
               rts        

peakread:      lea.l      pkrq(pc),a1   ; request(0)- und peakwert(2)
               clr.w      (a1)          ; peakanforderung
               move.l     a1,d0         ; pointer zurÅckgeben
               rts        

peakshow:      move.w     (a0)+,d0
               tst.w      d0
               bne.s      setpkshow
               cmpi.w     #2,nopeaks
               bne.s      peakshow2
               clr.w      nopeaks
peakshow2:     rts        
setpkshow:     cmpi.w     #0,nopeaks    ; von adcemul schon gestezt ?
               bne.s      peakshow2
               move.w     #2,nopeaks    ; ohne Peakberechnung
               rts        

peakmake:      move.w     (a0)+,nopkbuf
               clr.l      d0
               rts        

ustartread:    lea.l      ustartp(pc),a4          ; User-Startsync adresse
               move.l     (a4),d0
               rts        

init_peak:     move.w     (a0)+,d0      ; Auswahl
               tst.w      d0
               beq.s      peaksolo
               cmpi.w     #1,d0
               beq        peakmulti
peaksolo:      lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               btst       #0,modr24
               beq.s      peaksolo2
               asr.w      #1,d0
peaksolo2:     subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; RÅckgabewert lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,ustartp
               move.l     #0,ustartm
               move.w     #0,usyncz
               lea.l      rimode(pc),a2
               move.l     #5,(a2)
               move.l     a4,d0
               rts        

ipeaksolo:     lea.l      rfifo(pc),a2
               movea.l    (a2),a3       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               movea.l    #5,a2
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     (a4),d1
               moveq.l    #8,d2
               moveq.l    #2,d3
ipkanf:        move.b     (a0),d0       ; Flag lesen
               and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ipkcopy       ; wenn ja, daten einlesen
               bra.s      ipkanf
ipkcopy:       move.w     a3,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ipkcopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ipkcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ipkcopy3      ; fehlerhafte Daten ?
               btst       #0,modr24     ; 24Bit ?
               beq.s      ipk24b1       ; nein
               move.w     (a1),d5       ; Lowest-Byte bei 24Bit wegwerfen
               btst       d2,d5
               beq.s      ipkcopy3      ; fehlerhafte Daten ?
               move.w     d5,dummy
ipk24b1:       move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ipkcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ipkcopy3      ; fehlerhafte Daten ?
               btst       #0,modr24     ; 24Bit ?
               beq.s      ipk24b2       ; nein
               move.w     (a1),dummy+2  ; Lowest-Byte bei 24Bit wegwerfen
ipk24b2:       asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               swap.w     d1
               btst       #15,d7
               beq.s      pnoneg
               not.w      d7
pnoneg:        cmp.w      d1,d7
               blt.s      pnoadd
               move.w     d7,d1
pnoadd:        swap.w     d1
               btst       #15,d5
               beq.s      pnoneg2
               not.w      d5
pnoneg2:       cmp.w      d1,d5
               blt.s      ipkcopy3
               move.w     d5,d1
ipkcopy3:      move.w     dummy,d4
               move.w     dummy+2,d5
               bsr        testuser
               dbra       d0,ipkcopy2
               move.l     d1,(a4)
               tst.w      pkrq          ; peakanforderung
               beq.s      ipkcopy4      ; nein ?, dann weiter
               move.l     d1,peakvalue
               clr.l      (a4)          ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
ipkcopy4:      move.l     #1,8(a4)      ; Break setzen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

peakmulti:     lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #5,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; RÅckgabewert lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.w     #0,xrch
               lea.l      rimode(pc),a2
               move.l     #29,(a2)
               move.l     a4,d0
               rts        

ipeakmult:     lea.l      rfifo(pc),a2
               movea.l    (a2),a3       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     (a4),d1
               moveq.l    #8,d2
               moveq.l    #2,d3
ipkmanf:       move.b     (a0),d0       ; Flag lesen
               and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ipkmcopy      ; wenn ja, daten einlesen
               bra.s      ipkmanf
ipkmcopy:      move.l     a3,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ipkmcopyb:     move.w     (a1),d7       ; High-Byte, Kanal1 (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        ipkmcopy3     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte, Kanal1 (Bit 8 geloescht ?)...
               btst       d2,d6
               bne        ipkmcopy3     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ipkmcopy3     ; fehlerhafte Daten ?
               move.w     (a1),d4
               tst.w      xrch
               bne.s      ipkmrec1
               bsr        getmult6
               bra.s      ipkmrec4
ipkmrec1:      move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #1,xrch
               bne.s      ipkmrec2
               bsr        getmult4
               bra.s      ipkmrec4
ipkmrec2:      move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               cmpi.w     #2,xrch
               bne.s      ipkmrec3
               bsr        getmult2
               bra.s      ipkmrec4
ipkmrec3:      move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
ipkmrec4:      asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               swap.w     d1
               btst       #15,d7
               beq.s      ipnoneg
               not.w      d7
ipnoneg:       cmp.w      d1,d7
               blt.s      ipnoadd
               move.w     d7,d1
ipnoadd:       swap.w     d1
               btst       #15,d5
               beq.s      ipnoneg2
               not.w      d5
ipnoneg2:      cmp.w      d1,d5
               blt.s      ipkmcopy3
               move.w     d5,d1
ipkmcopy3:     dbra       d0,ipkmcopyb
               move.l     d1,(a4)
               move.l     #1,8(a4)      ; Break setzen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

getmult6:      movea.w    (a1),a5       ; Kanalbyte holen
               movea.w    (a1),a5       ; Kanalbyte holen
               movea.w    (a1),a5       ; Kanalbyte holen
               movea.w    (a1),a5       ; Kanalbyte holen
getmult4:      movea.w    (a1),a5       ; Kanalbyte holen
               movea.w    (a1),a5       ; Kanalbyte holen
               movea.w    (a1),a5       ; Kanalbyte holen
               movea.w    (a1),a5       ; Kanalbyte holen
getmult2:      movea.w    (a1),a5       ; Kanalbyte holen
               movea.w    (a1),a5       ; Kanalbyte holen
               movea.w    (a1),a5       ; Kanalbyte holen
               movea.w    (a1),a5       ; Kanalbyte holen
               rts        

init_mrppeak:  rts        

idrecpeak:     lea.l      rdvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rdbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rdfifo(pc),a2
               move.l     #$1000,(a2)   ; dspbuffer 16384 (/4=$1000) Byte
               lea.l      drecbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      dpimode(pc),a2
               move.l     #0,(a2)
               lea.l      drimode(pc),a2
               move.l     #14,(a2)
               move.l     a4,d0
               rts        

init_mrecpeak: move.w     (a0)+,d0      ; Auswahl
               tst.w      d0
               beq.s      imrecpeak
               cmpi.w     #1,d0
               beq        idrecpeak
imrecpeak:     lea.l      rvon(pc),a2
               move.l     (a0)+,(a2)    ; von a3
               lea.l      rbis(pc),a2
               move.l     (a0)+,(a2)    ; bis d1
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               lsr.w      #3,d0
               btst       #0,modr24
               beq.s      nimrec24
               lsr.w      #1,d0
nimrec24:      subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               move.l     #0,ustartp
               move.l     #0,ustartm
               move.w     #0,usyncz
               lea.l      rimode(pc),a2
               move.l     #6,(a2)
               bsr        initplugr
               lea.l      recbyte,a4    ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

mrecpeak:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      mrecpea2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
mrecpea2:      movea.l    rvon(pc),a2   ; von a2
               move.l     rbis(pc),d1   ; bis d1
               movea.l    rfifo(pc),a4  ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               clr.l      dummy
               movea.l    vmestart(pc),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               movea.l    16(a5),a6     ; Peak-RÅckgabewert holen
miranf:        move.b     (a0),d0       ; Flag lesen
               btst       #2,d0         ; REC-FIFO voll ?
               bne.s      nordful3
               tst.l      24(a5)        ; Recposition abfragen
               beq.s      nordful3
               addq.l     #1,12(a5)     ; Fehler +1
nordful3:      andi.b     #2,d0         ; FIFO mehr als halbvoll ?
               bne.s      miranf        ; wenn ja, daten einlesen
mircopy:       move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
               btst       #0,modr24     ; 24Bit ?
               bne        mircopy24     ; ja->dorthin
               moveq.l    #8,d2
mircopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        mircopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq        mircopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne        mircopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne        mircopy3      ; fehlerhafte Daten ?
               tst.w      pluglistr
               bne.s      imemrkuse2
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               bsr        ppeakcmp
               bra.s      mrp24b4
imemrkuse2:    move.b     d7,dummy
               move.b     d6,dummy+1
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.b     d5,dummy
               move.b     d4,dummy+1
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bsr        ppeakcmp
               bsr        workplugsr    ; plugins aufrufen
               move.w     6(sp),(a2)+   ; Linker Kanal,HighByte senden,A1=1
               move.w     2(sp),(a2)+   ; Rechter Kanal,HighByte senden,A1=0
               adda.l     d2,sp
mrp24b4:       addq.l     #4,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      mirweg
mircopy3:      dbra       d0,mircopy2
mir_back:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
mir_back2:     lea.l      recbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Recordbyte speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      mir_back2b    ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
mir_back2b:    movem.l    (sp)+,d0-d7/a0-a6
               rte        
mirweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     a6,16(a5)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      mirweg1b      ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a5)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
mirweg1b:      move.l     a2,rvon       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

mircopy24:     moveq.l    #8,d3
mircopy24b:    move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d3,d7
               beq        mircopy4      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d3,d6
               beq        mircopy4      ; fehlerhafte Daten ?
               move.w     (a1),d2       ; Lowest-Byte bei 24Bit wegwerfen
               btst       d3,d2
               beq        mircopy4      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d3,d5
               bne        mircopy4      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d3,d4
               bne        mircopy4      ; fehlerhafte Daten ?
               move.w     (a1),d3       ; Lowest-Byte bei 24Bit wegwerfen
               movem.w    d4/d5,-(sp)
               move.w     d2,d4
               move.w     d3,d5
               bsr        testuser
               movem.w    (sp)+,d4/d5
               tst.w      pluglistr
               bne.s      imemrkuse
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d2,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               move.b     d3,(a2)+
               bsr        ppeakcmp
               bra.s      mrp24b4b
imemrkuse:     move.b     d7,dummy+1
               move.b     d6,dummy+2
               move.b     d2,dummy+3
               move.l     dummy,-(sp)   ; linken Kanal holen
               move.b     d5,dummy+1
               move.b     d4,dummy+2
               move.b     d3,dummy+3
               move.l     dummy,-(sp)   ; rechten Kanal holen
               bsr        ppeakcmp
               bsr        workplugsr    ; plugins aufrufen
               move.b     5(sp),(a2)+   ; Linker Kanal,HighByte
               move.b     6(sp),(a2)+   ; Linker Kanal,MidByte
               move.b     7(sp),(a2)+   ; Linker Kanal,LowByte
               move.b     1(sp),(a2)+   ; Linker Kanal,HighByte
               move.b     2(sp),(a2)+   ; Linker Kanal,MidByte
               move.b     3(sp),(a2)+   ; Linker Kanal,LowByte
               adda.l     d3,sp
mrp24b4b:      addq.l     #6,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq        mirweg
mircopy4:      dbra       d0,mircopy24
               bra        mir_back

ppeakcmp:      tst.w      nopeaks
               beq.s      ppeakcmp2
               rts        
ppeakcmp2:     lsl.w      #8,d7
               add.b      d6,d7
               lsl.w      #8,d5
               add.b      d4,d5
               move.l     d1,-(sp)
               move.l     a6,d1
               swap.w     d1
               btst       #15,d7
               beq.s      pxpnoneg
               not.w      d7
pxpnoneg:      cmp.w      d1,d7
               blt.s      pxpnoadd
               move.w     d7,d1
pxpnoadd:      swap.w     d1
               btst       #15,d5
               beq.s      pxpnoneg2
               not.w      d5
pxpnoneg2:     cmp.w      d1,d5
               blt.s      pxircop2b
               move.w     d5,d1
pxircop2b:     movea.l    d1,a6
               move.l     (sp)+,d1
               rts        

ppeakcmps:     tst.w      nopeaks
               beq.s      ppeakcmps2
               rts        
ppeakcmps2:    lsl.w      #8,d7
               add.b      d6,d7
               lsl.w      #8,d5
               add.b      d4,d5
               move.l     a6,d1
               swap.w     d1
               btst       #15,d7
               beq.s      pxpnonegs
               not.w      d7
pxpnonegs:     cmp.w      d1,d7
               blt.s      pxpnoadds
               move.w     d7,d1
pxpnoadds:     swap.w     d1
               btst       #15,d5
               beq.s      pxpnonegs2
               not.w      d5
pxpnonegs2:    cmp.w      d1,d5
               blt.s      pxircop2sb
               move.w     d5,d1
pxircop2sb:    movea.l    d1,a6
               rts        

init_impmix:   move.w     (a0)+,d0      ; Auswahl
               tst.w      d0
               beq.s      aimixplay
               cmpi.w     #2,d0
               beq.s      aimixplay
               rts        
aimixplay:     lea.l      von(pc),a2
               move.l     (a0)+,d2      ; von a3
               move.l     d2,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      bis(pc),a2
               move.l     (a0)+,d3      ; bis d1
               move.l     d3,(a2)       ; bis d1
               lea.l      bbis(pc),a3
               move.l     (a2),(a3)     ; bis d1 retten fÅr crossplay und loop
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               clr.l      d4
               move.w     (a0)+,d4      ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      imixnmidi
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
imixnmidi:     lea.l      step(pc),a2
               tst.w      d4
               blt        imemperrs
               move.l     d2,d0
               sub.l      d3,d0
               tst.l      d0
               beq        imemperrs
               ble.s      imixpneg8
               moveq.l    #0,d2
               addq.l     #1,d4
               sub.l      d4,d2
               move.l     d2,d4
               move.l     d4,d5
               add.l      d5,d4
               add.l      d5,d4
               add.l      d5,d4
               btst       #0,modr24
               beq.s      imixnmi16
               add.l      d5,d4
               add.l      d5,d4
               addi.l     #-6,d4
               bra.s      imixpplus
imixnmi16:     addi.l     #-4,d4
               bra.s      imixpplus
imixpneg8:     move.l     d4,d5
               add.l      d5,d4
               add.l      d5,d4
               add.l      d5,d4
               btst       #0,modr24
               beq.s      imixpplus
               add.l      d5,d4
               add.l      d5,d4
imixpplus:     move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               btst       #0,modr24
               beq.s      imixshft24
               asr.w      #1,d0
imixshft24:    subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,(a4)       ; mempos lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      rvon(pc),a2
               move.l     (a2),d0
               lea.l      recmics(pc),a2          ; RÅckgabewerte-Liste
               subi.l     #24576,d0
               move.l     d0,(a2)
               lea.l      pimode(pc),a2
               move.l     #8,(a2)
               bsr        initplugr
               bsr        initplugp
               lea.l      playbyte,a4   ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

implaymix:     clr.l      d5
               lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               clr.l      dummy
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
               lea.l      recmics(pc),a4          ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq        xip_back
xipfill:       move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      xnowrleer
               move.l     strtp(pc),d0
               cmp.l      24(a6),d0
               beq.s      xnowrleer
               addi.l     #1,12(a6)     ;Fehler +1
xnowrleer:     move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      xipcopyanf
               bra.s      xipfill
xipcopyanf:    tst.l      d4
               blt        xipcopyneg
               cmpa.l     d1,a2
               bge        xiplayend
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
xipcopy:       movea.l    (a4),a3
               btst       #0,modr24
               bne.s      xipcopy24
               move.w     (a2)+,d7      ; linken Kanal holen
               move.w     (a3)+,d6
               bsr        mixer
               tst.w      pluglistp
               bne.s      impuseplug
               move.w     d7,d6
               asr.w      #8,d6
               move.b     d6,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d7,(a5)       ; Linker Kanal,LowByte senden,A1=1
               move.w     (a2)+,d7      ; linken Kanal holen
               move.w     (a3)+,d6
               move.l     a3,(a4)
               bsr        mixer
               move.w     d7,d6
               asr.w      #8,d6
               move.b     d6,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d7,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra.s      xipcopy1b
impuseplug:    move.w     d7,-(sp)
               move.w     #0,-(sp)
               move.w     (a2)+,d7      ; linken Kanal holen
               move.w     (a3)+,d6
               move.l     a3,(a4)
               bsr        mixer
               move.w     d7,-(sp)
               move.w     #0,-(sp)
               bsr        workplugsp    ; plugins aufrufen
               move.b     6(sp),(a5)    ; Linker Kanal,HighByte holen
               move.b     7(sp),(a5)    ; Linker Kanal,LowByte holen
               move.b     2(sp),(a1)    ; Rechter Kanal,HighByte holen
               move.b     3(sp),(a1)    ; Rechter Kanal,LowByte holen
               addq.l     #8,sp
xipcopy1b:     addq.l     #4,24(a6)     ; Playposition
               bra        xipcopyx
xipcopy24:     clr.w      d7
               move.b     (a2)+,d7      ; linken Kanal holen
               lsl.l      #8,d7
               move.b     (a2)+,d7      ; linken Kanal holen
               lsl.l      #8,d7
               move.b     (a2)+,d7      ; linken Kanal holen
               clr.w      d6
               move.b     (a3)+,d6      ; rechten Kanal holen
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; rechten Kanal holen
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; rechten Kanal holen
               bsr        mixer24
               tst.w      pluglistp
               bne.s      impuseplug2
               move.l     d7,d5
               swap.w     d5
               move.l     d7,d6
               asr.w      #8,d6
               move.b     d5,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a5)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d7,(a5)       ; Linker Kanal,LowByte senden,A1=1
               clr.w      d7
               move.b     (a2)+,d7      ; linken Kanal holen
               lsl.l      #8,d7
               move.b     (a2)+,d7      ; linken Kanal holen
               lsl.l      #8,d7
               move.b     (a2)+,d7      ; linken Kanal holen
               clr.w      d6
               move.b     (a3)+,d6      ; rechten Kanal holen
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; rechten Kanal holen
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; rechten Kanal holen
               move.l     a3,(a4)
               bsr        mixer24
               move.l     d7,d5
               swap.w     d5
               move.l     d7,d6
               asr.w      #8,d6
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d7,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra.s      xipcop24b
impuseplug2:   move.l     d7,-(sp)
               clr.w      d7
               move.b     (a2)+,d7      ; linken Kanal holen
               lsl.l      #8,d7
               move.b     (a2)+,d7      ; linken Kanal holen
               lsl.l      #8,d7
               move.b     (a2)+,d7      ; linken Kanal holen
               clr.w      d6
               move.b     (a3)+,d6      ; rechten Kanal holen
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; rechten Kanal holen
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; rechten Kanal holen
               move.l     a3,(a4)
               bsr        mixer24
               move.l     d7,-(sp)
               bsr        workplugsp    ; plugins aufrufen
               move.b     5(sp),(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     6(sp),(a5)    ; Linker Kanal,MidByte senden,A1=1
               move.b     7(sp),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     1(sp),(a1)    ; Linker Kanal,HighByte senden,A1=0
               move.b     2(sp),(a1)    ; Linker Kanal,MidByte senden,A1=0
               move.b     3(sp),(a1)    ; Linker Kanal,LowByte senden,A1=0
               addq.l     #8,sp
xipcop24b:     addq.l     #6,24(a6)     ; Playposition
xipcopyx:      cmpa.l     d1,a2
               bge.s      xiplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,xipcopy
               bra.s      xip_back
xipcopyneg:    cmpa.l     d1,a2
               ble.s      xiplayend
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
xipcopy2:      btst       #0,modr24
               bne.s      xipcopy24n
               move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a6)     ; Playposition
               bra.s      xipcopy24bx
xipcopy24n:    move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #6,24(a6)     ; Playposition
xipcopy24bx:   cmpa.l     d1,a2
               ble.s      xiplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,xipcopy2
xip_back:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
xip_back2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d5,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xiplayend:     moveq.l    #0,d0
               addq.l     #1,d5
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d5,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      loop(pc),a4
               move.l     d5,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #1,d3         ; crossplay ?
               beq.s      xiplooptst    ; wenn nein, ueberspringen
               lea.l      crosflag(pc),a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      xbaktofor
xfortobak:     addq.l     #8,d4
               neg.l      d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Endposition
               lea.l      bvon(pc),a4
               move.l     (a4),d1
               addq.l     #4,d1
               lea.l      bis(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra.s      xip_back2
xbaktofor:     neg.l      d4
               subq.l     #8,d4
               lea.l      step(pc),a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               lea.l      von(pc),a4
               move.l     d1,(a4)       ; neue Anfangsposition
               lea.l      bbis(pc),a4
               lea.l      bis(pc),a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        xip_back2
xiendplay:     lea.l      playbyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xiplooptst:    btst       #0,d3
               beq.s      xiendplay
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        xip_back2
xipmidi:       movem.l    d1-d7/a0-a4,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               tst.w      d0
               beq.s      xipnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      xipmidi2      ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      xipnomidi
xipmidi2:      cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      xipmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      xipnomidi
xipmidi3:      move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      xipmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      xipmidi6
xipmidi3b:     move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      xipnomidi
xipmidi4:      cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      xipmidi3      ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      xipnomidi
xipmidi5:      cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      xipmidi3b     ; wenn nein, Datenwort lîschen
               bra.s      xipmidiex     ; Abbruch, da NOTE OFF !
xipmidi6:      cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      xipmidi3b     ; wenn nein, Datenwort lîschen
               tst.b      2(a0)         ; Velocity ist Null ?
               bne.s      xipmidi3b     ; wenn nein, Datenwort lîschen
               bra.s      xipmidiex     ; Abbruch, da NOTE ON und Velo=Null !
xipnomidi:     move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #0,d0
               rts        
xipmidiex:     move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #1,d0
               rts        

init_xmixplay: rts        

; d4=lowest leftbyte, d5=lowest rightbyte, a2=startradresse
testuser:      tst.w      asrc          ; digital ?
               beq.s      testusr2
               rts        
testusr2:      move.l     d7,-(sp)
               btst       #0,d4         ; Userstatus-Syncbit gesetzt ?
               beq.s      yesustart
               btst       #0,d5         ; Userstatus-Startbit gesetzt ?
               beq.s      notustart
               move.w     usyncz,d7
               tst.w      d7            ; erster Sync ?
               beq.s      firstusync
nfirstusync:   cmpi.w     #5,d7         ; 5 Syncs erreicht ?
               beq.s      yesustart
               addi.w     #1,d7         ; SynczÑhler um 1 erhîhen
               move.w     d7,usyncz
               cmpi.w     #5,d7         ; 5 Syncs erreicht ?
               bne.s      yesustart
               move.l     ustartm,d7
               move.l     d7,ustartp    ; Sync-Startadresse Åbergeben
               bra.s      yesustart
notustart:     move.w     #0,usyncz
yesustart:     move.l     (sp)+,d7
               rts        
firstusync:    addi.w     #1,d7         ; SynczÑhler um 1 erhîhen
               move.w     d7,usyncz
               move.l     a2,d7
               subq.l     #6,d7
               move.l     d7,ustartm    ; Sync-Startadresse merken
               bra.s      yesustart

init_xmemplay: move.w     (a0)+,d0      ; Code der record-art
               tst.w      d0
               beq.s      xplayinit
               cmpi.w     #1,d0
               beq        xdplayinit
               cmpi.w     #2,d0
               beq        xplayinit8
               cmpi.w     #3,d0
               beq        xplayinit16
               cmpi.w     #10,d0
               beq        ds_play
xplayinit:     lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      bis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      xmem2b
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
xmem2b:        lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               btst       #0,modr24
               beq.s      xmem2c
               asr.w      #1,d0
xmem2c:        subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      pimode(pc),a2
               move.l     #9,(a2)
               bsr        initplugp
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

init_xmemp4:   lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von d1
               move.l     d1,(a2)       ; von d1
               lea.l      bvon(pc),a3
               move.l     d1,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang d2
               lea.l      dvon(pc),a2
               move.l     (a0)+,d3      ; von d3
               move.l     d3,(a2)       ; von d3
               lea.l      dbvon(pc),a3
               move.l     d3,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      dvon2(pc),a2
               move.l     (a0)+,d4      ; zweiter Speicherbereich Anfang d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Anfang d4
               move.l     (a0)+,d5      ; lÑnge der Speicherbereiche
               lea.l      bis(pc),a2
               add.l      d5,d1
               move.l     d1,(a2)       ; bis d1
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d5,d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Ende
               lea.l      dbis(pc),a2
               add.l      d5,d3
               move.l     d3,(a2)       ; bis d1
               lea.l      dbbis(pc),a3
               move.l     d3,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      dbis2(pc),a2
               add.l      d5,d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Ende
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               lea.l      dplaybyte(pc),a5        ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen fifo
               move.l     d0,24(a5)     ; Playposition setzen dsp
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               lea.l      dendcount(pc),a5
               move.l     (a0)+,(a2)    ; Zaehler endwert fifo
               move.l     (a2),(a5)     ; Zaehler endwert dsp
               lea.l      fileart(pc),a2
               lea.l      dfileart(pc),a5
               move.w     (a0)+,(a2)    ; fileart=3=WAV fifo
               move.w     (a2),(a5)     ; fileart dsp
               lea.l      dstep(pc),a5
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4 fifo
               move.l     d0,(a5)       ; Anzahl der For/Backstep d4 dsp
               lea.l      dmode(pc),a5
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a5)       ; mode dsp
               btst       #2,d0
               beq.s      xmemv3
               lea.l      midisuch(pc),a2
               lea.l      dmidisuch(pc),a5
               move.w     (a0)+,(a2)    ; midi d0
               move.w     (a2),(a5)
xmemv3:        lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      dfifo(pc),a2
               move.l     #$7ff,(a2)    ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      dmidiw(pc),a2
               move.l     #0,(a2)
               lea.l      dloop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      dcrosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               lea.l      dplaybyte(pc),a5        ; RÅckgabewerte-Liste
               move.l     #0,8(a5)      ; Break lîschen
               move.l     #0,4(a5)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a5)     ; Fehler lîschen
               move.l     #0,16(a5)     ; Peak-RÅckgabewert lîschen
               lea.l      pimode(pc),a2
               move.l     #22,(a2)
               lea.l      drimode(pc),a2
               move.l     #0,(a2)
               lea.l      dpimode(pc),a2
               move.l     #33,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

xmemplay:      movea.l    von(pc),a3    ; von a3
               move.l     bis(pc),d1    ; bis d1
               move.l     step(pc),d4   ; Anzahl der For/Backstep d4
               move.w     mode(pc),d3   ; mode (Bit0=Loop,Bit1=cross,Bit2=Midi)
               move.l     fifo(pc),d2   ; fifolen (len/2/4-1) bei 8192byte=$3ff
               move.w     midisuch(pc),d0         ; midi
               lea.l      backup(pc),a4
               clr.l      (a4)
               movea.l    vmestart(pc),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    16(a5),a6     ; Peak-RÅckgabewert holen
               cmpa.l     d1,a2
               beq        xp_back
xpfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrlx
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      nowrlx
               addq.l     #1,12(a5)     ;Fehler +1
nowrlx:        move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               beq.s      xpfill
xpcopyanf:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
               btst       #0,modr24
               bne        xpcopy24

               tst.w      pluglistp
               beq        xmempnoplg16  ; CopyRoutine 16bit play ohne Plugins

xpcopy16:      movem.l    d2-d4,-(sp)
ixmuseplug:    cmpi.w     #3,fileart
               bne.s      xnowave
               move.b     1(a2),dummy
               move.b     (a2),dummy+1
               move.w     dummy,-(sp)
               move.b     (a2)+,d6
               move.b     (a2)+,d7
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.b     1(a2),dummy
               move.b     (a2),dummy+1
               move.w     dummy,-(sp)
               move.b     (a2)+,d4
               move.b     (a2)+,d5
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bra.s      xcope
xnowave:       move.w     (a2),-(sp)
               move.w     #0,-(sp)
               move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.w     (a2),-(sp)
               move.w     #0,-(sp)
               move.b     (a2)+,d5
               move.b     (a2)+,d4
xcope:         bsr        ppeakcmp
               bsr        workplugsp    ; plugins aufrufen
               btst       #0,playch
               bne.s      ixmempl
               move.b     #0,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               bra.s      ixmempl2
ixmempl:       move.b     6(sp),2(a1)   ; Linker Kanal,HighByte holen
               move.b     7(sp),2(a1)   ; Linker Kanal,LowByte holen
ixmempl2:      btst       #1,playch
               bne.s      ixmempr
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      ixmempr2
ixmempr:       move.b     2(sp),(a1)    ; Rechter Kanal,HighByte holen
               move.b     3(sp),(a1)    ; Rechter Kanal,LowByte holen
ixmempr2:      addq.l     #8,sp
               addq.l     #4,24(a5)     ; Playposition
               movem.l    (sp)+,d2-d4
               adda.l     d4,a2
               add.l      d4,24(a5)
               move.w     mode,d3
               btst       #0,d3         ; loop ? dann kein max countwert
               bne.s      xcope3v
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendplay2
xcope3v:       cmpa.l     d1,a2
               beq        xplayend
               dbra       d0,xpcopy16
               bra        xp_back
xpcopy24:      tst.w      pluglistp
               beq        xmempnoplg24
ixmuseplug2:   movem.l    d2-d4,-(sp)
               cmpi.w     #3,fileart
               bne.s      xnowave24
               move.b     (a2)+,d2
               move.b     (a2)+,d6
               move.b     (a2)+,d7
               move.b     d2,3(a4)
               move.b     d6,2(a4)
               move.b     d7,1(a4)
               move.l     (a4),-(sp)    ; linken Kanal holen
               move.b     (a2)+,d3
               move.b     (a2)+,d4
               move.b     (a2)+,d5
               move.b     d3,3(a4)
               move.b     d4,2(a4)
               move.b     d5,1(a4)
               move.l     (a4),-(sp)    ; Rechter Kanal holen
               bra.s      xcope24
xnowave24:     move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.b     (a2)+,d2
               move.b     d7,1(a4)
               move.b     d6,2(a4)
               move.b     d2,3(a4)
               move.l     (a4),-(sp)    ; linken Kanal holen
               move.b     (a2)+,d5
               move.b     (a2)+,d4
               move.b     (a2)+,d3
               move.b     d5,1(a4)
               move.b     d4,2(a4)
               move.b     d3,3(a4)
               move.l     (a4),-(sp)    ; Rechter Kanal holen
xcope24:       bsr        ppeakcmp
               bsr        workplugsp    ; plugins aufrufen
               btst       #0,playch
               bne.s      ixmemplb
               move.b     #0,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               bra.s      ixmempl2b
ixmemplb:      move.b     5(sp),2(a1)   ; Linker Kanal,HighByte senden,A1=1
               move.b     6(sp),2(a1)   ; Linker Kanal,MidByte senden,A1=1
               move.b     7(sp),2(a1)   ; Linker Kanal,LowByte senden,A1=1
ixmempl2b:     btst       #1,playch
               bne.s      ixmemprb
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      ixmempr2b
ixmemprb:      move.b     1(sp),(a1)    ; Linker Kanal,HighByte senden,A1=0
               move.b     2(sp),(a1)    ; Linker Kanal,MidByte senden,A1=0
               move.b     3(sp),(a1)    ; Linker Kanal,LowByte senden,A1=0
ixmempr2b:     addq.l     #8,sp
ixmempr2c:     addq.l     #6,24(a5)     ; Playposition
               movem.l    (sp)+,d2-d4
               adda.l     d4,a2
               add.l      d4,24(a5)
               move.w     mode,d3
               btst       #0,d3         ; loop ? dann kein max countwert
               bne.s      xcope3
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendplay2
xcope3:        cmpa.l     d1,a2
               beq.s      xplayend
               dbra       d0,ixmuseplug2
xp_back:       move.l     a2,von        ; Playposition retten
xp_back2:      lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
;               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      xp_back2b     ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
xp_back2b:     movem.l    (sp)+,d0-d7/a0-a6
               rte        
xplayend:      moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
;               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      xplayend2     ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
xplayend2:     move.l     d6,loop       ; Anzahl loops sichern
               move.l     a2,von        ; Playposition retten
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               tst.l      4(a5)         ; Memflag abfragen
               bne.s      memt1
memt2:         move.l     von2,d0       ; zweiter Memblock Start
               move.l     d0,von        ; von
               move.l     bis2,d0       ; zweiter Memblock Ende
               move.l     d0,bis        ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      memte
memt1:         move.l     bvon,d0       ; erster Memblock Start
               move.l     d0,von        ; von
               move.l     bbis,d0       ; erster Memblock Ende
               move.l     d0,bis        ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
memte:         bra        xp_back2
               btst       #1,d3         ; crossplay ?
               beq        xplooptst     ; wenn nein, ueberspringen
               lea.l      crosflag(pc),a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      xbktofor
xfortobk:      addq.l     #8,d4
               neg.l      d4
               move.l     d4,step       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               move.l     d1,von        ; neue Endposition
               move.l     bvon,d1
               addq.l     #4,d1
               move.l     d1,bis        ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra        xp_back2
xbktofor:      neg.l      d4
               subq.l     #8,d4
               move.l     d4,step       ; Anzahl der For/Backstep d4
               subq.l     #4,d1
               move.l     d1,von        ; neue Anfangsposition
               lea.l      bbis(pc),a4
               lea.l      bis(pc),a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        xp_back2
xendplay:      lea.l      playbyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
xendplayb:     movem.l    (sp)+,d0-d7/a0-a6
               rte        
xendplay2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
;               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      xendplay3     ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
xendplay3:     move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xplooptst:     btst       #0,d3
               beq.s      xendplay
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        xp_back2
xpmidi:        movem.l    d1-d7/a0-a4,-(sp)
               lea.l      midisuch(pc),a0
               move.w     (a0),d2
               move.w     d2,-(sp)
               move.w     #3,-(sp)      ; MIDI
               move.w     #1,-(sp)      ; Bconstat
               trap       #13
               addq.l     #4,sp
               tst.w      d0
               beq.s      xpnomidi
               move.w     #3,-(sp)
               move.w     #2,-(sp)      ; Bconin
               trap       #13
               addq.l     #4,sp
               move.w     (sp)+,d2
               move.w     d2,-(sp)
               lea.l      midiw(pc),a0
               btst       #7,d0
               beq.s      xpmidi2       ; Daten oder Befehl ?
               asr.w      #8,d2         ; Channel im oberen Byte des Wortes
               sub.b      d2,d0         ; Channel vom Befehl abziehen
               move.b     d0,(a0)       ; Befehl schreiben
               bra.s      xpnomidi
xpmidi2:       cmp.b      d2,d0         ; Noten-DATA ?
               beq.s      xpmidi4
               cmp.b      1(a0),d2      ; Noten-data schon gewesen und korrekt ?
               bne.s      xpnomidi
xpmidi3:       move.b     d0,2(a0)      ; Velocitywert schreiben
               cmpi.b     #$80,(a0)     ; NOTE OFF ?
               beq.s      xpmidi5
               cmpi.b     #$90,(a0)     ; NOTE ON ?
               beq.s      xpmidi6
xpmidi3b:      move.l     #0,(a0)       ; Datenwort lîschen
               bra.s      xpnomidi
xpmidi4:       cmp.b      1(a0),d2      ; Noten-DATA schon gewesen ?
               beq.s      xpmidi3       ; dann ist es nicht Note sondern Velocity
               move.b     d0,1(a0)      ; Notenwert schreiben
               bra.s      xpnomidi
xpmidi5:       cmp.b      1(a0),d2      ; NOTE OFF und Note OK ?
               bne.s      xpmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      xpmidiex      ; Abbruch, da NOTE OFF !
xpmidi6:       cmp.b      1(a0),d2      ; NOTE ON und Note OK ?
               bne.s      xpmidi3b      ; wenn nein, Datenwort lîschen
               tst.b      2(a0)         ; Velocity ist Null ?
               bne.s      xpmidi3b      ; wenn nein, Datenwort lîschen
               bra.s      xpmidiex      ; Abbruch, da NOTE ON und Velo=Null !
xpnomidi:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #0,d0
               rts        
xpmidiex:      move.w     (sp)+,d2
               movem.l    (sp)+,d1-d7/a0-a4
               moveq.l    #1,d0
               rts        

xmempnoplg24:  movem.w    d0/d2-d4,-(sp)
               move.b     playch,d0
               cmpi.w     #3,fileart
               bne.s      xnowaveu24
               move.b     (a2)+,d2
               move.b     (a2)+,d6
               move.b     (a2)+,d7
               move.b     (a2)+,d3
               move.b     (a2)+,d4
               move.b     (a2)+,d5
               bra.s      xcopeu24
xnowaveu24:    move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.b     (a2)+,d2
               move.b     (a2)+,d5
               move.b     (a2)+,d4
               move.b     (a2)+,d3
xcopeu24:      btst       #0,d0
               bne.s      ixmemplbu
               move.b     #0,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               bra.s      ixmempl2bu
ixmemplbu:     move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,MidByte senden,A1=1
               move.b     d2,2(a1)      ; Linker Kanal,LowByte senden,A1=1
ixmempl2bu:    btst       #1,d0
               bne.s      ixmemprbu
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      ixmemprbux
ixmemprbu:     move.b     d5,(a1)       ; Linker Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Linker Kanal,MidByte senden,A1=0
               move.b     d3,(a1)       ; Linker Kanal,LowByte senden,A1=0
ixmemprbux:    bsr        ppeakcmp
               addq.l     #6,24(a5)     ; Playposition
               movem.w    (sp)+,d0/d2-d4
               adda.l     d4,a2
               add.l      d4,24(a5)
               move.w     mode,d3
               btst       #0,d3         ; loop ? dann kein max countwert
               bne.s      xcope3y
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendplay2
xcope3y:       cmpa.l     d1,a2
               beq        xplayend
               dbra       d0,xmempnoplg24
               bra        xp_back

xmempnoplg16:  movem.w    d2/d4,-(sp)
               move.b     playch,d2
               cmpi.w     #3,fileart
               bne.s      xnowaveu
               move.b     (a2)+,d6
               move.b     (a2)+,d7
               move.b     (a2)+,d4
               move.b     (a2)+,d5
               bra.s      xcopeu
xnowaveu:      move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.b     (a2)+,d5
               move.b     (a2)+,d4
xcopeu:        btst       #0,d2
               bne.s      ixmemplu
               clr.b      2(a1)         ; Linker Kanal,HighByte senden,A1=1
               clr.b      2(a1)         ; Linker Kanal,LowByte senden,A1=1
               bra.s      ixmempl2u
ixmemplu:      move.b     d7,2(a1)      ; Linker Kanal,HighByte holen
               move.b     d6,2(a1)      ; Linker Kanal,LowByte holen
ixmempl2u:     btst       #1,d2
               bne.s      ixmempru
               clr.b      (a1)          ; Linker Kanal,HighByte senden,A1=1
               clr.b      (a1)          ; Linker Kanal,LowByte senden,A1=1
               bra.s      ixmemprux
ixmempru:      move.b     d5,(a1)       ; Rechter Kanal,HighByte holen
               move.b     d4,(a1)       ; Rechter Kanal,LowByte holen
ixmemprux:     bsr        ppeakcmp
               addq.l     #4,24(a5)     ; Playposition
               movem.w    (sp)+,d2/d4
               adda.l     d4,a2
               add.l      d4,24(a5)
               move.w     mode,d3
               btst       #0,d3         ; loop ? dann kein max countwert
               bne.s      xcope3x
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendplay2
xcope3x:       cmpa.l     d1,a2
               beq        xplayend
               dbra       d0,xmempnoplg16
               bra        xp_back

recdummy:      move.l     #2047,d0      ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
               subq.l     #1,d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               adda.l     #$ff,a6
recdummy2:     move.w     (a6),d7       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               dbra       d0,recdummy2
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

playdummy:     move.l     #2047,d0      ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
               subq.l     #1,d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               adda.l     #$ff,a6
playdummy2:    move.w     #0,(a6)       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               dbra       d0,playdummy2
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

setadcdac:     move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               lea.l      dmarec(pc),a3 ; DMA-Mode restaurieren
               move.w     (a3),d0
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               lea.l      dacrec(pc),a3 ; DAC-Mode restaurieren
               move.w     (a3),d0
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPCARD-OUT-auswahl
               lea.l      cardrec(pc),a3          ; DSP-Mode restaurieren
               move.w     (a3),d0
               bsr        matinsel
               rts        

init_emuladc8: move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq        getmadc8
               tst.w      d0
               bne.s      initadc8a
               bsr        no_emuladc8
               move.w     #0,emuladc
               move.w     #0,nopeaks
               rts        
initadc8a:     move.w     d0,emuladc
initadc8b:     tst.w      emuladc
               beq        no_emuladc8
               move.w     #1,emuladc
               cmpi.w     #2,playmod    ; playmode=Achtkanal?
               bne        exemuladc8    ; wenn nein,fertig und raus hier...
               tst.w      recmod        ; recmode=Stereo ?
               bne        exemuladc8    ; wenn nein,fertig und raus hier...

               lea.l      stack,a0
               move.w     #0,(a0)       ; intmode
               bsr        intact
               move.w     #1,emulact8

               move.w     #1,endless
               move.w     #1,nopeaks
               move.w     #0,-(sp)
               move.w     #$86,-(sp)
               trap       #GEMDOS       ; montrack
               addq.l     #4,sp
               move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               bsr        matinsel
;               move.w     #2,dmarec
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; mit DSPCARD-IN verbinden
               bsr        matinsel
;               move.w     #2,dacrec
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPCARD-OUT-auswahl
               move.w     #1,d0         ; mit DMAPLAY verbinden
               bsr        matinsel
;               move.w     #2,dsprec
;               lea.l      vmestart(pc),a6
;               movea.l    (a6),a6
;               move.b     #13,$214(a6)
               lea.l      stack,a0
               move.w     #0,(a0)+      ; select
               lea.l      recbuf,a1
               move.l     a1,(a0)+      ; buffer1
               lea.l      recbuf2,a1
               move.l     a1,(a0)+      ; buffer2
               move.l     #recbuflen,(a0)+        ; bufferlen
               move.l     #4,(a0)+      ; endcount
               move.w     #0,(a0)+      ; fileart
               lea.l      epeakbuf,a1
               move.l     a1,(a0)+      ; peakbuf
               lea.l      stack,a0
               bsr        init_xmemrec
               lea.l      stack,a0
               move.w     #2,(a0)+      ; select
               lea.l      recbuf2,a1
               move.l     a1,(a0)+      ; buffer1
               lea.l      recbuf,a1
               move.l     a1,(a0)+      ; buffer2
               move.l     #recbuflen,(a0)+        ; bufferlen
               move.l     #0,(a0)+      ;count
               move.l     #4,(a0)+      ; endcount
               move.w     #0,(a0)+      ; fileart
               move.w     #0,(a0)+      ; step
               move.w     #0,(a0)+      ; mode
               lea.l      stack,a0
               bsr        init_xmemplay
               lea.l      pimode(pc),a2
               move.l     #28,(a2)
               lea.l      stack,a0
               move.w     #3,(a0)       ; intmode
               bsr        intact
exemuladc8:    lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        
getmadc8:      clr.l      d0
               move.w     emulact8,d0
               swap.w     d0
               move.w     emuladc,d0
               rts        

no_emuladc8:   tst.w      emuladc
               beq.s      no_emuladc8b
               lea.l      stack,a0
               move.w     #0,(a0)       ; intmode
               bsr        intact
               bsr        setadcdac
               move.w     #0,emulact8
               rts        
no_emuladc8b:  move.w     #0,emuladc
               lea.l      stack,a0
               move.w     #0,(a0)       ; intmode
               bsr        intact
               move.w     #0,emulact8
               rts        

adcemu8:       lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    16(a5),a6     ; Peak-RÅckgabewert holen
               cmpa.l     d1,a2
               beq        aep_back
aepfill:       move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      aenowrlx
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      aenowrlx
               addi.l     #1,12(a5)     ;Fehler +1
aenowrlx:      move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      aepcopyanf
               bra.s      aepfill
aepcopyanf:    move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
aepcopy:       move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               move.w     #0,d7
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d7,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d7,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d7,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d7,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d7,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d7,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               addq.l     #4,24(a5)     ; Playposition
               tst.w      endless
               bne.s      aep_backa
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        aeendplay
aep_backa:     cmpa.l     d1,a2
               beq.s      aeplayend
               dbra       d0,aepcopy
aep_back:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
aep_back2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      aep_back3     ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
aep_back3:     movem.l    (sp)+,d0-d7/a0-a6
               rte        
aeplayend:     moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      aeplayend2    ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
aeplayend2:    lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      aememt1
aememt2:       lea.l      von2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      aememte
aememt1:       lea.l      bvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
aememte:       bra        aep_back2
aeendplay:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      aeendplay2    ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
aeendplay2:    move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

init_xmemrec:  move.w     (a0)+,d0      ; Code der record-art
               tst.w      d0
               beq.s      xrecinit
               cmpi.w     #1,d0
               beq        xdrecinit
               cmpi.w     #2,d0
               beq        xrecinit8
               cmpi.w     #3,d0
               beq        xrecinit16
               cmpi.w     #10,d0        ; external8
               beq        ds_rec
               cmpi.w     #11,d0        ; adc8
               beq        ds_rec
xrecinit:      lea.l      rvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      rbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      rvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      rbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      rbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      rendcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.l      #3,d0
               btst       #0,modr24
               beq.s      xrecini24
               asr.l      #1,d0
xrecini24:     subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      rpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               move.l     #0,pnleft
               move.l     #0,pnright
               move.w     #0,pncount
               move.l     #0,ustartp
               move.l     #0,ustartm
               move.w     #0,usyncz
               btst       #0,modr24
               beq.s      xrecini16
               bsr        pushaesr
xrecini16:     lea.l      rimode(pc),a2
               move.l     #10,(a2)
               bsr        initplugr
               lea.l      recbyte,a4    ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

init_xmemr4:   lea.l      rvon(pc),a2
               move.l     (a0)+,d1      ; von d1
               move.l     d1,(a2)       ; von d1
               lea.l      rbvon(pc),a3
               move.l     d1,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      rvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang d2
               lea.l      rdvon(pc),a2
               move.l     (a0)+,d3      ; von d3
               move.l     d3,(a2)       ; von d3
               lea.l      rdbvon(pc),a3
               move.l     d3,(a3)       ; von a3 retten fÅr crossplay und loop
               lea.l      rdvon2(pc),a2
               move.l     (a0)+,d4      ; zweiter Speicherbereich Anfang d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Anfang d4
               move.l     (a0)+,d5      ; lÑnge der Speicherbereiche
               lea.l      rbis(pc),a2
               add.l      d5,d1
               move.l     d1,(a2)       ; bis d1
               lea.l      rbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rbis2(pc),a2
               add.l      d5,d2
               move.l     d2,(a2)       ; zweiter Speicherbereich Ende
               lea.l      rdbis(pc),a2
               add.l      d5,d3
               move.l     d3,(a2)       ; bis d1
               lea.l      rdbbis(pc),a3
               move.l     d3,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rdbis2(pc),a2
               add.l      d5,d4
               move.l     d4,(a2)       ; zweiter Speicherbereich Ende
               lea.l      rendcount(pc),a2
               lea.l      rdendcount(pc),a3
               move.l     (a0)+,(a2)    ; Zaehler endwert fuer fifo
               move.l     (a2),(a3)     ; Zaehler endwert fuer dsp
               lea.l      rfileart(pc),a2
               lea.l      rdfileart(pc),a3
               move.w     (a0)+,(a2)    ; fileart=3=WAV fuer fifo
               move.w     (a2),(a3)     ; fileart=3=WAV fuer dsp
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      rdfifo(pc),a2
               move.l     #$1ff,(a2)    ; dspbuffer 2048 (/4=$200) Byte
               lea.l      rpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      rdpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      drecbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      stack,a0
               move.w     #1,(a0)       ; input=adc
               bsr        digana
               lea.l      stack,a0
               move.w     #3,(a0)+      ; source=adc
               move.w     #3,(a0)+      ; adc->dmarec und dsprec
               move.w     #0,(a0)+      ; srcclk=normal
               move.w     #0,(a0)+      ; prescale=digital sync
               move.w     #1,(a0)       ; protocol
               lea.l      stack,a0
               bsr        devconnect
               lea.l      rimode(pc),a2
               move.l     #23,(a2)
               lea.l      dpimode(pc),a2
               move.l     #0,(a2)
               lea.l      drimode(pc),a2
               move.l     #34,(a2)
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     a4,d0
               rts        

xmemrec:       lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      xmemre2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xmemre2:       lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               lea.l      rpeakmerk(pc),a2
               move.l     16(a5),(a2)   ; Peakwert holen
               movea.l    rvon(pc),a3   ; von a3
               move.l     rbis(pc),d1   ; bis d1
               move.l     #0,dummy
               movea.l    vmestart(pc),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               movea.l    a3,a2
xranf:         move.b     (a0),d0
               btst       #2,d0         ; RECORD-FIFO voll ?
               bne.s      xnordful
               tst.l      24(a5)        ; Recposition abfragen
               beq.s      xnordful
               addq.l     #1,12(a5)     ;Fehler +1
xnordful:      andi.b     #2,d0         ; FIFO mehr als halbvoll ?
               beq.s      xrstrt        ; wenn ja, daten einlesen
               bra.s      xranf
xrstrt:        movea.l    pnleft,a0     ; Peak pos/neg left lîschen
               movea.l    pnright,a3    ; Peak pos/neg right lîschen
               movea.w    pncount,a4
xrcopy:        move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
               btst       #0,modr24
               bne        xrcopy24
               tst.w      pluglistr
               beq        xmemrnoplg16
               moveq.l    #8,d2
xrcopy2:       move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        xrcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq        xrcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne        xrcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne        xrcopy3a      ; fehlerhafte Daten ?
               cmpi.w     #3,rfileart
               bne.s      xnorwave
               move.b     d6,dummy
               move.b     d7,dummy+1
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.b     d4,dummy
               move.b     d5,dummy+1
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Rechter Kanal holen
               bra.s      xrcope
xnorwave:      move.b     d7,dummy
               move.b     d6,dummy+1
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Linker Kanal holen
               move.b     d5,dummy
               move.b     d4,dummy+1
               move.w     dummy,-(sp)
               move.w     #0,-(sp)      ; Rechter Kanal holen
xrcope:        move.l     d1,-(sp)
               bsr        rpeakcmp
               move.l     (sp)+,d1
               bsr        workplugsr    ; plugins aufrufen
               move.w     6(sp),(a2)+   ; Linker Kanal,HighByte senden,A1=1
               move.w     2(sp),(a2)+   ; Rechter Kanal,HighByte senden,A1=0
               addq.l     #8,sp
xrcopeux:      addq.l     #4,24(a5)     ; Recposition
               tst.w      endless
               bne.s      xrcopeba
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrec2
xrcopeba:      cmpa.l     d1,a2         ; Speicher voll ?
               beq        xrweg
xrcopy3a:      dbra       d0,xrcopy2
               bra        xr_back
xrcopy24:      tst.w      pluglistr
               beq        xmemrnoplg24
xrcop24:       move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       #8,d7
               beq        xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       #8,d6
               beq        xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d3       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       #8,d3
               beq        xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       #8,d5
               bne        xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       #8,d4
               bne        xrcopy3       ; fehlerhafte Daten ?
               move.w     (a1),d2       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       #8,d2
               bne        xrcopy3       ; fehlerhafte Daten ?
               cmpi.w     #3,rfileart
               bne.s      xnorwav24
               move.b     d3,dummy+1
               move.b     d6,dummy+2
               move.b     d7,dummy+3
               move.l     dummy,-(sp)   ; linken Kanal holen
               move.b     d2,dummy+1
               move.b     d4,dummy+2
               move.b     d5,dummy+3
               move.l     dummy,-(sp)   ; rechten Kanal holen
               bra.s      xrcope24
xnorwav24:     move.b     d7,dummy+1
               move.b     d6,dummy+2
               move.b     d3,dummy+3
               move.l     dummy,-(sp)   ; linken Kanal holen
               move.b     d5,dummy+1
               move.b     d4,dummy+2
               move.b     d2,dummy+3
               move.l     dummy,-(sp)   ; rechten Kanal holen
xrcope24:      movem.w    d4/d5,-(sp)
               move.w     d3,d4
               move.w     d2,d5
               bsr        testuser
               movem.w    (sp)+,d4/d5
               move.l     d1,-(sp)
               bsr        rpeakcmp
               move.l     (sp)+,d1
               bsr        workplugsr    ; plugins aufrufen
               move.b     5(sp),(a2)+   ; Linker Kanal,HighByte
               move.b     6(sp),(a2)+   ; Linker Kanal,MidByte
               move.b     7(sp),(a2)+   ; Linker Kanal,LowByte
               move.b     1(sp),(a2)+   ; Linker Kanal,HighByte
               move.b     2(sp),(a2)+   ; Linker Kanal,MidByte
               move.b     3(sp),(a2)+   ; Linker Kanal,LowByte
               addq.l     #8,sp
xrcopeux2:     addq.l     #6,24(a5)     ; Recposition
               tst.w      endless
               bne.s      xrcopeb
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrec2
xrcopeb:       cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      xrweg
xrcopy3:       dbra       d0,xrcop24
xr_back:       move.l     a0,pnleft
               move.l     a3,pnright
               move.w     a4,pncount
               move.l     a2,rvon       ; Recposition retten
xr_back2:      move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakbuf(pc),a3         ; Peakbuffer-Adresse holen
               move.l     (a3),20(a5)   ; aktuelle Peakbuffer-Adresse
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      xr_back2b     ; nein ?, dann weiter
               move.l     (a4),peakvalue
               clr.l      16(a5)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
xr_back2b:     movem.l    (sp)+,d0-d7/a0-a6
               rte        
xrweg:         move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      memr1
memr2:         move.l     rvon2,d0      ; zweiter Memblock Start
               move.l     d0,rvon       ; von
               move.l     rbis2,d0      ; zweiter Memblock Ende
               move.l     d0,rbis       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      xr_back2
memr1:         move.l     rbvon,d0      ; erster Memblock Start
               move.l     d0,rvon       ; von
               move.l     rbbis,d0      ; erster Memblock Ende
               move.l     d0,rbis       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      xr_back2
xendrec2:      move.l     a2,rvon       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               movea.l    rpeakbuf(pc),a3         ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      xendrec2b     ; nein ?, dann weiter
               move.l     (a4),peakvalue
               clr.l      16(a5)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
xendrec2b:     move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
xendrec3b:     movem.l    (sp)+,d0-d7/a0-a6
               rte        

xmemrnoplg24:  cmpi.w     #3,rfileart   ;wav ?
               beq        pslow24wav
               move.l     d1,-(sp)      ; ohne plugins
               move.w     #8,d1
               clr.w      rett
               cmp.w      d1,d0         ; kleiner als 8 DurchlÑufe ?
               blt.s      pslow24b
               sub.w      d1,d0
               move.w     d0,rett
               move.w     #7,d0
               bra.s      pslow24b
pslow24:       move.l     d1,-(sp)
               move.w     #8,d1
pslow24b:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d1,d7
               beq        xrcopy3y      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d1,d6
               beq        xrcopy3y      ; fehlerhafte Daten ?
               move.w     (a1),d3       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d1,d3
               beq        xrcopy3y      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d1,d5
               bne        xrcopy3y      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d1,d4
               bne        xrcopy3y      ; fehlerhafte Daten ?
               move.w     (a1),d2       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d1,d2
               bne        xrcopy3y      ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d3,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               move.b     d2,(a2)+
               movem.w    d4/d5,-(sp)
               move.w     d3,d4
               move.w     d2,d5
               bsr        testuser
               movem.w    (sp)+,d4/d5
               bsr        rpeakcmp
               move.l     (sp)+,d1
               addq.l     #6,24(a5)     ; Recposition
               tst.w      endless
               bne.s      xrcopebx
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrec2
xrcopebx:      cmpa.l     d1,a2         ; Speicher voll ?
               beq        xrweg
xrcopy3x:      dbra       d0,pslow24
               move.w     rett,d0
               tst.w      d0
               bne.s      pfast24       ; mehr als 8 durchlÑufe ?
               bra        xr_back
xrcopy3y:      move.l     (sp)+,d1
               dbra       d0,pslow24
               move.w     rett,d0
               tst.w      d0
               beq        xr_back       ; mehr als 8 durchlÑufe ?
pfast24:       move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               move.w     (a1),d3       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               move.w     (a1),d2       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d3,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               move.b     d2,(a2)+
               movem.w    d4/d5,-(sp)
               move.w     d3,d4
               move.w     d2,d5
               bsr        testuser
               movem.w    (sp)+,d4/d5
               move.l     d1,-(sp)
               bsr        rpeakcmp
               move.l     (sp)+,d1
               addq.l     #6,24(a5)     ; Recposition
               tst.w      endless
               bne.s      xrcopebxb
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrec2
xrcopebxb:     cmpa.l     d1,a2         ; Speicher voll ?
               beq        xrweg
               dbra       d0,pfast24
               bra        xr_back
pslow24wav:    move.l     d1,-(sp)      ; ohne plugins
               moveq.l    #8,d1         ; als wav ohne plugins
               clr.w      rett
               cmp.w      d1,d0         ; kleiner als 8 DurchlÑufe ?
               blt.s      pslow24bw
               sub.w      d1,d0
               move.w     d0,rett
               move.w     #7,d0
               bra.s      pslow24bw
pslow24w:      move.l     d1,-(sp)
pslow24bw:     move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d1,d7
               beq        xrcopy3yw     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d1,d6
               beq        xrcopy3yw     ; fehlerhafte Daten ?
               move.w     (a1),d3       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d1,d3
               beq        xrcopy3yw     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d1,d5
               bne        xrcopy3yw     ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d1,d4
               bne        xrcopy3yw     ; fehlerhafte Daten ?
               move.w     (a1),d2       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d1,d2
               bne        xrcopy3yw     ; fehlerhafte Daten ?
               move.b     d3,(a2)+
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d2,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               movem.w    d4/d5,-(sp)
               move.w     d3,d4
               move.w     d2,d5
               bsr        testuser
               movem.w    (sp)+,d4/d5
               bsr        rpeakcmp
               move.l     (sp)+,d1
               addq.l     #6,24(a5)     ; Recposition
               tst.w      endless
               bne.s      xrcopebxw
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrec2
xrcopebxw:     cmpa.l     d1,a2         ; Speicher voll ?
               beq        xrweg
xrcopy3xw:     dbra       d0,pslow24w
               move.w     rett,d0
               tst.w      d0
               bne.s      pfast24wav    ; mehr als 8 durchlÑufe ?
               bra        xr_back
xrcopy3yw:     move.l     (sp)+,d1
               dbra       d0,pslow24w
               move.w     rett,d0
               tst.w      d0
               beq        xr_back       ; mehr als 8 durchlÑufe ?
pfast24wav:    move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               move.w     (a1),d3       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               move.w     (a1),d2       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               move.b     d3,(a2)+
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d2,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               movem.w    d4/d5,-(sp)
               move.w     d3,d4
               move.w     d2,d5
               bsr        testuser
               movem.w    (sp)+,d4/d5
               move.l     d1,-(sp)
               bsr        rpeakcmp
               move.l     (sp)+,d1
               addq.l     #6,24(a5)     ; Recposition
               tst.w      endless
               bne.s      xrcopebxbw
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrec2
xrcopebxbw:    cmpa.l     d1,a2         ; Speicher voll ?
               beq        xrweg
               dbra       d0,pfast24wav
               bra        xr_back

xmemrnoplg16:  moveq.l    #8,d2         ; ohne plugins
               clr.w      rett
               cmp.w      d2,d0         ; kleiner als 8 DurchlÑufe ?
               blt.s      pslow16
               sub.w      d2,d0
               move.w     d0,rett
               move.w     #7,d0
pslow16:       cmpi.w     #3,rfileart   ; kein wav
               beq        pslow16wav
pslow16b:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        xrcopy3ax     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq        xrcopy3ax     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne        xrcopy3ax     ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne        xrcopy3ax     ; fehlerhafte Daten ?
               move.l     d1,d3
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               bsr        rpeakcmp
               move.l     d3,d1
               addq.l     #4,24(a5)     ; Recposition
               tst.w      endless
               bne.s      xrcopebax
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrec2
xrcopebax:     cmpa.l     d1,a2         ; Speicher voll ?
               beq        xrweg
xrcopy3ax:     dbra       d0,pslow16b
               move.w     rett,d0
               tst.w      d0
               beq        xr_back       ; mehr als 8 durchlÑufe ?
pfast16:       move.w     (a1),d7       ; High-Byte,Linker Kanal
               move.w     (a1),d6       ; Low-Byte,Linker Kanal
               move.w     (a1),d5       ; High-Byte,Rechter Kanal
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal
               move.l     d1,d3
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               bsr        rpeakcmp
               move.l     d3,d1
               addq.l     #4,24(a5)     ; Recposition
               tst.w      endless
               bne.s      pfxrcopebax
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrec2
pfxrcopebax:   cmpa.l     d1,a2         ; Speicher voll ?
               beq        xrweg
               dbra       d0,pfast16
               bra        xr_back
pslow16wav:    move.w     (a1),d7       ;als wav
               btst       d2,d7
               beq        xrcopy4ax     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq        xrcopy4ax     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne        xrcopy4ax     ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne        xrcopy4ax     ; fehlerhafte Daten ?
               move.l     d1,d3
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bsr        rpeakcmp
               move.l     d3,d1
               addq.l     #4,24(a5)     ; Recposition
               tst.w      endless
               bne.s      xrcopebaxb
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrec2
xrcopebaxb:    cmpa.l     d1,a2         ; Speicher voll ?
               beq        xrweg
xrcopy4ax:     dbra       d0,pslow16wav
               move.w     rett,d0
               tst.w      d0
               bne.s      pfast16wav    ; mehr als 8 durchlÑufe ?
               bra        xr_back
pfast16wav:    move.w     (a1),d7       ; High-Byte,Linker Kanal
               move.w     (a1),d6       ; Low-Byte,Linker Kanal
               move.w     (a1),d5       ; High-Byte,Rechter Kanal
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal
               move.l     d1,d3
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bsr        rpeakcmp
               move.l     d3,d1
               addq.l     #4,24(a5)     ; Recposition
               tst.w      endless
               bne.s      pfxrcopebay
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrec2
pfxrcopebay:   cmpa.l     d1,a2         ; Speicher voll ?
               beq        xrweg
               dbra       d0,pfast16wav
               bra        xr_back

killbuf:       lea.l      cadr,a6
               movea.l    (a6),a1       ; Startadresse fifo
               movea.l    4(a6),a2      ; Startadresse recstat
killbu2:       move.w     (a1),d1
               btst       #0,(a2)
               bne.s      killbu2
               rts        

txmemrec:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      txmemre2
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
txmemre2:      lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               lea.l      rpeakmerk(pc),a2
               move.l     16(a5),(a2)   ; Peakwert holen
               lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
txranf:        move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      txnordful
               tst.l      24(a5)        ; Recposition abfragen
               beq.s      txnordful
               addi.l     #1,12(a5)     ;Fehler +1
txnordful:     and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      txrcopy       ; wenn ja, daten einlesen
               bra.s      txranf
txrcopy:       move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
txrcopy2:      move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      txrcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      txrcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      txrcopy3      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      txrcopy3      ; fehlerhafte Daten ?
               move.l     d1,-(sp)
               cmpi.w     #3,rfileart
               bne.s      txnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bsr        rpeakcmp2
               bra.s      txrcope
txnorwave:     move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               bsr        rpeakcmp2
txrcope:       move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        txendrec2
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      txrweg
txrcopy3:      dbra       d0,txrcopy2
txr_back:      lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
txr_back2:     move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      txr_back2b    ; nein ?, dann weiter
               move.l     (a4),peakvalue
               clr.l      16(a5)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
txr_back2b:    movem.l    (sp)+,d0-d7/a0-a6
               rte        
txrweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      tmemr1
tmemr2:        lea.l      rvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      txr_back2
tmemr1:        lea.l      rbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      txr_back2
txendrec2:     lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      txendrec3     ; nein ?, dann weiter
               move.l     (a4),peakvalue
               clr.l      16(a5)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
txendrec3:     move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

rpeakcmp2:     lea.l      rpeakmerk(pc),a4
               move.l     (a4),d1
               lsl.w      #8,d7
               add.b      d6,d7
               lsl.w      #8,d5
               add.b      d4,d5
               swap.w     d1
               btst       #15,d7
               beq.s      rxpnonegs
               not.w      d7
rxpnonegs:     cmp.w      d1,d7
               blt.s      rxpnoadds
               move.w     d7,d1
rxpnoadds:     swap.w     d1
               btst       #15,d5
               beq.s      rxpnonegs2
               not.w      d5
rxpnonegs2:    cmp.w      d1,d5
               blt.s      rxircop2sb
               move.w     d5,d1
rxircop2sb:    move.l     d1,(a4)
               rts        

rpeakcmp:      tst.w      nopeaks       ; keine Peaks ?
               beq.s      rpeakrun
               rts        
rpeakrun:      tst.w      nopkbuf       ; kein Peakbuf ?
               bne.s      rpeakcmp2
               lsl.w      #8,d7         ; Peak-Aufnahme mit Peakbuf
               add.b      d6,d7
               lsl.w      #8,d5
               add.b      d4,d5
               move.l     a0,d1         ; peak linker Kanal
               btst       #15,d7
               beq.s      xpnoneg
               not.w      d7
               cmp.w      d1,d7
               blt.s      xpnoadd
               move.w     d7,d1
               bra.s      xpnoadd
xpnoneg:       swap.w     d1            ; positive HÑlfte
               cmp.w      d1,d7
               blt.s      xpnoadd2
               move.w     d7,d1
xpnoadd2:      swap.w     d1            ; peak linker Kanal, negative HÑlfte
xpnoadd:       movea.l    d1,a0         ; peak links retten
               move.l     a3,d1         ; peak rechter Kanal
               btst       #15,d5
               beq.s      xpnoneg2
               not.w      d5
               cmp.w      d1,d5
               blt.s      xircop2b
               move.w     d5,d1
               bra.s      xircop2b
xpnoneg2:      swap.w     d1
               cmp.w      d1,d5
               blt.s      xircop2c
               move.w     d5,d1
xircop2c:      swap.w     d1
xircop2b:      movea.l    d1,a3         ;peak rechts retten
               addq.w     #1,a4
               cmpa.w     #512,a4
               bne.s      pbufweg
               lea.l      rpeakbuf(pc),a4
               movea.l    (a4),a6       ; Peakbuffer-Adresse holen
               move.l     a0,(a6)+      ; Peakwert li im Peakbuffer speichern
               move.l     a3,(a6)+      ; Peakwert re im Peakbuffer speichern
               move.l     a6,(a4)       ; neue Peakbuffer-Adresse retten
               move.l     a0,d6
               move.w     d6,d7
               swap.w     d6
               cmp.w      d7,d6
               blt.s      peakrm1
               move.w     d6,d7
peakrm1:       lea.l      rpeakmerk(pc),a4
               move.l     (a4),d1
               swap.w     d1
               cmp.w      d1,d7
               blt.s      pypnoadd
               move.w     d7,d1
pypnoadd:      swap.w     d1
               move.l     a3,d6
               move.w     d6,d7
               swap.w     d6
               cmp.w      d7,d6
               blt.s      peakrm2
               move.w     d6,d7
peakrm2:       cmp.w      d1,d7
               blt.s      pyircop2b
               move.w     d7,d1
pyircop2b:     move.l     d1,(a4)
               clr.w      a4            ; WertezÑhler lîschen
               clr.l      a0            ; Peakwert re lîschen
               clr.l      a3            ; Peakwert li lîschen
pbufweg:       rts        

crveclc:       movea.l    (a0)+,a1      ; von
               movea.l    (a0)+,a2      ; bis
               clr.l      d1            ; zaehler pos
               clr.l      d4            ; zaehler neg
               clr.l      d3
               btst       #0,modr24
               bne.s      crveclc24
               move.w     #15,d5
               move.w     #8,d6
               move.w     #4,d2
crvec1:        move.w     (a1),d3
               btst       d5,d3
               beq.s      crvepos
crveneg:       neg.w      d3
               cmp.w      d4,d3
               ble.s      crvenxt
               move.w     d3,d4
               bra.s      crvenxt
crvepos:       cmp.w      d1,d3
               ble.s      crvenxt
               move.w     d3,d1
crvenxt:       adda.l     d2,a1
               cmpa.l     a2,a1
               blt.s      crvec1
               lea.l      crvepnt(pc),a2
               move.l     d1,(a2)
               move.l     d4,4(a2)
               move.l     a2,d0
               rts        
crveclc24:     move.w     #23,d5
               move.w     #8,d6
               move.w     #3,d2
crvec24a:      clr.l      d3
               move.b     (a1)+,d3
               lsl.l      d6,d3
               move.b     (a1)+,d3
               lsl.l      d6,d3
               move.b     (a1)+,d3
               btst       d5,d3
               beq.s      crvepos24
crveneg24:     ori.l      #$ff000000,d3
               neg.l      d3
               cmp.l      d4,d3
               ble.s      crvenxt24
               move.l     d3,d4
               bra.s      crvenxt24
crvepos24:     cmp.l      d1,d3
               ble.s      crvenxt24
               move.l     d3,d1
crvenxt24:     adda.l     d2,a1
               cmpa.l     a2,a1
               blt.s      crvec24a
               lea.l      crvepnt(pc),a2
               move.l     d1,(a2)
               move.l     d4,4(a2)
               move.l     a2,d0
               rts        

fncopy:        movea.l    (a0)+,a1      ; anf
               movea.l    (a0)+,a2      ; ende
               movea.l    (a0)+,a3      ; dest
               movea.l    (a0)+,a4      ; grenzwert
               btst       #0,modr24
               bne.s      fncopy24
fncopy2:       move.l     (a1)+,(a3)+
               cmpa.l     a2,a1
               bge.s      fncopyw
               cmpa.l     a4,a3
               blt.s      fncopy2
fncopyw:       rts        
fncopy24:      move.l     (a1)+,(a3)+
               move.w     (a1)+,(a3)+
               cmpa.l     a2,a1
               bge.s      fncopyw
               cmpa.l     a4,a3
               blt.s      fncopy24
               rts        

fnldsave:      movea.l    (a0)+,a1      ; von
               movea.l    (a0)+,a2      ; nach
               move.l     (a0)+,d0      ; len
               add.l      a1,d0
fnlds2:        move.b     (a1)+,(a2)+
               cmpa.l     d0,a1
               bne.s      fnlds2
               rts        

fnbackcopy:    movea.l    (a0)+,a1      ; ende
               movea.l    (a0)+,a2      ; anf
               movea.l    (a0)+,a3      ; destende
               add.l      a1,d0
               btst       #0,modr24
               bne.s      fnback24
fnbck2:        move.l     -(a1),-(a3)
               cmpa.l     a2,a1
               bgt.s      fnbck2
               rts        
fnback24:      move.l     -(a1),-(a3)
               move.w     -(a1),-(a3)
               cmpa.l     a2,a1
               bgt.s      fnback24
               rts        

fnpeaksuch:    movea.l    (a0)+,a1      ; anf
               movea.l    (a0)+,a2      ; ende
               clr.l      d0
               btst       #0,modr24
               bne.s      fnpeaks24
fnpksu2:       move.w     (a1)+,d1
               btst       #15,d1
               beq.s      psnoneg
               not.w      d1
psnoneg:       cmp.w      d0,d1
               blt.s      psnoadd
               move.w     d1,d0
psnoadd:       cmpa.l     a2,a1
               blt.s      fnpksu2
               rts        
fnpeaks24:     clr.l      d1
               move.b     (a1)+,d1
               lsl.l      #8,d1
               move.b     (a1)+,d1
               lsl.l      #8,d1
               move.b     (a1)+,d1
               btst       #23,d1
               beq.s      psnoneg24
               ori.l      #$ff000000,d1
               not.l      d1
psnoneg24:     cmp.l      d0,d1
               blt.s      psnoadd24
               move.l     d1,d0
psnoadd24:     cmpa.l     a2,a1
               blt.s      fnpeaks24
               rts        

normalize:     movea.l    (a0)+,a1      ; anf
               movea.l    (a0)+,a2      ; ende
               move.l     (a0)+,d0      ; wunschhîchstwert (max. 7FFF)
               move.l     (a0)+,d1      ; ermittelter hîchstwert
               btst       #0,modr24
               bne.s      norma24
norliz2:       clr.l      d2
               move.w     (a1),d2
               btst       #15,d2
               beq.s      normneg
               not.w      d2
               mulu.w     d0,d2
               divu.w     d1,d2
               not.w      d2
norliz3:       move.w     d2,(a1)+
               cmpa.l     a2,a1
               blt.s      norliz2
               rts        
normneg:       mulu.w     d0,d2
               divu.w     d1,d2
               bra.s      norliz3

norma24:       clr.l      d2
               move.b     (a1),d2
               lsl.l      #8,d2
               move.b     1(a1),d2
               lsl.l      #8,d2
               move.b     2(a1),d2
               btst       #23,d2
               beq.s      normneg24
               ori.l      #$ff000000,d2
               not.l      d2
               bsr        normcalc24
               not.l      d2
norma24b:      move.l     d2,d7
               move.w     d2,d6
               swap.w     d7
               move.b     d7,(a1)+
               lsr.w      #8,d6
               move.b     d6,(a1)+
               move.b     d2,(a1)+
               cmpa.l     a2,a1
               blt.s      norma24
               rts        
normneg24:     bsr        normcalc24
               bra.s      norma24b

normcalc24:               ; d1 ermittelter hîchstwert (als shiftwert=2er Potenz)
               move.l     d2,d3
               swap.w     d3
               move.l     d0,d6
               swap.w     d6
               andi.w     #$ff,d6
               move.l     d3,d7
               mulu.w     d6,d7         ; highmul upper word
               swap.w     d7
               mulu.w     d0,d3         ; highmul lower word
               add.l      d7,d3
               move.w     d2,d4
               lsr.w      #8,d4
               andi.l     #$ff,d4
               move.l     d0,d6
               swap.w     d6
               andi.w     #$ff,d6
               move.l     d4,d7
               mulu.w     d6,d7         ; midmul upper word
               swap.w     d7
               mulu.w     d0,d4         ; midmul lower word
               add.l      d7,d4
               andi.l     #$ff,d2
               move.l     d0,d6
               swap.w     d6
               andi.w     #$ff,d6
               move.l     d2,d7
               mulu.w     d6,d7         ; lowmul upper word
               swap.w     d7
               mulu.w     d0,d2         ; lowmul lower word
               add.l      d7,d2
               cmpi.w     #16,d1
               blt.s      lowcalc24
               move.l     d1,d5
               subi.l     #16,d5
               lsr.l      d5,d3         ; shift highmul to correct range
               move.l     d1,d5
               subi.l     #8,d5
               lsr.l      d5,d4         ; shift midmul to correct range
               lsr.l      d1,d2         ; shift lowmul to correct range
               add.l      d4,d2
               add.l      d3,d2
               rts        
lowcalc24:     lsr.l      #8,d2         ; shift lowmul to correct range
               add.l      d4,d2         ; add midmul
               lsr.l      #8,d2         ; shift to correct range
               add.l      d3,d2         ; add highmul
               move.l     #16,d5
               sub.l      d1,d5
               lsl.l      d5,d2         ; shift to correct range
               rts        

resample:      movea.l    a0,a6
               movea.l    (a6)+,a0      ; sourceanf
               movea.l    (a6)+,a1      ; sourceende
               movea.l    (a6)+,a2      ; destanf
               movea.l    (a6)+,a3      ; destende
               clr.l      d3
               move.w     (a6)+,d3      ; source-sample-rate (320,441,480)
               clr.l      d4
               move.w     (a6)+,d4      ; dest-sample-rate (320,441,480)
               move.l     d3,d5
               sub.l      d4,d5         ; d5 source-dest
               moveq.l    #0,d1
               move.l     d3,d2
               divu.w     d4,d2         ; d2 source/dest
               cmpi.l     #1,d2
               beq.s      abzanf
               andi.l     #$ffff,d2
               btst       #0,modr24
               bne        resample24
               tst.w      d2
               beq.s      dazuanf       ; dest ist grîûer (smple wird schneller)
               cmpi.w     #2,d2
               blt.s      abzanf2
abzanf:        move.l     (a0),(a2)+    ; source ist also >=2*dest (langsamer)
               add.l      d3,d1         ; d1 counter(bzw.teilrest) + sourcerate
               move.l     d1,d2         ; d2=d1
               divu.w     d4,d2         ; d2 ist (counter+sourcerate)/destrate
               andi.l     #$ffff,d2
               move.l     d2,d7
               mulu.w     #4,d7         ; d7 ist (counter+sr)/dr mal 4
               mulu.w     d4,d2         ; d2 ist int((counter+sr)/dr)*dr
               sub.l      d2,d1         ; d1 teilungsrest von int() behalten
               adda.l     d7,a0         ; x werte Åberspringen
               cmpa.l     a1,a0
               blt.s      abzanf
               bra.s      resamende
abzanf2:       move.l     d3,d5
               sub.l      d4,d5         ; d5 source-dest
abzanf3:       move.l     (a0)+,d0      ; source ist also >=dest und <2*dest
               add.l      d5,d1         ; add source-dest zu counter
               move.l     d1,d2
               sub.l      d3,d2         ; counter-source
               bmi.s      noabz2        ; wenn kleiner, gleichen wert copy
               move.l     d2,d1         ; wenn erreicht, nÑ wert & rest merken
               bra.s      abztest2
noabz2:        move.l     d0,(a2)+      ; wert kopieren
abztest2:      cmpa.l     a1,a0
               blt.s      abzanf3       ; wiederholen
               bra.s      resamende
dazuanf:       move.l     d4,d2         ; dest ist grîûer (smple wird schneller)
               divu.w     d3,d2         ; d2 dest/source
               cmpi.w     #2,d2
               bge.s      dazuanf4
               move.l     d4,d5
               sub.l      d3,d5         ; d5 dest-source
dazuanf2:      move.l     (a0)+,d0
               add.l      d5,d1
               move.l     d1,d2
               sub.l      d3,d2
               bmi.s      dazuanf3
               move.l     d2,d1
               move.l     d0,(a2)+
dazuanf3:      move.l     d0,(a2)+
               cmpa.l     a3,a2
               bge.s      resamende
               cmpa.l     a1,a0
               blt.s      dazuanf2
               bra.s      resamende
dazuanf4:      move.l     (a0)+,d0
               add.l      d4,d1
               move.l     d1,d2
               divu.w     d3,d2
               andi.l     #$ffff,d2
               move.l     d2,d7
               mulu.w     d3,d2
               sub.l      d2,d1
               subq.l     #1,d7
dazuanf5:      move.l     d0,(a2)+
               cmpa.l     a3,a2
               bge.s      resamende
               dbra       d7,dazuanf5
               cmpa.l     a1,a0
               blt.s      dazuanf4
resamende:     move.l     a2,d0
               rts        
resample24:    tst.w      d2
               beq.s      dazuanf24     ; dest ist grîûer (smple wird schneller)
               cmpi.w     #2,d2
               blt.s      abzanf24b
abzanf24:      move.l     (a0),(a2)+    ; source ist also >=2*dest (langsamer)
               move.w     4(a0),(a2)+
               add.l      d3,d1         ; d1 counter(bzw.teilrest) + sourcerate
               move.l     d1,d2         ; d2=d1
               divu.w     d4,d2         ; d2 ist (counter+sourcerate)/destrate
               andi.l     #$ffff,d2
               move.l     d2,d7
               mulu.w     #6,d7         ; d7 ist (counter+sr)/dr mal 6
               mulu.w     d4,d2         ; d2 ist int((counter+sr)/dr)*dr
               sub.l      d2,d1         ; d1 teilungsrest von int() behalten
               adda.l     d7,a0         ; x werte Åberspringen
               cmpa.l     a1,a0
               blt.s      abzanf24
               bra.s      resame24
abzanf24b:     move.l     d3,d5
               sub.l      d4,d5         ; d5 source-dest
abzanf24c:     move.l     (a0)+,d0      ; source ist also >=dest und <2*dest
               move.w     (a0)+,d6
               add.l      d5,d1         ; add source-dest zu counter
               move.l     d1,d2
               sub.l      d3,d2         ; counter-source
               bmi.s      noabz24       ; wenn kleiner, gleichen wert copy
               move.l     d2,d1         ; wenn erreicht, nÑ wert & rest merken
               bra.s      abztest24
noabz24:       move.l     d0,(a2)+      ; wert kopieren
               move.w     d6,(a2)+      ; wert kopieren
abztest24:     cmpa.l     a1,a0
               blt.s      abzanf24c     ; wiederholen
               bra.s      resame24
dazuanf24:     move.l     d4,d2         ; dest ist grîûer (smple wird schneller)
               divu.w     d3,d2         ; d2 dest/source
               cmpi.w     #2,d2
               bge.s      dazuanf24d
               move.l     d4,d5
               sub.l      d3,d5         ; d5 dest-source
dazuanf24b:    move.l     (a0)+,d0
               move.w     (a0)+,d6
               add.l      d5,d1
               move.l     d1,d2
               sub.l      d3,d2
               bmi.s      dazuanf24c
               move.l     d2,d1
               move.l     d0,(a2)+
               move.w     d6,(a2)+
dazuanf24c:    move.l     d0,(a2)+
               move.w     d6,(a2)+
               cmpa.l     a3,a2
               bge.s      resame24
               cmpa.l     a1,a0
               blt.s      dazuanf24b
               bra.s      resame24
dazuanf24d:    move.l     (a0)+,d0
               move.w     (a0)+,d6
               add.l      d4,d1
               move.l     d1,d2
               divu.w     d3,d2
               andi.l     #$ffff,d2
               move.l     d2,d7
               mulu.w     d3,d2
               sub.l      d2,d1
               subq.l     #1,d7
dazuanf24e:    move.l     d0,(a2)+
               move.w     d6,(a2)+
               cmpa.l     a3,a2
               bge.s      resame24
               dbra       d7,dazuanf24e
               cmpa.l     a1,a0
               blt.s      dazuanf24d
resame24:      move.l     a2,d0
               rts        

fnmono:        movea.l    (a0)+,a1      ; anf
               movea.l    (a0)+,a2      ; ende
monoanf2:      btst       #0,modr24
               bne.s      fnmono24
               moveq.l    #0,d1
               move.l     d1,d2
               move.w     (a1),d1
               move.w     2(a1),d2
               btst       #15,d1
               bne.s      monoanf5
monoanf3:      btst       #15,d2
               bne.s      monoanf6
monoanf4:      add.l      d2,d1         ; plus und plus = plus
               bra.s      monoende
monoanf5:      btst       #15,d2
               bne.s      monoanf7      ; minus und minus = minus
               not.w      d1
               sub.l      d1,d2         ; minus und plus = ?
               move.l     d2,d1
               bra.s      monoende
monoanf6:      not.w      d2            ; plus und minus = ?
               sub.l      d2,d1
               bra.s      monoende
monoanf7:      add.l      d2,d1         ; add + wech
monoende:      asr.l      #1,d1
               move.w     d1,(a1)+
               move.w     d1,(a1)+
               cmpa.l     a2,a1
               blt.s      monoanf2
monoweg:       rts        
fnmono24:      clr.l      d1
               move.l     d1,d2
               move.b     (a1),d1
               lsl.l      #8,d1
               move.b     1(a1),d1
               lsl.l      #8,d1
               move.b     2(a1),d1
               move.b     3(a1),d2
               lsl.l      #8,d2
               move.b     4(a1),d2
               lsl.l      #8,d2
               move.b     5(a1),d2
               btst       #23,d1
               bne.s      bmonoanf5
bmonoanf3:     btst       #23,d2
               bne.s      bmonoanf6
bmonoanf4:     add.l      d2,d1         ; plus und plus = plus
               bra.s      bmonoende
bmonoanf5:     btst       #23,d2
               bne.s      bmonoanf7     ; minus und minus = minus
               ori.l      #$ff000000,d1
               not.l      d1
               sub.l      d1,d2         ; minus und plus = ?
               move.l     d2,d1
               bra.s      bmonoende
bmonoanf6:     ori.l      #$ff000000,d2
               not.l      d2            ; plus und minus = ?
               sub.l      d2,d1
               bra.s      bmonoende
bmonoanf7:     add.l      d2,d1         ; add + wech
bmonoende:     asr.l      #1,d1
               move.l     d1,d7
               swap.w     d7
               move.l     d1,d6
               lsr.w      #8,d6
               move.b     d7,(a1)+
               move.b     d6,(a1)+
               move.b     d1,(a1)+
               move.b     d7,(a1)+
               move.b     d6,(a1)+
               move.b     d1,(a1)+
               cmpa.l     a2,a1
               blt.s      fnmono24
bmonoweg:      rts        

fnintel:       movea.l    (a0)+,a1      ; anf
               movea.l    (a0)+,a2      ; ende
               btst       #0,modr24
               bne.s      fnintel24
               clr.l      d0
fnintel2:      move.w     (a1),d0
               move.b     d0,(a1)+
               asr.w      #8,d0
               move.b     d0,(a1)+
               cmpa.l     a2,a1
               blt.s      fnintel2
               rts        
fnintel24:     clr.l      d0
fnintel24b:    move.b     (a1),d0
               move.b     2(a1),(a1)
               move.b     d0,2(a1)
               addq.l     #3,a1
               cmpa.l     a2,a1
               blt.s      fnintel24b
               rts        

fncopyback:    movea.l    (a0)+,a1      ; anf
               movea.l    (a0)+,a2      ; ende
               movea.l    a2,a3
               btst       #0,modr24
               bne.s      fncback24
fncb2:         subq.l     #4,a3
               move.l     (a3),(a2)+
               cmpa.l     a1,a3
               bgt.s      fncb2
               rts        
fncback24:     subq.l     #6,a3
               move.l     (a3),(a2)+
               move.w     4(a3),(a2)+
               cmpa.l     a1,a3
               bgt.s      fncback24
               rts        

fnzero:        movea.l    (a0)+,a3      ; anf
               movea.l    (a0)+,a1      ; ende
               move.w     (a0)+,d0      ; Richtung
               btst       #0,modr24
               bne.s      fnzero24
               tst.w      d0
               bne.s      zback
zvor:          move.w     (a3)+,d0
               tst.w      d0
               beq.s      zvorweg
               cmpa.l     a1,a3
               blt.s      zvor
               move.l     #-1,d0
               rts        
zvorweg:       subq.l     #2,a3
               move.l     a3,d0
               rts        
zback:         move.w     -(a1),d0
               tst.w      d0
               beq.s      zbackweg
               cmpa.l     a3,a1
               bgt.s      zback
               move.l     #-1,d0
               rts        
zbackweg:      move.l     a1,d0
zweg:          rts        
fnzero24:      tst.w      d0
               bne.s      zback24
zvor24:        clr.l      d0
               move.b     (a3)+,d0
               lsl.l      #8,d0
               move.b     (a3)+,d0
               lsl.l      #8,d0
               move.b     (a3)+,d0
               tst.l      d0
               beq.s      zvorweg24
               cmpa.l     a1,a3
               blt.s      zvor24
               move.l     #-1,d0
               rts        
zvorweg24:     subq.l     #3,a3
               move.l     a3,d0
               rts        
zback24:       subq.l     #3,a1
               clr.l      d0
               move.b     (a1),d0
               lsl.l      #8,d0
               move.b     1(a1),d0
               lsl.l      #8,d0
               move.b     2(a1),d0
               bclr       #0,d0         ; wegen Userbit !
               tst.l      d0
               beq.s      zbackweg
               cmpa.l     a3,a1
               bgt.s      zback24
               move.l     #-1,d0
               rts        

negate:        movea.l    (a0)+,a1      ; anf
               movea.l    (a0)+,a2      ; ende
               btst       #0,modr24
               bne.s      negate24
negat2:        neg.w      (a1)+
               cmpa.l     a2,a1
               blt.s      negat2
               rts        
negate24:      clr.l      d1
               move.b     (a1),d1
               lsl.l      #8,d1
               move.b     1(a1),d1
               lsl.l      #8,d1
               move.b     2(a1),d1
               btst       #23,d1
               beq.s      negat24b
               ori.l      #$ff000000,d1
negat24b:      neg.l      d1
               move.l     d1,d7
               swap.w     d7
               move.w     d1,d6
               lsr.w      #8,d6
               move.b     d7,(a1)+
               move.b     d6,(a1)+
               move.b     d1,(a1)+
               cmpa.l     a2,a1
               blt.s      negate24
               rts        

lrchange:      movea.l    (a0)+,a1      ; anf
               movea.l    (a0)+,a2      ; ende
               btst       #0,modr24
               bne.s      lrchng24
lrchng2:       move.l     (a1),d0
               swap.w     d0
               move.l     d0,(a1)+
               cmpa.l     a2,a1
               blt.s      lrchng2
               rts        
lrchng24:      move.b     3(a1),d0
               move.b     4(a1),d1
               move.b     5(a1),d2
               move.b     (a1),3(a1)
               move.b     1(a1),4(a1)
               move.b     2(a1),5(a1)
               move.b     d0,(a1)
               move.b     d1,1(a1)
               move.b     d2,2(a1)
               addq.l     #6,a1
               cmpa.l     a2,a1
               blt.s      lrchng24
               rts        

fnsdmono:      movea.l    a0,a6
               movea.l    (a6)+,a0      ; meml
               movea.l    (a6)+,a1      ; memh
               movea.l    (a6)+,a2      ; mdat%
               movea.l    (a6)+,a3      ; mdat%+len
               move.w     (a6)+,d7      ; handle
               movea.l    a2,a5
               btst       #0,modr24
               bne.s      sdmono24
sdanf:         move.w     (a0),(a5)+
               addq.l     #4,a0
               cmpa.l     a5,a3
               bne.s      sdweiter
               bsr        sdwrite
               tst.l      d0
               bmi.s      sdfehler
sdweiter:      cmpa.l     a1,a0
               blt.s      sdanf
               bsr        sdwrite
               tst.l      d0
               bmi.s      sdfehler
               move.l     a0,d0
               rts        
sdfehler:      clr.l      d0
               rts        
sdwrite:       movem.l    d7/a0-a5,-(sp)
               move.l     a2,-(sp)      ; Fwrite
               move.l     a5,d0
               sub.l      a2,d0
               move.l     d0,-(sp)
               move.w     d7,-(sp)
               move.w     #64,-(sp)
               tst.l      d0
               beq.s      sdnowrite
               trap       #1
sdnowrite:     lea.l      $c(sp),sp
               movem.l    (sp)+,d7/a0-a5
               movea.l    a2,a5
               rts        
sdmono24:      move.b     (a0),(a5)+
               move.b     1(a0),(a5)+
               move.b     2(a0),(a5)+
               addq.l     #6,a0
               cmpa.l     a5,a3
               bne.s      sdweiter24
               bsr        sdwrite
               tst.l      d0
               bmi.s      sdfehler
sdweiter24:    cmpa.l     a1,a0
               blt.s      sdmono24
               bsr        sdwrite
               tst.l      d0
               bmi.s      sdfehler
               move.l     a0,d0
               rts        

fnsdstereo:    movea.l    a0,a6
               movea.l    (a6)+,a0      ; meml
               movea.l    (a6)+,a1      ; memh
               movea.l    (a6)+,a2      ; mdat%
               movea.l    (a6)+,a3      ; mdat%+len
               move.w     (a6)+,d7      ; handle
               bsr        sdsread
               tst.l      d0
               bmi.s      sdsfehler
               btst       #0,modr24
               bne.s      sdstereo24
sdsanf:        move.w     (a5)+,(a0)
               addq.l     #4,a0
               cmpa.l     a5,a6
               bne.s      sdsweiter
               bsr        sdsread
               tst.l      d0
               bmi.s      sdsfehler
sdsweiter:     cmpa.l     a1,a0
               blt.s      sdsanf
               move.l     a0,d0
               rts        
sdsfehler:     clr.l      d0
               rts        
sdsread:       move.l     a1,d0
               sub.l      a0,d0
               move.l     a3,d1
               sub.l      a2,d1
               cmp.l      d1,d0
               blt.s      sdsread2
               move.l     d1,d0
sdsread2:      movea.l    d0,a6
               adda.l     a2,a6
               movem.l    d7/a0-a6,-(sp)
               move.l     a2,-(sp)      ; Fread
               move.l     d0,-(sp)
               move.w     d7,-(sp)
               move.w     #63,-(sp)
               tst.l      d0
               beq.s      sdsnoread
               trap       #1
sdsnoread:     lea.l      $c(sp),sp
               movem.l    (sp)+,d7/a0-a6
               movea.l    a2,a5
               rts        
sdstereo24:    move.b     (a5)+,(a0)
               move.b     (a5)+,1(a0)
               move.b     (a5)+,2(a0)
               addq.l     #6,a0
               cmpa.l     a5,a6
               bne.s      sdsweiter24
               bsr        sdsread
               tst.l      d0
               bmi.s      sdsfehler
sdsweiter24:   cmpa.l     a1,a0
               blt.s      sdstereo24
               move.l     a0,d0
               rts        

fnwavalon:     movea.l    (a0)+,a1      ; anf
               movea.l    (a0)+,a2      ; ende
               btst       #0,modr24
               bne.s      avalon24
wavalo2:       move.w     (a1),d0
               subi.w     #$8000,d0
               move.w     d0,(a1)+
               cmpa.l     a2,a1
               blt.s      wavalo2
               rts        
avalon24:      clr.l      d0
               move.b     (a1),d0
               lsl.l      #8,d0
               move.b     1(a1),d0
               lsl.l      #8,d0
               move.b     2(a1),d0
               subi.l     #$800000,d0
               move.l     d0,d7
               swap.w     d7
               move.l     d0,d6
               lsr.w      #8,d6
               move.b     d7,(a1)+
               move.b     d6,(a1)+
               move.b     d0,(a1)+
               cmpa.l     a2,a1
               blt.s      avalon24
               rts        

peaksuch:      movea.l    (a0)+,a1      ; von
               movea.l    (a0)+,a2      ; bis
               lea.l      peakw(pc),a3
               clr.l      d1
               clr.l      d2
               clr.l      d3
               clr.l      d4
peak1:         move.w     (a1)+,d0
               cmp.w      d1,d0
               blt.s      peak2
               move.w     d0,d1
peak2:         move.w     (a1)+,d0
               cmp.w      d2,d0
               blt.s      peak3
               move.w     d0,d2
peak3:         move.w     (a1)+,d0
               cmp.w      d3,d0
               blt.s      peak4
               move.w     d0,d3
peak4:         move.w     (a1)+,d0
               cmp.w      d4,d0
               blt.s      peak5
               move.w     d0,d4
peak5:         cmpa.l     a2,a1
               bne.s      peak1
               move.w     d1,(a3)       ; maxwert pos links
               move.w     d2,2(a3)      ; maxwert neg links
               move.w     d3,4(a3)      ; maxwert pos rechts
               move.w     d4,6(a3)      ; maxwert neg rechts
               move.l     a3,d0
               rts        

mixit:         move.w     (a0)+,d0      ; Anzahl der MixkanÑle
               move.w     (a0)+,trkall16          ; alle samples 16bit?
               btst       #0,modr24
               bne.s      mixit24
               cmpi.w     #16,d0
               beq        mix16
               cmpi.w     #12,d0
               beq        mix12
               cmpi.w     #8,d0
               beq        mix8
               cmpi.w     #4,d0
               beq.s      mix4
               move.l     #-1,d0
               rts        
mixit24:       cmpi.w     #16,d0
               beq        bigmix16
               cmpi.w     #12,d0
               beq        bigmix12
               cmpi.w     #8,d0
               beq        bigmix8
               cmpi.w     #4,d0
               beq        bigmix4
               move.l     #-1,d0
               rts        

mixer:         btst       #15,d6        ; mixt (d6 und d7) nach d7
               beq.s      noneg
               neg.w      d6
               btst       #15,d7
               bne.s      negneg
negplus:       neg.w      d6
               add.w      d6,d7
               bra.s      accuweg
negneg:        neg.w      d7
               add.w      d6,d7
               neg.w      d7
               bra.s      accuweg
noneg:         btst       #15,d7
               beq.s      plusplus
plusneg:       add.w      d6,d7
               bra.s      accuweg
plusplus:      add.w      d6,d7
accuweg:       rts        

; Mixt 2 StereokanÑle (=4 MonokanÑle) zusammen - 16bit

mix4:          movea.l    (a0)+,a2      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a4      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle2adresse
               clr.l      d2
               clr.l      d5
               move.l     #100,d3
               move.w     (a6)+,d2      ; Volume1
               move.w     (a6),d5       ; Volume2
accu:          move.w     (a2)+,d6      ; source1
               move.w     (a3)+,d7      ; source2
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
               bsr        mixer
               move.w     d7,(a4)+      ; d7,destination
               subq.l     #1,d0
               tst.l      d0
               bne.s      accu
               rts        

; Mixt 4 StereokanÑle (=8 MonokanÑle) zusammen - 16 Bit

mix8:          movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
               move.l     #100,d3
               clr.l      d2
               clr.l      d5
accu8:         move.w     (a1)+,d6      ; source1
               move.w     (a2)+,d7      ; source2
               move.w     (a6),d2       ; Volume1
               move.w     2(a6),d5      ; Volume2
               cmp.w      d2,d3
               beq.s      nomul8a
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul8a:       cmp.w      d5,d3
               beq.s      nomul8b
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul8b:       bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,d1
               move.w     (a3)+,d6      ; source3
               move.w     (a4)+,d7      ; source4
               move.w     4(a6),d2      ; Volume3
               move.w     6(a6),d5      ; Volume4
               cmp.w      d2,d3
               beq.s      nomul8c
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul8c:       cmp.w      d5,d3
               beq.s      nomul8d
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul8d:       bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d1,d6
               bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,(a5)+      ; d7,destination
               subq.l     #1,d0
               tst.l      d0
               bne.s      accu8
               rts        

; Mixt 6 StereokanÑle (=12 MonokanÑle) zusammen - 16 Bit

mix12:         movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a6      ; zieladresse
               move.l     a6,-(sp)      ; zieladresse retten
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
               movea.l    a4,a5
               adda.l     d1,a5         ; quelle5adresse
               movea.l    a5,a0
               adda.l     d1,a0         ; quelle6adresse
               move.l     #100,d3
               clr.l      d2
               clr.l      d5
accu12:        move.w     (a1)+,d6      ; source1
               move.w     (a2)+,d7      ; source2
               move.w     (a6),d2       ; Volume1
               move.w     2(a6),d5      ; Volume2
               cmp.w      d2,d3
               beq.s      nomul12a
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul12a:      cmp.w      d5,d3
               beq.s      nomul12b
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul12b:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,d1
               move.w     (a3)+,d6      ; source3
               move.w     (a4)+,d7      ; source4
               move.w     4(a6),d2      ; Volume3
               move.w     6(a6),d5      ; Volume4
               cmp.w      d2,d3
               beq.s      nomul12c
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul12c:      cmp.w      d5,d3
               beq.s      nomul12d
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul12d:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d1,d6
               bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,d1
               move.w     (a5)+,d6      ; source5
               move.w     (a0)+,d7      ; source6
               move.w     8(a6),d2      ; Volume5
               move.w     10(a6),d5     ; Volume6
               cmp.w      d2,d3
               beq.s      nomul12e
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul12e:      cmp.w      d5,d3
               beq.s      nomul12f
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul12f:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d1,d6
               bsr        mixer         ; mixt (d6 und d7) nach d7
               movea.l    a6,a0
               movea.l    (sp)+,a6
               move.w     d7,(a6)+      ; d7,destination
               move.l     a6,-(sp)
               movea.l    a0,a6
               subq.l     #1,d0
               tst.l      d0
               bne.s      accu12
               movea.l    (sp)+,a6
               rts        

; Mixt 8 StereokanÑle (=16 MonokanÑle) zusammen - 16 Bit

mix16:         movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     d1,d0
               asr.l      #1,d0
               move.l     #100,d3
               clr.l      d2
               clr.l      d5
accu16:        movea.l    a1,a2
               move.w     (a2),d6       ; source1
               adda.l     d1,a2
               move.w     (a2),d7       ; source2
               move.w     (a6),d2       ; Volume1
               move.w     2(a6),d5      ; Volume2
               cmp.w      d2,d3
               beq.s      nomul16a
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16a:      cmp.w      d5,d3
               beq.s      nomul16b
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16b:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,-(sp)      ; ergebnis 1+2 retten
               adda.l     d1,a2
               move.w     (a2),d6       ; source3
               adda.l     d1,a2
               move.w     (a2),d7       ; source4
               move.w     4(a6),d2      ; Volume3
               move.w     6(a6),d5      ; Volume4
               cmp.w      d2,d3
               beq.s      nomul16c
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16c:      cmp.w      d5,d3
               beq.s      nomul16d
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16d:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     (sp)+,d6      ; ergebnis 1+2 holen
               bsr        mixer         ; mixt 1+2 und 3+4 zusammen
               move.w     d7,-(sp)
               adda.l     d1,a2
               move.w     (a2),d6       ; source5
               adda.l     d1,a2
               move.w     (a2),d7       ; source6
               move.w     8(a6),d2      ; Volume5
               move.w     10(a6),d5     ; Volume6
               cmp.w      d2,d3
               beq.s      nomul16e
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16e:      cmp.w      d5,d3
               beq.s      nomul16f
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16f:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     d7,-(sp)      ; ergebnis 5+6 retten
               adda.l     d1,a2
               move.w     (a2),d6       ; source7
               adda.l     d1,a2
               move.w     (a2),d7       ; source8
               move.w     12(a6),d2     ; Volume7
               move.w     14(a6),d5     ; Volume8
               cmp.w      d2,d3
               beq.s      nomul16g
               muls.w     d2,d6         ; Volume2 in d5
               divs.w     d3,d6         ; d7-Vol anpassen
nomul16g:      cmp.w      d5,d3
               beq.s      nomul16h
               muls.w     d5,d7         ; Volume2 in d5
               divs.w     d3,d7         ; d7-Vol anpassen
nomul16h:      bsr        mixer         ; mixt (d6 und d7) nach d7
               move.w     (sp)+,d6      ; ergebnis 5+6 holen
               bsr        mixer         ; mixt 5+6 und 7+8 zusammen
               move.w     (sp)+,d6      ; ergebnis 1+2+3+4 holen
               bsr        mixer         ; mixt 1+2+3+4 und 5+6+7+8 zusammen
               move.w     d7,(a5)+      ; d7,destination (1-8)
               addq.l     #2,a1
               subq.l     #1,d0
               tst.l      d0
               bne        accu16
               rts        

volume24:      cmpi.w     #128,d2
               beq.s      volume24c
               move.l     d6,-(sp)
               btst       #23,d6
               beq.s      volume24b
               ori.l      #$ff000000,d6
               neg.l      d6
volume24b:     clr.l      d3
               move.w     d6,d3
               mulu.w     d2,d3         ; lowmul
               swap.w     d6
               andi.l     #$ff,d6
               mulu.w     d2,d6         ; highmul
               move.l     d3,d4
               swap.w     d4
               andi.l     #$ffff,d4
               add.l      d6,d4         ; e1
               move.l     d4,d2
               andi.l     #$ffff0000,d2 ; e2
               swap.w     d4
               move.w     d3,d4         ; e1
               lsl.l      #8,d2
               lsl.l      #1,d2
               lsr.l      #7,d4
               add.l      d2,d4         ; ergebnis in d4
               move.l     d4,d6
               move.l     (sp)+,d4
               btst       #23,d4
               beq.s      volume24c
               andi.l     #$ffffff,d6
               neg.l      d6
volume24c:     rts        

mixer24:       btst       #23,d6        ; mixt (d6 und d7) nach d7
               beq.s      noneg24
               ori.l      #$ff000000,d6
               neg.l      d6
               btst       #23,d7
               bne.s      negneg24
negplus24:     neg.l      d6
               ori.l      #$ff000000,d6
               add.l      d6,d7
               bra.s      accuweg24
negneg24:      ori.l      #$ff000000,d7
               neg.l      d7
               add.l      d6,d7
               andi.l     #$ffffff,d7
               neg.l      d7
               bra.s      accuweg24
noneg24:       btst       #23,d7
               beq.s      plusplus24
plusneg24:     add.l      d6,d7
               bra.s      accuweg24
plusplus24:    add.l      d6,d7
accuweg24:     andi.l     #$ffffff,d7
               rts        

; Mixt 2 StereokanÑle (=4 MonokanÑle) zusammen - 24bit

bigmix4:       movea.l    (a0)+,a2      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a4      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               movea.l    (a0)+,a5      ; bitsize-Wertetabelle (16/24)
               move.l     d1,d0
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle2adresse
bigaccu4:      clr.l      d2
               move.w     (a6),d2       ; Volume1
               tst.w      (a5)          ; 16bit-samplespur ?
               beq.s      bigaccu4b
               clr.l      d6
               move.b     (a2)+,d6      ; source1
               lsl.l      #8,d6
               move.b     (a2)+,d6      ; source1
               lsl.l      #8,d6
               move.b     (a2)+,d6      ; source1
               bra.s      bigaccu4c
bigaccu4b:     move.w     (a2)+,d6      ; source1,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu4c
               asl.l      #8,d6
bigaccu4c:     bsr        volume24      ; LautstÑrke anpassen (d6)
               move.l     d6,d7         ; source 1 retten
               move.w     2(a6),d2      ; Volume2
               tst.w      2(a5)         ; 16bit-samplespur ?
               beq.s      bigaccu4d
               clr.l      d6
               move.b     (a3)+,d6      ; source2
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; source2
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; source2
               bra.s      bigaccu4e
bigaccu4d:     move.w     (a3)+,d6      ; source2,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu4e
               asl.l      #8,d6
bigaccu4e:     bsr        volume24      ; LautstÑrke anpassen (d6)
               bsr        mixer24
               tst.w      trkall16
               beq.s      bigaccu4f
               asl.l      #7,d7         ; End-LautstÑrkekorrektur fÅr 16bit
bigaccu4f:     move.l     d7,d5
               swap.w     d5
               move.l     d7,d6
               asr.w      #8,d6
               move.b     d5,(a4)+      ; d7,destination
               move.b     d6,(a4)+      ; d7,destination
               move.b     d7,(a4)+      ; d7,destination
               subq.l     #3,d0
               tst.l      d0
               bne        bigaccu4
               rts        

; Mixt 4 StereokanÑle (=8 MonokanÑle) zusammen - 24 Bit

bigmix8:       movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               movea.l    (a0),a0       ; bitsize-Wertetabelle (16/24)
               move.l     d1,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
bigaccu8:      clr.l      d2
               move.w     (a6),d2       ; Volume1
               tst.w      (a0)          ; 16bit-samplespur ?
               beq.s      bigaccu8b
               clr.l      d6
               move.b     (a1)+,d6      ; source1
               lsl.l      #8,d6
               move.b     (a1)+,d6      ; source1
               lsl.l      #8,d6
               move.b     (a1)+,d6      ; source1
               bra.s      bigaccu8c
bigaccu8b:     move.w     (a1)+,d6      ; source1,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu8c
               asl.l      #8,d6
bigaccu8c:     bsr        volume24      ; LautstÑrke anpassen (d6)
               move.l     d6,d7         ; source 1 retten
               clr.l      d2
               move.w     2(a6),d2      ; Volume2
               tst.w      2(a0)         ; 16bit-samplespur ?
               beq.s      bigaccu8d
               clr.l      d6
               move.b     (a2)+,d6      ; source2
               lsl.l      #8,d6
               move.b     (a2)+,d6      ; source2
               lsl.l      #8,d6
               move.b     (a2)+,d6      ; source2
               bra.s      bigaccu8e
bigaccu8d:     move.w     (a2)+,d6      ; source2,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu8e
               asl.l      #8,d6
bigaccu8e:     bsr        volume24      ; LautstÑrke anpassen (d6)
               bsr        mixer24       ; mixt (d6 und d7) nach d7
               move.l     d7,d1         ; mixergebnis von 1+2 merken
               clr.l      d2
               move.w     4(a6),d2      ; Volume3
               clr.l      d6
               tst.w      4(a0)         ; 16bit-samplespur ?
               beq.s      bigaccu8f
               move.b     (a3)+,d6      ; source3
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; source3
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; source3
               bra.s      bigaccu8g
bigaccu8f:     move.w     (a3)+,d6      ; source3,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu8g
               asl.l      #8,d6
bigaccu8g:     bsr        volume24      ; LautstÑrke anpassen (d6)
               move.l     d6,d7         ; source 3 retten
               clr.l      d2
               move.w     6(a6),d2      ; Volume4
               tst.w      6(a0)         ; 16bit-samplespur ?
               beq.s      bigaccu8h
               clr.l      d6
               move.b     (a4)+,d6      ; source4
               lsl.l      #8,d6
               move.b     (a4)+,d6      ; source4
               lsl.l      #8,d6
               move.b     (a4)+,d6      ; source4
               bra.s      bigaccu8i
bigaccu8h:     move.w     (a4)+,d6      ; source4,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu8i
               asl.l      #8,d6
bigaccu8i:     bsr        volume24      ; LautstÑrke anpassen (d6)
               bsr        mixer24       ; mixt (d6 und d7) nach d7
               move.l     d1,d6
               bsr        mixer24       ; mixt (d6 und d7) nach d7
               tst.w      trkall16
               beq.s      bigaccu8j
               asl.l      #6,d7         ; End-LautstÑrkekorrektur fÅr 16bit
bigaccu8j:     move.l     d7,d5
               swap.w     d5
               move.l     d7,d6
               asr.w      #8,d6
               move.b     d5,(a5)+      ; d7,destination
               move.b     d6,(a5)+      ; d7,destination
               move.b     d7,(a5)+      ; d7,destination
               subq.l     #3,d0
               tst.l      d0
               bne        bigaccu8
               rts        

; Mixt 6 StereokanÑle (=12 MonokanÑle) zusammen - 24 Bit

bigmix12:      movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a6      ; zieladresse
               move.l     a6,-(sp)      ; zieladresse retten
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               move.l     (a0)+,d5      ; bitsize-Wertetabelle (16/24)
               move.l     d1,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
               movea.l    a4,a5
               adda.l     d1,a5         ; quelle5adresse
               movea.l    a5,a0
               adda.l     d1,a0         ; quelle6adresse
bigaccu12:     clr.l      d2
               move.w     (a6),d2       ; Volume1
               exg.l      d5,a0
               tst.w      (a0)          ; 16bit-samplespur ?
               beq.s      bigaccu12b
               clr.l      d6
               move.b     (a1)+,d6      ; source1
               lsl.l      #8,d6
               move.b     (a1)+,d6      ; source1
               lsl.l      #8,d6
               move.b     (a1)+,d6      ; source1
               bra.s      bigaccu12c
bigaccu12b:    move.w     (a1)+,d6      ; source1,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu12c
               asl.l      #8,d6
bigaccu12c:    bsr        volume24      ; LautstÑrke anpassen (d6)
               move.l     d6,d7         ; source 1 retten
               clr.l      d2
               move.w     2(a6),d2      ; Volume2
               tst.w      2(a0)         ; 16bit-samplespur ?
               beq.s      bigaccu12d
               clr.l      d6
               move.b     (a2)+,d6      ; source2
               lsl.l      #8,d6
               move.b     (a2)+,d6      ; source2
               lsl.l      #8,d6
               move.b     (a2)+,d6      ; source2
               bra.s      bigaccu12e
bigaccu12d:    move.w     (a2)+,d6      ; source2,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu12e
               asl.l      #8,d6
bigaccu12e:    bsr        volume24      ; LautstÑrke anpassen (d6)
               bsr        mixer24       ; mixt (d6 und d7) nach d7
               move.l     d7,d1         ; mixergebnis von 1+2 retten
               clr.l      d2
               move.w     4(a6),d2      ; Volume3
               tst.w      4(a0)         ; 16bit-samplespur ?
               beq.s      bigaccu12f
               clr.l      d6
               move.b     (a3)+,d6      ; source3
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; source3
               lsl.l      #8,d6
               move.b     (a3)+,d6      ; source3
               bra.s      bigaccu12g
bigaccu12f:    move.w     (a3)+,d6      ; source3,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu12g
               asl.l      #8,d6
bigaccu12g:    bsr        volume24      ; LautstÑrke anpassen (d6)
               move.l     d6,d7         ; source 3 retten
               clr.l      d2
               move.w     6(a6),d2      ; Volume4
               tst.w      6(a0)         ; 16bit-samplespur ?
               beq.s      bigaccu12h
               clr.l      d6
               move.b     (a4)+,d6      ; source4
               lsl.l      #8,d6
               move.b     (a4)+,d6      ; source4
               lsl.l      #8,d6
               move.b     (a4)+,d6      ; source4
               bra.s      bigaccu12i
bigaccu12h:    move.w     (a4)+,d6      ; source4,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu12i
               asl.l      #8,d6
bigaccu12i:    bsr        volume24      ; LautstÑrke anpassen (d6)
               bsr        mixer24       ; mixt 3+4
               move.l     d1,d6         ; mix 1+2 holen
               bsr        mixer24       ; mixt 1+2+3+4
               move.l     d7,d1         ; mixergebnis 1+2+3+4 retten
               clr.l      d2
               move.w     8(a6),d2      ; Volume5
               tst.w      8(a0)         ; 16bit-samplespur ?
               beq.s      bigaccu12j
               clr.l      d6
               move.b     (a5)+,d6      ; source5
               lsl.l      #8,d6
               move.b     (a5)+,d6      ; source5
               lsl.l      #8,d6
               move.b     (a5)+,d6      ; source5
               bra.s      bigaccu12k
bigaccu12j:    move.w     (a5)+,d6      ; source5,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu12k
               asl.l      #8,d6
bigaccu12k:    bsr        volume24      ; LautstÑrke anpassen (d6)
               move.l     d6,d7         ; source 3 retten
               clr.l      d2
               move.w     10(a6),d2     ; Volume6
               tst.w      10(a0)        ; 16bit-samplespur ?
               beq.s      bigaccu12l
               exg.l      d5,a0
               clr.l      d6
               move.b     (a0)+,d6      ; source6
               lsl.l      #8,d6
               move.b     (a0)+,d6      ; source6
               lsl.l      #8,d6
               move.b     (a0)+,d6      ; source6
               bra.s      bigaccu12m
bigaccu12l:    exg.l      d5,a0
               move.w     (a0)+,d6      ; source6,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu12m
               asl.l      #8,d6
bigaccu12m:    bsr        volume24      ; LautstÑrke anpassen (d6)
               bsr        mixer24       ; mixt 5+6
               move.l     d1,d6         ; mix 1+2+3+4 holen
               bsr        mixer24       ; mixt 1+2+3+4+5+6
               movea.l    a6,a0
               movea.l    (sp)+,a6
               tst.w      trkall16
               beq.s      bigaccu12y
               asl.l      #5,d7         ; End-LautstÑrkekorrektur fÅr 16bit
bigaccu12y:    move.l     d7,d6
               swap.w     d7
               asr.w      #8,d6
               move.b     d7,(a6)+      ; d7,destination
               move.b     d6,(a6)+      ; d7,destination
               swap.w     d7
               move.b     d7,(a6)+      ; d7,destination
               move.l     a6,-(sp)
               movea.l    a0,a6
               subq.l     #3,d0
               tst.l      d0
               bne        bigaccu12
               movea.l    (sp)+,a6
               rts        

; Mixt 8 StereokanÑle (=16 MonokanÑle) zusammen - 24 Bit

bigmix16:      movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    (a0)+,a6      ; Track-Volume-Wertetabelle
               movea.l    (a0)+,a4      ; bitsize-Wertetabelle (16/24)
               move.l     d1,d0
               movea.l    a1,a3         ; SourceAdresse 16bit
bigaccu16:     movea.l    a1,a2         ; SourceAdresse 24bit holen
               movea.l    a3,a0         ; SourceAdresse 16bit holen
               clr.l      d2
               move.w     (a6),d2       ; Volume1
               tst.w      (a4)          ; 16bit-samplespur ?
               beq.s      bigaccu16b
               clr.l      d6
               move.b     (a2),d6       ; source1
               lsl.l      #8,d6
               move.b     1(a2),d6      ; source1
               lsl.l      #8,d6
               move.b     2(a2),d6      ; source1
               bra.s      bigaccu16c
bigaccu16b:    move.w     (a0),d6       ; source1,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu16c
               asl.l      #8,d6
bigaccu16c:    bsr        volume24      ; LautstÑrke anpassen (d6)
               move.l     d6,d7         ; source 1 retten
               adda.l     d1,a2
               adda.l     d1,a0
               clr.l      d2
               move.w     2(a6),d2      ; Volume2
               tst.w      2(a4)         ; 16bit-samplespur ?
               beq.s      bigaccu16d
               clr.l      d6
               move.b     (a2),d6       ; source2
               lsl.l      #8,d6
               move.b     1(a2),d6      ; source2
               lsl.l      #8,d6
               move.b     2(a2),d6      ; source2
               bra.s      bigaccu16e
bigaccu16d:    move.w     (a0),d6       ; source2,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu16e
               asl.l      #8,d6
bigaccu16e:    bsr        volume24      ; LautstÑrke anpassen (d6)
               bsr        mixer24       ; mixt (d6 und d7) nach d7
               move.l     d7,-(sp)      ; ergebnis 1+2 retten
               adda.l     d1,a2
               adda.l     d1,a0
               clr.l      d2
               move.w     4(a6),d2      ; Volume3
               tst.w      4(a4)         ; 16bit-samplespur ?
               beq.s      bigaccu16f
               clr.l      d6
               move.b     (a2),d6       ; source3
               lsl.l      #8,d6
               move.b     1(a2),d6      ; source3
               lsl.l      #8,d6
               move.b     2(a2),d6      ; source3
               bra.s      bigaccu16g
bigaccu16f:    move.w     (a0),d6       ; source3,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu16g
               asl.l      #8,d6
bigaccu16g:    bsr        volume24      ; LautstÑrke anpassen (d6)
               move.l     d6,d7         ; source 3 retten
               adda.l     d1,a2
               adda.l     d1,a0
               clr.l      d2
               move.w     6(a6),d2      ; Volume4
               tst.w      6(a4)         ; 16bit-samplespur ?
               beq.s      bigaccu16h
               clr.l      d6
               move.b     (a2),d6       ; source4
               lsl.l      #8,d6
               move.b     1(a2),d6      ; source4
               lsl.l      #8,d6
               move.b     2(a2),d6      ; source4
               bra.s      bigaccu16i
bigaccu16h:    move.w     (a0),d6       ; source4,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu16i
               asl.l      #8,d6
bigaccu16i:    bsr        volume24      ; LautstÑrke anpassen (d6)
               bsr        mixer24       ; mixt 3+4
               move.l     (sp)+,d6      ; ergebnis 1+2 holen
               bsr        mixer24       ; mixt 1+2 und 3+4 zusammen
               move.l     d7,-(sp)      ; mixergebnis 1+2+3+4 retten
               adda.l     d1,a2
               adda.l     d1,a0
               clr.l      d2
               move.w     8(a6),d2      ; Volume5
               tst.w      8(a4)         ; 16bit-samplespur ?
               beq.s      bigaccu16j
               clr.l      d6
               move.b     (a2),d6       ; source5
               lsl.l      #8,d6
               move.b     1(a2),d6      ; source5
               lsl.l      #8,d6
               move.b     2(a2),d6      ; source5
               bra.s      bigaccu16k
bigaccu16j:    move.w     (a0),d6       ; source5,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu16k
               asl.l      #8,d6
bigaccu16k:    bsr        volume24      ; LautstÑrke anpassen (d6)
               move.l     d6,d7         ; source 5 retten
               adda.l     d1,a2
               adda.l     d1,a0
               clr.l      d2
               move.w     10(a6),d2     ; Volume6
               tst.w      10(a4)        ; 16bit-samplespur ?
               beq.s      bigaccu16l
               clr.l      d6
               move.b     (a2),d6       ; source6
               lsl.l      #8,d6
               move.b     1(a2),d6      ; source6
               lsl.l      #8,d6
               move.b     2(a2),d6      ; source6
               bra.s      bigaccu16m
bigaccu16l:    move.w     (a0),d6       ; source6,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu16m
               asl.l      #8,d6
bigaccu16m:    bsr        volume24      ; LautstÑrke anpassen (d6)
               bsr        mixer24       ; mixt 5+6
               move.l     d7,-(sp)      ; ergebnis 5+6 retten
               adda.l     d1,a2
               adda.l     d1,a0
               clr.l      d2
               move.w     12(a6),d2     ; Volume7
               tst.w      12(a4)        ; 16bit-samplespur ?
               beq.s      bigaccu16n
               clr.l      d6
               move.b     (a2),d6       ; source7
               lsl.l      #8,d6
               move.b     1(a2),d6      ; source7
               lsl.l      #8,d6
               move.b     2(a2),d6      ; source7
               bra.s      bigaccu16o
bigaccu16n:    move.w     (a0),d6       ; source7,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu16o
               asl.l      #8,d6
bigaccu16o:    bsr        volume24      ; LautstÑrke anpassen (d6)
               move.l     d6,d7         ; source 7 retten
               adda.l     d1,a2
               adda.l     d1,a0
               clr.l      d2
               move.w     14(a6),d2     ; Volume8
               tst.w      14(a4)        ; 16bit-samplespur ?
               beq.s      bigaccu16p
               clr.l      d6
               move.b     (a2),d6       ; source8
               lsl.l      #8,d6
               move.b     1(a2),d6      ; source8
               lsl.l      #8,d6
               move.b     2(a2),d6      ; source8
               bra.s      bigaccu16q
bigaccu16p:    move.w     (a0),d6       ; source8,16bit
               ext.l      d6
               tst.w      trkall16
               bne.s      bigaccu16q
               asl.l      #8,d6
bigaccu16q:    bsr        volume24      ; LautstÑrke anpassen (d6)
               bsr        mixer24       ; mixt 7+8
               move.l     (sp)+,d6      ; ergebnis 5+6 holen
               bsr        mixer24       ; mixt 5+6 und 7+8 zusammen
               move.l     (sp)+,d6      ; ergebnis 1+2+3+4 holen
               bsr        mixer24       ; mixt 1+2+3+4 und 5+6+7+8 zusammen
               tst.w      trkall16
               beq.s      bigaccu16y
               asl.l      #5,d7         ; End-LautstÑrkekorrektur fÅr 16bit
bigaccu16y:    move.l     d7,d5
               swap.w     d5
               move.l     d7,d6
               asr.w      #8,d6
               move.b     d5,(a5)+      ; d7,destination
               move.b     d6,(a5)+      ; d7,destination
               move.b     d7,(a5)+      ; d7,destination
               addq.l     #2,a3         ; zum nÑchsten 16bit-wert
               addq.l     #3,a1         ; zum nÑchsten 24bit-wert
               subq.l     #3,d0
               tst.l      d0
               bne        bigaccu16
               rts        

; ---------------------------Anfang der Interrupt-Treiber-----------------------

ihandler_play: movem.l    d0-d7/a0-a6,-(sp)
               lea.l      intlist(pc),a3
               move.l     pimode,d0
               tst.w      d0
               ble        playdummy
               cmpi.w     #39,d0
               bgt        playdummy
               lsl.w      #2,d0
               movea.l    0(a3,d0.w),a2
               jmp        (a2)

ihandler_dsp:  movem.l    d0-d7/a0-a6,-(sp)
               lea.l      intlist(pc),a3
               move.l     drimode,d0
               tst.w      d0
               bgt.s      dspinthere
               move.l     dpimode,d0
               tst.w      d0
               ble.s      dspintexit
dspinthere:    cmpi.w     #39,d0
               bgt.s      dspintexit
               lsl.w      #2,d0
               movea.l    0(a3,d0.w),a2
               jmp        (a2)
dspintexit:    movem.l    (sp)+,d0-d7/a0-a6
               rte        

ihandler_rec:  movem.l    d0-d7/a0-a6,-(sp)
               lea.l      intlist(pc),a3
               move.l     rimode,d0
               tst.w      d0
               ble        recdummy
               cmpi.w     #39,d0
               bgt        recdummy
               lsl.w      #2,d0
               movea.l    0(a3,d0.w),a2
               jmp        (a2)

; ----------------------- DATEN ------------------------

intlist:       .DC.l 0
               .DC.l imemplay           ; 1
               .DC.l imemrec            ; 2
               .DC.l ihardplay          ; 3
               .DC.l ihardrec           ; 4
               .DC.l ipeaksolo          ; 5
               .DC.l mrecpeak           ; 6
               .DC.l xmemrec16          ; 7
               .DC.l implaymix          ; 8
               .DC.l xmemplay           ; 9
               .DC.l xmemrec            ; 10
               .DC.l falcplay           ; 11
               .DC.l falcrec            ; 12
               .DC.l dspplay            ; 13
               .DC.l dsprecord          ; 14
               .DC.l dsphbp             ; 15
               .DC.l dsphbr             ; 16
               .DC.l xmemplay8          ; 17
               .DC.l imemr24            ; 18
               .DC.l imemp24            ; 19
               .DC.l xmemrec8           ; 20
               .DC.l xmemplay16         ; 21
               .DC.l xmemplay           ; 22
               .DC.l txmemrec           ; 23
               .DC.l cblread            ; 24
               .DC.l falcplay8          ; 25
               .DC.l falcrec8           ; 26
               .DC.l scrubbing          ; 27
               .DC.l adcemu8            ; 28
               .DC.l ipeakmult          ; 29
               .DC.l mplaymix           ; 30
               .DC.l imempeakp          ; 31
               .DC.l imempkp24          ; 32
               .DC.l dsphbp             ; 33
               .DC.l tdsphbr            ; 34
               .DC.l imemplay           ; 35
               .DC.l imemruser          ; 36
               .DC.l xmdsrec8           ; 37
               .DC.l xmdsplay8          ; 38
               .DC.l xmdsrin8           ; 39

aes_params:    .DC.l control,global,int_in,int_out,addr_in,addr_out
magic:         .DC.l $12233445
matin:         .DC.w 0,0,0,0,0
lowreg:        .DC.b 0
hireg:         .DC.b 0
aesreg:        .DC.b 0
dspreg:        .DC.b 0
dsppath1:      .DC.b 0
dspport:       .DC.b 0
dspconv:       .DC.b 0
dsppdat:       .DC.b 0
dsppath2:      .DC.b 0
clkdiv:        .DC.b 0
mdac:          .DC.w 0
dmarec:        .DC.w 0
dsprec:        .DC.w 0
extrec:        .DC.w 0
dacrec:        .DC.w 0
cardrec:       .DC.w 0
playmod:       .DC.w 0
recmod:        .DC.w 0
smpte:         .DC.b 0
intreg:        .DC.b 0
dintreg:       .DC.b 0
               .EVEN 
dstrm:         .DC.w 0
dsfrm:         .DC.l 0
dsblke:        .DC.l 0
dsfrlen:       .DC.l 0
dsblke2:       .DC.l 0
dsfrlen2:      .DC.l 0
dspart:        .DC.w 0
proff:         .DC.w 0
proffm:        .DC.w 0
bridg1:        .DC.w 0
bridg2:        .DC.w 0
bridg3:        .DC.w 0
bridg4:        .DC.w 0
bridge:        .DC.w 0
cat0:          .DC.w 0
catb0:         .DC.w 0
cat1:          .DC.w 0
catb1:         .DC.w 0
gen:           .DC.w 0
copyobit:      .DC.w 0
scms:          .DC.w 0
empha:         .DC.w 0
dpathw:        .DC.w 0
cblm:          .DC.w 0
hz:            .DC.w 0
rimode:        .DC.l 0
pimode:        .DC.l 0
adwert:        .DC.l 0
dawert:        .DC.l 0
asrc:          .DC.w 0
dsrc:          .DC.w 0
cmdaddr:       .DC.w 0
cmdadcinp:     .DC.w 0
cmdpresc:      .DC.w 1
mcbit:         .DC.w 0
dspm:          .DC.w 0
falcmode:      .DC.w 0
dgmode:        .DC.w 0
drimode:       .DC.l 0
dpimode:       .DC.l 0
dummy:         .DS.l 1
dummy2:        .DS.l 1
int_reg:       .DC.l 0
vmestart:      .DC.l 0
vmemask:       .DC.l 0
strtp:         .DC.l 0
sclockv:       .DC.b $d4,84,208,148,80,20,144,16,116,112,52,48
falctab:       .DC.b 0,3,2,1,11,10,9,8,7,6,5,4,15,14,13,12
plugs:         .DS.b 240
vpluglistp:    .DS.w 11
pluglistp:     .DS.w 11
pluglistr:     .DS.w 11
cardlist:      .DS.l 8
oldval:        .DS.l 1
berrsprung:    .DS.l 1
berrspreg:     .DS.l 1
midisprung:    .DS.l 1
midiktest:     .DC.w 0
midikey:       .DC.w 0
midimax:       .DC.w 0    ; max entrys
midix:         .DC.l 0    ; midi (ch,note)
midipath:      .DC.l 0
midistart:     .DC.l 0
midiend:       .DC.l 0
midisrate:     .DC.l 0
midiloop:      .DC.l 0
miditri:       .DC.l 0
midicount:     .DC.b 0    ; midi pipeline-counter
midioncount:   .DC.b 0    ; midi_on pipeline-counter
midioffcount:  .DC.b 0    ; midi_off pipeline-counter
vmidioncount:  .DC.b 0    ; midi_on pipeline-counter
vmidioffcount: .DC.b 0    ; midi_off pipeline-counter
               .EVEN 
midismpte:     .DC.l 100  ; aktuelle midiplay-startwerte

mword:         .DC.b 0,0
smpwert:       .DS.l 2
cardz:         .DC.w 0
cardsl:        .DC.w 0
cadr:          .DS.l 4
pos:           .DS.l 1
rpos:          .DS.l 1
von:           .DS.l 18
bvon:          .DS.l 18
von2:          .DS.l 18
bis2:          .DS.l 18
rvon2:         .DS.l 18
rvon:          .DS.l 18
rbvon:         .DS.l 18
bis:           .DS.l 18
bbis:          .DS.l 18
rbis:          .DS.l 1
rbbis:         .DS.l 1
rbis2:         .DS.l 1
dvon:          .DS.l 1
rdvon:         .DS.l 1
dbvon:         .DS.l 1
rdbvon:        .DS.l 1
dvon2:         .DS.l 1
rdvon2:        .DS.l 1
dbis2:         .DS.l 1
rdbis2:        .DS.l 1
dbis:          .DS.l 1
rdbis:         .DS.l 1
dbbis:         .DS.l 1
rdbbis:        .DS.l 1
len:           .DS.l 1
rlen:          .DS.l 1
step:          .DS.l 1
mode:          .DS.l 1
dstep:         .DS.l 1
dmode:         .DS.l 1
fifo:          .DS.l 1
rfifo:         .DS.l 1
dfifo:         .DS.l 1
rdfifo:        .DS.l 1
stath:         .DS.l 1
regh:          .DS.l 1
playread:      .DS.l 1
playstart:     .DS.l 1
dstath:        .DS.l 1
dregh:         .DS.l 1
dplayread:     .DS.l 1
dplaystart:    .DS.l 1
peakbuf:       .DS.l 1
rpeakbuf:      .DS.l 1
peakmerk:      .DS.l 1
rpeakmerk:     .DS.l 1
dpeakbuf:      .DS.l 1
rdpeakbuf:     .DS.l 1
dpeakmerk:     .DS.l 1
rdpeakmerk:    .DS.l 1
sectors:       .DS.l 1
endcount:      .DS.l 1
rendcount:     .DS.l 1
dendcount:     .DS.l 1
rdendcount:    .DS.l 1
dsectors:      .DS.l 1
fileart:       .DS.l 1
rfileart:      .DS.l 1
loop:          .DS.l 1
crosflag:      .DS.l 1
dfileart:      .DS.l 1
rdfileart:     .DS.l 1
dloop:         .DS.l 1
dcrosflag:     .DS.l 1
dendflag:      .DS.l 1
rdendflag:     .DS.l 1
handle:        .DS.l 1
rhandle:       .DS.l 1
seeknr:        .DS.l 1
sectnr:        .DS.l 1
rsectnr:       .DS.l 1
bsectnr:       .DS.l 1
load:          .DS.w 1
specnam:       .DC.b "SOUND.INF",0
Text:          .DC.b 13,10,"Xbios-Driver for StarTrack is ready...     ",13,10,0
demotxt:       .DC.b "no Audiohardware found -> Demomode",13,10,0
               .EVEN 
nfoundtxt:     .DC.b 13,"no Audiocard in Slot:",0
yfoundtxt:     .DC.b 13,"*found* Audiocard in Slot:",0
intext:        .DC.b "MFP ",13,10,0
intext2:       .DC.b "INT ",13,10,0
tex:           .DC.b "Jippee",13,10,0
showc:         .DC.b 13,10
showt0:        .DC.b "/",0
showt1:        .DC.b "P",0
showt2:        .DC.b "MI",0
showt3:        .DC.b "AD",0
showr0:        .DC.b "->R ",0
showr1:        .DC.b "->MX ",0
showr2:        .DC.b "->DA ",0
showbt1:       .DC.b "MI",0
showbt2:       .DC.b "DX",0
showbt3:       .DC.b "EI",0
showbr0:       .DC.b "->EX ",0
showbr1:       .DC.b "->DI ",0
showbr2:       .DC.b "->MX ",0
showcvn:       .DC.b "CVT0 ",0
showcvj:       .DC.b "CVT1 ",0
showpm:        .DC.b "PM",0
showpm16:      .DC.b "PM16 ",0
showrm:        .DC.b "RM",0
showeadc:      .DC.b "EADC",0
showm16:       .DC.b "16b      ",0
showm24:       .DC.b "24b      ",0
               .EVEN 
gem:           .DC.w 0
osrc:          .DC.w 0
rett:          .DC.l 0
rrett:         .DC.l 0
rfirstint:     .DC.w 0
pfirstint:     .DC.w 0
plugcnt:       .DC.w 0
midisuch:      .DC.w 0
midiw:         .DC.l 0
dmidisuch:     .DC.w 0
dmidiw:        .DC.l 0
ustartm:       .DC.l 0
ustartp:       .DC.l 0
usyncz:        .DC.w 0
crvepnt:       .DC.l 0,0
peakw:         .DC.l 2
peaklist:      .DS.w 16
playbyte:      .DS.l 18
dplaybyte:     .DS.l 8
recbyte:       .DS.l 8
drecbyte:      .DS.l 9
nopkbuf:       .DC.w 0
pkrq:          .DC.w 0
peakvalue:     .DC.l 17
lock:          .DC.w 0
firstbuf:      .DC.w 0
pbufstrt:      .DS.l 1
pbufend:       .DS.l 1
rbufstrt:      .DS.l 1
rbufend:       .DS.l 1
recmics:       .DS.l 1
merklen:       .DC.l 0
framediv:      .DC.w 0
frames:        .DC.l 0
mtcmod:        .DC.w 0
mtclist:       .DC.b 0,0,0,0,0,0,0,0
sndmode:       .DC.w 1
highsr:        .DC.w 0
modr24:        .DC.w 0
trkall16:      .DC.w 0
playch:        .DC.w 0
pnleft:        .DC.l 0
pnright:       .DC.l 0
pncount:       .DC.w 0
ptracks:       .DC.w 0
rtracks:       .DC.w 0
montrack:      .DC.w 0
montrack2:     .DC.w 0
src_inter:     .DC.w 0
cause:         .DC.w 0
bufop:         .DC.w 0
pbufptr:       .DS.l 1
rbufptr:       .DS.l 1
snderr:        .DC.w 0
ltatt:         .DC.w 0
rtatt:         .DC.w 0
cardmagc:      .DC.w 0
lgain:         .DC.w 0
rgain:         .DC.w 0
xrch:          .DC.w 0
src:           .DC.w 0
dst:           .DC.w 0
srcclk:        .DC.w 0
prescale:      .DC.w 0
tosv1:         .DS.w 1
tosv2:         .DS.l 1
tosv3:         .DS.w 1
prgemul:       .DC.w 0
cooksnd:       .DC.l 0
ncooksnd:      .DC.l 0
cookmch:       .DC.l 0
ncookmch:      .DC.l 0
cookcpu:       .DC.l 0
ncookcpu:      .DC.l 0
startupmem:    .DC.l 0
backup:        .DC.l 0
dspvlong:      .DC.l 0
cookvdo:       .DC.l 0
ncookvdo:      .DC.l 0
cookfpu:       .DC.l 0
ncookfpu:      .DC.l 0
emuladc:       .DC.w 0
emulact8:      .DC.w 0
cookmgmc:      .DC.l 0
cookmilan:     .DC.l 0
matout:        .DC.w 0
time:          .DC.l 0
slowmode:      .DC.w 0
protocol:      .DC.w 0
gpiodat:       .DC.w 0
gpdirect:      .DC.w 0
eclkmode:      .DC.w 0
exclkm:        .DC.w 0
endless:       .DC.w 0
nopeaks:       .DC.w 0
csysadr:       .DC.l 0
demo:          .DC.w 0
falcxmov:      .DC.w 0
devconr:       .DC.w 0
falcxnr:       .DC.w 0

;--------------------------------
_dsp_codebuf:  .DS.b 72
_dsp_subs:     .DS.b 96
_dsp_max_avail_mem:       .DC.l 0
_dsp_avail_pmem:          .DC.l 0
_dsp_xreserve: .DC.l 0
_dsp_ability:  .DC.w 0
_dsp_free_subridx:        .DC.w 0
_dsp_uniqueability:       .DC.w 0
_dsp_tmtbuf_ptr:          .DC.l 0
_dsp_tmtsize:  .DC.l 0
_dsp_num_tmtblks:         .DC.l 0
_dsp_tmtblks_done_ptr:    .DC.l 0
_dsp_rcvbuf_ptr:          .DC.l 0
_dsp_rcvsize:  .DC.l 0
_dsp_num_rcvblks:         .DC.l 0
_dsp_rcvblks_done_ptr:    .DC.l 0
_dsp_lock:     .DC.w 0
_snd_lock:     .DC.b 0
               .EVEN 
_dsp_subr_adr: .DC.l 0
_dsp_rcv_ptr:  .DC.l 0
_dsp_tmt_ptr:  .DC.l 0
_snd_ch_att:   .DC.w 0

program_end:   
;--------------------------------

muster:        movea.l    (a0)+,a1      ; anfadresse
               move.l     (a0)+,d0
               move.l     (a0)+,d1
               btst       #0,modr24
               bne.s      muster24
muster2:       move.l     d1,(a1)+
               cmpa.l     d0,a1
               blt.s      muster2
               clr.l      d0
               rts        
muster24:      move.l     d1,d2
               move.l     d1,d3
               lsr.w      #8,d3         ; midbyte
               swap.w     d2            ; highbyte
muster24b:     move.b     d2,(a1)+      ; put highbyte
               move.b     d3,(a1)+      ; put midbyte
               move.b     d1,(a1)+      ; put lowbyte
               cmpa.l     d0,a1
               blt.s      muster24b
               clr.l      d0
               rts        

testbits:      movea.l    (a0)+,a1      ; anfadresse
               move.l     (a0)+,d0
               move.l     d0,d2
               sub.l      a1,d2
               btst       #0,modr24
               bne.s      testbit24
               asr.l      #8,d2
               move.l     #0,d1
               clr.l      d3
testbit2:      move.l     d1,(a1)+
               addi.l     #1,d3
               cmp.l      d2,d3
               blt.s      testbit2
               clr.l      d3
               move.l     #1,d1
testbit3:      move.l     d1,(a1)+
               addi.l     #1,d3
               cmp.l      d2,d3
               blt.s      testbit3
               clr.l      d3
               cmpi.l     #$80000000,d1
               beq.s      testbit4
               lsl.l      #1,d1
               bra.s      testbit3
testbit4:      clr.l      d0
               rts        
testbit24:     lsr.l      #8,d2
               lsr.l      #1,d2
               move.l     #0,d1
               clr.l      d3
               move.l     d1,d7
               swap.w     d7
               move.l     d1,d6
               asr.w      #8,d6
testbit24b:    move.b     d7,(a1)+
               move.b     d6,(a1)+
               move.b     d1,(a1)+
               move.b     #0,(a1)+
               move.b     #0,(a1)+
               move.b     #0,(a1)+
               addi.l     #1,d3
               cmp.l      d2,d3
               blt.s      testbit24b
               clr.l      d3
               move.l     #1,d1
               move.l     d1,d7
               swap.w     d7
               move.l     d1,d6
               asr.w      #8,d6
testbit24c:    move.b     d7,(a1)+
               move.b     d6,(a1)+
               move.b     d1,(a1)+
               move.b     #0,(a1)+
               move.b     #0,(a1)+
               move.b     #0,(a1)+
               addi.l     #1,d3
               cmp.l      d2,d3
               blt.s      testbit24c
               clr.l      d3
               cmpi.l     #$800000,d1
               beq.s      testbit24d
               lsl.l      #1,d1
               move.l     d1,d7
               swap.w     d7
               move.l     d1,d6
               asr.w      #8,d6
               bra.s      testbit24c
testbit24d:    move.l     #0,d1
               clr.l      d3
               move.l     d1,d7
               swap.w     d7
               move.l     d1,d6
               lsr.w      #8,d6
testbit24e:    move.b     #0,(a1)+
               move.b     #0,(a1)+
               move.b     #0,(a1)+
               move.b     d7,(a1)+
               move.b     d6,(a1)+
               move.b     d1,(a1)+
               addi.l     #1,d3
               cmp.l      d2,d3
               blt.s      testbit24e
               clr.l      d3
               move.l     #1,d1
               move.l     d1,d7
               swap.w     d7
               move.l     d1,d6
               lsr.w      #8,d6
testbit24f:    move.b     #0,(a1)+
               move.b     #0,(a1)+
               move.b     #0,(a1)+
               move.b     d7,(a1)+
               move.b     d6,(a1)+
               move.b     d1,(a1)+
               addi.l     #1,d3
               cmp.l      d2,d3
               blt.s      testbit24f
               clr.l      d3
               cmpi.l     #$800000,d1
               beq.s      testbit24g
               lsl.l      #1,d1
               move.l     d1,d7
               swap.w     d7
               move.l     d1,d6
               lsr.w      #8,d6
               bra.s      testbit24f
testbit24g:    clr.l      d0
               rts        

convstm:       move.w     (a0)+,d1      ; channels
               movea.l    (a0)+,a1      ; anfadresse filemem
               movea.l    (a0)+,a2      ; zieladresse directstream
               move.l     (a0)+,d0      ; anzahl
               btst       #0,modr24
               bne.s      convstm24
convstm16:     move.w     (a1)+,(a2)+
               cmpi.w     #1,d1
               beq.s      convstm16b
               adda.l     #2,a1
convstm16b:    subi.l     #1,d0
               cmpi.l     #0,d0
               bgt.s      convstm16
               clr.l      d0
               rts        
convstm24:     move.b     (a1)+,(a2)+
               move.b     (a1)+,(a2)+
               move.b     (a1)+,(a2)+
               cmpi.w     #1,d1
               beq.s      convstm24b
               adda.l     #3,a1
convstm24b:    adda.l     #1,a2
               subi.l     #1,d0
               cmpi.l     #0,d0
               bgt.s      convstm24
               clr.l      d0
               rts        

convmst:       move.w     (a0)+,d1      ; channels
               movea.l    (a0)+,a1      ; anfadresse directstream
               movea.l    (a0)+,a2      ; zieladresse filemem
               move.l     (a0)+,d0      ; anzahl
               btst       #0,modr24
               bne.s      convmst24
convmst16:     move.w     (a1)+,(a2)+
               cmpi.w     #1,d1
               beq.s      convmst16b
               adda.l     #2,a2
convmst16b:    subi.l     #1,d0
               cmpi.l     #0,d0
               bgt.s      convmst16
               clr.l      d0
               rts        
convmst24:     move.b     (a1)+,(a2)+
               move.b     (a1)+,(a2)+
               move.b     (a1)+,(a2)+
               cmpi.w     #1,d1
               beq.s      convmst24b
               adda.l     #3,a2
convmst24b:    adda.l     #1,a2
               subi.l     #1,d0
               cmpi.l     #0,d0
               bgt.s      convmst24
               clr.l      d0
               rts        

fastcut:       movea.l    (a0)+,a1      ; anfadresse
               move.l     (a0)+,d0
               movea.l    d0,a6         ; endadresse
               sub.l      a1,d0         ; ist die Anzahl der Bytes
               clr.l      d2            ; Register lîschen
               moveq.l    #48,d1
               cmp.l      d1,d0
               blt.s      cutrest
               clr.l      d3
               clr.l      d4
               clr.l      d5
               clr.l      d6
               clr.l      d7
               movea.l    d2,a0
               movea.l    a0,a1
               movea.l    a0,a2
               movea.l    a0,a3
               movea.l    a0,a4
               movea.l    a0,a5         ; sind zusammen 13 Register = 52 Bytes
fastcut2:      movem.l    d2-d7/a0-a5,-(a6)
               sub.l      d1,d0
               cmp.l      d1,d0
               bge.s      fastcut2
cutrest:       tst.l      d0
               beq.s      cutend
cutrest2:      lsr.l      #2,d0
               subq.l     #1,d0
cutrest3:      move.l     d2,-(a6)
               dbra       d0,cutrest3
cutend:        clr.l      d0
               rts        

intbreak:      movem.l    a1/a6,-(sp)
               lea.l      intreg(pc),a1
               move.b     (a1),d1
               bclr       d0,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$280(a6)
               movem.l    (sp)+,a1/a6
               rts        

fading:        movea.l    (a0)+,a3      ; wertetabelle
               move.w     (a0)+,d0      ; werte (246)
               movea.l    (a0)+,a1      ; anfang
               movea.l    (a0)+,a2      ; ende
               move.l     (a0)+,d3      ; ist sampleanzahl/4/werte
               movea.l    a3,a0         ; a0 zeiger auf wertetabelle
               btst       #0,modr24     ; 24 bit ?
               bne        fading24      ; dann dorthin
               tst.l      d3            ; samplezahl<werte ?
               bne.s      fadanf2a
               moveq.l    #1,d3         ; mind. 1 Sample pro Wert
fadanf2a:      subi.w     #1,d0         ; werte-1 (245) fÅr loop
fadanf2:       move.w     (a0),d2
               move.w     2(a0),d6      ; erste beiden Datenwerte holen
               sub.w      d2,d6         ; voneinander subtrahieren = d6,Steigung
               andi.l     #$ffff,d6
               btst       #15,d6
               beq.s      fpositiv      ; -> positive Steigung
fnegativ:      neg.w      d6
               divu.w     d3,d6         ; Steigung/Anzahl Samples pro Wert = SteigungsstÅck
fneg2:         neg.w      d6
               bra.s      fadanf2b
fpositiv:      divu.w     d3,d6         ; Steigung/Anzahl Samples pro Wert
fadanf2b:      move.w     d3,d4
               subi.w     #1,d4         ; Anzahl Samples pro Wert fÅr Schleife
fadanf3:       move.w     (a1),d1       ; Sample holen
               bsr        fade          ; faden
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
               move.w     (a1),d1       ; Sample holen
               bsr        fade          ; faden
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
               add.w      d6,d2         ; SteigungsstÅck zum Anfangswert dazu
               dbra       d4,fadanf3    ; Anzahl Samples pro Wert
               addq.l     #2,a0         ; zum nÑchsten Datenwert
               dbra       d0,fadanf2    ; Anzahl Werte
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg        ; dann weg
fadanf4:       move.w     (a1),d1
               bsr        fade          ; rest faden
               cmpa.l     a2,a1
               blt.s      fadanf4       ; bis zum Ende ?
fadweg:        clr.l      d0
               rts        
calc16:        andi.l     #$ffff,d1
               mulu.w     d2,d1         ; lowword mal aktuelle steigung
               swap.w     d1
               rts        
fade:          andi.l     #$ffff,d1     ; aktuelles Sample
               btst       #15,d1
               beq.s      fnoneg        ; wenn positiv dahin
               not.w      d1
               bsr        calc16
               not.w      d1
               bra.s      fweiter
fnoneg:        bsr        calc16
fweiter:       move.w     d1,(a1)+      ; Sample speichern, zum nÑchsten Sample
               clr.l      d1
               rts        
fading24:      tst.l      d3
               bne.s      fadanf24a
               moveq.l    #1,d3         ; mind. 1 Sample pro Wert
fadanf24a:     subi.w     #1,d0
fadanf24:      move.w     (a0),d2
               move.w     2(a0),d6      ; erste beiden Datenwerte holen
               sub.w      d2,d6         ; voneinander subtrahieren = Steigung
               andi.l     #$ffff,d6
               btst       #15,d6
               beq.s      fpositiv24    ; -> positive Steigung
fnegativ24:    neg.w      d6
               divu.w     d3,d6         ; Steigung/Anzahl Samples pro Wert = SteigungsstÅck
fneg24:        neg.w      d6
               bra.s      fadanf24b
fpositiv24:    divu.w     d3,d6         ; Steigung/Anzahl Samples pro Wert
fadanf24b:     move.w     d3,d4
               subi.w     #1,d4         ; Anzahl Samples pro Wert holen fÅr Schleife
fadanf24c:     clr.l      d1
               move.b     (a1),d1       ; Sample holen high
               lsl.l      #8,d1
               move.b     1(a1),d1      ; Sample holen mid
               lsl.l      #8,d1
               move.b     2(a1),d1      ; Sample holen low
               bsr        fade24        ; faden
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg24      ; dann weg
               clr.l      d1
               move.b     (a1),d1       ; Sample holen high
               lsl.l      #8,d1
               move.b     1(a1),d1      ; Sample holen mid
               lsl.l      #8,d1
               move.b     2(a1),d1      ; Sample holen low
               bsr        fade24        ; faden
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg24      ; dann weg
               add.w      d6,d2         ; SteigungsstÅck zum Anfangswert dazu
               dbra       d4,fadanf24c  ; Anzahl Samples pro Wert
               addq.l     #2,a0         ; zum nÑchsten Datenwert
               dbra       d0,fadanf24   ; Anzahl Werte
               cmpa.l     a2,a1         ; Ende ?
               bge.s      fadweg24      ; dann weg
fadanf24d:     clr.l      d1
               move.b     (a1),d1       ; Sample holen high
               lsl.l      #8,d1
               move.b     1(a1),d1      ; Sample holen mid
               lsl.l      #8,d1
               move.b     2(a1),d1      ; Sample holen low
               bsr        fade24        ; rest faden
               cmpa.l     a2,a1
               blt.s      fadanf24d     ; bis zum Ende ?
fadweg24:      clr.l      d0
               rts        
calc24:        move.l     d1,d7
               swap.w     d7
               andi.l     #$ff,d7
               mulu.w     d2,d7         ; highbyteword mal aktuelle Steigung
               andi.l     #$ffff,d1
               mulu.w     d2,d1         ; lowword mal aktuelle steigung
               swap.w     d1
               andi.l     #$ffff,d1     ; /65536
               add.l      d7,d1
               rts        
fade24:        andi.l     #$ffffff,d1   ; aktuelles Sample
               btst       #23,d1
               beq.s      fnoneg24      ; wenn positiv dahin
               ori.l      #$ff000000,d1
               not.l      d1
               bsr        calc24
               not.l      d1
               bra.s      fweiter24
fnoneg24:      bsr        calc24
fweiter24:     move.l     d1,d7
               swap.w     d7
               move.l     d1,d5
               lsr.w      #8,d5
               move.b     d7,(a1)+      ; Sample speichern, zum nÑchsten Sample
               move.b     d5,(a1)+      ; Sample speichern, zum nÑchsten Sample
               move.b     d1,(a1)+      ; Sample speichern, zum nÑchsten Sample
               rts        

zerono:        movea.l    (a0)+,a3      ; anf
               movea.l    (a0)+,a1      ; ende
               move.w     (a0)+,d0      ; Richtung
               movea.l    a3,a0
               btst       #0,modr24
               bne.s      zerono24
               tst.w      d0
               bne.s      znback
znvor:         move.w     (a0)+,d1
               tst.w      d1
               bne.s      znvorweg
               cmpa.l     a1,a0
               blt.s      znvor
               move.l     #-1,d0
               rts        
znvorweg:      move.l     a0,d0
               subq.l     #2,d0
               rts        
znback:        move.w     -(a1),d1
               tst.w      d1
               bne.s      znbackweg
               cmpa.l     a0,a1
               bgt.s      znback
               move.l     #-1,d0
               rts        
znbackweg:     move.l     a1,d0
               rts        
zerono24:      tst.w      d0
               bne.s      znback24
znvor24:       clr.l      d1
               move.b     (a0)+,d1
               lsl.l      #8,d1
               move.b     (a0)+,d1
               lsl.l      #8,d1
               move.b     (a0)+,d1
               bclr       #0,d1         ; wegen Userbit !
               tst.l      d1
               bne.s      znvorw24
               cmpa.l     a1,a0
               blt.s      znvor24
               move.l     #-1,d0
               rts        
znvorw24:      move.l     a0,d0
               subq.l     #3,d0
               rts        
znback24:      subq.l     #3,a1
               clr.l      d1
               move.b     (a1),d1
               lsl.l      #8,d1
               move.b     1(a1),d1
               lsl.l      #8,d1
               move.b     2(a1),d1
               bclr       #0,d1         ; wegen Userbit !
               tst.l      d1
               bne.s      znbackweg
               cmpa.l     a0,a1
               bgt.s      znback24
               move.l     #-1,d0
               rts        

digana:        lea.l      lowreg(pc),a1
               lea.l      asrc(pc),a6   ; asrc=digana
               move.b     (a1),d1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq.s      getdiga
               move.w     d0,(a6)
               cmpi.w     #1,d0
               bgt.s      digerr
               tst.w      d0
               blt.s      digerr
               andi.w     #$fe,d1
               add.b      d0,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,(a6)
               tst.w      d0
               bne.s      analog
               andi.w     #3,d1
               move.b     d1,(a6)
analog:        bsr        seteclk
               clr.l      d0
               rts        
digerr:        move.l     #-1,d0
               rts        
getdiga:       clr.l      d0
               move.w     (a6),d0
               rts        

digcom:        lea.l      lowreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               lea.l      dsrc(pc),a5   ; dsrc=digital source
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getdig
               move.w     d0,(a5)
               cmpi.w     #2,d0
               bgt.s      digerr
               tst.w      d0
               blt.s      digerr
               bne.s      inkoax
inopto:        bclr       #1,d1
               bra.s      digcom2
inkoax:        cmpi.b     #1,d0
               bne.s      inaes
               bset       #1,d1
digcom2:       move.b     d1,(a1)
               lea.l      asrc(pc),a5   ; asrc=digana
               tst.w      (a5)
               bne.s      digcom3
               andi.w     #3,d1         ; bei digital ausfiltern
digcom3:       move.b     d1,(a6)
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               bclr       #7,d1
               bclr       #3,d1         ; raus aus playmode 128bit...
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.w     #0,montrack2  ; ...denn montrack wird ja 1 hîher
               bsr        pushaesr
               bsr        seteclk
               clr.l      d0
               rts        
inaes:         bset       #1,d1
               move.b     d1,(a1)
               move.b     d1,(a6)
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               bset       #7,d1
               bclr       #3,d1         ; raus aus playmode 128bit...
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.w     #0,montrack2  ; ...denn montrack wird ja 1 hîher
               bsr        pushaesr
               bsr        seteclk
               clr.l      d0
               rts        
getdig:        clr.l      d0
               move.w     (a5),d0
               rts        

sclock:        move.w     (a0)+,d0      ; wert
dclock:        lea.l      lowreg(pc),a1
               move.b     (a1),d1
               cmpi.w     #-1,d0
               beq        getsclock
               lea.l      hz(pc),a2
               move.w     d0,(a2)
               tst.w      d0
               blt.s      sclocke
               bne.s      sclock1
               andi.w     #3,d1
               bra.s      sclockwr
sclock1:       cmpi.w     #1,d0
               bne.s      sclock2
               andi.w     #3,d1
               bset       #2,d1
               bra.s      sclockwr
sclock2:       cmpi.w     #2,d0
               bne.s      sclock3
               andi.w     #3,d1
               bset       #3,d1
               bra.s      sclockwr
sclock3:       cmpi.w     #3,d0
               bne.s      sclock4
               andi.w     #3,d1
               bset       #2,d1
               bset       #3,d1
               bra.s      sclockwr
sclock4:       cmpi.w     #15,d0
               bgt.s      sclocke
               andi.w     #3,d1
               subi.w     #4,d0
               lea.l      sclockv(pc),a3
               move.b     0(a3,d0.w),d2
               add.b      d2,d1
sclockwr:      move.b     (a1),d0       ; alten wert holen
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      asrc(pc),a5   ; asrc=digana
               tst.w      (a5)
               bne.s      sclockwr2
               andi.w     #3,d1         ; bei digital ausfiltern
sclockwr2:     move.b     d1,(a6)
               btst       #5,d0         ; war vorher external wordsync ?
               beq.s      noextword
               bsr        recreset      ; XXL - unter Vorbehalt
noextword:     bsr        seteclk
               clr.l      d0
               rts        
sclocke:       move.l     #-1,d0
               rts        
getsclock:     clr.l      d0
               lea.l      hz(pc),a2
               move.w     (a2),d0
               rts        

errorcode:     lea.l      hireg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               clr.l      d0
               move.b     $20(a6),d0
               andi.w     #7,d0
               rts        

digcode:       lea.l      hireg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               bset       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               clr.l      d0
               move.b     $20(a6),d0
               btst       #7,d0
               bne.s      emphyes
               andi.w     #7,d0
               bra.s      digcod2
emphyes:       andi.w     #7,d0
               bset       #3,d0
digcod2:       bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               bchg       #3,d0
               andi.b     #$0f,d0
               rts        

frecres:       lea.l      snderr(pc),a1
               bclr       #4,(a1)
               bclr       #5,(a1)
               lea.l      stack,a0
               lea.l      falcmode(pc),a6
               move.w     (a6),d0
               move.w     d0,(a0)
;               bsr        compatible   ; soundstatus-reset
               clr.l      d0            ; fÅr Fifo-reset weglassen
               rts                      ; dito

recreset:      movem.l    d0-d7/a0-a6,-(sp)
               lea.l      hireg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d1
               bset       #1,d1
               bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.l     #2,d0
               bsr        pause
               bclr       #1,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.l     #2,d0
               bsr        pause
               bsr        kickstart
               movem.l    (sp)+,d0-d7/a0-a6
               clr.l      d0
               rts        

pause:         movem.l    d1-d3,-(sp)
               move.l     $4ba,d1
paus1:         move.l     $4ba,d2
               sub.l      d1,d2
               tst.l      d2
               bmi.s      overrun
paus2:         cmp.l      d0,d2
               blt.s      paus1
               movem.l    (sp)+,d1-d3
               rts        
overrun:       move.l     #-1,d3
               sub.l      d1,d3
               add.l      d3,d2
               bra.s      paus2

kickstart:     move.l     dawert(pc),d0
               move.l     d0,-(sp)
               lea.l      stack,a0
               move.l     #0,(a0)
               bsr        volda         ; volume silence
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     #2,d0
               bsr        matoutsel
               bsr        getdspreg
               andi.b     #$fc,d1
               move.b     d1,$80(a6)
               lea.l      aesreg(pc),a3
               move.b     (a3),d3
               move.w     #4,d7
toggle:        bset       #3,d3
               move.b     d3,$c0(a6)
               move.b     d3,$c0(a6)
               move.l     #2,d0
               bsr        pause
               bclr       #3,d3
               move.b     d3,$c0(a6)
               move.l     #2,d0
               bsr        pause
               dbra       d7,toggle
               move.l     #2,d0
               bsr        pause
               move.b     (a3),d3
               move.b     d3,$c0(a6)
               bsr        getdspreg
               move.b     d1,$80(a6)
               move.l     #2,d0
               bsr        pause
               lea.l      montrack(pc),a1
               move.w     #0,2(a1)      ; alten montrack-wert setzen
               bsr        pushaesr
               lea.l      stack,a0
               move.l     (sp)+,(a0)
               bsr        volda         ; volume rewrite
kickleave:     clr.l      d0
               rts        

bypass:        lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d0      ; wert
               tst.w      d0
               blt.s      byperr
               cmpi.w     #1,d0
               bgt.s      byperr
               beq.s      fifoplay
               movem.l    d0-d7/a0-a6,-(sp)
               move.w     #0,d3
               bsr        profmake
               movem.l    (sp)+,d0-d7/a0-a6
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; DSP-Out->DAC
               lea.l      dspart(pc),a3
               move.w     (a3),d3
               tst.w      d3
               bne.s      bypassx
               move.w     #2,d0         ; A/D->DAC
bypassx:       move.w     d0,dacrec
               bsr        matinsel
               cmpi.w     #2,d3
               bne.s      bypassz
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPIN-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
bypassz:       clr.l      d0
               rts        
byperr:        move.l     #-1,d0
               rts        

fifoplay:      movem.l    d0-d7/a0-a6,-(sp)
               move.w     #1,d3
               bsr        profmake
               movem.l    (sp)+,d0-d7/a0-a6
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               lea.l      dspart(pc),a3
               move.w     (a3),d3
               cmpi.w     #2,d3
               beq.s      fifopla2
               move.w     #1,d0         ; DMAPLAY->DAC
               move.w     d0,dacrec
               bsr        matinsel
               clr.l      d0
               rts        
fifopla2:      move.w     #3,d0         ; DSP-Out->DAC
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSP-Input-auswahl
               move.w     #1,d0         ; DMA-Play->DSP-Input
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
               clr.l      d0
               rts        

pushaesr:      movem.l    d0-d7/a0-a6,-(sp)
               lea.l      playmod(pc),a1
               move.w     (a1),d1
               cmpi.w     #2,d1         ; 128Bit mode ?
               blt.s      pmonleave
               bsr        setmontr2     ; monitorchannel aktualisieren
pmonweg:       movem.l    (sp)+,d0-d7/a0-a6
               rts        
pmonleave:     lea.l      montrack(pc),a1
               move.w     #0,2(a1)      ; set old montrack-value
               lea.l      aesreg(pc),a1 ; digmode einstellen
               move.b     (a1),d1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      highsr(pc),a2
               move.w     (a2),d2
               bclr       #2,d1         ; normal digmode
               bclr       #3,d1         ; play normalmode
               bclr       #4,d1         ; rec normalmode
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               bsr        nhrdtst
               btst       #0,d0         ; neue oder alte hardware?
               bne        pmonle2       ; alte hardware!
               move.b     d1,$c0(a6)    ; doppelt wegen sum24
pmonle2:       lea.l      modr24(pc),a3
               move.b     (a3),d0
               btst       #0,d0
               bne.s      pmonmdh24
               move.b     #0,(a3)
               tst.w      d2
               beq.s      pmonweg
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               bra.s      pmonweg
pmonmdh24:     move.b     #1,(a3)
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
               tst.w      d2
               beq.s      pmonweg
               move.b     d1,$c0(a6)
               bra        pmonweg

profmake:      lea.l      proffm(pc),a2
               move.w     (a2),d2
               tst.w      d2
               bne.s      proffja
proffno:       tst.w      d3
               bne.s      proffno1
proffno0:      lea.l      bridg3(pc),a3
               move.w     (a3),-(sp)
               bsr        copyone
               lea.l      bridg4(pc),a3
               move.w     (a3),-(sp)
               bsr        prot
               bra.s      profend
proffno1:      lea.l      bridg1(pc),a3
               move.w     (a3),-(sp)
               bsr        copyone
               lea.l      bridg2(pc),a3
               move.w     (a3),-(sp)
               bsr        prot
profend:       rts        
proffja:       tst.w      d3
               bne.s      profja1
profja0:       move.w     #0,d2
               move.w     d2,(a2)
               lea.l      cat0(pc),a3
               lea.l      catb0(pc),a4
               move.w     (a4),(a3)
               lea.l      cat1(pc),a3
               lea.l      catb1(pc),a4
               move.w     (a4),(a3)
               lea.l      scms(pc),a3
               move.w     (a3),-(sp)
               bsr        prot
               lea.l      gen(pc),a3
               move.w     (a3),-(sp)
               bsr        genera
               lea.l      cat0(pc),a3
               move.w     (a3),-(sp)
               bsr        categ0
               lea.l      cat1(pc),a3
               move.w     (a3),-(sp)
               bsr        categ1
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      empha(pc),a6
               move.w     (a6),d0       ; wert
               bsr        emphasis2
               lea.l      aesreg(pc),a3
               move.b     (a3),d4
               bclr       #0,d4
               bclr       #3,d4         ; raus aus playmode 128bit...
               move.b     d4,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d4,$c0(a6)
               move.w     #0,montrack2  ; ...denn montrack wird ja 1 hîher
               bsr        pushaesr
               rts        
profja1:       move.w     #1,d2
               move.w     d2,(a2)
               lea.l      cat0(pc),a3
               lea.l      catb0(pc),a4
               move.w     (a3),(a4)
               lea.l      cat1(pc),a3
               lea.l      catb1(pc),a4
               move.w     (a3),(a4)
               bsr        proffhz
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               lea.l      empha(pc),a6
               move.w     (a6),d0       ; wert
               bsr        emphasis2
               move.w     #1,-(sp)
               bsr        genprof
               lea.l      aesreg(pc),a3
               move.b     (a3),d4
               bset       #0,d4
               bclr       #3,d4         ; raus aus playmode 128bit...
               move.b     d4,(a3)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d4,$c0(a6)
               move.w     #0,montrack2  ; ...denn montrack wird ja 1 hîher
               bsr        pushaesr
               rts        

prot:          move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               tst.w      d7
               bne.s      prot1
prot0:         bclr       #0,d6
               bra.s      prot2
prot1:         bset       #0,d6
prot2:         move.b     d6,(a6)
               lea.l      scms(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

categ0:        move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               tst.w      d7
               bne.s      cate1
cate0:         bclr       #6,d6
               bra.s      cate2
cate1:         bset       #6,d6
cate2:         move.b     d6,(a6)
               lea.l      cat0(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

categ1:        move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               tst.w      d7
               bne.s      cateb1
cateb0:        bclr       #7,d6
               bra.s      cateb2
cateb1:        bset       #7,d6
cateb2:        move.b     d6,(a6)
               lea.l      cat1(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

genera:        move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               tst.w      d7
               bne.s      genera1
genera0:       bclr       #5,d6
               bra.s      genera2
genera1:       bset       #5,d6
genera2:       move.b     d6,(a6)
               lea.l      gen(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

genprof:       move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               tst.w      d7
               bne.s      genprof1
genprof0:      bclr       #5,d6
               bra.s      genprof2
genprof1:      bset       #5,d6
genprof2:      move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

emphprof:      move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               tst.w      d7
               bne.s      emphprof1
emphprof0:     bclr       #4,d6
               bra.s      emphprof2
emphprof1:     bset       #4,d6
emphprof2:     move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

protprof:      move.l     (sp)+,d5
               lea.l      hireg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               tst.w      d7
               bne.s      protprof1
protprof0:     bclr       #0,d6
               bra.s      protprof2
protprof1:     bset       #0,d6
protprof2:     move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$40(a6)
               move.l     d5,-(sp)
               rts        

copyone:       move.l     (sp)+,d5
               lea.l      aesreg(pc),a6
               move.b     (a6),d6
               move.w     (sp)+,d7
               tst.w      d7
;               bne.s      copyo1
copyo0:                   ;     bclr       #1,d6
;               bra.s      copyo2
copyo1:                   ;      bset       #1,d6
copyo2:        bclr       #3,d6         ; raus aus playmode 128bit...
               move.b     d6,(a6)
               lea.l      copyobit(pc),a6
               move.b     d6,(a6)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d6,$c0(a6)
               move.l     d5,-(sp)
               move.w     #0,montrack2  ; ...denn montrack wird ja 1 hîher
               bsr        pushaesr
               rts        

proffhz:       lea.l      hz(pc),a1
               move.w     (a1),d0
               cmpi.w     #1,d0
               beq.s      proffhz32
               cmpi.w     #2,d0
               beq.s      proffhz44
               cmpi.w     #3,d0
               beq.s      proffhz48
               rts        
proffhz32:     move.w     #1,-(sp)
               bsr        protprof
               move.w     #1,-(sp)
               bsr        emphprof
               move.w     #1,-(sp)
               bsr        genprof
               rts        
proffhz44:     move.w     #1,-(sp)
               bsr        protprof
               move.w     #0,-(sp)
               bsr        emphprof
               move.w     #1,-(sp)
               bsr        genprof
               rts        
proffhz48:     move.w     #0,-(sp)
               bsr        protprof
               move.w     #1,-(sp)
               bsr        emphprof
               move.w     #1,-(sp)
               bsr        genprof
               rts        

playstat:      clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $40(a6),d0
               andi.w     #7,d0
               rts        

recstat:       clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $60(a6),d0
               andi.w     #7,d0
               rts        

dspmode:       lea.l      vmestart(pc),a6
               movea.l    (a6),a6
;               lea.l      hireg(pc),a1
;               move.b     (a1),d1
;               lea.l      dspreg(pc),a2
;               move.b     (a2),d2
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getdspm
               tst.w      d0
               blt        digerr
               cmpi.w     #2,d0
               bgt        digerr
               lea.l      dspart(pc),a3
               move.w     d0,(a3)
               tst.w      d0
               beq.s      dspnoc
               cmpi.w     #1,d0
               beq.s      dspswin
               cmpi.w     #2,d0
               beq        dspswout
               clr.l      d0
               rts        
dspnoc:        move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dmarec
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPIN-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
               clr.l      d0
               rts        
dspswin:       move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #3,d0         ; mit DSP-OUT verbinden
               move.w     d0,dmarec
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; mit DSP-OUT verbinden
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPIN-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               andi.w     #$f9,d0
               move.b     d0,(a1)
               move.b     d0,$214(a6)
               clr.l      d0
               rts        
dspswout:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dmarec
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; mit DSP-OUT verbinden
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPIN-auswahl
               move.w     #2,d0         ; mit A/D verbinden
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               andi.w     #$f9,d0
               move.b     d0,(a1)
               move.b     d0,$214(a6)
               clr.l      d0
               rts        
getdspm:       clr.l      d0
               lea.l      dspart(pc),a3
               move.w     (a3),d0
               rts        

calcdigsr:     lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               move.l     #lfifo,d2
               asr.l      #1,d2
               clr.l      d6
               move.l     #lfifo,d0
cdig0:         move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               dbra       d0,cdig0
               move.l     $4ba,d1       ; Starttime
cdig1:         move.b     (a0),d0       ; Flag lesen
               move.l     $4ba,d4       ; Endtime
               sub.l      d1,d4         ; time
               cmpi.l     #50,d4
               bgt.s      cdigend
               btst       #1,d0         ; RECORD-FIFO voll ?
               bne.s      cdig1
               move.l     d2,d0         ; fifodepth/2-1
               subq.l     #1,d0
               add.l      d2,d6
cdig2:         move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               dbra       d0,cdig2
               move.l     $4ba,d4       ; Endtime
               sub.l      d1,d4         ; time
               cmpi.l     #50,d4
               blt.s      cdig1
cdigend:       move.l     d6,d0
               rts        

digsrate:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a1
               move.b     (a1),d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.b     $80(a6),d0
               asr.w      #6,d0
               andi.w     #2,d0
               bset       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               move.b     $80(a6),d2
               asr.w      #7,d2
               andi.w     #1,d2
               add.w      d2,d0
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               bset       #4,d1
               move.b     d1,(a1)
               move.b     d1,$40(a6)
               clr.l      d2
               move.b     $20(a6),d2
               btst       #0,d2         ; Profi or consumermode ?
               bne.s      digconsum
digprofi:      cmpi.w     #1,d0         ; profi 44 khz ?
               bne.s      dighzp48
               moveq.l    #2,d0
               rts        
dighzp48:      cmpi.w     #2,d0         ; profi 48 khz ?
               bne.s      dighzp32
               moveq.l    #3,d0
               rts        
dighzp32:      cmpi.w     #3,d0         ; profi 32 khz ?
               bne.s      dighzerr
               moveq.l    #1,d0
               rts        
digconsum:     tst.w      d0            ; consumer 44 khz ?
               bne.s      dighz48
               moveq.l    #2,d0
               rts        
dighz48:       cmpi.w     #2,d0         ; consumer 48 khz ?
               bne.s      dighz32
               moveq.l    #3,d0
               rts        
dighz32:       cmpi.w     #3,d0         ; consumer 32 khz ?
               bne.s      dighzerr
               moveq.l    #1,d0
               rts        
dighzerr:      clr.l      d0
               rts        

dspreset:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath1(pc),a1
               move.b     (a1),d1
               bset       #3,d1
               move.b     d1,(a1)
               move.b     d1,$210(a6)
               move.l     #10,d0
               bsr        pause
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$210(a6)
               move.l     #20,d0
               bsr        pause
               clr.l      d0
               rts        

getdspreg:     movem.l    d0/a2,-(sp)
getd1b:        move.w     matout,d0
               bsr        matoutsel     ; zur MatrixOut registerauswahl
getd1c:        lea.l      matin(pc),a2
               move.w     matout,d1
               lsl.w      #1,d1
               subq.w     #2,d1
               move.w     0(a2,d1.w),d0
               andi.w     #3,d0
               lea.l      dspreg(pc),a2
               move.b     (a2),d1
               andi.w     #$fc,d1
               add.w      d0,d1
               movem.l    (sp)+,d0/a2
               rts        

volad:         bsr        getdspreg
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d2      ; wert left
               cmpi.w     #-1,d2
               beq.s      getvolad
               move.w     (a0)+,d3      ; wert right
               tst.w      d2
               blt        digerr
               tst.w      d3
               blt        digerr
               cmpi.w     #255,d2
               bgt        digerr
               cmpi.w     #255,d3
               bgt        digerr
volad2:        move.l     a6,-(sp)
               move.l     d0,-(sp)
               lea.l      adwert(pc),a6
               move.w     d2,d0
               swap.w     d0
               move.w     d3,d0
               move.l     d0,(a6)
               move.l     (sp)+,d0
               movea.l    (sp)+,a6
               bclr       #3,d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bsr        volclk
               move.w     d2,d3
               bsr        volclk
               bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               clr.l      d0
               rts        
getvolad:      lea.l      adwert(pc),a6
               move.l     (a6),d0
               rts        

volclk:        move.w     #8,d0
volad0:        subi.w     #1,d0
               btst       d0,d3
               bne.s      volad1
               bclr       #4,d1
               bra.s      volad1b
volad1:        bset       #4,d1
volad1b:       move.b     d1,(a1)
               move.b     d1,$80(a6)
               bset       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               tst.w      d0
               bne.s      volad0
               rts        

volda:         bsr        getdspreg
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d2      ; wert left
               cmpi.w     #-1,d2
               beq.s      getvolda
               move.w     (a0)+,d3      ; wert right
               tst.w      d2
               blt        digerr
               tst.w      d3
               blt        digerr
               cmpi.w     #255,d2
               bgt        digerr
               cmpi.w     #255,d3
               bgt        digerr
volda2:        move.l     a6,-(sp)
               move.l     d0,-(sp)
               lea.l      dawert(pc),a6
               move.w     d2,d0
               swap.w     d0
               move.w     d3,d0
               move.l     d0,(a6)
               move.l     (sp)+,d0
               movea.l    (sp)+,a6
               bclr       #3,d1
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #5,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bsr        volclk
               move.w     d2,d3
               bsr        volclk
               bset       #5,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #4,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               bclr       #3,d1
               move.b     d1,(a1)
               move.b     d1,$80(a6)
               clr.l      d0
               rts        
getvolda:      lea.l      dawert(pc),a6
               move.l     (a6),d0
               rts        

intact:        lea.l      intreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     (a1),d3
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq.s      getintact
               tst.w      d0
               blt        digerr
               cmpi.w     #3,d0
               bgt        digerr
nodintres:     move.b     d0,(a1)
               andi.w     #3,d0
               move.b     d0,$280(a6)
               clr.l      d0
               rts        
getintact:     clr.l      d0
               move.b     (a1),d0
               rts        

dspintact:     lea.l      dintreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq.s      infodspi
               tst.w      d0
               blt        digerr
               cmpi.w     #3,d0
               bgt        digerr
               move.b     d0,(a1)
               tst.w      d0
               bne.s      dspintgo
               move.b     $1ff(a6),d0
               andi.w     #$fc,d0
               move.b     d0,$1ff(a6)   ; dspint-stop
               bra.s      dspintex
dspintgo:      move.b     #124,$202(a6) ; dsp-intvector
               move.b     $1ff(a6),d1
               andi.w     #$fc,d1
               add.w      d0,d1
               move.b     d1,$1ff(a6)   ; dspint-start
dspintex:      clr.l      d0
               rts        
infodspi:      clr.l      d0
               move.b     (a1),d0
               rts        

dspcommnd:     move.w     (a0)+,d0      ; wert
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               bset       #7,d0
               addi.b     #18,d0
               move.b     d0,$200(a6)
               clr.l      d0
               rts        

dspclear:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
dspclear2:     btst       #0,$201(a6)
               beq.s      dspclear3
               move.b     $203(a6),d2
               move.b     $204(a6),d2
               move.b     $205(a6),d2
               move.b     $206(a6),d2
               bra.s      dspclear2
dspclear3:     clr.l      d0
               rts        

exclkmode:     move.w     (a0)+,d0      ; wert
               lea.l      exclkm(pc),a2
               cmpi.w     #-1,d0
               beq.s      exclkstat
               move.w     d0,(a2)
               clr.l      d0
               rts        
exclkstat:     clr.l      d0
               move.w     (a2),d0
               rts        

gpiodirect:    move.w     (a0)+,d0      ; wert
               lea.l      gpdirect(pc),a2
               cmpi.w     #-1,d0
               beq.s      gpdstat
               move.w     d0,(a2)
               clr.l      d0
               rts        
gpdstat:       move.w     (a2),d0
               rts        

clkdirect:     move.w     (a0)+,d0      ; wert
               lea.l      eclkmode(pc),a2
               cmpi.w     #-1,d0
               beq.s      eclkstat
               move.w     d0,(a2)
               bsr        seteclk
               clr.l      d0
               rts        
eclkstat:      move.w     (a2),d0
               rts        

seteclk:       movem.l    d1/d2/a1/a6,-(sp)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      lowreg(pc),a1
               move.b     (a1),d1
               move.w     d1,d2
               bclr       #4,d2         ; clkdirect-bit loeschen
               cmpi.w     #0,eclkmode
               beq.s      seteclk2
               bset       #4,d2         ; clkdirect-bit setzen
seteclk2:      move.b     d2,(a6)       ; clkdirect setzen oder loeschen
               move.b     d2,(a1)
               move.b     d1,(a6)       ; extakt setzen oder loeschen
               move.b     d1,(a1)
eclkex:        movem.l    (sp)+,d1/d2/a1/a6
               rts        

emphasis:      lea.l      hireg(pc),a1
               move.b     (a1),d1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getemph
               cmpi.w     #1,d0
               bgt        digerr
               tst.w      d0
               blt        digerr
emphasis2:     lea.l      proff(pc),a2
               move.b     (a2),d2
               btst       #0,d2         ;professional oder consumer ?
               bne.s      profmode
consmode:      tst.w      d0
               bne.s      consmod1
               lea.l      empha(pc),a6
               move.w     #0,(a6)
               bclr       #3,d1
               bra.s      consmod2
consmod1:      bset       #3,d1
               lea.l      empha(pc),a6
               move.w     #1,(a6)
consmod2:      move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$40(a6)
               clr.l      d0
               rts        
profmode:      bclr       #3,d1
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$40(a6)
               tst.w      d0
               bne.s      profmod1
               lea.l      empha(pc),a6
               move.w     #0,(a6)
               move.w     #1,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               bra.s      profmod2
profmod1:      move.w     #0,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               lea.l      empha(pc),a6
               move.w     #1,(a6)
profmod2:      clr.l      d0
               rts        
getemph:       clr.l      d0
               lea.l      empha(pc),a1
               move.w     (a1),d0
               rts        

digmode:       lea.l      dgmode(pc),a1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getdigmode
               cmpi.w     #1,d0
               bgt        digerr
               tst.w      d0
               blt        digerr
               move.w     d0,(a1)
               tst.w      d0
               bne        digprof
digcons:       lea.l      proffm(pc),a1
               move.w     (a1),d1
               tst.w      d1
               beq.s      digcons2
               move.w     #0,d1
               move.w     d1,(a1)
               lea.l      cat0(pc),a3
               lea.l      catb0(pc),a4
               move.w     (a4),(a3)
               lea.l      cat1(pc),a3
               lea.l      catb1(pc),a4
               move.w     (a4),(a3)
               lea.l      scms(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        prot
               lea.l      gen(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        genera
               lea.l      cat0(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        categ0
               lea.l      cat1(pc),a1
               move.w     (a1),d0
               move.w     d0,-(sp)
               bsr        categ1
               lea.l      empha(pc),a6
               move.w     (a6),d0       ; wert
               bsr        emphasis2
digcons2:      lea.l      aesreg(pc),a1
               move.b     (a1),d1
               bclr       #0,d1
               bclr       #3,d1         ; raus aus playmode 128bit...
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$c0(a6)
               move.w     #0,montrack2  ; ...denn montrack wird ja 1 hîher
               bsr        pushaesr
               rts        
digprof:       lea.l      proffm(pc),a1
               move.b     #1,(a1)
               rts        
getdigmode:    clr.l      d0
               lea.l      dgmode(pc),a1
               move.w     (a1),d0       ; wert
               rts        

mycopybit:     lea.l      mcbit(pc),a1
               move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getcbit
               tst.w      d0
               beq.s      mycopyno
               cmpi.w     #1,d0
               beq.s      mycopyone
               cmpi.w     #2,d0
               beq        mycopyall
               move.l     #-1,d0
               rts        
mycopyno:      move.w     d0,(a1)
               lea.l      proff(pc),a1
               move.w     (a1),d1
               tst.w      d1
               bne.s      proffce
               move.w     #1,-(sp)
               bsr        genera
               move.w     #1,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               lea.l      bridg1(pc),a1
               move.w     #0,(a1)
               lea.l      bridg2(pc),a1
               move.w     #0,(a1)
               lea.l      bridge(pc),a1
               move.w     (a1),d1
               tst.w      d1
               bne.s      proffce
               move.w     #0,-(sp)
               bsr        copyone
               move.w     #0,-(sp)
               bsr        prot
proffce:       clr.l      d0
               rts        
mycopyone:     move.w     d0,(a1)
               lea.l      proff(pc),a1
               move.w     (a1),d1
               tst.w      d1
               bne.s      proffce
               move.w     #0,-(sp)
               bsr        genera
               move.w     #0,-(sp)
               bsr        categ0
               move.w     #0,-(sp)
               bsr        categ1
               lea.l      bridg1(pc),a1
               move.w     #1,(a1)
               lea.l      bridg2(pc),a1
               move.w     #1,(a1)
               lea.l      bridge(pc),a1
               move.w     (a1),d1
               tst.w      d1
               bne.s      proffce
               move.w     #1,-(sp)
               bsr        copyone
               move.w     #1,-(sp)
               bsr        prot
               bra.s      proffce
mycopyall:     move.w     d0,(a1)
               lea.l      proff(pc),a1
               move.w     (a1),d1
               tst.w      d1
               bne.s      proffce
               move.w     #1,-(sp)
               bsr        genera
               move.w     #1,-(sp)
               bsr        categ0
               move.w     #1,-(sp)
               bsr        categ1
               lea.l      bridg1(pc),a1
               move.w     #0,(a1)
               lea.l      bridg2(pc),a1
               move.w     #1,(a1)
               lea.l      bridge(pc),a1
               move.w     (a1),d1
               tst.w      d1
               bne        proffce
               move.w     #0,-(sp)
               bsr        copyone
               move.w     #1,-(sp)
               bsr        prot
               bra        proffce
getcbit:       clr.l      d0
               lea.l      mcbit(pc),a1
               move.w     (a1),d0
               rts        

scmsmode:      move.w     (a0)+,d0      ; wert
               cmpi.w     #-1,d0
               beq        getscms
               cmpi.w     #1,d0
               bgt        digerr
               tst.w      d0
               blt        digerr
               bne.s      scmsclr
scmsbridge:    lea.l      bridge(pc),a1
               move.w     #0,(a1)
               lea.l      bridg3(pc),a1
               lea.l      copyobit(pc),a2
               move.w     (a2),(a1)
               lea.l      bridg4(pc),a1
               lea.l      scms(pc),a2
               move.w     (a2),(a1)
               lea.l      copyobit(pc),a2
               move.w     (a2),d1
               move.w     d1,-(sp)
               bsr        copyone
               lea.l      scms(pc),a2
               move.w     (a2),d1
               move.w     d1,-(sp)
               bsr        prot
               clr.l      d0
               rts        
scmsclr:       lea.l      bridge(pc),a1
               move.w     #1,(a1)
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
;               bset       #1,d1
               bclr       #3,d1         ; raus aus playmode 128bit...
               move.b     d1,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d1,$c0(a6)
               move.w     #0,montrack2  ; ...denn montrack wird ja 1 hîher
               bsr        pushaesr
               lea.l      bridg3(pc),a1
               move.w     #1,(a1)
               lea.l      bridg4(pc),a1
               move.w     #0,(a1)
               lea.l      proff(pc),a1
               move.w     (a1),d1
               tst.w      d1
               bne.s      scmse
               lea.l      bridg4(pc),a1
               move.w     (a1),d1
               move.w     d1,-(sp)
               bsr        prot
scmse:         clr.l      d0
               rts        
getscms:       clr.l      d0
               lea.l      bridge(pc),a1
               move.w     (a1),d0
               rts        

readsmp:       clr.l      d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     #256,d1
               move.w     #8,d2
readsmp2:      move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      readsmp3
               dbra       d1,readsmp2
rdsmperr:      move.l     #-1,d0
               rts        
readsmp3:      lea.l      smpwert(pc),a1
               movea.l    a1,a2
               btst       #0,modr24
               bne.s      readsmp24
               clr.l      (a1)
               clr.l      4(a1)
               move.b     d0,2(a1)
               move.w     $ff(a6),d0
               btst       d2,d0
               beq.s      readsmp2
               move.b     d0,3(a1)
               move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      rdsmperr
               move.b     d0,6(a1)
               move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      rdsmperr
               move.b     d0,7(a1)
               move.l     a2,d0
               rts        
readsmp24:     clr.l      (a1)
               clr.l      4(a1)
               move.b     d0,1(a1)
               move.w     $ff(a6),d0
               btst       d2,d0
               beq.s      readsmp2
               move.b     d0,2(a1)
               move.w     $ff(a6),d0
               btst       d2,d0
               beq.s      readsmp2
               move.b     d0,3(a1)
               move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      rdsmperr
               move.b     d0,5(a1)
               move.w     $ff(a6),d0
               btst       d2,d0
               bne.s      rdsmperr
               move.b     d0,6(a1)
               move.w     $ff(a6),d0
               btst       d2,d0
               bne        rdsmperr
               move.b     d0,7(a1)
               move.l     a2,d0
               rts        

highsrate:     move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq.s      gethighs
               cmpi.w     #1,d0
               bgt.s      higherr
               tst.w      d0
               blt.s      higherr
               lea.l      highsr(pc),a2
               move.w     d0,(a2)
               bsr        pushaesr
               clr.l      d0
               rts        
higherr:       move.l     #-1,d0
               rts        
gethighs:      clr.l      d0
               lea.l      highsr(pc),a2
               move.w     (a2),d0
               rts        

mode24:        move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq.s      getmod24
               cmpi.w     #2,d0
               bgt.s      errmd24
               tst.w      d0
               blt.s      errmd24
               lea.l      modr24(pc),a3
               move.b     d0,(a3)
               bsr        pushaesr
               clr.l      d0
               rts        
errmd24:       move.l     #-1,d0
               rts        
getmod24:      clr.l      d0
               lea.l      modr24(pc),a3
               move.b     (a3),d0
               rts        

setplaych:     move.w     (a0)+,d0
               andi.w     #3,d0
               move.b     d0,playch
               clr.l      d0
               rts        

writesmp:      lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               adda.l     #$100,a6      ; Playread im Bytemode
               move.w     #8,d2
               btst       #0,modr24
               bne.s      writesmp24
               move.w     (a0)+,d0
               move.w     d0,d1
               asr.w      d2,d0
               move.b     d0,2(a6)
               move.b     d1,2(a6)
               move.w     (a0)+,d0
               move.w     d0,d1
               asr.w      d2,d0
               move.b     d0,(a6)
               move.b     d1,(a6)
               clr.l      d0
               rts        
writesmp24:    move.l     (a0)+,d0
               move.l     d0,d7
               swap.w     d7
               move.l     d0,d6
               asr.w      d2,d6
               move.b     d7,2(a6)
               move.b     d6,2(a6)
               move.b     d0,2(a6)
               move.l     (a0)+,d0
               move.l     d0,d7
               swap.w     d7
               move.l     d0,d6
               asr.w      d2,d6
               move.b     d7,(a6)
               move.b     d6,(a6)
               move.b     d0,(a6)
               clr.l      d0
               rts        

read_rlow:     clr.l      d0
               lea.l      lowreg(pc),a1
               move.b     (a1),d0
               rts        

read_rhi:      clr.l      d0
               lea.l      hireg(pc),a1
               move.b     (a1),d0
               rts        

read_raes:     clr.l      d0
               lea.l      aesreg(pc),a1
               move.b     (a1),d0
               rts        

read_rdsp:     clr.l      d0
               lea.l      dspreg(pc),a1
               move.b     (a1),d0
               andi.b     #$3f,d0
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     $80(a6),d1
               andi.b     #$c0,d1
               add.b      d1,d0
               rts        

read_rint:     clr.l      d0
               lea.l      intreg(pc),a1
               move.b     (a1),d0
               rts        

read_dpath1:   clr.l      d0
               lea.l      dsppath1(pc),a1
               move.b     (a1),d0
               rts        

read_dpath2:   clr.l      d0
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               rts        

read_dport:    clr.l      d0
               lea.l      dspport(pc),a1
               move.b     (a1),d0
               rts        

read_dconv:    clr.l      d0
               lea.l      dspconv(pc),a1
               move.b     (a1),d0
               rts        

read_dpdat:    clr.l      d0
               lea.l      dsppdat(pc),a1
               move.b     (a1),d0
               rts        

read_dclk:     clr.l      d0
               lea.l      clkdiv(pc),a1
               move.b     (a1),d0
               rts        

point_dreg:    lea.l      matin(pc),a1
               move.l     a1,d0
               rts        

setconnects2:  lea.l      vmestart,a6
               movea.l    (a6),a6
               move.w     (a0)+,d0
               move.b     dsppath2(pc),d2
               andi.w     #1,d2
               andi.w     #3,d0
               lsl.w      #1,d0
               or.w       d0,d2
               move.w     (a0)+,d0
               move.b     dsppdat(pc),d1
               andi.w     #4,d1
               andi.w     #3,d0
               or.w       d0,d1
               move.w     (a0)+,d0
               andi.w     #1,d0
               lsl.w      #3,d0
               or.w       d0,d1
               move.b     d1,dsppdat
               move.b     d1,$240(a6)
               move.w     (a0)+,d0
               andi.w     #1,d0
               lsl.w      #3,d0
               or.w       d0,d2
               move.b     d2,dsppath2
               move.b     d2,$214(a6)
               clr.l      d0
               rts        


showconnects:  move.w     #13,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               lea.l      matin(pc),a1
               move.w     (a1)+,d0
               tst.w      d0
               beq.s      shrec0
               cmpi.w     #1,d0
               beq.s      shrec1
               cmpi.w     #2,d0
               beq.s      shrec2
               lea.l      showt2(pc),a2
               bra.s      showcon2
shrec0:        lea.l      showt0(pc),a2
               bra.s      showcon2
shrec1:        lea.l      showt1(pc),a2
               bra.s      showcon2
shrec2:        lea.l      showt3(pc),a2
showcon2:      move.w     (a1)+,d0
               tst.w      d0
               beq.s      shdac0
               cmpi.w     #1,d0
               beq.s      shdac1
               cmpi.w     #2,d0
               beq.s      shdac2
               lea.l      showt2(pc),a3
               bra.s      showcon3
shdac0:        lea.l      showt0(pc),a3
               bra.s      showcon3
shdac1:        lea.l      showt1(pc),a3
               bra.s      showcon3
shdac2:        lea.l      showt3(pc),a3
showcon3:      move.w     (a1)+,d0
               tst.w      d0
               beq.s      shxo0
               cmpi.w     #1,d0
               beq.s      shxo1
               cmpi.w     #2,d0
               beq.s      shxo2
               lea.l      showt2(pc),a4
               bra.s      showcon4
shxo0:         lea.l      showt0(pc),a4
               bra.s      showcon4
shxo1:         lea.l      showt1(pc),a4
               bra.s      showcon4
shxo2:         lea.l      showt3(pc),a4
showcon4:      move.l     a2,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showr0(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.l     a4,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showr1(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.l     a3,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showr2(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               btst       #3,d0
               beq.s      shconvn
               lea.l      showcvj(pc),a5
               bra.s      showcon4b
shconvn:       lea.l      showcvn(pc),a5
showcon4b:     lsr.b      #1,d0
               andi.b     #3,d0
               tst.w      d0
               beq.s      shbxo0
               cmpi.w     #1,d0
               beq.s      shbxo1
               lea.l      showbt1(pc),a2
               bra.s      showcon5
shbxo0:        lea.l      showbt2(pc),a2
               bra.s      showcon5
shbxo1:        lea.l      showbt3(pc),a2
showcon5:      lea.l      dsppdat(pc),a1
               move.b     (a1),d0
               andi.b     #3,d0
               tst.w      d0
               beq.s      shbex0
               cmpi.w     #1,d0
               beq.s      shbex1
               lea.l      showbt3(pc),a3
               bra.s      showcon6
shbex0:        lea.l      showbt1(pc),a3
               bra.s      showcon6
shbex1:        lea.l      showbt2(pc),a3
showcon6:      move.b     (a1),d0
               btst       #3,d0
               beq.s      shbdr0
               lea.l      showbt3(pc),a4
               bra.s      showcon7
shbdr0:        lea.l      showbt1(pc),a4
showcon7:      move.l     a3,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showbr0(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.l     a4,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showbr1(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.l     a2,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               pea        showbr2(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.l     a5,-(sp)      ;Msg ausgeben
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               lea.l      playmod(pc),a3
               move.w     (a3),d0
               move.w     #2,d7
               lsl.w      d0,d7
               cmpi.w     #16,d7
               bne.s      showpnorm
               pea        showpm16(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               bra.s      showcon8
showpnorm:     pea        showpm(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               addi.w     #48,d7
               move.w     d7,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     #32,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
showcon8:      lea.l      recmod(pc),a3
               move.w     (a3),d0
               move.w     #2,d7
               lsl.w      d0,d7
               pea        showrm(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               addi.w     #48,d7
               move.w     d7,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     #32,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               pea        showeadc(pc)
               move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.w     emuladc,d0
               addi.w     #48,d0
               move.w     d0,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               move.w     #32,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               btst       #0,modr24
               beq.s      showcon9
               pea        showm24(pc)
               bra.s      showcon10
showcon9:      pea        showm16(pc)
showcon10:     move.w     #9,-(sp)      ;* ausgeben
               trap       #1            ;GEMDOS
               addq.l     #6,sp         ;* Stack sÑubern
               move.w     #13,-(sp)
               move.w     #2,-(sp)
               trap       #1
               addq.l     #4,sp
               clr.l      d0
               rts        

setconnects1:  move.w     (a0),d0
               cmpi.w     #-1,d0
               beq        point_dreg
               move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     (a0)+,d0
               move.w     d0,dmarec
               bsr        matinsel
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     (a0)+,d0
               move.w     d0,dacrec
               bsr        matinsel
               move.w     #3,d0
               bsr        matoutsel     ; zu DSPCARD-IN-auswahl
               move.w     (a0)+,d0
               move.w     d0,dsprec
               move.w     d0,cardrec
               bsr        matinsel
               clr.l      d0
               rts        

wr_dpath1:     move.w     (a0)+,d0
               lea.l      dsppath1(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$210(a6)
               clr.l      d0
               rts        

wr_dpath2:     move.w     (a0)+,d0
               lea.l      dsppath2(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$214(a6)
               clr.l      d0
               rts        

wr_dport:      move.w     (a0)+,d0
               lea.l      dspport(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$212(a6)
               clr.l      d0
               rts        

wr_dconv:      move.w     (a0)+,d0
               lea.l      dspconv(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$216(a6)
               clr.l      d0
               rts        

wr_dpdat:      move.w     (a0)+,d0
               lea.l      dsppdat(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$240(a6)
               clr.l      d0
               rts        

wr_dclk:       move.w     (a0)+,d0
               lea.l      clkdiv(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$242(a6)
               clr.l      d0
               rts        

wr_rlow:       move.w     (a0)+,d0
               lea.l      lowreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,(a6)
               clr.l      d0
               rts        

wr_rhi:        move.w     (a0)+,d0
               lea.l      hireg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$40(a6)
               clr.l      d0
               rts        

wr_raes:       move.w     (a0)+,d0
               lea.l      aesreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$c0(a6)
               clr.l      d0
               rts        

wr_rdsp:       move.w     (a0)+,d0
               lea.l      dspreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$80(a6)
               clr.l      d0
               rts        

wr_rint:       move.w     (a0)+,d0
               lea.l      intreg(pc),a1
               move.b     d0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d0,$280(a6)
               clr.l      d0
               rts        

plugincount:   clr.l      d0
               move.w     plugcnt,d0
               rts        

pvolname:      .DC.b "VOLUME",0,0
pvolpara:      .DC.l 100,100            ; Parameter Maximalwert,Aktueller Wert
               .DC.l 100,100            ; Parameter Maximalwert,Aktueller Wert
               .DC.b "LEFT",0,"NC",0    ; Slidertext,Slidereinheit
               .DC.b "RIGHT",0,"NC",0   ; Slidertext,Slidereinheit
               .DC.b "SWE STEPHAN WILHELM ELECTRONIC",0     ;Copyright
pvolnr:        .DC.w 0
pvolexist:     .DC.w 0
pvolmake:      movem.l    d6/d7/a6,-(sp)          ; Plugin-Routine 16bit
               lea.l      pvolpara(pc),a6
               move.l     (a6)+,d6      ; maxvol left
               move.l     (a6)+,d7      ; Volume left
               muls.w     d7,d2
               divs.w     d6,d2
               move.l     (a6)+,d6      ; maxvol right
               move.l     (a6),d7       ; Volume right
               muls.w     d7,d1
               divs.w     d6,d1
               movem.l    (sp)+,d6/d7/a6
pvolini:       rts        

plugvolctrl:   move.w     (a0)+,d0
               tst.w      d0
               bne.s      pvolc1
               lea.l      vpluglistp(pc),a1
               lea.l      pluglistp(pc),a2
               moveq.l    #10,d1
pvolc1a:       move.w     (a1)+,(a2)+
               dbra       d1,pvolc1a
               move.w     #0,pvolexist
               move.w     pvolnr,d0
               bra        pluginkill2
pvolc1:        move.w     plugcnt,d0
               addq.w     #1,d0
               move.w     d0,plugcnt
               lea.l      pluglistp(pc),a1
               movea.l    a1,a3
               lea.l      vpluglistp(pc),a2
               moveq.l    #10,d1
pvolc1b:       move.w     (a1)+,(a2)+
               dbra       d1,pvolc1b
               move.w     d0,(a3)+
               move.w     #0,(a3)
               lea.l      plugs(pc),a1
               clr.l      d1
pvolc2:        move.w     0(a1,d1.w),d2
               tst.w      d2
               beq.s      pvolc3
               addi.l     #24,d1
               bra.s      pvolc2
pvolc3:        move.w     #1,0(a1,d1.w) ; loaded
               move.w     #2,2(a1,d1.w) ; parameter anzahl
               lea.l      pvolini(pc),a0
               move.l     a0,4(a1,d1.w) ; init plugin startadresse
               lea.l      pvolmake(pc),a0
               move.l     a0,8(a1,d1.w) ; work plugin startadresse
               lea.l      pvolname(pc),a0
               move.l     a0,12(a1,d1.w)          ; pointer auf name
               move.l     #10,16(a1,d1.w)         ; taktzyklen
               lea.l      pvolpara(pc),a0
               move.l     a0,20(a1,d1.w)          ; pointer auf parameterliste
               divu.w     #24,d1
               addq.w     #1,d1
               move.w     d1,pvolnr
               move.w     #1,pvolexist
               lea.l      pvolpara(pc),a0
               move.l     a0,d0
               rts        

pluginload:    move.w     plugcnt,d0
               cmpi.w     #10,d0
               beq.s      pluginerr
               addq.w     #1,d0
               move.w     d0,plugcnt
               lea.l      plugs(pc),a1
               clr.l      d1
               clr.w      d3
freefound:     move.w     0(a1,d1.w),d2
               tst.w      d2
               beq.s      pluginfree
               addi.l     #24,d1
               addi.w     #1,d3
               cmpi.w     #10,d3
               beq.s      pluginerr
               bra.s      freefound
pluginfree:    move.w     #1,0(a1,d1.w) ; loaded
               move.w     (a0)+,2(a1,d1.w)        ; parameter anzahl
               move.l     (a0)+,4(a1,d1.w)        ; init plugin startadresse
               move.l     (a0)+,8(a1,d1.w)        ; work plugin startadresse
               move.l     (a0)+,12(a1,d1.w)       ; pointer auf name
               move.l     (a0)+,16(a1,d1.w)       ; taktzyklen
               move.l     (a0)+,20(a1,d1.w)       ; pointer auf parameterliste
               divu.w     #24,d1
               clr.l      d0
               move.w     d1,d0
               rts        
pluginerr:     move.l     #-1,d0
               rts        

pluginkill:    clr.l      d0
               move.w     (a0)+,d0
               cmpi.w     #1,d0
               blt.s      pluginerr
               cmpi.w     #10,d0
               bgt.s      pluginerr
pluginkill2:   lea.l      plugs(pc),a1
               subq.w     #1,d0
               mulu.w     #24,d0
               move.w     0(a1,d0.w),d2 ; loaded-flag
               tst.w      d2
               beq.s      pluginerr
               move.w     #0,0(a1,d0.w) ; loaded
               move.w     plugcnt,d0
               subq.w     #1,d0
               move.w     d0,plugcnt
               clr.l      d0
               rts        

plugfind:      clr.l      d2
               move.w     (a0)+,d2
               cmpi.w     #1,d2
               blt.s      pluginerr
               cmpi.w     #10,d2
               bgt.s      pluginerr
               lea.l      plugs(pc),a1
               subq.w     #1,d2
               mulu.w     #24,d2
               move.w     0(a1,d2.w),d1
               tst.w      d1
               beq.s      pluginerr
               move.l     a1,d0
               add.l      d2,d0
               addq.l     #2,d0
               rts        

plugplist:     lea.l      pluglistp(pc),a1
               movea.l    a1,a3
               move.l     (a0)+,d0      ; liste oder abfrage ?
               cmpi.l     #-1,d0
               bne.s      plugpl1
               move.l     a1,d0         ; Liste abfragen
               rts        
plugpl1:       movea.l    d0,a2
               clr.w      d2
plugpl2:       move.w     (a2)+,d0
               move.w     d0,(a1)+
               addi.w     #1,d2
               cmpi.w     #11,d2
               beq.s      plugplerr
               tst.w      d0
               bne.s      plugpl2
               clr.l      d0
               rts        
plugplerr:     move.w     #0,(a3)
               bra        pluginerr

plugrlist:     lea.l      pluglistr(pc),a1
               movea.l    a1,a3
               move.l     (a0)+,d0      ; liste oder Abfrage ?
               cmpi.l     #-1,d0
               bne.s      plugrl1
               move.l     a1,d0         ; Liste abfragen
               rts        
plugrl1:       movea.l    d0,a2
               clr.w      d2
plugrl2:       move.w     (a2)+,d0
               move.w     d0,(a1)+
               addi.w     #1,d2
               cmpi.w     #11,d2
               beq.s      plugplerr
               tst.w      d0
               bne.s      plugrl2
               clr.l      d0
               rts        

plugmtime:     move.l     #10000,d0
               rts        

plugrtime:     lea.l      pluglistr(pc),a1
plugrt0:       lea.l      plugs(pc),a2
               clr.l      d3
plugrt1:       move.w     (a1)+,d0
               tst.w      d0
               bne.s      plugrt2
               move.l     d3,d0
               rts        
plugrt2:       subq.w     #1,d0
               mulu.w     #24,d0
               move.l     16(a2,d0.w),d2
               add.l      d2,d3
               bra.s      plugrt1

plugptime:     lea.l      pluglistp(pc),a1
               bra.s      plugrt0

workplugsp:    tst.w      pluglistp
               bne.s      workplgp2
               rts        
workplgp2:     movem.l    d0-d2/a1-a3,-(sp)
               move.l     28(sp),d1     ; linken Kanal holen
               move.l     32(sp),d2     ; rechten Kanal holen
               lea.l      pluglistp(pc),a1
               lea.l      plugs(pc),a2
workplgp3:     move.w     (a1)+,d0      ; plugin-nummer
               tst.w      d0
               beq.s      workplgend
               subq.w     #1,d0
               mulu.w     #24,d0
               movea.l    8(a2,d0.w),a3
               jsr        (a3)          ; bearbeite samples mit plugin
               bra.s      workplgp3
workplgend:    move.l     d1,28(sp)     ; linken Kanal setzen
               move.l     d2,32(sp)     ; rechten Kanal setzen
               movem.l    (sp)+,d0-d2/a1-a3
               rts        

workplugsr:    tst.w      pluglistr
               bne.s      workplgr2
               rts        
workplgr2:     movem.l    d0-d2/a1-a3,-(sp)
               move.l     28(sp),d1     ; linken Kanal holen
               move.l     32(sp),d2     ; rechten Kanal holen
               lea.l      pluglistr(pc),a1
               lea.l      plugs(pc),a2
workplgr3:     move.w     (a1)+,d0      ; plugin-nummer
               tst.w      d0
               beq.s      workplgend
               subq.w     #1,d0
               mulu.w     #24,d0
               movea.l    8(a2,d0.w),a3
               jsr        (a3)          ; bearbeite samples mit plugin
               bra.s      workplgr3

; ----------------------------Falcon-Routinen-----------------------

locksnd:       lea.l      lock(pc),a1
               move.w     (a1),d1
               tst.w      d1
               beq.s      lockja
               move.l     #-129,d0
               rts        
lockja:        move.w     #1,(a1)
               move.l     #1,d0
               rts        

unlocksnd:     lea.l      lock(pc),a1
               move.w     (a1),d1
               tst.w      d1
               bne.s      unlockja
               move.l     #-128,d0
               rts        
unlockja:      move.w     #0,(a1)
               move.l     #0,d0
               rts        

soundcmd:      move.w     (a0)+,d0
               move.w     (a0)+,d1
               tst.w      d0
               beq.s      ltatten
               cmpi.w     #1,d0
               beq.s      rtatten
               cmpi.w     #2,d0
               beq        ltgain
               cmpi.w     #3,d0
               beq        rtgain
               cmpi.w     #4,d0
               beq        addrin
               cmpi.w     #5,d0
               beq        adcinput
               cmpi.w     #6,d0
               beq        setprescale
               clr.l      d0
               rts        
ltatten:       tst.w      d1
               bmi.s      ltstat
               lea.l      ltatt(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               bsr        getdspreg
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      ltatt(pc),a2
               move.w     (a2),d2
               asr.w      #2,d2
               andi.w     #$3f,d2
               move.w     #192,d0
               sub.w      d2,d0
               move.w     d0,d2         ; wert left
               lea.l      rtatt(pc),a2
               move.w     (a2),d3
               asr.w      #2,d3
               andi.w     #$3f,d3
               move.w     #192,d0
               sub.w      d3,d0
               move.w     d0,d3         ; wert right
               bsr        volda2
ltstat:        lea.l      ltatt(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
rtatten:       tst.w      d1
               bmi.s      rtstat
               lea.l      rtatt(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               bsr        getdspreg
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      ltatt(pc),a2
               move.w     (a2),d2
               asr.w      #2,d2
               andi.w     #$3f,d2
               move.w     #192,d0
               sub.w      d2,d0
               move.w     d0,d2         ; wert left
               lea.l      rtatt(pc),a2
               move.w     (a2),d3
               asr.w      #2,d3
               andi.w     #$3f,d3
               move.w     #192,d0
               sub.w      d3,d0
               move.w     d0,d3         ; wert right
               bsr        volda2
rtstat:        lea.l      rtatt(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
ltgain:        tst.w      d1
               bmi.s      lgstat
               lea.l      lgain(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               bsr        getdspreg
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      lgain(pc),a2
               move.w     (a2),d0
               asr.w      #4,d0
               andi.w     #$f,d0
               clr.l      d2
               add.w      d0,d2
               add.w      d0,d2
               add.w      d0,d2
               bset       #7,d2
               bset       #6,d2         ; wert left
               lea.l      rgain(pc),a2
               move.w     (a2),d0
               asr.w      #4,d0
               andi.w     #$f,d0
               clr.l      d3
               add.w      d0,d3
               add.w      d0,d3
               add.w      d0,d3
               bset       #7,d3
               bset       #6,d3         ; wert right
               bsr        volad2
lgstat:        lea.l      lgain(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
rtgain:        tst.w      d1
               bmi.s      rgstat
               lea.l      rgain(pc),a1
               andi.w     #$f0,d1
               move.w     d1,(a1)
               bsr        getdspreg
               lea.l      dspreg(pc),a1
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      lgain(pc),a2
               move.w     (a2),d0
               asr.w      #4,d0
               andi.w     #$f,d0
               clr.l      d2
               add.w      d0,d2
               add.w      d0,d2
               add.w      d0,d2
               bset       #7,d2
               bset       #6,d2         ; wert left
               lea.l      rgain(pc),a2
               move.w     (a2),d0
               asr.w      #4,d0
               andi.w     #$f,d0
               clr.l      d3
               add.w      d0,d3
               add.w      d0,d3
               add.w      d0,d3
               bset       #7,d3
               bset       #6,d3         ; wert right
               bsr        volad2
rgstat:        lea.l      rgain(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
addrin:        lea.l      cmdaddr(pc),a1
               tst.w      d1
               bmi        getaddr
               andi.w     #3,d1
               cmp.w      (a1),d1
               bne.s      addrin2
               move.w     d1,(a1)
               bra        getaddr
addrin2:       cmpi.w     #1,d1
               beq.s      adderadc
               tst.w      d1
               beq.s      adderno
               cmpi.w     #2,d1
               beq.s      addermax
               cmpi.w     #3,d1
               beq.s      addermax
               move.w     d1,(a1)
               bra.s      getaddr
addermax:      move.w     d1,(a1)
               lea.l      mdac(pc),a1   ; originalquelle von DAC holen
               lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a1),d7
               move.w     d7,(a0)
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     d7,d0         ; mit quelle verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC
               bsr        adc8tst
               bra.s      getaddr
adderadc:      lea.l      mdac(pc),a2   ; originalquelle von DAC sichern
               lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a0),d7
               tst.w      (a1)
               beq.s      adderadc2
               move.w     d7,(a2)
adderadc2:     move.w     d1,(a1)
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC
               bsr        adc8tst
               bra.s      getaddr
adderno:       lea.l      mdac(pc),a2   ; originalquelle von DAC sichern
               lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     (a0),d7
               cmpi.w     #1,(a1)
               beq.s      adderno2
               move.w     d7,(a2)
adderno2:      move.w     d1,(a1)
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; mit nichts verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC
               bsr        adc8tst
getaddr:       lea.l      cmdaddr(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        
adcinput:      lea.l      cmdadcinp(pc),a1
               tst.w      d1
               bmi        getadcinp
               andi.w     #3,d1
               move.w     d1,(a1)
getadcinp:     move.w     (a1),d0
               rts        
setprescale:   lea.l      cmdpresc(pc),a1
               tst.w      d1
               bmi        getpresc
               andi.w     #3,d1
               move.w     d1,(a1)
getpresc:      move.w     (a1),d0
               rts        

setbuffer:     move.w     (a0)+,d0
               move.l     (a0)+,d1
               move.l     (a0)+,d2
               tst.w      d0
               beq.s      setpbuf
               cmpi.w     #1,d0
               beq.s      setrbuf
               clr.l      d0
               rts        
setpbuf:       lea.l      pbufstrt(pc),a1
               move.l     d1,(a1)
;               lea.l      pbufptr(pc),a1
;               move.l     d1,(a1)
               lea.l      pbufend(pc),a1
               move.l     d2,(a1)
               clr.l      d0
               rts        
setrbuf:       lea.l      rbufstrt(pc),a1
               move.l     d1,(a1)
;               lea.l      rbufptr(pc),a1
;               move.l     d1,(a1)
               lea.l      rbufend(pc),a1
               move.l     d2,(a1)
               clr.l      d0
               rts        

setsndmode:    move.w     (a0)+,d1
               lea.l      sndmode(pc),a1
               cmpi.w     #-1,d1
               beq.s      getsndmode
               move.w     d1,(a1)
               clr.l      d0
               rts        
getsndmode:    clr.l      d0
               move.w     (a1),d0
               rts        

settrack:      move.w     (a0)+,d1
               cmpi.w     #-1,d1
               beq.s      gettrack
               move.w     (a0)+,d2
               lea.l      ptracks(pc),a1
               lea.l      rtracks(pc),a2
               move.w     d1,(a1)
               move.w     d2,(a2)
               clr.l      d0
               rts        
gettrack:      lea.l      ptracks(pc),a1
               lea.l      rtracks(pc),a2
               move.w     (a1),d0
               swap.w     d0
               move.w     (a2),d0
               rts        

nhrdtst:       move.l     a1,-(sp)
               lea.l      cardmagc,a1
               move.w     (a1),d0
               andi.l     #1,d0
               movea.l    (sp)+,a1
               rts        

oldsetmontr:   lea.l      montrack(pc),a1
               move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq        getmontr
               tst.w      d0
               blt        monterr
               cmpi.w     #3,d0
               bgt        monterr
               move.w     d0,(a1)       ; set new montrack-value
               bsr        pushaesr
               bra        monterr

osetmontr2:               ; setmontrack - neuen wert in d0 Åbergeben
               lea.l      montrack(pc),a1
               move.w     2(a1),d7      ; letzten montrackwert holen
               move.w     (a1),d0       ; neuen montrackwert holen
               move.w     d0,2(a1)      ; alten montrackwert aktualisieren
               move.w     d0,d6
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      playmod(pc),a3
               move.w     (a3),d3
oisma128:      bclr       #4,d1         ; recmode resetten
               bclr       #2,d1         ; digmode resetten
               btst       #3,d1         ; playmoderegister schon gesetzt ?
               bne.s      oism128       ; dann dorthin
               bclr       #3,d1
               move.b     d1,$c0(a6)    ; playmoderegister resetten
               move.b     d1,(a1)
               bset       #3,d1
               move.b     d1,$c0(a6)    ; playmode=128,auf channel 0 setzen
               move.b     d1,(a1)
               tst.w      d0
               beq        omontgo
               clr.w      d7            ; wir sind ja auf Channel 0
oism128:       cmp.w      d7,d0
               bgt.s      oism128b
               addi.w     #4,d0
oism128b:      sub.w      d7,d0
               bset       #3,d1         ; recmode reset,playmode=128bit
               move.b     d1,$c0(a6)    ; playset numero 1
               move.b     d1,(a1)
               cmpi.w     #1,d0         ; letztes channelset ?
               beq.s      omontgo
onormon1b:     move.b     d1,$c0(a6)    ; playset numero 2
               move.b     d1,(a1)
               cmpi.w     #2,d0         ; letztes channelset ?
               beq.s      omontgo
onormon1c:     move.b     d1,$c0(a6)    ; playset numero 3
               move.b     d1,(a1)
               cmpi.w     #3,d0         ; letztes channelset ?
               beq.s      omontgo
onormon1d:     move.b     d1,$c0(a6)    ; playset numero 4
               move.b     d1,(a1)
               cmpi.w     #4,d0         ; letztes channelset ?
               beq.s      omontgo
onormon1e:     move.b     d1,$c0(a6)    ; playset numero 5
               move.b     d1,(a1)
omontgo:       lea.l      dspconv(pc),a2          ; channel in dspconv setzen
               move.b     (a2),d2
               asl.w      #2,d6
               andi.w     #$c,d6
               andi.w     #$f3,d2
               add.b      d6,d2
               move.b     d2,(a2)
               move.b     d2,$216(a6)
               clr.l      d0
               rts        

setmontrack:   bsr        nhrdtst
               btst       #0,d0         ; neue oder alte hardware?
               bne        oldsetmontr
               lea.l      montrack(pc),a1
               move.w     (a0)+,d0
               cmpi.w     #-1,d0
               beq.s      getmontr
               tst.w      d0
               blt.s      monterr
               cmpi.w     #3,playmod
               bne.s      setmontr8
               cmpi.w     #7,d0
               bgt.s      monterr
               bra.s      setmontr16
setmontr8:     cmpi.w     #3,d0
               bgt.s      monterr
setmontr16:    move.w     d0,(a1)       ; set new montrack-value
               bsr        pushaesr
monterr:       move.l     #-1,d0
               rts        
getmontr:      clr.l      d0
               move.w     (a1),d0
               rts        

setmontr2:                ; setmontrack - wert aktualisieren,original in (a1)
               bsr        nhrdtst
               btst       #0,d0         ; neue oder alte hardware?
               bne        osetmontr2
               lea.l      montrack(pc),a1
               move.w     2(a1),d7      ; montrack-backup holen
               move.w     (a1),d0       ; aktuellen montrackwert holen
               move.w     d0,2(a1)      ; make backup vom aktuellen montrackwert
               move.w     d0,d6
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               lea.l      playmod(pc),a3
               move.w     (a3),d3
isma128:       bclr       #4,d1         ; dsb/sum24 resetten
               move.w     highsr(pc),d4 ; highsamplerate ?
               tst.w      d4
               bne        chsrhigh
               bclr       #2,d1         ; digmode resetten
               btst       #1,modr24     ; sum24 ?
               bne.s      ismba128
               btst       #3,d1         ; playmoderegister schon gesetzt ?
               bne.s      ism128        ; dann dorthin
ismba128:      bclr       #3,d1
               btst       #1,modr24     ; sum24 ?
               beq.s      ismb128
               bset       #4,d1         ; bit sum24 setzen
ismb128:       move.b     d1,$c0(a6)    ; playmoderegister resetten
               move.b     d1,(a1)
               bset       #3,d1
               bclr       #4,d1         ; bit dsb lîschen
               move.b     d1,$c0(a6)    ; playmode=128,auf channel 0 setzen
               move.b     d1,(a1)
               clr.w      d7
               cmp.w      d7,d0
               beq.s      montgo
               btst       #1,modr24     ; sum24 ?
               bne.s      montgo
ism128:        cmp.w      d7,d0
               bgt.s      ism128b
               addi.w     #8,d0
ism128b:       sub.w      d7,d0
               subq.w     #1,d0
               bset       #3,d1         ; recmode reset,playmode=128bit
ism128c:       move.b     d1,$c0(a6)    ; playset numero 1
               move.b     d1,(a1)
               dbra       d0,ism128c
montgo:        lea.l      dspconv(pc),a2          ; channel in dspconv setzen
               move.b     (a2),d2
               move.w     #4,d0
               cmpi.b     #0,modr24
               bne.s      chk24b
               clr.w      d0
chk24b:        andi.w     #$f3,d2
               add.b      d0,d2
               move.b     d2,(a2)
               move.b     d2,$216(a6)
               move.w     d6,d0
               andi.w     #4,d0
               andi.w     #$f3,d2
               add.b      d0,d2
               move.b     d2,(a2)
               move.b     d2,$216(a6)
               asl.w      #1,d6
               move.w     d6,d0
               andi.w     #4,d0
               andi.w     #$f3,d2
               add.b      d0,d2
               move.b     d2,(a2)
               move.b     d2,$216(a6)
               asl.w      #1,d6
               move.w     d6,d0
               andi.w     #4,d0
               andi.w     #$f3,d2
               add.b      d0,d2
               move.b     d2,(a2)
               move.b     d2,$216(a6)
montok:        clr.l      d0
               rts        

chsrhigh:      btst       #3,d1         ; playmoderegister schon gesetzt ?
               bne.s      ism256        ; dann dorthin
               bclr       #3,d1
               bclr       #2,d1         ; highsamplerate resetten
               move.b     d1,$c0(a6)    ; playmoderegister resetten
               move.b     d1,(a1)
               bset       #3,d1
               move.b     d1,$c0(a6)    ; playmode=256,auf channel 0 setzen
               move.b     d1,(a1)
               clr.w      d7
ism256:        addi.w     #2,d7
               cmp.w      d7,d0
               beq.s      ism256d
               cmp.w      d7,d0
               bgt.s      ism256b
               addi.w     #8,d0
ism256b:       sub.w      d7,d0
               subq.w     #1,d0
               bset       #3,d1         ; recmode reset,playmode=128bit
ism256c:       move.b     d1,$c0(a6)    ; playset numero 1
               move.b     d1,(a1)
               dbra       d0,ism256c
ism256d:       bset       #2,d1         ; highsamplerate auswÑhlen
               move.b     d1,$c0(a6)    ; set numero 1
               move.b     d1,$c0(a6)    ; set numero 2
               move.b     d1,(a1)
               bra        montgo

setinterrupt:  move.w     (a0)+,d1
               cmpi.w     #-1,d1
               beq.s      getints
               lea.l      src_inter(pc),a1
               move.w     d1,(a1)
               move.w     (a0)+,d1
               lea.l      cause(pc),a1
               move.w     d1,(a1)
               clr.l      d0
               rts        
getints:       lea.l      src_inter(pc),a1
               move.w     (a1),d0
               swap.w     d0
               lea.l      cause(pc),a1
               move.w     (a1),d0
               rts        

buffoper:      move.w     (a0)+,d1
               lea.l      bufop(pc),a1
               cmpi.w     #-1,d1
               beq.s      bufopstat
               move.w     d1,(a1)
               btst       #0,d1
               bne.s      fplaystrt
               lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #0,d0         ; play-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               lea.l      pbufptr(pc),a1
               lea.l      pbufstrt(pc),a2
               move.l     (a2),(a1)
buffop2:       btst       #2,d1
               bne        frecstrt
               lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #1,d0         ; rec-INT-lîschen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               lea.l      rbufptr(pc),a1
               lea.l      rbufstrt(pc),a2
               move.l     (a2),(a1)
               clr.l      d0
               rts        
bufopstat:     move.w     (a1),d0
               rts        

fplaystrt:     move.w     #0,pfirstint
               move.w     d1,-(sp)
               lea.l      pbufstrt(pc),a1
               lea.l      von(pc),a2
               move.l     (a1),(a2)
               lea.l      playmod(pc),a6
               move.w     (a6),d0
               cmpi.w     #2,d0
               bge.s      fplaystart2
               lea.l      montrack(pc),a1
               clr.l      d1
               move.w     (a1),d1
               add.w      d1,d1
               add.w      d1,d1
               add.l      d1,(a2)
fplaystart2:   lea.l      pbufend(pc),a1
               lea.l      bis(pc),a2
               move.l     (a1),(a2)
               lea.l      pimode(pc),a2
               move.w     (a6),d0
               cmpi.w     #2,d0
               bge.s      fplaystart3
               move.l     #11,(a2)      ; to falcplay normal
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
fplaystart4:   lea.l      intreg(pc),a1
               move.b     (a1),d0
               bset       #0,d0         ; play-INT-setzen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               move.w     (sp)+,d1
               bra        buffop2
fplaystart3:   move.l     #25,(a2)      ; to falcplay8
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #5,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               bra.s      fplaystart4

frecstrt:      move.w     #0,rfirstint
               lea.l      rbufstrt(pc),a1
               lea.l      rvon(pc),a2
               move.l     (a1),(a2)
               lea.l      rbufend(pc),a1
               lea.l      rbis(pc),a2
               move.l     (a1),(a2)
               lea.l      rimode(pc),a2
               lea.l      playmod(pc),a6
               move.w     (a6),d0
               cmpi.w     #2,d0
               bge.s      frecstrt3
               move.l     #12,(a2)      ; to falcrec
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
frecstrt4:     lea.l      intreg(pc),a1
               move.b     (a1),d0
               bset       #1,d0         ; rec-INT-setzen
               move.b     d0,(a1)
               lea.l      vmestart(pc),a1
               movea.l    (a1),a1
               move.b     d0,$280(a1)
               clr.l      d0
               rts        
frecstrt3:     move.l     #26,(a2)      ; to falcrec8
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #5,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               bra.s      frecstrt4

dsptristate:   
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath1(pc),a2
               move.b     (a2),d2
               lea.l      dsppath2(pc),a3
               move.b     (a3),d3
               move.w     (a0)+,d0
               move.w     (a0)+,d1
               tst.w      d0
               blt.s      trierr
               cmpi.w     #1,d0
               bgt.s      trierr
               tst.w      d1
               blt.s      trierr
               cmpi.w     #1,d1
               bgt.s      trierr
               andi.b     #$f9,d2
               tst.w      d0
               beq.s      triplay
               addi.b     #6,d2
triplay:       move.b     d2,(a2)
               move.b     d2,$210(a6)
               andi.b     #$fe,d2
               andi.b     #$fe,d3
               tst.w      d1
               beq.s      trirec
               addi.b     #1,d2
               addi.b     #1,d3
trirec:        move.b     d2,(a2)
               move.b     d2,$210(a6)
               move.b     d3,(a3)
               move.b     d3,$214(a6)
triweg:        clr.l      d0
               rts        
trierr:        move.l     #-1,d0
               rts        

gpio:          lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     (a0)+,d1
               cmpi.w     #1,d1
               beq        gprd
               move.w     (a0)+,d2
               tst.w      d1
               beq.s      gpdir
               cmpi.w     #2,d1
               beq.s      gpwr
               move.l     #-1,d0
               rts        
gpdir:         lea.l      dspport(pc),a1
               move.b     (a1),d0
               bclr       #3,d0
               move.w     d2,d4
               asl.w      #3,d4
               andi.w     #8,d4
               add.b      d4,d0
               move.b     d0,$212(a6)
               move.b     d0,(a1)
               lea.l      dspconv(pc),a1
               move.b     (a1),d0
               move.w     montrack(pc),d6
               andi.w     #7,d6
               asr.w      #1,d2
               andi.w     #3,d2
               move.w     d6,d0
               andi.w     #4,d0
               andi.w     #$f3,d2
               add.b      d0,d2
               move.b     d2,(a1)
               move.b     d2,$216(a6)
               asl.w      #1,d6
               move.w     d6,d0
               andi.w     #4,d0
               andi.w     #$f3,d2
               add.b      d0,d2
               move.b     d2,(a1)
               move.b     d2,$216(a6)
               asl.w      #1,d6
               move.w     d6,d0
               andi.w     #4,d0
               andi.w     #$f3,d2
               add.b      d0,d2
               move.b     d2,(a1)
               move.b     d2,$216(a6)
               clr.l      d0
               rts        
gprd:          move.b     $212(a6),d0
               andi.l     #7,d0
               rts        
gpwr:          lea.l      dspport(pc),a1
               move.b     (a1),d0
               andi.w     #8,d0
               andi.b     #7,d2
               lea.l      gpiodat(pc),a1          ; spdif-status der gpiobits
               move.w     d2,(a1)
               tst.w      gpdirect
               bne.s      gpwr2
               bsr        gpiofreq
gpwr2:         add.b      d0,d2
               move.b     d2,$212(a6)
               clr.l      d0
               rts        

gpiofreq:      movem.l    d0-d7/a0-a6,-(sp)
               bsr        isextclk
;               bsr        checkdigi
;               tst.w      d0
;               beq.s      gpioint
;               lea.l      stack,a0
;               tst.w      (a0)
;               bsr        digana
               movem.l    (sp)+,d0-d7/a0-a6
               rts        
gpioint:       lea.l      stack,a0
               move.w     #1,(a0)
               bsr        digana
               movem.l    (sp)+,d0-d7/a0-a6
               rts        

isextclk:      btst       #2,d2
               bne.s      adatfreq
               btst       #1,d2
               bne.s      adfreq
freqspdif:     lea.l      stack,a0
               move.w     #0,(a0)
               bsr        sclock
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     #0,$242(a6)
               rts        
adfreq:        lea.l      stack,a0
               move.w     #2,(a0)
               btst       #0,d2
               beq.s      adf44
               move.w     #3,(a0)
adf44:         bsr        sclock
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     #0,$242(a6)
               rts        
adatfreq:      lea.l      stack,a0
               move.w     #13,(a0)
               bsr        sclock
               lea.l      clkdiv(pc),a1
               move.b     #0,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     #0,$242(a6)
               rts        

devconnect:    move.w     (a0)+,d1
               lea.l      src(pc),a1
               andi.w     #3,d1
               move.w     d1,(a1)
               move.w     (a0)+,d2
               lea.l      dst(pc),a1
               andi.w     #15,d2
               move.w     d2,(a1)
               move.w     (a0)+,d3
               lea.l      srcclk(pc),a1
               andi.w     #7,d3
               move.w     d3,(a1)
               move.w     (a0)+,d4
               lea.l      prescale(pc),a1
               andi.w     #15,d4
               move.w     d4,(a1)
               move.w     (a0)+,d5
               lea.l      protocol(pc),a1
               andi.w     #1,d5
               move.w     d5,(a1)

               move.w     falcxmov,d7
               btst       #2,d7         ; XBIOS devconnect protokollieren ?
               beq.s      nodevcopr     ; nein, dann raus...
               lea.l      devcolist,a6
               move.w     devconr,d7
               cmpi.w     #1300,d7
               bne.s      nlistcls
               move.w     #0,d7
nlistcls:      add.w      d7,d7
               add.w      d7,d7
               move.w     d1,0(a6,d7.w)
               move.w     d2,2(a6,d7.w)
               addi.w     #1,devconr

nodevcopr:     tst.w      d1
               bne.s      nodmaout      ; source ist nicht dmaplay
               move.w     prgemul,d7
               btst       #0,d7         ; Analyser-Emulation ?
               beq        dmaout
               cmpi.w     #12,d2        ; DMAPLAY->EXTOUT+DAC ?
               bne        dmaout
               move.w     #1,d1         ; DMAPLAY nach DSPXMIT umlenken

nodmaout:      cmpi.w     #1,d1
               beq        dspout        ; source ist dsp-transmit
               cmpi.w     #2,d1
               beq        extout        ; source ist ext-input (RDATA)
               cmpi.w     #3,d1
               beq        adout         ; source ist a/d
               move.l     #-1,d0
               rts        

devcone:       lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.w     playmod(pc),d0
               cmpi.w     #1,d0
               beq.s      devc4
               move.w     recmod(pc),d0
               cmpi.w     #1,d0
               bne.s      devcone2
devc4:         move.w     #4,d0
               bsr        matoutsel     ; zu 4Kanal-Mode
               lea.l      matin(pc),a2
               move.w     matout,d7
               lsl.w      #1,d7
               subq.w     #2,d7
               move.w     0(a2,d7.w),d0
               andi.w     #3,d0
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               andi.w     #$fc,d3
               add.w      d0,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)

devcone2:      
               bsr        checkdigi

               lea.l      srcclk(pc),a1
               move.w     (a1),d0
               cmpi.w     #1,d0
               beq.s      srccext
               cmpi.w     #2,d0
               beq.s      clkextall
               lea.l      exclkm(pc),a2
               move.w     (a2),d2
               tst.w      d2
               bne.s      devcfalc
               tst.w      d0
               beq.s      srcint
               cmpi.w     #3,d0
               beq        clkofalc
               bra.s      srcint
devcfalc:      tst.w      d0
               beq.s      clkofalc
;               cmpi.w     #3,d0
;               beq        srcint
srcint:        lea.l      prescale(pc),a1
               move.w     (a1),d2
               lea.l      stack,a0
               move.w     d2,(a0)
               bsr        sclock
               clr.l      d0
               rts        
srccext:       lea.l      gpiodat(pc),a1
               move.w     (a1),d2
               bsr        gpiofreq
               clr.l      d0
               rts        
clkextall:     lea.l      prescale(pc),a1
               move.w     (a1),d0
               clr.l      d1
               move.w     d0,d1
               divu.w     #15,d1
               andi.l     #3,d1
               move.w     #15,d2
               sub.w      d1,d2         ; sclock-wert
               mulu.w     #15,d1
               sub.w      d1,d0
               tst.w      d0
               beq.s      clkea2
               addq.w     #1,d0         ; clkdiv-wert
clkea2:        move.w     d0,-(sp)
               lea.l      stack,a0
               move.w     d2,(a0)
               bsr        sclock
               move.w     (sp)+,d0
               lea.l      stack,a0
               move.w     d0,(a0)
               bsr        clkdivide
               rts        
clkofalc:      lea.l      prescale(pc),a1
               move.w     (a1),d0
               tst.w      d0
               beq.s      clkofdig
               addq.w     #1,d0
               lea.l      stack,a0
               move.w     d0,(a0)
               bsr        clkdivide
               lea.l      stack,a0
               move.w     #15,(a0)
               bsr        sclock
               rts        
clkofdig:      lea.l      stack,a0
               move.w     #0,(a0)
               bsr        clkdivide
               lea.l      stack,a0
               move.w     #0,(a0)
               bsr        sclock
               rts        

checkdigi:     lea.l      gpiodat(pc),a1          ; gpio=sp/dif ?
               move.w     (a1),d0
               btst       #2,d0
               bne.s      nodigiok
               lea.l      srcclk(pc),a1 ; external clock ?
               move.w     (a1),d0
               cmpi.w     #1,d0
               bne.s      nodigiok
               lea.l      dsppdat(pc),a1
               move.b     (a1),d0       ; quelle von DSP-Receive holen
               btst       #3,d0         ; quelle ist EXTINP
               bne.s      digiok        ; dann ok,sp/dif->DSPREC
               andi.w     #3,d0
               cmpi.w     #2,d0         ; RDATA->PDATA ?
               beq.s      digiok        ; dann ok,sp/dif->PDATA
               lea.l      dacrec(pc),a1 ; quelle von DAC(ziel) holen
               move.w     (a1),d0
               cmpi.w     #3,d0         ; DSPcard->DAC ?
               beq.s      digiok        ; dann ok,sp/dif->DAC
nodigiok:      clr.w      d0
               rts        
digiok:        move.w     #-1,d0
               rts        

; Zielkomponente(n) mit DMAPLAY-Source verbinden
dmaout:        lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               btst       #0,d2         ; ist DMAREC unser ziel ?
               beq.s      dmaout1       ; wenn ja: DMAPLAY->DMAREC
dmarset:       move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; externen Matrix_input bestimmen:
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #2,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dmarset1b     ; dann matrix_input von dsp-transmit
               bset       #2,d7         ; sonst matrix_input von matrix_out
dmarset1b:     bclr       #1,d7
               move.b     d7,(a0)
               move.b     d7,$214(a6)   ; externen Matrix_input schreiben
dmaout1:       lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               btst       #1,d2         ; ist DSPREC unser ziel ?
               beq.s      dmaout2       ; wenn ja: DMAPLAY->DSPREC
dsprset:       move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bclr       #3,d7         ; quelle ist matrix_out
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
dmaout2:       lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               beq.s      dmaout3       ; wenn ja: DMAPLAY->EXTOUT
extrset:       move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bclr       #1,d7         ; quelle ist Matrix_out
               bclr       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
dmaout3:       lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               btst       #3,d2         ; ist DAC unser ziel ?
               beq.s      dmaout4       ; wenn ja: DMAPLAY->DAC
dacrset:       move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #1,d0
               lea.l      playmod(pc),a2
               move.w     (a2),d7       ; playmode holen
               cmpi.w     #2,d7         ; playmode ist Vierkanal oder Stereo ?
               blt.s      dacrsetb      ; dann DMAPLAY->DAC
               move.w     #3,d0         ; sonst Matrix_in->DAC
dacrsetb:      move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; quelle von Matrix_in holen
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #2,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dacrsetb2     ; dann DSP_Transceive->Matrix_in
               bset       #2,d7         ; sonst Matrix_Out->Matrix_in
dacrsetb2:     bclr       #1,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
               lea.l      playmod(pc),a2
               move.w     (a2),d7       ; playmode holen
               cmpi.w     #2,d7         ; playmode ist Vierkanal oder Stereo ?
               blt.s      dmaout4       ; dann nÑchstes ziel abfragen
               move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; quelle DMAPLAY auswÑhlen(Sync/Takt)
               lea.l      extrec(pc),a0 ; als quelle von EXTOUT(ziel) setzen
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; und setzen
dmaout4:       bsr        adc8tst
               bra        devcone       ; fertig und raus hier...

; Zielkomponente(n) mit DSPXMIT-Source verbinden
dspout:        lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               btst       #0,d2         ; ist DMAREC unser ziel ?
               beq.s      dspout1       ; wenn ja: DSPXMIT->DMAREC
dmarset2:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #3,d0         ; mit quelle Matrix_in verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu Matrix_in setzen
               lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung !!!???!!!
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; externen Matrix-input bestimmen:
               bclr       #2,d7         ; dsp_transmit->Matrix_input
               bclr       #1,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
dspout1:       lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               btst       #1,d2         ; ist DSPREC unser ziel ?
               beq.s      dspout2       ; wenn ja: DSPXMIT->DSPREC
dsprset2:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #3,d0         ; mit quelle DSPXMIT verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DSPXMIT setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bclr       #3,d7         ; quelle ist matrix_out
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
dspout2:       lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               beq.s      dspout3       ; wenn ja: DSPXMIT->EXTOUT
extrset2:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #3,d0         ; quelle DSPXMIT setzen(vermerk)
               move.w     d0,(a0)       ; und sichern
               move.w     #1,d0
               move.w     d0,cardrec
;               bsr        matinsel      ; Verbindung DMAPLAY->Matrix_out setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bclr       #1,d7         ; quelle ist DSP_Transmit
               bset       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
dspout3:       lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               btst       #3,d2         ; ist DAC unser ziel ?
               beq        dspout4       ; wenn ja: DSPXMIT->DAC
dacrset2:      move.w     asrc(pc),d7
               cmpi.w     #1,d7
               bne.s      dacrset2b
               cmpi.w     #2,playmod    ; playmode=Achtkanal?
               bne.s      dacrset2b
;               cmpi.w     #2,recmod     ; recmode=Achtkanal?
;               bne.s      dacrset2b
               lea.l      dsprec(pc),a1 ; quelle von DAC(ziel) holen
               move.w     (a1),d7
               cmpi.w     #2,d7         ; ADC->DSPXMIT ?
               bne.s      dacrset2b
               lea.l      dsppath2(pc),a1
               move.b     (a1),d7
               bclr       #1,d7         ; DSPXMIT->MatrixIn
               bclr       #2,d7
               bset       #3,d7         ; convertmode an
               move.b     d7,(a1)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$214(a6)   ; und setzen
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; mit MatrixIn verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC
               bra.s      dspout4
dacrset2b:     move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; Matrix_in->DAC
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu DSPXMIT setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; quelle von Matrix_in holen
               bclr       #2,d7         ; DSP-Transceive->Matrix_in
               bclr       #1,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
dspout4:       bsr        adc8tst
               bra        devcone       ; fertig und raus hier...

; Zielkomponente(n) mit EXTINP-Source verbinden
extout:        lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               btst       #0,d2         ; ist DMAREC unser ziel ?
               beq.s      extout1       ; wenn ja: EXTINP->DMAREC
dmarset3:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #3,d0         ; mit quelle Matrix_in verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu Matrix_in setzen
               lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #0,d0         ; DAC-quelle entfernen
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; keine Verbindung
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; externen Matrix_input bestimmen:
               bclr       #2,d7
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #1,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dmarset3b     ; dann matrix_input von dsp_transmit
               bset       #1,d7         ; sonst matrix_input von EXTINP (RDATA)
dmarset3b:     move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; externen Matrix-input schreiben
extout1:       lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               btst       #1,d2         ; ist DSPREC unser ziel ?
               beq.s      extout2       ; wenn ja: EXTINP->DSPREC
dsprset3:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #1,d0         ; mit quelle DMAPLAY verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bset       #3,d7         ; quelle ist EXTINP
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
extout2:       lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               bne.s      extrset3      ; wenn ja: EXTINP->EXTOUT
;               lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
;               move.w     (a0),d0
;               cmpi.w     #3,d0         ; DMAREC-quelle ist Matrix_in ?
;               beq.s      extout3       ; dann nÑchstes ziel abfragen
               bra.s      extout3       ; nÑchstes ziel abfragen
extrset3:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #3,d0         ; EXTOUT mit quelle EXTINP verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     #1,d0
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu DMAPLAY setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bset       #1,d7         ; quelle ist EXTINP(RDATA)
               bclr       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
extout3:       lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               btst       #3,d2         ; ist DAC unser ziel ?
               beq.s      extout4       ; wenn ja: EXTINP->DAC
dacrset3:      move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; Matrix_in->DAC
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath2(pc),a0
               move.b     (a0),d7       ; quelle von Matrix_in holen
               bclr       #2,d7
               lea.l      playmod(pc),a5
               move.w     (a5),d5       ; playmode holen
               bclr       #1,d7
               cmpi.w     #1,d5         ; playmode ist Vierkanal ?
               beq.s      dacrset3b     ; dann DSP_Transceive->Matrix_in
               bset       #1,d7         ; sonst EXTINP->Matrix_in
dacrset3b:     move.b     d7,(a0)       ; und sichern
               move.b     d7,$214(a6)   ; und setzen
extout4:       bsr        adc8tst
               bra        devcone       ; fertig und raus hier...

adout:         lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               btst       #0,d2         ; ist DMAREC unser ziel ?
               beq.s      adout1        ; wenn ja: ADC->DMAREC
dmarset4:      move.w     #1,d0
               bsr        matoutsel     ; zu DMAREC-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC setzen
adout1:        lea.l      dsprec(pc),a0 ; quelle von DSPREC(ziel) holen
               btst       #1,d2         ; ist DSPREC unser ziel ?
               beq.s      adout2        ; wenn ja: ADC->DSPREC
dsprset4:                 ;    move.w     asrc(pc),d7
;               cmpi.w     #1,d7
;               bne.s      dsprset4b
               cmpi.w     #2,playmod    ; playmode=Achtkanal?
               bne.s      dsprset4b
;               cmpi.w     #2,recmod     ; recmode=Achtkanal?
;               bne.s      dsprset4b
               lea.l      dacrec(pc),a1 ; quelle von DAC(ziel) holen
               move.w     (a1),d7
               cmpi.w     #3,d7         ; DSPXMIT->DAC ?
               bne.s      dsprset4b
               lea.l      dsppath2(pc),a1
               move.b     (a1),d7
               bset       #3,d7         ; convertmode an
               move.b     d7,(a1)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$214(a6)   ; und setzen
dsprset4b:     move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu ADC setzen
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von DSP-Receive holen
               bclr       #3,d7         ; quelle ist matrix_out
               move.b     d7,(a0)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$240(a6)   ; und setzen
adout2:        lea.l      extrec(pc),a0 ; quelle von EXTOUT(ziel) holen
               btst       #2,d2         ; ist EXTOUT unser ziel ?
               beq.s      adout3        ; wenn ja: ADC->EXTOUT
extrset4:      move.w     #3,d0
               bsr        matoutsel     ; zu Matrix_out-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               move.w     d0,cardrec
               bsr        matinsel      ; Verbindung zu ADC setzen
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppdat(pc),a0
               move.b     (a0),d7       ; quelle von EXTOUT(PDATA) holen
               bclr       #1,d7         ; quelle ist Matrix_out
               bclr       #0,d7
               move.b     d7,(a0)       ; und sichern
               move.b     d7,$240(a6)   ; und setzen
adout3:        lea.l      dacrec(pc),a0 ; quelle von DAC(ziel) holen
               btst       #3,d2         ; ist DAC unser ziel ?
               beq.s      adout4        ; wenn ja: ADC->DAC
dacrset4:                 ;     move.w     asrc(pc),d7
;               cmpi.w     #1,d7
;               bne.s      dacrset4b
               cmpi.w     #2,playmod    ; playmode=Achtkanal?
               bne.s      dacrset4b
;               cmpi.w     #2,recmod     ; recmode=Achtkanal?
;               bne.s      dacrset4b
               lea.l      dsppath2(pc),a1
               move.b     (a1),d7
               bclr       #1,d7         ; Matrixin->MatrixOut
               bset       #2,d7
               bset       #3,d7         ; convertmode an
               move.b     d7,(a1)       ; und sichern
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               move.b     d7,$214(a6)   ; und setzen
               move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #3,d0         ; mit MatrixIn verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC
               bra.s      adout4
dacrset4b:     move.w     #2,d0
               bsr        matoutsel     ; zu DAC-auswahl
               move.w     #2,d0         ; mit quelle ADC verbinden
               move.w     d0,(a0)       ; und sichern
               bsr        matinsel      ; Verbindung zu ADC
adout4:        bsr        adc8tst
               bra        devcone       ; fertig und raus hier...

adc8tst:       rts        
               cmpi.w     #2,playmod    ; playmode=Achtkanal?
               bne.s      adctst3       ; wenn nein,fertig und raus hier...
;               tst.w      recmod     ; recmode=Stereo ?
;               bne.s      adctst3       ; wenn nein,fertig und raus hier...
               move.w     dacrec,d7
               cmpi.w     #2,d7         ; quelle von DAC(ziel) holen
               beq.s      adctst1
               move.w     extrec,d7
               cmpi.w     #2,d7         ; quelle von EXTOUT(ziel) holen
;               beq.s      adctst1
               move.w     dsprec,d7
               cmpi.w     #2,d7         ; quelle von DSPREC(ziel) holen
;               beq.s      adctst1       ; nur ADC->DMAREC dann lîschen...
               bra.s      adctst3       ; oder ADC keine Quelle, dann lîschen
adctst1:       lea.l      dmarec(pc),a0 ; quelle von DMAREC(ziel) holen
               move.w     (a0),d7
               tst.w      d7            ; gibt es eine Quelle fÅr DMAREC ?
               beq.s      adctst2       ; wenn ja, dann kein ADC-Emulmode
               cmpi.w     #2,d7         ; gibt es eine Quelle fÅr DMAREC ?
               beq.s      adctst2       ; wenn ja, dann kein ADC-Emulmode
               bra.s      adctst4
adctst2:       bsr        initadc8b     ; sonst ADC-EmulMode einschalten
               rts        
adctst3:       bsr        no_emuladc8   ; dann dorthin
adctst4:       rts                      ; fertig und raus hier...

matoutsel:     movem.l    d3/a3/a6,-(sp)
               move.w     d0,matout
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      hireg(pc),a3
               move.b     (a3),d3
               bclr       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               tst.w      d0
               beq.s      matoutgo
               bset       #2,d3
               move.b     d3,(a3)
               move.b     d3,$40(a6)
               cmpi.w     #1,d0
               beq.s      matoutgo
               move.b     d3,$40(a6)
               cmpi.w     #2,d0
               beq.s      matoutgo
               move.b     d3,$40(a6)
               cmpi.w     #3,d0
               beq.s      matoutgo
               move.b     d3,$40(a6)
matoutgo:      movem.l    (sp)+,d3/a3/a6
               rts        

matinsel:      movem.l    d3/a3/a6,-(sp)
               move.l     d7,-(sp)
               lea.l      matin(pc),a6
               move.w     matout,d7
               lsl.w      #1,d7
               subq.w     #2,d7
               tst.w      d7
               blt.s      nomatin
               cmpi.w     #8,d7
               bgt.s      nomatin
               move.w     d0,0(a6,d7.w)
nomatin:       move.l     (sp)+,d7
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dspreg(pc),a3
               move.b     (a3),d3
               andi.w     #$fc,d3
               andi.w     #3,d0
               add.b      d0,d3
               move.b     d3,(a3)
               move.b     d3,$80(a6)
               movem.l    (sp)+,d3/a3/a6
               rts        

sndstatus:     move.w     (a0)+,d1
               cmpi.w     #$dd02,d1
               beq.s      fdicook
               cmpi.w     #1,d1
               beq        frecres
sndstat2:      clr.l      d0
               lea.l      snderr(pc),a1
               move.b     (a1),d0
               bclr       #4,(a1)
               bclr       #5,(a1)
               rts        
fdicook:       move.l     #$4711,d0
               rts        

buffptr:       movea.l    (a0)+,a1
               lea.l      pbufptr(pc),a2
               move.l     (a2),(a1)+
               lea.l      rbufptr(pc),a2
               move.l     (a2),(a1)+
               move.l     #0,(a1)+
               move.l     #0,(a1)
               clr.l      d0
               rts        

falcplay:      movea.l    von,a3        ; von a3
               move.l     bis,d1        ; bis d1
               clr.l      d4
               move.w     ptracks,d4    ; Anzahl der For/Backstep d4
               lea.l      sndmode(pc),a6
               tst.w      (a6)          ; sndmode stereo8
               bne.s      ptstereo16
               lsl.w      #1,d4
ptstereo16:    cmpi.w     #1,(a6)       ; sndmode stereo16
               bne.s      ptmono8
               lsl.w      #2,d4
ptmono8:       move.l     fifo(pc),d2   ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               movea.l    vmestart(pc),a0
               movea.l    a0,a1
               adda.l     #$40,a0
               adda.l     #$100,a1
               lea.l      pbufptr(pc),a5
               movea.l    a3,a2
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        fplayend
fpfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrf
               lea.l      snderr(pc),a4
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
nowrf:         move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      fpcopyanf
               bra.s      fpfill
fpcopyanf:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
fpcopy:        move.l     d4,-(sp)
               cmpi.w     #1,(a6)       ; sndmode
               beq.s      stereo16
               tst.w      (a6)          ; sndmode
               beq.s      stereo8
               cmpi.w     #2,(a6)       ; sndmode
               beq.s      mono8
               bra.s      stereo16
mono8:         move.b     (a2)+,d7      ; MonoKanal,Byte holen
               clr.w      d6
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra.s      fpcopy2
stereo8:       move.b     (a2)+,d7      ; Linker Kanal,Byte holen
               move.b     (a2)+,d5      ; Rechter Kanal,Byte holen
               clr.w      d6
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               bra.s      fpcopy2
stereo16:      move.b     (a2)+,d7      ; Linker Kanal,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal,LowByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,LowByte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,LowByte senden,A1=0
fpcopy2:       move.l     (sp)+,d4
               adda.l     d4,a2
               move.l     a2,(a5)       ; Playposition
               cmpa.l     d1,a2
               bge.s      fplayend
               dbra       d0,fpcopy
fp_back:       move.l     a2,von        ; Playposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               tst.w      pfirstint
               bne        intee
               move.w     #1,pfirstint
               move.w     cause,d1
               btst       #0,d1
               beq        intee
               move.w     src_inter,d1
               btst       #0,d1
               beq        timera
               bra        mfpint
fplayend:      moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     a2,von        ; Playposition retten
               move.w     bufop,d3      ; mode (Bit1=Loop ein/aus) d3
               btst       #1,d3
               beq        fendplay      ; kein loop
               lea.l      pbufstrt(pc),a1
               move.l     (a1),(a2)
               move.l     (a1),(a5)     ; bufpointer auf Anfangswert setzen
               clr.l      d1
               move.w     montrack,d1
               add.w      d1,d1
               add.w      d1,d1
               add.l      d1,von
               lea.l      pbufend(pc),a1
               lea.l      bis(pc),a2
               move.l     (a1),(a2)
               bra.s      intptest
fendplay:      lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #0,d0         ; play-INT-lîschen
               move.b     d0,(a1)
               movea.l    vmestart(pc),a1
               move.b     d0,$280(a1)
               lea.l      pbufstrt(pc),a1
               move.l     (a1),(a5)     ; bufpointer auf Anfangswert setzen
intptest:      move.w     cause,d1
               tst.w      d1
               beq.s      intee
               btst       #0,d1
               beq.s      intee
               move.w     src_inter,d1
               btst       #0,d1
               beq.s      timera
mfpint:        movem.l    (sp)+,d0-d7/a0-a6
imfpadr:       move.l     $13c,-(sp)
               nop        
               rts        
timera:        movem.l    (sp)+,d0-d7/a0-a6
itimadr:       move.l     $134,-(sp)
               nop        
               rts        
intee:         movem.l    (sp)+,d0-d7/a0-a6
               rte        

falcrec:       movea.l    rvon,a3       ; von a3
               move.l     rbis,d1       ; bis d1
               movea.l    vmestart(pc),a0
               movea.l    a0,a1
               adda.l     #$60,a0
               adda.l     #$ff,a1
               lea.l      rbufptr(pc),a5          ; pointer record
               clr.l      d4
               move.w     rtracks,d4    ; Anzahl der For/Backstep d4
               lsl.w      #2,d4
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        frecend
franf:         move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      fnordful
               lea.l      snderr(pc),a4
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
fnordful:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      frcopy        ; wenn ja, daten einlesen
               bra.s      franf
frcopy:        move.l     rfifo(pc),d0  ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
frcopy2:       move.l     d4,-(sp)
               move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      frcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      frcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      frcopy3a      ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      frcopy3a      ; fehlerhafte Daten ?
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
frcopy3a:      move.l     (sp)+,d4
               adda.l     d4,a2
               move.l     a2,(a5)       ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               bge.s      frecend
frcopy3:       dbra       d0,frcopy2
fr_back:       move.l     a2,rvon       ; recposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               tst.w      rfirstint
               bne        intee2
               move.w     #1,rfirstint
               move.w     cause,d1
               btst       #1,d1
               beq.s      intee2
               move.w     src_inter(pc),d1
               btst       #0,d1
               beq        timera
               bra        mfpint
frecend:       moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Recbyte speichern
               move.l     a2,rvon       ; Playposition retten
               move.w     bufop,d3      ; mode (Bit1=Loop ein/aus) d3
               btst       #3,d3
               beq        fendrec       ; kein loop
               lea.l      rbufstrt(pc),a1
               lea.l      rvon(pc),a2
               move.l     (a1),(a2)
               move.l     (a1),(a5)     ; Bufpointer auf Anfangswert setzen
               lea.l      rbufend(pc),a1
               lea.l      rbis(pc),a2
               move.l     (a1),(a2)
               bra.s      intrtest
fendrec:       lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #1,d0         ; rec-INT-lîschen
               move.b     d0,(a1)
               movea.l    vmestart(pc),a1
               move.b     d0,$280(a1)
               lea.l      rbufstrt(pc),a1
               move.l     (a1),(a5)     ; Bufpointer auf Anfangswert setzen
intrtest:      move.w     cause,d1
               btst       #1,d1
               beq.s      intee2
               move.w     src_inter(pc),d1
               btst       #0,d1
               beq        timera
               bra        mfpint
intee2:        movem.l    (sp)+,d0-d7/a0-a6
               rte        

falcplay8:     movea.l    von(pc),a2    ; von a2
               move.l     bis(pc),d1    ; bis d1
               move.w     sndmode(pc),d4
ptmono8b:      move.l     fifo(pc),d2   ; fifolen  (len/2/4-1) d2
               movea.l    vmestart(pc),a0
               lea.l      snderr(pc),a4
               move.w     ptracks,d5    ; Anzahl der Tracks
               movea.l    a0,a1
               adda.l     #$40,a0
               adda.l     #$100,a1
               lea.l      pbufptr(pc),a5
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        fplayendb
fpfillb:       btst       #0,(a0)       ; FIFO leer ?
               bne.s      nowrfb
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
nowrfb:        btst       #1,(a0)       ; FIFO halbleer ?
               beq.s      fpfillb
fpcopyanfb:    move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
fpcopyb:       cmpi.w     #1,d4         ; sndmode
               beq.s      stereo16b
               tst.w      d4            ; sndmode
               beq        stereo8b
               cmpi.w     #2,d4         ; sndmode
               beq.s      mono8b
stereo16b:     move.b     (a2)+,2(a1)   ; Linker Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte holen
               tst.w      d5
               beq.s      fploop16
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte holen
               cmpi.w     #1,d5
               beq.s      fploop16
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte holen
               cmpi.w     #2,d5
               beq.s      fploop16
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte holen
fploop16:      move.l     a2,(a5)       ; Playposition
               cmpa.l     d1,a2
               bge        fplayendb
               dbra       d0,stereo16b
               bra        fp_backb
mono8b:        clr.w      d6
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               tst.w      d5
               beq.s      fploopm8
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #1,d5
               beq.s      fploopm8
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #2,d5
               beq.s      fploopm8
               move.b     (a2)+,d7      ; MonoKanal,Byte holen
               move.b     d7,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     d7,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
fploopm8:      move.l     a2,(a5)       ; Playposition
               cmpa.l     d1,a2
               bge.s      fplayendb
               dbra       d0,mono8b
               bra.s      fp_backb
stereo8b:      clr.w      d6
               move.b     (a2)+,2(a1)   ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               tst.w      d5
               beq.s      fploops8
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #1,d5
               beq.s      fploops8
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
               cmpi.w     #2,d5
               beq.s      fploops8
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
fploops8:      move.l     a2,(a5)       ; Playposition
               cmpa.l     d1,a2
               bge.s      fplayendb
               dbra       d0,stereo8b
fp_backb:      move.l     a2,von        ; Playposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               tst.w      pfirstint
               bne        inteeb
               move.w     #1,pfirstint
               move.w     cause(pc),d1
               btst       #0,d1
               beq.s      inteeb
               move.w     src_inter(pc),d1
               btst       #0,d1
               beq        timera
               bra        mfpint
fplayendb:     moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     a2,von        ; Playposition retten
               move.w     bufop,d3      ; mode (Bit1=Loop ein/aus) d3
               btst       #1,d3
               beq        fendplayb     ; kein loop
               lea.l      pbufstrt(pc),a1
               lea.l      von(pc),a2
               move.l     (a1),(a2)
               move.l     (a1),(a5)     ; bufpointer auf Anfangswert setzen
               lea.l      pbufend(pc),a1
               lea.l      bis(pc),a2
               move.l     (a1),(a2)
               bra.s      intptestb
fendplayb:     lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #0,d0         ; play-INT-lîschen
               move.b     d0,(a1)
               movea.l    vmestart(pc),a1
               move.b     d0,$280(a1)
               lea.l      pbufstrt(pc),a1
               move.l     (a1),(a5)     ; bufpointer auf Anfangswert setzen
intptestb:     move.w     cause(pc),d1
               btst       #0,d1
               beq.s      inteeb
               move.w     src_inter(pc),d1
               btst       #0,d1
               beq        timera
               bra        mfpint
inteeb:        movem.l    (sp)+,d0-d7/a0-a6
               rte        

falcrec8:      movea.l    rvon(pc),a2   ; von a2
               move.l     rbis(pc),d1   ; bis d1
               lea.l      snderr(pc),a4
               movea.l    vmestart(pc),a0
               movea.l    a0,a1
               adda.l     #$60,a0
               adda.l     #$ff,a1
               movea.l    a1,a3
               addq.l     #1,a3
               lea.l      rbufptr(pc),a5          ; pointer record
               moveq.l    #8,d2
               moveq.l    #2,d3
               cmpa.l     d1,a2         ; Ende des Buffers erreicht ?
               beq        frecendb
franfb:        move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      fnordfulb
               bset       #4,(a4)       ;Fehler rechter öberlauf
               bset       #5,(a4)       ;Fehler linker öberlauf
fnordfulb:     and.b      d3,d0         ; FIFO mehr als halbvoll ?
               bne.s      franfb        ; wenn ja, daten einlesen
frcopyb:       move.l     rfifo(pc),d0  ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
frcopy2b:      move.w     (a1),d7       ; High-Byte, Kanal1 (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      frcopy3ab     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte, Kanal1 (Bit 8 geloescht ?)...
               btst       d2,d6
               bne.s      frcopy3ab     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      frcopy3ab     ; fehlerhafte Daten ?
               move.b     d7,(a2)+      ; Kanal1-High
               move.b     d6,(a2)+      ; Kanal1-Low
               move.b     d5,(a2)+      ; Kanal2-High
               move.b     (a3),(a2)+    ; Kanal2-Low
               tst.w      rtracks
               bne.s      frcopyy0
               movem.w    (a1),d4-d7
               movem.w    (a1),d4-d7
               movem.w    (a1),d4-d7
frcopy3ab:     move.l     a2,(a5)       ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               bge        frecendb
               dbra       d0,frcopy2b
               bra.s      fr_backb
frcopyy0:      move.b     (a3),(a2)+    ; write Kanal3-High
               move.b     (a3),(a2)+    ; write Kanal3-Low
               move.b     (a3),(a2)+    ; write Kanal4-High
               move.b     (a3),(a2)+    ; write Kanal4-Low
               cmpi.w     #1,rtracks
               bgt.s      frcopyy1
               movem.w    (a1),d4-d7
               movem.w    (a1),d4-d7
               move.l     a2,(a5)       ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               bge.s      frecendb
               dbra       d0,frcopy2b
               bra.s      fr_backb
frcopyy1:      move.b     (a3),(a2)+    ; write Kanal5-High
               move.b     (a3),(a2)+    ; write Kanal5-Low
               move.b     (a3),(a2)+    ; write Kanal6-High
               move.b     (a3),(a2)+    ; write Kanal6-Low
               cmpi.w     #2,rtracks
               bgt.s      frcopyy2
               movem.w    (a1),d4-d7
               move.l     a2,(a5)       ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               bge.s      frecendb
               dbra       d0,frcopy2b
               bra.s      fr_backb
frcopyy2:      move.b     (a3),(a2)+    ; write Kanal7-High
               move.b     (a3),(a2)+    ; write Kanal7-Low
               move.b     (a3),(a2)+    ; write Kanal8-High
               move.b     (a3),(a2)+    ; write Kanal8-Low
               move.l     a2,(a5)       ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               bge.s      frecendb
frcopy3b:      dbra       d0,frcopy2b
fr_backb:      move.l     a2,rvon       ; recposition retten
               move.l     a2,(a5)       ; Returnwert Playbyte speichern
               tst.w      rfirstint
               bne        intee2b
               move.w     #1,rfirstint
               move.w     cause,d1
               btst       #1,d1
               beq        intee2b
               move.w     src_inter(pc),d1
               btst       #0,d1
               beq        timera
               bra        mfpint
frecendb:      moveq.l    #0,d0
               move.l     a2,(a5)       ; Returnwert Recbyte speichern
               move.l     a2,rvon       ; Playposition retten
               move.w     bufop,d3      ; mode (Bit1=Loop ein/aus) d3
               btst       #3,d3
               beq        fendrecb      ; kein loop
               lea.l      rbufstrt(pc),a1
               lea.l      rvon(pc),a2
               move.l     (a1),(a2)
               move.l     (a1),(a5)     ; bufpointer auf Anfangswert setzen
               lea.l      rbufend(pc),a1
               lea.l      rbis(pc),a2
               move.l     (a1),(a2)
               bra.s      intrtestb
fendrecb:      lea.l      intreg(pc),a1
               move.b     (a1),d0
               bclr       #1,d0         ; rec-INT-lîschen
               move.b     d0,(a1)
               movea.l    vmestart(pc),a1
               move.b     d0,$280(a1)
               lea.l      rbufstrt(pc),a1
               move.l     (a1),(a5)     ; bufpointer auf Anfangswert setzen
intrtestb:     move.w     cause,d1
               btst       #1,d1
               beq.s      intee2b
               move.w     src_inter(pc),d1
               btst       #0,d1
               beq        timera
               bra        mfpint
intee2b:       movem.l    (sp)+,d0-d7/a0-a6
               rte        

ihandler_mfp:  rte        

ihandler_tima: rte        

dspplay:       lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     7(a6),d0
               lea.l      dvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      dbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      dstep(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      dmode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      dfifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      dmidisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               movea.l    a6,a0
               adda.l     #2,a0         ; Adresse DSP-Receive-Status
               movea.l    a6,a1
               adda.l     #4,a1         ; Adresse DSP-Daten
               movea.l    a3,a2
               lea.l      dplaybyte(pc),a6        ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq        dsp_pback
dspcopyanf:    move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
dspcopy:       btst       #2,(a0)       ; DSP empfangsbereit ?
               beq.s      dspcopy
               move.b     (a2)+,1(a1)   ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,2(a1)   ; Rechter Kanal,LowByte senden,A1=0
               move.b     #0,3(a1)
dspcopy2:      btst       #2,(a0)       ; DSP empfangsbereit ?
               beq.s      dspcopy2
               move.b     (a2)+,1(a1)   ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,2(a1)   ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,3(a1)
               addq.l     #4,24(a6)     ; Playposition
               cmpa.l     d1,a2
               beq.s      dspplayend
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,dspcopy
dsp_pback:     lea.l      dvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
dsp_pback2:    lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dspplayend:    moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      dloop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      dvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #0,d3
               beq.s      dspendplay
               lea.l      dvon(pc),a4
               lea.l      dbvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        dsp_pback2
dspendplay:    lea.l      dplaybyte(pc),a4
               move.l     #1,8(a4)      ; Breakflag setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

dspbreak:      lea.l      cadr(pc),a0
               lea.l      dintreg(pc),a1
               move.b     (a1),d0
               andi.w     #$fc,d0
               movea.l    12(a0),a0     ; Startadresse DSP
               move.b     d0,(a0)       ; Interrupt disabled
               move.b     #146,1(a0)    ; Command Vektor $12
               rts        

conv16:        move.l     (a0)+,d0      ; Sampleanzahl
               movea.l    (a0)+,a1      ; Startadresse 16bit
               movea.l    (a0)+,a2      ; Startadresse 24bit
               move.w     (a0)+,d1      ; fileart (3=wav)
               cmpi.w     #3,d1
               beq.s      cnvwav16b     ; zur wave-routine
conv16b:       move.b     #0,-(a2)
               move.b     -(a1),-(a2)
               move.b     -(a1),-(a2)
               subq.l     #1,d0
               tst.l      d0
               bne.s      conv16b
               rts        
cnvwav16b:     move.b     -(a1),-(a2)
               move.b     -(a1),-(a2)
               move.b     #0,-(a2)
               subq.l     #1,d0
               tst.l      d0
               bne.s      cnvwav16b
               rts        

conv24:        move.l     (a0)+,d1      ; Sampleanzahl
               movea.l    (a0)+,a1      ; Startadresse 24bit
               movea.l    (a0)+,a2      ; Startadresse 16bit
               move.w     (a0)+,d2      ; fileart (3=wav)
               cmpi.w     #3,d2
               beq.s      cnvwav24b     ; zur wave-routine
conv24b:       move.b     (a1)+,d0
               lsl.w      #8,d0
               move.b     (a1),d0
               addq.l     #2,a1
               move.w     d0,(a2)+
               subq.l     #1,d1
               tst.l      d1
               bne.s      conv24b
               rts        
cnvwav24b:     addq.l     #1,a1
               move.b     (a1)+,d0
               lsl.w      #8,d0
               move.b     (a1)+,d0
               move.w     d0,(a2)+
               subq.l     #1,d1
               tst.l      d1
               bne.s      cnvwav24b
               rts        

dspmix:        move.w     (a0)+,d0      ; Anzahl KanÑle
               cmpi.w     #4,d0
               beq.s      dspmix4
               cmpi.w     #8,d0
               beq        dspmix8
               cmpi.w     #16,d0
               beq        dspmix16
               move.l     #-1,d0
               rts        

dspmix4:       movea.l    (a0)+,a2      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a4      ; zieladresse
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle2adresse
dspaccu:       move.l     (a2)+,(a4)+   ; source1
               move.l     (a3)+,(a4)+   ; source2
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccu
               clr.l      d0
               rts        

dspmix8:       movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
dspaccu8:      move.l     (a1)+,(a5)+   ; source1
               move.l     (a2)+,(a5)+   ; source2
               move.l     (a3)+,(a5)+   ; source3
               move.l     (a4)+,(a5)+   ; source4
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccu8
               clr.l      d0
               rts        

dspmix16:      movea.l    (a0)+,a1      ; quelle1adresse
               move.l     (a0)+,d1      ; len
               movea.l    (a0)+,a5      ; zieladresse
               movea.l    a5,a6
               adda.l     #16,a6
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle2adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle3adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle4adresse
               movea.l    a4,a0
dspaccu16:     move.l     (a1)+,(a5)+   ; source1
               move.l     (a2)+,(a5)+   ; source2
               move.l     (a3)+,(a5)+   ; source3
               move.l     (a4)+,(a5)+   ; source4
               adda.l     #16,a5
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccu16
               move.l     d1,d0
               asr.l      #2,d0
               movea.l    a0,a1
               adda.l     d1,a1         ; quelle5adresse
               movea.l    a1,a2
               adda.l     d1,a2         ; quelle6adresse
               movea.l    a2,a3
               adda.l     d1,a3         ; quelle7adresse
               movea.l    a3,a4
               adda.l     d1,a4         ; quelle8adresse
dspaccub16:    move.l     (a1)+,(a6)+   ; source5
               move.l     (a2)+,(a6)+   ; source6
               move.l     (a3)+,(a6)+   ; source7
               move.l     (a4)+,(a6)+   ; source8
               adda.l     #16,a6
               subq.l     #1,d0
               tst.l      d0
               bne.s      dspaccub16
               clr.l      d0
               rts        

scrubbing:     lea.l      von(pc),a2
               movea.l    (a2),a3       ; startwert a3
               lea.l      step(pc),a2
               move.l     (a2),d6
               move.l     a3,d2         ; und startwert d2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
               move.l     8(a6),d1      ; endwert d1
               lea.l      fifo(pc),a5
               move.l     (a5),d5       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               clr.l      d4            ; distance
               lea.l      slowmode(pc),a4
               lea.l      bbis(pc),a5
               cmp.l      (a5),d1
               bne.s      scloopa
               tst.w      (a4)
               beq        iscdifgo
               bra        scrubslgo
scloopa:       clr.w      (a4)
               move.l     d1,(a5)
               move.l     $4ba,d6       ; 200hz-timer
               lea.l      time(pc),a5
               move.l     (a5),d5       ; alte zeit
               move.l     d6,(a5)       ; neue zeit sichern
               sub.l      d5,d6         ; zeitdifferenz
               move.l     d6,(a2)       ; dif sichern
scloop:        move.l     d1,d3         ; und endwert d3
               lea.l      fifo(pc),a5
               move.l     (a5),d5       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               clr.l      d4            ; distance
               move.l     d3,d0
               sub.l      d2,d0
               bmi.s      iscnegdif
               lea.l      slowmode(pc),a5
               move.w     #0,(a5)
               tst.l      d0
               beq        iscdifgo
iscpldif:      move.l     4(a6),d7      ; samplerate
               divu.w     #200,d7       ; /200->ergebnis
               tst.w      d7            ; divide by zero ?
               beq        scrubpslow
               divu.w     d7,d0         ; block/ergebnis
               tst.w      d6            ; divide by zero ?
               beq        scrubpslow
               divu.w     d6,d0         ; /timer
               cmpi.w     #4,d0
               blt        scrubpslow
               btst       #0,modr24
               beq.s      iscpldi2
               cmpi.w     #6,d0
               blt        scrubpslow
               andi.l     #$ffff,d0
               divu.w     #6,d0
               andi.l     #$ffff,d0
               mulu.w     #6,d0
               move.l     d0,d4
               bra.s      iscdifgo
iscpldi2:      andi.l     #$fffc,d0
               move.l     d0,d4
               bra.s      iscdifgo
iscnegdif:     move.l     d2,d0
               sub.l      d3,d0
               move.l     4(a6),d7      ; samplerate
               divu.w     #200,d7       ; /200->ergebnis
               tst.w      d7            ; divide by zero ?
               beq        scrubnslow
               divu.w     d7,d0         ; block/ergebnis
               tst.w      d6            ; divide by zero ?
               beq        scrubnslow
               divu.w     d6,d0         ; /timer
               cmpi.w     #4,d0
               blt        scrubnslow
               btst       #0,modr24
               beq.s      iscnegdi2
               cmpi.w     #6,d0
               blt        scrubnslow
               andi.l     #$ffff,d0
               divu.w     #6,d0
               andi.l     #$ffff,d0
               mulu.w     #6,d0
               neg.l      d0
               move.l     d0,d4
               bra.s      iscdifgo
iscnegdi2:     andi.l     #$fffc,d0
               neg.l      d0
               move.l     d0,d4
iscdifgo:      move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
iscfill:       move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      iscopy1
               bra.s      iscfill
iscopy1:       move.w     d5,d0         ; ...dann FIFO halb-fuellen (fifolen)!
iscopy2:       btst       #0,modr24
               bne.s      iscopy24
               move.b     (a2),(a5)     ; Linker Kanal,HighByte senden,A1=1
               move.b     1(a2),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(a2),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(a2),(a1)    ; Rechter Kanal,LowByte senden,A1=0
               bra.s      iscopy24b
iscopy24:      move.b     (a2),(a5)     ; Linker Kanal,HighByte senden,A1=1
               move.b     1(a2),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(a2),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     3(a2),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     4(a2),(a1)    ; Rechter Kanal,LowByte senden,A1=0
               move.b     5(a2),(a1)    ; Rechter Kanal,LowByte senden,A1=0
iscopy24b:     adda.l     d4,a2
               tst.l      d4
               beq.s      iscopynxt
iscopye:       btst       #31,d4
               beq.s      isistp
               cmpa.l     d1,a2
               ble.s      isc_backv
               bra.s      iscopynxt
isistp:        cmpa.l     d1,a2
               bge.s      isc_backv
iscopynxt:     dbra       d0,iscopy2
               bra.s      isc_back
isc_backv:     movea.l    d1,a2
isc_back:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
isc_back2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
scloop2:       movem.l    (sp)+,d0-d7/a0-a6
               rte        
scrubnslow:    move.l     4(a6),d7      ; samplerate
               divu.w     #50,d7        ; /50->ergebnis
               tst.w      d6            ; divide by zero ?
               beq.s      scrubns1
               divu.w     d6,d0         ; mem/timer>ergebnis2
               andi.l     #$ffff,d7
               tst.w      d0            ; divide by zero ?
               beq.s      scrubns1
               divu.w     d0,d7         ; ergebnis/ergebnis2
               andi.l     #$ffff,d7
               tst.l      d7
               bne.s      scrubns2
scrubns1:      moveq.l    #1,d7
scrubns2:      move.l     d7,d6
               btst       #0,modr24
               bne.s      scrubns24
               move.l     #4,d4
               bra.s      scrubns3
scrubns24:     move.l     #6,d4
scrubns3:      neg.l      d4
               bra.s      scrubslgo
scrubpslow:    move.l     4(a6),d7      ; samplerate
               divu.w     #50,d7        ; /50->ergebnis
               tst.w      d6            ; divide by zero ?
               beq.s      scrubps1
               divu.w     d6,d0         ; mem/timer>ergebnis2
               andi.l     #$ffff,d7
               tst.w      d0            ; divide by zero ?
               beq.s      scrubps1
               divu.w     d0,d7         ; ergebnis/ergebnis2
               andi.l     #$ffff,d7
               tst.l      d7
               bne.s      scrubps2
scrubps1:      moveq.l    #1,d7
scrubps2:      move.l     d7,d6
               btst       #0,modr24
               bne.s      scrubps24
               move.l     #4,d4
               bra.s      scrubslgo
scrubps24:     move.l     #6,d4
scrubslgo:     move.l     d4,(a2)       ; Anzahl der For/Backstep d4
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
islfill:       move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      islcopy1
               bra.s      islfill
islcopy1:      lea.l      slowmode(pc),a4
               move.w     #1,(a4)
               move.w     d5,d0         ; ...dann FIFO halb-fuellen (fifolen)!
islcopy2:      btst       #0,modr24
               bne.s      islcopy24
               move.b     (a2),(a5)     ; Linker Kanal,HighByte senden,A1=1
               move.b     1(a2),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(a2),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     3(a2),(a1)    ; Rechter Kanal,LowByte senden,A1=0
               bra.s      islcopy3
islcopy24:     move.b     (a2),(a5)     ; Linker Kanal,HighByte senden,A1=1
               move.b     1(a2),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     2(a2),(a5)    ; Linker Kanal,LowByte senden,A1=1
               move.b     3(a2),(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     4(a2),(a1)    ; Rechter Kanal,LowByte senden,A1=0
               move.b     5(a2),(a1)    ; Rechter Kanal,LowByte senden,A1=0
islcopy3:      subq.l     #1,d6
               tst.l      d6
               bne.s      islnoadd
               adda.l     d4,a2
               cmpa.l     d1,a2
               beq        isc_back
               move.l     d7,d6
islnoadd:      dbra       d0,islcopy2
               bra        isc_back

xdplayinit:    lea.l      dvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      dbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      dvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      dbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      dbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      dbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      dplaybyte(pc),a4        ; RÅckgabewerte-Liste
               move.l     (a0)+,24(a4)  ; Anfang Playzaehler
               lea.l      dendcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert dsp
               lea.l      dfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      dstep(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      dmode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      dspmem2b
               lea.l      dmidisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
dspmem2b:      lea.l      dfifo(pc),a2
               move.l     #$7ff,(a2)    ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      dmidiw(pc),a2
               move.l     #0,(a2)
               lea.l      dloop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      dcrosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      drimode(pc),a2
               move.l     #0,(a2)
               lea.l      dpimode(pc),a2
               move.l     #15,(a2)
               move.l     a4,d0
               rts        

dsphbp:        lea.l      cadr(pc),a0
               movea.l    12(a0),a0     ; Startadresse DSP
               move.b     7(a0),d0
               lea.l      dplaybyte(pc),a5        ; RÅckgabewerte-Liste
               adda.l     #29,a5        ; zum Volume-Wert (Offset 28)
               move.w     #14,d0
               bset       #7,d0
               addi.b     #18,d0
               move.b     d0,1(a0)      ; DSP Command SetVolume (Cmd 14)
tdpvol_l:      btst       #1,2(a0)      ; DSP empfangsbereit ?
               beq.s      tdpvol_l
               move.b     (a5)+,5(a0)   ; Volume-left schreiben,Data high
               move.b     (a5)+,6(a0)   ; Data mid
               move.b     (a5)+,7(a0)   ; Data low
               addq.l     #1,a5
tdpvol_r:      btst       #1,2(a0)      ; DSP empfangsbereit ?
               beq.s      tdpvol_r
               move.b     (a5)+,5(a0)   ; Volume right schreiben
               move.b     (a5)+,6(a0)
               move.b     (a5)+,7(a0)
               lea.l      dplaybyte(pc),a5        ; RÅckgabewerte-Liste
               adda.l     #16,a5        ; zum Peakwert
               move.w     #2,d0
               bset       #7,d0
               addi.b     #18,d0
               move.b     d0,1(a0)      ; DSP Command Read-Peak (Cmd 2)
tdppkl:        btst       #0,2(a0)      ; DSP empfangsbereit ?
               beq.s      tdppkl
               move.b     5(a0),d7      ; Daten lesen
               move.b     6(a0),d6      ; Daten lesen
               move.b     7(a0),d2      ; Daten lesen
               move.b     #0,(a5)+
               move.b     d7,(a5)+
               move.b     d6,(a5)+
               move.b     d2,(a5)+
tdppkr:        btst       #0,2(a0)      ; DSP empfangsbereit ?
               beq.s      tdppkr
               move.b     5(a0),d7      ; Daten lesen
               move.b     6(a0),d6      ; Daten lesen
               move.b     7(a0),d2      ; Daten lesen
               move.b     #0,(a5)+
               move.b     d7,(a5)+
               move.b     d6,(a5)+
               move.b     d2,(a5)+
               lea.l      dvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      dbis(pc),a2
               move.l     (a2),d2       ; bis d2
               lea.l      dfifo(pc),a2
               move.l     (a2),d0       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               movea.l    a3,a2
               lea.l      dplaybyte(pc),a5        ; RÅckgabewerte-Liste
               cmpa.l     d2,a2
               beq        dsp_back
dspcopy4:      move.b     (a2)+,d7      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d6      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d5      ; Rechter Kanal,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal,HighByte holen
dspcope:       btst       #2,2(a0)      ; DSP empfangsbereit ?
               beq.s      dspcope
               move.b     d7,5(a0)      ; Linker Kanal,LowByte
               move.b     d6,6(a0)      ; Linker Kanal,HighByte
               move.b     #0,7(a0)
dspcope2:      btst       #2,2(a0)      ; DSP empfangsbereit ?
               beq.s      dspcope2
               move.b     d5,5(a0)      ; Rechter Kanal,LowByte
               move.b     d4,6(a0)      ; Rechter Kanal,HighByte
               move.b     #0,7(a0)
               addq.l     #4,24(a5)     ; Playposition
               move.l     dendcount(pc),d7
               cmp.l      24(a5),d7
               ble        dspendp4
               cmpa.l     d2,a2
               beq.s      dsplayend
               dbra       d0,dspcopy4
dsp_back:      lea.l      dvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               lea.l      dplaybyte(pc),a4
dsp_back2:     move.l     a2,(a4)       ; Returnwert Playbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dsplayend:     lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               lea.l      dvon(pc),a5
               move.l     a2,(a5)       ; Playposition retten
               move.l     4(a4),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      dspmemt1
dspmemt2:      lea.l      dvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      dvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      dbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      dbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a4)      ; Status zweiter Memblock
               bra.s      dspmemte
dspmemt1:      lea.l      dbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      dvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      dbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      dbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a4)      ; Status erster Memblock
dspmemte:      bra        dsp_back2
dspendp4:      lea.l      dplaybyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

ds_play:       lea.l      dstrm(pc),a2
               move.w     #-1,(a2)
xplayinit8:    lea.l      von(pc),a2
               lea.l      bvon(pc),a3
               lea.l      von2(pc),a5
               move.l     (a0)+,d1      ; erster Halfbuffer Anfang
               move.l     (a0)+,d2      ; zweiter Halfbuffer Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      dsfrm(pc),a1
               move.l     d3,(a1)       ; framelaenge retten
               move.l     d1,d6
               move.l     d2,d7
               cmpi.w     #3,playmod    ; 16ch ?
               beq.s      xplin16
               move.w     #16,d0
xplin8b:       move.l     d1,(a2)+
               move.l     d1,(a3)+      ; Bufferstart copy 1a
               add.l      d3,d1
               dbra       d0,xplin8b
               move.w     #16,d0
xplin8c:       move.l     d2,(a5)+
               add.l      d3,d2
               dbra       d0,xplin8c
               bra.s      xplin8d
xplin16:       move.w     #7,d0
               move.l     a2,-(sp)
               move.l     a3,-(sp)
xplin16b:      move.l     d1,(a2)
               move.l     d1,(a3)
               adda.l     #8,a2
               adda.l     #8,a3
               add.l      d3,d1
               dbra       d0,xplin16b
               move.w     #7,d0
               movea.l    (sp)+,a3
               movea.l    (sp)+,a2
               adda.l     #4,a2
               adda.l     #4,a3
xplin16c:      move.l     d1,(a2)
               move.l     d1,(a3)
               adda.l     #8,a2
               adda.l     #8,a3
               add.l      d3,d1
               dbra       d0,xplin16c
               move.l     d1,-(a2)
               move.l     d1,-(a3)
               move.w     #7,d0
               move.l     a5,-(sp)
xplin16d:      move.l     d2,(a5)
               adda.l     #8,a5
               add.l      d3,d2
               dbra       d0,xplin16d
               move.w     #7,d0
               movea.l    (sp)+,a5
               adda.l     #4,a5
xplin16e:      move.l     d2,(a5)
               adda.l     #8,a5
               add.l      d3,d2
               dbra       d0,xplin16e
               move.l     d2,-(a5)
xplin8d:       lea.l      bis(pc),a2
               add.l      d3,d6
               move.l     d6,(a2)
               lea.l      bbis(pc),a3
               move.l     d6,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d3,d7
               move.l     d7,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #5,d0
               cmpi.w     #3,playmod    ; 16ch ?
               bne.s      xplin8e
               asr.w      #1,d0
xplin8e:       subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      dstrm(pc),a6
               cmpi.w     #0,(a6)       ; directstream ?
               bne.s      emem2b
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      emem2b
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
emem2b:        lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               lea.l      pimode(pc),a2
               move.l     #17,(a2)
               move.l     a4,d0
               cmpi.w     #0,(a6)       ; directstream ?
               beq.s      xplaynds
               move.l     von2(pc),d2
               lea.l      dsblke2(pc),a5
               move.l     d2,(a5)
               move.l     von(pc),d1
               sub.l      d1,d2
               lea.l      dsfrlen2(pc),a5
               move.l     d2,(a5)
               move.l     #38,(a2)
               move.w     #0,(a6)
xplaynds:      rts        

xmdsplay8:     lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               btst       #0,modr24     ; 24Bit ?
               beq.s      xmdspl2
               asr.w      #1,d2
xmdspl2:       lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               move.l     dsfrm(pc),d4
               lea.l      dsblke2(pc),a3
dsplfill:      move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      dsnowrlx
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      dsnowrlx
               addi.l     #1,12(a5)     ;Fehler +1
dsnowrlx:      move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      dspcopygo
               bra.s      dsplfill
dspcopygo:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
dspcopydo:     lea.l      von(pc),a6
               cmpi.w     #3,playmod    ; 16ch ?
               beq.s      dspcopy16
               btst       #0,modr24     ; 8ch/24Bit ?
               bne.s      dspcopy24
               movea.l    (a6),a2       ; ...also 8ch/16bit
               move.b     (a2)+,2(a1)   ; Kanal 1,HighByte holen
               move.b     (a2)+,(a1)    ; Kanal 1,LowByte holen
               move.l     a2,(a6)+
               move.w     #6,d5
dspcopyd2:     movea.l    (a6),a2
               move.b     (a2)+,(a1)    ; Kanal 2..8,HighByte holen
               move.b     (a2)+,(a1)    ; Kanal 2..8,LowByte holen
               move.l     a2,(a6)+
               dbra       d5,dspcopyd2
               bra.s      dspcopye
dspcopy24:     movea.l    (a6),a2
               move.b     (a2)+,2(a1)   ; Kanal 1,HighByte holen
               move.b     (a2)+,(a1)    ; Kanal 1,MidByte holen
               move.b     (a2)+,(a1)    ; Kanal 1,LowByte holen
               addq.l     #1,a2
               move.l     a2,(a6)+
               move.w     #6,d5
dspcopyd3:     movea.l    (a6),a2
               move.b     (a2)+,(a1)    ; Kanal 2..8,HighByte holen
               move.b     (a2)+,(a1)    ; Kanal 2..8,MidByte holen
               move.b     (a2)+,(a1)    ; Kanal 2..8,LowByte holen
               addq.l     #1,a2
               move.l     a2,(a6)+
               dbra       d5,dspcopyd3
dspcopye:      addq.l     #1,24(a5)     ; Playposition
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        dsendplay
               cmpa.l     (a3),a2       ; halfbuffer voll ?
               beq.s      dsplend
               cmpa.l     (a6),a2       ; Speicher voll ?
               beq.s      dspfrset8
dspcpyx8:      dbra       d0,dspcopydo
               bra.s      dspl_back
dspcopy16:     movea.l    (a6),a2       ; 16ch/16bit
               move.b     (a2)+,2(a1)   ; Kanal 1,HighByte holen
               move.b     (a2)+,(a1)    ; Kanal 1,LowByte holen
               move.l     a2,(a6)+
               move.w     #14,d5
dspcopy16b:    movea.l    (a6),a2
               move.b     (a2)+,(a1)    ; Kanal 9,HighByte holen
               move.b     (a2)+,(a1)    ; Kanal 9,LowByte holen
               move.l     a2,(a6)+
               dbra       d5,dspcopy16b
               addq.l     #1,24(a5)     ; Playposition
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        dsendplay
               cmpa.l     (a3),a2       ; halfbuffer voll ?
               beq.s      dsplend
               cmpa.l     (a6),a2       ; Speicher voll ?
               beq.s      dspfrset16
dspcpyx16:     dbra       d0,dspcopydo
dspl_back:     lea.l      playbyte(pc),a4
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dspfrset8:     move.l     (a6),d7
               lea.l      von(pc),a6
               sub.l      (a6),d7
               move.w     #7,d5
dspfrs8b:      add.l      d7,(a6)+
               dbra       d5,dspfrs8b
               add.l      d4,d7
               add.l      d7,(a6)
               bra.s      dspcpyx8
dspfrset16:    move.l     (a6),d7
               lea.l      von(pc),a6
               sub.l      (a6),d7
               move.w     #15,d5
dspfrs16b:     add.l      d7,(a6)+
               dbra       d5,dspfrs16b
               add.l      d4,d7
               add.l      d7,(a6)
               bra.s      dspcpyx16
dsplend:       moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      dsmemt1
dsmemt2:       lea.l      dsblke2(pc),a2
               lea.l      von2(pc),a3
               move.l     (a3),d0
               add.l      dsfrlen2(pc),d0
               move.l     d0,(a2)
               lea.l      von(pc),a2
               moveq.l    #16,d0
dscpypvon:     move.l     (a3)+,(a2)+   ; von
               dbra       d0,dscpypvon
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      dsmemte
dsmemt1:       lea.l      dsblke2(pc),a2
               lea.l      bvon(pc),a3
               move.l     (a3),d0
               add.l      dsfrlen2(pc),d0
               move.l     d0,(a2)
               lea.l      von(pc),a2
               moveq.l    #16,d0
dscpypvo2:     move.l     (a3)+,(a2)+   ; von
               dbra       d0,dscpypvo2
               move.l     #0,4(a5)      ; Status erster Memblock
dsmemte:       bra        dspl_back
dsendplay:     lea.l      playbyte(pc),a4
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xmemplay8:     lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               btst       #0,modr24     ; 24Bit ?
               beq.s      epmidi
               asr.w      #1,d2
epmidi:        lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    16(a5),a6     ; Peak-RÅckgabewert holen
               cmpa.l     d1,a2
               beq        ep_back
epfill:        move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      enowrlx
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      enowrlx
               addi.l     #1,12(a5)     ;Fehler +1
enowrlx:       move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      epcopyanf
               bra.s      epfill
epcopyanf:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
epcopy:        btst       #0,modr24     ; 24Bit ?
               bne.s      epcopy24
               move.b     (a2)+,2(a1)   ; Linker Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte holen
               bra.s      epcopye
epcopy24:      move.b     (a2)+,2(a1)   ; Linker Kanal,HighByte holen
               move.b     (a2),(a1)     ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2),(a1)     ; Rechter Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte holen
               move.b     (a2),(a1)     ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2),(a1)     ; Rechter Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte holen
               move.b     (a2),(a1)     ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2),(a1)     ; Rechter Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,HighByte holen
               move.b     (a2),(a1)     ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte holen
               move.b     (a2),(a1)     ; Rechter Kanal,LowByte holen
               move.b     (a2)+,(a1)    ; Linker Kanal,LowByte holen
epcopye:       addq.l     #4,24(a5)     ; Playposition
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        eendplay
               cmpa.l     d1,a2
               beq.s      eplayend
               dbra       d0,epcopy
ep_back:       lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ep_back2:      lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      ep_back2b     ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
ep_back2b:     movem.l    (sp)+,d0-d7/a0-a6
               rte        
eplayend:      moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      eplayend2     ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
eplayend2:     lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      ememt1
ememt2:        lea.l      von2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      ememte
ememt1:        lea.l      bvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
ememte:        bra        ep_back2
eendplay:      lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      eendplay2     ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
eendplay2:     move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

ds_rec:        lea.l      dstrm(pc),a2
               move.w     #-1,(a2)
xrecinit8:     lea.l      xrch(pc),a2
               move.w     (a0)+,d1      ; Bitliste Kanalnummer(n)
               move.b     d1,(a2)
               lea.l      rvon(pc),a6
               lea.l      rbvon(pc),a3
               lea.l      rvon2(pc),a5
               move.l     (a0)+,d1      ; Bufferstart 1a
               move.l     (a0)+,d2      ; Bufferstart 1b
               move.l     (a0)+,d3      ; laenge
               lea.l      dsfrm(pc),a2
               move.l     d3,(a2)
               move.w     #8,d7
xrecin8b:      move.l     d1,(a6)+
               move.l     d1,(a3)+      ; Bufferstart copy 1a
               add.l      d3,d1
               dbra       d7,xrecin8b
               move.w     #8,d7
xrecin8c:      move.l     d2,(a5)+
               add.l      d3,d2
               dbra       d7,xrecin8c
               lea.l      rendcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d7
               asr.w      #5,d7
               subq.l     #1,d7
               move.l     d7,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      dstrm(pc),a6
               cmpi.w     #0,(a6)       ; directstream ?
               bne.s      xrecin8d
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
xrecin8d:      lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #20,(a2)
               cmpi.w     #0,(a6)       ; directstream ?
               beq.s      xrecnds
               move.l     rvon2(pc),d2
               lea.l      dsblke(pc),a5
               move.l     d2,(a5)
               move.l     rvon(pc),d1
               sub.l      d1,d2
               lea.l      dsfrlen(pc),a5
               move.l     d2,(a5)
               move.w     #0,(a6)
               move.l     #37,(a2)      ; external8
               cmpi.w     #11,d0        ; adc8?
               bne.s      xrecnds
               move.l     #39,(a2)      ; adc8
xrecnds:       move.l     a4,d0
               rts        

xrecinit16:    lea.l      xrch(pc),a2
               move.w     (a0)+,d1      ; Bitliste Kanalnummer(n)
               move.b     d1,(a2)
               lea.l      rvon(pc),a6
               move.l     (a0)+,d1      ; Bufferstart 1a
               move.l     d1,(a6)+
               lea.l      rbvon(pc),a3
               move.l     d1,(a3)+      ; Bufferstart copy 1a
               lea.l      rvon2(pc),a5
               move.l     (a0)+,d2
               move.l     d2,(a5)+      ; Bufferstart 1b
               move.l     (a0)+,d3      ; laenge
               add.l      d3,d1
               move.l     d1,(a6)+      ; Bufferstart 2a
               move.l     d1,(a3)+      ; Bufferstart copy 2a
               add.l      d3,d1
               move.l     d1,(a6)+      ; Bufferstart 3a
               move.l     d1,(a3)+      ; Bufferstart copy 3a
               add.l      d3,d1
               move.l     d1,(a6)+      ; Bufferstart 4a
               move.l     d1,(a3)+      ; Bufferstart copy 4a
               add.l      d3,d1
               move.l     d1,(a6)+      ; Bufferstart 5a
               move.l     d1,(a3)+      ; Bufferstart copy 5a
               add.l      d3,d1
               move.l     d1,(a6)+      ; Bufferstart 6a
               move.l     d1,(a3)+      ; Bufferstart copy 6a
               add.l      d3,d1
               move.l     d1,(a6)+      ; Bufferstart 7a
               move.l     d1,(a3)+      ; Bufferstart copy 7a
               add.l      d3,d1
               move.l     d1,(a6)+      ; Bufferstart 8a
               move.l     d1,(a3)+      ; Bufferstart copy 8a
               add.l      d3,d1         ; Bufferende Gesamt
               move.l     d1,(a6)+      ; Bufferstart 9a (Ende)
               move.l     d1,(a3)+      ; Bufferstart copy 9a (Ende)
               add.l      d3,d2
               move.l     d2,(a5)+      ; Bufferstart 2b
               add.l      d3,d2
               move.l     d2,(a5)+      ; Bufferstart 3b
               add.l      d3,d2
               move.l     d2,(a5)+      ; Bufferstart 4b
               add.l      d3,d2
               move.l     d2,(a5)+      ; Bufferstart 5b
               add.l      d3,d2
               move.l     d2,(a5)+      ; Bufferstart 6b
               add.l      d3,d2
               move.l     d2,(a5)+      ; Bufferstart 7b
               add.l      d3,d2
               move.l     d2,(a5)+      ; Bufferstart 8b
               add.l      d3,d2         ; Bufferende Gesamt
               move.l     d2,(a5)+      ; Bufferstart 9b (Ende)
               lea.l      rendcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      rfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rfifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #6,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      recbyte(pc),a4          ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      rimode(pc),a2
               move.l     #7,(a2)
               move.l     a4,d0
               rts        

xmdsrec8:      moveq.l    #2,d5
               btst       #0,modr24     ; 24Bit ?
               beq.s      xmdsrec8a     ; no
               moveq.l    #4,d5
xmdsrec8a:     lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      xmdsre8b
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xmdsre8b:      lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               moveq.l    #8,d2
               moveq.l    #2,d3
               move.l     dsfrm(pc),d4
               lea.l      dsblke(pc),a3
dsranf8:       move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      dsnrdfu8
               tst.l      24(a5)        ; Recposition abfragen
               beq.s      dsnrdfu8
               addi.l     #1,12(a5)     ;Fehler +1
dsnrdfu8:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      dsrcpy8       ; wenn ja, daten einlesen
               bra.s      dsranf8
dsrcpy8:       move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
dsrcpy8b:      lea.l      rvon(pc),a6
               move.w     (a1),d7       ; High-Byte, Kanal1 (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        dsrcpya3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte, Kanal1 (Bit 8 geloescht ?)...
               btst       d2,d6
               bne        dsrcpya3      ; fehlerhafte Daten ?
               movea.l    (a6),a2       ; BufferStart1
               btst.b     #0,xrch
               beq.s      dsrecm8
               move.b     d7,(a2)       ; Kanal1-High
               move.b     d6,1(a2)      ; Kanal1-Low
dsrecm8:       adda.l     d5,a2
               move.l     a2,(a6)+      ; Buffercount1 save,to next buffer
               move.w     (a1),d7       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               btst       d2,d7
               bne.s      dsrcpya3      ; fehlerhafte Daten ?
               move.w     (a1),d6
               movea.l    (a6),a2       ; BufferStart1
               btst.b     #1,xrch
               beq.s      dsrecm8b
               move.b     d7,(a2)       ; Kanal1-High
               move.b     d6,1(a2)      ; Kanal1-Low
dsrecm8b:      adda.l     d5,a2
               move.l     a2,(a6)+      ; Buffercount1 save,to next buffer
               move.w     #2,d1
dsrecm8c:      move.w     (a1),d7
               move.w     (a1),d6
               movea.l    (a6),a2       ; BufferStart2..8
               btst.b     d1,xrch
               beq.s      dsrecm8d
               move.b     d7,(a2)       ; Kanalx-High
               move.b     d6,1(a2)      ; Kanalx-Low
dsrecm8d:      adda.l     d5,a2
               move.l     a2,(a6)+      ; Buffercount2..4 save,to next buffer
               addq.w     #1,d1
               cmpi.w     #8,d1
               bne.s      dsrecm8c
               addq.l     #1,24(a5)     ; Recposition
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        dsendrea2
               cmpa.l     (a3),a2       ; halfbuffer voll ?
               beq.s      dsrweg8
               cmpa.l     (a6),a2       ; Speicher voll ?
               beq.s      dsrfrset
dsrcpya3:      dbra       d0,dsrcpy8b
dsr_back8b:    movem.l    (sp)+,d0-d7/a0-a6
               rte        
dsrfrset:      lea.l      rvon(pc),a4
               move.l     a2,(a4)+
               move.l     d5,-(sp)
               move.w     #7,d5
dsrfrs2:       adda.l     d4,a2
               move.l     a2,(a4)+
               dbra       d5,dsrfrs2
               move.l     (sp)+,d5
               bra.s      dsrcpya3
dsrweg8:       move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      dsmemra1
dsmemra2:      lea.l      dsblke(pc),a2
               lea.l      rvon2(pc),a3
               move.l     (a3),d0
               add.l      dsfrlen(pc),d0
               move.l     d0,(a2)
               lea.l      rvon(pc),a2
               moveq.l    #8,d0
dscpyrvon:     move.l     (a3)+,(a2)+   ; von
               dbra       d0,dscpyrvon
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      dsr_back8b
dsmemra1:      lea.l      dsblke(pc),a2
               lea.l      rbvon(pc),a3
               move.l     (a3),d0
               add.l      dsfrlen(pc),d0
               move.l     d0,(a2)
               lea.l      rvon(pc),a2
               moveq.l    #8,d0
dscpyrbvon:    move.l     (a3)+,(a2)+   ; von
               dbra       d0,dscpyrbvon
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      dsr_back8b
dsendrea2:     move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xmdsrin8:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      xmdsrin8b
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xmdsrin8b:     lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               moveq.l    #8,d2
               moveq.l    #2,d3
               move.l     dsfrm(pc),d4
               lea.l      dsblke(pc),a3
dsrianf8:      move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      dsirdfu8
               tst.l      24(a5)        ; Recposition abfragen
               beq.s      dsirdfu8
               addi.l     #1,12(a5)     ;Fehler +1
dsirdfu8:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      dsricpy8      ; wenn ja, daten einlesen
               bra.s      dsrianf8
dsricpy8:      move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
dsricpy8b:     lea.l      rvon(pc),a6
               move.w     (a1),d7       ; High-Byte, Kanal1 (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        dsricpya3     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte, Kanal1 (Bit 8 geloescht ?)...
               btst       d2,d6
               bne        dsricpya3     ; fehlerhafte Daten ?
               move.b     xrch,d5
               lsr.w      #2,d5
               andi.l     #60,d5
               cmpi.w     #0,d5
               beq.s      dsricpya1
               subi.w     #4,d5
               adda.l     d5,a6
               movea.l    (a6),a2       ; BufferStart1
               move.b     d7,(a2)+      ; Kanal1-High
               move.b     d6,(a2)+      ; Kanal1-Low
               cmpi.w     #28,d5        ; letzter kanal?
               bne.s      dsrilk1
               subq.l     #2,a2
dsrilk1:       move.l     a2,(a6)       ; BufferStart1
dsricpya1:     lea.l      rvon(pc),a6
               move.w     (a1),d7       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               btst       d2,d7
               bne.s      dsricpya3     ; fehlerhafte Daten ?
               move.w     (a1),d6
               tst.w      asrc          ; digitalquelle?
               bne.s      dsndgin       ; ist analog...
               move.w     (a1),d7       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               move.w     (a1),d6
dsndgin:       move.b     xrch,d5
               lsl.w      #2,d5
               andi.l     #60,d5
               cmpi.w     #0,d5
               beq.s      dsricpya2
               subi.w     #4,d5
               adda.l     d5,a6
               movea.l    (a6),a2       ; BufferStart1
               move.b     d7,(a2)+      ; Kanal1-High
               move.b     d6,(a2)+      ; Kanal1-Low
               cmpi.w     #28,d5        ; letzter kanal?
               bne.s      dsrilk2
               subq.l     #2,a2
dsrilk2:       move.l     a2,(a6)       ; BufferStart
dsricpya2:     lea.l      rvon(pc),a6
               addi.l     #2,28(a6)
               movea.l    28(a6),a2
               move.w     #5,d1
               tst.w      asrc          ; digitalquelle?
               bne.s      dsricrd       ; ist analog...
               move.w     #4,d1
dsricrd:       move.w     (a1),d7
               move.w     (a1),d6
               dbra       d1,dsricrd
               addq.l     #1,24(a5)     ; Recposition
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        dsendrea2
               cmpa.l     (a3),a2       ; halfbuffer voll ?
               beq        dsrweg8
               cmpa.l     32(a6),a2     ; Speicher voll ?
               beq.s      dsrifrset
dsricpya3:     dbra       d0,dsricpy8b
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dsrifrset:     lea.l      rvon(pc),a4
               move.l     a2,(a4)+
               move.w     #7,d5
dsrifrs2:      adda.l     d4,a2
               move.l     a2,(a4)+
               dbra       d5,dsrifrs2
               bra.s      dsricpya3

xmemrec8:      lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      xmemre8b
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xmemre8b:      lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               moveq.l    #8,d2
               moveq.l    #2,d3
xranf8:        move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      xnordfu8
               tst.l      24(a5)        ; Recposition abfragen
               beq.s      xnordfu8
               addi.l     #1,12(a5)     ;Fehler +1
xnordfu8:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      xrcopy8       ; wenn ja, daten einlesen
               bra.s      xranf8
xrcopy8:       move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
xrcopy8b:      lea.l      rvon(pc),a6
               move.w     (a1),d7       ; High-Byte, Kanal1 (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        xrcopya3      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte, Kanal1 (Bit 8 geloescht ?)...
               btst       d2,d6
               bne        xrcopya3      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      xrcopya3      ; fehlerhafte Daten ?
               move.w     (a1),d4
               btst.b     #0,xrch
               beq.s      xrecm8
               movea.l    (a6),a2       ; BufferStart1
               move.b     d7,(a2)+      ; Kanal1-High
               move.b     d6,(a2)+      ; Kanal1-Low
               move.b     d5,(a2)+      ; Kanal2-High
               move.b     d4,(a2)+      ; Kanal2-Low
               move.l     a2,(a6)+      ; Buffercount1 save,to next buffer
xrecm8:        move.w     #1,d1
xrecm8b:       move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               btst.b     d1,xrch
               beq.s      xrecm8c
               movea.l    (a6),a2       ; BufferStart2..4
               move.b     d7,(a2)+      ; Kanalx-High
               move.b     d6,(a2)+      ; Kanalx-Low
               move.b     d5,(a2)+      ; Kanaly-High
               move.b     d4,(a2)+      ; Kanaly-Low
               move.l     a2,(a6)+      ; Buffercount2..4 save,to next buffer
xrecm8c:       addq.w     #1,d1
               cmpi.w     #4,d1
               bne.s      xrecm8b
               addq.l     #4,24(a5)     ; Recposition
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrea2
               cmpa.l     (a6),a2       ; Speicher voll ?
               beq.s      xrweg8
xrcopya3:      dbra       d0,xrcopy8b
xr_back8b:     movem.l    (sp)+,d0-d7/a0-a6
               rte        
xrweg8:        move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      memra1
memra2:        lea.l      rvon2(pc),a3
               lea.l      rvon(pc),a2
               moveq.l    #8,d0
cpyrvon:       move.l     (a3)+,(a2)+   ; von
               dbra       d0,cpyrvon
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      xr_back8b
memra1:        lea.l      rbvon(pc),a3
               lea.l      rvon(pc),a2
               moveq.l    #8,d0
cpyrbvon:      move.l     (a3)+,(a2)+   ; von
               dbra       d0,cpyrbvon
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      xr_back8b
xendrea2:      move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xmemrec16:     lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      xmemre16b
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
xmemre16b:     lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               moveq.l    #8,d2
               moveq.l    #2,d3
xranf16:       move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      xnordfu16
               tst.l      24(a5)        ; Recposition abfragen
               beq.s      xnordfu16
               addi.l     #1,12(a5)     ;Fehler +1
xnordfu16:     and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      xrcopy16      ; wenn ja, daten einlesen
               bra.s      xranf16
xrcopy16:      move.l     rfifo(pc),d0  ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
xrcopy16b:     lea.l      rvon(pc),a6
               move.w     (a1),d7       ; High-Byte, Kanal1 (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        xrecm16d      ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Low-Byte, Kanal1 (Bit 8 geloescht ?)...
               btst       d2,d6
               bne        xrecm16d      ; fehlerhafte Daten ?
               move.w     (a1),d5       ; High-Byte, Kanal2 (Bit 8 geloescht ?)...
               btst       d2,d5
               bne        xrecm16d      ; fehlerhafte Daten ?
               move.w     (a1),d4
               btst.b     #0,xrch
               beq.s      xrecm16
               movea.l    (a6),a2       ; BufferStart1
               move.b     d7,(a2)+      ; Kanal1-High
               move.b     d6,(a2)+      ; Kanal1-Low
               move.b     d5,(a2)+      ; Kanal2-High
               move.b     d4,(a2)+      ; Kanal2-Low
               move.l     a2,(a6)+      ; Buffercount1 save,to next buffer
xrecm16:       move.w     #1,d1
xrecm16b:      move.w     (a1),d7
               move.w     (a1),d6
               move.w     (a1),d5
               move.w     (a1),d4
               btst.b     d1,xrch
               beq.s      xrecm16c
               movea.l    (a6),a2       ; BufferStart2..8
               move.b     d7,(a2)+      ; Kanal3-High
               move.b     d6,(a2)+      ; Kanal3-Low
               move.b     d5,(a2)+      ; Kanal4-High
               move.b     d4,(a2)+      ; Kanal4-Low
               move.l     a2,(a6)+      ; Buffercount2..8 save,to next buffer
xrecm16c:      addq.w     #1,d1
               cmpi.w     #8,d1
               bne.s      xrecm16b
               addq.l     #4,24(a5)     ; Recposition
               move.l     rendcount(pc),d7
               cmp.l      24(a5),d7
               ble        xendrea16
               cmpa.l     (a6),a2       ; Speicher voll ?
               beq.s      xrweg16
xrecm16d:      dbra       d0,xrcopy16b
xr_back16:     movem.l    (sp)+,d0-d7/a0-a6
               rte        
xrweg16:       move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      memra1x
memra2x:       lea.l      rvon2(pc),a3
               lea.l      rvon(pc),a2
               moveq.l    #16,d0
cpyrv16:       move.l     (a3)+,(a2)+   ; von
               dbra       d0,cpyrv16
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      xr_back16
memra1x:       lea.l      rbvon(pc),a3
               lea.l      rvon(pc),a2
               moveq.l    #16,d0
cpyrbv16:      move.l     (a3)+,(a2)+   ; von
               dbra       d0,cpyrbv16
               move.l     #0,4(a5)      ; Status erster Memblock
               bra.s      xr_back16
xendrea16:     move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xplayinit16:   lea.l      von(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      bvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      von2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      bis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      bbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      bis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a0)+,d0      ; Playposition setzen
               move.l     d0,24(a4)     ; Playposition setzen
               lea.l      strtp(pc),a2
               move.l     d0,(a2)
               lea.l      endcount(pc),a2
               move.l     (a0)+,(a2)    ; Zaehler endwert
               lea.l      fileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      step(pc),a2
               clr.l      d0
               move.w     (a0)+,d0      ; Anzahl der For/Backstep d4
               move.l     d0,(a2)       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a0)+,d0      ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.w     d0,(a2)       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               btst       #2,d0
               beq.s      ememb3
               lea.l      midisuch(pc),a2
               move.w     (a0)+,(a2)    ; midi d0
ememb3:        lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #6,d0
;               asr.w      #3,d0
               subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midiw(pc),a2
               move.l     #0,(a2)
               lea.l      loop(pc),a2
               move.l     #0,(a2)       ; LoopzÑhler  d6
               lea.l      crosflag(pc),a2
               move.l     #0,(a2)       ; Richtungsflag lîschen
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               lea.l      peaklist(pc),a2
               move.l     a2,16(a4)     ; Liste Peak-RÅckgabewert lîschen
               move.w     #15,d0
delpkl:        move.w     #0,(a2)+
               dbra       d0,delpkl
               lea.l      pimode(pc),a2
               move.l     #21,(a2)
               move.l     a4,d0
               rts        

mpeak:         lsl.w      #8,d5
               add.b      d4,d5
               btst       #15,d5
               beq.s      mpkneg
               not.w      d5
mpkneg:        cmp.w      (a6),d5
               blt.s      mpkexit
               move.w     d5,(a6)+
               rts        
mpkexit:       addq.l     #2,a6
               rts        

cpypkl:        bsr        nhrdtst
               btst       #0,d0         ; neue oder alte hardware?
               beq        cpypkl2       ; neue hardware!
               rts        
cpypkl2:       lea.l      peaklist(pc),a2
               lea.l      peakvalue(pc),a3
               move.w     #7,d0
cpypkl1:       move.w     (a2),(a3)+
               move.w     #0,(a2)+
               dbra       d0,cpypkl1
               clr.w      pkrq          ; Anforderung zurÅcknehmen
               rts        

xmemplay16:    lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a3,a2
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq        ep_backb
epfill16:      move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      enowrlx16
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      enowrlx16
               addi.l     #1,12(a5)     ;Fehler +1
enowrlx16:     move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      epcopya16
               bra.s      epfill16
epcopya16:     bsr        nhrdtst
               btst       #0,d0         ; neue oder alte hardware?
               bne        opcopya16     ; alte hardware!
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
epcopy16:      move.b     (a2)+,2(a1)   ; Kanal1,HighByte holen
               moveq.l    #7,d5
               bra.s      epcopy16c
epcopy16b:     suba.l     #16,a2
               move.b     (a2)+,(a1)    ; Kanal1,HighByte holen
epcopy16c:     move.b     (a2)+,(a1)    ; Kanal1,LowByte holen
               adda.l     #14,a2
               move.b     (a2)+,(a1)    ; Kanal9,HighByte holen
               move.b     (a2)+,(a1)    ; Kanal9,LowByte holen
               dbra       d5,epcopy16b
               addq.l     #4,24(a5)     ; Playposition
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        eendplay16
               cmpa.l     d1,a2
               beq.s      eplayend16
               dbra       d0,epcopy16
ep_backb:      lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ep_backb2:     lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      ep_backb3     ; nein ?, dann weiter
               bsr        cpypkl
ep_backb3:     movem.l    (sp)+,d0-d7/a0-a6
               rte        
eplayend16:    moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      eplayend16b   ; nein ?, dann weiter
               bsr        cpypkl
               clr.w      pkrq          ; Anforderung zurÅcknehmen
eplayend16b:   lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      ememtb1
ememtb2:       lea.l      von2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      ememte16
ememtb1:       lea.l      bvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      von(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      bbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      bis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
ememte16:      bra        ep_backb2
eendplay16:    lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      eendplay16b   ; nein ?, dann weiter
               bsr        cpypkl
eendplay16b:   move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

opcopya16:     move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
opcopy16:      move.b     (a2)+,d7      ; Linker Kanal1,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal1,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Linker Kanal2,HighByte holen
               move.b     (a2)+,d4      ; Linker Kanal2,LowByte holen
               move.b     d7,2(a1)      ; Linker Kanal1,HighByte senden,A1=1
               move.b     d5,(a1)       ; Linker Kanal2,HighByte senden,A1=0
               move.b     d6,(a1)       ; Linker Kanal1,LowByte senden,A1=0
               move.b     d4,(a1)       ; Linker Kanal2,LowByte senden,A1=0
               move.l     d1,-(sp)
               move.w     #2,d1
opcop16b:      subq.l     #4,a2
               move.b     (a2)+,d7      ; Rechter Kanal1,HighByte holen
               move.b     (a2)+,d6      ; Rechter Kanal1,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Rechter Kanal2,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal2,LowByte holen
               move.b     d7,(a1)       ; Rechter Kanal1,HighByte senden,A1=0
               move.b     d5,(a1)       ; Rechter Kanal2,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal1,LowByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal2,LowByte senden,A1=0
               move.b     (a2)+,d7      ; Linker Kanal3,HighByte holen
               move.b     (a2)+,d6      ; Linker Kanal3,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Linker Kanal4,HighByte holen
               move.b     (a2)+,d4      ; Linker Kanal4,LowByte holen
               move.b     d7,(a1)       ; Linker Kanal3,HighByte senden,A1=1
               move.b     d5,(a1)       ; Linker Kanal4,HighByte senden,A1=0
               move.b     d6,(a1)       ; Linker Kanal3,LowByte senden,A1=0
               move.b     d4,(a1)       ; Linker Kanal4,LowByte senden,A1=0
               dbra       d1,opcop16b
               move.l     (sp)+,d1
               subq.l     #4,a2
               move.b     (a2)+,d7      ; Rechter Kanal7,HighByte holen
               move.b     (a2)+,d6      ; Rechter Kanal7,LowByte holen
               addq.l     #2,a2
               move.b     (a2)+,d5      ; Rechter Kanal8,HighByte holen
               move.b     (a2)+,d4      ; Rechter Kanal8,LowByte holen
               move.b     d7,(a1)       ; Rechter Kanal7,HighByte senden,A1=0
               move.b     d5,(a1)       ; Rechter Kanal8,HighByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal7,LowByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal8,LowByte senden,A1=0
               addq.l     #4,24(a5)     ; Playposition
               move.l     endcount(pc),d7
               cmp.l      24(a5),d7
               ble        eendplay16
               cmpa.l     d1,a2
               beq        eplayend16
               dbra       d0,opcopy16
               bra        ep_backb

dsprecord:     lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #0,(a6)       ; weitere Interrupts sperren
               move.b     6(a6),d0      ; Anforderung lîschen
               move.b     7(a6),d0      ; Anforderung lîschen
               lea.l      rdvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rdbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rdfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               movea.l    a6,a0
               adda.l     #2,a0         ; Adresse DSP-Receive-Status
               movea.l    a6,a1
               adda.l     #4,a1         ; Adresse DSP-Daten
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    16(a5),a6     ; Peak-RÅckgabewert holen
               movea.l    a3,a2
dircopy:       move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
dircopy2:      move.b     #0,2(a1)      ; Daten anfordern
               move.b     #0,3(a1)      ; Daten anfordern
dirlok1:       btst       #0,(a0)       ; DSP empfangsbereit ?
               beq.s      dirlok1
               move.b     1(a1),d7      ; Daten lesen
               move.b     2(a1),d6      ; Daten lesen
               move.b     3(a1),d2      ; Daten lesen
               move.b     #0,2(a1)      ; Daten anfordern
               move.b     #0,3(a1)      ; Daten anfordern
dirlok2:       btst       #0,(a0)       ; DSP empfangsbereit ?
               beq.s      dirlok2
               move.b     1(a1),d5      ; Daten lesen
               move.b     2(a1),d4      ; Daten lesen
               move.b     3(a1),d2      ; Daten lesen
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
               asl.w      #8,d7
               add.b      d6,d7
               asl.w      #8,d5
               add.b      d4,d5
               move.l     d1,-(sp)
               move.l     a6,d1
               swap.w     d1
               btst       #15,d7
               beq.s      dpnoneg
               not.w      d7
dpnoneg:       cmp.w      d1,d7
               blt.s      dpnoadd
               move.w     d7,d1
dpnoadd:       swap.w     d1
               btst       #15,d5
               beq.s      dpnoneg2
               not.w      d5
dpnoneg2:      cmp.w      d1,d5
               blt.s      dircop2b
               move.w     d5,d1
dircop2b:      movea.l    d1,a6
               move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      dirweg
dircopy3:      dbra       d0,dircopy2
dir_back:      lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
dir_back2:     lea.l      drecbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Recordbyte speichern
               move.l     a6,16(a4)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      dir_back2b    ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
dir_back2b:    lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #1,(a6)       ; weitere Interrupts erlauben
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
dirweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     a6,16(a5)     ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      dirweg1b      ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a5)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
dirweg1b:      lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

xdrecinit:     lea.l      rdvon(pc),a2
               move.l     (a0)+,d1      ; von a3
               move.l     d1,(a2)       ; von a3
               lea.l      rdbvon(pc),a3
               move.l     (a2),(a3)     ; von a3 retten fÅr crossplay und loop
               lea.l      rdvon2(pc),a2
               move.l     (a0)+,d2      ; zweiter Speicherbereich Anfang
               move.l     d2,(a2)       ; zweiter Speicherbereich Anfang
               move.l     (a0)+,d3      ; laenge
               lea.l      rdbis(pc),a2
               add.l      d3,d1
               move.l     d1,(a2)
               lea.l      rdbbis(pc),a3
               move.l     d1,(a3)       ; bis d1 retten fÅr crossplay und loop
               lea.l      rdbis2(pc),a2
               add.l      d3,d2
               move.l     d2,(a2)
               lea.l      rdendcount(pc),a2
               move.l     (a0)+,(a2)    ; Anzahl der FIFO-Blîcke
               lea.l      rdfileart(pc),a2
               move.w     (a0)+,(a2)    ; fileart=3=WAV
               lea.l      rdfifo(pc),a2
               move.l     #$1000,(a2)   ; dspbuffer 16384 (/4=$1000) Byte
               lea.l      rdpeakbuf(pc),a2
               move.l     (a0)+,(a2)    ; Peak-Buffer-Anfang
               lea.l      drecbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     #0,8(a4)      ; Break lîschen
               move.l     #0,4(a4)      ; Memflag lîschen (1=zweiter Memblock)
               move.l     #0,12(a4)     ; Fehler lîschen
               move.l     #0,16(a4)     ; Peak-RÅckgabewert lîschen
               move.l     #0,24(a4)     ; Recposition lîschen
               lea.l      dpimode(pc),a2
               move.l     #0,(a2)
               lea.l      drimode(pc),a2
               move.l     #16,(a2)
               move.l     a4,d0
               rts        

dsphbr:        lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #0,(a6)       ; weitere Interrupts sperren
               move.b     7(a6),d0      ; Anforderung lîschen
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
               lea.l      rdpeakmerk(pc),a2
               move.l     16(a5),(a2)   ; Peakwert holen
               lea.l      rdvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rdbis(pc),a2
               move.l     (a2),d1       ; bis d1
               movea.l    a6,a1
               movea.l    a3,a2
drstrt:        clr.l      a0            ; Peak pos/neg left lîschen
               clr.l      a3            ; Peak pos/neg right lîschen
               clr.l      a4
drcopy:        move.l     rdfifo(pc),d0 ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
drcopy2:       move.b     #0,7(a1)      ; Daten anfordern
drlok1:        btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      drlok1
               move.b     5(a1),d7      ; Daten lesen
               move.b     6(a1),d6      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.b     #0,7(a1)      ; Daten anfordern
drlok2:        btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      drlok2
               move.b     5(a1),d5      ; Daten lesen
               move.b     6(a1),d4      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.l     d1,-(sp)
               cmpi.w     #3,rdfileart
               bne.s      dnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
;               bsr        rpeakcmp
               bra.s      drcope
dnorwave:      move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
;               bsr        rpeakcmp
drcope:        move.l     (sp)+,d1
               addq.l     #4,24(a5)     ; Recposition
               move.l     rdendcount(pc),d7
               cmp.l      24(a5),d7
               ble        dendrec2
               cmpa.l     d1,a2         ; Speicher voll ?
               beq.s      drweg
drcopy3:       dbra       d0,drcopy2
dr_back:       lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
dr_back2:      move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rdpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rdpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      dr_back2b     ; nein ?, dann weiter
               move.l     (a4),peakvalue
               clr.l      16(a5)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
dr_back2b:     lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #1,(a6)       ; weitere Interrupts erlauben
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
drweg:         move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      dmemr1
dmemr2:        lea.l      rdvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      dr_back2
dmemr1:        lea.l      rdbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra        dr_back2
dendrec2:      lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      rdpeakbuf(pc),a4
               movea.l    (a4),a3       ; Peakbuffer-Adresse holen
               move.l     a3,20(a5)     ; aktuelle Peakbuffer-Adresse
               lea.l      rdpeakmerk(pc),a4
               move.l     (a4),16(a5)   ; Peak-RÅckgabewert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      dendrec2b     ; nein ?, dann weiter
               move.l     (a4),peakvalue
               clr.l      16(a5)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
dendrec2b:     move.l     #1,8(a5)      ; Break setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

tdsphbr:       lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #0,(a6)       ; weitere Interrupts sperren
               move.b     7(a6),d0      ; Anforderung lîschen
               lea.l      rdvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rdbis(pc),a2
               movea.l    (a2),a0       ; bis a0
               movea.l    a6,a1
               movea.l    a3,a2
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
               adda.l     #29,a5        ; zum Volume-Wert (Offset 28)
               move.w     #14,d0
               bset       #7,d0
               addi.b     #18,d0
               move.b     d0,1(a1)      ; DSP Command SetVolume (Cmd 14)
tdrvol_l:      btst       #1,2(a1)      ; DSP empfangsbereit ?
               beq.s      tdrvol_l
               move.b     (a5)+,5(a1)   ; Volume-left schreiben,Data high
               move.b     (a5)+,6(a1)   ; Data mid
               move.b     (a5)+,7(a1)   ; Data low
               addq.l     #1,a5
tdrvol_r:      btst       #1,2(a1)      ; DSP empfangsbereit ?
               beq.s      tdrvol_r
               move.b     (a5)+,5(a1)   ; Volume right schreiben
               move.b     (a5)+,6(a1)
               move.b     (a5)+,7(a1)
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
               adda.l     #16,a5        ; zum Peakwert
               move.w     #2,d0
               bset       #7,d0
               addi.b     #18,d0
               move.b     d0,1(a1)      ; DSP Command Read-Peak (Cmd 2)
tdrpkl:        btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      tdrpkl
               move.b     5(a1),d7      ; Daten lesen
               move.b     6(a1),d6      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.b     #0,(a5)+
               move.b     d7,(a5)+
               move.b     d6,(a5)+
               move.b     d2,(a5)+
tdrpkr:        btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      tdrpkr
               move.b     5(a1),d7      ; Daten lesen
               move.b     6(a1),d6      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.b     #0,(a5)+
               move.b     d7,(a5)+
               move.b     d6,(a5)+
               move.b     d2,(a5)+
               lea.l      drecbyte(pc),a5         ; RÅckgabewerte-Liste
tdrcopy:       move.l     rdfifo(pc),d0 ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
tdrcopy2:      move.b     #0,7(a1)      ; Daten anfordern
tdrlok1:       btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      tdrlok1
               move.b     5(a1),d7      ; Daten lesen
               move.b     6(a1),d6      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               move.b     #0,7(a1)      ; Daten anfordern
tdrlok2:       btst       #0,2(a1)      ; DSP empfangsbereit ?
               beq.s      tdrlok2
               move.b     5(a1),d5      ; Daten lesen
               move.b     6(a1),d4      ; Daten lesen
               move.b     7(a1),d2      ; Daten lesen
               cmpi.w     #3,rdfileart
               bne.s      tdnorwave
               move.b     d6,(a2)+
               move.b     d7,(a2)+
               move.b     d4,(a2)+
               move.b     d5,(a2)+
               bra.s      tdrcope
tdnorwave:     move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               move.b     d4,(a2)+
tdrcope:       addq.l     #4,24(a5)     ; Recposition
               move.l     rdendcount(pc),d7
               cmp.l      24(a5),d7
               ble        tdendrec2
               cmpa.l     a0,a2         ; Speicher voll ?
               beq.s      tdrweg
tdrcopy3:      dbra       d0,tdrcopy2
tdr_back:      lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
tdr_back2:     move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               lea.l      cadr(pc),a6
               movea.l    12(a6),a6     ; Startadresse DSP
               move.b     #1,(a6)       ; weitere Interrupts erlauben
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
tdrweg:        move.l     a2,(a5)       ; Returnwert Playbyte speichern
               move.l     4(a5),d0      ; Memflag abfragen
               tst.l      d0
               bne.s      tdmemr1
tdmemr2:       lea.l      rdvon2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbis2(pc),a2
               move.l     (a2),d0       ; zweiter Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #1,4(a5)      ; Status zweiter Memblock
               bra.s      tdr_back2
tdmemr1:       lea.l      rdbvon(pc),a2
               move.l     (a2),d0       ; erster Memblock Start
               lea.l      rdvon(pc),a2
               move.l     d0,(a2)       ; von
               lea.l      rdbbis(pc),a2
               move.l     (a2),d0       ; erster Memblock Ende
               lea.l      rdbis(pc),a2
               move.l     d0,(a2)       ; bis
               move.l     #0,4(a5)      ; Status erster Memblock
               bra        tdr_back2
tdendrec2:     lea.l      rdvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
               move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               move.l     #1,8(a5)      ; Break setzen
               bsr        dspbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

imemr24:       lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      imemr24b
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
imemr24b:      lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               clr.l      dummy
               clr.l      dummy2
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
iranf24:       move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      nordfu24
               tst.l      24(a5)        ; Recposition abfragen
               beq.s      nordfu24
               addi.l     #1,12(a5)     ;Fehler +1
nordfu24:      and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ircopy24      ; wenn ja, daten einlesen
               bra.s      iranf24
ircopy24:      move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ircopy24b:     move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq        ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Mid-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq        ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d4
               beq        ircopy24c     ; fehlerhafte Daten ?
               tst.w      pluglistr
               bne.s      ircopy24bb
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d4,(a2)+
               bra.s      ircopy24bc
ircopy24bb:    move.b     d7,dummy+1
               move.b     d6,dummy+2
               move.b     d4,dummy+3
ircopy24bc:    move.w     (a1),d7       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d7
               bne.s      ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Mid-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d6
               bne.s      ircopy24c     ; fehlerhafte Daten ?
               move.w     (a1),d5       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ircopy24c     ; fehlerhafte Daten ?
               tst.w      pluglistr
               bne.s      ircopy24bd
               move.b     d7,(a2)+
               move.b     d6,(a2)+
               move.b     d5,(a2)+
               jsr        testuser
               bra.s      ircopy24be
ircopy24bd:    move.b     d7,dummy2+1
               move.b     d6,dummy2+2
               move.b     d5,dummy2+3
               jsr        testuser
               move.l     dummy,-(sp)   ; linken Kanal holen
               move.l     dummy2,-(sp)  ; rechten Kanal holen
               bsr        workplugsr    ; plugins aufrufen
               move.b     5(sp),(a2)+   ; Linker Kanal,HighByte
               move.b     6(sp),(a2)+   ; Linker Kanal,MidByte
               move.b     7(sp),(a2)+   ; Linker Kanal,LowByte
               move.b     1(sp),(a2)+   ; Linker Kanal,HighByte
               move.b     2(sp),(a2)+   ; Linker Kanal,MidByte
               move.b     3(sp),(a2)+   ; Linker Kanal,LowByte
               addq.l     #8,sp
ircopy24be:    addq.l     #6,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               bge.s      irweg24
ircopy24c:     dbra       d0,ircopy24b
ir_back24:     lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
ir_back24b:    move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
irweg24:       move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        

imemruser:     lea.l      firstbuf(pc),a1
               tst.w      (a1)
               bne.s      imemr24bu
               move.w     #1,(a1)
               bsr        killbuf
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
imemr24bu:     lea.l      rvon(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      rbis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      rfifo(pc),a2
               movea.l    (a2),a4       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               lea.l      recbyte(pc),a5          ; RÅckgabewerte-Liste
               moveq.l    #8,d2
               moveq.l    #2,d3
               movea.l    a3,a2
iranf24u:      move.b     (a0),d0       ; Flag lesen
               btst       d3,d0         ; RECORD-FIFO voll ?
               bne.s      nordfu24u
               tst.l      24(a5)        ; Recposition abfragen
               beq.s      nordfu24u
               addi.l     #1,12(a5)     ;Fehler +1
nordfu24u:     and.b      d3,d0         ; FIFO mehr als halbvoll ?
               beq.s      ircopy24u     ; wenn ja, daten einlesen
               bra.s      iranf24u
ircopy24u:     move.w     a4,d0         ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
ircopy24bu:    move.w     (a1),d7       ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d7
               beq.s      ircopy24cu    ; fehlerhafte Daten ?
               move.w     (a1),d6       ; Mid-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d6
               beq.s      ircopy24cu    ; fehlerhafte Daten ?
               move.w     (a1),d5       ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
               btst       d2,d5
               beq.s      ircopy24cu    ; fehlerhafte Daten ?
               move.b     #$7f,d7
               move.b     #$ff,d6
               btst       #0,d5
               bne.s      user1
user0:         clr.w      d7
               clr.w      d6
user1:         move.b     d7,(a2)+
               move.b     d6,(a2)+      ; Userbit speichern
               addq.l     #2,24(a5)     ; Recposition2
               move.w     (a1),d7       ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d7
               bne.s      ircopy24bbu   ; fehlerhafte Daten ?
               move.w     (a1),d5       ; Mid-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d5
               bne.s      ircopy24bbu   ; fehlerhafte Daten ?
               move.w     (a1),d4       ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
               btst       d2,d4
               bne.s      ircopy24bbu   ; fehlerhafte Daten ?
               move.b     #$7f,d7
               move.b     #$ff,d5
               btst       #0,d4
               bne.s      user1b
user0b:        clr.w      d7
               clr.w      d5
user1b:        move.b     d7,(a2)+
               move.b     d5,(a2)+      ; Userbit speichern
               addq.l     #2,24(a5)     ; Recposition
               cmpa.l     d1,a2         ; Speicher voll ?
               bge.s      irweg24u
ircopy24cu:    dbra       d0,ircopy24bu
ir_back24u:    lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Recposition retten
ir_back24bu:   move.l     a2,(a5)       ; Returnwert Recordbyte speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
irweg24u:      move.l     a2,(a5)       ; Returnwert Playbyte speichern
               lea.l      rvon(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               move.l     #1,8(a5)      ; Break setzen
               move.w     #1,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
ircopy24bbu:   subq.l     #2,a2
               bra.s      ircopy24cu

cblread:       move.l     #lfifo,d4     ; fifolen  (len/2/4-1) bei 8192Byte=$3FF a4
               lea.l      vmestart(pc),a0
               movea.l    (a0),a0
               movea.l    a0,a1
               adda.l     #$60,a0       ; StatH im Bytemode
               adda.l     #$ff,a1       ; Playread im Wordmode
               move.l     #8,d2
               lea.l      cblbits,a2
cblcopy:       asr.w      #1,d4
cblcopy2:      move.w     (a1),d6       ; cbl-anfang (geloescht) ?
               subq.w     #1,d4
               tst.w      d4
               beq.s      cblex
               btst       d2,d6
               bne.s      cblcopy2      ; fehlerhafte Daten ?
cblcopy2b:     move.w     (a1),d6       ; cbl-anfang (geloescht) ?
               subq.w     #1,d4
               tst.w      d4
               beq.s      cblex
               btst       d2,d6
               beq.s      cblcopy2b     ; fehlerhafte Daten ?
               move.b     d6,(a2)+
               move.l     #23,d1
cblcopy3:      move.w     (a1),d6
               subq.w     #1,d4
               tst.w      d4
               beq.s      cblex
               move.b     d6,(a2)+
               dbra       d1,cblcopy3
cblcopy4:      move.w     (a1),d6
               dbra       d4,cblcopy4
cblex:         movem.l    (sp)+,d0-d7/a0-a6
               rte        

imemp24:       lea.l      von(pc),a2
               movea.l    (a2),a3       ; von a3
               lea.l      bis(pc),a2
               move.l     (a2),d1       ; bis d1
               lea.l      step(pc),a2
               move.l     (a2),d4       ; Anzahl der For/Backstep d4
               lea.l      mode(pc),a2
               move.w     (a2),d3       ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               lea.l      fifo(pc),a2
               move.l     (a2),d2       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      midisuch(pc),a2
               move.w     (a2),d0       ; midi d0
               lea.l      backup(pc),a4
               clr.l      (a4)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               movea.l    a1,a5
               addq.l     #2,a5         ; Playread,a5,A1=1
               movea.l    a3,a2
               lea.l      playbyte(pc),a6         ; RÅckgabewerte-Liste
               cmpa.l     d1,a2
               beq        ip_back24
ipfill24:      move.b     (a0),d0       ; FIFO leer ?
               btst       #0,d0
               bne.s      nowrleer24
               move.l     strtp(pc),d0
               cmp.l      24(a6),d0
               beq.s      nowrleer24
               addi.l     #1,12(a6)     ;Fehler +1
nowrleer24:    move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               bne.s      ipcopyanf24
               bra.s      ipfill24
ipcopyanf24:   tst.l      d4
               blt        ipcopyn24
               cmpa.l     d1,a2
               bge        iplayend24
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopy24:      tst.w      pluglistp
               bne.s      impuse24
               btst       #0,playch
               bne.s      impuse24b
               move.b     #0,(a5)
               move.b     #0,(a5)
               move.b     #0,(a5)
               addq.l     #3,a2
               bra.s      impuse24c
impuse24b:     move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,MidByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
impuse24c:     btst       #1,playch
               bne.s      impuse24d
               move.b     #0,(a1)
               move.b     #0,(a1)
               move.b     #0,(a1)
               addq.l     #3,a2
               bra.s      imemputr24bu
impuse24d:     move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,MidByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               bra.s      imemputr24bu
impuse24:      move.b     (a2)+,1(a4)
               move.b     (a2)+,2(a4)
               move.b     (a2)+,3(a4)
               move.l     (a4),-(sp)    ; linken Kanal holen
               move.b     (a2)+,1(a4)
               move.b     (a2)+,2(a4)
               move.b     (a2)+,3(a4)
               move.l     (a4),-(sp)    ; Rechter Kanal holen
               bsr        workplugsp    ; plugins aufrufen
               btst       #0,playch
               bne.s      imemputl24
               move.b     #0,(a5)
               move.b     #0,(a5)
               move.b     #0,(a5)
               bra.s      imemputl24b
imemputl24:    move.b     5(sp),(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     6(sp),(a5)    ; Linker Kanal,MidByte senden,A1=1
               move.b     7(sp),(a5)    ; Linker Kanal,LowByte senden,A1=1
imemputl24b:   btst       #1,playch
               bne.s      imemputr24
               move.b     #0,(a1)
               move.b     #0,(a1)
               move.b     #0,(a1)
               bra.s      imemputr24b
imemputr24:    move.b     1(sp),(a1)    ; Linker Kanal,HighByte senden,A1=0
               move.b     2(sp),(a1)    ; Linker Kanal,MidByte senden,A1=0
               move.b     3(sp),(a1)    ; Linker Kanal,LowByte senden,A1=0
imemputr24b:   addq.l     #8,sp
imemputr24bu:  addq.l     #6,24(a6)     ; Playposition
               cmpa.l     d1,a2
               bge        iplayend24
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,ipcopy24
               bra        ip_back24
ipcopyn24:     cmpa.l     d1,a2
               ble        iplayend24
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopyb24:     tst.w      pluglistp
               bne.s      impuseb24
               btst       #0,playch
               bne.s      impuseb24b
               move.b     #0,(a5)
               move.b     #0,(a5)
               move.b     #0,(a5)
               addq.l     #3,a2
               bra.s      impuseb24c
impuseb24b:    move.b     (a2)+,(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,MidByte senden,A1=1
               move.b     (a2)+,(a5)    ; Linker Kanal,LowByte senden,A1=1
impuseb24c:    btst       #1,playch
               bne.s      impuseb24d
               move.b     #0,(a1)
               move.b     #0,(a1)
               move.b     #0,(a1)
               addq.l     #3,a2
               bra.s      imemputru24d
impuseb24d:    move.b     (a2)+,(a1)    ; Rechter Kanal,HighByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,MidByte senden,A1=0
               move.b     (a2)+,(a1)    ; Rechter Kanal,LowByte senden,A1=0
               bra.s      imemputru24d
impuseb24:     move.b     (a2)+,1(a4)
               move.b     (a2)+,2(a4)
               move.b     (a2)+,3(a4)
               move.l     (a4),-(sp)    ; linken Kanal holen
               move.b     (a2)+,1(a4)
               move.b     (a2)+,2(a4)
               move.b     (a2)+,3(a4)
               move.l     (a4),-(sp)    ; Rechter Kanal holen
               bsr        workplugsp    ; plugins aufrufen
               btst       #0,playch
               bne.s      imemputl24c
               move.b     #0,(a5)
               move.b     #0,(a5)
               move.b     #0,(a5)
               bra.s      imemputl24d
imemputl24c:   move.b     5(sp),(a5)    ; Linker Kanal,HighByte senden,A1=1
               move.b     6(sp),(a5)    ; Linker Kanal,MidByte senden,A1=1
               move.b     7(sp),(a5)    ; Linker Kanal,HighByte senden,A1=1
imemputl24d:   btst       #1,playch
               bne.s      imemputr24c
               move.b     #0,(a1)
               move.b     #0,(a1)
               move.b     #0,(a1)
               bra.s      imemputr24d
imemputr24c:   move.b     1(sp),(a1)    ; Linker Kanal,HighByte senden,A1=1
               move.b     2(sp),(a1)    ; Linker Kanal,MidByte senden,A1=1
               move.b     3(sp),(a1)    ; Linker Kanal,HighByte senden,A1=1
imemputr24d:   addq.l     #8,sp
imemputru24d:  addq.l     #6,24(a6)     ; Playposition
               cmpa.l     d1,a2
               ble.s      iplayend24
               adda.l     d4,a2
               add.l      d4,24(a6)     ; Playposition
               dbra       d0,ipcopyb24
ip_back24:     lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
ip_back224:    lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplayend24:    moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               lea.l      loop(pc),a4
               move.l     d6,(a4)       ; Anzahl loops sichern
               lea.l      von(pc),a4
               move.l     a2,(a4)       ; Playposition retten
               btst       #1,d3         ; crossplay ?
               beq        iplooptst24   ; wenn nein, ueberspringen
               lea.l      crosflag,a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      baktofor24
fortobak24:    addi.l     #12,d4
               neg.l      d4
               lea.l      step,a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #6,d1
               lea.l      von,a4
               move.l     d1,(a4)       ; neue Endposition
               lea.l      bvon,a4
               move.l     (a4),d1
               addq.l     #6,d1
               lea.l      bis,a4
               move.l     d1,(a4)       ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra.s      ip_back224
baktofor24:    neg.l      d4
               subi.l     #12,d4
               lea.l      step,a4
               move.l     d4,(a4)       ; Anzahl der For/Backstep d4
               subq.l     #6,d1
               lea.l      von,a4
               move.l     d1,(a4)       ; neue Anfangsposition
               lea.l      bbis,a4
               lea.l      bis,a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        ip_back224
iendplay24:    lea.l      playbyte,a4
               tst.l      60(a4)        ; wenn 1, dann neue start und endpos
               beq.s      iendplay241b
               lea.l      von,a3
               move.l     64(a4),(a3)   ; startpos fÅr compare retten
               lea.l      bis,a3
               move.l     68(a4),(a3)   ; endpos fÅr compare retten
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     #0,60(a4)     ; cuewerteÅbernommen-Flag
               bra.s      iendplay241c
iendplay241b:  lea.l      playbyte,a4
               move.l     #1,8(a4)      ; Breakflag setzen
               move.w     #0,d0         ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
iendplay241c:  cmpi.l     #35,pimode
               bne.s      iendplay242
               jsr        startupmex
iendplay242:   movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplooptst24:   btst       #0,d3
               beq.s      iendplay24
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        ip_back224

imempkp24:     movea.l    von(pc),a2    ; von a2
               move.l     bis(pc),d1    ; bis d1
               move.l     step(pc),d4   ; Anzahl der For/Backstep d4
               move.w     mode(pc),d3   ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi) d3
               move.l     fifo(pc),d2   ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               move.w     midisuch(pc),d0         ; midi d0
               lea.l      backup(pc),a4
               clr.l      (a4)
               movea.l    vmestart(pc),a0
               movea.l    a0,a1
               adda.l     #$40,a0       ; StatH im Bytemode
               adda.l     #$100,a1      ; Playread im Bytemode
               lea.l      playbyte(pc),a5         ; RÅckgabewerte-Liste
               movea.l    16(a5),a6     ; Peak-RÅckgabewert holen
               cmpa.l     d1,a2
               beq        ip_backp24
ipfillp24:     btst       #0,(a0)       ; FIFO leer ?
               bne.s      nowrleerp24
               move.l     strtp(pc),d0
               cmp.l      24(a5),d0
               beq.s      nowrleerp24
               addq.l     #1,12(a5)     ;Fehler +1
nowrleerp24:   move.b     (a0),d0       ; FIFO halbleer ?
               andi.b     #2,d0
               beq.s      ipfillp24
ipcopyanfp24:  tst.l      d4
               blt        ipcopynp24    ; rÅckwÑrts abspielen
               cmpa.l     d1,a2
               bge        iplayendp24
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopyp24:     move.w     d2,-(sp)
               move.b     playch,d2
               tst.w      pluglistp
               bne.s      impkuse24
ipcopyp24b:    movem.l    d4-d6,-(sp)   ; vorwÑrts ohne plugins
               move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.b     (a2)+,d5
               btst       #0,d2
               bne.s      impkuse24b
               move.b     #0,2(a1)
               move.b     #0,2(a1)
               move.b     #0,2(a1)
               bra.s      impkuse24c
impkuse24b:    move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,MidByte senden,A1=1
               move.b     d5,2(a1)      ; Linker Kanal,LowByte senden,A1=1
impkuse24c:    move.b     (a2)+,d5
               move.b     (a2)+,d4
               move.b     (a2)+,d6
               btst       #1,d2
               bne.s      impkuse24d
               move.b     #0,(a1)
               move.b     #0,(a1)
               move.b     #0,(a1)
               bra.s      impkuse24e
impkuse24d:    move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,MidByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
impkuse24e:    jsr        ppeakcmp
               movem.l    (sp)+,d4-d6
               addq.l     #6,24(a5)     ; Playposition
               cmpa.l     d1,a2
               bge        iplayendp24x
               adda.l     d4,a2
               add.l      d4,24(a5)     ; Playposition
               dbra       d0,ipcopyp24b
               move.w     (sp)+,d2
               bra        ip_backp24
impkuse24:     movem.l    d4-d6,-(sp)   ; vorwÑrts mit plugins
               move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.b     (a2)+,d5
               move.b     d7,1(a4)
               move.b     d6,2(a4)
               move.b     d5,3(a4)
               move.l     (a4),-(sp)    ; linken Kanal holen
               move.b     (a2)+,d5
               move.b     (a2)+,d4
               move.b     (a2)+,d6
               move.b     d5,1(a4)
               move.b     d4,2(a4)
               move.b     d6,3(a4)
               move.l     (a4),-(sp)    ; Rechter Kanal holen
               jsr        ppeakcmp
               bsr        workplugsp    ; plugins aufrufen
               btst       #0,d2
               bne.s      imempkl24
               move.b     #0,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               bra.s      imempkl24b
imempkl24:     move.b     5(sp),2(a1)   ; Linker Kanal,HighByte senden,A1=1
               move.b     6(sp),2(a1)   ; Linker Kanal,MidByte senden,A1=1
               move.b     7(sp),2(a1)   ; Linker Kanal,LowByte senden,A1=1
imempkl24b:    btst       #1,d2
               bne.s      imempkr24
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      imempkr24b
imempkr24:     move.b     1(sp),(a1)    ; Linker Kanal,HighByte senden,A1=0
               move.b     2(sp),(a1)    ; Linker Kanal,MidByte senden,A1=0
               move.b     3(sp),(a1)    ; Linker Kanal,LowByte senden,A1=0
imempkr24b:    addq.l     #8,sp
               movem.l    (sp)+,d4-d6
               addq.l     #6,24(a5)     ; Playposition
               cmpa.l     d1,a2
               bge        iplayendp24x
               adda.l     d4,a2
               add.l      d4,24(a5)     ; Playposition
               dbra       d0,impkuse24
               move.w     (sp)+,d2
               bra        ip_backp24
ipcopynp24:    cmpa.l     d1,a2
               ble        iplayendp24
               move.w     d2,d0         ; ...dann FIFO halb-fuellen (fifolen)!
ipcopybp24:    move.w     d2,-(sp)
               move.b     playch,d2
               tst.w      pluglistp
               bne.s      impkuseb24
ipcopybp24b:   movem.l    d4-d6,-(sp)   ; rÅckwÑrts ohne plugins
               move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.b     (a2)+,d5
               btst       #0,d2
               bne.s      impkuseb24b
               move.b     #0,2(a1)
               move.b     #0,2(a1)
               move.b     #0,2(a1)
               bra.s      impkuseb24c
impkuseb24b:   move.b     d7,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     d6,2(a1)      ; Linker Kanal,MidByte senden,A1=1
               move.b     d5,2(a1)      ; Linker Kanal,LowByte senden,A1=1
impkuseb24c:   move.b     (a2)+,d5
               move.b     (a2)+,d4
               move.b     (a2)+,d6
               btst       #1,d2
               bne.s      impkuseb24d
               move.b     #0,(a1)
               move.b     #0,(a1)
               move.b     #0,(a1)
               bra.s      impkuseb24e
impkuseb24d:   move.b     d5,(a1)       ; Rechter Kanal,HighByte senden,A1=0
               move.b     d4,(a1)       ; Rechter Kanal,MidByte senden,A1=0
               move.b     d6,(a1)       ; Rechter Kanal,LowByte senden,A1=0
impkuseb24e:   jsr        ppeakcmp
               movem.l    (sp)+,d4-d6
               addq.l     #6,24(a5)     ; Playposition
               cmpa.l     d1,a2
               ble        iplayendp24x
               adda.l     d4,a2
               add.l      d4,24(a5)     ; Playposition
               dbra       d0,ipcopybp24b
               move.w     (sp)+,d2
               bra        ip_backp24
impkuseb24:    movem.l    d4-d6,-(sp)   ; rÅckwÑrts mit plugins
               move.b     (a2)+,d7
               move.b     (a2)+,d6
               move.b     (a2)+,d5
               move.b     d7,1(a4)
               move.b     d6,2(a4)
               move.b     d5,3(a4)
               move.l     (a4),-(sp)    ; linken Kanal holen
               move.b     (a2)+,d5
               move.b     (a2)+,d4
               move.b     (a2)+,d6
               move.b     d5,1(a4)
               move.b     d4,2(a4)
               move.b     d6,3(a4)
               move.l     (a4),-(sp)    ; Rechter Kanal holen
               jsr        ppeakcmp
               bsr        workplugsp    ; plugins aufrufen
               btst       #0,d2
               bne.s      imempkl24c
               move.b     #0,2(a1)      ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,2(a1)      ; Linker Kanal,LowByte senden,A1=1
               bra.s      imempkl24d
imempkl24c:    move.b     5(sp),2(a1)   ; Linker Kanal,HighByte senden,A1=1
               move.b     6(sp),2(a1)   ; Linker Kanal,MidByte senden,A1=1
               move.b     7(sp),2(a1)   ; Linker Kanal,HighByte senden,A1=1
imempkl24d:    btst       #1,d2
               bne.s      imempkr24c
               move.b     #0,(a1)       ; Linker Kanal,HighByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               move.b     #0,(a1)       ; Linker Kanal,LowByte senden,A1=1
               bra.s      imempkr24d
imempkr24c:    move.b     1(sp),(a1)    ; Linker Kanal,HighByte senden,A1=1
               move.b     2(sp),(a1)    ; Linker Kanal,MidByte senden,A1=1
               move.b     3(sp),(a1)    ; Linker Kanal,HighByte senden,A1=1
imempkr24d:    addq.l     #8,sp
imempkr24ud:   movem.l    (sp)+,d4-d6
               addq.l     #6,24(a5)     ; Playposition
               cmpa.l     d1,a2
               ble.s      iplayendp24x
               adda.l     d4,a2
               add.l      d4,24(a5)     ; Playposition
               dbra       d0,impkuseb24
               move.w     (sp)+,d2
ip_backp24:    move.l     a2,von        ; Playposition retten
ip_backp224:   lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     a6,16(a4)     ; Peakwert speichern
               tst.w      pkrq          ; peakanforderung
               beq.s      ip_backp225   ; nein ?, dann weiter
               move.l     a6,peakvalue
               clr.l      16(a4)        ; peakmax lîschen
               clr.w      pkrq          ; Anforderung zurÅcknehmen
ip_backp225:   move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplayendp24x:  move.w     (sp)+,d2
iplayendp24:   moveq.l    #0,d0
               addq.l     #1,d6
               lea.l      playbyte(pc),a4
               move.l     a2,(a4)       ; Returnwert Playbyte speichern
               move.l     d6,28(a4)     ; Returnwert Anzahl loops speichern
               move.l     d6,loop       ; Anzahl loops sichern
               move.l     a2,von        ; Playposition retten
               btst       #1,d3         ; crossplay ?
               beq        iplooptstp24  ; wenn nein, ueberspringen
               lea.l      crosflag,a5
               tst.b      (a5)          ; Richtungsflag testen
               bne.s      baktoforp24
fortobakp24:   addi.l     #12,d4
               neg.l      d4
               move.l     d4,step       ; Anzahl der For/Backstep d4
               subq.l     #6,d1
               move.l     d1,von        ; neue Endposition
               move.l     bvon,d1
               addq.l     #6,d1
               move.l     d1,bis        ; neue Anfangsposition
               move.b     #1,(a5)       ; cross-backplay
               bra        ip_backp224
baktoforp24:   neg.l      d4
               subi.l     #12,d4
               move.l     d4,step       ; Anzahl der For/Backstep d4
               subq.l     #6,d1
               move.l     d1,von        ; neue Anfangsposition
               lea.l      bbis,a4
               lea.l      bis,a3
               move.l     (a4),(a3)     ; neue Endposition
               move.b     #0,(a5)       ; cross-forplay
               btst       #0,d3         ; loop ?
               bne        ip_backp224
iendplayp24:   lea.l      playbyte,a4
               move.l     #1,8(a4)      ; Breakflag setzen
               clr.w      d0            ; INT-Registerinhalt
               bsr        intbreak      ; Interrupt lîschen
iendplayp242:  movem.l    (sp)+,d0-d7/a0-a6
               rte        
iplooptstp24:  btst       #0,d3
               beq.s      iendplayp24
               lea.l      von(pc),a4
               lea.l      bvon(pc),a3
               move.l     (a3),(a4)     ; neue Anfangsposition
               bra        ip_backp224

init_scrub:    lea.l      von(pc),a2
               move.l     (a0)+,(a2)    ; memstart
               lea.l      bbis(pc),a3
               move.l     (a2),(a3)
               lea.l      playbyte(pc),a4         ; RÅckgabewerte-Liste
               move.l     (a2),8(a4)    ; memend
               move.l     #0,(a4)       ; mempos lîschen
               move.l     (a0)+,d0      ; samplerate holen
               move.l     d0,4(a4)      ; samplerate
               lea.l      step(pc),a2
               move.l     #0,(a2)
               lea.l      fifo(pc),a2
               move.l     #lfifo,d0
               asr.w      #3,d0
               btst       #0,modr24
               beq.s      iniscrub2
               asr.w      #1,d0
iniscrub2:     subq.l     #1,d0
               move.l     d0,(a2)       ; fifolen  (len/2/4-1) bei 8192Byte=$3FF d2
               lea.l      pimode(pc),a2
               move.l     #27,(a2)
               move.l     $4ba,d6       ; 200hz-timer
               lea.l      time(pc),a5
               move.l     d6,(a5)       ; zeit sichern
               move.l     a4,d0
               rts        
iscruberrs:    move.l     #-1,d0
               rts        

cblmode:       lea.l      cblm(pc),a1
               move.w     (a0)+,d2      ; cblstatus
               cmpi.w     #-1,d2
               beq.s      getcblm
               tst.w      d2
               blt.s      cblerr
               cmpi.w     #1,d2
               bgt.s      cblerr
               move.w     d2,(a1)
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               bclr       #4,d1
               bclr       #2,d1         ; digmode resetten
               bclr       #3,d1         ; playmode 128bit resetten
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               tst.w      d2
               bne.s      cblja
               move.w     #0,montrack2  ; montrack resetten
               bsr        pushaesr
               bra.s      cblweg
cblja:         bset       #4,d1
               move.b     d1,(a1)
               move.b     d1,$c0(a6)
               move.b     d1,$c0(a6)
cblweg:        clr.l      d0
               rts        
cblerr:        move.l     #-1,d0
               rts        
getcblm:       clr.l      d0
               move.w     (a1),d0
               rts        

init_cbl:      lea.l      rimode(pc),a2
               move.l     #24,(a2)
               lea.l      cblbits,a2
               move.l     a2,d0
               rts        

recmode:       move.w     (a0)+,d2
recmode2:      cmpi.w     #-1,d2
               beq        getrmode
               tst.w      d2
               blt        rmerr
               cmpi.w     #1,d2
               bgt        rmerr
               lea.l      recmod(pc),a3
               move.w     d2,(a3)
               lea.l      dsppath2(pc),a3
               move.b     (a3),d3
               bclr       #3,d3
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      playmod(pc),a4
               move.w     (a4),d4       ; playmode
qconvm2:       cmpi.w     #1,d2         ; recmode ist Vierkanal ?
               beq.s      norconvm      ; ja, dann kein convert
               cmpi.w     #2,d4         ; playmode ist 128 Bit?
               blt.s      norconvm      ; nein, dann raus
doconvm:       bset       #3,d3         ; convert einschalten
norconvm:      move.b     d3,(a3)
               move.b     d3,$214(a6)   ; convertmode setzen
               lea.l      aesreg(pc),a1
               move.b     (a1),d1
               move.w     #4,d0
               bsr        matoutsel     ; zur Vierkanalauswahl
               lea.l      matin(pc),a2
               move.w     matout,d7
               lsl.w      #1,d7
               subq.w     #2,d7
               move.w     0(a2,d7.w),d0
               andi.w     #3,d0
               lea.l      dspreg(pc),a5
               move.b     (a5),d5
               andi.w     #$fc,d5
               add.w      d0,d5
               bclr       #0,d5
               move.b     d5,(a5)
               move.b     d5,$80(a6)    ; rec4-mode loeschen
               move.w     d5,d0
               andi.w     #3,d0
               move.w     d0,0(a2,d7.w)
               cmpi.w     #1,d2         ; recmode ist Vierkanal ?
               beq.s      norconv3
               cmpi.w     #1,d4         ; playmode ist Vierkanal ?
               beq.s      rmweg         ; dann raus
               move.w     #1,d0
               bsr        matoutsel     ; zur DMAREC auswahl
               lea.l      matin(pc),a2
               move.w     matout,d7
               lsl.w      #1,d7
               subq.w     #2,d7
               move.w     0(a2,d7.w),d0
               andi.w     #3,d0
               lea.l      dspreg(pc),a5
               move.b     (a5),d5
               andi.w     #$fc,d5
               add.w      d0,d5
               move.b     d5,(a5)
               move.b     d5,$80(a6)    ; in normalmode (nicht vierkanalmode)
               bra.s      rmweg
norconv3:      bclr       #3,d1         ; dann play128 modus entfernen
               move.b     d1,$c0(a6)
               move.b     d1,(a1)
               move.w     #0,montrack2  ; alten montrack-wert aktualisieren
               bset       #0,d5         ; vierkanal recording an
norconv5:      move.b     d5,(a5)
               move.b     d5,$80(a6)
               andi.w     #3,d5
               move.w     d5,0(a2,d7.w)
rmweg:         bsr        adc8tst
               clr.l      d0
               rts        
rmerr:         move.l     #-1,d0
               rts        
getrmode:      clr.l      d0
               lea.l      recmod(pc),a3
               move.w     (a3),d0
               rts        

dspmem:        lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dspm(pc),a5
               lea.l      dsppdat(pc),a1
               move.b     (a1),d1
               move.w     (a0)+,d2
               cmpi.w     #-1,d2
               beq.s      getdspmem
               move.w     d2,(a5)
               tst.w      d2
               beq.s      dmem0
               cmpi.w     #1,d2
               beq.s      dmem1
               move.l     #-1,d0
               rts        
dmem0:         bclr       #2,d1
               move.b     d1,(a1)
               move.b     d1,$240(a6)
               bra.s      dmweg
dmem1:         bset       #2,d1
               move.b     d1,(a1)
               move.b     d1,$240(a6)
dmweg:         clr.l      d0
               rts        
getdspmem:     clr.l      d0
               move.w     (a5),d0
               rts        


clkdivide:     lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      clkdiv(pc),a1
               move.w     (a0)+,d2
               cmpi.w     #-1,d2
               beq.s      getclkdiv
               tst.w      d2
               blt.s      clkderr
               cmpi.w     #15,d2
               bgt.s      clkderr
               move.b     d2,(a1)
               move.b     d2,$242(a6)
               clr.l      d0
               rts        
clkderr:       move.l     #-1,d0
               rts        
getclkdiv:     clr.l      d0
               move.b     (a1),d0
               rts        

pathset:       lea.l      dpathw(pc),a2
               lea.l      vmestart(pc),a6
               movea.l    (a6),a6
               lea.l      dsppath1(pc),a1
               move.w     (a0)+,d2
               cmpi.w     #-1,d2
               beq.s      getpath
               tst.w      d2
               blt.s      patherr
               cmpi.w     #15,d2
               bgt.s      patherr
               move.w     d2,(a2)
               move.w     d2,d3
               andi.w     #7,d2
               move.b     (a1),d0
               andi.b     #$f8,d0
               add.b      d2,d0
               move.b     d0,(a1)
               move.b     d0,$210(a6)
               asr.w      #3,d3
               andi.w     #1,d3
               lea.l      dsppath2(pc),a1
               move.b     (a1),d0
               andi.b     #$fe,d0
               add.b      d3,d0
               move.b     d0,(a1)
               move.b     d0,$214(a6)
               clr.l      d0
               rts        
patherr:       move.l     #-1,d0
               rts        
getpath:       clr.l      d0
               move.w     (a2),d0
               rts        

getdevadr:     lea.l      devcolist,a1
               move.l     a1,d0
               rts        

getdevco:      lea.l      devconr(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        

getfalcxadr:   lea.l      falcxlist,a1
               move.l     a1,d0
               rts        

getfalcxnr:    lea.l      falcxnr(pc),a1
               clr.l      d0
               move.w     (a1),d0
               rts        

devcountreset: move.w     #0,devconr
               rts        

falcxnreset:   move.w     #0,falcxnr
               rts        

falcxmode:     lea.l      falcxmov(pc),a1
               move.w     (a0)+,d1
               cmpi.w     #-1,d1
               beq.s      getfalcxm
               move.w     d1,(a1)
               clr.l      d0
               rts        
getfalcxm:     clr.l      d0
               move.w     (a1),d0
               rts        

mtc_mode:      lea.l      mtcmod(pc),a2
               move.w     (a0)+,d7      ; mtc-modus
               cmpi.w     #-1,d7
               beq.s      getmtcm
               tst.w      d7
               beq.s      mtcm2
               cmpi.w     #1,d7
               beq.s      mtcm2
               move.l     #-1,d0
               rts        
mtcm2:         move.w     d7,(a2)
               clr.l      d0
               rts        
getmtcm:       clr.l      d0
               move.w     (a2),d0
               rts        

mtc_wait:      move.l     (a0)+,d6      ; wait to frames
               lea.l      framediv(pc),a2
               move.w     (a0)+,d7      ; frames/sec
               move.w     d7,(a2)
               bsr        mtc_clr
mtcw2:         movem.l    d6/d7,-(sp)
mtcw3:         move.w     #2,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               tst.l      d0
               bne.s      mtc_break
               move.w     #3,-(sp)
               move.w     #1,-(sp)
               trap       #13
               addq.l     #4,sp
               tst.l      d0
               beq.s      mtcw3
               move.w     #3,-(sp)
               move.w     #2,-(sp)
               trap       #13
               addq.l     #4,sp
               move.l     (sp)+,d6
               bsr        mtc_tim2
               move.l     (sp)+,d7
               btst       #31,d0
               beq.s      mtcw2
               bclr       #31,d0
               cmp.l      d6,d0
               blt.s      mtcw2
               sub.l      d6,d0
               cmpi.l     #10,d0
               bgt.s      mtcw2
               clr.l      d0
               rts        
mtc_break:     move.l     (sp)+,d6
               move.l     (sp)+,d7
               clr.l      d0
               rts        

mtc_time:      lea.l      framediv(pc),a2
               move.w     (a0)+,d7      ; frames/sec
               move.w     d7,(a2)
mtc_tim2:      lea.l      mtclist(pc),a5
               clr.l      d0
               move.b     (a5)+,d0
               move.b     (a5)+,d1
               lsl.b      #4,d1
               add.b      d1,d0         ; ms frames
               clr.l      d1
               move.b     (a5)+,d1
               move.b     (a5)+,d2
               lsl.b      #4,d2
               add.b      d2,d1
               mulu.w     d7,d1
               add.l      d1,d0         ; sekundenframes dazu
               clr.l      d1
               move.b     (a5)+,d1
               move.b     (a5)+,d2
               lsl.b      #4,d2
               add.b      d2,d1
               mulu.w     d7,d1
               mulu.w     #60,d1
               add.l      d1,d0         ; minutenframes dazu
               clr.l      d1
               move.b     (a5)+,d1
               move.b     (a5),d2
               btst       #7,d2         ; Kennung
               beq.s      mtc_tim3
               bset       #31,d0        ; Kennung einfÅgen
               lsl.b      #4,d2
               add.b      d2,d1
               mulu.w     d7,d1
               mulu.w     #60,d1
               mulu.w     #60,d1
               add.l      d1,d0         ; stundenframes dazu
               lea.l      frames(pc),a2
               move.l     d0,(a2)
               move.b     (a5),d2
               bclr       #7,d2
               move.b     d2,(a5)
               rts        
mtc_tim3:      lsl.b      #4,d2
               add.b      d2,d1
               mulu.w     d7,d1
               mulu.w     #60,d1
               mulu.w     #60,d1
               add.l      d1,d0         ; stundenframes dazu
               lea.l      frames(pc),a2
               move.l     d0,(a2)
               rts        

mtc_clr:       movem.l    d1-d7/a0-a6,-(sp)
               lea.l      frames(pc),a2
               clr.l      d0
               move.l     d0,(a2)
               lea.l      mtclist(pc),a6
               move.l     #-1,(a6)
               move.l     #-1,4(a6)
               move.b     d0,7(a6)
               movem.l    (sp)+,d1-d7/a0-a6
               clr.l      d0
               rts        

int_midi:      lea.l      midisprung,a1
               movea.l    (a1),a1
               jsr        (a1)
               move.w     mtcmod(pc),d6 ; mtc-modus
               cmpi.w     #1,d6
               beq.s      intmidi2
               rts        
intmidi2:      lea.l      mword(pc),a5
               cmpi.b     #$f1,d0
               bne.s      miditst
               move.b     d0,(a5)
               rts        
miditst:       move.b     (a5),d1
               cmpi.b     #$f1,d1
               bne.s      miditst2
               move.w     d0,d2
               move.b     d2,d1
               lsr.b      #4,d1
               andi.w     #7,d1         ; locator
               andi.b     #$f,d2        ; wert
               cmpi.b     #7,d1
               bne.s      nomiwo7
               andi.b     #1,d2
               bset       #7,d2         ; Kennung
nomiwo7:       lea.l      mtclist(pc),a6
               move.b     d2,0(a6,d1.w)
miditst2:      clr.w      (a5)
intmiex:       rts        

getfclocks:    lea.l      srcclk(pc),a1
               move.w     (a1),d0
               swap.w     d0
               lea.l      prescale(pc),a1
               move.w     (a1),d0
               rts        

none:          rts        

analyser:      lea.l      prgemul(pc),a2
               move.w     (a0)+,d7      ; Analyser-Emulationsmode
               tst.w      d7
               beq.s      del_analyse
               move.w     (a2),d7
               bset       #0,d7
               move.w     d7,(a2)
               rts        
del_analyse:   move.w     (a2),d7
               bclr       #0,d7
               move.w     d7,(a2)
               rts        

getsrp:        movea.l    (a0)+,a0
               bsr        pmovefromsrp
               rts        
pmovefromsrp:  .DC.w $f010              ; gets srp to (a0)+
               .DC.w $4a00
               rts        

getcrp:        movea.l    (a0)+,a0
               bsr        pmovefromcrp
               rts        
pmovefromcrp:  .DC.w $f010              ; gets crp to (a0)+
               .DC.w $4e00
               rts        

gettc:         movea.l    (a0)+,a0
               bsr        pmovefromtc
               rts        
pmovefromtc:   .DC.w $f010              ; gets tc to (a0)+
               .DC.w $4200
               rts        

putcrp:        movea.l    (a0)+,a0
               bsr        pmovetocrp
               rts        
pmovetocrp:    .DC.w $f010              ; puts crp from (a0)+
               .DC.w $4c00
               rts        

puttc:         movea.l    (a0)+,a0
               bsr        pmovetotc
               rts        
pmovetotc:     .DC.w $f010              ; puts tc from (a0)+
               .DC.w $4000
               rts        

pflusha:       .DC.w $f008
               .DC.w $2400
               rts        

getmmucode:    lea.l      mmucode,a0
               move.l     a0,d0
               rts        

installed:     move.l     #$71273800,d0 ;magic
               rts        

copyright:     lea.l      vtxt,a0       ;Copyright-Text
               move.l     a0,d0
               rts        

spassthru:     .DC.b "_START RING 0000 0000 0000 DSP56000 5.3.2",13,10
               .DC.b "_DATA P 0000",13,10
               .DC.b "0C0040",13,10
               .DC.b "_DATA P 000C",13,10
               .DC.b "0BF080 000067 0BF080 000067 0BF080 000075 0BF080 000075",13,10
               .DC.b "_DATA P 0040",13,10
               .DC.b "08F4BE 000000 0003F8 0500BB 0500BA 364000 05F426 FFFFFF",13,10
               .DC.b "_DATA P 0048",13,10
               .DC.b "08F4A1 000000 08F4A3 000000 08F4AC",13,10
passthru24:    .DC.b "004000 08F4AD 00F200",13,10
               .DC.b "08F4BF 003000 08F4A1 00FFE8 00FCB8 65F400 005000 657000",13,10
               .DC.b "000060 64F400 004000 647000 000061 05F424 001FFF 05F425",13,10
               .DC.b "001FFF 2E0000 000000 000000 567000 000050 0C0066 655E00",13,10
               .DC.b "65F000 000060 0AAEA1 000072 000000 085DEF 657000 000060",13,10
               .DC.b "65FE00 000004 0865AF 65FE00 000004 645E00 455E00 565E00",13,10
               .DC.b "64F000 000061 0AAEA1 00009A 000000 08DCEF 647000 000061",13,10
               .DC.b "45F400 005000 228E00 200065 0AF0A2 00008B 2E0100 000000",13,10
               .DC.b "000000 567000 000050 45F400 004000 228E00 200065 0AF0A2",13,10
               .DC.b "000096 2E0000 000000 000000 567000 000050 56FE00 45FE00",13,10
               .DC.b "64FE00 000004 08E4AF 0C0096",13,10
               .DC.b "_END 0000",13,10
epassthru:     .EVEN 

sdsprec2:      .DC.b "_START RING4 0000 0000 0000 DSP56000 5.3.2",13,10
               .DC.b "_DATA P 0000",13,10
               .DC.b "0C0040",13,10
               .DC.b "_DATA P 000C",13,10
               .DC.b "0BF080 00006F 0BF080 00006F 0BF080 0000CC 0BF080 0000CC",13,10
               .DC.b "_DATA P 0020",13,10
               .DC.b "0BF080 0000AF 0BF080 0000D9 0BF080 0000DA 0BF080 0000E6",13,10
               .DC.b "_DATA P 0040",13,10
               .DC.b "08F4BE 000000 0003F8 08F4A0 000001 0500BB 364000 05F426",13,10
               .DC.b "FFFFFF 0502BA 08F4A1 000000 08F4A3 000000 08F4AC",13,10
dsprec24:      .DC.b "004000",13,10
               .DC.b "08F4AD 00F200 08F4BF 003800 08F4A1 00FFE8 310000 617000",13,10
               .DC.b "000053 617000 000054 65F400 004000 657000 000050 64F400",13,10
               .DC.b "004000 647000 000051 05F424 001FFF 05F425 001FFF 2E0000",13,10
               .DC.b "567000 000052 000000 08F4A8 000005 00FCB8 0C006E 655E00",13,10
               .DC.b "455E00 565E00 575E00 084F2F 56F000 000053 250000 000000",13,10
               .DC.b "000000 200065 0AF0AA 0000AA 65F000 000050 0AAEA1 0000A6",13,10
               .DC.b "000000 5F5D00 657000 000050 577000 000055 45F400 005000",13,10
               .DC.b "22AE00 200065 0AF0A2 00008F 2E0100 0AF080 000098 45F400",13,10
               .DC.b "004000 22AE00 200065 0AF0A2 0000A1 2E0000 000000 000000",13,10
               .DC.b "567000 000052 56F000 000053 08CE2B 250100 200060 567000",13,10
               .DC.b "000053 57FE00 56FE00 45FE00 65FE00 000004 576500 577000",13,10
               .DC.b "000056 0C00A1 0AAEA1 0000A7 577000 000055 0C00A1 455E00",13,10
               .DC.b "645E00 565E00 084E2B 64F000 000051 000000 56F000 000054",13,10
               .DC.b "250000 200065 0AF0A2 0000C2 08E4AB 250100 457000 000054",13,10
               .DC.b "0AF080 0000C6 08DCEB 250000 457000 000054 647000 000051",13,10
               .DC.b "56FE00 64FE00 45FE00 000004 455E00 0AAEA1 0000D5 000000",13,10
               .DC.b "45F000 000055 08C52F 45FE00 000004 45F000 000056 08C52F",13,10
               .DC.b "0C00D3 000004 615E00 61F400 004000 617000 000050 617000",13,10
               .DC.b "000051 310000 617000 000053 61FE00 000004 615E00 310100",13,10
               .DC.b "617000 000053 310000 617000 000054 61FE00 000004",13,10
               .DC.b "_END 0000",13,10
edsprec2:      .EVEN 

sdsprec4:      .DC.b "_START DSPREC2 0000 0000 0000 DSP56000 5.3.2",CR,LF
               .DC.b "_DATA P 0000",CR,LF
               .DC.b "0C0080",CR,LF
               .DC.b "_DATA P 000C",CR,LF
               .DC.b "0BF080 0000B1 0BF080 0000B1 0BF080 000141 0BF080 000141",CR,LF
               .DC.b "_DATA P 0020",CR,LF
               .DC.b "0BF080 000124 0BF080 00014E 0BF080 00014F 0BF080 00015B",CR,LF
               .DC.b "0BF080 000164",CR,LF
               .DC.b "_DATA P 0040",CR,LF
               .DC.b "0BF080 000174 0BF080 000188",CR,LF
               .DC.b "_DATA P 0080",CR,LF
               .DC.b "08F4BE 000000 0003F8 08F4A0 000001 0500BB 364000 05F426",CR,LF
               .DC.b "FFFFFF 0502BA 08F4A1 000000 08F4A3 000000 08F4AC",CR,LF
recfour24:     .DC.b "004000",CR,LF
               .DC.b "08F4AD 00F200 08F4BF 003800 08F4A1 00FFE8 310000 617000",CR,LF
               .DC.b "00005C 617000 00005D 65F400 004000 657000 000059 64F400",CR,LF
               .DC.b "004000 647000 00005A 05F424 0003FF 05F425 0003FF 67F400",CR,LF
               .DC.b "000054 2E0000 567000 00005B 000000 08F4A8 000005 00FCB8",CR,LF
               .DC.b "0C00B0 655E00 455E00 565E00 575E00 084F2F 56F000 00005C",CR,LF
               .DC.b "250000 000000 000000 200065 0AF0AA 00010E 65F000 000059",CR,LF
               .DC.b "0AAEA1 0000F9 000000 0A67A0 0000CB 62F400 000056 21E700",CR,LF
               .DC.b "46E200 2000B8 20003A 5F5D00 657000 000059 62F400 000051",CR,LF
               .DC.b "000000 000000 44E200 20004D 0AF0AF 0000D7 576200 577000",CR,LF
               .DC.b "00005E 45F400 004200 22AE00 200065 0AF0A2 0000E2 2E0100",CR,LF
               .DC.b "0AF080 0000EB 45F400 004000 22AE00 200065 0AF0A2 0000F4",CR,LF
               .DC.b "2E0000 000000 000000 567000 00005B 56F000 00005C 08CE2B",CR,LF
               .DC.b "250100 200060 567000 00005C 57FE00 56FE00 45FE00 65FE00",CR,LF
               .DC.b "000004 0A67A0 000101 62F400 000055 21E700 46E200 2000B8",CR,LF
               .DC.b "20003A 576500 62F400 000050 000000 000000 44E200 20004D",CR,LF
               .DC.b "0AF0AF 00010B 576200 577000 00005F 0C00F4 0AAEA1 0000F9",CR,LF
               .DC.b "0A67A0 000118 62F400 000056 21E700 46E200 2000B8 20003A",CR,LF
               .DC.b "62F400 000051 000000 000000 44E200 20004D 0AF0AF 000121",CR,LF
               .DC.b "576200 577000 00005E 0C00F4 455E00 645E00 565E00 084E2B",CR,LF
               .DC.b "64F000 00005A 000000 56F000 00005D 250000 200065 0AF0A2",CR,LF
               .DC.b "000137 08E4AB 250100 457000 00005D 0AF080 00013B 08DCEB",CR,LF
               .DC.b "250000 457000 00005D 647000 00005A 56FE00 64FE00 45FE00",CR,LF
               .DC.b "000004 455E00 0AAEA1 00014A 000000 45F000 00005E 08C52F",CR,LF
               .DC.b "45FE00 000004 45F000 00005F 08C52F 0C0148 000004 615E00",CR,LF
               .DC.b "61F400 004000 617000 000059 617000 00005A 310000 617000",CR,LF
               .DC.b "00005C 61FE00 000004 615E00 310100 617000 00005C 310000",CR,LF
               .DC.b "617000 00005D 61FE00 000004 565E00 605E00 60F400 000050",CR,LF
               .DC.b "000000 060280 000170 0AA981 00016B 56E000 08CE2B 2E0000",CR,LF
               .DC.b "565800 60FE00 56FE00 000004 565E00 605E00 000000 60F400",CR,LF
               .DC.b "000055 0AA980 000179 084E2B 000000 000000 565800 0AA980",CR,LF
               .DC.b "00017F 084E2B 000000 000000 566000 60FE00 56FE00 000004",CR,LF
               .DC.b "565E00 605E00 000000 60F400 000054 0AA980 00018D 084E2B",CR,LF
               .DC.b "000000 000000 565800 60FE00 56FE00 000004",CR,LF
               .DC.b "_DATA X 0050",CR,LF
               .DC.b "000000 000000 000000 000000 000000 3FFF00 3FFF00 3FFF00",CR,LF
               .DC.b "3FFF00",CR,LF
               .DC.b "_END 0000",CR,LF
edsprec4:      .EVEN 

sdspplay2:     .DC.b "_START DSPPLAY 0000 0000 0000 DSP56000 5.3.2",CR,LF
               .DC.b "_DATA P 0000",CR,LF
               .DC.b "0C0080",CR,LF
               .DC.b "_DATA P 000C",CR,LF
               .DC.b "0BF080 0000BC 0BF080 0000BC 0BF080 0000C0 0BF080 0000C0",CR,LF
               .DC.b "_DATA P 0020",CR,LF
               .DC.b "0BF080 00011C 0BF080 00014D 0BF080 00014E 0BF080 000164",CR,LF
               .DC.b "0BF080 000165",CR,LF
               .DC.b "_DATA P 0040",CR,LF
               .DC.b "0BF080 000175 0BF080 000189",CR,LF
               .DC.b "_DATA P 0080",CR,LF
               .DC.b "08F4BE 000000 0003F8 08F4A0 000001 0500BB 364000 05F426",CR,LF
               .DC.b "FFFFFF 0502BA 08F4A1 000000 08F4A3 000000 08F4AC",CR,LF
dspplay24:     .DC.b "004000",CR,LF
               .DC.b "08F4AD 00F200 08F4BF 003800 08F4A1 00FFE8 67F400 000054",CR,LF
               .DC.b "310000 617000 00005C 617000 00005D 65F400 004000 657000",CR,LF
               .DC.b "000059 64F400 004000 647000 00005A 05F424 000FFF 05F425",CR,LF
               .DC.b "000FFF 200013 000000 000000 567000 00005B 000000 0AA980",CR,LF
               .DC.b "0000B5 084E2B 000000 000000 0C00AF 08F4A8 000005 00FCB8",CR,LF
               .DC.b "56F400 000001 08CE2B 0C00BB 575E00 084F2F 57FE00 000004",CR,LF
               .DC.b "625E00 645E00 455E00 565E00 56F000 00005C 45F400 000001",CR,LF
               .DC.b "200065 0AF0A7 0000D0 45F400 000000 08C52F 0AF080 000104",CR,LF
               .DC.b "64F000 00005A 0AAEA1 000109 000000 5EDC00 0A67A0 0000DE",CR,LF
               .DC.b "62F400 000056 21C700 46E200 2000B0 200032 62F400 000051",CR,LF
               .DC.b "000000 44E200 200045 0AF0AF 0000E6 566200 08CE2F 647000",CR,LF
               .DC.b "00005A 45F400 004800 228E00 200065 0AF0A2 0000F7 56F400",CR,LF
               .DC.b "000001 000000 567000 00005B 56F000 00005C 08CE2B 45F400",CR,LF
               .DC.b "004000 228E00 200065 0AF0A2 000104 200013 000000 567000",CR,LF
               .DC.b "00005B 56F400 000001 08CE2B 56FE00 45FE00 64FE00 62FE00",CR,LF
               .DC.b "000004 56E400 0A67A0 000112 62F400 000055 21C700 46E200",CR,LF
               .DC.b "2000B0 200032 62F400 000050 000000 44E200 200045 0AF0AF",CR,LF
               .DC.b "00011A 566200 08CE2F 0C0104 455E00 565E00 65F000 000059",CR,LF
               .DC.b "000000 56F000 00005D 45F400 000000 200065 0AF0A2 00012F",CR,LF
               .DC.b "45F400 000001 457000 00005D 0865AB 0AF080 00014A 085DEB",CR,LF
               .DC.b "657000 000059 45F400 000000 457000 00005D 22AE00 45F400",CR,LF
               .DC.b "0007FF 200066 45F400 000000 200065 0AF0A2 00014A 56F000",CR,LF
               .DC.b "00005C 45F400 000001 200060 567000 00005C 200065 0AF0A2",CR,LF
               .DC.b "00014A 08CE2B 56FE00 45FE00 000004 000004 615E00 565E00",CR,LF
               .DC.b "310000 617000 00005C 617000 00005D 61F400 004000 617000",CR,LF
               .DC.b "000059 617000 00005A 05F424 000FFF 05F425 000FFF 200013",CR,LF
               .DC.b "000000 08CE2B 56FE00 61FE00 000004 565E00 605E00 60F400",CR,LF
               .DC.b "000050 000000 060280 000171 0AA981 00016C 56E000 08CE2B",CR,LF
               .DC.b "200013 565800 60FE00 56FE00 000004 565E00 605E00 000000",CR,LF
               .DC.b "60F400 000055 0AA980 00017A 084E2B 000000 000000 565800",CR,LF
               .DC.b "0AA980 000180 084E2B 000000 000000 566000 60FE00 56FE00",CR,LF
               .DC.b "000004 565E00 605E00 000000 60F400 000054 0AA980 00018E",CR,LF
               .DC.b "084E2B 000000 000000 565800 60FE00 56FE00 000004",CR,LF
               .DC.b "_DATA X 0050",CR,LF
               .DC.b "000000 000000 000000 000000 000000 3FFF00 3FFF00 3FFF00",CR,LF
               .DC.b "3FFF00",CR,LF
               .DC.b "_END 0000",CR,LF
edspplay2:     .EVEN 

sdspplay4:     .DC.b "_START RING3C 0000 0000 0000 DSP56000 5.3.2",13,10
               .DC.b "_DATA P 0000",13,10
               .DC.b "0C0040",13,10
               .DC.b "_DATA P 000C",13,10
               .DC.b "0BF080 000083 0BF080 000083 0BF080 000085 0BF080 000085",13,10
               .DC.b "_DATA P 0020",13,10
               .DC.b "0BF080 00009F 0BF080 0000A7 0BF080 0000A8",13,10
               .DC.b "_DATA P 0040",13,10
               .DC.b "08F4BE 000000 0003F8 08F4A0 000001 0500BB 364000 05F426",13,10
               .DC.b "FFFFFF 0502BA 08F4A1 000000 08F4A3 000000 08F4AC",13,10
playfour24:    .DC.b "004000",13,10
               .DC.b "08F4AD 00F200 08F4BF 003800 08F4A1 00FFE8 200013 567000",13,10
               .DC.b "000050 2E0100 567000 000051 65F400 004000 05F425 0003FF",13,10
               .DC.b "64F400 004000 05F424 0003FF 61F400 005000 05F421 0007FF",13,10
               .DC.b "47F400 0007FF 08F4A8 000005 00FCB8 56F000 000051 200003",13,10
               .DC.b "0E206D 060082 000078 56D900 57D900 45D900 45D960 566568",13,10
               .DC.b "5F5D00 56F000 000050 250100 457060 000051 567065 000050",13,10
               .DC.b "0E206D 08CE2B 0C006D 08462F 000004 565E00 56F000 000050",13,10
               .DC.b "240100 200045 0AF0A7 000090 200013 08CE2F 0AF080 00009B",13,10
               .DC.b "0AAEA1 00009D 08DCEF 228E00 44F400 0001FF 200046 200003",13,10
               .DC.b "0AF0A2 00009B 08CE2B 56FE00 000004 08E4AF 0C009B 565E00",13,10
               .DC.b "0859AB 222E00 200076 567000 000051 56FE00 000004 000004",13,10
               .DC.b "565E00 200013 567000 000050 2E0100 567000 000051 65F400",13,10
               .DC.b "004000 64F400 004000 61F400 005000 08CE2B 56FE00 000004",13,10
               .DC.b "_END 0000",13,10
edspplay4:     .EVEN 

sdspplay8:     .DC.b "_START RING5 0000 0000 0000 DSP56000 5.3.2",13,10
               .DC.b "_DATA P 0000",13,10
               .DC.b "0C0040",13,10
               .DC.b "_DATA P 000C",13,10
               .DC.b "0BF080 000096 0BF080 000096 0BF080 000098 0BF080 000098",13,10
               .DC.b "_DATA P 0020",13,10
               .DC.b "0BF080 0000B2 0BF080 0000BA 0BF080 0000BB",13,10
               .DC.b "_DATA P 0040",13,10
               .DC.b "08F4BE 000000 0003F8 08F4A0 000001 0500BB 364000 05F426",13,10
               .DC.b "FFFFFF 0502BA 08F4A1 000000 08F4A3 000000 08F4AC",13,10
playeight24:   .DC.b "004000",13,10
               .DC.b "08F4AD 00F200 08F4BF 003800 08F4A1 00FFE8 200013 567000",13,10
               .DC.b "000050 2E0100 567000 000051 65F400 004000 05F425 0003FF",13,10
               .DC.b "64F400 004000 05F424 0003FF 61F400 006000 05F421 000FFF",13,10
               .DC.b "47F400 000FFF 08F4A8 000005 00FCB8 56F000 000051 200003",13,10
               .DC.b "0E206D 060082 00008B 56D900 57D900 45D900 45D960 200022",13,10
               .DC.b "200022 566568 20002A 20002A 5F6500 56D900 57D900 45D900",13,10
               .DC.b "200060 200022 200022 45E500 200060 45D900 566568 20002A",13,10
               .DC.b "20002A 4DE500 200068 5F5D00 56F000 000050 250100 457060",13,10
               .DC.b "000051 567065 000050 0E206D 08CE2B 0C006D 08462F 000004",13,10
               .DC.b "565E00 56F000 000050 240100 200045 0AF0A7 0000A3 200013",13,10
               .DC.b "08CE2F 0AF080 0000AE 0AAEA1 0000B0 08DCEF 228E00 44F400",13,10
               .DC.b "0001FF 200046 200003 0AF0A2 0000AE 08CE2B 56FE00 000004",13,10
               .DC.b "08E4AF 0C00AE 565E00 0859AB 222E00 200076 567000 000051",13,10
               .DC.b "56FE00 000004 000004 565E00 200013 567000 000050 2E0100",13,10
               .DC.b "567000 000051 65F400 004000 64F400 004000 61F400 006000",13,10
               .DC.b "08CE2B 56FE00 000004",13,10
               .DC.b "_END 0000",13,10
edspplay8:     .EVEN 

sdspmix8:      .DC.b "_START MIX128 0000 0000 0000 DSP56000 5.3.2",13,10
               .DC.b "_DATA P 0000",13,10
               .DC.b "0C0040",13,10
               .DC.b "_DATA P 000C",13,10
               .DC.b "0BF080 00007E 0BF080 00007E 0BF080 000089 0BF080 000089",13,10
               .DC.b "_DATA P 0040",13,10
               .DC.b "08F4BE 000000 0003F8 0500BB 0500BA 364000 05F426 FFFFFF",13,10
               .DC.b "08F4A1 000000 08F4A3 000000 08F4AC 004700 08F4AD 00F800",13,10
               .DC.b "08F4BF 003000 08F4A1 00FFF8 65F400 002800 05F425 000FFF",13,10
               .DC.b "64F400 002000 05F424 000FFF 45F400 002FF8 22B300 05F423",13,10
               .DC.b "000FFF 00FCB8 22AE00 226666 200055 0EA062 62F400 000050",13,10
               .DC.b "000000 46DA00 47DB00 46DAB0 47DB00 46DAB8 47DB00 46DAB3",13,10
               .DC.b "47DB00 46DABB 47DB00 46DAB3 47DB00 46DABB 47DB00 46DAB3",13,10
               .DC.b "47E300 2000BB 567B00 56DB00 575B00 0C0062 0AAEA3 000082",13,10
               .DC.b "085DAF 000004 565E00 22AE00 200066 21D500 56FE00 085DAF",13,10
               .DC.b "000004 0AAEA2 00008D 08DCAF 000004 575E00 228F00 20006E",13,10
               .DC.b "21F400 000000 57DC00 57FE00 08DCAF 000004",13,10
               .DC.b "_DATA X 0050",13,10
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",13,10
               .DC.b "_END 0000",13,10
edspmix8:      .EVEN 

sdspeff8:      .DC.b "_START MIX128B 0000 0000 0000 DSP56000 5.3.2",13,10
               .DC.b "_DATA P 0000",13,10
               .DC.b "0C0040",13,10
               .DC.b "_DATA P 000C",13,10
               .DC.b "0BF080 00007E 0BF080 00007E 0BF080 00009F 0BF080 00009F",13,10
               .DC.b "_DATA P 0040",13,10
               .DC.b "08F4BE 000000 0003F8 0500BB 0500BA 364000 05F426 FFFFFF",13,10
               .DC.b "08F4A1 000000 08F4A3 000000 08F4AC 004700 08F4AD 00F800",13,10
               .DC.b "08F4BF 003000 08F4A1 00FFF8 65F400 006000 05F425 003FFF",13,10
               .DC.b "64F400 004000 05F424 003FFF 45F400 00FFF8 22B300 05F423",13,10
               .DC.b "003FFF 00FCB8 22AE00 226666 200055 0EA062 62F400 000050",13,10
               .DC.b "000000 46DA00 47DB00 46DAB0 47DB00 46DAB8 47DB00 46DAB3",13,10
               .DC.b "47DB00 46DABB 47DB00 46DAB3 47DB00 46DABB 47DB00 46DAB3",13,10
               .DC.b "47E300 2000BB 567B00 56DB00 575B00 0C0062 0AAEA3 000094",13,10
               .DC.b "565E00 22AE00 44F400 000007 200046 44F400 000001 200045",13,10
               .DC.b "0AF0A2 000091 084E2F 44E522 200040 200022 565D00 56FE00",13,10
               .DC.b "000004 085DAF 56FE00 000004 565E00 22AE00 200066 21D500",13,10
               .DC.b "084E2F 44E522 200040 200022 565D00 56FE00 000004 0AAEA2",13,10
               .DC.b "0000A3 08DCAF 000004 575E00 228F00 20006E 21F400 000000",13,10
               .DC.b "57DC00 57FE00 08DCAF 000004",13,10
               .DC.b "_DATA X 0050",13,10
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",13,10
               .DC.b "_END 0000",13,10
edspeff8:      .EVEN 

extmxdsp:      .DC.b "_START EXTALL4 0000 0000 0000 DSP56000 5.3.2",CR,LF
               .DC.b "_DATA P 0000",CR,LF
               .DC.b "0C0100",CR,LF
               .DC.b "_DATA P 000C",CR,LF
               .DC.b "0BF080 0001D3 0BF080 0001D3 0BF080 000201 0BF080 000201",CR,LF
               .DC.b "_DATA P 0020",CR,LF
               .DC.b "0BF080 00020E 0BF080 000214 0BF080 000215 0BF080 000218",CR,LF
               .DC.b "0BF080 000230",CR,LF
               .DC.b "_DATA P 0040",CR,LF
               .DC.b "0BF080 000244 0BF080 00025C 0BF080 000270",CR,LF
               .DC.b "_DATA P 0100",CR,LF
               .DC.b "08F4BE 000000 0003F8 08F4A0 000001 0502BA 0500BB 66F400",CR,LF
               .DC.b "000400 05F426 FFFFFF 08F4A1 000000 08F4A3 000000 08F4AC",CR,LF
               .DC.b "004700 08F4AD 00F800 08F4BF 003800 08F4A1 00FFE8 65F400",CR,LF
               .DC.b "002800 64F400 002000 45F400 002FF8 22B300 05F420 FFFFFF",CR,LF
               .DC.b "05F421 FFFFFF 05F422 FFFFFF 05F423 000FFF 05F424 000FFF",CR,LF
               .DC.b "05F425 000FFF 05F427 FFFFFF 60F400 0000A6 0AA980 000134",CR,LF
               .DC.b "084E2B 000000 000000 0C012E 08F4A8 000005 00FCB8 22AE00",CR,LF
               .DC.b "226666 200055 0EA137 62F400 000062 61F400 000074 67F400",CR,LF
               .DC.b "000051 47F000 000050 0AC702 00018F 46DA00 635E00 0BF080",CR,LF
               .DC.b "000177 63FE00 000000 47DB00 0BF080 000177 47FB00 635E00",CR,LF
               .DC.b "61F400 0000A6 061080 000155 47FB00 477900 226600 62F400",CR,LF
               .DC.b "000086 0BF080 000161 61F400 000097 0BF080 000161 63FE00",CR,LF
               .DC.b "0C0137 060880 000175 56DA00 44D900 21CF00 47F400 000008",CR,LF
               .DC.b "200076 0AF0AA 000171 20007C 47F43B 000001 20CE78 0AF080",CR,LF
               .DC.b "000172 20CE3B 47D910 21D300 000000 446300 00000C 060880",CR,LF
               .DC.b "00018D 0A5F80 00017F 0BF080 0001CA 0AF080 00018D 47E300",CR,LF
               .DC.b "44D900 46F0B1 000072 200032 21C700 46DAB1 200032 565B00",CR,LF
               .DC.b "47DB45 0AF0AF 00018D 567900 44D900 000000 00000C 46DA00",CR,LF
               .DC.b "060880 0001A6 0A5F80 000198 0BF080 0001C1 0AF080 0001A6",CR,LF
               .DC.b "47E300 44D900 46F0B1 000072 200032 21C700 46DAB1 200032",CR,LF
               .DC.b "565B00 200045 0AF0AF 0001A6 567900 44D900 000000 635E00",CR,LF
               .DC.b "61F400 00009E 060880 0001AE 47FB00 000000 477900 000000",CR,LF
               .DC.b "226600 62F400 000086 060880 0001BD 44D900 57DA00 20CE00",CR,LF
               .DC.b "000000 200010 000000 21D300 000000 446300 000000 63FE00",CR,LF
               .DC.b "0C0137 46DA00 56DB00 44D900 200045 0AF0AF 0001C9 567900",CR,LF
               .DC.b "44D900 00000C 46DA00 56DB00 44D900 47DB45 0AF0AF 0001D2",CR,LF
               .DC.b "567900 44D900 00000C 0AAEA3 0001FA 565E00 455E00 45F000",CR,LF
               .DC.b "000050 000000 0AC507 0001E9 22AE00 45F400 000007 000000",CR,LF
               .DC.b "200066 45F400 000002 000000 200065 0AF0AA 0001ED 0AF0A7",CR,LF
               .DC.b "0001F4 085DAF 45FE00 56FE00 000004 087DAF 56DD00 45F400",CR,LF
               .DC.b "000000 000000 455D00 0C01EA 45F400 000000 000000 455D00",CR,LF
               .DC.b "084E2F 0C01EA 565E00 22AE00 200066 21D500 56FE00 085DAF",CR,LF
               .DC.b "000004 0AAEA2 000205 08DCAF 000004 575E00 228F00 20006E",CR,LF
               .DC.b "21F400 000000 57DC00 57FE00 08DCAF 000004 565E00 56F000",CR,LF
               .DC.b "00FFEB 565800 56FE00 000004 000004 60F400 0000A6 000004",CR,LF
               .DC.b "565E00 575E00 445E00 60F400 0000A6 000000 57D800 000000",CR,LF
               .DC.b "44E000 56F400 000062 000000 200010 000000 21D000 000000",CR,LF
               .DC.b "446000 000000 60F400 0000A6 44FE00 57FE00 56FE00 000004",CR,LF
               .DC.b "565E00 575E00 56F400 000074 57F000 0000A6 000000 200010",CR,LF
               .DC.b "000000 21D000 000000 56E000 08CE2B 2E0000 566000 60F400",CR,LF
               .DC.b "0000A6 57FE00 56FE00 000004 565E00 575E00 445E00 60F400",CR,LF
               .DC.b "0000A6 000000 57D800 000000 44E000 56F400 000086 000000",CR,LF
               .DC.b "200010 000000 21D000 000000 446000 000000 60F400 0000A6",CR,LF
               .DC.b "44FE00 57FE00 56FE00 000004 565E00 575E00 445E00 60F400",CR,LF
               .DC.b "0000A6 56F400 000051 57D800 44E000 200010 000000 21D000",CR,LF
               .DC.b "000000 446000 60F400 0000A6 44FE00 57FE00 56FE00 000004",CR,LF
               .DC.b "445E00 60F400 0000A6 000000 44E000 000000 60F400 000050",CR,LF
               .DC.b "000000 446000 60F400 0000A6 65F400 002800 64F400 002000",CR,LF
               .DC.b "0AC422 00028E 45F400 002FF8 0AC421 00028A 08F4AC 004700",CR,LF
               .DC.b "0AF080 00028C 08F4AC 006700 44FE00 000004 45F400 002FF0",CR,LF
               .DC.b "65F400 002800 64F400 002000 0AC421 000299 08F4AC 004F00",CR,LF
               .DC.b "0C028C 08F4AC 006F00 0C028C",CR,LF
               .DC.b "_DATA X 0050",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000000 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",CR,LF
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",CR,LF
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000001",CR,LF
               .DC.b "000002 000003 000004 000005 000006 000007 000008 000009",CR,LF
               .DC.b "00000A 00000B 00000C 00000D 00000E 00000F 000000 000000",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "_END 0000",CR,LF
xtmxdsp:       .EVEN 

panmxdsp:      .DC.b "_START PANALL4 0000 0000 0000 DSP56000 5.3.2",CR,LF
               .DC.b "_DATA P 0000",CR,LF
               .DC.b "0C0080",CR,LF
               .DC.b "_DATA P 000C",CR,LF
               .DC.b "0BF080 0001B7 0BF080 0001B7 0BF080 0001E5 0BF080 0001E5",CR,LF
               .DC.b "_DATA P 0020",CR,LF
               .DC.b "0BF080 0001F2 0BF080 0001F9 0BF080 0001FA 0BF080 0001FD",CR,LF
               .DC.b "0BF080 000211",CR,LF
               .DC.b "_DATA P 0040",CR,LF
               .DC.b "0BF080 000225 0BF080 000239 0BF080 00024D",CR,LF
               .DC.b "_DATA P 0080",CR,LF
               .DC.b "08F4BE 000000 0003F8 08F4A0 000001 0502BA 0500BB 66F400",CR,LF
               .DC.b "000400 05F426 FFFFFF 08F4A1 000000 08F4A3 000000 08F4AC",CR,LF
               .DC.b "004700 08F4AD 00F800 08F4BF 003800 08F4A1 00FFE8 65F400",CR,LF
               .DC.b "002800 64F400 002000 45F400 002FF8 22B300 05F420 FFFFFF",CR,LF
               .DC.b "05F421 FFFFFF 05F422 FFFFFF 05F423 000FFF 05F424 000FFF",CR,LF
               .DC.b "05F425 000FFF 240000 05F427 FFFFFF 60F400 0000DA 447000",CR,LF
               .DC.b "000050 0AA980 0000B5 084E2B 0C00B1 08F4A8 000005 00FCB8",CR,LF
               .DC.b "65F400 002800 64F400 002000 22B300 0A7008 000050 22AE00",CR,LF
               .DC.b "226666 200055 0EA0BF 62F413 000062 61F41B 0000A6 46DA00",CR,LF
               .DC.b "47F000 000050 000000 0AC728 0000B8 0AC722 0000D2 000000",CR,LF
               .DC.b "0AF080 00014C 635E00 0BF080 000134 226700 63FE00 475E00",CR,LF
               .DC.b "475E00 47DB00 0BF080 000134 63FE00 44D900 0A67A0 0000E3",CR,LF
               .DC.b "21C700 46DAB1 21E732 200045 0AF0AF 0000E8 567900 44D900",CR,LF
               .DC.b "44D900 0A6780 0000ED 0AF080 0000EF 2000B9 20003A 27004D",CR,LF
               .DC.b "0AF0AF 0000F3 577900 46F000 000050 000000 0AC621 000122",CR,LF
               .DC.b "061080 0000FA 477B00 0AC620 00010D 226600 61F400 0000C8",CR,LF
               .DC.b "21C700 56D900 200050 000000 21D300 000000 475B00 000000",CR,LF
               .DC.b "47DB00 000000 576300 0AF080 000132 565B00 21C700 46F400",CR,LF
               .DC.b "008000 2000B0 505B00 260000 465B00 465B00 465B00 465B00",CR,LF
               .DC.b "465B00 465B00 575B00 21E700 46F400 008000 2000B0 505B00",CR,LF
               .DC.b "0AF080 000132 477B00 477B00 477B00 477B00 477B00 477B00",CR,LF
               .DC.b "477B00 577B00 477B00 477B00 477B00 477B00 477B00 477B00",CR,LF
               .DC.b "477B00 567B00 63FE00 0C00BF 060880 00014A 44D900 47E300",CR,LF
               .DC.b "565E00 46DAB0 46DA32 47E345 0AF0AF 000140 567900 44D900",CR,LF
               .DC.b "46DAB0 200032 44FE00 47DB40 200011 575E00 46DAB8 47DB3A",CR,LF
               .DC.b "44FE00 200048 200019 00000C 060880 000162 44D900 47E300",CR,LF
               .DC.b "565E00 46DAB0 46DA32 47E345 0AF0AF 000158 567900 44D900",CR,LF
               .DC.b "46DAB0 200032 44FE00 47DB40 200011 575E00 46DAB8 20003A",CR,LF
               .DC.b "44FE00 200048 200019 62F400 0000A2 61F400 0000B6 67F400",CR,LF
               .DC.b "000061 44D900 46DA00 0A67A0 000170 21C700 46DAB1 21E732",CR,LF
               .DC.b "200045 0AF0AF 000175 567900 44D900 44D900 0A6780 00017B",CR,LF
               .DC.b "635E00 0AF080 00017D 635EB9 20003A 27004D 0AF0AF 000181",CR,LF
               .DC.b "577900 46F000 000050 000000 0AC621 0001AD 060880 000188",CR,LF
               .DC.b "477B00 0AC620 00019C 226600 61F400 0000C8 21C700 56D900",CR,LF
               .DC.b "200050 000000 21D300 000000 476300 56E100 200050 21D300",CR,LF
               .DC.b "000000 576300 0AF080 0001B5 565B00 21C700 46F400 008000",CR,LF
               .DC.b "2000B0 505B00 260000 465B00 465B00 575B00 21E700 46F400",CR,LF
               .DC.b "008000 2000B0 505B00 0AF080 0001B5 477B00 477B00 477B00",CR,LF
               .DC.b "577B00 477B00 477B00 477B00 567B00 63FE00 0C00BF 0AAEA3",CR,LF
               .DC.b "0001DE 565E00 455E00 45F000 000050 000000 0AC507 0001CD",CR,LF
               .DC.b "22AE00 45F400 000007 000000 200066 45F400 000002 000000",CR,LF
               .DC.b "200065 0AF0AA 0001D1 0AF0A7 0001D8 085DAF 45FE00 56FE00",CR,LF
               .DC.b "000004 087DAF 56DD00 45F400 000000 000000 455D00 0C01CE",CR,LF
               .DC.b "45F400 000000 000000 455D00 084E2F 0C01CE 565E00 22AE00",CR,LF
               .DC.b "200066 21D500 56FE00 085DAF 000004 0AAEA2 0001E9 08DCAF",CR,LF
               .DC.b "000004 575E00 228F00 20006E 21F400 000000 57DC00 57FE00",CR,LF
               .DC.b "08DCAF 000004 565E00 56F000 00FFEB 000000 565800 56FE00",CR,LF
               .DC.b "000004 000004 60F400 0000DA 000004 565E00 575E00 445E00",CR,LF
               .DC.b "60F400 0000DA 56F400 000062 57D800 44E000 200010 000000",CR,LF
               .DC.b "21D000 000000 446000 60F400 0000DA 44FE00 57FE00 56FE00",CR,LF
               .DC.b "000004 565E00 575E00 56F400 0000A6 57F000 0000DA 000000",CR,LF
               .DC.b "200010 000000 21D000 000000 56E000 08CE2B 2E0000 566000",CR,LF
               .DC.b "60F400 0000DA 57FE00 56FE00 000004 565E00 575E00 445E00",CR,LF
               .DC.b "60F400 0000DA 56F400 0000B8 57D800 44E000 200010 000000",CR,LF
               .DC.b "21D000 000000 446000 60F400 0000DA 44FE00 57FE00 56FE00",CR,LF
               .DC.b "000004 565E00 575E00 445E00 60F400 0000DA 56F400 000051",CR,LF
               .DC.b "57D800 44E000 200010 000000 21D000 000000 446000 60F400",CR,LF
               .DC.b "0000DA 44FE00 57FE00 56FE00 000004 0003F8 445E00 60F400",CR,LF
               .DC.b "0000DA 000000 44E000 000000 0AC468 60F400 000050 000000",CR,LF
               .DC.b "446000 60F400 0000DA 65F400 002800 64F400 002000 22B300",CR,LF
               .DC.b "0AC422 000270 45F400 002FF8 0AC421 00026A 08F4AC 004700",CR,LF
               .DC.b "0AF080 00026C 08F4AC 006700 44FE00 00FCB8 000000 000004",CR,LF
               .DC.b "45F400 002FF0 0AC421 000277 08F4AC 004F00 0C026C 08F4AC",CR,LF
               .DC.b "006F00 0C026C",CR,LF
               .DC.b "_DATA X 0050",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000000 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",CR,LF
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",CR,LF
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",CR,LF
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",CR,LF
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",CR,LF
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",CR,LF
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",CR,LF
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00",CR,LF
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 000000 000000",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000001 000002 000003 000004 000005 000006 000007",CR,LF
               .DC.b "000008 000009 00000A 00000B 00000C 00000D 00000E 00000F",CR,LF
               .DC.b "000000 000001 000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000000",CR,LF
               .DC.b "000000 000000",CR,LF
               .DC.b "_END 0000",CR,LF
xpanmxdsp:     .EVEN 

balmxdsp:      .DC.b "_START BALMIXER",13,10
               .DC.b "_DATA P 0000",13,10
               .DC.b "0C0100",13,10
               .DC.b "_DATA P 000C",13,10
               .DC.b "0BF080 0001FC 0BF080 0001FC 0BF080 000207 0BF080 000207",13,10
               .DC.b "_DATA P 0020",13,10
               .DC.b "0BF080 000214 0BF080 00021E 0BF080 00021F 0BF080 000222",13,10
               .DC.b "0BF080 000242",13,10
               .DC.b "_DATA P 0040",13,10
               .DC.b "0BF080 000256 0BF080 000276",13,10
               .DC.b "_DATA P 0100",13,10
               .DC.b "08F4BE 000000 0003F8 08F4A0 000001 0502BA 0500BB 364000",13,10
               .DC.b "05F426 FFFFFF 08F4A1 000000 08F4A3 000000 08F4AC 004700",13,10
               .DC.b "08F4AD 00F800 08F4BF 003800 08F4A1 00FFE8 65F400 002800",13,10
               .DC.b "05F425 000FFF 64F400 002000 05F424 000FFF 45F400 002FF8",13,10
               .DC.b "22B300 05F423 000FFF 05F420 000FFF 05F427 00FFFF 60F400",13,10
               .DC.b "000073 0AA980 00012F 084E2B 000000 000000 0C0129 08F4A8",13,10
               .DC.b "000005 00FCB8 22AE00 226666 200055 0EA132 62F400 000055",13,10
               .DC.b "61F400 00005F 67F400 000050 47DB00 44D900 0A6780 000143",13,10
               .DC.b "20EE00 0AF080 000146 46DA00 2000B0 200032 46DA45 0AF0AF",13,10
               .DC.b "00014B 567900 44D900 47DB00 0A5F80 000151 20EF00 0AF080",13,10
               .DC.b "000153 2000B8 20003A 44D900 46DA4D 0AF0AF 000159 577900",13,10
               .DC.b "44D900 47DB00 565E00 0A6780 000160 20EE00 0AF080 000162",13,10
               .DC.b "2000B0 200032 44D900 46DA45 0AF0AF 000168 567900 44D900",13,10
               .DC.b "44FE00 200040 200011 47DB00 44D900 575E00 0A5F80 000173",13,10
               .DC.b "20EF00 0AF080 000175 2000B8 20003A 46DA4D 0AF0AF 00017A",13,10
               .DC.b "577900 44D900 44FE00 200048 200019 47DB00 44D900 565E00",13,10
               .DC.b "0A6780 000185 20EE00 0AF080 000187 2000B0 200032 46DA45",13,10
               .DC.b "0AF0AF 00018C 567900 44D900 44FE00 200040 200011 47DB00",13,10
               .DC.b "44D900 575E00 0A5F80 000197 20EF00 0AF080 000199 2000B8",13,10
               .DC.b "20003A 46DA4D 0AF0AF 00019E 577900 44D900 44FE00 200048",13,10
               .DC.b "200019 47DB00 44D900 565E00 0A6780 0001A9 20EE00 0AF080",13,10
               .DC.b "0001AB 2000B0 200032 46DA45 0AF0AF 0001B0 567900 44D900",13,10
               .DC.b "44FE00 200040 200011 47DB00 44D900 575E00 0A5F80 0001BB",13,10
               .DC.b "20EF00 0AF080 0001BD 2000B8 20003A 46DA4D 0AF0AF 0001C2",13,10
               .DC.b "577900 44D900 44FE00 200048 200019 21C700 44D900 0A67A0",13,10
               .DC.b "0001CB 2000B1 200032 46DA45 0AF0AF 0001D0 567900 44D900",13,10
               .DC.b "21E700 44D900 0A67A0 0001D6 2000B9 20003A 20004D 0AF0AF",13,10
               .DC.b "0001DB 577900 44D900 635E00 270000 060880 0001DF 477B00",13,10
               .DC.b "226600 21C700 61F400 000071 000000 000000 56D900 000000",13,10
               .DC.b "000000 200050 000000 000000 21D300 000000 000000 476300",13,10
               .DC.b "56E100 000000 000000 200050 000000 000000 21D300 000000",13,10
               .DC.b "000000 576300 63FE00 0C0132 0AAEA3 000200 085DAF 000004",13,10
               .DC.b "565E00 22AE00 200066 21D500 56FE00 085DAF 000004 0AAEA2",13,10
               .DC.b "00020B 08DCAF 000004 575E00 228F00 20006E 21F400 000000",13,10
               .DC.b "57DC00 57FE00 08DCAF 000004 565E00 000000 000000 56F000",13,10
               .DC.b "00FFEB 000000 000000 565800 56FE00 000004 000004 60F400",13,10
               .DC.b "000073 000004 565E00 575E00 445E00 000000 000000 60F400",13,10
               .DC.b "000073 000000 000000 57D800 000000 000000 44E000 56F400",13,10
               .DC.b "000055 000000 000000 200010 000000 000000 21D000 000000",13,10
               .DC.b "000000 446000 000000 000000 60F400 000073 44FE00 57FE00",13,10
               .DC.b "56FE00 000004 565E00 575E00 56F400 00005F 57F000 000073",13,10
               .DC.b "000000 200010 000000 21D000 000000 56E000 08CE2B 2E0000",13,10
               .DC.b "566000 60F400 000073 57FE00 56FE00 000004 565E00 575E00",13,10
               .DC.b "445E00 000000 000000 60F400 000073 000000 000000 57D800",13,10
               .DC.b "000000 000000 44E000 56F400 000069 000000 000000 200010",13,10
               .DC.b "000000 000000 21D000 000000 000000 446000 000000 000000",13,10
               .DC.b "60F400 000073 44FE00 57FE00 56FE00 000004 565E00 575E00",13,10
               .DC.b "445E00 60F400 000073 56F400 000050 57D800 44E000 200010",13,10
               .DC.b "000000 21D000 000000 446000 60F400 000073 44FE00 57FE00",13,10
               .DC.b "56FE00 000004",13,10
               .DC.b "_DATA X 0050",13,10
               .DC.b "000000 000000 000000 000000 000000 1FFF00 1FFF00 1FFF00",13,10
               .DC.b "1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 1FFF00 000000",13,10
               .DC.b "000000 000000 000000 000000 000000 000000 000000 000000",13,10
               .DC.b "000000 000000 000001 000002 000003 000004 000005 000006",13,10
               .DC.b "000007 000000 000001",13,10
               .DC.b "_END 0000",13,10
xbalmxdsp:     .EVEN 

setdspmxext:   jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               bsr        dspcall1
               lea.l      extmxdsp(pc),a0
               lea.l      xtmxdsp(pc),a2
               bsr        dspcall2
               rts        

setdspmxpan:   jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               bsr        dspcall1
               lea.l      panmxdsp(pc),a0
               lea.l      xpanmxdsp(pc),a2
               bsr        dspcall2
               rts        

setdspmxbal:   jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               bsr        dspcall1
               lea.l      balmxdsp(pc),a0
               lea.l      xbalmxdsp(pc),a2
               bsr        dspcall2
               rts        

setpassthru:   jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               lea.l      passthru24(pc),a6
               move.b     #$34,2(a6)    ; 16bit
               btst       #0,modr24
               beq.s      setpasst2
               move.b     #$36,2(a6)    ; 24bit
setpasst2:     bsr        dspcall1
               lea.l      spassthru(pc),a0
               lea.l      epassthru(pc),a2
               bsr        dspcall2
               rts        

setdsprec2:    jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               lea.l      dsprec24(pc),a6
               move.b     #$34,2(a6)    ; 16bit
               btst       #0,modr24
               beq.s      setdspr2
               move.b     #$36,2(a6)    ; 24bit
setdspr2:      bsr        dspcall1
               lea.l      sdsprec2(pc),a0
               lea.l      edsprec2(pc),a2
               bsr        dspcall2
               rts        

setdsprec4:    jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               lea.l      recfour24(pc),a6
               move.b     #$34,2(a6)    ; 16bit
               btst       #0,modr24
               beq.s      rsetfour2
               move.b     #$36,2(a6)    ; 24bit
rsetfour2:     bsr        dspcall1
               lea.l      sdsprec4(pc),a0
               lea.l      edsprec4(pc),a2
               bsr        dspcall2
               rts        

setdspplay2:   jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               lea.l      dspplay24(pc),a6
               move.b     #$34,2(a6)    ; 16bit
               btst       #0,modr24
               beq.s      psetplay2
               move.b     #$36,2(a6)    ; 24bit
psetplay2:     bsr        dspcall1
               lea.l      sdspplay2(pc),a0
               lea.l      edspplay2(pc),a2
               bsr        dspcall2
               rts        

setdspplay4:   jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               lea.l      playfour24(pc),a6
               move.b     #$34,2(a6)    ; 16bit
               btst       #0,modr24
               beq.s      psetfour2
               move.b     #$36,2(a6)    ; 24bit
psetfour2:     bsr        dspcall1
               lea.l      sdspplay4(pc),a0
               lea.l      edspplay4(pc),a2
               bsr        dspcall2
               rts        

setdspplay8:   jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               lea.l      playeight24(pc),a6
               move.b     #$34,2(a6)    ; 16bit
               btst       #0,modr24
               beq.s      pseteight2
               move.b     #$36,2(a6)    ; 24bit
pseteight2:    bsr        dspcall1
               lea.l      sdspplay8(pc),a0
               lea.l      edspplay8(pc),a2
               bsr        dspcall2
               rts        

setdspmix8:    jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               bsr        dspcall1
               lea.l      sdspmix8(pc),a0
               lea.l      edspmix8(pc),a2
               bsr        dspcall2
               rts        

setdspeff8:    jsr        dspreset
               jsr        dsp_stdinit   ; DSP-Initialize
               bsr        dspcall1
               lea.l      sdspeff8(pc),a0
               lea.l      edspeff8(pc),a2
               bsr        dspcall2
               rts        

dspcall1:      jsr        Dsp_Unlock
;               move.w     #105,-(sp)    ; unlock
;               trap       #14
;               addq.l     #2,sp
               jsr        Dsp_Lock
;               move.w     #104,-(sp)    ; lock
;               trap       #14
;               addq.l     #2,sp
               jsr        Dsp_RequestUniqueAbility
;               move.w     #113,-(sp)    ; ability
;               trap       #14
;               addq.l     #2,sp
               move.w     d0,dummy2
               rts        

dspcall2:      lea.l      recbuf,a1
               jsr        conv_LOD_to_bin
               divu.w     #3,d0
               andi.l     #$ffff,d0
               move.l     d0,dummy
               lea.l      stack,a0
               movea.l    a0,a2
               lea.l      recbuf,a1
               move.l     a1,(a2)+      ; zeiger
               move.l     dummy,(a2)+   ; size
               move.w     dummy2,(a2)+  ; ability
               jsr        Dsp_ExecProg
;               move.w     dummy2,-(sp)  ; ability
;               move.l     dummy,-(sp)   ; size
;               lea.l      recbuf(pc),a1
;               move.l     a1,-(sp)      ; zeiger
;               move.w     #109,-(sp)    ; exec
;               trap       #14
;               adda.l     #12,sp
               clr.l      d0
               move.w     dummy2,d0
               rts        

; ----------------StarTrack--Sprungtabelle-----------------------


Rlist:         .DC.w 96,97,98,99
               .DC.w 100,101,102,103,104,105,106,107,108,109          ; DSP
               .DC.w 110,111,112,113,114,115,116,117,118,119
               .DC.w 120,121,122,123,124,125,126,127

               .DC.w $80,$81,$82,$83,$84,$85,$86,$87,$88,$89
               .DC.w $8a,$8b,$8c,$8d    ; Falcon-XBIOS

Rlistb:        .DC.w myxcall            ; my-XBIOS
               .DC.w 0

falcxlen:      .DC.w 8,8,8,8
               .DC.w 8,12,1,0,0,0,4,4,4,5         ; DSP
               .DC.w 5,4,1,0,0,0,5,1,1,1
               .DC.w 1,0,0,8,8,0,4,8

               .DC.w 0,0,2,5,1,2,1,2,1,2
               .DC.w 2,5,1,2            ; Falcon-XBIOS

; Anmerkung: Beim senden oder lesen des DSP wird nur am Anfang getestet
; ob Sende oder Empfangsbereit. Das mag am Falcon gehen, nicht jedoch am Hades
; da der zu schnell ist. Nachfragen ob okay und gegebenenfalls Ñndern !

R_addr:        .DC.l Dsp_DoBlock        ; tested
               .DC.l Dsp_BlkHandShake   ; tested
               .DC.l Dsp_BlkUnpacked    ; tested
               .DC.l Dsp_InStream       ; tested
               .DC.l Dsp_OutStream      ; tested
               .DC.l Dsp_IOStream       ; hauptteil angesehen,scheint okay,int ?
               .DC.l Dsp_RemoveInterrupts         ; tested
               .DC.l Dsp_GetWordSize    ; tested
               .DC.l Dsp_Lock           ; tested
               .DC.l Dsp_Unlock         ; tested
               .DC.l Dsp_Available      ; tested
               .DC.l Dsp_Reserve        ; tested
               .DC.l Dsp_LoadProg       ; tested
               .DC.l Dsp_ExecProg       ; tested
               .DC.l Dsp_ExecBoot       ; tested
               .DC.l Dsp_LodToBinary    ; tested
               .DC.l Dsp_TriggerHC      ; tested
               .DC.l Dsp_RequestUniqueAbility     ; tested
               .DC.l Dsp_GetProgAbility ; tested
               .DC.l Dsp_FlushSubroutines
               .DC.l Dsp_LoadSubroutine
               .DC.l Dsp_InqSubrAbility
               .DC.l Dsp_RunSubroutine
               .DC.l Dsp_Hf0            ; tested
               .DC.l Dsp_Hf1            ; tested
               .DC.l Dsp_Hf2            ; tested
               .DC.l Dsp_Hf3            ; tested
               .DC.l Dsp_BlkWords       ; tested
               .DC.l Dsp_BlkBytes       ; tested
               .DC.l Dsp_HStat          ; tested
               .DC.l Dsp_SetVectors     ; angesehen, scheint okay
               .DC.l Dsp_MultBlocks     ; tested

               .DC.l locksnd            ; sperre Audiosub,tested
               .DC.l unlocksnd          ; freigeben des Audiosub,tested
               .DC.l soundcmd           ; vol-controller,in a/d,vorteiler
               .DC.l setbuffer          ; set play & recbuffer,tested
               .DC.l setsndmode         ; 8bit Stereo/16bit/8bit mono,tested
               .DC.l settrack           ; Kanalzahl
               .DC.l setmontrack        ; playtrack
               .DC.l setinterrupt       ; welcher Int bei play/rec
               .DC.l buffoper           ; rec/play-start,tested
               .DC.l dsptristate        ; Multiplexer abkoppeln
               .DC.l gpio ; DSP-AnschlÅsse setzen,tested
               .DC.l devconnect         ; Multiplexer setzen,tested
               .DC.l sndstatus          ; Codec-init
               .DC.l buffptr            ; rec/play-position,tested

R_addrb:       .DC.l myxbios

Rlist2:        .DC.w 1,2  ; cookie/copyright
               .DC.w 10,11,12,13        ; card
               .DC.w 20,21,22,23,24,25,26,27,28,29          ; select
               .DC.w 30,31,32,33        ; digital-modes
               .DC.w 40,41,42,43,44,45,46,47      ; status
               .DC.w 50,51,52,53,54,55  ; vol/exec
               .DC.w 60,61              ; reset
               .DC.w 70,71,72,73,74,75,76,77      ; dsp-modes
               .DC.w 100,101            ; mix
               .DC.w 110,111            ; none_int
               .DC.w 120,121,122,123,124,125      ; int
               .DC.w 130,131,132        ; peak & int
               .DC.w 140,141,142,143,144          ; halfbuffer
               .DC.w 150,151,152,153    ; peakwert,userstart abholen
               .DC.w 160,161,162,163,164,165,166,167,168    ; Falconmode,mtc
               .DC.w 170,171            ; Programmemulationen
               .DC.w 180  ; startup-endroutine

               .DC.w 200,201,202,203,204          ; read_reg
               .DC.w 210,211,212,213,214          ; write_reg
               .DC.w 220,221,222,223,224          ; dsp-register lesen
               .DC.w 225,226,227,228,229          ; infos lesen
               .DC.w 230,231,232,233,234,235      ; dsp-register schreiben

               .DC.w 250,251,252,253,254,255,256,257,258,259          ; plugins
               .DC.w 260  ; internal plugins

               .DC.w 300,301,302,303,304,305,306,307,308,309          ; function
               .DC.w 310,311,312,313,314,315,316,317,318,319
               .DC.w 320,321,322,323,324,325,326,327

               .DC.w 400,401,402,403,404,405,406,407        ; tt-mmu support
               .DC.w 410,411,412,413,414,415,416  ; sndcall/dsp/devco list

               .DC.w 500,501,502,503,504,505,506,507        ; dsproutinen
               .DC.w 510,511,512        ; dspmixer

               .DC.w 0    ; end

R_addr2:       .DC.l installed          ; cookie XBIOS-Treiber
               .DC.l copyright          ; Copyright-Abfrage

               .DC.l cardslot           ; Anzahl Soundkarten im System
               .DC.l cardsel            ; Soundkarte auswaehlen
               .DC.l cardmagic          ; Soundkarten-magic auslesen
               .DC.l cardadr            ; Adressen sample/recstat/playstat/dsp

               .DC.l digana             ; Digital/Analogeingang
               .DC.l digcom             ; Digitalquelle
               .DC.l dspmode            ; dsprouting no/input/output
               .DC.l sclock             ; Samplerate
               .DC.l highsrate          ; samplerate-verdopplung
               .DC.l bypass             ; bypass/sampleplay
               .DC.l recmode            ; rec normal,4ch,8ch
               .DC.l playmode           ; play normal,4ch,8ch,16ch
               .DC.l mode24             ; 16Bit/24Bit
               .DC.l setplaych          ; playchannels auswÑhlen (L,R,Stereo)

               .DC.l digmode            ; digitaloutput consumer/professional
               .DC.l scmsmode           ; clear copybit fuer Kopierdecoder-mode
               .DC.l mycopybit          ; eigener SCMS-Kopierschutz no/one/all
               .DC.l emphasis           ; de-emphasis

               .DC.l digsrate           ; samplerate-erkennung vom digitalinput
               .DC.l digcode            ; Digitalinput-Aufnahmeart-Code
               .DC.l errorcode          ; Digitalinput-Fehlercode
               .DC.l cblmode            ; set cbl-mode
               .DC.l init_cbl           ; Read 192 Bit Channel Status
               .DC.l recstat            ; rec-FIFO-status
               .DC.l playstat           ; play-FIFO-status
               .DC.l calcdigsr          ; calculate digital samplerate

               .DC.l volad              ; volume-controller fuer input
               .DC.l volda              ; volume-controller fuer output
               .DC.l readsmp            ; sample lesen
               .DC.l writesmp           ; sample schreiben
               .DC.l intact             ; interrupt-freigabe fÅr fifo
               .DC.l dspintact          ; interrupt-freigabe fÅr dsp

               .DC.l recreset           ; record-FIFO loeschen
               .DC.l dspreset           ; reset fuer DSP

               .DC.l dspmem             ; 32Kx24,128Kx24 DSP-Memory
               .DC.l clkdivide          ; DSP-Clockdivider
               .DC.l pathset            ; dsp-verbindung zur matrix
               .DC.l dspcommnd          ; dsp-kommando
               .DC.l dspclear           ; dsp-receive auslesen (muell loeschen)
               .DC.l exclkmode          ; extclock-mode ja/nein (25.175 MHz)
               .DC.l gpiodirect         ; Direktzugriff auf gpio-Bits (wg srate)
               .DC.l clkdirect          ; Direkte (externe) Clockgenerierung

               .DC.l mixit              ; mixt 2-8 StereokanÑle (4-16 Tracks)
               .DC.l dspmix             ; mixt 4,8,16 Tracks fuer Falconmode

               .DC.l monitor            ; record&play-bypass
               .DC.l recwait            ; warten auf autorecord-schwellwert

               .DC.l init_peak          ; peakwert-ausgabe im Interrupt
               .DC.l init_imemrec       ; memory-record im Interrupt
               .DC.l init_imemplay      ; memory-play im Interrupt
               .DC.l init_impmix        ; memory-play mit rec-mix im Interrupt
               .DC.l init_hrec          ; HD-record im Interrupt
               .DC.l init_hplay         ; HD-play im Interrupt

               .DC.l init_mrecpeak      ; memory-rec & peakausgabe im Interrupt
               .DC.l init_mplaypeak     ; memory-play & peakausgabe im Interrupt
               .DC.l init_mrppeak       ;!mem-play&rec-mix&peakausgabe im Int

               .DC.l init_xmemrec       ; record im HalfBuffer-System
               .DC.l init_xmemplay      ; play im HalfBuffer-System
               .DC.l init_xmixplay      ;!play&mix-rec im HalfBuffer-System
               .DC.l init_xmemr4        ; 4Ch-mode rec im HalfBuffer-System
               .DC.l init_xmemp4        ; 4Ch-mode play im HalfBuffer-System

               .DC.l peakread           ; peakwert-Adresse fÅr request abholen
               .DC.l ustartread         ; aktuelle User-Startsync Adresse
               .DC.l peakmake           ; Peakmem anlegen ja/nein
               .DC.l peakshow           ; Peakwerte berechnen ja/nein

               .DC.l compatible         ; Falcon-TOS (emulation) ja/nein
               .DC.l mtc_clr            ; mtc-framezaehler loeschen
               .DC.l mtc_mode           ; midi-timecode erzeugung an/aus
               .DC.l mtc_time           ; midi-frames holen
               .DC.l mtc_wait           ; auf mtc-framewert warten
               .DC.l init_emuladc8      ; Emulation ADC64->DAC128
               .DC.l midikeyinit        ; Midi-Keys Protokoll an/aus
               .DC.l midikeyrst         ; Midi-Keys Matrix lîschen
               .DC.l midiplaymix        ; Midiplay-Routine

               .DC.l analyser           ; Emulation fÅr Soundpool Analyser
               .DC.l winrec             ; _MCH-Emulation fÅr Winrec

               .DC.l startup_exit       ; Startup Sound beenden

               .DC.l read_rlow          ; low-register lesen
               .DC.l read_rhi           ; high-register lesen
               .DC.l read_rdsp          ; dsp-register lesen
               .DC.l read_raes          ; aes-register lesen
               .DC.l read_rint          ; interrupt-register lesen

               .DC.l wr_rlow            ; low-register schreiben
               .DC.l wr_rhi             ; high-register schreiben
               .DC.l wr_rdsp            ; dsp-register schreiben
               .DC.l wr_raes            ; aes-register schreiben
               .DC.l wr_rint            ; interrupt-register schreiben

               .DC.l read_dpath1        ; dsppfad1-register lesen
               .DC.l read_dpath2        ; dsppfad2-register lesen
               .DC.l read_dport         ; dsp-port-register lesen
               .DC.l read_dconv         ; dsp-convert-register lesen
               .DC.l read_dpdat         ; dsp-pdat-register lesen
               .DC.l read_dclk          ; dsp-clkdiv-register lesen
               .DC.l setconnects1       ; read/write matrixwerte StarTrack
               .DC.l setconnects2       ; read/write matrixwerte dsp
               .DC.l showconnects       ; Ausgabe der matrixwerte u.a.
               .DC.l getfclocks         ; Ausgabe der devconnect-clocks

               .DC.l wr_dpath1          ; dsppfad1-register schreiben
               .DC.l wr_dpath2          ; dsppfad2-register schreiben
               .DC.l wr_dport           ; dsp-port-register schreiben
               .DC.l wr_dconv           ; dsp-convert-register schreiben
               .DC.l wr_dpdat           ; dsp-pdat-register schreiben
               .DC.l wr_dclk            ; dsp-clkdiv-register schreiben

               .DC.l plugincount        ; anzahl installierte plugins
               .DC.l pluginload         ; lade plugin
               .DC.l pluginkill         ; entferne plugin
               .DC.l plugfind           ; rd params,name,takte,parameterlst
               .DC.l plugplist          ; setze play-pluginliste
               .DC.l plugrlist          ; setze rec-pluginliste
               .DC.l plugmtime          ; liest max. plugin taktzyklen
               .DC.l plugrtime          ; real verbrauchte rec plug-taktzyklen
               .DC.l plugptime          ; real verbrauchte play plug-taktzyklen
               .DC.l pluginit           ; initialisiere rec&playplugs

               .DC.l plugvolctrl        ; internal volume-plugin

               .DC.l fastcut            ; speicherbereich loeschen im samplemem
               .DC.l peaksuch           ; peakwert-suche im pbf
               .DC.l zerono             ; nullstellen-suche im samplemem
               .DC.l fading             ; sample-fading im samplemem
               .DC.l muster             ; speicherbereich mit Muster fÅllen
               .DC.l testbits           ; RAM->bitmuster (1,2..$80000000) fÅllen
               .DC.l speedtst           ; testet Interface-speed
               .DC.l init_scrub         ; scrubbing
               .DC.l crveclc            ; peakwert-suche im samplemem
               .DC.l fncopy             ; samples kopieren
               .DC.l fnldsave           ; samples load/save
               .DC.l fnbackcopy         ; samples backcopy
               .DC.l fnpeaksuch         ; samples peaksuch
               .DC.l normalize          ; samples normalize
               .DC.l resample           ; samples resample
               .DC.l fnmono             ; samples mono
               .DC.l fnintel            ; samples load intel
               .DC.l fncopyback         ; samples copyback
               .DC.l fnzero             ; samples zero
               .DC.l negate             ; samples negate
               .DC.l lrchange           ; samples left/right change
               .DC.l fnsdmono           ; samples sdmono
               .DC.l fnsdstereo         ; samples sdstereo
               .DC.l fnwavalon          ; samples wavalon
               .DC.l conv16             ; konvertiert 16bit->24bit
               .DC.l conv24             ; konvertiert 24bit->16bit
               .DC.l convstm            ; move data file->stream
               .DC.l convmst            ; move data stream->file

               .DC.l getsrp             ; get supervisor root pointer
               .DC.l getcrp             ; get cpu root pointer
               .DC.l gettc              ; get translation code register
               .DC.l none ; put supervisor root pointer
               .DC.l putcrp             ; put cpu root pointer
               .DC.l puttc              ; put translation code register
               .DC.l pflusha            ; clear all atc-entrys
               .DC.l getmmucode         ; get mmutable startadress (resistant)

               .DC.l getdevadr          ; get devconnect listadress
               .DC.l getdevco           ; get number of devconnect listentrys
               .DC.l devcountreset      ; clear devconnect listcounter
               .DC.l getfalcxadr        ; get soundcall listadress
               .DC.l getfalcxnr         ; get number of soundcall listentrys
               .DC.l falcxnreset        ; clear soundcall listcounter
               .DC.l falcxmode          ; sndcall/dspcall/devcon list on/off

               .DC.l setpassthru        ; dsp-bypass (thru) routine laden
               .DC.l setdsprec2         ; host dsprecord dsp-routine laden
               .DC.l setdsprec4         ; host dsprec4 dsp-routine laden
               .DC.l setdspplay2        ; host dspplay dsp-routine laden
               .DC.l setdspplay4        ; host dspplay4 dsp-routine laden
               .DC.l setdspplay8        ; host dspplay8 dsp-routine laden
               .DC.l setdspmix8         ; mixing8 dsp-routine laden
               .DC.l setdspeff8         ; mixeffect8 dsp-routine laden

               .DC.l setdspmxbal        ; balance mixer
               .DC.l setdspmxpan        ; panpot mixer
               .DC.l setdspmxext        ; external mixer

; ---------------Falcon/MagicMac-Sprungtabelle-----------------------


Rlist3:        .DC.w myxcall            ; my-XBIOS
               .DC.w 0
R_addr3:       .DC.l demoxbios

R_addr4:       .DC.l installed          ; cookie XBIOS-Treiber
               .DC.l copyright          ; Copyright-Abfrage

               .DC.l cardslot           ; Anzahl Soundkarten im System
               .DC.l none ; Soundkarte auswaehlen
               .DC.l none ; Soundkarten-magic auslesen
               .DC.l none ; Adressen sample/recstat/playstat/dsp

               .DC.l none ; Digital/Analogeingang
               .DC.l none ; Digitalquelle
               .DC.l none ; dsprouting no/input/output
               .DC.l none ; Samplerate
               .DC.l none ; samplerate-verdopplung
               .DC.l none ; bypass/sampleplay
               .DC.l none ; rec normal,4ch,8ch
               .DC.l none ; play normal,4ch,8ch,16ch
               .DC.l none ; 16Bit/24Bit
               .DC.l none ; playchannels auswÑhlen (L,R,Stereo)

               .DC.l none ; digitaloutput consumer/professional
               .DC.l none ; clear copybit fuer Kopierdecoder-mode
               .DC.l none ; eigener SCMS-Kopierschutz no/one/all
               .DC.l none ; de-emphasis

               .DC.l none ; samplerate-erkennung vom digitalinput
               .DC.l none ; Digitalinput-Aufnahmeart-Code
               .DC.l none ; Digitalinput-Fehlercode
               .DC.l none ; set cbl-mode
               .DC.l none ; Read 192 Bit Channel Status
               .DC.l none ; rec-FIFO-status
               .DC.l none ; play-FIFO-status
               .DC.l none ; calculate digital samplerate

               .DC.l none ; volume-controller fuer input
               .DC.l none ; volume-controller fuer output
               .DC.l none ; sample lesen
               .DC.l none ; sample schreiben
               .DC.l none ; interrupt-freigabe fÅr fifo
               .DC.l none ; interrupt-freigabe fÅr dsp

               .DC.l none ; record-FIFO loeschen
               .DC.l none ; reset fuer DSP

               .DC.l none ; 32Kx24,128Kx24 DSP-Memory
               .DC.l none ; DSP-Clockdivider
               .DC.l none ; dsp-verbindung zur matrix
               .DC.l none ; dsp-kommando
               .DC.l none ; dsp-receive auslesen (muell loeschen)
               .DC.l none ; extclock-mode ja/nein (25.175 MHz)
               .DC.l none ; Direktzugriff auf gpio-Bits (wg srate)
               .DC.l none ; Direkte (externe) Clockgenerierung

               .DC.l mixit              ; mixt 2-8 StereokanÑle (4-16 Tracks)
               .DC.l dspmix             ; mixt 4,8,16 Tracks fuer Falconmode

               .DC.l none ; record&play-bypass
               .DC.l none ; warten auf autorecord-schwellwert

               .DC.l none ; peakwert-ausgabe im Interrupt
               .DC.l none ; memory-record im Interrupt
               .DC.l none ; memory-play im Interrupt
               .DC.l none ; memory-play mit rec-mix im Interrupt
               .DC.l none ; HD-record im Interrupt
               .DC.l none ; HD-play im Interrupt

               .DC.l none ; memory-rec & peakausgabe im Interrupt
               .DC.l none ;!memory-play & peakausgabe im Interrupt
               .DC.l none ;!mem-play&rec-mix&peakausgabe im Int

               .DC.l none ; record im HalfBuffer-System
               .DC.l none ; play im HalfBuffer-System
               .DC.l none ; play&mix-rec im HalfBuffer-System
               .DC.l none ; 4Ch-mode rec im HalfBuffer-System
               .DC.l none ; 4Ch-mode play im HalfBuffer-System

               .DC.l none ; aktuellen peakwert abholen (only ipeak)
               .DC.l none ; aktuelle User-Startsync Adresse
               .DC.l peakmake           ; Peakmem anlegen ja/nein
               .DC.l peakshow           ; Peakwerte berechnen ja/nein

               .DC.l none ; Falcon-TOS (emulation) ja/nein
               .DC.l mtc_clr            ; mtc-framezaehler loeschen
               .DC.l mtc_mode           ; midi-timecode erzeugung an/aus
               .DC.l mtc_time           ; midi-frames holen
               .DC.l mtc_wait           ; auf mtc-framewert warten
               .DC.l none ; Emulation ADC64->DAC128
               .DC.l none ; Midi-Keys Protokoll an/aus
               .DC.l none ; Midi-Keys Matrix lîschen
               .DC.l none ; Midiplay-Routine

               .DC.l none ; Emulation fÅr Soundpool Analyser
               .DC.l none ; _MCH-Emulation fÅr Winrec

               .DC.l none ; Startup Sound beenden

               .DC.l none ; low-register lesen
               .DC.l none ; high-register lesen
               .DC.l none ; dsp-register lesen
               .DC.l none ; aes-register lesen
               .DC.l none ; interrupt-register lesen

               .DC.l none ; low-register schreiben
               .DC.l none ; high-register schreiben
               .DC.l none ; dsp-register schreiben
               .DC.l none ; aes-register schreiben
               .DC.l none ; interrupt-register schreiben

               .DC.l none ; dsppfad1-register lesen
               .DC.l none ; dsppfad2-register lesen
               .DC.l none ; dsp-port-register lesen
               .DC.l none ; dsp-convert-register lesen
               .DC.l none ; dsp-pdat-register lesen
               .DC.l none ; dsp-clkdiv-register lesen
               .DC.l none ; read/write matrixwerte StarTrack
               .DC.l none ; read/write matrixwerte dsp
               .DC.l showconnects       ; Ausgabe der matrixwerte u.a.
               .DC.l getfclocks         ; Ausgabe der devconnect-clocks

               .DC.l none ; dsppfad1-register schreiben
               .DC.l none ; dsppfad2-register schreiben
               .DC.l none ; dsp-port-register schreiben
               .DC.l none ; dsp-convert-register schreiben
               .DC.l none ; dsp-pdat-register schreiben
               .DC.l none ; dsp-clkdiv-register schreiben

               .DC.l plugincount        ; anzahl installierte plugins
               .DC.l pluginload         ; lade plugin
               .DC.l pluginkill         ; entferne plugin
               .DC.l plugfind           ; rd params,name,takte,parameterlst
               .DC.l plugplist          ; setze play-pluginliste
               .DC.l plugrlist          ; setze rec-pluginliste
               .DC.l plugmtime          ; liest max. plugin taktzyklen
               .DC.l plugrtime          ; real verbrauchte rec plug-taktzyklen
               .DC.l plugptime          ; real verbrauchte play plug-taktzyklen
               .DC.l pluginit           ; initialisiere rec&playplugs

               .DC.l plugvolctrl        ; internal volume-plugin

               .DC.l fastcut            ; speicherbereich loeschen im samplemem
               .DC.l peaksuch           ; peakwert-suche im pbf
               .DC.l zerono             ; nullstellen-suche im samplemem
               .DC.l fading             ; sample-fading im samplemem
               .DC.l muster             ; speicherbereich mit Muster fÅllen
               .DC.l testbits           ; RAM->bitmuster (1,2..$80000000) fÅllen
               .DC.l none ; testet Interface-speed
               .DC.l none ; scrubbing
               .DC.l crveclc            ; peakwert-suche im samplemem
               .DC.l fncopy             ; samples kopieren
               .DC.l fnldsave           ; samples load/save
               .DC.l fnbackcopy         ; samples backcopy
               .DC.l fnpeaksuch         ; samples peaksuch
               .DC.l normalize          ; samples normalize
               .DC.l resample           ; samples resample
               .DC.l fnmono             ; samples mono
               .DC.l fnintel            ; samples load intel
               .DC.l fncopyback         ; samples copyback
               .DC.l fnzero             ; samples zero
               .DC.l negate             ; samples negate
               .DC.l lrchange           ; samples left/right change
               .DC.l fnsdmono           ; samples sdmono
               .DC.l fnsdstereo         ; samples sdstereo
               .DC.l fnwavalon          ; samples wavalon
               .DC.l conv16             ; konvertiert 16bit->24bit
               .DC.l conv24             ; konvertiert 24bit->16bit
               .DC.l convstm            ; move data file->stream
               .DC.l convmst            ; move data stream->file

               .DC.l getsrp             ; get supervisor root pointer
               .DC.l getcrp             ; get cpu root pointer
               .DC.l gettc              ; get translation code register
               .DC.l none ; put supervisor root pointer
               .DC.l putcrp             ; put cpu root pointer
               .DC.l puttc              ; put translation code register
               .DC.l pflusha            ; clear all atc-entrys
               .DC.l getmmucode         ; get mmutable startadress (resistant)

               .DC.l getdevadr          ; get devconnect listadress
               .DC.l getdevco           ; get number of devconnect listentrys
               .DC.l devcountreset      ; clear devconnect listcounter
               .DC.l getfalcxadr        ; get soundcall listadress
               .DC.l getfalcxnr         ; get number of soundcall listentrys
               .DC.l falcxnreset        ; clear soundcall listcounter
               .DC.l falcxmode          ; sndcall/dspcall/devcon list on/off

               .DC.l setpassthru        ; dsp-bypass (thru) routine laden
               .DC.l setdsprec2         ; dsprecord dsp-routine laden
               .DC.l setdsprec4         ; host dsprec4 dsp-routine laden
               .DC.l setdspplay2        ; dspplay dsp-routine laden
               .DC.l setdspplay4        ; host dspplay4 dsp-routine laden
               .DC.l setdspplay8        ; host dspplay8 dsp-routine laden
               .DC.l setdspmix8         ; mixing8 dsp-routine laden
               .DC.l setdspeff8         ; mixeffect8 dsp-routine laden

               .DC.l setdspmxbal        ; balance mixer
               .DC.l setdspmxpan        ; panpot mixer
               .DC.l setdspmxext        ; external mixer

               .DATA 
stack:         .DS.b 512
               .BSS 
midilist:      .DS.w 2048 ; list of pressed or unpressed keys
pipefind:      .DS.b 2048 ; list of midipipe entry-locations
midipipe:      .DS.w 256  ; midikey pipeline
midionpipe:    .DS.w 256  ; midikey_on pipeline
midioffpipe:   .DS.w 256  ; midikey_off pipeline
newcjar:       .DS.l 102
epeakbuf:      .DS.b 4
param:         .DS.l 8
csysbase:      .DS.b 128
mmucode:       .DS.b 4096
cblbits:       .DS.b 2400
devcolist:     .DS.w 1300
falcxlist:     .DS.w 3000
filebuf:       
recbuf:        .DS.b 8192
recbuf2:       .DS.b 8192
recbuf3:       
filebfe:       
vmemul:        .DS.b 1024
control:       .DS.w 4
global:        .DS.w 14
int_in:        .DS.w 16
int_out:       .DS.w 7
addr_in:       .DS.l 3
addr_out:      .DS.l 1
               .DS.b 512
stack_end:     
               .END 
;ENDE

