$m300000
compile=TRUE
accok=FALSE
'
' READ  00h   Status Low   SUBFR0   Bit0-1 -> AESC24,AESC25,(AESF0)
' READ  00h   Status Low   SUBFR1   Bit0-2 -> AESC24,AESC25,EMPH
'
' WRITE 00h   Register Low          Bit0-3 -> SWAES,SWDIGIN,TAKT0,TAKT1
'
'
'
' READ  20h   Status Mid   SUBFR0   Bit0-2 -> ERR0,ERR1,ERR2
' READ  20h   Status Mid   SUBFR1   Bit0-2 -> USE,AUDIO,PROT
'
'
'
' READ  40h   Status High           Bit0-3 -> RDE,RDH,WRF,WRH
'
' WRITE 40h   Register High         Bit0-3 -> SWPROT,SWRES-FIFO,SWDIGOUT,SWSUBFR
'
'
'
' WRITE 80h   DSP-Register          Bit0-1 -> DSPON,DSPIN
'
'
'
' RD/WR C0h   Sample Read/Write
'
'
' SAMPLER zum VME_SMP16
'
' Bedienung aller wichtiger Parametrer des 16Bit-Stereo-Samplers
'
' l„uft als Gem-Prg sowie als Accessory (Endung von .PRG auf .ACC „ndern)
'
' ---------------------------.ACC-Abfrage---------------------------------------
IF auflauf=0 THEN
  xwidth=WORK_OUT(0)+1
  ywidth=WORK_OUT(1)+1
ENDIF
IF accok=TRUE THEN
  ap_id&=APPL_INIT()
  IF ap_id&>0
    me_id&=MENU_REGISTER(ap_id&,"  SAMPLER16")
    DO
      ~EVNT_MESAG(0)
      IF MENU(1)=40
        acc=TRUE
        IF xwidth<640 OR ywidth<400 THEN
          ALERT 3,"Aufl”sung ist zu gering|Mindestens 640x400 n”tig !",1,"EXIT",g
          GOTO ende
        ENDIF
        GOTO start
      ende:
      ENDIF
    LOOP
  ENDIF
ENDIF
'
' ----------------------------Variablendefinition-------------------------------
start:
auflauf=auflauf+1
IF auflauf=1 THEN
  LET smp16&=0 !RSC_TREE
  LET smpedit&=1 !RSC_TREE
  LET dspedit&=2 !RSC_TREE
  LET peak&=3 !RSC_TREE
  LET loop&=4 !RSC_TREE
  LET normaliz&=5 !RSC_TREE
  LET resample&=6 !RSC_TREE
  LET midiedit&=7 !RSC_TREE
  LET editfade&=8 !RSC_TREE
  LET popups&=9 !RSC_TREE
  LET record&=10 !RSC_TREE
  LET cutedit&=11 !RSC_TREE
  LET savebloc&=12 !RSC_TREE
  LET arranger&=13 !RSC_TREE
  LET exit&=3 !Obj in #0
  LET datei&=5 !Obj in #0
  LET prot&=8 !Obj in #0
  LET emph&=9 !Obj in #0
  LET audio&=10 !Obj in #0
  LET use&=11 !Obj in #0
  LET smp32&=13 !Obj in #0
  LET smp44&=14 !Obj in #0
  LET smp48&=15 !Obj in #0
  LET noval&=17 !Obj in #0
  LET confid&=18 !Obj in #0
  LET slipped&=19 !Obj in #0
  LET crc&=20 !Obj in #0
  LET parity&=21 !Obj in #0
  LET biphase&=22 !Obj in #0
  LET nolock&=23 !Obj in #0
  LET edit&=26 !Obj in #0
  LET swdsp&=27 !Obj in #0
  LET peaksw&=28 !Obj in #0
  LET protect&=36 !Obj in #0
  LET input&=38 !Obj in #0
  LET incirc&=39 !Obj in #0
  LET source&=40 !Obj in #0
  LET srccirc&=41 !Obj in #0
  LET smpauto&=43 !Obj in #0
  LET smpstart&=44 !Obj in #0
  LET play&=46 !Obj in #0
  LET rate2&=50 !Obj in #0
  LET ratecir2&=51 !Obj in #0
  LET helporig&=52 !Obj in #0
  LET dsp&=56 !Obj in #0
  LET dspcirc&=57 !Obj in #0
  LET filesel&=59 !Obj in #0
  LET memused&=61 !Obj in #0
  LET smpsta&=5 !Obj in #1
  LET smpstb&=6 !Obj in #1
  LET smpstc&=7 !Obj in #1
  LET smpstd&=8 !Obj in #1
  LET smpste&=9 !Obj in #1
  LET smpsavl&=10 !Obj in #1
  LET smptsa&=11 !Obj in #1
  LET smptsb&=12 !Obj in #1
  LET smptsc&=13 !Obj in #1
  LET smptsd&=14 !Obj in #1
  LET smptse&=15 !Obj in #1
  LET hacksa&=16 !Obj in #1
  LET hacksb&=17 !Obj in #1
  LET hacksc&=18 !Obj in #1
  LET hacksd&=19 !Obj in #1
  LET smpea&=22 !Obj in #1
  LET smpeb&=23 !Obj in #1
  LET smpec&=24 !Obj in #1
  LET smped&=25 !Obj in #1
  LET smpee&=26 !Obj in #1
  LET smpsavr&=27 !Obj in #1
  LET smplen&=28 !Obj in #1
  LET smpsec&=29 !Obj in #1
  LET smpexit&=33 !Obj in #1
  LET smpl1&=35 !Obj in #1
  LET smpr1&=36 !Obj in #1
  LET smpl2&=37 !Obj in #1
  LET smpr2&=38 !Obj in #1
  LET smpl3&=39 !Obj in #1
  LET smpr3&=40 !Obj in #1
  LET smpanf&=41 !Obj in #1
  LET smpend&=42 !Obj in #1
  LET smpmid&=43 !Obj in #1
  LET rate&=44 !Obj in #1
  LET ratecirc&=45 !Obj in #1
  LET smptsava&=46 !Obj in #1
  LET hackse&=47 !Obj in #1
  LET hackss&=48 !Obj in #1
  LET smploop&=50 !Obj in #1
  LET smppmark&=51 !Obj in #1
  LET midi&=53 !Obj in #1
  LET mintext&=54 !Obj in #1
  LET smpfile&=55 !Obj in #1
  LET smprate&=56 !Obj in #1
  LET mover&=59 !Obj in #1
  LET movecirc&=60 !Obj in #1
  LET uhr&=61 !Obj in #1
  LET smptea&=62 !Obj in #1
  LET smpteb&=63 !Obj in #1
  LET smptec&=64 !Obj in #1
  LET smpted&=65 !Obj in #1
  LET smptee&=66 !Obj in #1
  LET smptsavb&=67 !Obj in #1
  LET hackea&=68 !Obj in #1
  LET hackeb&=69 !Obj in #1
  LET hackec&=70 !Obj in #1
  LET hacked&=71 !Obj in #1
  LET hackee&=72 !Obj in #1
  LET hackes&=73 !Obj in #1
  LET helpedit&=75 !Obj in #1
  LET norm&=76 !Obj in #1
  LET resmp&=77 !Obj in #1
  LET mono&=78 !Obj in #1
  LET mix&=79 !Obj in #1
  LET edfade&=80 !Obj in #1
  LET peaksw2&=81 !Obj in #1
  LET hear&=82 !Obj in #1
  LET monitor&=83 !Obj in #1
  LET smpauto2&=84 !Obj in #1
  LET smpstrt2&=85 !Obj in #1
  LET smpplay&=86 !Obj in #1
  LET edmidi&=87 !Obj in #1
  LET loopart&=88 !Obj in #1
  LET smpload&=89 !Obj in #1
  LET smpsave&=90 !Obj in #1
  LET cut&=91 !Obj in #1
  LET hard&=92 !Obj in #1
  LET arrange&=93 !Obj in #1
  LET dsphall&=2 !Obj in #2
  LET dspecho&=3 !Obj in #2
  LET dspret&=4 !Obj in #2
  LET dspeq&=5 !Obj in #2
  LET dspload&=6 !Obj in #2
  LET helpdsp&=7 !Obj in #2
  LET dspexit&=8 !Obj in #2
  LET dspsave&=9 !Obj in #2
  LET plmin&=14 !Obj in #3
  LET pl2&=15 !Obj in #3
  LET pl3&=16 !Obj in #3
  LET pl4&=17 !Obj in #3
  LET pl5&=18 !Obj in #3
  LET pl6&=19 !Obj in #3
  LET pl7&=20 !Obj in #3
  LET pl8&=21 !Obj in #3
  LET pl9&=22 !Obj in #3
  LET plmax&=23 !Obj in #3
  LET prmin&=24 !Obj in #3
  LET pr2&=25 !Obj in #3
  LET pr3&=26 !Obj in #3
  LET pr4&=27 !Obj in #3
  LET pr5&=28 !Obj in #3
  LET pr6&=29 !Obj in #3
  LET pr7&=30 !Obj in #3
  LET pr8&=31 !Obj in #3
  LET pr9&=32 !Obj in #3
  LET prmax&=33 !Obj in #3
  LET loopexit&=1 !Obj in #4
  LET forw&=3 !Obj in #4
  LET cross&=4 !Obj in #4
  LET backw&=5 !Obj in #4
  LET helploop&=7 !Obj in #4
  LET autoloop&=8 !Obj in #4
  LET normok&=2 !Obj in #5
  LET normexit&=3 !Obj in #5
  LET normdb&=4 !Obj in #5
  LET normauto&=7 !Obj in #5
  LET normadj&=8 !Obj in #5
  LET norml1&=10 !Obj in #5
  LET normr1&=11 !Obj in #5
  LET norml2&=12 !Obj in #5
  LET normr2&=13 !Obj in #5
  LET norml3&=14 !Obj in #5
  LET normr3&=15 !Obj in #5
  LET helpnorm&=16 !Obj in #5
  LET resother&=1 !Obj in #6
  LET resl1&=3 !Obj in #6
  LET resl2&=4 !Obj in #6
  LET resl3&=5 !Obj in #6
  LET resr1&=6 !Obj in #6
  LET resr2&=7 !Obj in #6
  LET resr3&=8 !Obj in #6
  LET res32&=13 !Obj in #6
  LET res44&=15 !Obj in #6
  LET res48&=17 !Obj in #6
  LET helprsmp&=18 !Obj in #6
  LET restxt&=19 !Obj in #6
  LET resok&=20 !Obj in #6
  LET resexit&=21 !Obj in #6
  LET notetxt&=1 !Obj in #7
  LET midinup&=2 !Obj in #7
  LET midindwn&=3 !Obj in #7
  LET midioup&=4 !Obj in #7
  LET midiodwn&=5 !Obj in #7
  LET chtxt&=7 !Obj in #7
  LET midicup&=9 !Obj in #7
  LET midicdwn&=10 !Obj in #7
  LET midiok&=11 !Obj in #7
  LET helpmidi&=13 !Obj in #7
  LET fadeok&=2 !Obj in #8
  LET fadeup&=3 !Obj in #8
  LET fadedown&=4 !Obj in #8
  LET fadeli&=5 !Obj in #8
  LET fadere&=6 !Obj in #8
  LET fadelin&=8 !Obj in #8
  LET infade&=10 !Obj in #8
  LET ausfade&=11 !Obj in #8
  LET helpfade&=12 !Obj in #8
  LET smppopup&=1 !Obj in #9
  LET rate32&=2 !Obj in #9
  LET rate44&=3 !Obj in #9
  LET rate48&=4 !Obj in #9
  LET dsppopup&=5 !Obj in #9
  LET dspoff&=6 !Obj in #9
  LET dspin&=7 !Obj in #9
  LET dspout&=8 !Obj in #9
  LET smppop2&=9 !Obj in #9
  LET ad32&=10 !Obj in #9
  LET ad44&=11 !Obj in #9
  LET ad48&=12 !Obj in #9
  LET inpop&=13 !Obj in #9
  LET analog&=14 !Obj in #9
  LET digital&=15 !Obj in #9
  LET srcpop&=16 !Obj in #9
  LET opto&=17 !Obj in #9
  LET coax&=18 !Obj in #9
  LET popmark&=19 !Obj in #9
  LET smpmark&=20 !Obj in #9
  LET smpzoom&=21 !Obj in #9
  LET smpscrol&=22 !Obj in #9
  LET kopy&=23 !Obj in #9
  LET move&=24 !Obj in #9
  LET merge&=25 !Obj in #9
  LET fade&=26 !Obj in #9
  LET recl1&=1 !Obj in #10
  LET recr1&=2 !Obj in #10
  LET recl2&=3 !Obj in #10
  LET recr2&=4 !Obj in #10
  LET timetxt&=5 !Obj in #10
  LET recok&=6 !Obj in #10
  LET recexit&=7 !Obj in #10
  LET cutin&=1 !Obj in #11
  LET cutout&=2 !Obj in #11
  LET cutexit&=3 !Obj in #11
  LET savall&=1 !Obj in #12
  LET savblock&=2 !Obj in #12
  LET savexit&=3 !Obj in #12
  LET hlpedit2&=2 !Obj in #13
  LET smpload2&=3 !Obj in #13
  LET smpsave2&=4 !Obj in #13
  LET hardcut&=5 !Obj in #13
  LET smpauto3&=7 !Obj in #13
  LET smpstrt3&=8 !Obj in #13
  LET smpplay2&=9 !Obj in #13
  LET pause&=10 !Obj in #13
  LET rewind&=11 !Obj in #13
  LET stop&=12 !Obj in #13
  LET forward&=13 !Obj in #13
  LET recplay&=14 !Obj in #13
  LET hardfs1&=25 !Obj in #13
  LET hardfs2&=27 !Obj in #13
  LET hardfs3&=29 !Obj in #13
  LET hardfs4&=31 !Obj in #13
  LET hardst1&=33 !Obj in #13
  LET hardst2&=35 !Obj in #13
  LET hardst3&=37 !Obj in #13
  LET hardst4&=39 !Obj in #13
  LET harde2&=41 !Obj in #13
  LET harde3&=43 !Obj in #13
  LET harde4&=45 !Obj in #13
  LET harde1&=49 !Obj in #13
  LET hardlen1&=51 !Obj in #13
  LET hardlen2&=53 !Obj in #13
  LET hardlen3&=55 !Obj in #13
  LET hardlen4&=57 !Obj in #13
  LET arrexit&=65 !Obj in #13
  OPTION BASE 0
  IF compile=FALSE THEN
    RESERVE 200000
  ENDIF
ENDIF
'
' -----------------------------Aufl”sung erfragen-------------------------------
IF xwidth<640 OR ywidth<400 THEN
  ALERT 3,"Aufl”sung ist zu gering|Mindestens 640x400 n”tig !",1,"EXIT",g
  END
ENDIF
'
' ----------------------------RSC laden etc.------------------------------------
' DEFMOUSE 0
@rsc_init
IF @rsc_laden("C:\SAMPLER4.RSC",13,9,-1,-1) THEN ! File$,Trees,Popup,Menu,Alert
  rscda=TRUE
ELSE
  rscda=FALSE
ENDIF
IF rscda=TRUE THEN
  @main
ENDIF
IF rscda=FALSE THEN
  ALERT 3,"RSC-File nicht gefunden !",1,"EXIT",g
  GEMSYS 109                                        ! Nur ab GEM 1.04!
  '  @rsc_exit
ENDIF
IF acc=TRUE THEN
  GOTO ende
ELSE
  END
ENDIF
'
' ----------------------------Hauptprogramm-------------------------------------
> PROCEDURE main
  IF compile=FALSE THEN
    ~GRAF_MOUSE(0,0)                           ! Fr den Compiler
  ENDIF
  ' Weil's im Interpreter sch”ner aussieht, fr den Compiler bitte entfernen!
  '  ~FORM_DIAL(3,deskx&,desky&,deskw&,deskh&,deskx&,desky&,deskw&,deskh&)
  '
  @rsc_draw(smp16&,7)
  IF auflauf=1 THEN
    @setup
  ELSE
    @aufbau
  ENDIF
  REPEAT
    REPEAT
      obj=@rsc_do(smp16&,0,popup&)
      ~RSRC_GADDR(0,smp16&,zuadr)
      buttadr=zuadr+24*obj
      but=DPEEK(buttadr+6) AND 255
    UNTIL but=26 OR but=24 OR but=20 OR but=22
    IF but=22 THEN
      IF obj=dsp& THEN
        a$=@rsc_text$(popups&,5+popup&)
        @textfeld(obj,a$,1)
        IF popup&=1 THEN
          @dspoff
        ENDIF
        IF popup&=2 THEN
          @dspin
        ENDIF
        IF popup&=3 THEN
          @dspout
        ENDIF
      ENDIF
      IF obj=rate2& THEN
        a$=@rsc_text$(popups&,9+popup&)
        @textfeld(obj,a$,1)
        IF popup&=1 THEN
          @adlow
        ENDIF
        IF popup&=2 THEN
          @admid
        ENDIF
        IF popup&=3 THEN
          @adhigh
        ENDIF
      ENDIF
      IF obj=input& THEN
        a$=@rsc_text$(popups&,13+popup&)
        @textfeld(obj,a$,1)
        IF popup&=1 THEN
          @analog
        ENDIF
        IF popup&=2 THEN
          @digital
        ENDIF
      ENDIF
      IF obj=source& THEN
        a$=@rsc_text$(popups&,16+popup&)
        @textfeld(obj,a$,1)
        IF popup&=1 THEN
          @opto
        ENDIF
        IF popup&=2 THEN
          @coax
        ENDIF
      ENDIF
    ENDIF
    IF obj=lock& THEN
      @locking
    ENDIF
    IF obj=edit& THEN
      @setbutton(edit&,32+16)
      @smpedit
    ENDIF
    IF obj=protect& THEN
      @prot
    ENDIF
    IF obj=smpauto& THEN
      @smpauto
    ENDIF
    IF obj=smpstart& THEN
      @smpstart
    ENDIF
    IF obj=play& THEN
      @play
    ENDIF
    IF obj=filesel& THEN
      @fsel
    ENDIF
    IF obj=peaksw& THEN
      @setbutton(peaksw&,32+16)
      @peak
    ENDIF
    IF obj=swdsp& THEN
      @setbutton(swdsp&,32+16)
      @dspwahl
    ENDIF
  UNTIL obj=exit&
  GEMSYS 109                                        ! Nur ab GEM 1.04!
  @rsc_exit
  IF manf>0 THEN
    ~MFREE(manf)
  ENDIF
RETURN
' ----------------------------Unterprogramme------------------------------------
> PROCEDURE markhlp
  handle&=rsc_handle%(nr)                         ! Fensterhandle des Dialogs
  ~WIND_GET(handle&,11,ax&,ay&,ab&,ah&)          ! 1. Rechteck
  yv=32   ! verschiebung in y-Richtung
  xd=ax&+10
  yd=ay&-11+yv
  xm=615
  ym=85
  ym2=100
  ym3=181
  d=22
  stay1=yd+d
  stay2=yd+d+ym3
  DEFTEXT 1,0,0,4
RETURN
'
> PROCEDURE markhlp2
  COLOR 1
  ALINE xd,stay1,xd,stay2,1,&HFFFF,2
  TEXT xd-3,yd+22,t$
RETURN
'
> PROCEDURE markhlp3(stxnr,smptnr)
  sec=(ce-cs)/(hz*4)
  sc=sec/xm*stxnr+cs/(hz*4)
  sc$=STR$(sc)
  IF INSTR(sc$,".") THEN
    mem$=LEFT$(sc$+"     ",5)+CHR$(0)
  ELSE
    mem$=RIGHT$("     "+sc$,5)+CHR$(0)
  ENDIF
  @textfeld(smptnr,mem$,1)
RETURN
'
> PROCEDURE normalize
  makecurve=0
  @rsc_back(nr)
  vornr=nr
  nr=normaliz&
  @rsc_draw(nr,5)
  @markhlp
  @setbutton(normadj&,0)
  @setbutton(normauto&,1)
  norma=1
  @normtest
  REPEAT
    REPEAT
      REPEAT
        obj=@rsc_do(nr,0,popup&)
        ~RSRC_GADDR(0,nr,zuadr)
        x=MOUSEX
        y=MOUSEY
      UNTIL obj<>0 AND obj<>-1
      buttadr=zuadr+24*obj
      but=DPEEK(buttadr+6) AND 255
    UNTIL but=26 OR but=24
    IF obj=norml1& OR obj=norml2& OR obj=norml3& OR obj=normr1& OR obj=normr2& OR obj=normr3& THEN
      PAUSE 1
      @setbutton(obj,0)
    ENDIF
    ~RSRC_GADDR(1,obj,objadr)
    objflag=DPEEK(objadr+8)
    IF obj=norml1& OR obj=norml2& OR obj=norml3& THEN
      @norml
    ENDIF
    IF obj=normr1& OR obj=normr2& OR obj=normr3& THEN
      @normr
    ENDIF
    IF obj=normauto& THEN
      norma=1
    ENDIF
    IF obj=normadj& THEN
      norma=0
    ENDIF
  UNTIL obj=normok& OR obj=normexit&
  IF obj=normok& THEN
    IF norma=1 THEN
      @normauto
    ENDIF
    IF norma=0 THEN
      @normadj
    ENDIF
  ENDIF
  @setbutton(obj,0)
  @restaura2
  @setbutton(norm&,0)
  obj=0
RETURN
'
> PROCEDURE fade
  vornr=nr
  @rsc_back(nr)
  nr=editfade&
  @rsc_draw(nr,5)
  ~RSRC_GADDR(0,nr,boxadr)
  @markhlp
  IF fadericht=0 THEN
    @setbutton(infade&,33)
  ELSE
    @setbutton(ausfade&,33)
  ENDIF
  yma=yd+248
  FOR i=1 TO fadnr
    IF fadericht=0 THEN
      y=fadeni(i)+yd+48
    ELSE
      y=fadeno(i)+yd+48
    ENDIF
    IF y<>yd+48 THEN
      LINE i+xd+8,yma,i+xd+8,y-1
    ENDIF
  NEXT i
  '  LINE xm,ym,x,y
  REPEAT
    REPEAT
      ' REPEAT
      '        obj=@rsc_do(nr,0,popup&)
      ' ~RSRC_GADDR(0,nr,zuadr)
      ' x=MOUSEX
      ' y=MOUSEY
      ' UNTIL obj<>0 AND obj<>-1
      REPEAT
        REPEAT
          ~RSRC_GADDR(0,nr,zuadr)
          k=MOUSEK
        UNTIL k=1 OR k=-1
        IF k=1 THEN
          x=MOUSEX
          y=MOUSEY
          obj=OBJC_FIND(boxadr,0,10,x,y)
        ENDIF
      UNTIL obj<>0 AND obj<>-1
      IF obj=infade& THEN
        @infade
      ENDIF
      IF obj=ausfade& THEN
        @ausfade
      ENDIF
      IF obj=1 THEN
        IF x<xd+8 THEN
          x=xd+8
        ENDIF
        LINE x,y,x,y
        xm=x
        ym=y
        REPEAT
          x=MOUSEX
          y=MOUSEY
          k=MOUSEK
          IF y>yd+yma THEN
            y=yd+yma
          ENDIF
          IF y<yd+24 THEN
            y=yd+24
          ENDIF
          IF fadericht=0 THEN
            IF x>=xm AND x>xd+7 AND x<xd+255 THEN
              IF y>ym THEN
                y=ym
              ENDIF
              LINE xm,ym,x,y
              FOR i=xm TO x
                LINE i,yma,i,y
                fadeni(i-xd-8)=y-(yd+48)
              NEXT i
              xm=x
              ym=y
            ENDIF
          ELSE
            IF x>=xm AND x>xd+7 AND x<xd+255 THEN
              IF ym>y THEN
                y=ym
              ENDIF
              LINE xm,ym,x,y
              FOR i=xm TO x
                LINE i,yma,i,y
                fadeno(i-xd-8)=y-(yd+48)
              NEXT i
              xm=x
              ym=y
            ENDIF
          ENDIF
        UNTIL MOUSEK=0
        IF x<xd+255 THEN
          @rsc_back(nr)
          @rsc_draw(nr,5)
        ELSE
          '          FOR i=1 TO fadnr
          '           PRINT fadeni(i),
          '          NEXT i
          FOR i=1 TO fadnr-1
            LINE i+xd+8,fadeni(i)+yd+48,i+xd+9,fadeni(i+1)+yd+48
          NEXT i
        ENDIF
      ENDIF
      buttadr=zuadr+24*obj
      but=DPEEK(buttadr+6) AND 255
    UNTIL but=26 OR but=24 OR but=22
    IF obj<>fadeup& AND obj<>fadedown& AND obj<>fadeli& AND obj<>fadere& AND obj<>fadelin& THEN
      aw=FORM_BUTTON(boxadr,obj,1,a)
      REPEAT
      UNTIL MOUSEK=0
    ELSE
      @setbutton(obj,33)
      PAUSE 1
      @setbutton(obj,32)
    ENDIF
    PAUSE 1
    ~RSRC_GADDR(1,obj,objadr)
    objflag=DPEEK(objadr+8)
    IF obj=fadedown& THEN
      @fadedown
    ENDIF
    IF obj=fadeup& THEN
      @fadeup
    ENDIF
    IF obj=fadeli& THEN
      @fadelinks
    ENDIF
    IF obj=fadere& THEN
      @faderechts
    ENDIF
    IF obj=fadelin& THEN
      @fadelinear
    ENDIF
  UNTIL obj=fadeok&
  @setbutton(obj,32)
  @restaura2
  obj=0
  @setbutton(edfade&,0)
RETURN
'
> PROCEDURE fadelinear
  yw=222/fadnr
  IF fadericht=0 THEN
    ym=yd+248
    y=ym
    FOR i=1 TO fadnr
      LINE i+xd+8,ym,i+xd+9,y
      fadeni(i)=y-yd-48
      y=y-yw
    NEXT i
  ELSE
    ym=yd+248
    y=yd+25
    FOR i=1 TO fadnr
      LINE i+xd+8,ym,i+xd+9,y
      fadeno(i)=y-yd-48
      y=y+yw
    NEXT i
  ENDIF
RETURN
'
> PROCEDURE infade
  fadericht=0
  @rsc_back(nr)
  @rsc_draw(nr,5)
  @setbutton(ausfade&,0)
  @setbutton(infade&,1)
  '  ~OBJC_DRAW(boxadr,0,99,17,17,yma+20,yma-16)
  FOR i=1 TO fadnr
    y=fadeni(i)+yd+48
    IF y<>yd+48 THEN
      LINE i+xd+8,yma,i+xd+8,y-1
    ENDIF
  NEXT i
RETURN
'
> PROCEDURE ausfade
  fadericht=1
  @rsc_back(nr)
  @rsc_draw(nr,5)
  @setbutton(infade&,0)
  @setbutton(ausfade&,1)
  '  ~OBJC_DRAW(boxadr,0,99,17,17,yma+20,yma-16)
  FOR i=1 TO fadnr
    y=fadeno(i)+yd+48
    IF y<>yd+48 THEN
      LINE i+xd+8,yma,i+xd+8,y-1
    ENDIF
  NEXT i
RETURN
'
> PROCEDURE blocklook
  IF sms=1 THEN
    c1=stax
  ENDIF
  IF sms=2 THEN
    c1=stbx
  ENDIF
  IF sms=3 THEN
    c1=stcx
  ENDIF
  IF sms=4 THEN
    c1=stdx
  ENDIF
  IF sms=5 THEN
    c1=stex
  ENDIF
  IF sme=1 THEN
    c2=eax
  ENDIF
  IF sme=2 THEN
    c2=ebx
  ENDIF
  IF sme=3 THEN
    c2=ecx
  ENDIF
  IF sme=4 THEN
    c2=edx
  ENDIF
  IF sme=5 THEN
    c2=eex
  ENDIF
  dist=ce-cs
  IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 THEN
    mce=dist/xm*c2+cs+meml
    mce=INT(mce/4)*4
    mcs=dist/xm*c1+cs+meml
    mcs=INT(mcs/4)*4
  ENDIF
RETURN
'
> PROCEDURE smptime
  IF hrd=1 THEN
    @markhlp
    vornr=nr
    @rsc_back(nr)
    nr=record&
    @rsc_draw(nr,5)
    @markhlp
    min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
    @textfeld(timetxt&,min$,1)
    oldmin=min
    REPEAT
      REPEAT
        REPEAT
          obj=@rsc_do(nr,0,popup&)
          ~RSRC_GADDR(0,nr,zuadr)
        UNTIL obj<>0 AND obj<>-1
        buttadr=zuadr+24*obj
        but=DPEEK(buttadr+6)
        REPEAT
        UNTIL MOUSEK=0
        PAUSE 2
        ~RSRC_GADDR(1,obj,objadr)
        objflag=DPEEK(objadr+8)
      UNTIL obj=recexit& OR obj=recok& OR obj=recl1& OR obj=recl2& OR obj=recr1& OR obj=recr2&
      IF obj=recr1& OR obj=recr2& THEN
        IF obj=recr1& AND min<9999 THEN
          min=min+1
        ENDIF
        IF obj=recr2& AND min<9995 THEN
          min=min+5
        ENDIF
        min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
        @textfeld(timetxt&,min$,1)
      ENDIF
      IF obj=recl1& OR obj=recl2& THEN
        IF obj=recl1& AND min>1 THEN
          min=min-1
        ENDIF
        IF obj=recl2& AND min>5 THEN
          min=min-5
        ENDIF
        min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
        @textfeld(timetxt&,min$,1)
      ENDIF
      @setbutton(obj,0)
    UNTIL obj=recexit& OR obj=recok&
    @restaura2
    IF obj=recok& THEN
      min$=RIGHT$("00000"+STR$(min),5)
      min$=min$+" MIN"+CHR$(0)
      @textfeld(mintext&,min$,1)
    ELSE
      min=oldmin
    ENDIF
  ELSE
    obj=recok&
  ENDIF
RETURN
'
> PROCEDURE smpkhlp
  IF sms<>0 AND sme<>0 AND sms<6 AND sme<6 THEN
    @markhlp
    @blocklook
    IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 AND ((c<>0 AND xmp=-1) OR (c=0 AND xmp=0)) THEN
      @maschinit10
      IF mcs>=meml AND mce+4<memh AND c=1 THEN
        @maschruf10(mcs,mce,mce+4,memh)
        sms=1
        sme=1
        stax=c2
        eax=c2+(c2-c1)
        IF eax>xm THEN
          eax=c2
          stax=c1
        ENDIF
      ENDIF
      IF mcs>=meml AND mce+4<memh AND c=2 THEN
        mcg=memh-(mce-mcs)
        noms=0
        IF mcg>meml AND mcg>=mce THEN
          @maschruf10(mcs,mce,mcg,memh)
        ELSE
          noms=1
          mcg=mce
          @maschruf10(mcs,mce,mcg,memh)
        ENDIF
        sms=1
        sme=1
        stax=xm-(c2-c1)
        eax=xm
        IF noms=1 THEN
          eax=c2
          stax=c1
        ENDIF
      ENDIF
      IF mcs>meml AND c=-1 THEN
        mcd=mcs-(mce-mcs)
        IF mcd<meml THEN
          mcd=meml
          mcs=mce-(mcs-meml)
        ENDIF
        @maschruf10(mcs,mce,mcd,mcs)
        sms=1
        sme=1
        eax=c1
        stax=c1-(c2-c1)
        IF stax<0 THEN
          stax=c1
          eax=c2
        ENDIF
      ENDIF
      IF mcs>meml AND c=-2 THEN
        noms=0
        mcd=mcs-(mce-mcs)
        IF mcd<meml THEN
          noms=1
          mcd=meml
          mcs=mce-(mcs-meml)
        ELSE
          mcd=meml
        ENDIF
        @maschruf10(mcs,mce,mcd,mcs)
        sms=1
        sme=1
        eax=c2-c1
        stax=0
        IF noms=1 THEN
          stax=c1
          eax=c2
        ENDIF
      ENDIF
      IF xmp=0 AND c=0 THEN
        stax=c1+xmo
        eax=c2+xmo
        sms=1
        sme=1
        IF stax<0 THEN
          stax=0
          eax=c2-c1
        ENDIF
        IF eax>xm THEN
          eax=xm
          stax=eax-(c2-c1)
        ENDIF
        ncs=dist/xm*stax+cs+meml
        ncs=INT(ncs/4)*4
        nce=dist/xm*eax+cs+meml
        nce=INT(nce/4)*4
        IF ncs>=mce THEN
          @maschruf10(mcs,mce,ncs,memh)
        ENDIF
        IF ncs<mcs THEN
          @maschruf10(mcs,mce,ncs,mce)
        ENDIF
        IF ncs<mce AND ncs>mcs THEN
          @maschinit11
          @maschruf11(mce,mcs,nce)
        ENDIF
      ENDIF
      @restaura
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE smpmhlp
  IF sms<>0 AND sme<>0 AND sms<6 AND sme<6 THEN
    @markhlp
    @blocklook
    IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 AND ((c<>0 AND xmp=-1) OR (c=0 AND xmp=0)) THEN
      sms=1
      sme=1
      IF xmp=1 AND mcs>meml THEN
        BMOVE mcs,meml,mce-mcs
        @maschinit9
        IF mcs>meml+(mce-mcs) THEN
          @maschruf9(mcs,mce)
        ELSE
          @maschruf9(meml+(mce-mcs),mce)
        ENDIF
        stax=0
        eax=c2-c1
      ENDIF
      IF xmp=3 THEN
        BMOVE mcs,memh-(mce-mcs),mce-mcs
        @maschinit9
        IF mce<memh-(mce-mcs) THEN
          @maschruf9(mcs,mce)
        ELSE
          @maschruf9(mcs,memh-(mce-mcs))
        ENDIF
        eax=xm
        stax=eax-(c2-c1)
      ENDIF
      IF xmp=2 THEN
        m=((memh-meml)/2)+meml-((mce-mcs)/2)
        m=INT(m/4)*4
        BMOVE mcs,m,mce-mcs
        @maschinit9
        IF mcs>=m+(mce-mcs) OR mce<m THEN
          @maschruf9(mcs,mce)
        ENDIF
        IF mcs<m+(mce-mcs) AND mcs>=m AND mce>m+(mce-mcs) THEN
          @maschruf9(m+(mce-mcs),mce)
        ENDIF
        IF mcs<m AND mce>=m AND mce<m+(mce-mcs) THEN
          @maschruf9(mcs,m-1)
        ENDIF
        n=INT((c2-c1)/2)
        stax=INT(xm/2-n)
        eax=stax+(c2-c1)
      ENDIF
      IF xmp=0 THEN
        stax=c1+xmo
        eax=c2+xmo
        IF stax<0 THEN
          stax=0
          eax=c2-c1
        ENDIF
        IF eax>xm THEN
          eax=xm
          stax=eax-(c2-c1)
        ENDIF
        ncs=dist/xm*stax+cs+meml
        ncs=INT(ncs/4)*4
        BMOVE mcs,ncs,mce-mcs
        @maschinit9
        IF mcs>=ncs+(mce-mcs) OR mce<ncs THEN
          @maschruf9(mcs,mce)
        ENDIF
        IF mcs<ncs+(mce-mcs) AND mcs>=ncs AND mce>ncs+(mce-mcs) THEN
          @maschruf9(ncs+(mce-mcs),mce)
        ENDIF
        IF mcs<ncs AND mce>=ncs AND mce<ncs+(mce-mcs) THEN
          @maschruf9(mcs,ncs-1)
        ENDIF
      ENDIF
      @restaura
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE markprod2
  IF stax<>-1 THEN
    t$="A"
    @markhandler(stax,*stax,stay1,stay2,xd,ym)
    @markhlp3(stax,smptsa&)
  ENDIF
  IF stbx<>-1 THEN
    t$="B"
    @markhandler(stbx,*stbx,stay1,stay2,xd,ym)
    @markhlp3(stbx,smptsb&)
  ENDIF
  IF stcx<>-1 THEN
    t$="C"
    @markhandler(stcx,*stcx,stay1,stay2,xd,ym)
    @markhlp3(stcx,smptsc&)
  ENDIF
  IF stdx<>-1 THEN
    t$="D"
    @markhandler(stdx,*stdx,stay1,stay2,xd,ym)
    @markhlp3(stdx,smptsd&)
  ENDIF
  IF stex<>-1 THEN
    t$="E"
    @markhandler(stex,*stex,stay1,stay2,xd,ym)
    @markhlp3(stex,smptse&)
  ENDIF
  IF stfx<>-1 THEN
    t$="S"
    @markhandler(stfx,*stfx,stay1,stay2,xd,ym)
    @markhlp3(stfx,smptsava&)
  ENDIF
  IF eax<>-1 THEN
    t$="A"
    @markhandler(eax,*eax,stay1,stay2,xd,ym)
    @markhlp3(eax,smptea&)
  ENDIF
  IF ebx<>-1 THEN
    t$="B"
    @markhandler(ebx,*ebx,stay1,stay2,xd,ym)
    @markhlp3(ebx,smpteb&)
  ENDIF
  IF ecx<>-1 THEN
    t$="C"
    @markhandler(ecx,*ecx,stay1,stay2,xd,ym)
    @markhlp3(ecx,smptec&)
  ENDIF
  IF edx<>-1 THEN
    t$="D"
    @markhandler(edx,*edx,stay1,stay2,xd,ym)
    @markhlp3(edx,smpted&)
  ENDIF
  IF eex<>-1 THEN
    t$="E"
    @markhandler(eex,*eex,stay1,stay2,xd,ym)
    @markhlp3(eex,smptee&)
  ENDIF
  IF efx<>-1 THEN
    t$="S"
    @markhandler(efx,*efx,stay1,stay2,xd,ym)
    @markhlp3(efx,smptsavb&)
  ENDIF
  '  @rsc_back(nr)
  ' @rsc_draw(nr,5)
RETURN
'
> PROCEDURE markprod3
  IF stax<>-1 THEN
    t$="A"
    @markhlp3(stax,smptsa&)
    @smpsta
    @markhlp5(stax)
  ENDIF
  IF stbx<>-1 THEN
    t$="B"
    @markhlp3(stbx,smptsb&)
    @smpstb
    @markhlp5(stbx)
  ENDIF
  IF stcx<>-1 THEN
    t$="C"
    @markhlp3(stcx,smptsc&)
    @smpstc
    @markhlp5(stcx)
  ENDIF
  IF stdx<>-1 THEN
    t$="D"
    @markhlp3(stdx,smptsd&)
    @smpstd
    @markhlp5(stdx)
  ENDIF
  IF stex<>-1 THEN
    t$="E"
    @markhlp3(stex,smptse&)
    @smpste
    @markhlp5(stex)
  ENDIF
  IF stfx<>-1 THEN
    t$="S"
    @markhlp3(stfx,smptsava&)
    @smpstf
    @markhlp5(stfx)
  ENDIF
  IF eax<>-1 THEN
    t$="A"
    @markhlp3(eax,smptea&)
    @smpea
    @markhlp5(eax)
  ENDIF
  IF ebx<>-1 THEN
    t$="B"
    @markhlp3(ebx,smpteb&)
    @smpeb
    @markhlp5(ebx)
  ENDIF
  IF ecx<>-1 THEN
    t$="C"
    @markhlp3(ecx,smptec&)
    @smpec
    @markhlp5(ecx)
  ENDIF
  IF edx<>-1 THEN
    t$="D"
    @markhlp3(edx,smpted&)
    @smped
    @markhlp5(edx)
  ENDIF
  IF eex<>-1 THEN
    t$="E"
    @markhlp3(eex,smptee&)
    @smpee
    @markhlp5(eex)
  ENDIF
  IF efx<>-1 THEN
    t$="S"
    @markhlp3(efx,smptsavb&)
    @smpef
    @markhlp5(efx)
  ENDIF
RETURN
'
> PROCEDURE smph2
  IF master=1 THEN
    t$="A"
    @markhandl2(stax,*stax,stay1,stay2,xd,ym)
    @markhlp3(stax,smptsa&)
  ENDIF
  IF master=2 THEN
    t$="B"
    @markhandl2(stbx,*stbx,stay1,stay2,xd,ym)
    @markhlp3(stbx,smptsb&)
  ENDIF
  IF master=3 THEN
    t$="C"
    @markhandl2(stcx,*stcx,stay1,stay2,xd,ym)
    @markhlp3(stcx,smptsc&)
  ENDIF
  IF master=4 THEN
    t$="D"
    @markhandl2(stdx,*stdx,stay1,stay2,xd,ym)
    @markhlp3(stdx,smptsd&)
  ENDIF
  IF master=5 THEN
    t$="E"
    @markhandl2(stex,*stex,stay1,stay2,xd,ym)
    @markhlp3(stex,smptse&)
  ENDIF
  IF master=6 THEN
    t$="A"
    @markhandl2(eax,*eax,stay1,stay2,xd,ym)
    @markhlp3(eax,smptea&)
  ENDIF
  IF master=7 THEN
    t$="B"
    @markhandl2(ebx,*ebx,stay1,stay2,xd,ym)
    @markhlp3(ebx,smpteb&)
  ENDIF
  IF master=8 THEN
    t$="C"
    @markhandl2(ecx,*ecx,stay1,stay2,xd,ym)
    @markhlp3(ecx,smptec&)
  ENDIF
  IF master=9 THEN
    t$="D"
    @markhandl2(edx,*edx,stay1,stay2,xd,ym)
    @markhlp3(edx,smpted&)
  ENDIF
  IF master=10 THEN
    t$="E"
    @markhandl2(eex,*eex,stay1,stay2,xd,ym)
    @markhlp3(eex,smptee&)
  ENDIF
  IF master=11 THEN
    t$="S"
    @markhandl2(stfx,*stfx,stay1,stay2,xd,ym)
    @markhlp3(stfx,smptsava&)
  ENDIF
  IF master=12 THEN
    t$="S"
    @markhandl2(efx,*efx,stay1,stay2,xd,ym)
    @markhlp3(efx,smptsavb&)
  ENDIF
RETURN
'
> PROCEDURE smpanf
  IF smark=6 THEN
    xmo=0
    xmp=1
    @smpmhlp
  ENDIF
  IF smark=5 THEN
    c=-2
    @smpkhlp
  ENDIF
  IF smark=4 THEN
    min=1
    min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
    @textfeld(recmin&,min$,1)
  ENDIF
  IF smark=3 THEN
    @smph1
    x=0
    @smph2
  ENDIF
  IF smark=2 THEN
    lz=1
    @zoomhelp
  ENDIF
  @setbutton(smpanf&,0)
RETURN
'
> PROCEDURE smpend
  IF smark=6 THEN
    xmp=3
    xmo=xm
    @smpmhlp
  ENDIF
  IF smark=5 THEN
    c=2
    @smpkhlp
  ENDIF
  IF smark=4 THEN
    min=9999
    min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
    @textfeld(recmin&,min$,1)
  ENDIF
  IF smark=3 THEN
    @smph1
    x=xm
    @smph2
  ENDIF
  IF smark=2 THEN
    lz=lzmrk
    @zoomhelp
  ENDIF
  @setbutton(smpend&,0)
RETURN
'
> PROCEDURE smpmid
  IF smark=6 THEN
    xmo=xm/2
    xmp=2
    @smpmhlp
  ENDIF
  IF smark=4 THEN
    min=5000
    min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
    @textfeld(recmin&,min$,1)
  ENDIF
  IF smark=3 THEN
    @smph1
    x=xm/2
    @smph2
  ENDIF
  IF smark=2 THEN
    lz=INT(lzmrk/2)
    IF lz=0 THEN
      lz=1
    ENDIF
    @zoomhelp
  ENDIF
  @setbutton(smpmid&,0)
RETURN
'
> PROCEDURE zoomhelp
  cs=lcs(lz)
  ce=lce(lz)
  @markhlp
  IF sms=1 THEN
    stax=ls(lz)
  ENDIF
  IF sms=2 THEN
    stbx=ls(lz)
  ENDIF
  IF sms=3 THEN
    stcx=ls(lz)
  ENDIF
  IF sms=4 THEN
    stdx=ls(lz)
  ENDIF
  IF sms=5 THEN
    stex=ls(lz)
  ENDIF
  IF sme=1 THEN
    eax=le(lz)
  ENDIF
  IF sme=2 THEN
    ebx=le(lz)
  ENDIF
  IF sme=3 THEN
    ecx=le(lz)
  ENDIF
  IF sme=4 THEN
    edx=le(lz)
  ENDIF
  IF sme=5 THEN
    eex=le(lz)
  ENDIF
  IF xm>0 AND ce>cs THEN
    @restaura
  ENDIF
RETURN
'
> PROCEDURE smpl
  @markhlp
  c=0
  IF smark=6 THEN
    xmp=0
    IF obj=smpl1& THEN
      xmo=-1
    ENDIF
    IF obj=smpl2& THEN
      xmo=-5
    ENDIF
    IF obj=smpl3& THEN
      xmo=-10
    ENDIF
    @smpmhlp
  ENDIF
  IF smark=5 THEN
    IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
      c=-1
    ENDIF
    @smpkhlp
  ENDIF
  IF smark=3 THEN
    IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
      @smph1
      IF obj=smpl1& THEN
        x=x-1
      ENDIF
      IF obj=smpl2& THEN
        x=x-3
      ENDIF
      IF obj=smpl3& THEN
        x=x-10
      ENDIF
      @smph2
    ENDIF
  ENDIF
  IF smark=2 THEN
    IF lz>1 THEN
      @smph1
      IF obj=smpl1& THEN
        xs=1
      ENDIF
      IF obj=smpl2& THEN
        xs=2
      ENDIF
      IF obj=smpl3& THEN
        xs=3
      ENDIF
      IF lz>xs THEN
        lz=lz-xs
        @zoomhelp
      ENDIF
    ENDIF
  ENDIF
  IF smark=1 THEN
    IF obj=smpl1& THEN
      xs=(ce-cs)/4
    ENDIF
    IF obj=smpl2& THEN
      xs=(ce-cs)/2
    ENDIF
    IF obj=smpl3& THEN
      xs=ce-cs
    ENDIF
    IF cs-xs>0 THEN
      cs=cs-xs
      cs=INT(cs/4)*4
      ce=ce-xs
      ce=INT(ce/4)*4
    ELSE
      u=cs
      cs=0
      ce=ce-u
      ce=INT(ce/4)*4
    ENDIF
    @restaura
  ENDIF
RETURN
'
> PROCEDURE smpr
  @markhlp
  c=0
  IF smark=6 THEN
    xmp=0
    IF obj=smpr1& THEN
      xmo=1
    ENDIF
    IF obj=smpr2& THEN
      xmo=5
    ENDIF
    IF obj=smpr3& THEN
      xmo=10
    ENDIF
    @smpmhlp
  ENDIF
  IF smark=5 THEN
    IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
      c=1
    ENDIF
    @smpkhlp
  ENDIF
  IF smark=3 THEN
    IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
      @smph1
      IF obj=smpr1& THEN
        x=x+1
      ENDIF
      IF obj=smpr2& THEN
        x=x+3
      ENDIF
      IF obj=smpr3& THEN
        x=x+10
      ENDIF
      @smph2
    ENDIF
  ENDIF
  IF smark=2 THEN
    IF lz<lmax THEN
      @smph1
      IF obj=smpr1& THEN
        xs=1
        xmul=1.5
      ENDIF
      IF obj=smpr2& THEN
        xs=1
        xmul=2
      ENDIF
      IF obj=smpr3& THEN
        xs=1
        xmul=3
      ENDIF
      IF lz+xs<lmax THEN
        lcs(lz)=cs
        lce(lz)=ce
        @markhlp
        IF sms=1 THEN
          dcs=stax
          stax=0
        ENDIF
        IF sms=2 THEN
          dcs=stbx
          stbx=0
        ENDIF
        IF sms=3 THEN
          dcs=stcx
          stcx=0
        ENDIF
        IF sms=4 THEN
          dcs=stdx
          stdx=0
        ENDIF
        IF sms=5 THEN
          dcs=stex
          stex=0
        ENDIF
        IF sme=1 THEN
          dce=eax
          eax=xm
        ENDIF
        IF sme=2 THEN
          dce=ebx
          ebx=xm
        ENDIF
        IF sme=3 THEN
          dce=ecx
          ecx=xm
        ENDIF
        IF sme=4 THEN
          dce=edx
          edx=xm
        ENDIF
        IF sme=5 THEN
          dce=eex
          eex=xm
        ENDIF
        IF sms=0 THEN
          dcs=0
        ENDIF
        IF sme=0 THEN
          dce=xm
        ENDIF
        ls(lz)=dcs
        le(lz)=dce
        lz=lz+xs
        lzmrk=lz
        IF dcs=0 AND dce=xm THEN
          dce=xm/xmul
        ENDIF
        dist=ce-cs
        IF xm>0 THEN
          ce=dist/xm*dce+cs
          ce=INT(ce/4)*4
          cs=dist/xm*dcs+cs
          cs=INT(cs/4)*4
        ENDIF
        lcs(lz)=cs
        lce(lz)=ce
        ls(lz)=0
        le(lz)=xm
        IF xm>0 AND ce>cs THEN
          @restaura
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  IF smark=1 THEN
    IF obj=smpr1& THEN
      xs=(ce-cs)/4
    ENDIF
    IF obj=smpr2& THEN
      xs=(ce-cs)/2
    ENDIF
    IF obj=smpr3& THEN
      xs=ce-cs
    ENDIF
    IF ce+xs<mlen THEN
      cs=cs+xs
      cs=INT(cs/4)*4
      ce=ce+xs
      ce=INT(ce/4)*4
    ELSE
      u=mlen-ce
      cs=cs+u
      cs=INT(cs/4)*4
      ce=ce+u
      ce=INT(ce/4)*4
    ENDIF
    @restaura
  ENDIF
RETURN
'
> PROCEDURE smpcut
  vornr=nr
  @rsc_back(nr)
  nr=cutedit&
  @rsc_draw(nr,5)
  @markhlp
  REPEAT
    REPEAT
      obj=@rsc_do(nr,0,popup&)
      ~RSRC_GADDR(0,nr,zuadr)
    UNTIL obj<>0 AND obj<>-1
    buttadr=zuadr+24*obj
    but=DPEEK(buttadr+6)
    REPEAT
    UNTIL MOUSEK=0
    PAUSE 2
    ~RSRC_GADDR(1,obj,objadr)
    objflag=DPEEK(objadr+8)
  UNTIL obj=cutexit& OR obj=cutin& OR obj=cutout&
  @setbutton(obj,0)
  @restaura2
  IF sms<>0 AND sme<>0 AND sms<6 AND sme<6 AND obj<>cutexit& THEN
    @markhlp
    @blocklook
    IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 THEN
      @maschinit9
      IF obj=cutout& THEN
        IF mcs>meml THEN
          @maschruf9(meml,mcs)
        ENDIF
        IF memh>mce THEN
          @maschruf9(mce,memh)
        ENDIF
      ELSE
        @maschruf9(mcs,mce)
      ENDIF
    ENDIF
    @restaura
  ENDIF
  obj=0
  @setbutton(cut&,0)
RETURN
'
> PROCEDURE markhandl4
  y=MOUSEY
  IF y>=stay1 AND y<=stay2 THEN
    IF smark=6 OR smark=5 THEN
      xmp=0
      c=0
    ENDIF
    tx=x-(x-c1)
    tx2=x+(c2-x)
    tm=tx
    tm2=tx2
    COLOR 0
    FOR i=c1-5 TO c1+5
      LINE i+xd,stay1+1,i+xd,stay1-5
    NEXT i
    FOR i=c2-5 TO c2+5
      LINE i+xd,stay1+1,i+xd,stay1-5
    NEXT i
    COLOR 1
    d1=x-c1
    d2=c2-x
    REPEAT
      x=MOUSEX
      y=MOUSEY
      k=MOUSEK
      IF x-d1>=0 AND x+d2<=xm AND y>=stay1 AND y<=stay2 AND x<>x2 THEN
        ALINE tx+xd,stay1+1,tx+xd,stay2,1,&HFFFF,2
        ALINE tx2+xd,stay1+1,tx2+xd,stay2,1,&HFFFF,2
        tx=x-d1
        tx2=x+d2
        x2=x
        ALINE tx+xd,stay1+1,tx+xd,stay2,1,&HFFFF,2
        ALINE tx2+xd,stay1+1,tx2+xd,stay2,1,&HFFFF,2
      ENDIF
    UNTIL k=0
    TEXT tx+xd-3,stay1,t$
    TEXT tx2+xd-3,stay1,t2$
  ENDIF
RETURN
'
> PROCEDURE edhandler2
  xmp=-1
  c=0
  k=MOUSEK
  IF k=1 THEN
    @markhlp
    x=MOUSEX
    y=MOUSEY
    IF smark=6 OR smark=5 THEN
      IF sms=1 THEN
        c1=stax
        t$="A"
      ENDIF
      IF sms=2 THEN
        c1=stbx
        t$="B"
      ENDIF
      IF sms=3 THEN
        c1=stcx
        t$="C"
      ENDIF
      IF sms=4 THEN
        c1=stdx
        t$="D"
      ENDIF
      IF sms=5 THEN
        c1=stex
        t$="E"
      ENDIF
      IF sme=1 THEN
        c2=eax
        t2$="A"
      ENDIF
      IF sme=2 THEN
        c2=ebx
        t2$="B"
      ENDIF
      IF sme=3 THEN
        c2=ecx
        t2$="C"
      ENDIF
      IF sme=4 THEN
        c2=edx
        t2$="D"
      ENDIF
      IF sme=5 THEN
        c2=eex
        t2$="E"
      ENDIF
      IF x>=c1+xd AND x<=c2+xd THEN
        @markhandl4
        IF sms=1 THEN
          stax=c1
        ENDIF
        IF sms=2 THEN
          stbx=c1
        ENDIF
        IF sms=3 THEN
          stcx=c1
        ENDIF
        IF sms=4 THEN
          stdx=c1
        ENDIF
        IF sms=5 THEN
          stex=c1
        ENDIF
        IF sme=1 THEN
          eax=c2
        ENDIF
        IF sme=2 THEN
          ebx=c2
        ENDIF
        IF sme=3 THEN
          ecx=c2
        ENDIF
        IF sme=4 THEN
          edx=c2
        ENDIF
        IF sme=5 THEN
          eex=c2
        ENDIF
        IF smark=5 THEN
          xmo=tx-tm
          @smpkhlp
        ENDIF
        IF smark=6 THEN
          xmo=tx-tm
          @smpmhlp
        ENDIF
      ENDIF
    ENDIF
    IF smark=1 OR smark=2 OR smark=3 OR smark=4 THEN
      @markprod2
      xmp=0
      c=0
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE blkstest
  IF master=0 AND shlp=1 THEN
    blksa=meml
    blkse=smrk
  ELSE
    @markhlp
    c1=stfx
    c2=efx
    dist=ce-cs
    blkse=dist/xm*c2+cs+meml
    blkse=INT(blkse/4)*4
    blksa=dist/xm*c1+cs+meml
    blksa=INT(blksa/4)*4
  ENDIF
RETURN
'
> PROCEDURE smpsave
  @markhlp
  vornr=nr
  @rsc_back(nr)
  nr=savebloc&
  @rsc_draw(nr,5)
  @markhlp
  REPEAT
    REPEAT
      obj=@rsc_do(nr,0,popup&)
      ~RSRC_GADDR(0,nr,zuadr)
    UNTIL obj<>0 AND obj<>-1
    buttadr=zuadr+24*obj
    but=DPEEK(buttadr+6)
    REPEAT
    UNTIL MOUSEK=0
    PAUSE 2
    ~RSRC_GADDR(1,obj,objadr)
    objflag=DPEEK(objadr+8)
  UNTIL obj=savexit& OR obj=savall& OR obj=savblock&
  IF obj=savall& THEN
    blks=0
  ENDIF
  IF obj=savblock& THEN
    blks=1
  ENDIF
  @setbutton(obj,0)
  @restaura2
  IF obj<>savexit& THEN
    @blkstest
    @makehz
    IF sms>5 THEN
      sms=msms
    ENDIF
    IF sme>5 THEN
      sme=msme
    ENDIF
    head=20
    @maschinit
    IF big=0 THEN
      IF blks=0 THEN
        anfloadx=MALLOC(mlen+&H200)
      ELSE
        anfloadx=MALLOC((blkse-blksa)+&H200)
      ENDIF
    ELSE
      IF blks=0 THEN
        anfloadx=meml
      ELSE
        anfloadx=blksa
      ENDIF
    ENDIF
    IF anfloadx<>0 AND anfloadx<>-1 THEN
      IF big=0 THEN
        datx=((INT(anfloadx/4))*4)+4
      ELSE
        datx=anfloadx
      ENDIF
      d$=SPACE$(100)
      danf=VARPTR(d$)                   !Anfang Header
      danf=INT(danf/2)*2+2
      '    GET xwidth/2-170,ywidth/2-170,xwidth/2+170,ywidth/2+170,cb$
      FILESELECT op$+"*.SMP",mp$,path$
      '   PUT xwidth/2-170,ywidth/2-170,cb$
      rp$=path$
      IF path$<>"" AND RIGHT$(path$,1)<>"\" THEN
        IF blks=0 THEN
          a=meml
          l=mlen
        ELSE
          a=blksa
          l=blkse-blksa
        ENDIF
        b=datx
        IF big=0 THEN
          @maschruf
        ENDIF
        REPEAT
          g=INSTR(path$,"\")
          IF g>0 THEN
            path$=RIGHT$(path$,(LEN(path$)-g))
          ENDIF
          g2=INSTR(path$,":")
          IF g2>0 THEN
            path$=RIGHT$(path$,(LEN(path$)-g2))
          ENDIF
        UNTIL g=0 AND g2=0
        IF INSTR(path$,".")=0 THEN
          path$=path$+".SMP"
        ENDIF
        IF INSTR(rp$,".")=0 THEN
          rp$=rp$+".SMP"
        ENDIF
        mp$=path$
        DPOKE danf,&HF07E                      ! SDS-Startkennung
        POKE danf+2,1                            ! MIDI-Kanalnummer
        POKE danf+3,1
        DPOKE danf+4,&H100                       ! Sample-Nr.
        POKE danf+6,16                           ! Bits
        per=10^9/hz
        x=INT(per/65536)
        y=per-x*65536
        POKE danf+7,x                            ! Periodendauer eines Samples
        DPOKE danf+8,y                           ! Periodendauer eines Samples
        IF blks=0 THEN
          mlh=INT(mlen/2)
        ELSE
          mlh=INT((blkse-blksa)/2)
        ENDIF
        x2=INT(mlh/256)
        y2=mlh-x2*256
        DPOKE danf+10,x2                          ! Sample Len in Worten
        POKE danf+12,y2                           ! Sample Len in Worten
        @markhlp
        IF sms=1 THEN
          lmin=stax
        ENDIF
        IF sms=2 THEN
          lmin=stbx
        ENDIF
        IF sms=3 THEN
          lmin=stcx
        ENDIF
        IF sms=4 THEN
          lmin=stdx
        ENDIF
        IF sms=5 THEN
          lmin=stex
        ENDIF
        IF sme=1 THEN
          lma=eax
        ENDIF
        IF sme=2 THEN
          lma=ebx
        ENDIF
        IF sme=3 THEN
          lma=ecx
        ENDIF
        IF sme=4 THEN
          lma=edx
        ENDIF
        IF sme=5 THEN
          lma=eex
        ENDIF
        IF blks=0 THEN
          lmin=mlen/xm*lmin
          lmin=INT(lmin/4)*4
          lma=mlen/xm*lma
          lma=INT(lma/4)*4
        ELSE
          dist=blkse-blksa
          lmin=mlen/xm*lmin
          lmin=lmin-(blksa-meml)
          lmin=INT(lmin/4)*4
          lma=mlen/xm*lma
          lma=lma-(blksa-meml)
          lma=INT(lma/4)*4
        ENDIF
        x3=INT(lmin/65536)
        y3=lmin-x3*65536
        POKE danf+13,x3                           ! Sustain Loop-Start
        DPOKE danf+14,y3                          ! Sustain Loop-Start
        x4=INT(lma/256)
        y4=lma-x4*256
        DPOKE danf+16,x4                          ! Sustain Loop-End
        POKE danf+18,y4                           ! Sustain Loop-End
        IF sret=0 THEN
          la=0
        ELSE
          la=1
        ENDIF
        IF sblock=0 THEN
          la=&H7F
        ENDIF
        POKE danf+19,la                           ! Loop-Art
        '      POKE danf+20,&HF7                         ! SDS-Endkennung
        '
        OPEN "O",#1,rp$
        BPUT #1,danf,head
        IF blks=0 THEN
          BPUT #1,datx,mlen
        ELSE
          BPUT #1,datx,blkse-blksa
        ENDIF
        CLOSE #1
        path$=SPACE$(6)+path$+SPACE$(6)
        path$=MID$(path$,INT(LEN(path$)/2)-5,12)
        @textfeld(smpfile&,path$,1)
      ENDIF
    ENDIF
    IF big=0 AND anfloadx<>0 THEN
      ~MFREE(anfloadx)
    ENDIF
    @restaura
  ENDIF
  @setbutton(smpsave&,0)
RETURN
'
> PROCEDURE restaura
  IF nr=smpedit& THEN
    @rsc_back(nr)
    @rsc_draw(nr,5)
    @curve(cs,ce)
    @markprod3
  ENDIF
RETURN
'
> PROCEDURE restaura2
  @rsc_back(nr)
  nr=vornr
  @rsc_draw(nr,5)
  @curve(cs,ce)
  @markprod3
RETURN
'
> PROCEDURE smpload
  pathmrk$=path$
  lnmrk=ln
  memlmrk=meml
  secmrk=sec
  @ldhlp
  IF anfloadx<>0 AND anfloadx<>-1 AND (ln-abz)<=mlen AND lready=1 THEN
    IF path$<>"" AND RIGHT$(path$,1)<>"\" AND pathda=TRUE THEN
      @textfeld(smpfile&,path$,1)
      mem$=RIGHT$("00000000"+STR$(ln),8)
      mem$="LEN "+mem$+" BYTES"+CHR$(0)
      @textfeld(smplen&,mem$,1)
      sec=INT(ln/(hz*4))+1
      mem$=RIGHT$("00000000"+STR$(sec),8)
      mem$="IST CA."+mem$+" SEC"+CHR$(0)
      @textfeld(smpsec&,mem$,1)
      @curve(cs,ce)
      '
      '
      IF sblock=1 THEN
        ALINE eax+xd,stay1,eax+xd,stay2,1,&HFFFF,2
        TEXT eax+xd-3,stay1,"A"
        ALINE stax+xd,stay1,stax+xd,stay2,1,&HFFFF,2
        TEXT stax+xd-3,stay1,"A"
      ENDIF
      IF hz=32000 THEN
        a$=@rsc_text$(popups&,2)
        @textfeld(rate&,a$,1)
        @adlow
      ENDIF
      IF hz=44100 THEN
        a$=@rsc_text$(popups&,3)
        @textfeld(rate&,a$,1)
        @admid
      ENDIF
      IF hz=48000 THEN
        a$=@rsc_text$(popups&,4)
        @textfeld(rate&,a$,1)
        @adhigh
      ENDIF
    ELSE
      @restaura
    ENDIF
  ELSE
    @restaura
  ENDIF
  @setbutton(smpload&,0)
RETURN
'
> PROCEDURE blkltest
  @markhlp
  IF master=0 THEN
    bstart=0
  ENDIF
  IF master=1 THEN
    bstart=stax
  ENDIF
  IF master=2 THEN
    bstart=stbx
  ENDIF
  IF master=3 THEN
    bstart=stcx
  ENDIF
  IF master=4 THEN
    bstart=stdx
  ENDIF
  IF master=5 THEN
    bstart=stex
  ENDIF
  IF master=6 THEN
    bstart=eax
  ENDIF
  IF master=7 THEN
    bstart=ebx
  ENDIF
  IF master=8 THEN
    bstart=ecx
  ENDIF
  IF master=9 THEN
    bstart=edx
  ENDIF
  IF master=10 THEN
    bstart=eex
  ENDIF
  dist=ce-cs
  bstart=dist/xm*bstart+cs+meml
  bstart=INT(bstart/4)*4
RETURN
'
> PROCEDURE ldhlp
  retime=0
  shlp=0
  lready=0
  cs=0
  ce=mlen-1
  ERASE ls()
  ERASE le()
  ERASE lcs()
  ERASE lce()
  DIM ls(lmax)
  DIM le(lmax)
  DIM lcs(lmax)
  DIM lce(lmax)
  head=20
  @maschinit
  '  GET xwidth/2-170,ywidth/2-170,xwidth/2+170,ywidth/2+170,cb$
  FILESELECT op$+"*.SMP","",path$
  ' PUT xwidth/2-170,ywidth/2-170,cb$
  pathda=EXIST(path$)
  IF path$<>"" AND RIGHT$(path$,1)<>"\" AND pathda=TRUE THEN
    d$=SPACE$(8)
    datx=VARPTR(d$)
    datx=INT(datx/2)*2+2
    OPEN "I",#1,path$
    ln=LOF(#1)
    BGET #1,datx,2
    CLOSE #1
    @blkltest
    IF big=0 THEN
      anfloadx=MALLOC(ln+&H200)
    ELSE
      IF blks=0 THEN
        anfloadx=meml
        mt=memh-meml
        @maschinit9
        @maschruf9(meml,memh)
      ELSE
        anfloadx=bstart
        mt=memh-bstart
      ENDIF
    ENDIF
    abz=DPEEK(datx)
    IF abz=&HF07E THEN
      abz=head
    ELSE
      abz=0
    ENDIF
    IF anfloadx<>0 AND anfloadx<>-1 AND (ln-abz)<=mt THEN
      lready=1
      ln2=ln
      pam$=path$
      @markdel
      path$=pam$
      ln=ln2
      datx=((INT(anfloadx/4))*4)+4
      OPEN "I",#1,path$
      BGET #1,datx,head
      lded=1
      @clsed
      danf=datx
      IF DPEEK(datx)=&HF07E THEN
        @markhlp
        a=datx
        '
        x=PEEK(danf+7)                            ! Periodendauer eines Samples
        y=DPEEK(danf+8)                           ! Periodendauer eines Samples
        x2=DPEEK(danf+10)                          ! Sample Len in Worten
        y2=PEEK(danf+12)                           ! Sample Len in Worten
        ldlen=(x2*256+y2)*2
        per=INT(10^9/(x*65536+y))
        perm=INT(per)
        per=INT(per/1000)
        IF per=32 THEN
          hz=32000
          sec=INT(mlen/(hz*4))+1
          IF nr=smp16& THEN
            @deladbutt
            a$=@rsc_text$(popups&,2)
            @textfeld(rate&,a$,1)
          ENDIF
          @adlow
        ENDIF
        IF per=44 THEN
          hz=44100
          sec=INT(mlen/(hz*4))+1
          IF nr=smp16& THEN
            @deladbutt
            a$=@rsc_text$(popups&,3)
            @textfeld(rate&,a$,1)
          ENDIF
          @admid
        ENDIF
        IF per=48 THEN
          hz=48000
          sec=INT(mlen/(hz*4))+1
          IF nr=smp16& THEN
            @deladbutt
            a$=@rsc_text$(popups&,4)
            @textfeld(rate&,a$,1)
          ENDIF
          @adhigh
        ENDIF
        IF per<>32 AND per<>44 AND per<>48 THEN
          retime=1
          hz=perm
          p$=STR$(hz/1000)+CHR$(0)
          IF nr=smpedit& THEN
            @textfeld(smprate&,p$,1)
          ENDIF
          hzm=hz
          sec=INT(mlen/(hz*4))+1
          IF nr=smp16& THEN
            @deladbutt
          ENDIF
        ELSE
          p$="    "+CHR$(0)
          IF nr=smpedit& THEN
            @textfeld(smprate&,p$,1)
          ENDIF
        ENDIF
        la=PEEK(danf+19)                           ! Loop-Art
        sblock=1
        IF la=0 THEN
          sret=0
        ENDIF
        IF la=1 THEN
          sret=1
        ENDIF
        IF la=&H7F THEN
          sblock=0
        ENDIF
        IF nr=smpedit& THEN
          IF sblock=0 THEN
            @setbutton(smppmark&,0)
          ELSE
            @setbutton(smppmark&,1)
          ENDIF
        ENDIF
        IF sblock=1 THEN
          x3=PEEK(danf+13)                           ! Sustain Loop-Start
          y3=DPEEK(danf+14)                          ! Sustain Loop-Start
          lmin=x3*65536+y3
          x4=DPEEK(danf+16)                          ! Sustain Loop-End
          y4=PEEK(danf+18)                           ! Sustain Loop-End
          lma=x4*256+y4
          sms=1
          sme=1
          master=0
          ah=xm/mlen*lma
          ah=INT(ah)
          eax=ah
          t$="A"
          IF nr=smpedit& THEN
            @markhlp3(eax,smptea&)
            @smpea
          ENDIF
          ah=xm/mlen*lmin
          ah=INT(ah)
          stax=ah
          t$="A"
          IF nr=smpedit& THEN
            @markhlp3(stax,smptsa&)
            @smpsta
            @setbutton(smpsta&,1)
            @setbutton(smpea&,1)
          ENDIF
        ELSE
          okmark=0
          sms=0
          sme=0
        ENDIF
        BGET #1,datx,ln-head
        CLOSE #1
      ELSE
        BGET #1,datx+head,ln-head
        CLOSE #1
        a=datx
        okmark=0
        sms=0
        sme=0
      ENDIF
      a=datx
      IF blks=0 THEN
        b=meml
        l=memh-meml
        shlp=1
        smrk=meml+(ln-head)
        smrk=INT(smrk/4)*4
      ELSE
        shlp=0
        b=bstart
        l=memh-bstart
      ENDIF
      IF big=0 THEN
        @maschruf
      ENDIF
      IF nr=smpedit& THEN
        @rsc_back(nr)
        @rsc_draw(nr,5)
      ENDIF
      REPEAT
        g=INSTR(path$,"\")
        IF g>0 THEN
          path$=RIGHT$(path$,(LEN(path$)-g))
        ENDIF
        g2=INSTR(path$,":")
        IF g2>0 THEN
          path$=RIGHT$(path$,(LEN(path$)-g2))
        ENDIF
      UNTIL g=0 AND g2=0
      mp$=path$
      path$=SPACE$(6)+path$+SPACE$(6)
      path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
    ELSE
      ln=lnmrk
      path$=pathmrk$
      meml=memlmrk
      sec=secmrk
      IF nr=smpedit& THEN
        path$=SPACE$(6)+path$+SPACE$(6)
        path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
        @textfeld(smpfile&,path$,1)
        mem$=RIGHT$("00000000"+STR$(ln),8)
        mem$="LEN "+mem$+" BYTES"+CHR$(0)
        @textfeld(smplen&,mem$,1)
        mem$=RIGHT$("00000000"+STR$(sec),8)
        mem$="IST CA."+mem$+" SEC"+CHR$(0)
        @textfeld(smpsec&,mem$,1)
      ENDIF
    ENDIF
    IF big=0 AND anfloadx<>0 THEN
      ~MFREE(anfloadx)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE clsed
  mem$="     "+CHR$(0)
  hac$=" "+CHR$(0)
  IF nr=smpedit& THEN
    @textfeld(smptsa&,mem$,1)
    @textfeld(smptsb&,mem$,1)
    @textfeld(smptsc&,mem$,1)
    @textfeld(smptsd&,mem$,1)
    @textfeld(smptse&,mem$,1)
    @textfeld(smptea&,mem$,1)
    @textfeld(smpteb&,mem$,1)
    @textfeld(smptec&,mem$,1)
    @textfeld(smpted&,mem$,1)
    @textfeld(smptee&,mem$,1)
    @textfeld(hacksa&,hac$,1)
    @textfeld(hacksb&,hac$,1)
    @textfeld(hacksc&,hac$,1)
    @textfeld(hacksd&,hac$,1)
    @textfeld(hackse&,hac$,1)
    @textfeld(hackea&,hac$,1)
    @textfeld(hackeb&,hac$,1)
    @textfeld(hackec&,hac$,1)
    @textfeld(hacked&,hac$,1)
    @textfeld(hackee&,hac$,1)
    @setbutton(smpsta&,0)
    @setbutton(smpstb&,0)
    @setbutton(smpstc&,0)
    @setbutton(smpstd&,0)
    @setbutton(smpste&,0)
    @setbutton(smpea&,0)
    @setbutton(smpeb&,0)
    @setbutton(smpec&,0)
    @setbutton(smped&,0)
    @setbutton(smpee&,0)
  ENDIF
  sms=0
  sme=0
  master=0
  sblock=0
  IF nr=smpedit& THEN
    @setbutton(smppmark&,0)
    IF sloop=1 THEN
      @setbutton(smploop&,1)
    ELSE
      @setbutton(smploop&,0)
    ENDIF
    a$=@rsc_text$(popups&,20)
    @textfeld(mover&,a$,1)
  ENDIF
  smark=3
RETURN
'
> PROCEDURE crossplay
  IF hrd=0 THEN
    IF sblock=0 THEN
      @maschinit15
      l=0
      adm=ad
      IF adm=0 THEN
        @analog
        IF nr=smp16& THEN
          a$=@rsc_text$(popups&,14)
          @textfeld(input&,a$,1)
        ENDIF
      ENDIF
      a=meml
      b=memh-4
      IF sloop=0 THEN
        l=0
      ELSE
        l=-1
      ENDIF
      IF a<b THEN
        @maschruf15
      ENDIF
      @digin
      IF adm=0 THEN
        @digital
        IF nr=smp16& THEN
          a$=@rsc_text$(popups&,15)
          @textfeld(input&,a$,1)
        ENDIF
      ENDIF
      IF nr=smpedit& THEN
        @setbutton(smpplay&,32)
      ENDIF
    ELSE
      @maschinit15
      a=meml
      ama=a
      amb=memh
      lng=ce-cs    ! Laenge
      IF sms=1 THEN
        stxnr=stax
      ENDIF
      IF sms=2 THEN
        stxnr=stbx
      ENDIF
      IF sms=3 THEN
        stxnr=stcx
      ENDIF
      IF sms=4 THEN
        stxnr=stdx
      ENDIF
      IF sms=5 THEN
        stxnr=stex
      ENDIF
      IF sms=6 THEN
        stxnr=stfx
      ENDIF
      IF xm>0 AND stxnr>0 THEN
        a=a+lng/xm*stxnr+cs
        a=INT(a/4)*4
      ENDIF
      b=meml
      IF sme=1 THEN
        stxnr=eax
      ENDIF
      IF sme=2 THEN
        stxnr=ebx
      ENDIF
      IF sme=3 THEN
        stxnr=ecx
      ENDIF
      IF sme=4 THEN
        stxnr=edx
      ENDIF
      IF sme=5 THEN
        stxnr=eex
      ENDIF
      IF sme=6 THEN
        stxnr=efx
      ENDIF
      IF xm>0 AND stxnr>0 THEN
        b=b+lng/xm*stxnr+cs
        b=INT(b/4)*4
        b=b-4
      ENDIF
      l=0
      lmin=a
      lma=b
      IF sms<>0 AND sme<>0 AND a>=ama AND b<=amb AND xm<>0 AND stxnr<>0 THEN
        adm=ad
        IF adm=0 THEN
          @analog
          IF nr=smp16& THEN
            a$=@rsc_text$(popups&,14)
            @textfeld(input&,a$,1)
          ENDIF
        ENDIF
        IF sloop=0 THEN
          l=0
        ELSE
          l=-1
        ENDIF
        IF a<b THEN
          @maschruf15
        ENDIF
        @digin
        IF adm=0 THEN
          @digital
          IF nr=smp16& THEN
            a$=@rsc_text$(popups&,15)
            @textfeld(input&,a$,1)
          ENDIF
        ENDIF
        IF sret=1 THEN
          POKE maschprg%+retanz,0
        ENDIF
      ENDIF
      IF nr=smpedit& THEN
        @setbutton(smpplay&,32)
      ENDIF
    ENDIF
  ENDIF
  sth=(sth AND 11)
  POKE adr+&H40,sth
RETURN
'
> PROCEDURE smppmhlp
  IF sret=2 THEN
    @crossplay
  ELSE
    IF mamidi=0 THEN
      @maschinit2
    ELSE
      @maschinit18
    ENDIF
    a=meml
    ama=a
    amb=memh
    lng=ce-cs    ! Laenge
    IF sms=1 THEN
      stxnr=stax
    ENDIF
    IF sms=2 THEN
      stxnr=stbx
    ENDIF
    IF sms=3 THEN
      stxnr=stcx
    ENDIF
    IF sms=4 THEN
      stxnr=stdx
    ENDIF
    IF sms=5 THEN
      stxnr=stex
    ENDIF
    IF sms=6 THEN
      stxnr=stfx
    ENDIF
    IF xm>0 AND stxnr<>-1 THEN
      a=a+lng/xm*stxnr+cs
      a=INT(a/4)*4
    ENDIF
    b=meml
    IF sme=1 THEN
      stxnr=eax
    ENDIF
    IF sme=2 THEN
      stxnr=ebx
    ENDIF
    IF sme=3 THEN
      stxnr=ecx
    ENDIF
    IF sme=4 THEN
      stxnr=edx
    ENDIF
    IF sme=5 THEN
      stxnr=eex
    ENDIF
    IF sme=6 THEN
      stxnr=efx
    ENDIF
    IF xm>0 AND stxnr>0 THEN
      b=b+lng/xm*stxnr+cs
      b=INT(b/4)*4
    ENDIF
    IF sloop=0 THEN
      l=0
    ELSE
      l=-1
    ENDIF
    lmin=a
    lma=b
    IF sms<>0 AND sme<>0 AND a>=ama AND b<=amb AND xm<>0 AND stxnr<>0 THEN
      IF sret=1 THEN
        POKE maschprg%+retanz,8
        c=a
        a=b-4
        b=c
      ENDIF
      adm=ad
      IF adm=0 THEN
        @analog
        IF nr=smp16& THEN
          a$=@rsc_text$(popups&,14)
          @textfeld(input&,a$,1)
        ENDIF
      ENDIF
      IF sret=0 AND a<b THEN
        IF mamidi=0 THEN
          @maschruf
        ELSE
          @maschruf18
        ENDIF
        @digin
      ENDIF
      IF sret=1 AND a>b THEN
        IF mamidi=0 THEN
          @maschruf
        ELSE
          @maschruf18
        ENDIF
        @digin
      ENDIF
      IF adm=0 THEN
        @digital
        IF nr=smp16& THEN
          a$=@rsc_text$(popups&,15)
          @textfeld(input&,a$,1)
        ENDIF
      ENDIF
      IF sret=1 THEN
        POKE maschprg%+retanz,0
      ENDIF
    ENDIF
    IF nr=smpedit& THEN
      @setbutton(smpplay&,32)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE curve(cs,ce)
  @markhlp
  @maschinit5
  bs=1
  LOCAL c$,s,e,l,y,len,stp,adr,i,a,z,m,k,d,xm,ym,xdi,ydi
  xdi=xd-1
  ydi=yd+45
  xm=617
  ym=80
  d=40
  COLOR 0
  l=xdi
  y=(ym-d)/2+ydi
  len=ce-cs
  stp=(INT(len/xm))
  stp=(INT((stp+1)/4)*4)
  IF stp=0 THEN
    stp=4
    IF len>xm*4 THEN
      bs=len/xm/4
    ELSE
      bs=xm*4/len
    ENDIF
  ENDIF
  adr=meml
  COLOR 1
  LINE xdi,ydi+((ym-d)/2),xdi+xm,ydi+((ym-d)/2)
  FOR i=adr+cs TO adr+ce-stp STEP stp
    @maschruf5
    IF a>32767 THEN
      a=a-65536
    ENDIF
    a=INT(a/65536*ym)
    a=((ym-d)/2)+a+ydi
    IF l<=(xm+xdi) THEN
      LINE l,y,l+bs,a
    ENDIF
    y=a
    l=l+bs
  NEXT i
  ydi=ydi+97
  l=xdi
  y=(ym-d)/2+ydi
  LINE xdi,ydi+((ym-d)/2),xdi+xm,ydi+((ym-d)/2)
  FOR i=adr+cs+2 TO adr+ce-stp STEP stp
    @maschruf5
    IF a>32767 THEN
      a=a-65536
    ENDIF
    a=INT(a/65536*ym)
    a=((ym-d)/2)+a+ydi
    IF l<=(xm+xdi) THEN
      LINE l,y,l+bs,a
    ENDIF
    y=a
    l=l+bs
  NEXT i
RETURN
'
> PROCEDURE resample
  makecurve=0
  @rsc_back(nr)
  vornr=nr
  nr=resample&
  @makehz
  @rsc_draw(nr,5)
  @markhlp
  resorig=hz/1000
  db$=STR$(resorig)+CHR$(0)
  @textfeld(restxt&,db$,1)
  resoth=44.1
  db$=STR$(resoth)+CHR$(0)
  @textfeld(resother&,db$,1)
  REPEAT
    REPEAT
      REPEAT
        obj=@rsc_do(nr,0,popup&)
        ~RSRC_GADDR(0,nr,zuadr)
        x=MOUSEX
        y=MOUSEY
      UNTIL obj<>0 AND obj<>-1
      buttadr=zuadr+24*obj
      but=DPEEK(buttadr+6) AND 255
    UNTIL but=26 OR but=24 OR k=-1
    IF obj=resl1& OR obj=resl2& OR obj=resl3& OR obj=resr1& OR obj=resr2& OR obj=resr3& THEN
      PAUSE 1
      @setbutton(obj,0)
    ENDIF
    ~RSRC_GADDR(1,obj,objadr)
    objflag=DPEEK(objadr+8)
    IF obj=resl1& OR obj=resl2& OR obj=resl3& THEN
      @resl
    ENDIF
    IF obj=resr1& OR obj=resr2& OR obj=resr3& THEN
      @resr
    ENDIF
    IF obj=res32& THEN
      @resoth32
    ENDIF
    IF obj=res44& THEN
      @resoth44
    ENDIF
    IF obj=res48& THEN
      @resoth48
    ENDIF
  UNTIL obj=resok& OR obj=resexit&
  IF obj=resok& THEN
    @makeresmp
  ENDIF
  @setbutton(obj,0)
  @restaura2
  @setbutton(resmp&,0)
  IF makecurve=1 THEN
    p$=STR$(hz/1000)+CHR$(0)
    @textfeld(smprate&,p$,1)
    sec=INT(ln/(hz*4))+1
    mem$=RIGHT$("00000000"+STR$(sec),8)
    mem$="IST CA."+mem$+" SEC"+CHR$(0)
    @textfeld(smpsec&,mem$,1)
    @timecorr
  ENDIF
  obj=0
RETURN
'
> PROCEDURE arranger
  vornr=nr
  @rsc_back(nr)
  nr=arranger&
  @rsc_draw(nr,5)
  @markhlp
  REPEAT
    REPEAT
      REPEAT
        obj=@rsc_do(nr,0,popup&)
        ~RSRC_GADDR(0,nr,zuadr)
        x=MOUSEX
        y=MOUSEY
      UNTIL obj<>0 AND obj<>-1
      buttadr=zuadr+24*obj
      but=DPEEK(buttadr+6) AND 255
    UNTIL but=26 OR but=24 OR k=-1
    ~RSRC_GADDR(1,obj,objadr)
    objflag=DPEEK(objadr+8)
    IF obj=midicup& THEN
      '      @channelup
    ENDIF
    IF obj=midicdwn& THEN
      '     @channeldown
    ENDIF
    IF obj=midinup& THEN
      '    @noteup
    ENDIF
    IF obj=midindwn& THEN
      '   @notedown
    ENDIF
    IF obj=midioup& THEN
      '  @oktup
    ENDIF
    IF obj=midiodwn& THEN
      ' @oktdown
    ENDIF
  UNTIL obj=arrexit&
  @setbutton(obj,0)
  @restaura2
  obj=0
  @setbutton(arrange&,0)
RETURN
'
> PROCEDURE smpedit
  min=4
  cs=0
  ce=mlen-1
  ERASE ls()
  ERASE le()
  ERASE lcs()
  ERASE lce()
  DIM ls(lmax)
  DIM le(lmax)
  DIM lcs(lmax)
  DIM lce(lmax)
  lz=1
  ldlen=0
  cutp=0
  blks=0
  fadericht=0
  mamidi=0
  admrk=ad
  @rsc_back(nr)
  nr=smpedit&
  @rsc_draw(nr,5)
  @markhlp
  '  @setbutton(smpsavl&,0)
  ' @setbutton(smpsavr&,0)
  ' @setbutton(midi&,0)
  a$=@rsc_text$(popups&,18)
  @textfeld(mover&,a$,1)
  ch=1
  note=127
  @makehz
  IF hz=32000 THEN
    a$=@rsc_text$(popups&,2)
    @textfeld(rate&,a$,1)
    @adlow
  ENDIF
  IF hz=44100 THEN
    a$=@rsc_text$(popups&,3)
    @textfeld(rate&,a$,1)
    @admid
  ENDIF
  IF hz=48000 THEN
    a$=@rsc_text$(popups&,4)
    @textfeld(rate&,a$,1)
    @adhigh
  ENDIF
  min$=RIGHT$("00000"+STR$(min),5)
  min$=min$+" MIN"+CHR$(0)
  @textfeld(mintext&,min$,1)
  IF sms<>0 AND sme<>0 THEN
    okmark=1
  ENDIF
  IF lded=0 AND okmark=0 THEN
    @markdel
    @clsed
  ELSE
    IF DPEEK(datx)=&HF07E OR okmark=1 THEN
      IF sblock=0 THEN
        '        @setbutton(smppmark&,0)
      ELSE
        '       @setbutton(smppmark&,1)
      ENDIF
    ELSE
      @markdel
      @clsed
    ENDIF
    '
    IF lded=1 THEN
      path$=pam$
    ENDIF
    REPEAT
      g=INSTR(path$,"\")
      IF g>0 THEN
        path$=RIGHT$(path$,(LEN(path$)-g))
      ENDIF
      g2=INSTR(path$,":")
      IF g2>0 THEN
        path$=RIGHT$(path$,(LEN(path$)-g2))
      ENDIF
    UNTIL g=0 AND g2=0
    mp$=path$
    path$=SPACE$(6)+path$+SPACE$(6)
    path$=MID$(path$,INT(LEN(path$)/2)-5,12)
    @textfeld(smpfile&,path$,1)
    mem$=RIGHT$("00000000"+STR$(ln),8)
    mem$="LEN "+mem$+" BYTES"+CHR$(0)
    @textfeld(smplen&,mem$,1)
    sec=INT(ln/(hz*4))+1
    mem$=RIGHT$("00000000"+STR$(sec),8)
    mem$="IST CA."+mem$+" SEC"+CHR$(0)
    @textfeld(smpsec&,mem$,1)
  ENDIF
  @curve(cs,ce)
  IF (lded=1 AND DPEEK(datx)=&HF07E) OR okmark=1 THEN
    @markprod3
    '      @setbutton(smpsta&,1)
    '     @setbutton(smpea&,1)
  ENDIF
  REPEAT
    REPEAT
    UNTIL MOUSEK=0
    REPEAT
      REPEAT
        obj=@rsc_do(nr,0,popup&)
        ~RSRC_GADDR(0,smpedit&,zuadr)
      UNTIL obj<>0 AND obj<>-1
      buttadr=zuadr+24*obj
      but=(DPEEK(buttadr+6)) AND 255
    UNTIL but=26 OR but=22 OR but=24 OR k=-1 OR but=33
    IF but=22 THEN
      IF obj=rate& THEN
        a$=@rsc_text$(popups&,1+popup&)
        @textfeld(obj,a$,1)
        IF popup&=1 THEN
          @adlow
        ENDIF
        IF popup&=2 THEN
          @admid
        ENDIF
        IF popup&=3 THEN
          @adhigh
        ENDIF
      ENDIF
      IF obj=mover& THEN
        a$=@rsc_text$(popups&,19+popup&)
        @textfeld(obj,a$,1)
        IF popup&=1 THEN
          @smpmark
        ENDIF
        IF popup&=2 THEN
          @smpzoom
        ENDIF
        IF popup&=3 THEN
          @smpscrol
        ENDIF
        IF popup&=4 THEN
          @smpkopie
        ENDIF
        IF popup&=5 THEN
          @smpmove
        ENDIF
        IF popup&=6 THEN
          @smpmerge
        ENDIF
        IF popup&=7 THEN
          @makefade
        ENDIF
      ENDIF
    ENDIF
    IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& OR obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
      @setbutton(obj,1)
      PAUSE 1
      @setbutton(obj,0)
    ENDIF
    ~RSRC_GADDR(1,obj,objadr)
    objflag=DPEEK(objadr+8)
    IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
      @smpl
    ENDIF
    IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
      @smpr
    ENDIF
    IF obj=smpanf& THEN
      @smpanf
    ENDIF
    IF obj=smpend& THEN
      @smpend
    ENDIF
    IF obj=smpmid& THEN
      @smpmid
    ENDIF
    IF obj=smpload& THEN
      @smpload
    ENDIF
    IF obj=smpsta& THEN
      @smpsta
    ENDIF
    IF obj=smpstb& THEN
      @smpstb
    ENDIF
    IF obj=smpstc& THEN
      @smpstc
    ENDIF
    IF obj=smpstd& THEN
      @smpstd
    ENDIF
    IF obj=smpste& THEN
      @smpste
    ENDIF
    IF obj=smpea& THEN
      @smpea
    ENDIF
    IF obj=smpeb& THEN
      @smpeb
    ENDIF
    IF obj=smpec& THEN
      @smpec
    ENDIF
    IF obj=smped& THEN
      @smped
    ENDIF
    IF obj=smpee& THEN
      @smpee
    ENDIF
    IF obj=smpsave& THEN
      @smpsave
    ENDIF
    IF obj=smpplay& THEN
      @smpplay
    ENDIF
    IF obj=smppmark& THEN
      @smppmark
    ENDIF
    IF obj=smploop& THEN
      @smploop
    ENDIF
    IF obj=smpauto2& THEN
      @smpauto
    ENDIF
    IF obj=smpstrt2& THEN
      @smpstart
    ENDIF
    IF obj=peaksw2& THEN
      @peak
    ENDIF
    IF obj=hard& THEN
      @harddisk
    ENDIF
    IF obj=blkstore& THEN
      @blkstore
    ENDIF
    IF obj=loopart& THEN
      @loopwahl
    ENDIF
    IF obj=loopauto& THEN
      @loopauto
    ENDIF
    IF obj=edmidi& THEN
      @midi
    ENDIF
    IF obj=edfade& THEN
      @fade
    ENDIF
    IF obj=midi& THEN
      @machmidi
    ENDIF
    IF obj=smpsavl& THEN
      @smpstf
    ENDIF
    IF obj=smpsavr& THEN
      @smpef
    ENDIF
    IF obj=helpedit& THEN
      @helpedit
    ENDIF
    IF obj=norm& THEN
      @normalize
    ENDIF
    IF obj=resmp& THEN
      @resample
    ENDIF
    IF obj=mono& THEN
      @mono
    ENDIF
    IF obj=mix& THEN
      @mix
    ENDIF
    IF obj=hear& THEN
      @speaker
    ENDIF
    IF obj=cut& THEN
      @smpcut
    ENDIF
    IF obj=monitor& THEN
      @monitor
    ENDIF
    IF obj=arrange& THEN
      @arranger
    ENDIF
  UNTIL obj=smpexit&
  @setbutton(smpexit&,0)
  @rsc_back(nr)
  nr=smp16&
  @rsc_draw(nr,7)
  path$=mp$
  path$=SPACE$(6)+path$+SPACE$(6)
  path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
  @textfeld(datei&,path$,2)
  ad=admrk
  IF ad=0 THEN
    @digital
  ENDIF
  IF clk=4 THEN
    a$=@rsc_text$(popups&,10)
    @textfeld(rate2&,a$,1)
  ENDIF
  IF clk=8 THEN
    a$=@rsc_text$(popups&,11)
    @textfeld(rate2&,a$,1)
  ENDIF
  IF clk=12 THEN
    a$=@rsc_text$(popups&,12)
    @textfeld(rate2&,a$,1)
  ENDIF
  obj=0
RETURN
'
> PROCEDURE timecorr
  IF stax<>-1 THEN
    @markhlp3(stax,smptsa&)
  ENDIF
  IF stbx<>-1 THEN
    @markhlp3(stbx,smptsb&)
  ENDIF
  IF stcx<>-1 THEN
    @markhlp3(stcx,smptsc&)
  ENDIF
  IF stdx<>-1 THEN
    @markhlp3(stdx,smptsd&)
  ENDIF
  IF stex<>-1 THEN
    @markhlp3(stex,smptse&)
  ENDIF
  IF stfx<>-1 THEN
    @markhlp3(stfx,smptsava&)
  ENDIF
  IF eax<>-1 THEN
    @markhlp3(eax,smptea&)
  ENDIF
  IF ebx<>-1 THEN
    @markhlp3(ebx,smpteb&)
  ENDIF
  IF ecx<>-1 THEN
    @markhlp3(ecx,smptec&)
  ENDIF
  IF edx<>-1 THEN
    @markhlp3(edx,smpted&)
  ENDIF
  IF eex<>-1 THEN
    @markhlp3(eex,smptee&)
  ENDIF
  IF efx<>-1 THEN
    @markhlp3(efx,smptsavb&)
  ENDIF
RETURN
'
> PROCEDURE markdel
  ln=mlen
  sec=INT(ln/(hz*4))+1
  stax=-1
  stbx=-1
  stcx=-1
  stdx=-1
  stex=-1
  stfx=-1
  eax=-1
  ebx=-1
  ecx=-1
  edx=-1
  eex=-1
  efx=-1
  smark=3
  IF nr=smpedit& THEN
    a$=@rsc_text$(popups&,20)
    @textfeld(mover&,a$,1)
  ENDIF
  master=0
  path$=mp$
  IF nr=smpedit& THEN
    path$=SPACE$(6)+path$+SPACE$(6)
    path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
    @textfeld(smpfile&,path$,1)
    mem$=RIGHT$("00000000"+STR$(ln),8)
    mem$="LEN "+mem$+" BYTES"+CHR$(0)
    @textfeld(smplen&,mem$,1)
    mem$=RIGHT$("00000000"+STR$(sec),8)
    mem$="IST CA."+mem$+" SEC"+CHR$(0)
    @textfeld(smpsec&,mem$,1)
  ENDIF
RETURN
'
> PROCEDURE smpblk(sx,st,s,m,b$)    ! stax,smptsa,sms,master,t$
  @sbtest
  sms=s
  t$=b$
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=m
  masthlp=hacksa&
  hac$=""+CHR$(0)
  @textfeld(hacksa&,hac$,1)
  IF sx=-1 THEN
    @markhlp
    *sx=0
    @markhlp2
    @markhlp3(sx,st)
    TEXT sx+xd-3,stay1,t$
  ELSE
    bx=sx
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE smpsta
  @sbtest
  sms=1
  t$="A"
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=1
  masthlp=hacksa&
  hac$=""+CHR$(0)
  @textfeld(hacksa&,hac$,1)
  IF stax=-1 THEN
    @markhlp
    stax=0
    @markhlp2
    @markhlp3(stax,smptsa&)
    TEXT stax+xd-3,stay1,t$
  ELSE
    bx=stax
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE smpstb
  @sbtest
  sms=2
  t$="B"
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=2
  masthlp=hacksb&
  hac$=""+CHR$(0)
  @textfeld(hacksb&,hac$,1)
  IF stbx=-1 THEN
    @markhlp
    stbx=0
    @markhlp2
    @markhlp3(stbx,smptsb&)
    TEXT stbx+xd-3,stay1,t$
  ELSE
    bx=stbx
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE smpstc
  @sbtest
  sms=3
  t$="C"
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=3
  masthlp=hacksc&
  hac$=""+CHR$(0)
  @textfeld(hacksc&,hac$,1)
  IF stcx=-1 THEN
    @markhlp
    stcx=0
    @markhlp2
    @markhlp3(stcx,smptsc&)
    TEXT stcx+xd-3,stay1,t$
  ELSE
    bx=stcx
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE smpstd
  @sbtest
  sms=4
  t$="D"
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=4
  masthlp=hacksd&
  hac$=""+CHR$(0)
  @textfeld(hacksd&,hac$,1)
  IF stdx=-1 THEN
    @markhlp
    stdx=0
    @markhlp2
    @markhlp3(stdx,smptsd&)
    TEXT stdx+xd-3,stay1,t$
  ELSE
    bx=stdx
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE smpste
  @sbtest
  sms=5
  t$="E"
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=5
  masthlp=hackse&
  hac$=""+CHR$(0)
  @textfeld(hackse&,hac$,1)
  IF stex=-1 THEN
    @markhlp
    stex=0
    @markhlp2
    @markhlp3(stex,smptse&)
    TEXT stex+xd-3,stay1,t$
  ELSE
  ENDIF
RETURN
'
> PROCEDURE smpea
  @sbtest
  sme=1
  t$="A"
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=6
  masthlp=hackea&
  hac$=""+CHR$(0)
  @textfeld(hackea&,hac$,1)
  IF eax=-1 THEN
    @markhlp
    eax=0
    @markhlp2
    @markhlp3(eax,smptea&)
    TEXT eax+xd-3,stay1,t$
  ELSE
    bx=eax
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE smpeb
  @sbtest
  sme=2
  t$="B"
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=7
  masthlp=hackeb&
  hac$=""+CHR$(0)
  @textfeld(hackeb&,hac$,1)
  IF ebx=-1 THEN
    @markhlp
    ebx=0
    @markhlp2
    @markhlp3(ebx,smpteb&)
    TEXT ebx+xd-3,stay1,t$
  ELSE
    bx=ebx
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE smpec
  @sbtest
  sme=3
  t$="C"
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=8
  masthlp=hackec&
  hac$=""+CHR$(0)
  @textfeld(hackec&,hac$,1)
  IF ecx=-1 THEN
    @markhlp
    ecx=0
    @markhlp2
    @markhlp3(ecx,smptec&)
    TEXT ecx+xd-3,stay1,t$
  ELSE
    bx=ecx
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE smped
  @sbtest
  sme=4
  t$="D"
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=9
  masthlp=hacked&
  hac$=""+CHR$(0)
  @textfeld(hacked&,hac$,1)
  IF edx=-1 THEN
    @markhlp
    edx=0
    @markhlp2
    @markhlp3(edx,smpted&)
    TEXT edx+xd-3,stay1,t$
  ELSE
    bx=edx
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE smpee
  @sbtest
  sme=5
  t$="E"
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=10
  masthlp=hackee&
  hac$=""+CHR$(0)
  @textfeld(hackee&,hac$,1)
  IF eex=-1 THEN
    @markhlp
    eex=0
    @markhlp2
    @markhlp3(eex,smptee&)
    TEXT eex+xd-3,stay1,t$
  ELSE
  ENDIF
RETURN
'
> PROCEDURE smph1
  IF master=1 THEN
    x=stax
  ENDIF
  IF master=2 THEN
    x=stbx
  ENDIF
  IF master=3 THEN
    x=stcx
  ENDIF
  IF master=4 THEN
    x=stdx
  ENDIF
  IF master=5 THEN
    x=stex
  ENDIF
  IF master=6 THEN
    x=eax
  ENDIF
  IF master=7 THEN
    x=ebx
  ENDIF
  IF master=8 THEN
    x=ecx
  ENDIF
  IF master=9 THEN
    x=edx
  ENDIF
  IF master=10 THEN
    x=eex
  ENDIF
  IF master=11 THEN
    x=stfx
  ENDIF
  IF master=12 THEN
    x=efx
  ENDIF
RETURN
'
> PROCEDURE markhlp4
  COLOR 1
  ALINE bx+xd,stay1,bx+xd,stay2,1,&HFFFF,2
  ALINE bx+xd,stay1,bx+xd,stay2,1,&HFFFF,2
  TEXT bx+xd-3,yd+22,t$
RETURN
'
> PROCEDURE markhlp5(bx)
  COLOR 1
  ALINE bx+xd,stay1,bx+xd,stay2,1,&HFFFF,2
RETURN
'
> PROCEDURE setup
  digana=FALSE           ! wenn TRUE, dann DIGITAL->ANALOG-Umschaltung bei Wiedergabe
  op$="F:\SAMPLES\"      ! Default-Zugriffspfad
  lmax=100               ! Feldgr”že fr SCROLL
  flen=&H2000            ! Sektorl„nge
  recfifolen=&H2000      ! Gr”že des RECORD-FIFO
  playfifolen=&H2000     ! Gr”že des PLAY-FIFO
  sram=&H900000          ! Anfang des SRAM
  hp$=SPACE$(32767)
  sad%=VARPTR(hp$)        !Buffer fr HARD-PLAY und HARD-RECORD
  sad%=INT(sad%/2)*2+2
  '
  @makehz
  adr=&HDF0401
  mtst=MALLOC(-1)
  IF mtst>&H110000 THEN
    mtst=INT((mtst-&H70000)/2)*2
    manf=MALLOC(mtst)
    merkfrei=manf
    IF manf>0 THEN
      manf=INT(manf/4)*4+4
      meml=manf
      memh=meml+mtst-4
      mlen=mtst-8
      big=1
    ELSE
      meml=sram
      memh=sram+&H100000-4
      mlen=&H100000
      big=0
    ENDIF
  ELSE
    meml=sram
    memh=sram+&H100000-4
    mlen=&H100000
    big=0
  ENDIF
  dat=((INT(anfload/2))*2)+2
  cs=0
  ce=mlen-1
  '
  DIM ls(lmax)
  DIM le(lmax)
  DIM lcs(lmax)
  DIM lce(lmax)
  fadnr=246
  DIM fadeni(fadnr)
  DIM fadeno(fadnr)
  lz=1
  ln=mlen
  sec=INT(ln/(hz*4))+1
  path$="MEMORY.SMP"
  mp$=path$
  path$=SPACE$(6)+path$+SPACE$(6)
  path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
  @textfeld(datei&,path$,2)
  mem$=RIGHT$("00000000"+STR$(ln),8)
  textfeld(memused&,mem$,2)
  @maschinit9
  @maschruf9(meml,memh)
  nr=smp16&
  retime=0
  ad=0
  xmp=0
  okmark=0
  merkerr=0
  merkfreq=0
  '
  '
  a$=@rsc_text$(popups&,15)
  @textfeld(input&,a$,1)
  a$=@rsc_text$(popups&,17)
  @textfeld(source&,a$,1)
  a$=@rsc_text$(popups&,11)
  @textfeld(rate2&,a$,1)
  a$=@rsc_text$(popups&,6)
  @textfeld(dsp&,a$,1)
  protnr=0
  locknr=0
  lded=0
  hrd=0
  merk1=0
  merk2=0
  merk3=0
  merk4=0
  merkc=-1
  '
  stl=0
  clk=8
  sth=0
  std=0
  POKE adr+&H0,stl
  POKE adr+&H40,sth
  POKE adr+&H80,std
RETURN
'
> PROCEDURE makehz
  IF ad=1 THEN
    IF clk=4 THEN
      hz=32000
    ENDIF
    IF clk=8 THEN
      hz=44100
    ENDIF
    IF clk=12 THEN
      hz=48000
    ENDIF
  ENDIF
  IF ad=0 THEN
    IF ad=0 THEN
      hzc=3 AND (PEEK(adr))
    ENDIF
    IF hzc=3 THEN
      hz=32000
    ENDIF
    IF hzc=0 THEN
      hz=44100
    ENDIF
    IF hzc=2 THEN
      hz=48000
    ENDIF
  ENDIF
  IF retime=1 THEN
    hz=hzm
  ENDIF
RETURN
'
> PROCEDURE aufbau
  IF (stl AND 2)=0 THEN
    @setbutton(opto&,1)
  ELSE
    @setbutton(coax&,1)
  ENDIF
  IF locknr=1 THEN
    @setbutton(lock&,1)
  ENDIF
  IF protnr=1 THEN
    @setbutton(protect&,1)
  ENDIF
  IF clk=4 THEN
    @setbutton(ad32&,1)
  ENDIF
  IF clk=8 THEN
    @setbutton(ad44&,1)
  ENDIF
  IF clk=12 THEN
    @setbutton(ad48&,1)
  ENDIF
  IF ad=0 THEN
    @setbutton(digital&,1)
  ELSE
    @setbutton(analog&,1)
  ENDIF
RETURN
'
> PROCEDURE mix
  ' @maschinit17
  IF sblock=0 THEN
    ' @maschruf17(meml,memh)
  ELSE
    @blocklook
    ' @maschruf17(mcs,mce)
  ENDIF
  @restaura
  obj=0
  @setbutton(mix&,0)
RETURN
'
> PROCEDURE speaker
  @setbutton(hear&,0)
RETURN
'
> PROCEDURE monitor
  @setbutton(monitor&,0)
RETURN
'
> PROCEDURE mono
  @maschinit17
  IF sblock=0 THEN
    @maschruf17(meml,memh)
  ELSE
    @blocklook
    @maschruf17(mcs,mce)
  ENDIF
  @restaura
  @setbutton(mono&,0)
  obj=0
RETURN
'
> PROCEDURE harddisk
  IF hrd=0 THEN
    hrd=1
  ELSE
    hrd=0
  ENDIF
RETURN
'
> PROCEDURE peak
  vornr=nr
  @rsc_back(nr)
  nr=peak&
  @rsc_draw(nr,1)
  @markhlp
  MENU OFF
  ~RSRC_GADDR(0,nr,boxadr)
  @findbutton(prmin&)
  sr1%=buttadr
  @findbutton(pr2&)
  sr2%=buttadr
  @findbutton(pr3&)
  sr3%=buttadr
  @findbutton(pr4&)
  sr4%=buttadr
  @findbutton(pr5&)
  sr5%=buttadr
  @findbutton(pr6&)
  sr6%=buttadr
  @findbutton(pr7&)
  sr7%=buttadr
  @findbutton(pr8&)
  sr8%=buttadr
  @findbutton(pr9&)
  sr9%=buttadr
  @findbutton(prmax&)
  sr10%=buttadr
  @findbutton(plmin&)
  sl1%=buttadr
  @findbutton(pl2&)
  sl2%=buttadr
  @findbutton(pl3&)
  sl3%=buttadr
  @findbutton(pl4&)
  sl4%=buttadr
  @findbutton(pl5&)
  sl5%=buttadr
  @findbutton(pl6&)
  sl6%=buttadr
  @findbutton(pl7&)
  sl7%=buttadr
  @findbutton(pl8&)
  sl8%=buttadr
  @findbutton(pl9&)
  sl9%=buttadr
  @findbutton(plmax&)
  sl10%=buttadr
  @maschinit14
  ON MENU MESSAGE GOSUB message
  REPEAT
    ON MENU
    @peakread
  UNTIL MOUSEK=2 OR MOUSEK=3
  IF vornr=smp16& THEN
    @rsc_back(nr)
    nr=vornr
    @rsc_draw(nr,7)
  ENDIF
  obj=0
  IF vornr=smpedit& THEN
    @restaura2
    @setbutton(peaksw2&,0)
  ENDIF
RETURN
'
> PROCEDURE midi
  vornr=nr
  @rsc_back(nr)
  nr=midiedit&
  @rsc_draw(nr,5)
  @markhlp
  db$=STR$(ch)+CHR$(0)
  @textfeld(chtxt&,db$,1)
  @makenote
  REPEAT
    REPEAT
      REPEAT
        obj=@rsc_do(nr,0,popup&)
        ~RSRC_GADDR(0,nr,zuadr)
        x=MOUSEX
        y=MOUSEY
      UNTIL obj<>0 AND obj<>-1
      buttadr=zuadr+24*obj
      but=DPEEK(buttadr+6) AND 255
    UNTIL but=26 OR but=24 OR k=-1
    IF obj<>midinup& AND obj<>midindwn& AND obj<>midioup& AND obj<>midiodwn& AND obj<>midicup& AND obj<>midicdwn& THEN
      aw=FORM_BUTTON(boxadr,obj,1,a)
      REPEAT
      UNTIL MOUSEK=0
    ELSE
      @setbutton(obj,1)
      PAUSE 1
      @setbutton(obj,0)
    ENDIF
    PAUSE 1
    ~RSRC_GADDR(1,obj,objadr)
    objflag=DPEEK(objadr+8)
    IF obj=midicup& THEN
      @channelup
    ENDIF
    IF obj=midicdwn& THEN
      @channeldown
    ENDIF
    IF obj=midinup& THEN
      @noteup
    ENDIF
    IF obj=midindwn& THEN
      @notedown
    ENDIF
    IF obj=midioup& THEN
      @oktup
    ENDIF
    IF obj=midiodwn& THEN
      @oktdown
    ENDIF
  UNTIL obj=midiok&
  @setbutton(obj,0)
  @restaura2
  obj=0
  @setbutton(edmidi&,0)
RETURN
'
> PROCEDURE fadedown
RETURN
'
> PROCEDURE fadeup
RETURN
'
> PROCEDURE fadelinks
RETURN
'
> PROCEDURE faderechts
RETURN
'
> PROCEDURE makefade
  FOR i=1 TO fadnr-1
    LINE i,fadeni(i),i+1,fadeni(i+1)
  NEXT i
RETURN
'
> PROCEDURE channelup
  IF ch<16 THEN
    ch=ch+1
  ENDIF
  db$=STR$(ch)+CHR$(0)
  @textfeld(chtxt&,db$,1)
  @makenote
RETURN
'
> PROCEDURE channeldown
  IF ch>1 THEN
    ch=ch-1
  ENDIF
  db$=STR$(ch)+CHR$(0)
  @textfeld(chtxt&,db$,1)
  @makenote
RETURN
'
> PROCEDURE makenote
  o=INT(note/12)
  n=note-o*12
  IF n=0 THEN
    IF o<3 THEN
      db$="C "
    ELSE
      db$="c "
    ENDIF
  ENDIF
  IF n=1 THEN
    IF o<3 THEN
      db$="C#"
    ELSE
      db$="c#"
    ENDIF
  ENDIF
  IF n=2 THEN
    IF o<3 THEN
      db$="D "
    ELSE
      db$="d "
    ENDIF
  ENDIF
  IF n=3 THEN
    IF o<3 THEN
      db$="D#"
    ELSE
      db$="d#"
    ENDIF
  ENDIF
  IF n=4 THEN
    IF o<3 THEN
      db$="E "
    ELSE
      db$="e "
    ENDIF
  ENDIF
  IF n=5 THEN
    IF o<3 THEN
      db$="F "
    ELSE
      db$="f "
    ENDIF
  ENDIF
  IF n=6 THEN
    IF o<3 THEN
      db$="F#"
    ELSE
      db$="f#"
    ENDIF
  ENDIF
  IF n=7 THEN
    IF o<3 THEN
      db$="G "
    ELSE
      db$="g "
    ENDIF
  ENDIF
  IF n=8 THEN
    IF o<3 THEN
      db$="G#"
    ELSE
      db$="g#"
    ENDIF
  ENDIF
  IF n=9 THEN
    IF o<3 THEN
      db$="A "
    ELSE
      db$="a "
    ENDIF
  ENDIF
  IF n=10 THEN
    IF o<3 THEN
      db$="A#"
    ELSE
      db$="a#"
    ENDIF
  ENDIF
  IF n=11 THEN
    IF o<3 THEN
      db$="B "
    ELSE
      db$="b "
    ENDIF
  ENDIF
  IF o=0 THEN
    db$=db$+"3"
  ENDIF
  IF o=1 THEN
    db$=db$+"2"
  ENDIF
  IF o=2 THEN
    db$=db$+"1"
  ENDIF
  IF o=3 THEN
    db$=db$+"0"
  ENDIF
  IF o=4 THEN
    db$=db$+"1"
  ENDIF
  IF o=5 THEN
    db$=db$+"2"
  ENDIF
  IF o=6 THEN
    db$=db$+"3"
  ENDIF
  IF o=7 THEN
    db$=db$+"4"
  ENDIF
  IF o=8 THEN
    db$=db$+"5"
  ENDIF
  IF o=9 THEN
    db$=db$+"6"
  ENDIF
  IF o=10 THEN
    db$=db$+"7"
  ENDIF
  db$=db$+CHR$(0)
  @textfeld(notetxt&,db$,1)
  midiwort=(ch-1)*256+note
RETURN
'
> PROCEDURE notedown
  IF note>0 THEN
    note=note-1
  ENDIF
  @makenote
RETURN
'
> PROCEDURE noteup
  IF note<127 THEN
    note=note+1
  ENDIF
  @makenote
RETURN
'
> PROCEDURE oktdown
  IF (note-12)>=0 THEN
    note=note-12
  ENDIF
  @makenote
RETURN
'
> PROCEDURE oktup
  IF (note+12)<=127 THEN
    note=note+12
  ENDIF
  @makenote
RETURN
'
> PROCEDURE machmidi
  IF mamidi=0 THEN
    mamidi=1
  ELSE
    mamidi=0
  ENDIF
RETURN
'
> PROCEDURE helpedit
  @setbutton(helpedit&,0)
RETURN
'
> PROCEDURE loopwahl
  vornr=nr
  @rsc_back(nr)
  nr=loop&
  @rsc_draw(nr,5)
  @markhlp
  IF sret=0 THEN
    @setbutton(forw&,1)
  ENDIF
  IF sret=1 THEN
    @setbutton(backw&,1)
  ENDIF
  IF sret=2 THEN
    @setbutton(cross&,1)
  ENDIF
  REPEAT
    REPEAT
      obj=@rsc_do(nr,0,popup&)
      ~RSRC_GADDR(0,nr,zuadr)
    UNTIL obj<>0 AND obj<>-1
    buttadr=zuadr+24*obj
    but=DPEEK(buttadr+6)
    REPEAT
    UNTIL MOUSEK=0
    PAUSE 2
    ~RSRC_GADDR(1,obj,objadr)
    objflag=DPEEK(objadr+8)
  UNTIL obj=loopexit& OR obj=forw& OR obj=backw& OR obj=cross&
  IF obj=forw& THEN
    @loopfor
  ENDIF
  IF obj=backw& THEN
    @loopret
  ENDIF
  IF obj=cross& THEN
    @loopcross
  ENDIF
  @setbutton(obj,0)
  @restaura2
  obj=0
  @setbutton(loopart&,0)
RETURN
'
> PROCEDURE dspwahl
  vornr=nr
  @rsc_back(nr)
  nr=dspedit&
  @rsc_draw(nr,5)
  @markhlp
  REPEAT
    REPEAT
      obj=@rsc_do(nr,0,popup&)
      REPEAT
        ~RSRC_GADDR(0,nr,zuadr)
        x=MOUSEX
        y=MOUSEY
      UNTIL obj<>0 AND obj<>-1
      buttadr=zuadr+24*obj
      but=DPEEK(buttadr+6) AND 255
    UNTIL but=26 OR but=24 OR k=-1
    IF obj=dspload& THEN
      PAUSE 2
      @setbutton(dspload&,0)
    ENDIF
    IF obj=dspsave& THEN
      PAUSE 2
      @setbutton(dspsave&,0)
    ENDIF
    IF obj=dsphall& THEN
      PAUSE 2
      @setbutton(dsphall&,0)
    ENDIF
    IF obj=dspecho& THEN
      PAUSE 2
      @setbutton(dspecho&,0)
    ENDIF
    IF obj=dspret& THEN
      PAUSE 2
      @setbutton(dspret&,0)
    ENDIF
    IF obj=dspeq& THEN
      PAUSE 2
      @setbutton(dspeq&,0)
    ENDIF
  UNTIL obj=dspexit&
  @setbutton(obj,0)
  @rsc_back(nr)
  nr=vornr
  @rsc_draw(nr,5)
  obj=0
RETURN
'
> PROCEDURE loopauto
  '  @setbutton(loopauto&,0)
RETURN
'
> PROCEDURE loopfor
  sret=0
RETURN
'
> PROCEDURE loopret
  sret=1
RETURN
'
> PROCEDURE loopcross
  sret=2
RETURN
'
> PROCEDURE normadj
  grenz=(db+aufloes)/20
  grenz=10^grenz
  IF grenz>32767 THEN
    grenz=32767
  ENDIF
  grenz=INT(grenz)
  @makenorm
RETURN
'
> PROCEDURE normauto
  db=0
  grenz=32767
  @makenorm
RETURN
'
> PROCEDURE makenorm
  @maschinit13
  IF sblock=0 THEN
    a=meml
    b=memh
  ELSE
    @blocklook
    a=mcs
    b=mce
  ENDIF
  IF sblock=0 OR (sblock=1 AND c2>c1 AND mce<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0) THEN
    @maschruf13(a,b,grenz,back%)
    makecurve=1
  ENDIF
RETURN
'
> PROCEDURE normtest
  aufloes=90.3
  @maschinit12
  IF sblock=0 THEN
    @maschruf12(meml,memh)
  ELSE
    @blocklook
    @maschruf12(mcs,mce)
  ENDIF
  IF back%>0 THEN
    db=back%
    db=20*LOG10(db)
    db=db-aufloes
    db=INT(db*100)/100
  ELSE
    back%=32767
    db=0
  ENDIF
  db$=STR$(db)+CHR$(0)
  @textfeld(normdb&,db$,1)
RETURN
'
> PROCEDURE norml
  IF norma=0 THEN
    auflh=INT(0-(aufloes*100))
    dbx=INT(db*100)
    IF obj=norml1& THEN
      nz=2
    ENDIF
    IF obj=norml2& THEN
      nz=20
    ENDIF
    IF obj=norml3& THEN
      nz=400
    ENDIF
    dbx=dbx-nz
    IF dbx>=auflh THEN
      db=INT(dbx)/100
    ENDIF
    db$=STR$(db)+CHR$(0)
    @textfeld(normdb&,db$,1)
  ENDIF
RETURN
'
> PROCEDURE normr
  IF norma=0 THEN
    dbx=INT(db*100)
    IF obj=normr1& THEN
      nz=2
    ENDIF
    IF obj=normr2& THEN
      nz=20
    ENDIF
    IF obj=normr3& THEN
      nz=400
    ENDIF
    t=1
    dbx=dbx+nz
    IF t>dbx THEN
      db=INT(dbx)/100
    ENDIF
    db$=STR$(db)+CHR$(0)
    @textfeld(normdb&,db$,1)
  ENDIF
RETURN
'
> PROCEDURE resl
  IF obj=resl1& THEN
    nz=0.1
  ENDIF
  IF obj=resl2& THEN
    nz=1
  ENDIF
  IF obj=resl3& THEN
    nz=5
  ENDIF
  t=5
  IF (resoth-nz)>=t THEN
    resoth=resoth-nz
  ENDIF
  resoth=INT(resoth*10)/10
  db$=STR$(resoth)+CHR$(0)
  @textfeld(resother&,db$,1)
RETURN
'
> PROCEDURE resr
  IF obj=resr1& THEN
    nz=0.1
  ENDIF
  IF obj=resr2& THEN
    nz=1
  ENDIF
  IF obj=resr3& THEN
    nz=5
  ENDIF
  t=96
  IF (resoth+nz)<=t THEN
    resoth=resoth+nz
  ENDIF
  db$=STR$(resoth)+CHR$(0)
  @textfeld(resother&,db$,1)
RETURN
'
> PROCEDURE resoth32
  resoth=32
  db$=STR$(resoth)+CHR$(0)
  @textfeld(resother&,db$,1)
  @setbutton(res32&,0)
RETURN
'
> PROCEDURE resoth44
  resoth=44.1
  db$=STR$(resoth)+CHR$(0)
  @textfeld(resother&,db$,1)
  @setbutton(res44&,0)
RETURN
'
> PROCEDURE resoth48
  resoth=48
  db$=STR$(resoth)+CHR$(0)
  @textfeld(resother&,db$,1)
  @setbutton(res48&,0)
RETURN
'
> PROCEDURE makeresmp
  @maschinit16
  e=INT(resorig*10)
  f=INT(resoth*10)
  bedarf=f/e
  IF sblock=0 THEN
    IF bedarf<=1 THEN
      a=meml
      b=memh
      c=meml
      d=memh
      @maschruf16(a,b,c,d,e,f)
      IF back%<memh AND back%>meml THEN
        @maschinit9
        @maschruf9(back%,memh-4)
      ENDIF
      makecurve=1
      hz=resoth*1000
      hzm=hz
      retime=1
    ELSE
      a=meml
      drittel=((memh-meml)-((memh-meml)/bedarf))
      IF ldlen=0 OR (ldlen<>0 AND ldlen<=drittel) THEN
        drittel=drittel+meml
        drittel=INT(drittel/4)*4
        b=drittel
        c=drittel
        d=memh
        @maschruf16(a,b,c,d,e,f)
        makecurve=1
        hz=resoth*1000
        hzm=hz
        retime=1
        @maschinit10
        @maschruf10(c,d,meml,memh)
        @maschinit9
        b=INT((d-c)/4)*4
        @maschruf9(meml+b,d)
      ELSE
        ALERT 3,"Zu wenig Speicher !|Bitte Block verkleinern !",1,"OKAY",a
      ENDIF
    ENDIF
  ELSE
    @blocklook
    a=mcs
    b=mce
    drittel=(memh-meml)/(mce-mcs)
    IF bedarf<=1 THEN
      c=mcs
      d=mce
      @maschruf16(a,b,c,d,e,f)
      makecurve=1
      hz=resoth*1000
      hzm=hz
      retime=1
      IF back%<mce AND back%>mcs THEN
        @maschinit9
        @maschruf9(back%,mce)
      ENDIF
    ELSE
      IF mce+4<memh AND drittel>=bedarf THEN
        c=mce+4
        d=memh
        STOP
        @maschruf16(a,b,c,d,e,f)
        makecurve=1
        hz=resoth*1000
        hzm=hz
        retime=1
        STOP
        @maschinit10
        @maschruf10(c,d,mcs,memh)
        @maschinit9
        b=INT((d-c)/4)*4
        @maschruf9(mcs+b,d)
      ELSE
        ALERT 3,"Zu wenig Speicher !|Bitte Block verkleinern !",1,"OKAY",a
      ENDIF
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE npeakread
  @maschinit6
  REPEAT
    @maschruf6
    @rsc_back(nr)
    @rsc_draw(nr,4)
  UNTIL MOUSEK OR INP?(2)=TRUE
RETURN
'
> PROCEDURE peakwert
  REPEAT
    pr=DPEEK(&HDF04C0)
  UNTIL (pr AND 256)=0
  REPEAT
    REPEAT
      pr=DPEEK(&HDF04C0)
    UNTIL (pr AND 256)=256
    pr2=DPEEK(&HDF04C0)
  UNTIL (pr2 AND 256)=256
  REPEAT
    REPEAT
      pl=DPEEK(&HDF04C0)
    UNTIL (pl AND 256)=0
    pl2=DPEEK(&HDF04C0)
  UNTIL (pl2 AND 256)=0
  pr=(pr AND 255)*256+(pr2 AND 255)
  pl=(pl AND 255)*256+(pl2 AND 255)
  IF pr>32767 THEN
    pr=ABS(pr-65536)
  ENDIF
  IF pl>32767 THEN
    pl=ABS(pl-65536)
  ENDIF
  pr=pr/32767*10
  pl=pl/32767*10
RETURN
'
> PROCEDURE peakread
  @maschruf14(4096)
  a=0
  b=0
  raus=FALSE
  i=0
  REPEAT
    @peakwert
    IF pr>9 OR pl>9 THEN
      a=pr
      b=pl
      raus=TRUE
    ENDIF
    IF pr>a THEN
      a=pr
    ENDIF
    IF pl>b THEN
      b=pl
    ENDIF
    INC i
  UNTIL i=100 OR raus=TRUE
  pr=a
  pl=b
  erlaub=TRUE
  IF erlaub=TRUE THEN
    IF pr>0 THEN
      DPOKE sr1%,1
    ELSE
      DPOKE sr1%,0
    ENDIF
    IF pl>0 THEN
      DPOKE sl1%,1
    ELSE
      DPOKE sl1%,0
    ENDIF
    IF pr>1 THEN
      DPOKE sr2%,1
    ELSE
      DPOKE sr2%,0
    ENDIF
    IF pl>1 THEN
      DPOKE sl2%,1
    ELSE
      DPOKE sl2%,0
    ENDIF
    IF pr>2 THEN
      DPOKE sr3%,1
    ELSE
      DPOKE sr3%,0
    ENDIF
    IF pl>2 THEN
      DPOKE sl3%,1
    ELSE
      DPOKE sl3%,0
    ENDIF
    IF pr>3 THEN
      DPOKE sr4%,1
    ELSE
      DPOKE sr4%,0
    ENDIF
    IF pl>3 THEN
      DPOKE sl4%,1
    ELSE
      DPOKE sl4%,0
    ENDIF
    IF pr>4 THEN
      DPOKE sr5%,1
    ELSE
      DPOKE sr5%,0
    ENDIF
    IF pl>4 THEN
      DPOKE sl5%,1
    ELSE
      DPOKE sl5%,0
    ENDIF
    IF pr>5 THEN
      DPOKE sr6%,1
    ELSE
      DPOKE sr6%,0
    ENDIF
    IF pl>5 THEN
      DPOKE sl6%,1
    ELSE
      DPOKE sl6%,0
    ENDIF
    IF pr>6 THEN
      DPOKE sr7%,1
    ELSE
      DPOKE sr7%,0
    ENDIF
    IF pl>6 THEN
      DPOKE sl7%,1
    ELSE
      DPOKE sl7%,0
    ENDIF
    IF pr>7 THEN
      DPOKE sr8%,1
    ELSE
      DPOKE sr8%,0
    ENDIF
    IF pl>7 THEN
      DPOKE sl8%,1
    ELSE
      DPOKE sl8%,0
    ENDIF
    IF pr>8 THEN
      DPOKE sr9%,1
    ELSE
      DPOKE sr9%,0
    ENDIF
    IF pl>8 THEN
      DPOKE sl9%,1
    ELSE
      DPOKE sl9%,0
    ENDIF
    IF pr>9 THEN
      DPOKE sr10%,1
    ELSE
      DPOKE sr10%,0
    ENDIF
    IF pl>9 THEN
      DPOKE sl10%,1
    ELSE
      DPOKE sl10%,0
    ENDIF
    ~OBJC_DRAW(boxadr,0,7,0,0,xwidth,ywidth)
    IF pr>9 OR pl>9 THEN
      PAUSE 20
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE smpscrol
  smark=1
RETURN
'
> PROCEDURE smpzoom
  smark=2
RETURN
'
> PROCEDURE smpkopie
  smark=5
RETURN
'
> PROCEDURE smpmove
  smark=6
RETURN
'
> PROCEDURE smpmerge
  smark=7
RETURN
'
> PROCEDURE smpmark
  smark=3
RETURN
'
> PROCEDURE sbtest
  IF master=11 THEN
    @setbutton(smpsavl&,0)
  ENDIF
  IF master=12 THEN
    @setbutton(smpsavr&,0)
  ENDIF
RETURN
'
> PROCEDURE sbtest2
  IF sms=1 THEN
    @setbutton(smpsta&,0)
  ENDIF
  IF sms=2 THEN
    @setbutton(smpstb&,0)
  ENDIF
  IF sms=3 THEN
    @setbutton(smpstc&,0)
  ENDIF
  IF sms=4 THEN
    @setbutton(smpstd&,0)
  ENDIF
  IF sms=5 THEN
    @setbutton(smpste&,0)
  ENDIF
  IF sme=1 THEN
    @setbutton(smpea&,0)
  ENDIF
  IF sme=2 THEN
    @setbutton(smpeb&,0)
  ENDIF
  IF sme=3 THEN
    @setbutton(smpec&,0)
  ENDIF
  IF sme=4 THEN
    @setbutton(smped&,0)
  ENDIF
  IF sme=5 THEN
    @setbutton(smpee&,0)
  ENDIF
RETURN
'
> PROCEDURE markhandler(tx,utx,ty1,ty2,dx,tym)
  IF x>tx+xd-2 AND x<tx+xd+2 AND y>=ty1 AND y<=ty2 THEN
    k=MOUSEK
    IF k=1 THEN
      COLOR 0
      FOR i=x-5 TO x+5
        LINE i,ty1+1,i,ty1-5
      NEXT i
      f=0
      REPEAT
        x2=MOUSEX
        IF x<>x2 THEN
          INC f
        ENDIF
        x=x2
        IF x>=xd AND x<=xm+xd AND y>=ty1 AND y<=ty2 AND x<>tx+xd THEN
          COLOR 0
          ALINE tx+xd,ty1+2,tx+xd,ty2,1,&HFFFF,2
          COLOR 1
          tx=x-xd
          ALINE tx+xd,ty1+2,tx+xd,ty2,1,&HFFFF,2
          *utx=tx
        ENDIF
        k=MOUSEK
      UNTIL k=0
      COLOR 1
      TEXT tx+xd-3,ty1-1,t$
    ENDIF
  ENDIF
  obj=0
RETURN
'
> PROCEDURE markhandl2(tx,utx,ty1,ty2,dx,tym)
  IF x>=0 AND x<=(xm) THEN
    COLOR 0
    ALINE tx+xd,ty1,tx+xd,ty2,1,&HFFFF,2
    FOR i=tx-5 TO tx+5
      LINE i+xd,ty1+1,i+xd,ty1-5
    NEXT i
    COLOR 1
    LINE tx+xd-1,ty1+2,tx+xd+1,ty1+2
    LINE tx+xd-1,ty1+tym-2,tx+xd+1,ty1+tym-2
    LINE tx+xd-1,ty1+ym2-2,tx+xd+1,ty1+ym2-2
    LINE tx+xd-1,ty1+ym3-2,tx+xd+1,ty1+ym3-2
    tx=x
    ALINE tx+xd,ty1,tx+xd,ty2,1,&HFFFF,2
    TEXT tx+xd-3,ty1,t$
    *utx=tx
  ENDIF
RETURN
'
> PROCEDURE markhandl3(tx,ty1,ty2,dx,tym)
  COLOR 1
  LINE tx-1,ty1+2,tx+1,ty1+2
  LINE tx-1,ty1+tym-2,tx+1,ty1+tym-2
  LINE tx-1,ty1+ym2-2,tx+1,ty1+ym2-2
  LINE tx-1,ty1+ym3-2,tx+1,ty1+ym3-2
  ALINE tx,ty1,tx,ty2,1,&HFFFF,2
  TEXT tx-3,ty1,t$
RETURN
'
> PROCEDURE blkstore
  IF blks=0 THEN
    blks=1
  ELSE
    blks=0
  ENDIF
RETURN
'
> PROCEDURE deladbutt
  IF clk=4 THEN
    @setbutton(ad32&,0)
  ENDIF
  IF clk=8 THEN
    @setbutton(ad44&,0)
  ENDIF
  IF clk=12 THEN
    @setbutton(ad48&,0)
  ENDIF
RETURN
'
> PROCEDURE digin
  sth=(sth AND 11)
  POKE adr+&H40,sth
RETURN
'
> PROCEDURE smpplay
  IF sret=2 THEN
    @crossplay
  ELSE
    IF hrd=0 THEN
      IF sblock=0 THEN
        IF mamidi=0 THEN
          @maschinit2
        ELSE
          @maschinit18
        ENDIF
        a=meml
        b=memh
        IF sloop=0 THEN
          l=0
        ELSE
          l=-1
        ENDIF
        IF sret=1 THEN
          POKE maschprg%+retanz,8
          c=a
          a=b-4
          b=c
        ENDIF
        adm=ad
        IF adm=0 THEN
          @analog
          IF nr=smp16& THEN
            a$=@rsc_text$(popups&,14)
            @textfeld(input&,a$,1)
          ENDIF
        ENDIF
        IF sret=0 AND a<b THEN
          IF mamidi=0 THEN
            @maschruf
          ELSE
            @maschruf18
          ENDIF
          @digin
          '
        ENDIF
        IF sret=1 AND a>b THEN
          IF mamidi=0 THEN
            @maschruf
          ELSE
            @maschruf18
          ENDIF
          @digin
        ENDIF
        IF adm=0 THEN
          @digital
          IF nr=smp16& THEN
            a$=@rsc_text$(popups&,15)
            @textfeld(input&,a$,1)
          ENDIF
        ENDIF
        IF sret=1 THEN
          POKE maschprg%+retanz,0
        ENDIF
        IF nr=smpedit& THEN
          @setbutton(smpplay&,32)
        ENDIF
      ELSE
        @smppmhlp
      ENDIF
    ELSE
      '      GET xwidth/2-170,ywidth/2-170,xwidth/2+170,ywidth/2+170,cb$
      FILESELECT op$+"*.SMP","",pat$
      '     PUT xwidth/2-170,ywidth/2-170,cb$
      IF EXIST(pat$) THEN
        IF nr=smpedit& THEN
          @restaura
        ENDIF
        OPEN "I",#1,pat$
        f=LOF(#1)
        CLOSE #1
        pa$=pat$+CHR$(0)
        sectors=INT(f/flen)
        REPEAT
          g=INSTR(pat$,"\")
          IF g>0 THEN
            pat$=RIGHT$(pat$,(LEN(pat$)-g))
          ENDIF
          g2=INSTR(pat$,":")
          IF g2>0 THEN
            pat$=RIGHT$(pat$,(LEN(pat$)-g2))
          ENDIF
        UNTIL g=0 AND g2=0
        pat$=SPACE$(6)+pat$+SPACE$(6)
        pat$=MID$(pat$,INT(LEN(pat$)/2)-5,12)+CHR$(0)
        IF nr=smpedit& THEN
          @textfeld(smpfile&,pat$,1)
          mem$=RIGHT$("00000000"+STR$(f),8)
          mem$="LEN "+mem$+" BYTES"+CHR$(0)
          @textfeld(smplen&,mem$,1)
          @makehz
          hsec=INT(f/(hz*4))
          mem$=RIGHT$("00000000"+STR$(hsec),8)
          mem$="IST CA."+mem$+" SEC"+CHR$(0)
          @textfeld(smpsec&,mem$,1)
        ENDIF
        IF nr=smp16& THEN
          @textfeld(datei&,pat$,2)
          mem$=RIGHT$("00000000"+STR$(f),8)
          @textfeld(memused&,mem$,2)
        ENDIF
        @maschinit7
        @maschruf7
        IF nr=smpedit& THEN
          @textfeld(smpfile&,path$,1)
          mem$=RIGHT$("00000000"+STR$(ln),8)
          mem$="LEN "+mem$+" BYTES"+CHR$(0)
          @textfeld(smplen&,mem$,1)
          mem$=RIGHT$("00000000"+STR$(sec),8)
          mem$="IST CA."+mem$+" SEC"+CHR$(0)
          @textfeld(smpsec&,mem$,1)
        ENDIF
        IF nr=smp16& THEN
          @textfeld(datei&,path$,2)
          mem$=RIGHT$("00000000"+STR$(ln),8)
          @textfeld(memused&,mem$,2)
        ENDIF
      ELSE
        IF nr=smpedit& THEN
          @restaura
        ENDIF
      ENDIF
      IF nr=smpedit& THEN
        @setbutton(smpplay&,32)
      ENDIF
    ENDIF
    sth=(sth AND 11)
    POKE adr+&H40,sth
  ENDIF
RETURN
'
> PROCEDURE smppmark
  IF sblock=0 THEN
    sblock=1
  ELSE
    sblock=0
  ENDIF
RETURN
'
> PROCEDURE smploop
  IF sloop=0 THEN
    sloop=1
  ELSE
    sloop=0
  ENDIF
RETURN
'
> PROCEDURE opto
  stl=(stl AND 1)
  IF ad=0 THEN
    POKE adr,stl
  ELSE
    POKE adr,(stl+clk)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,17)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE dspoff
  std=(std AND 14)
  POKE adr+&H80,std
RETURN
'
> PROCEDURE dspin
  std=(std AND 14)
  std=std+1
  POKE adr+&H80,stl
RETURN
'
> PROCEDURE dspout
  std=(std AND 12)
  std=std+3
  POKE adr+&H80,stl
RETURN
'
> PROCEDURE coax
  stl=(stl AND 1)
  stl=stl+2
  IF ad=0 THEN
    POKE adr,stl
  ELSE
    POKE adr,(stl+clk)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,18)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE locking
  IF locknr=0 THEN
    locknr=1
    @setbutton(noval&,0)
    @setbutton(confid&,0)
    @setbutton(slipped&,0)
    @setbutton(crc&,0)
    @setbutton(parity&,0)
    @setbutton(biphase&,0)
    @setbutton(nolock&,0)
  ELSE
    locknr=0
  ENDIF
RETURN
'
> PROCEDURE prot
  IF protnr=0 THEN
    sth=(sth AND 14)
    sth=sth+1
    POKE adr+&H40,sth
    protnr=1
  ELSE
    sth=(sth AND 14)
    POKE adr+&H40,sth
    protnr=0
  ENDIF
RETURN
'
> PROCEDURE adlow
  clk=4
  IF ad=1 THEN
    @analog
  ENDIF
RETURN
'
> PROCEDURE admid
  clk=8
  IF ad=1 THEN
    @analog
  ENDIF
RETURN
'
> PROCEDURE adhigh
  clk=12
  IF ad=1 THEN
    @analog
  ENDIF
RETURN
'
> PROCEDURE analog
  IF nr<>smpedit& OR digana=TRUE THEN
    stl=(stl AND 2)
    stl=stl+1
    POKE adr,(stl+clk)
    ad=1
    IF nr=smp16& THEN
      a$=@rsc_text$(popups&,14)
      @textfeld(input&,a$,1)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE digital
  stl=(stl AND 2)
  POKE adr,stl
  ad=0
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,15)
    @textfeld(input&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE smpauto
  @smptime
  IF obj=recok& THEN
    retime=0
    ldlen=0
    th=257
    mem$=RIGHT$("00000000"+STR$(ln),8)
    IF nr=smp16& THEN
      textfeld(memused&,mem$,2)
    ENDIF
    @maschinit4
    IF hrd=0 THEN
      @maschinit3
      POKE maschprg%+111,0      ! REC-FIFO nicht loeschen
      IF blocks=0 THEN
        a=meml
        l=mlen
      ELSE
        @blocklook
        a=mcs
        l=mce-mcs
      ENDIF
      tr%=th
      sab%=a
      enb%=a+l
    ELSE
      @record3
    ENDIF
    IF (hrd=0 AND sblock=0) OR (hrd=0 AND sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0) OR (hrd=1 AND frag=1 AND nofile=0) THEN
      ~C:bmaschprg%(L:tr%)
    ENDIF
    IF ad=0 THEN
      hzc=3 AND (PEEK(adr))
    ENDIF
    IF (hrd=0 AND sblock=0) OR (hrd=0 AND sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0) THEN
      ~C:maschprg%(L:sab%,L:enb%,L:adk%)
      POKE maschprg%+111,2     ! REC_FIFO loeschen
    ENDIF
    IF hrd=1 THEN
      @record4
    ENDIF
    IF nr=smp16& THEN
      @setbutton(smpauto&,0)
    ENDIF
    IF nr=smpedit& THEN
      @setbutton(smpauto2&,0)
    ENDIF
    @record2
  ELSE
    IF nr=smp16& THEN
      @setbutton(smpauto&,0)
    ENDIF
    IF nr=smpedit& THEN
      @setbutton(smpauto2&,0)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE smpstart
  @smptime
  IF obj=recok& THEN
    ldlen=0
    IF hrd=0 THEN
      @record
    ELSE
      @record3
      @record4
    ENDIF
    IF nr=smp16& THEN
      @setbutton(smpstart&,0)
    ENDIF
    IF nr=smpedit& THEN
      @setbutton(smpstrt2&,0)
    ENDIF
    IF hrd=0 THEN
      @record2
    ENDIF
  ELSE
    IF nr=smp16& THEN
      @setbutton(smpstart&,0)
    ENDIF
    IF nr=smpedit& THEN
      @setbutton(smpstrt2&,0)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE record
  retime=0
  ldlen=0
  IF nr=smp16& THEN
    mem$=RIGHT$("00000000"+STR$(ln),8)
    textfeld(memused&,mem$,2)
  ENDIF
  IF nr=smpedit& THEN
    p$="    "+CHR$(0)
    @textfeld(smprate&,p$,1)
  ENDIF
  @maschinit3
  IF sblock=0 THEN
    a=meml
    l=mlen
  ELSE
    @blocklook
    a=mcs
    l=mce-mcs
  ENDIF
  IF ad=0 THEN
    hzc=3 AND (PEEK(adr))
  ENDIF
  IF sblock=0 OR (sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0) THEN
    @maschruf3
  ENDIF
RETURN
'
> PROCEDURE record2
  IF nr=smpedit& THEN
    @rsc_back(nr)
    @rsc_draw(nr,5)
    @clsed
    path$="MEMORY.SMP"
    path$=SPACE$(6)+path$+SPACE$(6)
    path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
    @textfeld(smpfile&,path$,1)
    mem$=RIGHT$("00000000"+STR$(ln),8)
    mem$="LEN "+mem$+" BYTES"+CHR$(0)
    @textfeld(smplen&,mem$,1)
    mem$=RIGHT$("00000000"+STR$(sec),8)
    mem$="IST CA."+mem$+" SEC"+CHR$(0)
    @textfeld(smpsec&,mem$,1)
    @curve(cs,ce)
  ENDIF
RETURN
'
> PROCEDURE record3
  retime=0
  ldlen=0
  '
  nofile=0
  IF hrd=1 THEN
    GET xwidth/2-170,ywidth/2-170,xwidth/2+170,ywidth/2+170,cb$
    FILESELECT op$+"*.SMP","",pat$
    PUT xwidth/2-170,ywidth/2-170,cb$
    IF pat$="" THEN
      nofile=1
    ELSE
      IF RIGHT$(pat$,1)="\" THEN
        nofile=1
      ENDIF
    ENDIF
    IF nofile=0 THEN
      IF INSTR(pat$,".")=0 THEN
        pat$=pat$+".SMP"
      ENDIF
      pa$=pat$+CHR$(0)
      @makehz
      f=min*60*hz*4
      sectors=INT(f/flen)
      REPEAT
        g=INSTR(pat$,"\")
        IF g>0 THEN
          pat$=RIGHT$(pat$,(LEN(pat$)-g))
        ENDIF
        g2=INSTR(pat$,":")
        IF g2>0 THEN
          pat$=RIGHT$(pat$,(LEN(pat$)-g2))
        ENDIF
      UNTIL g=0 AND g2=0
      pat$=SPACE$(6)+pat$+SPACE$(6)
      pat$=MID$(pat$,INT(LEN(pat$)/2)-5,12)+CHR$(0)
      IF nr=smpedit& THEN
        @textfeld(smpfile&,pat$,1)
        mem$=RIGHT$("00000000"+STR$(f),8)
        mem$="LEN "+mem$+" BYTES"+CHR$(0)
        @textfeld(smplen&,mem$,1)
        hsec=INT(f/(hz*4))
        mem$=RIGHT$("00000000"+STR$(hsec),8)
        mem$="IST CA."+mem$+" SEC"+CHR$(0)
        @textfeld(smpsec&,mem$,1)
      ENDIF
      IF nr=smp16& THEN
        @textfeld(datei&,pat$,2)
        mem$=RIGHT$("00000000"+STR$(f),8)
        @textfeld(memused&,mem$,2)
      ENDIF
      @maschinit8
      IF hrd=1 THEN
        ALERT 2,"HD-AUFNAHME ?",2,"JA|NEIN",frag
      ENDIF
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE record4
  IF hrd=1 THEN
    IF frag=1 AND nofile=0 THEN
      @maschruf8
    ENDIF
    IF nr=smpedit& THEN
      @textfeld(smpfile&,path$,1)
      mem$=RIGHT$("00000000"+STR$(ln),8)
      mem$="LEN "+mem$+" BYTES"+CHR$(0)
      @textfeld(smplen&,mem$,1)
      mem$=RIGHT$("00000000"+STR$(sec),8)
      mem$="IST CA."+mem$+" SEC"+CHR$(0)
      @textfeld(smpsec&,mem$,1)
    ENDIF
    IF nr=smp16& THEN
      @textfeld(datei&,path$,2)
      mem$=RIGHT$("00000000"+STR$(ln),8)
      @textfeld(memused&,mem$,2)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE play
  sth=(sth AND 11)
  sth=sth+4
  POKE adr+&H40,sth
  mem$=RIGHT$("00000000"+STR$(ln),8)
  textfeld(memused&,mem$,2)
  @smpplay
  @setbutton(play&,32)
  sth=(sth AND 11)
  POKE adr+&H40,sth
RETURN
'
> PROCEDURE fsel
  pathmrk$=path$
  lnmrk=ln
  memlmrk=meml
  secmrk=sec
  @ldhlp
  IF anfloadx<>0 AND anfloadx<>-1 AND (ln-abz)<=mlen AND lready=1 THEN
    IF path$<>"" AND RIGHT$(path$,1)<>"\" AND pathda=TRUE THEN
      @textfeld(datei&,path$,2)
      mem$=RIGHT$("00000000"+STR$(ln),8)
      @textfeld(memused&,mem$,2)
    ENDIF
    ~MFREE(anfloadx)
    IF hz=32000 THEN
      a$=@rsc_text$(popups&,10)
      @textfeld(rate2&,a$,1)
      @adlow
    ENDIF
    IF hz=44100 THEN
      a$=@rsc_text$(popups&,11)
      @textfeld(rate2&,a$,1)
      @admid
    ENDIF
    IF hz=48000 THEN
      a$=@rsc_text$(popups&,12)
      @textfeld(rate2&,a$,1)
      @adhigh
    ENDIF
  ENDIF
  @setbutton(filesel&,32)
RETURN
'
> PROCEDURE edhandler
  IF locknr=0 THEN
    c=3 AND (PEEK(adr))
    IF c<>merkc THEN
      merkc=c
      IF c=3 THEN
        IF merkfreq<>0 THEN
          @setbutton(merkfreq,0)
        ENDIF
        @setbutton(smp32&,1)
        merkfreq=smp32&
      ENDIF
      IF c=0 THEN
        IF merkfreq<>0 THEN
          @setbutton(merkfreq,0)
        ENDIF
        @setbutton(smp44&,1)
        merkfreq=smp44&
      ENDIF
      IF c=2 THEN
        IF merkfreq<>0 THEN
          @setbutton(merkfreq,0)
        ENDIF
        @setbutton(smp48&,1)
        merkfreq=smp48&
      ENDIF
    ENDIF
  ENDIF
  IF locknr=0 THEN
    '
    '
    a=PEEK(adr)           ! Status Low
    a=(a AND 15)
    b=PEEK(adr+&H20)      ! Status Mid
    b=(b AND 7)
    IF merk1<>a OR merk2<>b THEN
      merk1=a
      merk2=b
      sth=(sth AND 7)
      POKE adr+&H40,sth
      sth=(sth AND 7)
      sth=sth+8
      POKE adr+&H40,sth
      sth=(sth AND 7)
      POKE adr+&H40,sth
      IF b=0 THEN
        IF merkerr<>0 THEN
          @setbutton(merkerr,0)
          merkerr=0
          errdel=1
        ENDIF
      ENDIF
      IF b=1 THEN
        IF merkerr<>0 THEN
          @setbutton(merkerr,0)
        ENDIF
        @setbutton(noval&,1)
        merkerr=noval&
        errdel=1
      ENDIF
      IF b=2 THEN
        IF merkerr<>0 THEN
          @setbutton(merkerr,0)
        ENDIF
        @setbutton(confid&,1)
        merkerr=confid&
        errdel=1
      ENDIF
      IF b=3 THEN
        IF merkerr<>0 THEN
          @setbutton(merkerr,0)
        ENDIF
        @setbutton(slipped&,1)
        merkerr=slipped&
        errdel=1
      ENDIF
      IF b=4 THEN
        IF merkerr<>0 THEN
          @setbutton(merkerr,0)
        ENDIF
        @setbutton(crc&,1)
        merkerr=crc&
        errdel=1
      ENDIF
      IF b=5 THEN
        IF merkerr<>0 THEN
          @setbutton(merkerr,0)
        ENDIF
        @setbutton(parity&,1)
        merkerr=parity&
        errdel=1
      ENDIF
      IF b=6 THEN
        IF merkerr<>0 THEN
          @setbutton(merkerr,0)
        ENDIF
        @setbutton(biphase&,1)
        merkerr=biphase&
        errdel=1
      ENDIF
      IF b=7 THEN
        IF merkerr<>0 THEN
          @setbutton(merkerr,0)
        ENDIF
        @setbutton(nolock&,1)
        merkerr=nolock&
        errdel=1
      ENDIF
    ENDIF
    '
    zi=zi+1
    IF zi=2000 OR errdel=1 THEN
      zi=0
      errdel=0
      sth=(sth AND 7)
      sth=sth+8
      POKE adr+&H40,sth
      a=PEEK(adr)           ! Status Low
      a=(a AND 4)
      b=PEEK(adr+&H20)      ! Status Mid
      b=(b AND 7)
      IF merk3<>a OR merk4<>b THEN
        merk3=a
        merk4=b
        IF (b AND 4)=4 THEN
          @setbutton(prot&,1)
        ELSE
          @setbutton(prot&,0)
        ENDIF
        IF (a AND 4)=4 THEN
          @setbutton(emph&,0)
        ELSE
          @setbutton(emph&,1)
        ENDIF
        IF (b AND 1)=1 THEN
          '    "CONSUMER"
          @setbutton(use&,0)
        ELSE
          '    "PROFI"
          @setbutton(use&,1)
        ENDIF
        IF (b AND 2)=2 THEN
          '    "DIGITAL"
          @setbutton(audio&,1)
        ELSE
          '    "DATA"
          @setbutton(audio&,0)
        ENDIF
      ENDIF
      PAUSE 3
      sth=(sth AND 7)
      POKE adr+&H40,sth
    ENDIF
    '
  ENDIF
RETURN
'
> PROCEDURE smpstf
  @sbtest
  @sbtest2
  t$="S"
  IF sms<6 THEN
    msms=sms
  ENDIF
  sms=6
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=11
  IF stfx=-1 THEN
    @markhlp
    stfx=0
    @markhlp2
    @markhlp3(stfx,smptsava&)
    TEXT stfx+xd-3,stay1,t$
  ELSE
    bx=stex
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE smpef
  t$="S"
  @sbtest
  @sbtest2
  IF sme<6 THEN
    msme=sme
  ENDIF
  sme=6
  IF master<>0 AND master<11 THEN
    hac$=" "+CHR$(0)
    @textfeld(masthlp,hac$,1)
  ENDIF
  master=12
  IF efx=-1 THEN
    @markhlp
    efx=0
    @markhlp2
    @markhlp3(efx,smptsavb&)
    TEXT efx+xd-3,stay1,t$
  ELSE
    bx=efx
    @markhlp4
  ENDIF
RETURN
'
> PROCEDURE maschruf
  ' LOAD/SAVE + PLAY
  '
  saa%=a
  sba%=b
  ena%=l
  ~C:maschprg%(L:saa%,L:sba%,L:ena%)
RETURN
'
> PROCEDURE maschinit
  ' LOAD/SAVE
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0  ; von
  ' 226F0044                       movea.l   68(sp),a1  ; nach
  ' 202F0048                       move.l    72(sp),d0 ; Len
  ' D088                           add.l     a0,d0
  ' 12D8                 anf2:     move.b    (a0)+,(a1)+
  ' B1C0                           cmp.l     d0,a0
  ' 6600FFFA                       bne       anf2
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfmasch:
  DATA &H48e7,&Hfffe
  DATA &H206f,&H0040
  DATA &H226f,&H0044
  DATA &H202F,&H0048
  DATA &Hd088
  DATA &H12d8
  DATA &Hb1c0
  DATA &H6600,&Hfffa
  DATA &H4cdf,&H7fff
  DATA &H4e75
  '
  RESTORE anfmasch
  m$=SPACE$(34)
  maschmerk=VARPTR(m$)
  IF maschmerk>0 AND maschmerk<>-1 THEN
    maschprg%=(INT(maschmerk/2))*2+2
    FOR g=0 TO 30 STEP 2
      READ a
      DPOKE maschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschinit2
  ' PLAY
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 262F0048                       move.l    72(sp),d3 ; loop
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4879000000FE                   pea       ptr
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43F9000000F8                   lea.l     rett,a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43F9000000F0                   lea.l     neuikbd,a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 10BC0004                       move.b    #4,(a0)
  ' 7808                           moveq.l   #8,d4               ; Anzahl der Backstep
  ' 49F900000100                   lea.l     merk,a4
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                 anf0:     movea.l   a3,a2
  ' 1010                 anf1:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf2:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfgen (Kennung fr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfgen (Kennung fr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 660C                           bne.s     weg
  ' 95C4                           suba.l    d4,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 66C6                           bne.s     anf1
  ' 4A83                           tst.l     d3
  ' 6702                           beq.s     weg
  ' 60BE                           bra.s     anf0
  ' 4879000000FF         weg:      pea       ptr2
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43F9000000F8                   lea.l     rett,a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 33FC000100000100     neuikbd:  move.w    #1,merk
  ' 4EF9000000F8         rett:     jmp       rett
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 0000                 merk:     Dc.w 0
  '
anfbmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H262F,&H0048
  DATA &H48E7,&HFFFE
  DATA &H4879,&H0000,&H00FE
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43F9,&H0000,&H00F8
  DATA &H2368,&H0020,&H0002
  DATA &H43F9,&H0000,&H00F0
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H10BC,&H0004
  DATA &H7800
  DATA &H49F9,&H0000,&H0100
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H3014
  DATA &H660C
  DATA &H95C4
  DATA &HB5C1
  DATA &H66C6
  DATA &H4A83
  DATA &H6702
  DATA &H60BE
  DATA &H4879,&H0000,&H00FF
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43F9,&H0000,&H00F8
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H0100
  DATA &H4EF9,&H0000,&H00F8
  DATA &H1208
  DATA &H0000
  '
  RESTORE anfbmasch
  m$=SPACE$(260)
  maschmerk=VARPTR(m$)
  IF maschmerk>0 AND maschmerk<>-1 THEN
    maschprg%=(INT(maschmerk/2))*2+2
    FOR g=0 TO 256 STEP 2
      READ a
      DPOKE maschprg%+g,a
    NEXT g
  ENDIF
  retanz=117    ! Stelle fuer Anzahl der Rueckspruenge bei RETPLAY
  LPOKE maschprg%+22,maschprg%+254    !ptr
  LPOKE maschprg%+196,maschprg%+255   !ptr2
  LPOKE maschprg%+120,maschprg%+256   !merk
  LPOKE maschprg%+244,maschprg%+256   !merk
  LPOKE maschprg%+88,maschprg%+240   !neuikbd
  LPOKE maschprg%+76,maschprg%+248   !rett
  LPOKE maschprg%+76,maschprg%+248   !rett
  LPOKE maschprg%+224,maschprg%+248   !rett
RETURN
'
> PROCEDURE maschinit3
  ' RECORD
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 2A6F0048                       movea.l   72(sp),a5 ; adr
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43F900000100                   lea.l     rett,a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43F9000000F8                   lea.l     neuikbd,a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Word-adressiert !!
  ' 10BC0002                       move.b    #2,(a0)   ; REC-FIFO loeschen, SWDIGOUT=0
  ' 10BC0000                       move.b    #0,(a0)
  ' DBFC00000002                   add.l     #2,a5
  ' 284D                           move.l    a5,a4
  ' 9BFC00000002                   sub.l     #2,a5
  ' 7408                           moveq.l   #8,d2
  ' 7601                           moveq.l   #1,d3
  ' 244B                 anf0:     movea.l   a3,a2
  ' 1010                 ctrl1:    move.b    (a0),d0   ; Daten gltig ?
  ' C003                           and.b     d3,d0
  ' 67FA                           beq.s     ctrl1
  ' 3E11                           move.w    (a1),d7   ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0507                           btst      d2,d7
  ' 66F2                           bne.s     anf0      ; fehlerhafte Daten ?
  ' 1010                 ctrl2:    move.b    (a0),d0   ; Daten gltig ?
  ' C003                           and.b     d3,d0
  ' 67FA                           beq.s     ctrl2
  ' 3C11                           move.w    (a1),d6   ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0506                           btst      d2,d6
  ' 66E6                           bne.s     anf0      ; fehlerhafte Daten ?
  ' 1010                 ctrl3:    move.b    (a0),d0   ; Daten gltig ?
  ' C003                           and.b     d3,d0
  ' 67FA                           beq.s     ctrl3
  ' 3A11                           move.w    (a1),d5   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0505                           btst      d2,d5
  ' 67DA                           beq.s     anf0      ; fehlerhafte Daten ?
  ' 1010                 ctrl4:    move.b    (a0),d0   ; Daten gltig ?
  ' C003                           and.b     d3,d0
  ' 67FA                           beq.s     ctrl4
  ' 3811                           move.w    (a1),d4   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0504                           btst      d2,d4
  ' 67CE                           beq.s     anf0      ; fehlerhafte Daten ?
  ' 14C7                           move.b    d7,(a2)+
  ' 14C6                           move.b    d6,(a2)+
  ' 14C5                           move.b    d5,(a2)+
  ' 14C4                           move.b    d4,(a2)+
  ' 3014                           move.w    (a4),d0
  ' 6604                           bne.s     weg
  ' B5C1                           cmpa.l    d1,a2
  ' 66C0                           bne.s     ctrl1
  ' DBFC00000001         weg:      add.l     #1,a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43F900000100                   lea.l     rett,a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 33FC000100000108     neuikbd:  move.w    #1,merk
  ' 4EF900000100         rett:     jmp       rett
  ' 12                   ptr:      DC.b $12
  ' 08                   ptr2:     DC.b $8
  ' 0000                 merk:     DC.w 0
anfcmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H2A6F,&H0048
  DATA &H48E7,&HFFFE
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43F9,&H0000,&H0100
  DATA &H2368,&H0020,&H0002
  DATA &H43F9,&H0000,&H00F8
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H10BC,&H0002
  DATA &H10BC,&H0000
  DATA &HDBFC,&H0000,&H0002
  DATA &H284D
  DATA &H9BFC,&H0000,&H0002
  DATA &H7408
  DATA &H7601
  DATA &H244B
  DATA &H1010
  DATA &HC003
  DATA &H67FA
  DATA &H3E11
  DATA &H0507
  DATA &H66F2
  DATA &H1010
  DATA &HC003
  DATA &H67FA
  DATA &H3C11
  DATA &H0506
  DATA &H66E6
  DATA &H1010
  DATA &HC003
  DATA &H67FA
  DATA &H3A11
  DATA &H0505
  DATA &H67DA
  DATA &H1010
  DATA &HC003
  DATA &H67FA
  DATA &H3811
  DATA &H0504
  DATA &H67CE
  DATA &H14C7
  DATA &H14C6
  DATA &H14C5
  DATA &H14C4
  DATA &H3014
  DATA &H6604
  DATA &HB5C1
  DATA &H66C0
  DATA &HDBFC,&H0000,&H0001
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43F9,&H0000,&H0100
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H0108
  DATA &H4EF9,&H0000,&H0100
  DATA &H1208
  DATA &H0000
  '
  RESTORE anfcmasch
  m$=SPACE$(270)
  maschmerk=VARPTR(m$)
  IF maschmerk>0 AND maschmerk<>-1 THEN
    maschprg%=(INT(maschmerk/2))*2+2
    FOR g=0 TO 264 STEP 2
      READ a
      DPOKE maschprg%+g,a
    NEXT g
  ENDIF
  LPOKE maschprg%+72,maschprg%+256    !rett
  LPOKE maschprg%+84,maschprg%+248    !neuikbd
  LPOKE maschprg%+232,maschprg%+256    !rett
  LPOKE maschprg%+252,maschprg%+264    !merk
  adk%=maschprg%+262
RETURN
'
> PROCEDURE maschinit4
  ' RECORD AUTO-WAIT
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 2E2F0040                       move.l    64(sp),d7 ; treshold
  ' 13FC000200DF0441               move.b    #2,$df0441      ; REC-FIFO loeschen
  ' 13FC000000DF0441               move.b    #0,$df0441
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 4CDF7FFF             weiter:   movem.l   (sp)+,d0-d7/a0-a6
  ' 48E77FFE             anf2:     movem.l   d1-d7/a0-a6,-(sp)
  ' 3F3C000B                       move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 660000DC                       bne       weg
  ' 323900DF04C0                   move.w    $df04c0,d1      ; auf 1 warten
  ' 08010008                       btst      #8,d1
  ' 67DA                           beq.s     anf2
  ' 323900DF04C0                   move.w    $df04c0,d1      ; wenn 0, weiter
  ' 08010008                       btst      #8,d1
  ' 66CE                           bne.s     anf2
  ' 024100FF                       andi.w    #$ff,d1
  ' E141                           asl.w     #8,d1
  ' 343900DF04C0                   move.w    $df04c0,d2      ; wenn 0, weiter
  ' 08020008                       btst      #8,d2
  ' 66BC                           bne.s     anf2
  ' 024200FF                       andi.w    #$ff,d2
  ' D242                           add.w     d2,d1
  ' 343900DF04C0                   move.w    $df04c0,d2      ; wenn 1, weiter
  ' 08020008                       btst      #8,d2
  ' 67AA                           beq.s     anf2
  ' 024200FF                       andi.w    #$ff,d2
  ' E142                           asl.w     #8,d2
  ' 363900DF04C0                   move.w    $df04c0,d3      ; wenn 1, weiter
  ' 08030008                       btst      #8,d3
  ' 6798                           beq.s     anf2
  ' 024300FF                       andi.w    #$ff,d3
  ' D443                           add.w     d3,d2
  ' 363900DF04C0                   move.w    $df04c0,d3      ; wenn 0, weiter
  ' 08030008                       btst      #8,d3
  ' 6686                           bne.s     anf2
  ' 024300FF                       andi.w    #$ff,d3
  ' E143                           asl.w     #8,d3
  ' 383900DF04C0                   move.w    $df04c0,d4      ; wenn 0, weiter
  ' 08040008                       btst      #8,d4
  ' 6600FF74                       bne       anf2
  ' 024400FF                       andi.w    #$ff,d4
  ' D644                           add.w     d4,d3
  ' 383900DF04C0                   move.w    $df04c0,d4      ; wenn 1, weiter
  ' 08040008                       btst      #8,d4
  ' 6700FF60                       beq       anf2
  ' 024400FF                       andi.w    #$ff,d4
  ' E144                           asl.w     #8,d4
  ' 3A3900DF04C0                   move.w    $df04c0,d5      ; wenn 1, weiter
  ' 08050008                       btst      #8,d5
  ' 6700FF4C                       beq       anf2
  ' 024500FF                       andi.w    #$ff,d5
  ' D845                           add.w     d5,d4
  ' 0801000F                       btst      #15,d1          ; Oberstes Bit da ?
  ' 6702                           beq.s     weiter1         ; dann negieren
  ' 4641                           not.w     d1
  ' 0802000F             weiter1:  btst      #15,d2
  ' 6702                           beq.s     weiter2
  ' 4642                           not.w     d2
  ' 0803000F             weiter2:  btst      #15,d3
  ' 6702                           beq.s     weiter3
  ' 4643                           not.w     d3
  ' 0804000F             weiter3:  btst      #15,d4
  ' 6702                           beq.s     weiter4
  ' 4644                           not.w     d4
  ' B247                 weiter4:  cmp.w     d7,d1           ; treshold vergleichen
  ' 6F00FF20                       ble       anf2
  ' B447                           cmp.w     d7,d2
  ' 6F00FF1A                       ble       anf2
  ' B647                           cmp.w     d7,d3
  ' 6F00FF14                       ble       anf2
  ' B847                           cmp.w     d7,d4
  ' 6F00FF0E                       ble       anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfdmasch:
  DATA &H48E7,&HFFFE
  DATA &H2E2F,&H0040
  DATA &H13FC,&H0002,&H00DF,&H0441
  DATA &H13FC,&H0000,&H00DF,&H0441
  DATA &H48E7,&HFFFE
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H4CDF,&H7FFE
  DATA &H0C80,&H0000,&H0000
  DATA &H6600,&H00DC
  DATA &H3239,&H00DF,&H04C0
  DATA &H0801,&H0008
  DATA &H67DA
  DATA &H3239,&H00DF,&H04C0
  DATA &H0801,&H0008
  DATA &H66CE
  DATA &H0241,&H00FF
  DATA &HE141
  DATA &H3439,&H00DF,&H04C0
  DATA &H0802,&H0008
  DATA &H66BC
  DATA &H0242,&H00FF
  DATA &HD242
  DATA &H3439,&H00DF,&H04C0
  DATA &H0802,&H0008
  DATA &H67AA
  DATA &H0242,&H00FF
  DATA &HE142
  DATA &H3639,&H00DF,&H04C0
  DATA &H0803,&H0008
  DATA &H6798
  DATA &H0243,&H00FF
  DATA &HD443
  DATA &H3639,&H00DF,&H04C0
  DATA &H0803,&H0008
  DATA &H6686
  DATA &H0243,&H00FF
  DATA &HE143
  DATA &H3839,&H00DF,&H04C0
  DATA &H0804,&H0008
  DATA &H6600,&HFF74
  DATA &H0244,&H00FF
  DATA &HD644
  DATA &H3839,&H00DF,&H04C0
  DATA &H0804,&H0008
  DATA &H6700,&HFF60
  DATA &H0244,&H00FF
  DATA &HE144
  DATA &H3A39,&H00DF,&H04C0
  DATA &H0805,&H0008
  DATA &H6700,&HFF4C
  DATA &H0245,&H00FF
  DATA &HD845
  DATA &H0801,&H000F
  DATA &H6702
  DATA &H4641
  DATA &H0802,&H000F
  DATA &H6702
  DATA &H4642
  DATA &H0803,&H000F
  DATA &H6702
  DATA &H4643
  DATA &H0804,&H000F
  DATA &H6702
  DATA &H4644
  DATA &HB247
  DATA &H6F00,&HFF20
  DATA &HB447
  DATA &H6F00,&HFF1A
  DATA &HB647
  DATA &H6F00,&HFF14
  DATA &HB847
  DATA &H6F00,&HFF0E
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfdmasch
  bm$=SPACE$(310)
  bmaschmerk=VARPTR(bm$)
  IF bmaschmerk>0 AND bmaschmerk<>-1 THEN
    bmaschprg%=(INT(bmaschmerk/2))*2+2
    FOR g=0 TO 306 STEP 2
      READ a
      DPOKE bmaschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschruf3
  ' RECORD
  '
  sab%=a
  enb%=a+l-4
  ~C:maschprg%(L:sab%,L:enb%,L:adk%)
RETURN
'
> PROCEDURE maschinit5
  ' MITTELWERT-BERECHNEN
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' D3FC00000000                   adda.l    #0,a1
  ' 7200                           moveq.l   #0,d1
  ' 7400                           moveq.l   #0,d2
  ' 7600                           moveq.l   #0,d3
  ' 3610                 anf2:     move.w    (a0),d3
  ' D1FC00000004                   adda.l    #4,a0
  ' 0803000F                       btst      #15,d3
  ' 6702                           beq.s     anf3
  ' 4643                           not.w     d3
  ' D283                 anf3:     add.l     d3,d1
  ' 068200000001                   add.l     #1,d2
  ' B1C9                           cmp.l     a1,a0
  ' 6DE4                           blt.s     anf2
  ' 82C2                           divu.w    d2,d1
  ' 45FA000A                       lea.l     wert(pc),a2
  ' 3481                           move.w    d1,(a2)
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 00000000             wert:     dc.l 0
anfemasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &HD3FC,&H0000,&H0000
  DATA &H7200
  DATA &H7400
  DATA &H7600
  DATA &H3610
  DATA &HD1FC,&H0000,&H0004
  DATA &H0803,&H000F
  DATA &H6702
  '  DATA &H4643
  '
  DATA &HB1C9
  '
  DATA &HD283
  DATA &H0682,&H0000,&H0001
  DATA &HB1C9
  DATA &H6DE4
  DATA &H82C2
  DATA &H45FA,&H000A
  DATA &H3481
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H0000,&H0000
  '
  RESTORE anfemasch
  cm$=SPACE$(80)
  cmaschmerk=VARPTR(cm$)
  IF cmaschmerk>0 AND cmaschmerk<>-1 THEN
    cmaschprg%=(INT(cmaschmerk/2))*2+2
    FOR g=0 TO 68 STEP 2
      READ a
      DPOKE cmaschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschruf5
  sac%=i
  sbc%=i+4
  ~C:cmaschprg%(L:sac%,L:sbc%)
  a=DPEEK(cmaschprg%+66)
RETURN
'
> PROCEDURE maschinit6
  ' PEAKMETER
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 41FA01F6                       lea.l     wert(pc),a0
  ' 20EF0040                       move.l    64(sp),(a0)+
  ' 20EF0044                       move.l    68(sp),(a0)+
  ' 20EF0048                       move.l    72(sp),(a0)+
  ' 20EF004C                       move.l    76(sp),(a0)+
  ' 20EF0050                       move.l    80(sp),(a0)+
  ' 20EF0054                       move.l    84(sp),(a0)+
  ' 20EF0058                       move.l    88(sp),(a0)+
  ' 20EF005C                       move.l    92(sp),(a0)+
  ' 20EF0060                       move.l    96(sp),(a0)+
  ' 20EF0064                       move.l    100(sp),(a0)+
  ' 20EF0068                       move.l    104(sp),(a0)+
  ' 20EF006C                       move.l    108(sp),(a0)+
  ' 20EF0070                       move.l    112(sp),(a0)+
  ' 20EF0074                       move.l    116(sp),(a0)+
  ' 20EF0078                       move.l    120(sp),(a0)+
  ' 20EF007C                       move.l    124(sp),(a0)+
  ' 20EF0080                       move.l    128(sp),(a0)+
  ' 20EF0084                       move.l    132(sp),(a0)+
  ' 20EF0088                       move.l    136(sp),(a0)+
  ' 20AF008C                       move.l    140(sp),(a0)
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA019C                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA0160                       lea.l     rett(pc),a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43FA014E                       lea.l     neuikbd(pc),a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41FA0152                       lea.l     wert(pc),a0
  ' 49FA019E                       lea.l     merk(pc),a4
  ' 4DF900DF0441                   lea.l     $df0441,a6
  ' 7A01                           moveq.l   #1,d5
  ' 303900DF04C0         anf:      move.w    $df04c0,d0
  ' 08000008                       btst      #8,d0
  ' 6700FFF4                       beq       anf
  ' 1016                 anf2:     move.b    (a6),d0   ; Daten gltig ?
  ' C005                           and.b     d5,d0
  ' 670000DA                       beq       test
  ' 323900DF04C0                   move.w    $df04c0,d1
  ' 08010008                       btst      #8,d1
  ' 6600FFEC                       bne       anf2
  ' 1016                 ctrl1:    move.b    (a6),d0   ; Daten gltig ?
  ' C005                           and.b     d5,d0
  ' 670000C4                       beq       test
  ' 343900DF04C0                   move.w    $df04c0,d2
  ' 08020008                       btst      #8,d2
  ' 6600FFD6                       bne       anf2
  ' 1016                 anf3:     move.b    (a6),d0   ; Daten gltig ?
  ' C005                           and.b     d5,d0
  ' 670000AE                       beq       test
  ' 363900DF04C0                   move.w    $df04c0,d3
  ' 08030008                       btst      #8,d3
  ' 6700FFEC                       beq       anf3
  ' 1016                 ctrl2:    move.b    (a6),d0   ; Daten gltig ?
  ' C005                           and.b     d5,d0
  ' 67000098                       beq       test
  ' 383900DF04C0                   move.w    $df04c0,d4
  ' 08040008                       btst      #8,d4
  ' 6700FFD6                       beq       anf3
  ' 024100FF                       and.w     #$ff,d1
  ' E141                           asl.w     #8,d1
  ' 024200FF                       and.w     #$ff,d2
  ' D242                           add.w     d2,d1
  ' 024300FF                       and.w     #$ff,d3
  ' E143                           asl.w     #8,d3
  ' 024400FF                       and.w     #$ff,d4
  ' D644                           add.w     d4,d3
  ' 0801000F                       btst      #15,d1
  ' 6702                           beq.s     anf4
  ' 4641                           not.w     d1
  ' 0803000F             anf4:     btst      #15,d3
  ' 6702                           beq.s     anf5
  ' 4643                           not.w     d3
  ' C2FC000A             anf5:     mulu.w    #10,d1
  ' C6FC000A                       mulu.w    #10,d3
  ' 82FC7FFF                       divu.w    #32767,d1
  ' 86FC7FFF                       divu.w    #32767,d3
  ' 7C00                           moveq.l   #0,d6
  ' 7E00                           moveq.l   #0,d7
  ' 22706000             anfrs:    movea.l   0(a0,d6.w),a1
  ' B207                           cmp.b     d7,d1
  ' 6E06                           bgt.s     anfrs2
  ' 32BC0000                       move.w    #0,(a1)
  ' 6004                           bra.s     anfrs3
  ' 32BC0001             anfrs2:   move.w    #1,(a1)
  ' 5886                 anfrs3:   addq.l    #4,d6
  ' 5287                           addq.l    #1,d7
  ' BE3C000A                       cmp.b     #10,d7
  ' 66E4                           bne.s     anfrs
  ' 7E00                           moveq.l   #0,d7
  ' 22706000             anfls:    movea.l   0(a0,d6.w),a1
  ' B607                           cmp.b     d7,d3
  ' 6E06                           bgt.s     anfls2
  ' 32BC0000                       move.w    #0,(a1)
  ' 6004                           bra.s     anfls3
  ' 32BC0001             anfls2:   move.w    #1,(a1)
  ' 5886                 anfls3:   addq.l    #4,d6
  ' 5287                           addq.l    #1,d7
  ' BE3C000A                       cmp.b     #10,d7
  ' 66E4                           bne.s     anfls
  ' B23C000A                       cmp.b     #10,d1
  ' 6708                           beq.s     nixw1
  ' B63C000A                       cmp.b     #10,d3
  ' 6702                           beq.s     nixw1
  ' 6004                           bra.s     test
  ' 61000036             nixw1:    bsr       pause
  ' 3014                 test:     move.w    (a4),d0
  ' 6604                           bne.s     weg
  ' 6000FF1A                       bra       anf2
  ' 4BFA004B             weg:      lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA0028                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 3C3CFFFF             pause:    move.w    #-1,d6
  ' 3E3CFFFF             pause2:   move.w    #-1,d7
  ' 51CFFFFE             pause3:   dbra      d7,pause3
  ' 51CEFFF6                       dbra      d6,pause2
  ' 4E75                           rts
  ' 33FC00010000024C     neuikbd:  move.w    #1,merk
  ' 4EF9000001F4         rett:     jmp       rett
  ' 12                   ptr:      DC.b $12
  ' 08                   ptr2:     DC.b $8
  ' 00000000             wert:     ds.l 20
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 0000                 merk:     DC.w 0
anffmasch:
  '
  DATA &H48E7,&HFFFE
  DATA &H41FA,&H01F6
  DATA &H20EF,&H0040
  DATA &H20EF,&H0044
  DATA &H20EF,&H0048
  DATA &H20EF,&H004C
  DATA &H20EF,&H0050
  DATA &H20EF,&H0054
  DATA &H20EF,&H0058
  DATA &H20EF,&H005C
  DATA &H20EF,&H0060
  DATA &H20EF,&H0064
  DATA &H20EF,&H0068
  DATA &H20EF,&H006C
  DATA &H20EF,&H0070
  DATA &H20EF,&H0074
  DATA &H20EF,&H0078
  DATA &H20EF,&H007C
  DATA &H20EF,&H0080
  DATA &H20EF,&H0084
  DATA &H20EF,&H0088
  DATA &H20AF,&H008C
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H019C
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H0160
  DATA &H2368,&H0020,&H0002
  DATA &H43FA,&H014E
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H41FA,&H0152
  DATA &H49FA,&H019E
  DATA &H4DF9,&H00DF,&H0441
  DATA &H7A01
  DATA &H3039,&H00DF,&H04C0
  DATA &H0800,&H0008
  DATA &H6700,&HFFF4
  DATA &H1016
  DATA &HC005
  DATA &H6700,&H00DA
  DATA &H3239,&H00DF,&H04C0
  DATA &H0801,&H0008
  DATA &H6600,&HFFEC
  DATA &H1016
  DATA &HC005
  DATA &H6700,&H00C4
  DATA &H3439,&H00DF,&H04C0
  DATA &H0802,&H0008
  DATA &H6600,&HFFD6
  DATA &H1016
  DATA &HC005
  DATA &H6700,&H00AE
  DATA &H3639,&H00DF,&H04C0
  DATA &H0803,&H0008
  DATA &H6700,&HFFEC
  DATA &H1016
  DATA &HC005
  DATA &H6700,&H0098
  DATA &H3839,&H00DF,&H04C0
  DATA &H0804,&H0008
  DATA &H6700,&HFFD6
  DATA &H0241,&H00FF
  DATA &HE141
  DATA &H0242,&H00FF
  DATA &HD242
  DATA &H0243,&H00FF
  DATA &HE143
  DATA &H0244,&H00FF
  DATA &HD644
  DATA &H0801,&H000F
  DATA &H6702
  DATA &H4641
  DATA &H0803,&H000F
  DATA &H6702
  DATA &H4643
  DATA &HC2FC,&H000A
  DATA &HC6FC,&H000A
  DATA &H82FC,&H7FFF
  DATA &H86FC,&H7FFF
  DATA &H7C00
  DATA &H7E00
  DATA &H2270,&H6000
  DATA &HB207
  DATA &H6E06
  DATA &H32BC,&H0000
  DATA &H6004
  DATA &H32BC,&H0001
  DATA &H5886
  DATA &H5287
  DATA &HBE3C,&H000A
  DATA &H66E4
  DATA &H7E00
  DATA &H2270,&H6000
  DATA &HB607
  DATA &H6E06
  DATA &H32BC,&H0000
  DATA &H6004
  DATA &H32BC,&H0001
  DATA &H5886
  DATA &H5287
  DATA &HBE3C,&H000A
  DATA &H66E4
  DATA &HB23C,&H000A
  DATA &H6708
  DATA &HB63C,&H000A
  DATA &H6702
  DATA &H6004
  DATA &H6100,&H0036
  DATA &H3014
  DATA &H6604
  '  DATA &H6000,&HFF1A
  '
  DATA &H0803,&H0008
  '
  DATA &H4BFA,&H004B
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H0028
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H3C3C,&HFFFF
  DATA &H3E3C,&HFFFF
  DATA &H51CF,&HFFFE
  DATA &H51CE,&HFFF6
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H024C
  DATA &H4EF9,&H0000,&H01F4
  DATA &H1208
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000
  RESTORE anffmasch
  fm$=SPACE$(600)
  fmaschmerk=VARPTR(fm$)
  IF fmaschmerk>0 AND fmaschmerk<>-1 THEN
    fmaschprg%=(INT(fmaschmerk/2))*2+2
    FOR g=0 TO 588 STEP 2
      READ a
      DPOKE fmaschprg%+g,a
    NEXT g
  ENDIF
  LPOKE fmaschprg%+496,fmaschprg%+588    !merk
RETURN
'
> PROCEDURE maschruf6
  ~C:fmaschprg%(L:sr1%,L:sr2%,L:sr3%,L:sr4%,L:sr5%,L:sr6%,L:sr7%,L:sr8%,L:sr9%,L:sr10%,L:sl1%,L:sl2%,L:sl3%,L:sl4%,L:sl5%,L:sl6%,L:sl7%,L:sl8%,L:sl9%,L:sl10%)
RETURN
'
> PROCEDURE maschinit7
  ' HARDDISK-PLAY
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       movea.l   68(sp),a6  ; fname
  ' 242F0048                       move.l    72(sp),d2 ; sectors
  ' 2A2F004C                       move.l    76(sp),d5 ; len
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA014A                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 4BFA010E                       lea.l     rett(pc),a5
  ' 2B6800200002                   move.l    32(a0),2(a5)
  ' 4BFA00FC                       lea.l     neuikbd(pc),a5
  ' 214D0020                       move.l    a5,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FEFE                       movem.l   d0-d6/a0-a6,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)  ; Fopen
  ' 2F0E                           move.l    a6,-(sp)
  ' 3F3C003D                       move.w    #61,-(sp)
  ' 4E41                           trap      #1
  ' 508F                           addq.l    #8,sp
  ' 3E00                           move.w    d0,d7
  ' 4CDF7F7F                       movem.l   (sp)+,d0-d6/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0          ; Flagstatus
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 49FA00DC                       lea.l     merk(pc),a4
  ' 220B                           move.l    a3,d1     ; MEMende
  ' D285                           add.l     d5,d1
  ' 7C00                           moveq.l   #0,d6
  ' 10BC0004                       move.b    #4,(a0)   ; DIGOUT setzen
  ' 7804                           moveq.l   #4,d4
  ' 7608                           moveq.l   #8,d3
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                           movea.l   a3,a2
  ' 48E7FFF8                       movem.l   d0-d7/a0-a4,-(sp)
  ' 2F0B                           move.l    a3,-(sp)  ; Fread
  ' 2F05                           move.l    d5,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF1FFF                       movem.l   (sp)+,d0-d7/a0-a4
  ' 1010                           move.b    (a0),d0   ; FIFO halbleer ?
  ' 02000008                       andi.b    #8,d0
  ' 6724                           beq.s     anf2
  ' 2F01                           move.l    d1,-(sp)
  ' 303C03FF                       move.w    #$3ff,d0     ; ...dann FIFO halb-fuellen (FIFO-LEN/2/4-1)!
  ' 121A                 copy:     move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 51C8FFE6                       dbra      d0,copy
  ' 221F                           move.l    (sp)+,d1
  ' 1010                 anf2:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf2
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf3
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf4
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf5:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf5
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 660A                           bne.s     weg
  ' B5C1                           cmpa.l    d1,a2
  ' 66C8                           bne.s     anf2
  ' BC82                           cmp.l     d2,d6
  ' 6600FF7C                       bne       anf
  ' 3F07                 weg:      move.w    d7,-(sp)  ; Fclose
  ' 3F3C003E                       move.w    #62,-(sp)
  ' 4E41                           trap      #1
  ' 588F                           addq.l    #4,sp
  ' 4BFA0039                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA0016                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 33FC000100000166     neuikbd:  move.w    #1,merk
  ' 4EF90000015E         rett:     jmp       rett
  ' 12                   ptr:      DC.b $12
  ' 08                   ptr2:     DC.b $8
  ' 0000                 merk:     DC.w 0
anfgmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H242F,&H0048
  DATA &H2A2F,&H004C
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H014A
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H4BFA,&H010E
  DATA &H2B68,&H0020,&H0002
  DATA &H4BFA,&H00FC
  DATA &H214D,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFEFE
  DATA &H3F3C,&H0000
  DATA &H2F0E
  DATA &H3F3C,&H003D
  DATA &H4E41
  DATA &H508F
  DATA &H3E00
  DATA &H4CDF,&H7F7F
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H49FA,&H00DC
  DATA &H220B
  DATA &HD285
  DATA &H7C00
  DATA &H10BC,&H0004
  DATA &H7804
  DATA &H7608
  DATA &H5286
  DATA &H244B
  DATA &H48E7,&HFFF8
  DATA &H2F0B
  DATA &H2F05
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H1FFF
  DATA &H1010
  DATA &H0200,&H0008
  DATA &H6724
  DATA &H2F01
  DATA &H303C,&H03FF
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H51C8,&HFFE6
  DATA &H221F
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H3014
  DATA &H660A
  DATA &HB5C1
  DATA &H66C8
  DATA &HBC82
  DATA &H6600,&HFF7C
  DATA &H3F07
  DATA &H3F3C,&H003E
  DATA &H4E41
  DATA &H588F
  DATA &H4BFA,&H0039
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H0016
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H0166
  DATA &H4EF9,&H0000,&H015E
  DATA &H1208
  DATA &H0000
  '
  RESTORE anfgmasch
  gm$=SPACE$(370)
  gmaschmerk=VARPTR(gm$)
  IF gmaschmerk>0 AND gmaschmerk<>-1 THEN
    gmaschprg%=(INT(gmaschmerk/2))*2+2
    FOR g=0 TO 358 STEP 2
      READ a
      DPOKE gmaschprg%+g,a
    NEXT g
  ENDIF
  LPOKE gmaschprg%+346,gmaschprg%+358    !merk
  fifofill=playfifolen/8-1
  DPOKE gmaschprg%+194,fifofill
RETURN
'
> PROCEDURE maschruf7
  sbd%=VARPTR(pa$)        !Pfad
  scd%=sectors            !sectors
  sdd%=flen               !len
  ~C:gmaschprg%(L:sad%,L:sbd%,L:scd%,L:sdd%)
RETURN
'
> PROCEDURE maschinit8
  ' HARDDISK-RECORD
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       movea.l   68(sp),a6  ; fname
  ' 2A2F0048                       move.l    72(sp),d5 ; sectors
  ' 282F004C                       move.l    76(sp),d4 ; len
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA0148                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 4BFA010C                       lea.l     rett(pc),a5
  ' 2B6800200002                   move.l    32(a0),2(a5)
  ' 4BFA00FA                       lea.l     neuikbd(pc),a5
  ' 214D0020                       move.l    a5,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FEFE                       movem.l   d0-d6/a0-a6,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)  ; Fcreate
  ' 2F0E                           move.l    a6,-(sp)
  ' 3F3C003C                       move.w    #60,-(sp)
  ' 4E41                           trap      #1
  ' 508F                           addq.l    #8,sp
  ' 3E00                           move.w    d0,d7
  ' 4CDF7F7F                       movem.l   (sp)+,d0-d6/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0          ; Flagstatus
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 49FA00DA                       lea.l     merk(pc),a4
  ' 220B                           move.l    a3,d1         ; MEMende
  ' D284                           add.l     d4,d1
  ' 7401                           moveq.l   #1,d2
  ' 7608                           moveq.l   #8,d3
  ' 10BC0002                       move.b    #2,(a0)   ; REC-FIFO l”schen, SWDIGOUT=0
  ' 10BC0000                       move.b    #0,(a0)
  ' 7C00                           moveq.l   #0,d6
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                 anf1:     movea.l   a3,a2
  ' 1010                 ctrl1:    move.b    (a0),d0   ; Daten gltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl1
  ' 3011                           move.w    (a1),d0   ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0700                           btst      d3,d0
  ' 66F4                           bne.s     ctrl1      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl2:    move.b    (a0),d0   ; Daten gltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl2
  ' 3011                           move.w    (a1),d0   ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0700                           btst      d3,d0
  ' 66F4                           bne.s     ctrl2      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl3:    move.b    (a0),d0   ; Daten gltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl3
  ' 3011                           move.w    (a1),d0   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0700                           btst      d3,d0
  ' 67F4                           beq.s     ctrl3      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl4:    move.b    (a0),d0   ; Daten gltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl4
  ' 3011                           move.w    (a1),d0   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0700                           btst      d3,d0
  ' 67F4                           beq.s     ctrl4      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' B5C1                           cmpa.l    d1,a2
  ' 66C4                           bne.s     ctrl1
  ' 48E77FF8                       movem.l   d1-d7/a0-a4,-(sp)
  ' 2F0B                           move.l    a3,-(sp)  ; Fwrite
  ' 2F04                           move.l    d4,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C0040                       move.w    #64,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 6B26                           bmi.s     weg
  ' B880                           cmp.l     d0,d4
  ' 6622                           bne.s     weg
  ' 3014                           move.w    (a4),d0
  ' 661E                           bne.s     weg
  ' 1010                           move.b    (a0),d0   ; Flag lesen
  ' 02000002                       andi.b    #2,d0     ; FIFO mehr als halbvoll ?
  ' 6612                           bne.s     nocopy    ; wenn nein, normal weiter
  ' 244B                           movea.l   a3,a2
  ' 5286                           addq.l    #1,d6
  ' 303C0FFF             copy:     move.w    #$0fff,d0 ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
  ' 14E90001             copy2:    move.b    1(a1),(a2)+   ; FIFO auslesen
  ' 51C8FFFA                       dbra      d0,copy2
  ' 6088                           bra.s     ctrl1
  ' BC85                 nocopy:   cmp.l     d5,d6
  ' 6680                           bne.s     anf
  ' 3F07                 weg:      move.w    d7,-(sp)  ; Fclose
  ' 3F3C003E                       move.w    #62,-(sp)
  ' 4E41                           trap      #1
  ' 588F                           addq.l    #4,sp
  ' 4BFA0039                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA0016                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 33FC000100000164     neuikbd:  move.w    #1,merk
  ' 4EF90000015C         rett:     jmp       rett
  ' 12                   ptr:      DC.b $12
  ' 08                   ptr2:     DC.b $8
  ' 0000                 merk:     DC.w 0
anfhmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H2A2F,&H0048
  DATA &H282F,&H004C
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H0148
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H4BFA,&H010C
  DATA &H2B68,&H0020,&H0002
  DATA &H4BFA,&H00FA
  DATA &H214D,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFEFE
  DATA &H3F3C,&H0000
  DATA &H2F0E
  DATA &H3F3C,&H003C
  DATA &H4E41
  DATA &H508F
  DATA &H3E00
  DATA &H4CDF,&H7F7F
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H49FA,&H00DA
  DATA &H220B
  DATA &HD284
  DATA &H7401
  DATA &H7608
  DATA &H10BC,&H0002
  DATA &H10BC,&H0000
  DATA &H7C00
  DATA &H5286
  DATA &H244B
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H66F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H66F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H67F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H67F4
  DATA &H14C0
  DATA &HB5C1
  DATA &H66C4
  DATA &H48E7,&H7FF8
  DATA &H2F0B
  DATA &H2F04
  DATA &H3F07
  DATA &H3F3C,&H0040
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H1FFE
  DATA &H6B26
  DATA &HB880
  DATA &H6622
  DATA &H3014
  DATA &H661E
  DATA &H1010
  DATA &H0200,&H0002
  DATA &H6612
  DATA &H244B
  DATA &H5286
  DATA &H303C,&H0FFF
  DATA &H14E9,&H0001
  DATA &H51C8,&HFFFA
  DATA &H6088
  DATA &HBC85
  DATA &H6680
  DATA &H3F07
  DATA &H3F3C,&H003E
  DATA &H4E41
  DATA &H588F
  DATA &H4BFA,&H0039
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H0016
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H0164
  DATA &H4EF9,&H0000,&H015C
  DATA &H1208
  DATA &H0000
  '
  RESTORE anfhmasch
  hm$=SPACE$(370)
  hmaschmerk=VARPTR(hm$)
  IF hmaschmerk>0 AND hmaschmerk<>-1 THEN
    hmaschprg%=(INT(hmaschmerk/2))*2+2
    FOR g=0 TO 356 STEP 2
      READ a
      DPOKE hmaschprg%+g,a
    NEXT g
  ENDIF
  LPOKE hmaschprg%+344,hmaschprg%+356    !merk
  fifofill=recfifolen/2-1
  DPOKE hmaschprg%+270,fifofill
RETURN
'
> PROCEDURE maschruf8
  sbe%=VARPTR(pa$)        !Pfad
  sce%=sectors            !sectors
  sde%=flen               !len
  ~C:hmaschprg%(L:sad%,L:sbe%,L:sce%,L:sde%)
RETURN
'
> PROCEDURE maschinit9
  ' CUT
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 7000                           moveq.l   #0,d0
  ' 20C0                 anf2:     move.l    d0,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DFA                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfimasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H7000
  DATA &H20C0
  DATA &HB1C9
  DATA &H6DFA
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfimasch
  im$=SPACE$(30)
  imaschmerk=VARPTR(im$)
  IF imaschmerk>0 AND imaschmerk<>-1 THEN
    imaschprg%=(INT(imaschmerk/2))*2+2
    FOR g=0 TO 24 STEP 2
      READ a
      DPOKE imaschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschruf9(ca,cb)
  cfa%=ca
  cfb%=cb
  ~C:imaschprg%(L:cfa%,L:cfb%)
RETURN
'
> PROCEDURE maschinit10
  ' COPY
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 246F0048                       movea.l   72(sp),a2 ; dest
  ' 266F004C                       movea.l   76(sp),a3 ; grenzwert
  ' 24D8                 anf2:     move.l    (a0)+,(a2)+
  ' B1C9                           cmp.l     a1,a0
  ' 6C04                           bge.s     weg
  ' B5CB                           cmp.l     a3,a2
  ' 6DF6                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfjmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H266F,&H004C
  DATA &H24D8
  DATA &HB1C9
  DATA &H6C04
  DATA &HB5CB
  DATA &H6DF6
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfjmasch
  jm$=SPACE$(40)
  jmaschmerk=VARPTR(jm$)
  IF jmaschmerk>0 AND jmaschmerk<>-1 THEN
    jmaschprg%=(INT(jmaschmerk/2))*2+2
    FOR g=0 TO 34 STEP 2
      READ a
      DPOKE jmaschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschruf10(ca,cb,cc,cd)
  cfa%=ca
  cfb%=cb
  cfc%=cc
  cfd%=cd
  ~C:jmaschprg%(L:cfa%,L:cfb%,L:cfc%,L:cfd%)
RETURN
'
> PROCEDURE maschinit11
  ' BACK-COPY
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; ende
  ' 226F0044                       movea.l   68(sp),a1 ; anf
  ' 246F0048                       movea.l   72(sp),a2 ; destende
  ' 2520                 anf2:     move.l    -(a0),-(a2)
  ' B1C9                           cmp.l     a1,a0
  ' 6EFA                           bgt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfkmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H2520
  DATA &HB1C9
  DATA &H6EFA
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfkmasch
  km$=SPACE$(30)
  kmaschmerk=VARPTR(km$)
  IF kmaschmerk>0 AND kmaschmerk<>-1 THEN
    kmaschprg%=(INT(kmaschmerk/2))*2+2
    FOR g=0 TO 26 STEP 2
      READ a
      DPOKE kmaschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschruf11(ca,cb,cc)
  cfa%=ca
  cfb%=cb
  cfc%=cc
  ~C:kmaschprg%(L:cfa%,L:cfb%,L:cfc%)
RETURN
'
> PROCEDURE maschinit12
  ' PEAK-SUCH
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 246F0048                       movea.l   72(sp),a2 ; Returnwert
  ' 7000                           moveq.l   #0,d0
  ' 3218                 anf2:     move.w    (a0)+,d1
  ' 0801000F                       btst      #15,d1
  ' 6702                           beq.s     noneg
  ' 4641                           not.w     d1
  ' B240                 noneg:    cmp.w     d0,d1
  ' 6D02                           blt.s     noadd
  ' 3001                           move.w    d1,d0
  ' B1C9                 noadd:    cmp.l     a1,a0
  ' 6DEC                           blt.s     anf2
  ' 2480                           move.l    d0,(a2)
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anflmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H7000
  DATA &H3218
  DATA &H0801,&H000F
  DATA &H6702
  DATA &H4641
  DATA &HB240
  DATA &H6D02
  DATA &H3001
  DATA &HB1C9
  DATA &H6DEC
  DATA &H2480
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anflmasch
  lm$=SPACE$(50)
  lmaschmerk=VARPTR(lm$)
  IF lmaschmerk>0 AND lmaschmerk<>-1 THEN
    lmaschprg%=(INT(lmaschmerk/2))*2+2
    FOR g=0 TO 44 STEP 2
      READ a
      DPOKE lmaschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschruf12(ca,cb)
  cfa%=ca
  cfb%=cb
  back%=0
  cfc%=VARPTR(back%)
  ~C:lmaschprg%(L:cfa%,L:cfb%,L:cfc%)
RETURN
'
> PROCEDURE maschinit13
  ' NORMALIZE
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 202F0048                       move.l    72(sp),d0 ; grenz
  ' 222F004C                       move.l    76(sp),d1 ; back%
  ' 7400                 anf2:     moveq.l   #0,d2
  ' 163C0000                       move.b    #0,d3
  ' 3410                           move.w    (a0),d2
  ' 0802000F                       btst      #15,d2
  ' 6714                           beq.s     noneg
  ' 4642                           not.w     d2
  ' C4C0                           mulu.w    d0,d2
  ' 84C1                           divu.w    d1,d2
  ' 4642                           not.w     d2
  ' 30C2                           move.w    d2,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DE4                           blt.s     anf2
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' C4C0                 noneg:    mulu.w    d0,d2
  ' 84C1                           divu.w    d1,d2
  ' 30C2                           move.w    d2,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DD4                           blt.s     anf2
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfmmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H202F,&H0048
  DATA &H222F,&H004C
  DATA &H7400
  DATA &H163C,&H0000
  DATA &H3410
  DATA &H0802,&H000F
  DATA &H6714
  DATA &H4642
  DATA &HC4C0
  DATA &H84C1
  DATA &H4642
  DATA &H30C2
  DATA &HB1C9
  DATA &H6DE4
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &HC4C0
  DATA &H84C1
  DATA &H30C2
  DATA &HB1C9
  DATA &H6DD4
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfmmasch
  mm$=SPACE$(80)
  mmaschmerk=VARPTR(mm$)
  IF mmaschmerk>0 AND mmaschmerk<>-1 THEN
    mmaschprg%=(INT(mmaschmerk/2))*2+2
    FOR g=0 TO 68 STEP 2
      READ a
      DPOKE mmaschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschruf13(ca,cb,cc,cd)
  cfa%=ca
  cfb%=cb
  cfc%=cc
  cfd%=cd
  ~C:mmaschprg%(L:cfa%,L:cfb%,L:cfc%,L:cfd%)
RETURN
'
> PROCEDURE maschinit14
  ' FIFO-DEL
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 202F0040                       move.l    64(sp),d0 ; adr
  ' 43F900DF04C0                   lea.l     $df04c0,a1
  ' 3211                 loop:     move.w    (a1),d1
  ' 51C8FFFC                       dbra      d0,loop
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfnmasch:
  DATA &H48E7,&HFFFE
  DATA &H202F,&H0040
  DATA &H43F9,&H00DF,&H04C0
  DATA &H3211
  DATA &H51C8,&HFFFC
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfnmasch
  nm$=SPACE$(30)
  nmaschmerk=VARPTR(nm$)
  IF nmaschmerk>0 AND nmaschmerk<>-1 THEN
    nmaschprg%=(INT(nmaschmerk/2))*2+2
    FOR g=0 TO 24 STEP 2
      READ a
      DPOKE nmaschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschruf14(ca)
  cfa%=ca
  ~C:nmaschprg%(L:cfa%)
RETURN
'
> PROCEDURE maschinit15
  ' CROSSPLAY
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 262F0048                       move.l    72(sp),d3 ; loop
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA0144                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA011A                       lea.l     rett(pc),a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43FA0108                       lea.l     neuikbd(pc),a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF             anf0:     movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 10BC0004                       move.b    #4,(a0)
  ' 49FA00E6                       lea.l     merk(pc),a4
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                           movea.l   a3,a2
  ' 1010                 anf1:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf2:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfgen (Kennung fr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfgen (Kennung fr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 6678                           bne.s     weg
  ' B5C1                           cmpa.l    d1,a2
  ' 66C8                           bne.s     anf1
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 2401                           move.l    d1,d2
  ' 220B                           move.l    a3,d1
  ' 068100000004                   add.l     #4,d1
  ' 2642                           move.l    d2,a3
  ' 97FC00000004                   suba.l    #4,a3
  ' 7808                           moveq.l   #4,d4
  ' 49FA007C                       lea.l     merk(pc),a4
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                           movea.l   a3,a2
  ' 1010                 anfb1:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anfb2:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anfb3:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfgen (Kennung fr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anfb4:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfgen (Kennung fr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 660E                           bne.s     weg
  ' 95C4                           suba.l    d4,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 66C6                           bne.s     anfb1
  ' 4A83                           tst.l     d3
  ' 6704                           beq.s     weg
  ' 6000FF34                       bra       anf0
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4BFA002B                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA001A                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 0000                 merk:     Dc.w 0
  ' 33FC00010000015C     neuikbd:  move.w    #1,merk
  ' 4EF900000166         rett:     jmp       rett
  '
anfomasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H262F,&H0048
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H0144
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H011A
  DATA &H2368,&H0020,&H0002
  DATA &H43FA,&H0108
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFFFE
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H10BC,&H0004
  DATA &H49FA,&H00E6
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H3014
  DATA &H6678
  DATA &HB5C1
  DATA &H66C8
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFFFE
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H2401
  DATA &H220B
  DATA &H0681,&H0000,&H0004
  DATA &H2642
  DATA &H97FC,&H0000,&H0004
  DATA &H7808
  DATA &H49FA,&H007C
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H3014
  DATA &H660E
  DATA &H95C4
  DATA &HB5C1
  DATA &H66C6
  DATA &H4A83
  DATA &H6704
  DATA &H6000,&HFF34
  DATA &H4CDF,&H7FFF
  DATA &H4BFA,&H002B
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H001A
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H1208
  DATA &H0000
  DATA &H33FC,&H0001,&H0000,&H015C
  DATA &H4EF9,&H0000,&H0166
  '
  RESTORE anfomasch
  om$=SPACE$(370)
  omaschmerk=VARPTR(om$)
  IF omaschmerk>0 AND omaschmerk<>-1 THEN
    omaschprg%=(INT(omaschmerk/2))*2+2
    FOR g=0 TO 362 STEP 2
      READ a
      DPOKE omaschprg%+g,a
    NEXT g
  ENDIF
  LPOKE omaschprg%+354,omaschprg%+348   !merk
RETURN
'
> PROCEDURE maschruf15
  ' CROSSPLAY
  '
  saa%=a
  sba%=b
  ena%=l
  ~C:omaschprg%(L:saa%,L:sba%,L:ena%)
RETURN
'
> PROCEDURE maschinit16
  ' RESAMPLE
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; sourceanf
  ' 226F0044                       movea.l   68(sp),a1 ; sourceende
  ' 246F0048                       movea.l   72(sp),a2 ; destanf
  ' 266F004C                       movea.l   76(sp),a3 ; destende
  ' 262F0050                       move.l    80(sp),d3 ; source-sample-rate (320,441,480)
  ' 282F0054                       move.l    84(sp),d4 ; dest-sample-rate (320,441,480)
  ' 286F0058                       move.l    88(sp),a4 ; destende-RETURN-Wert
  ' 2A03                           move.l    d3,d5
  ' 9A84                           sub.l     d4,d5
  ' 7200                           moveq.l   #0,d1
  ' 2403                           move.l    d3,d2
  ' 84C4                           divu      d4,d2
  ' 0C8200000001                   cmpi.l    #1,d2
  ' 6712                           beq.s     abzanf
  ' 02820000FFFF                   andi.l    #$ffff,d2
  ' 0C420000                       cmpi.w    #0,d2
  ' 6740                           beq.s     dazuanf
  ' 0C420002                       cmpi.w    #2,d2
  ' 6D20                           blt.s     abzanf2
  ' 24D0                 abzanf:   move.l    (a0),(a2)+
  ' D283                           add.l     d3,d1
  ' 2401                           move.l    d1,d2
  ' 84C4                           divu      d4,d2
  ' 02820000FFFF                   andi.l    #$ffff,d2
  ' 2E02                           move.l    d2,d7
  ' CEFC0004                       mulu      #4,d7
  ' C4C4                           mulu      d4,d2
  ' 9282                           sub.l     d2,d1
  ' D1C7                           adda.l    d7,a0
  ' B1C9                           cmpa.l    a1,a0
  ' 6DE2                           blt.s     abzanf
  ' 6066                           bra.s     ende
  ' 2A03                 abzanf2:  move.l    d3,d5
  ' 9A84                           sub.l     d4,d5
  ' 2018                 abzanf3:  move.l    (a0)+,d0
  ' D285                           add.l     d5,d1
  ' 2401                           move.l    d1,d2
  ' 9483                           sub.l     d3,d2
  ' 6B04                           bmi.s     noabz2
  ' 2202                           move.l    d2,d1
  ' 6002                           bra.s     abztest2
  ' 24C0                 noabz2:   move.l    d0,(a2)+
  ' B1C9                 abztest2: cmpa.l    a1,a0
  ' 6DEC                           blt.s     abzanf3
  ' 604C                           bra.s     ende
  ' 2404                 dazuanf:  move.l    d4,d2
  ' 84C3                           divu      d3,d2
  ' 0C420002                       cmpi.w    #2,d2
  ' 6C1E                           bge.s     dazuanf4
  ' 2A04                           move.l    d4,d5
  ' 9A83                           sub.l     d3,d5
  ' 2018                 dazuanf2: move.l    (a0)+,d0
  ' D285                           add.l     d5,d1
  ' 2401                           move.l    d1,d2
  ' 9483                           sub.l     d3,d2
  ' 6B04                           bmi.s     dazuanf3
  ' 2202                           move.l    d2,d1
  ' 24C0                           move.l    d0,(a2)+
  ' 24C0                 dazuanf3: move.l    d0,(a2)+
  ' B5CB                           cmpa.l    a3,a2
  ' 6C2A                           bge.s     ende
  ' B1C9                           cmpa.l    a1,a0
  ' 6DE8                           blt.s     dazuanf2
  ' 6024                           bra.s     ende
  ' 2018                 dazuanf4: move.l    (a0)+,d0
  ' D284                           add.l     d4,d1
  ' 2401                           move.l    d1,d2
  ' 84C3                           divu      d3,d2
  ' 02820000FFFF                   andi.l    #$ffff,d2
  ' 2E02                           move.l    d2,d7
  ' C4C3                           mulu      d3,d2
  ' 9282                           sub.l     d2,d1
  ' 5387                           subq.l    #1,d7
  ' 24C0                 dazuanf5: move.l    d0,(a2)+
  ' B5CB                           cmp.l     a3,a2
  ' 6C08                           bge.s     ende
  ' 51CFFFF8                       dbra      d7,dazuanf5
  ' B1C9                           cmpa.l    a1,a0
  ' 6DDC                           blt.s     dazuanf4
  ' 288A                 ende:     move.l    a2,(a4)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfpmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H266F,&H004C
  DATA &H262F,&H0050
  DATA &H282F,&H0054
  DATA &H286F,&H0058
  DATA &H2A03
  DATA &H9A84
  DATA &H7200
  DATA &H2403
  DATA &H84C4
  DATA &H0C82,&H0000,&H0001
  DATA &H6712
  DATA &H0282,&H0000,&HFFFF
  DATA &H0C42,&H0000
  DATA &H6740
  DATA &H0C42,&H0002
  DATA &H6D20
  DATA &H24D0
  DATA &HD283
  DATA &H2401
  DATA &H84C4
  DATA &H0282,&H0000,&HFFFF
  DATA &H2E02
  DATA &HCEFC,&H0004
  DATA &HC4C4
  DATA &H9282
  DATA &HD1C7
  DATA &HB1C9
  DATA &H6DE2
  DATA &H6066
  DATA &H2A03
  DATA &H9A84
  DATA &H2018
  DATA &HD285
  DATA &H2401
  DATA &H9483
  DATA &H6B04
  DATA &H2202
  DATA &H6002
  DATA &H24C0
  DATA &HB1C9
  DATA &H6DEC
  DATA &H604C
  DATA &H2404
  DATA &H84C3
  DATA &H0C42,&H0002
  DATA &H6C1E
  DATA &H2A04
  DATA &H9A83
  DATA &H2018
  DATA &HD285
  DATA &H2401
  DATA &H9483
  DATA &H6B04
  DATA &H2202
  DATA &H24C0
  DATA &H24C0
  DATA &HB5CB
  DATA &H6C2A
  DATA &HB1C9
  DATA &H6DE8
  DATA &H6024
  DATA &H2018
  DATA &HD284
  DATA &H2401
  DATA &H84C3
  DATA &H0282,&H0000,&HFFFF
  DATA &H2E02
  DATA &HC4C3
  DATA &H9282
  DATA &H5387
  DATA &H24C0
  DATA &HB5CB
  DATA &H6C08
  DATA &H51CF,&HFFF8
  DATA &HB1C9
  DATA &H6DDC
  DATA &H288A
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfpmasch
  pm$=SPACE$(220)
  pmaschmerk=VARPTR(pm$)
  IF pmaschmerk>0 AND pmaschmerk<>-1 THEN
    pmaschprg%=(INT(pmaschmerk/2))*2+2
    FOR g=0 TO 208 STEP 2
      READ a
      DPOKE pmaschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschruf16(a,b,c,d,e,f)
  ' a - sourceanf
  ' b - sourceende
  ' c - destanf
  ' d - destende
  ' e - source-sample-rate (320,441,480)
  ' f - dest-sample-rate (320,441,480)
  ' back% - destende-RETURN-Wert
  '
  saa%=a
  sba%=b
  sca%=c
  sda%=d
  sea%=e
  sfa%=f
  back%=0
  sga%=VARPTR(back%)
  ~C:pmaschprg%(L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:sfa%,L:sga%)
RETURN
'
> PROCEDURE maschinit17
  ' MONO
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 7200                 anf2:     moveq.l   #0,d1
  ' 2401                           move.l    d1,d2
  ' 3210                           move.w    (a0),d1
  ' 34280002                       move.w    2(a0),d2
  ' 0801000F                       btst      #15,d1
  ' 660A                           bne.s     anf5
  ' 0802000F             anf3:     btst      #15,d2
  ' 6612                           bne.s     anf6
  ' D282                 anf4:     add.l     d2,d1    ; plus und plus = plus
  ' 6016                           bra.s     ende
  ' 0802000F             anf5:     btst      #15,d2
  ' 660E                           bne.s     anf7     ; minus und minus = minus
  ' 4641                           not.w     d1
  ' 9481                           sub.l     d1,d2    ; minus und plus = ?
  ' 2202                           move.l    d2,d1
  ' 6008                           bra.s     ende
  ' 4642                 anf6:     not.w     d2       ; plus und minus = ?
  ' 9282                           sub.l     d2,d1
  ' 6002                           bra.s     ende
  ' D282                 anf7:     add.l     d2,d1    ; add + wech
  ' E281                 ende:     asr.l     #1,d1
  ' 30C1                           move.w    d1,(a0)+
  ' 30C1                           move.w    d1,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DC6                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfqmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H7200
  DATA &H2401
  DATA &H3210
  DATA &H3428,&H0002
  DATA &H0801,&H000F
  DATA &H660A
  DATA &H0802,&H000F
  DATA &H6612
  DATA &HD282
  DATA &H6016
  DATA &H0802,&H000F
  DATA &H660E
  DATA &H4641
  DATA &H9481
  DATA &H2202
  DATA &H6008
  DATA &H4642
  DATA &H9282
  DATA &H6002
  DATA &HD282
  DATA &HE281
  DATA &H30C1
  DATA &H30C1
  DATA &HB1C9
  DATA &H6DC6
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfqmasch
  qm$=SPACE$(80)
  qmaschmerk=VARPTR(qm$)
  IF qmaschmerk>0 AND qmaschmerk<>-1 THEN
    qmaschprg%=(INT(qmaschmerk/2))*2+2
    FOR g=0 TO 74 STEP 2
      READ a
      DPOKE qmaschprg%+g,a
    NEXT g
  ENDIF
RETURN
'
> PROCEDURE maschruf17(a,b)
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~C:qmaschprg%(L:saa%,L:sba%)
RETURN
'
> PROCEDURE maschinit18
  ' MIDI-PLAY
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 262F0048                       move.l    72(sp),d3 ; loop
  ' 242F004C                       move.l    76(sp),d2 ; midi
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA010E                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 10BC0004                       move.b    #4,(a0)
  ' 7808                           moveq.l   #8,d4               ; Anzahl der Backstep
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                 anf0:     movea.l   a3,a2
  ' 1010                 anf1:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf2:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfgen (Kennung fr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfgen (Kennung fr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 48E77FFE                       movem.l   d1-a6,-(sp)
  ' 3F3C0003                       move.w    #3,-(sp)  ; MIDI
  ' 3F3C0001                       move.w    #1,-(sp)  ; Bconstat
  ' 4E4D                           trap      #13
  ' 58A7                           addq.l    #4,-(sp)
  ' B07C0000                       cmp.w     #0,d0
  ' 676C                           beq.s     nomidi
  ' 3F3C0003                       move.w    #3,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)  ; Bconin
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-a6
  ' 48E77FFE                       movem.l   d1-a6,-(sp)
  ' 4BFA0088                       lea.l     midiw(pc),a5
  ' 08000007                       btst      #7,d0
  ' 6708                           beq.s     midi2     ; Daten oder Befehl ?
  ' E002                           asr.b     #8,d2     ; Channel im oberen Byte des Wortes
  ' 9002                           sub.b     d2,d0     ; Channel vom Befehl abziehen
  ' 1A80                           move.b    d0,(a5)   ; Befehl schreiben
  ' 6046                           bra.s     nomidi
  ' B002                 midi2:    cmp.b     d2,d0       ; Noten-DATA ?
  ' 671E                           beq.s     midi4
  ' B42D0001                       cmp.b     1(a5),d2    ; Noten-data schon gewesen und korrekt ?
  ' 663C                           bne.s     nomidi
  ' 1B400002             midi3:    move.b    d0,2(a5)    ; Velocitywert schreiben
  ' 0C150080                       cmp.b     #$80,(a5)   ; NOTE OFF ?
  ' 671A                           beq.s     midi5
  ' 0C150090                       cmp.b     #$90,(a5)   ; NOTE ON ?
  ' 671C                           beq.s     midi6
  ' 2ABC00000000         midi3b:   move.l    #0,(a5)     ; Datenwort l”schen
  ' 6024                           bra.s     nomidi
  ' B42D0001             midi4:    cmp.b     1(a5),d2  ; Noten-DATA schon gewesen ?
  ' 67E2                           beq.s     midi3     ; dann ist es nicht Note sondern Velocity
  ' 1B400001                       move.b    d0,1(a5)  ; Notenwert schreiben
  ' 6018                           bra.s     nomidi
  ' B42D0001             midi5:    cmp.b     1(a5),d2  ; NOTE OFF und Note OK ?
  ' 66E6                           bne.s     midi3b    ; wenn nein, Datenwort l”schen
  ' 6024                           bra.s     weg2      ; Abbruch, da NOTE OFF !
  ' B42D0001             midi6:    cmp.b     1(a5),d2  ; NOTE ON und Note OK ?
  ' 66DE                           bne.s     midi3b    ; wenn nein, Datenwort l”schen
  ' 0C2D00000002                   cmp.b     #0,2(a5)  ; Velocity ist Null ?
  ' 66D6                           bne.s     midi3b    ; wenn nein, Datenwort l”schen
  ' 6014                           bra.s     weg2      ; Abbruch, da NOTE ON und Velo=Null !
  ' 4CDF7FFE             nomidi:   movem.l   (sp)+,d1-a6
  ' 95C4                           suba.l    d4,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 6600FF44                       bne       anf1
  ' 4A83                           tst.l     d3
  ' 6708                           beq.s     weg
  ' 6000FF3A                       bra       anf0
  ' 4CDF7FFE             weg2:     movem.l   (sp)+,d1-a6
  ' 4BFA0017             weg:      lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 00000000             midiw:    dc.l 0
anfrmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H262F,&H0048
  DATA &H242F,&H004C
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H010E
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H4CDF,&H7FFF
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H10BC,&H0004
  DATA &H7808
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H58A7
  DATA &HB07C,&H0000
  DATA &H676C
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H7FFE
  DATA &H48E7,&H7FFE
  DATA &H4BFA,&H0088
  DATA &H0800,&H0007
  DATA &H6708
  DATA &HE002
  DATA &H9002
  DATA &H1A80
  DATA &H6046
  DATA &HB002
  DATA &H671E
  DATA &HB42D,&H0001
  DATA &H663C
  DATA &H1B40,&H0002
  DATA &H0C15,&H0080
  DATA &H671A
  DATA &H0C15,&H0090
  DATA &H671C
  DATA &H2ABC,&H0000,&H0000
  DATA &H6024
  DATA &HB42D,&H0001
  DATA &H67E2
  DATA &H1B40,&H0001
  DATA &H6018
  DATA &HB42D,&H0001
  DATA &H66E6
  DATA &H6024
  DATA &HB42D,&H0001
  DATA &H66DE
  DATA &H0C2D,&H0000,&H0002
  DATA &H66D6
  DATA &H6014
  DATA &H4CDF,&H7FFE
  DATA &H95C4
  DATA &HB5C1
  DATA &H6600,&HFF44
  DATA &H4A83
  DATA &H6708
  DATA &H6000,&HFF3A
  DATA &H4CDF,&H7FFE
  DATA &H4BFA,&H0017
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H1208
  DATA &H0000,&H0000
  '
  RESTORE anfrmasch
  rm$=SPACE$(310)
  rmaschmerk=VARPTR(rm$)
  IF rmaschmerk>0 AND rmaschmerk<>-1 THEN
    maschprg%=(INT(rmaschmerk/2))*2+2
    FOR g=0 TO 300 STEP 2
      READ a
      DPOKE maschprg%+g,a
    NEXT g
  ENDIF
  retanz=63    ! Stelle fuer Anzahl der Rueckspruenge bei RETPLAY
RETURN
'
> PROCEDURE maschruf18
  ' a - sourceanf
  ' b - sourceende
  ' l - L„nge
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  saa%=a
  sba%=b
  sca%=l
  sda%=midiwort
  REPEAT
    x=INP?(3)
    y=INP?(2)
    IF x=TRUE THEN
      xx=INP(3)
      IF xx=&H90+(ch-1) THEN
        REPEAT
          x=INP?(3)
          y=INP?(2)
        UNTIL x=TRUE OR y=TRUE
        IF y=FALSE AND x=TRUE THEN
          xx=INP(3)
          IF xx=note THEN
            REPEAT
              x=INP?(3)
              y=INP?(2)
            UNTIL x=TRUE OR y=TRUE
            IF y=FALSE AND x=TRUE THEN
              xx=INP(3)
              raus=TRUE
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    IF y=TRUE THEN
      yy=INP(2)
    ENDIF
  UNTIL y=TRUE OR raus=TRUE
  IF raus=TRUE AND y=FALSE THEN
    ~C:maschprg%(L:saa%,L:sba%,L:sca%,L:sda%)
  ENDIF
RETURN
'
> PROCEDURE textfeld(txtname,txt$,versatz)
  ~RSRC_GADDR(0,nr,zuadr)
  string=LPEEK(LPEEK(zuadr+24*txtname+12))
  FOR it=1 TO LEN(txt$)
    POKE string+it-1+(versatz-1),ASC(MID$(txt$,it,1))
  NEXT it
  ~WIND_UPDATE(1)                                    ! BEG_UPDATE
  ~OBJC_DRAW(zuadr,txtname,1,0,0,xwidth,ywidth)
  ~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE setbutton(buttnr,buttflag)
  ~RSRC_GADDR(0,nr,zuadr)
  buttadr=zuadr+24*buttnr
  DPOKE buttadr+10,buttflag
  ~WIND_UPDATE(1)                                    ! BEG_UPDATE
  ~OBJC_DRAW(zuadr,buttnr,1,0,0,xwidth,ywidth)
  ~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE findbutton(buttnr)
  ~RSRC_GADDR(0,nr,zuadr)
  buttadr=(zuadr+24*buttnr)+10
RETURN
'
' ------------------------------------------------------------------------------
> PROCEDURE key
  cont&=FORM_KEYBD(rsc_adr%,edit_obj&,key&,0,next_obj&,key&)
  ' M”chten Sie erweiterte Tastaturkommandos? Dann entREMen Sie
  ' diese Zeile und ersetzen die Prozedur durch:
  ' cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  '
  '
  a=MENU(13)
  b=MENU(14)
  ascii|=(b AND 255)
  scan|=INT(b/256)
  '  ascii|=BYTE(key&)                                  ! ASCII-Code
  ' scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
  '
  IF ascii|=0                                        ! Kein ASCII-Code...
    '
    IF scan|=97 OR scan|=98                          ! UNDO/HELP...
      ascii|=ADD(SUB(scan|,97),14)
      obj&=0
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
      IF BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE IF scan|>=59 AND scan|<=68                  ! F-Tasten...
      ascii|=SUB(scan|,58)
      obj&=0
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
      IF SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE                                             ! ALT+Buchstabe...
      '
      IF scan|>=120 AND scan|<=129                   ! Zahlen...
        SUB scan|,118
        keytab%={XBIOS(16,L:-1,L:-1,L:-1)}           ! ...ohne Shift
      ELSE                                           ! Alles andere...
        keytab%={ADD(XBIOS(16,L:-1,L:-1,L:-1),4)}    ! ...mit Shift
      ENDIF
      '
      ascii|=BYTE{ADD(keytab%,scan|)}                ! ASCII-Code holen
      IF ascii|<>0                                      ! Tastaturbedienbar...
        CLR a&,obj&
        '
        DO WHILE NOT BTST(OB_FLAGS(rsc_adr%,obj&),5) ! Nicht LASTOBJ
          INC obj&
          '
          scan|=BYTE(SHR(OB_TYPE(rsc_adr%,obj&),8))
          IF scan|=26 OR scan|=28                    ! Ein Button/String...
            a$=@rsc_text$(tree&,obj&)                ! ...Text
            '
            a&=INSTR(a$,"[")
            IF a&                                    ! Tastaturbedienbar...
              a&=ASC(MID$(a$,SUCC(a&),1))
              a&=(BCLR(a&,5)=ascii|) OR (a&>=48 AND a&<=57 AND a&=ascii|)
            ENDIF
            '                                        ! '[' vor Zeichen
          ENDIF
          '
        LOOP UNTIL a&                                ! ...gefunden
        '
        IF a&                                        ! Objekt gefunden...
          key&=0                                     ! ...keine Eingabe mehr
          '                                          ! +SHIFT Circle-Butt?
          IF BTST(shift&,1) AND BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5) AND SHR(OB_TYPE(rsc_adr%,obj&+2),8)=27
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simulieren
            ~OBJC_OFFSET(rsc_adr%,obj&+2,mx&,my&)
            '                                        ! Ist es ein Popup...
          ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5)
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simul.
            ~OBJC_OFFSET(rsc_adr%,obj&,mx&,my&)
          ELSE                                       ! ...Button bedienen
            cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
          ENDIF
        ENDIF
        '
      ENDIF
    ENDIF
    '
  ENDIF
  '
  IF key&
    ~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,2,idx&)  ! ...Eingabe
  ENDIF
  '
RETURN
> PROCEDURE message
  handle&=MENU(4)                                    ! ...Fenster-Handle
  '
  FOR a&=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
    EXIT IF handle&=rsc_handle%(a&)
  NEXT a&
  '
  IF MENU(1)=41 OR (MENU(1)=22 AND tree&=a&)         ! AC_CLOSE/Closer...
    MUL rsc_window&,-(MENU(1)=22)
    '
    next_obj&=exit&                          ! ...Exit-Code
    '
    GOTO rsc_dox_ende                                 ! ...rsc_do verlassen
    '
  ELSE IF a&>-1 AND NOT (MENU(1)=21 AND a&<>tree&)   ! Ein RSC-Fenster....
    rsc_message(a&,MENU(1),MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    '
  ELSE IF MENU(1)=40 OR MENU(1)=21                   ! AC_OPEN/Anderes Fenster toppen...
    rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    '
  ELSE IF MENU(1)<>21 AND MENU(1)<>22                ! nicht toppen/schliežen...
    '    message_auswerten(MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
  ELSE                                               ! Nichts zu machen...
    ~BIOS(3,2,7)
  ENDIF
rsc_dox_ende:
  '  RETURN next_obj&
RETURN
> PROCEDURE button
  mx&=MOUSEX
  my&=MOUSEY
  next_obj&=OBJC_FIND(rsc_adr%,0,100,mx&,my&)
  '                                                  ! String vor Popup...
  IF next_obj&>0
    IF BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND SHR(OB_TYPE(rsc_adr%,next_obj&),8)=28 AND BTST(OB_STATE(rsc_adr%,SUCC(next_obj&)),5)
      ' (TOUCHEXIT, STRING, SUCC: SHADOWED)
      INC next_obj&
    ENDIF
  ENDIF
  '
  IF next_obj&=-1                                    ! Neben die Box...
    '    SOUND 1,15,10,4,10
    '   SOUND 0,0,0,0,0
    next_obj&=0
    '
  ELSE
    cont&=FORM_BUTTON(rsc_adr%,next_obj&,1,next_obj&)
    ' ------------------------------------------------ Flydial-Ecke
    IF BTST(OB_STATE(rsc_adr%,next_obj&),1)          ! (CROSSED)
      rsc_movedial(tree&,edit_obj&,idx&)             ! ...Dialog verschieben
      '
      next_obj&=0                                    ! Damit der Cursor..
      cont&=1                                        ! ..bleibt wo er ist
      ' ---------------------------------------------- Circle-Button...
    ELSE IF SHR(OB_TYPE(rsc_adr%,next_obj&),8)=27 AND BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),5) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),3))
      ' (G_BOXCHAR, PRED: SHADOWED /NOT DISABLED)
      next_obj&=PRED(next_obj&)                      ! Objektnr. Button
      a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
      evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
      '
      obj&=1
      FOR ob_tail&=1 TO PRED(evnt&)
        obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
      NEXT ob_tail&
      '
      evnt&=SUCC(obj&)
      b$=@rsc_text$(rsc_popup&,evnt&)
      DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
        INC evnt&                                    ! Defaulteintrag
      LOOP
      '
      REPEAT
        INC evnt&                                    ! N„chster Eintrag...
        IF evnt&>OB_TAIL(rsc_adr%(rsc_popup&),obj&)  ! ...gibt es nicht
          evnt&=SUCC(obj&)                           ! ...dann wieder 1.
        ENDIF
        '                                            ! bis nicht DISABLED
      UNTIL NOT BTST(OB_STATE(rsc_adr%(rsc_popup&),evnt&),3)
      '                                              ! Button „ndern...
      rsc_text(tree&,next_obj&,@rsc_text$(rsc_popup&,evnt&))
      ~OBJC_DRAW(rsc_adr%,next_obj&,1,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
      popup&=SUB(evnt&,obj&)
      REPEAT
      UNTIL MOUSEK=0
      ' ---------------------------------------------- Popup-Menue...
    ELSE IF BTST(OB_STATE(rsc_adr%,next_obj&),5) AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND (NOT BTST(OB_STATE(rsc_adr%,next_obj&),3))
      IF ((next_obj&=rate& OR next_obj&=mover&) AND nr=smpedit&) OR ((next_obj&=input& OR next_obj&=source& OR next_obj&=dsp& OR next_obj&=rate2&) AND nr=smp16&)
        ' (SHADOWED, TOUCHEXIT, NOT DISABLED)
        evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
        obj&=1
        FOR ob_tail&=1 TO PRED(evnt&)
          obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
        NEXT ob_tail&
        ob_tail&=OB_TAIL(rsc_adr%(rsc_popup&),obj&)
        a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
        evnt&=SUCC(obj&)
        DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
          INC evnt&                                    ! Ausrichtung ermitteln
        LOOP UNTIL evnt&>ob_tail&
        '
        IF evnt&<=ob_tail&                             ! Defaulteintrag...
          popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,SUB(evnt&,SUCC(obj&)))    ! war TRUE
        ELSE                                           ! Sonst ohne...
          IF tree&=smpedit& THEN
            popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,1)
          ENDIF
        ENDIF
        IF popup&=0                                    ! Abbruch...
          cont&=1                                      ! ...weiter geht's
          next_obj&=0                                  ! ...Cursor 'festhalten'
        ENDIF
        ' ---------------------------------------------- Cursor positionieren
        ' M”chten Sie den Cursor mit der Maus zeichengenau positionieren?
        ' Dann entREMen Sie diese Zeilen und laden diese Prozedur nach:
        ' ELSE IF BTST(OB_FLAGS(rsc_adr%,next_obj&),3)
        ' rsc_set_cursor(rsc_adr%,mx&,my&,edit_obj&,next_obj&,idx&)
      ENDIF
    ENDIF
    '
  ENDIF
  IF cont&=0 OR (next_obj&<>0 AND next_obj&<>edit_obj&)
    ~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
  ENDIF
RETURN
'
> PROCEDURE rsc_init
  LOCAL a&
  '
  ' Initialisiert die von den RSC-Routinen ben”tigten Variablen...
  '
  ap_id&=APPL_INIT()                         ! Applikations-ID
  '
  rsc_aes&=INT{{ADD(GB,4)}}                  ! AES-Version
  rsc_mtsk!=INT{ADD({ADD(GB,4)},2)}<>1       ! Multitasking?
  rsc_alert&=-1                              ! Noch keine fliegenden Alerts
  '
  CONTRL(6)=GRAF_HANDLE(wchar&,hchar&,a&,a&) ! AES-Handle, Zeichenbreite/H”he
  rsc_vh&=V_OPNVWK(1)                        ! Virt.Workst. fr Flydials ”ffnen
  IF rsc_vh&=0
    rsc_vh&=V~H                              ! ...Fehler, dann eben die alte
  ENDIF
  CONTRL(6)=V~H
  '
  INTIN(0)=1
  VDISYS 102,1,0
  planes&=INTOUT(4)                          ! Bitplanes
  '
  ~WIND_GET(0,7,deskx&,desky&,deskw&,deskh&) ! Hintergrundfenster
  ' ------------------------------------------------------ Inline vorbereiten
  INLINE rsc_flyd%,2834
  '
  rsc_bitblt%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,16)})      ! BITBLT-Routine
  rsc_obspec%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,18)})      ! OB_SPEC-Routine...
  rsc_cookie%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,20)})      ! COOKIE-Routine...
  '
  {ADD(rsc_flyd%,22)}=ADD(GB,24)                         ! VDI-Parameterblock
  INT{ADD(rsc_flyd%,26)}=rsc_vh&                         ! Virt. Workstation
  INT{ADD(rsc_flyd%,28)}=wchar&                          ! Zeichenzellenbreite
  INT{ADD(rsc_flyd%,30)}=hchar&                          ! Zeichenzellenh”he
  ' ------------------------------------------------------
  ' Berechnet den Speicherbedarf einer Bitmap-Grafik...
  DEFFN getsize(w&,h&)=SHL(SHR(ADD(MUL(MUL(SHR(ADD(w&,15),3),h&),planes&),255),8),8)
  '
  ' Gegenstck zur Prozedur rsc_text: Universelles Objekt-Text auslesen...
  DEFFN rsc_text$(tree&,obj&)=CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}
  '
RETURN
> PROCEDURE rsc_exit
  '
  CONTRL(6)=rsc_vh&
  VDISYS 38,0,0                              ! vqt_attributes
  IF ABS(INTOUT(0))<>1                       ! Anderer AES-Zeichensatz (MTOS)...
    ~VST_UNLOAD_FONTS(0)                     ! ...freigeben
  ENDIF
  '
  IF rsc_vh&<>V~H                            ! Flydial-Workstation freigeben...
    ~V_CLSVWK()
  ENDIF
  '
  ' Die folgenden Zeilen sind nur im Interpreter relevant und k”nnen im
  ' Compilat wegfallen. Tip: Mit dem ERGO!pro-Pr„prozessor ausblenden.
  '
  ~RSRC_FREE()                               ! Resource entfernen
  '
  IF popup_back%
    ~MFREE(popup_back%)                      ! Popup-Hintergrund freigeben
  ENDIF
  '
  IF rsc_userblk%
    ~MFREE(rsc_userblk%)                     ! Userblks freigeben
  ENDIF
  '
RETURN
'
> FUNCTION rsc_laden(file$,trees&,popup&,menu&,alert&)
$F%
LOCAL tree&,obj&,font_h&,font_id&,color3d&,a%
popup_back%=0
'
' L„dt die Resource und initialisiert einige globale Variablen...
' ------------------------------------------------------ RSC laden
' Wollen Sie das RSC-File direkt im Programmcode 'aufbewahren'?
' Dann entREMen Sie diese Zeilen und laden Sie die Funktion
' 'rsc_conv' aus EXTENDED.LST hinzu...
' INLINE rsc%,3160
' IF @rsrc_conv(rsc%)=0
IF RSRC_LOAD(file$)=0
  '
  ~FORM_ALERT(1,"[3][ | Fehler beim Laden | der RSC-Datei! | ][Abbruch]")
  RETURN FALSE
ENDIF
' ------------------------------------------------------
IF auflauf>1 THEN
  ERASE rsc_adr%()
  ERASE rsc_handle%()
  ERASE rscx&()
  ERASE rscy&()
  ERASE rscw&()
  ERASE rsch&()
ENDIF
DIM rsc_adr%(trees&),rsc_handle%(trees&)
DIM rscx&(trees&),rscy&(trees&),rscw&(trees&),rsch&(trees&)
'
rsc_trees&=trees&                                      ! Anzahl Objektb„ume-1
rsc_popup&=popup&                                      ! Popup-Baum
rsc_menu&=menu&                                        ! Dropdown-Baum
rsc_alert&=alert&                                      ! Alert-Baum
' ------------------------------------------------------
' Die folgenden Zeilen sind nur n”tig, wenn das Resource-File ALERT-
' oder FREE-B„ume enth„lt. N„heres in der Doku.
' alerts&=trees&-SUCC(rsc_alert&)                        ! Alerts & Free Strings...
' FOR tree&=0 TO alerts&
' ~RSRC_GADDR(5,tree&,a%)
' rsc_adr%(rsc_alert&+SUCC(tree&))=a%
' NEXT tree&
' trees&=rsc_alert&
' ------------------------------------------------------ Adressen ermitteln
FOR tree&=0 TO trees&
  '
  ~RSRC_GADDR(0,tree&,a%)  ! Kompatibel zu den XRSRC-Routinen
  rsc_adr%(tree&)=a%
  IF tree&<>menu&
    ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
  ENDIF
  '
NEXT tree&
' ------------------------------------------------------ Gr”žtes Popup
IF popup&>-1
  obj&=1
  '
  WHILE obj&>0
    popup_back%=MAX(popup_back%,@getsize(ADD(OB_W(rsc_adr%(popup&),obj&),21),OB_H(rsc_adr%(popup&),obj&)))
    obj&=OB_NEXT(rsc_adr%(popup&),obj&)
  WEND
  '
  popup_back%=MALLOC(popup_back%)                      ! Hintergrundpuffer...
  IF popup_back%=0
    RETURN FALSE                                       ! ...nicht geklappt
  ENDIF
  '
ENDIF
' ------------------------------------------------------ Anderer Zeichensatz
IF rsc_aes&>=&H400 OR APPL_FIND("?API")=0              ! Hat APPL_GETINFO()...
  '
  GCONTRL(0)=130
  GCONTRL(1)=1
  GCONTRL(2)=5
  GCONTRL(3)=0
  GCONTRL(4)=0
  GINTIN(0)=0
  '
  GEMSYS                                               ! APPL_GETINFO()
  '
  IF GINTOUT(0)=1                                      ! Hat geklappt...
    font_h&=GINTOUT(1)                                 ! AES-Font H”he
    font_id&=GINTOUT(2)                                ! AES-Font ID
    '
    IF ABS(font_id&)<>1 AND GDOS?<>0                   ! Anderer AES-Font...
      V~H=rsc_vh&
      ~VST_LOAD_FONTS(0)                               ! ...Fonts laden
      DEFTEXT ,,,,font_id&
      DEFTEXT ,,,font_h&                               ! ...und einstellen
      V~H=-1
    ENDIF
  ENDIF
ENDIF
' ------------------------------------------------------ 3D-Darstellung
IF rsc_aes&>=&H340                                     ! Ab AES 3.40...
  GCONTRL(0)=48
  GCONTRL(1)=4
  GCONTRL(2)=3
  GCONTRL(3)=0
  GCONTRL(4)=0
  '
  GINTIN(0)=0                                          ! Inquire
  GINTIN(1)=5                                          ! Background
  '
  GEMSYS                                               ! OBJC_SYSVAR()
  '
  IF GINTOUT(0)>0                                      ! Hat geklappt...
    color3d&=GINTOUT(1)                                ! ...3D-Farbe
  ENDIF
ENDIF
' ------------------------------------------------------
INT{ADD(rsc_flyd%,32)}=color3d&>0                      ! 3D-Darstellung an/aus
INT{ADD(rsc_flyd%,34)}=color3d&                        ! 3D-Farbe
' ------------------------------------------------------
IF @rsc_walk_tree(trees&)
  RETURN TRUE                                          ! alles ok
ENDIF
'
RETURN FALSE                                           ! Error!
ENDFUNC
> FUNCTION rsc_walk_tree(trees&)
$F%
LOCAL a&,b&,userblk&,tree&,obj&,a%
'
' RSC-Baum durchgehen und userdefs installieren...
'
' ------------------------------------------------------ Userdefs ermitteln
FOR tree&=0 TO trees&
'
obj&=-1
'
REPEAT
  '
  INC obj&
  '
  a&=SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)           ! Es ist ein userdef...
  ADD userblk&,-AND(a&>=17,a&<=22)
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! ...bis LAST_OBJ
'
NEXT tree&
'
rsc_userblk%=MALLOC(SHL(SUCC(userblk&),3))             ! Userblks(+1) anfordern (*8)
IF rsc_userblk%=0                                      ! Zu wenig Speicher...
RETURN FALSE                                         ! ...Error!
ENDIF
a%=rsc_userblk%                                        ! Merken
' ------------------------------------------------------ Objektb„ume modifiz.
FOR tree&=0 TO trees&
'
obj&=-1
REPEAT
  '
  INC obj&
  '
  SELECT SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)       ! OB_TYPE
    ' ------------------------------------------------ Flydial-Ecke...
  CASE 17
    rsc_instal_userdef(tree&,obj&,5)
    ' ------------------------------------------------ Button/String...
  CASE 18
    '
    a&=OB_FLAGS(rsc_adr%(tree&),obj&)                ! OB_FLAGS
    b&=BYTE(OB_TYPE(rsc_adr%(tree&),obj&))           ! Alter OB_TYPE
    '
    IF BTST(a&,4)                                    ! Radiobutton...
      rsc_instal_userdef(tree&,obj&,1)
      '                                              ! BUTTON, nicht EXIT
    ELSE IF b&=26 AND (NOT BTST(a&,2))               ! Checkbutton...
      rsc_instal_userdef(tree&,obj&,2)
      '
    ELSE                                             ! Normale EXIT-Buttons...
      '
      IF b&<>28                                      ! Kein STRING...
        a&=SUCC(-BTST(a&,1)-BTST(a&,2)-BTST(a&,6))
        IF a&>1 !EXIT       DEFAULT    TOUCHEXIT
          OB_X(rsc_adr%(tree&),obj&)=SUB(OB_X(rsc_adr%(tree&),obj&),a&)
          OB_Y(rsc_adr%(tree&),obj&)=SUB(OB_Y(rsc_adr%(tree&),obj&),a&)
          OB_W(rsc_adr%(tree&),obj&)=ADD(OB_W(rsc_adr%(tree&),obj&),ADD(a&,a&))
          OB_H(rsc_adr%(tree&),obj&)=SUCC(ADD(OB_H(rsc_adr%(tree&),obj&),ADD(a&,a&)))
        ENDIF                                        ! ...fr Redraw gr”žer
      ENDIF
      '
      rsc_instal_userdef(tree&,obj&,6)
      '
    ENDIF
    ' ------------------------------------------------ Unterstr. Text...
  CASE 19
    rsc_instal_userdef(tree&,obj&,4)
    OB_FLAGS(rsc_adr%(tree&),obj&)=BSET(OB_FLAGS(rsc_adr%(tree&),obj&),13)
    ' ...OB_FLAG 13 setzen, wird in 'rsc_draw' ben”tigt
    ' ------------------------------------------------ Rahmen...
  CASE 20
    rsc_instal_userdef(tree&,obj&,3)
    ' ------------------------------------------------ Niceline...
  CASE 21
    rsc_instal_userdef(tree&,obj&,8)
    ' ------------------------------------------------ Circlebutton...
  CASE 22
    IF hchar&=8 OR hchar&=16                         ! ...nur wenn m”glich
      rsc_instal_userdef(tree&,obj&,7)               ! ...als Bitmap
    ELSE
      OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(27,8),BYTE(OB_TYPE(rsc_adr%(tree&),obj&)))
    ENDIF                                            ! ...sonst Pfeil lassen
    '
  ENDSELECT
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! Bis LAST_OB gesetzt
'
NEXT tree&
'
{rsc_userblk%}=0                                       ! Fr Nullstrings
rsc_userblk%=a%                                        ! Fr MFREE() am Ende
'
RETURN TRUE                                            ! Alles OK
ENDFUNC
> PROCEDURE rsc_instal_userdef(tree&,obj&,nr&)
'
' Userdef-Objekt installieren...
'
' nr& bezeichnet eine der folgenden Ausgaberoutinen:
' 1  Radiobutton, rund
' 2  Check-Button
' 3  Rahmen
' 4  Unterstr. Text
' 5  Flydial
' 6  Button
' 7  Circlebutton
' 8  Niceline
'
{rsc_userblk%}=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,SHL(PRED(nr&),1))})
{ADD(rsc_userblk%,4)}=OB_SPEC(rsc_adr%(tree&),obj&)
'
OB_SPEC(rsc_adr%(tree&),obj&)=rsc_userblk%             ! userdef und alter Typ
OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(BYTE(OB_TYPE(rsc_adr%(tree&),obj&)),8),24)
'                                                      ! im oberen Byte
ADD rsc_userblk%,8
'
RETURN
'
> PROCEDURE rsc_draw(tree&,flag%)
LOCAL fly&,title&,obj&,x&,y&,w&,h&,rx&,ry&,rb&,rh&,handle&,a%,rsc_adr%
'
' Stellt einen Dialog auf dem Bildschirm dar...
'
' tree&   : Index des Dialogbaumes
' flag%   : Bitbelegung
'           Bit 0 -> Fensterdialog
'           Bit 1 -> Schliežfeld
'           Bit 2 -> Bei Fensterdialogen: Sofort zeichnen
'
rsc_adr%=rsc_adr%(tree&)
' --------------------------------------------------- Titel & Flugecke suchen
DO WHILE NOT (fly&>0 AND title&>0)
INC obj&
IF BTST(OB_STATE(rsc_adr%,obj&),1)                ! Flugecke...
  fly&=obj&
ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),13)          ! Dialogtitel...
  title&=obj&
ENDIF
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
' --------------------------------------------------- Als Fenster-Dialog
IF BTST(flag%,0)
x&=SUCC(rscx&(tree&))
y&=ADD(ADD(rscy&(tree&),SHL(hchar&,1)),5)
w&=SUB(rscw&(tree&),2)
h&=SUB(SUB(rsch&(tree&),SHL(hchar&,1)),5)
'
IF fly&                                           ! Flugecke hidden...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                 ! Rahmen: 1 Pixel aužen...
OB_SPEC(rsc_adr%,0)=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
'
rx&=OR(&X1001,SHL(-BTST(flag%,1),1))              ! Ggf. Schliežfeld
handle&=WIND_CREATE(rx&,deskx&,desky&,deskw&,deskh&)
IF handle&>0                                      ! Fenster vorhanden...
  '
  ~WIND_UPDATE(1)                                 ! BEG_UPDATE
  '
  INC rsc_window&                                 ! Anz. offene Fenster+1
  rsc_menu_ienable(FALSE)                         ! Mentitel disablen
  '
  IF title&                                       ! Dialogtitel existiert...
    a%=C:rsc_obspec%(L:rsc_adr%,title&)           ! ...Adresse des Titels
  ELSE
    a%=rsc_userblk%                               ! ...sonst Nullstring
  ENDIF
  ~WIND_SET(handle&,2,INT(SWAP(a%)),INT(a%),0,0)  ! Fenstertitel setzen
  '
  ~WIND_CALC(0,&X1001,x&,y&,w&,h&,rx&,ry&,rb&,rh&)! WC_BORDER
  ~WIND_OPEN(handle&,rx&,ry&,rb&,rh&)
  '
  rsc_handle%(tree&)=handle&
  '
  IF BTST(flag%,2)                                ! Sofort zeichnen...
    rsc_message(tree&,20,x&,y&,w&,h&,0,0)         ! ...redrawen
    REPEAT
      obj&=EVNT_MULTI(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1000)
      IF BTST(obj&,4) AND (MENU(4)<>rsc_handle%(tree&))
        '           message_auswerten(MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
      ENDIF
    UNTIL BTST(obj&,5)                            ! ...bis Timer-Event
  ENDIF
  '
  ~WIND_UPDATE(0)                                 ! END_UPDATE
  '
ENDIF
ENDIF
' --------------------------------------------------- Als normaler Dialog
IF rsc_handle%(tree&)=0
a%=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
OB_SPEC(rsc_adr%,0)=OR(a%,SHL(2,16))              ! Rahmen: 2 Pixel innen
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'                                                 ! Aužerhalb des Screens...
IF rscy&(tree&)<desky& OR ADD(rscx&(tree&),PRED(w&))>ADD(deskx&,PRED(deskw&)) OR ADD(rscy&(tree&),PRED(h&))>ADD(desky&,PRED(deskh&))
  ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                             ! ...wieder in die Mitte
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
'
rsc_list$=rsc_list$+MKI$(tree&)                   ! Dialog in die Liste aufnehmen
'
rsc_handle%(tree&)=MALLOC(@getsize(w&,h&))
IF rsc_handle%(tree&)                             ! Hintergrund retten...
  rsc_bitblt(0,0,0,rsc_handle%(tree&),w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
  '
ENDIF
'
IF fly&>0 AND rsc_handle%(tree&)>0               ! Flugecke sichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BCLR(OB_FLAGS(rsc_adr%,fly&),7)
ELSE IF fly&                                     ! unsichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                ! Zeichnen...
~OBJC_DRAW(rsc_adr%,0,7,rscx&(tree&),rscy&(tree&),w&,h&)
'
ENDIF
'
RETURN
> PROCEDURE rsc_menu_ienable(stat!)
LOCAL obj&,title&,rsc_adr%
'
' Disabled/enabled alle Men-Titel und den 'About...'-Men-Eintrag...
'                                ! Gibt es ein Men..
IF rsc_menu&>-1 AND rsc_window&=1! und ist es das 1. Fenster?
'
rsc_adr%=rsc_adr%(rsc_menu&)
'                              ! Objektbreite ver„ndern...
IF stat!                       ! Enablen...
  OB_W(rsc_adr%,2)=rscw&(rsc_menu&)
ELSE                           ! Disablen...
  rscw&(rsc_menu&)=OB_W(rsc_adr%,2)
  OB_W(rsc_adr%,2)=OB_W(rsc_adr%,3)
ENDIF
'
obj&=3                         ! Ersten Mentitel berspringen
'
REPEAT
  INC obj&
  '                            ! G_TITEL...
  IF BYTE(OB_TYPE(rsc_adr%,obj&))=32
    '
    ~MENU_IENABLE(rsc_adr%,obj&,stat!)
    '
    title&=obj&                ! Wird fr 'About...' gebraucht
  ENDIF
  '
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
'                              ! 'About...' dis/enablen
~MENU_IENABLE(rsc_adr%,ADD(title&,3),stat!)
'                              ! Unter MultiTOS...
IF (rsc_aes&>=&H400) AND rsc_mtsk!
  IF ap_id&=MENU_BAR(rsc_adr%,-1)
    ~MENU_BAR(rsc_adr%,1)      ! ...Menu nur neu anzeigen, wenn erlaubt
  ENDIF
ELSE                           ! Unter SingleTOS...
  ~MENU_BAR(rsc_adr%,1)        ! ...Menu immer neu anzeigen
ENDIF
'
ENDIF
'
RETURN
'
> FUNCTION rsc_do(tree&,next_obj&,VAR popup&)
$F%
LOCAL a&,handle&,a$
LOCAL edit_obj&,cont&,ob_tail&,obj&,idx&,flags&,rsc_adr%,keytab%
LOCAL ascii|,scan|,evnt&,mx&,my&,mb&,mc&,shift&,key&
'
' Dialog auswerten...
'
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(1)                                      ! ...BEG_UPDATE
~WIND_UPDATE(3)                                      ! ...BEG_MCTRL
flags&=&X11                                          ! ...BUTTON/KEYBD-Events
'
ELSE                                                   ! Fenster-Dialog...
flags&=&X10011                                       ! ...zus. MESSAGE-Events
ENDIF
'
rsc_adr%=rsc_adr%(tree&)
cont&=TRUE
' ------------------------------------------------------ Editierbares Objekt
DO WHILE (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3)) OR BTST(OB_STATE(rsc_adr%,next_obj&),3)
INC next_obj&
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,next_obj&),5)
IF BTST(OB_FLAGS(rsc_adr%,next_obj&),5) AND (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3))
next_obj&=0
ENDIF
' ------------------------------------------------------
'
IF next_obj&<>0 AND edit_obj&<>next_obj&             ! Ggf. Cursor setzen...
edit_obj&=next_obj&                                ! ...Exit-Code zurck
next_obj&=0                                        ! ...'rsc_do' verlassen
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)       ! ...Cursor ein
ENDIF
'
ON MENU KEY GOSUB key
ON MENU MESSAGE GOSUB message
next_obj&=0
REPEAT
ON MENU
IF MOUSEK=1 THEN
GOSUB button
ENDIF
IF nr=smp16& THEN
@edhandler
ENDIF
IF nr=smpedit& THEN
@edhandler2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(0)                                      ! END_UPDATE
~WIND_UPDATE(2)                                      ! END_MCTRL
ENDIF
IF mc&=2 AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6)      ! Doppelklick auf
next_obj&=WORD(BSET(next_obj&,15))                   ! TOUCHEXIT...
ENDIF                                                  ! ...15. Bit setzen
UNTIL next_obj&<>0
rsc_do_ende:
RETURN next_obj&
ENDFUNC
> FUNCTION rsc_popup(a!,tree&,button&,popup&,def&)
$F%
LOCAL x&,y&,b&,h&,m!
LOCAL evnt&,mx&,my&,mb&,shift&,key&,mc&,ascii|,scan|
LOCAL obj&,old_obj&,first&,anz&
LOCAL rsc&,rsc_adr%
'
' Popup-Men darstellen und auswerten...
'
' a!       : TRUE: Button ver„ndern, FALSE: Nur Popup
' tree&    : Index des Dialogbaumes
' button&  : Objektnr. des bet„tigten Buttons
' popup&   : Index des Popups
' def&     : Default-Eintrag (1-x)
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~WIND_UPDATE(3)                                   ! BEG_MCTRL
'
rsc_adr%=rsc_adr%(rsc_popup&)
'
first&=OB_HEAD(rsc_adr%,popup&)                   ! erster Eintrag
anz&=SUB(OB_TAIL(rsc_adr%,popup&),first&)         ! Anzahl Eintr„ge-1
' ------------------------------------------------- Popup positionieren
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)
OB_X(rsc_adr%,0)=SUB(x&,OB_X(rsc_adr%,popup&))
OB_Y(rsc_adr%,0)=MAX(ADD(hchar&,4),MIN(SUB(WORK_OUT(1),4)-OB_H(rsc_adr%,popup&),SUB(y&,MUL(def&,hchar&))))-OB_Y(rsc_adr%,popup&)
'
x&=ADD(OB_X(rsc_adr%,0),PRED(OB_X(rsc_adr%,popup&)))
y&=ADD(OB_Y(rsc_adr%,0),PRED(OB_Y(rsc_adr%,popup&)))
b&=ADD(OB_W(rsc_adr%,popup&),4)
h&=ADD(OB_H(rsc_adr%,popup&),4)
' -------------------------------------------------
rsc_bitblt(0,0,0,popup_back%,b&,h&,x&,y&,b&,h&,0,0)
'
~OBJC_DRAW(rsc_adr%,0,7,x&,y&,b&,h&)              ! Popup zeichnen
'
IF a!                                             ! Button ver„ndern...
'
~GRAF_MOUSE(256,0)                              ! Hidem
V~H=rsc_vh&                                     ! ...Default-Eintrag mit...
GRAPHMODE 2
'
INTIN(0)=8                                      ! ...H„kchen versehen
PTSIN(0)=ADD(x&,DIV(wchar&,2))
PTSIN(1)=y&-DIV(hchar&,6)+MUL(SUCC(def&),hchar&)
VDISYS 8,1,1                                    ! ...v_gtext()
'
GRAPHMODE 1
V~H=-1
~GRAF_MOUSE(257,0)                              ! Showm
'
ENDIF
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)      ! Objekt unter der Maus...
'
IF obj&<=0                                        ! Daneben...
obj&=ADD(first&,def&)                           ! ...Default-Eintrag nehmen
ENDIF
'
old_obj&=obj&
IF (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))   ! Nicht disabled...
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
ENDIF                                             ! ...selektieren
'
~EVNT_TIMER(200)
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
IF mb&=1
m!=TRUE
evnt&=4
ENDIF
'
' --------------------------------------------------
DO
'
IF NOT m!
evnt&=EVNT_MULTI(&X111,1,1,1,1,mx&,my&,1,1,0,0,0,0,0,0,0,mx&,my&,mb&,shift&,key&,mc&)
ELSE
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
ENDIF
'
IF BTST(evnt&,0)                                 ! Tastaturereignis...
ascii|=BYTE(key&)
scan|=BYTE(SHR(key&,8))
'                                              ! Noch kein sel. Eintrag...
IF NOT (obj&>=first& AND obj&<=ADD(first&,anz&))
obj&=first&
'
ELSE IF scan|=80                               ! ...Cursor runter
INC obj&
IF obj&>ADD(first&,anz&)
  obj&=first&
ENDIF
'
ELSE IF scan|=72                               ! ...Cursor runter
DEC obj&
IF obj&<first&
  obj&=ADD(first&,anz&)
ENDIF
'
ENDIF
'
ENDIF
'
IF BTST(evnt&,2)                                 ! Mausereignis...
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)
ENDIF
'                                                ! Alten Eintrag deselekt...
IF obj&<>old_obj&
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),1)
ENDIF
'                                                ! Im Men und nicht disabled...
IF (obj&>=first& AND obj&<=ADD(first&,anz&)) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
'                                              ! ...neuen selektieren
old_obj&=obj&
rsc&=SUB(obj&,first&)                          ! Rckgabe
ENDIF
'
LOOP UNTIL BTST(evnt&,1) OR (mb&<>1 AND m!) OR ascii|=13 OR ascii|=27 OR scan|=97
' --------------------------------------------------
rsc_bitblt(popup_back%,b&,h&,0,0,0,0,0,b&,h&,x&,y&)! Hintergrund restaurieren
'
IF rsc&=SUB(obj&,first&) AND scan|<>97 AND ascii|<>27 ! Eintrag ausgew„hlt...
'
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,obj&),0),0)
'
IF a!                                            ! Button ver„ndern...
'                                              ! Neuen Text eintragen:
rsc_text(tree&,button&,@rsc_text$(rsc_popup&,obj&))
'
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)    ! Button zeichnen
~OBJC_DRAW(rsc_adr%(tree&),button&,1,x&,y&,OB_W(rsc_adr%(tree&),button&),OB_H(rsc_adr%(tree&),button&))
'
ENDIF
'
ELSE                                               ! Daneben => Abbruch...
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),0)
'
rsc&=-1                                          ! ...Abbruch markieren
'
ENDIF
'
REPEAT
~GRAF_MKSTATE(mx&,my&,mb&,shift&)                ! Mausknopf 'entprellen'
UNTIL mb&=0
'
~WIND_UPDATE(2)                                    ! END_MCTRL
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN SUCC(rsc&)
ENDFUNC
'
> PROCEDURE rsc_movedial(tree&,edit_obj&,idx&)
LOCAL ghost!,x&,y&,a%
'
' Dialogbox bewegen...
' M”chten Sie SOLID-Flydials? Dann ersetzen Sie diese Prozedur
' durch die entsprechenden aus der EXTENDED.LST-Datei.
'
~GRAF_MKSTATE(x&,x&,x&,y&)
ghost!=AND(y&,&X1111) OR x&=3                            ! Geisterdials...
IF ghost!
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
ENDIF
'
~GRAF_MOUSE(4,0)                                         ! Bewegen...
~GRAF_DRAGBOX(rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),deskx&,desky&,deskw&,deskh&,x&,y&)
~GRAF_MOUSE(0,0)
'
IF x&<>rscx&(tree&) OR y&<>rscy&(tree&) OR ghost!        ! šberhaupt bewegt...
'
IF NOT ghost!
a%=MALLOC(@getsize(rscw&(tree&),rsch&(tree&)))       ! Dialog getten
IF a%                                                ! ...hat geklappt
rsc_bitblt(0,0,0,a%,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
ENDIF
ENDIF
'                                                      ! Hintergr. restaur.
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
'
rscx&(tree&)=x&                                        ! Neue Position setzen...
rscy&(tree&)=y&
'
OB_X(rsc_adr%(tree&),0)=ADD(x&,3)
OB_Y(rsc_adr%(tree&),0)=ADD(y&,3)
'                                                      ! Neuen Hintergr. holen
rsc_bitblt(0,0,0,rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
'                                                      ! Dialog hinsetzen...
IF a%                                                  ! Hintergrund gerettet...
rsc_bitblt(a%,rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~MFREE(a%)
ELSE                                                   ! Sonst wenigstens...
~OBJC_DRAW(rsc_adr%(tree&),0,7,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
IF edit_obj&
rsc_cursor(rsc_adr%(tree&),edit_obj&,idx&)           ! ...Cursor ein
ENDIF
ENDIF
'
ENDIF
'
RETURN
> PROCEDURE rsc_message(tree&,message&,x&,y&,w&,h&,edit_obj&,idx&)
LOCAL a|,ax&,ay&,ab&,ah&,handle&,obj&,rsc_adr%,a%,a$
'
' Wertet ein innerhalb des 'rsc_do' eingetroffenes Message-Ereignis aus...
'
handle&=rsc_handle%(tree&)                         ! Fensterhandle des Dialogs
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
SELECT message&
' --------------------------------------------------------------------------
CASE 20,21                                         ! WM_REDRAW/WM_TOPPED
IF message&=20                                   ! WM_REDRAW...
' ~GRAF_MOUSE(256,0)                           ! Hidem
~WIND_GET(handle&,11,ax&,ay&,ab&,ah&)          ! 1. Rechteck
'
REPEAT
'
IF RC_INTERSECT(x&,y&,w&,h&,ax&,ay&,ab&,ah&) ! ...redrawen
  ~OBJC_DRAW(rsc_adr%(tree&),0,7,ax&,ay&,ab&,ah&)
ENDIF
'
~WIND_GET(handle&,12,ax&,ay&,ab&,ah&)        ! N„chstes Rechteck...
UNTIL ab&=0 AND ah&=0                          ! ...kein Redraw mehr n”tig
'
' ~GRAF_MOUSE(257,0)                           ! Showm
'
ELSE                                             ! WM_TOPPED...
~WIND_SET(handle&,10,0,0,0,0)                  ! ...toppen
ENDIF
'
~WIND_GET(0,10,ax&,ay&,ay&,ay&)                  ! Oberstes Fenster...
IF ax&=handle& AND edit_obj&>0                   ! Ist das unsrige...
' ---------------------------------------------- Cursor-Setz-Orgie...
rsc_adr%=rsc_adr%(tree&)
'
obj&=edit_obj&                                 ! Parent ermitteln...
'
REPEAT
obj&=OB_NEXT(rsc_adr%,obj&)
UNTIL obj&<edit_obj&
'
~OBJC_OFFSET(rsc_adr%,edit_obj&,ax&,ay&)       ! Koordinaten des Objekts
'
a$=CHAR{{ADD(OB_SPEC(rsc_adr%,edit_obj&),4)}}  ! Maske: "Eingabe:______"
ah&=1
WHILE MID$(a$,ah&,1)<>"_"                      ! L„nge des Vortextes...
INC ah&
WEND                                           ! ...ermitteln
'
ADD ax&,MUL(wchar&,ADD(PRED(ah&),idx&))        ! Cursor-Position im Pixeln
ah&=ADD(OB_H(rsc_adr%,edit_obj&),6)            ! Cursor ist gr”žer hchar&
'                                              ! Cursor l”schen...
~OBJC_DRAW(rsc_adr%,obj&,7,ax&,SUB(ay&,3),wchar&,ah&)
rsc_cursor(rsc_adr%,edit_obj&,idx&)            ! ...und setzen
'
ENDIF
' --------------------------------------------------------------------------
CASE 28                                            ! WM_MOVED
~WIND_CALC(1,&X1001,x&,y&,w&,h&,ax&,ay&,ab&,ah&)
'
rscx&(tree&)=PRED(ax&)
rscy&(tree&)=SUB(SUB(ay&,5),MUL(hchar&,2))
OB_X(rsc_adr%(tree&),0)=ADD(rscx&(tree&),3)
OB_Y(rsc_adr%(tree&),0)=ADD(rscy&(tree&),3)
'
~WIND_SET(handle&,5,x&,y&,w&,h&)
'
ENDSELECT
'
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN
'
> PROCEDURE rsc_back(tree&)
'
' Entfernt den Dialog vom Bildschirm...
'
' ---------------------------------------------------- Als Fenster-Dialog
IF rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
rsc_menu_ienable(TRUE)                             ! ...Men wieder w„hlbar
'
IF rsc_window&                                     ! Fenster existiert...
'
~WIND_CLOSE(rsc_handle%(tree&))
~WIND_DELETE(rsc_handle%(tree&))                 ! ...schliežen & abmelden
'
DEC rsc_window&                                  ! Anz. offene Fenster-1
'
ELSE                                               ! Sonst Redraw ausl”sen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF
' -------------------------------------------------- Als normaler Dialog
ELSE
rsc_list$=LEFT$(rsc_list$,SUB(LEN(rsc_list$),2))   ! Dialog aus der Liste entf.
'
IF rsc_handle%(tree&)                              ! Hintergrund gerettet...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~MFREE(rsc_handle%(tree&))
'
ELSE                                               ! Desktop redrawen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
IF rsc_list$<>""                                 ! Noch ein Dialog drunter...
~OBJC_DRAW(rsc_adr%(CVI(RIGHT$(rsc_list$,2))),0,7,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                            ! ...diesen auch redrawen
ENDIF
ENDIF
'
rsc_handle%(tree&)=0
'
~WIND_UPDATE(0)                                      ! END_UPDATE
'
RETURN
'
> PROCEDURE rsc_text(tree&,obj&,a$)
'
' Universelle Objekt-Text Belegung...
'
'  CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}=a$
RETURN
> PROCEDURE rsc_bitblt(a%,w&,h&,b%,rb&,rh&,ax&,ay&,ab&,ah&,gx&,gy&)
'
' Universeller Raster-Kopierer (benutzt vro_cpyfm oder vrt_cpyfm)...
'
IF ab&>0 AND ah&>0                 ! Breite und H”he vorhanden...
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:a%,w&,h&,0,planes&,L:b%,rb&,rh&,0,planes&,ax&,ay&,ab&,ah&,gx&,gy&,1)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_cursor(rsc_adr%,edit_obj&,idx&)
LOCAL a|,a%
'
' Zeichengenaue Positionierung des Cursors...
'
a%=ADD({OB_SPEC(rsc_adr%,edit_obj&)},idx&)
'
a|=BYTE{a%}                                        ! Zeichen merken
BYTE{a%}=0                                         ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)       ! Cursor setzen
BYTE{a%}=a|                                        ! ...Zeichen restaurieren
'
RETURN
' ------------------------------------------------------------------------------
