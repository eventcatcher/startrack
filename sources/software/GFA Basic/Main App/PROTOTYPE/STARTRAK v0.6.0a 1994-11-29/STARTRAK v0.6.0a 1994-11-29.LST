$m500000
demo=FALSE
' ------------------------------------------------------------------------------
' ------------------------REGISTER----------------------------------------------
' ------------------------------------------------------------------------------
' READ  00h   Status Low   SUBFR0   Bit0-1 -> AESC24,AESC25,(AESF0)
' READ  00h   Status Low   SUBFR1   Bit0-2 -> AESC24,AESC25,EMPH
'
' WRITE 00h   Register Low          Bit0-3 -> SWAES,SWDIGIN,TAKT0,TAKT1
'
'
'
' READ  20h   Status Mid   SUBFR0   Bit0-2 -> ERR0,ERR1,ERR2
' READ  20h   Status Mid   SUBFR1   Bit0-2 -> USE,AUDIO,PROT
'
'
'
' READ  40h   Status High           Bit0-3 -> RDE,RDH,WRF,WRH
'
' WRITE 40h   Register High         Bit0-3 -> SWPROT,SWRES-FIFO,SWDIGOUT,SWSUBFR
'
'
'
' WRITE 80h   DSP-Register          Bit0-1 -> DSPON,DSPIN
'
'
'
' RD/WR C0h   Sample Read/Write
'
'
' SAMPLER zum VME_SMP16
'
' Bedienung aller wichtiger Parametrer des 16Bit-Stereo-Samplers
'
' lÑuft als Gem-Prg sowie als Accessory (Endung von .PRG auf .ACC Ñndern)
'
' ------------------------------------------------------------------------------
' ------------------------ACC-ABFRAGE-------------------------------------------
' ------------------------------------------------------------------------------
CLIP OFF
compile=BYTE{ADD(BASEPAGE,256)}<>96
acc=({ADD(BASEPAGE,36)}=0)
INLINE m_busy%,592
m_adr%=m_busy%
IF auflauf=0 THEN
  xwidth=WORK_OUT(0)+1
  ywidth=WORK_OUT(1)+1
ENDIF
IF acc=TRUE THEN
  '  $I-
  ~MENU_REGISTER(APPL_INIT(),"  VME_SMP16")
  DO
    ~EVNT_MESAG(0)
    IF MENU(1)=40
      IF xwidth<640 OR ywidth<400 THEN
        ALERT 3,"Auflîsung ist zu gering|Mindestens 640x400 nîtig !",1,"EXIT",g
        GOTO ende
      ENDIF
      GOTO start
    ende:
    ENDIF
  LOOP
ELSE
  @busy_mouse
ENDIF
'
' ----------------------------Variablendefinition-------------------------------
start:
auflauf=auflauf+1
IF auflauf=1 THEN
  ' ------------------------------------------------------------------------------
  ' ------------------------RSC-VARIABLEN-----------------------------------------
  ' ------------------------------------------------------------------------------
  LET smp16&=0 !RSC_TREE
  LET smpedit&=1 !RSC_TREE
  LET dspedit&=2 !RSC_TREE
  LET peak&=3 !RSC_TREE
  LET loop&=4 !RSC_TREE
  LET normaliz&=5 !RSC_TREE
  LET resample&=6 !RSC_TREE
  LET midiedit&=7 !RSC_TREE
  LET editfade&=8 !RSC_TREE
  LET popups&=9 !RSC_TREE
  LET record&=10 !RSC_TREE
  LET cutedit&=11 !RSC_TREE
  LET savebloc&=12 !RSC_TREE
  LET arranger&=13 !RSC_TREE
  LET loadbloc&=14 !RSC_TREE
  LET setup&=15 !RSC_TREE
  LET info&=16 !RSC_TREE
  LET arrmname&=17 !RSC_TREE
  LET delay&=18 !RSC_TREE
  LET virtual&=19 !RSC_TREE
  LET concat&=20 !RSC_TREE
  LET space&=21 !RSC_TREE
  LET moving&=22 !RSC_TREE
  LET arrmake&=23 !RSC_TREE
  LET timeed&=24 !RSC_TREE
  LET mainbox&=0 !Obj in #0
  LET exit&=2 !Obj in #0
  LET datei&=4 !Obj in #0
  LET mainbox2&=5 !Obj in #0
  LET emph&=7 !Obj in #0
  LET audio&=8 !Obj in #0
  LET use&=9 !Obj in #0
  LET smp32&=11 !Obj in #0
  LET smp44&=12 !Obj in #0
  LET smp48&=13 !Obj in #0
  LET noval&=15 !Obj in #0
  LET confid&=16 !Obj in #0
  LET slipped&=17 !Obj in #0
  LET crc&=18 !Obj in #0
  LET parity&=19 !Obj in #0
  LET biphase&=20 !Obj in #0
  LET nolock&=21 !Obj in #0
  LET prot&=23 !Obj in #0
  LET mainbox5&=24 !Obj in #0
  LET edit&=25 !Obj in #0
  LET swdsp&=26 !Obj in #0
  LET peaksw&=27 !Obj in #0
  LET mainbox6&=31 !Obj in #0
  LET protect&=35 !Obj in #0
  LET input&=37 !Obj in #0
  LET incirc&=38 !Obj in #0
  LET source&=39 !Obj in #0
  LET srccirc&=40 !Obj in #0
  LET smpauto&=42 !Obj in #0
  LET smpstart&=43 !Obj in #0
  LET mainbox4&=45 !Obj in #0
  LET rate2&=48 !Obj in #0
  LET ratecir2&=49 !Obj in #0
  LET mainbox3&=50 !Obj in #0
  LET dsp&=53 !Obj in #0
  LET dspcirc&=54 !Obj in #0
  LET filesel&=56 !Obj in #0
  LET memused&=58 !Obj in #0
  LET helporig&=63 !Obj in #0
  LET play&=64 !Obj in #0
  LET editbox7&=0 !Obj in #1
  LET editbox&=2 !Obj in #1
  LET smplen&=3 !Obj in #1
  LET smpsec&=4 !Obj in #1
  LET smpexit&=7 !Obj in #1
  LET smpl1&=9 !Obj in #1
  LET smpr1&=10 !Obj in #1
  LET smpl2&=11 !Obj in #1
  LET smpr2&=12 !Obj in #1
  LET smpl3&=13 !Obj in #1
  LET smpr3&=14 !Obj in #1
  LET smpanf&=15 !Obj in #1
  LET smpend&=16 !Obj in #1
  LET smpmid&=17 !Obj in #1
  LET rate&=18 !Obj in #1
  LET ratecirc&=19 !Obj in #1
  LET editbox6&=20 !Obj in #1
  LET smppmark&=21 !Obj in #1
  LET midi&=22 !Obj in #1
  LET smploop&=23 !Obj in #1
  LET mintext&=24 !Obj in #1
  LET smpfile&=26 !Obj in #1
  LET smprate&=27 !Obj in #1
  LET editbox5&=28 !Obj in #1
  LET mover&=29 !Obj in #1
  LET movecirc&=30 !Obj in #1
  LET uhr&=31 !Obj in #1
  LET trash&=32 !Obj in #1
  LET editbox3&=34 !Obj in #1
  LET editbox8&=35 !Obj in #1
  LET smpsta&=36 !Obj in #1
  LET smpstb&=37 !Obj in #1
  LET smpstc&=38 !Obj in #1
  LET smpstd&=39 !Obj in #1
  LET smpste&=40 !Obj in #1
  LET editbox9&=41 !Obj in #1
  LET hacksa&=42 !Obj in #1
  LET hacksb&=43 !Obj in #1
  LET hacksc&=44 !Obj in #1
  LET hacksd&=45 !Obj in #1
  LET hackse&=46 !Obj in #1
  LET hackss&=47 !Obj in #1
  LET smptsa&=48 !Obj in #1
  LET smptsb&=49 !Obj in #1
  LET smptsc&=50 !Obj in #1
  LET smptsd&=51 !Obj in #1
  LET smptse&=52 !Obj in #1
  LET smptsava&=53 !Obj in #1
  LET smpsavl&=55 !Obj in #1
  LET editbox4&=56 !Obj in #1
  LET editbx10&=57 !Obj in #1
  LET smpea&=58 !Obj in #1
  LET smpeb&=59 !Obj in #1
  LET smpec&=60 !Obj in #1
  LET smped&=61 !Obj in #1
  LET smpee&=62 !Obj in #1
  LET editbx11&=63 !Obj in #1
  LET hackea&=64 !Obj in #1
  LET hackeb&=65 !Obj in #1
  LET hackec&=66 !Obj in #1
  LET hacked&=67 !Obj in #1
  LET hackee&=68 !Obj in #1
  LET hackes&=69 !Obj in #1
  LET smptea&=70 !Obj in #1
  LET smpteb&=71 !Obj in #1
  LET smptec&=72 !Obj in #1
  LET smpted&=73 !Obj in #1
  LET smptee&=74 !Obj in #1
  LET smptsavb&=75 !Obj in #1
  LET smpsavr&=77 !Obj in #1
  LET coptoarr&=79 !Obj in #1
  LET coptotxt&=80 !Obj in #1
  LET smpedhlp&=81 !Obj in #1
  LET editbox2&=82 !Obj in #1
  LET setuper&=83 !Obj in #1
  LET norm&=84 !Obj in #1
  LET resmp&=85 !Obj in #1
  LET mono&=86 !Obj in #1
  LET mix&=87 !Obj in #1
  LET edfade&=88 !Obj in #1
  LET peaksw2&=89 !Obj in #1
  LET monitor&=90 !Obj in #1
  LET smpauto2&=91 !Obj in #1
  LET smpstrt2&=92 !Obj in #1
  LET smpplay&=93 !Obj in #1
  LET loopart&=94 !Obj in #1
  LET cut&=95 !Obj in #1
  LET hard&=96 !Obj in #1
  LET arrange&=97 !Obj in #1
  LET smpload&=98 !Obj in #1
  LET smpsave&=99 !Obj in #1
  LET infoicon&=100 !Obj in #1
  LET edmidi&=101 !Obj in #1
  LET dspbox&=0 !Obj in #2
  LET dsphall&=2 !Obj in #2
  LET dspecho&=3 !Obj in #2
  LET dspret&=4 !Obj in #2
  LET dspeq&=5 !Obj in #2
  LET dspload&=6 !Obj in #2
  LET helpdsp&=7 !Obj in #2
  LET dspexit&=8 !Obj in #2
  LET dspsave&=9 !Obj in #2
  LET peakbox&=0 !Obj in #3
  LET plmin&=14 !Obj in #3
  LET pl2&=15 !Obj in #3
  LET pl3&=16 !Obj in #3
  LET pl4&=17 !Obj in #3
  LET pl5&=18 !Obj in #3
  LET pl6&=19 !Obj in #3
  LET pl7&=20 !Obj in #3
  LET pl8&=21 !Obj in #3
  LET pl9&=22 !Obj in #3
  LET plmax&=23 !Obj in #3
  LET prmin&=24 !Obj in #3
  LET pr2&=25 !Obj in #3
  LET pr3&=26 !Obj in #3
  LET pr4&=27 !Obj in #3
  LET pr5&=28 !Obj in #3
  LET pr6&=29 !Obj in #3
  LET pr7&=30 !Obj in #3
  LET pr8&=31 !Obj in #3
  LET pr9&=32 !Obj in #3
  LET prmax&=33 !Obj in #3
  LET loopbox&=0 !Obj in #4
  LET loopexit&=1 !Obj in #4
  LET forw&=3 !Obj in #4
  LET cross&=4 !Obj in #4
  LET backw&=5 !Obj in #4
  LET helploop&=7 !Obj in #4
  LET autoloop&=8 !Obj in #4
  LET normbox&=0 !Obj in #5
  LET normok&=2 !Obj in #5
  LET normexit&=3 !Obj in #5
  LET normdb&=4 !Obj in #5
  LET normauto&=7 !Obj in #5
  LET normadj&=8 !Obj in #5
  LET norml1&=10 !Obj in #5
  LET normr1&=11 !Obj in #5
  LET norml2&=12 !Obj in #5
  LET normr2&=13 !Obj in #5
  LET norml3&=14 !Obj in #5
  LET normr3&=15 !Obj in #5
  LET helpnorm&=16 !Obj in #5
  LET resmpbox&=0 !Obj in #6
  LET resother&=1 !Obj in #6
  LET resl1&=3 !Obj in #6
  LET resl2&=4 !Obj in #6
  LET resl3&=5 !Obj in #6
  LET resr1&=6 !Obj in #6
  LET resr2&=7 !Obj in #6
  LET resr3&=8 !Obj in #6
  LET rsmptxt2&=10 !Obj in #6
  LET rsmptxt1&=11 !Obj in #6
  LET res32&=13 !Obj in #6
  LET res44&=15 !Obj in #6
  LET res48&=17 !Obj in #6
  LET helprsmp&=18 !Obj in #6
  LET resok&=19 !Obj in #6
  LET resexit&=20 !Obj in #6
  LET restxt&=22 !Obj in #6
  LET midibox&=0 !Obj in #7
  LET notetxt&=1 !Obj in #7
  LET midinup&=2 !Obj in #7
  LET midindwn&=3 !Obj in #7
  LET midioup&=4 !Obj in #7
  LET midiodwn&=5 !Obj in #7
  LET chtxt&=7 !Obj in #7
  LET midicup&=9 !Obj in #7
  LET midicdwn&=10 !Obj in #7
  LET midiok&=11 !Obj in #7
  LET helpmidi&=13 !Obj in #7
  LET fadebox&=0 !Obj in #8
  LET fadeok&=2 !Obj in #8
  LET fadeup&=3 !Obj in #8
  LET fadedown&=4 !Obj in #8
  LET fadeli&=5 !Obj in #8
  LET fadere&=6 !Obj in #8
  LET fadelin&=8 !Obj in #8
  LET infade&=10 !Obj in #8
  LET ausfade&=11 !Obj in #8
  LET helpfade&=12 !Obj in #8
  LET smppopup&=1 !Obj in #9
  LET rate32&=2 !Obj in #9
  LET rate44&=3 !Obj in #9
  LET rate48&=4 !Obj in #9
  LET dsppopup&=5 !Obj in #9
  LET dspoff&=6 !Obj in #9
  LET dspin&=7 !Obj in #9
  LET dspout&=8 !Obj in #9
  LET smppop2&=9 !Obj in #9
  LET ad32&=10 !Obj in #9
  LET ad44&=11 !Obj in #9
  LET ad48&=12 !Obj in #9
  LET inpop&=13 !Obj in #9
  LET analog&=14 !Obj in #9
  LET digital&=15 !Obj in #9
  LET srcpop&=16 !Obj in #9
  LET opto&=17 !Obj in #9
  LET coax&=18 !Obj in #9
  LET popmark&=19 !Obj in #9
  LET smpmark&=20 !Obj in #9
  LET smpzoom&=21 !Obj in #9
  LET smpscrol&=22 !Obj in #9
  LET kopy&=23 !Obj in #9
  LET move&=24 !Obj in #9
  LET merge&=25 !Obj in #9
  LET fade&=26 !Obj in #9
  LET insert&=27 !Obj in #9
  LET recbox&=0 !Obj in #10
  LET recl1&=1 !Obj in #10
  LET recr1&=2 !Obj in #10
  LET recl2&=3 !Obj in #10
  LET recr2&=4 !Obj in #10
  LET timetxt&=5 !Obj in #10
  LET recok&=6 !Obj in #10
  LET recexit&=7 !Obj in #10
  LET rechelp&=9 !Obj in #10
  LET cutbox&=0 !Obj in #11
  LET cutin&=1 !Obj in #11
  LET cutout&=2 !Obj in #11
  LET cutexit&=3 !Obj in #11
  LET cuthelp&=5 !Obj in #11
  LET cutdel&=6 !Obj in #11
  LET savebox&=0 !Obj in #12
  LET savall&=1 !Obj in #12
  LET savblock&=2 !Obj in #12
  LET savexit&=3 !Obj in #12
  LET savehelp&=5 !Obj in #12
  LET arrbox&=0 !Obj in #13
  LET arrbox2&=1 !Obj in #13
  LET hlpedit2&=2 !Obj in #13
  LET hardmerg&=3 !Obj in #13
  LET arrload&=4 !Obj in #13
  LET arrsave&=5 !Obj in #13
  LET arrplay&=6 !Obj in #13
  LET arrmidi&=7 !Obj in #13
  LET arrins&=8 !Obj in #13
  LET arrdel&=9 !Obj in #13
  LET arrdelay&=10 !Obj in #13
  LET smpauto3&=12 !Obj in #13
  LET smpstrt3&=13 !Obj in #13
  LET pause&=14 !Obj in #13
  LET rewind&=15 !Obj in #13
  LET stop&=16 !Obj in #13
  LET recplay&=17 !Obj in #13
  LET smpplay2&=18 !Obj in #13
  LET smprplay&=19 !Obj in #13
  LET forward&=20 !Obj in #13
  LET arrstrt&=21 !Obj in #13
  LET arrend&=22 !Obj in #13
  LET arrbox4&=23 !Obj in #13
  LET playlen&=24 !Obj in #13
  LET playname&=25 !Obj in #13
  LET arreal&=26 !Obj in #13
  LET arrbox3&=33 !Obj in #13
  LET arrbox5&=34 !Obj in #13
  LET hardfs1&=35 !Obj in #13
  LET spur1&=36 !Obj in #13
  LET arrbox6&=37 !Obj in #13
  LET hardfs2&=38 !Obj in #13
  LET spur2&=39 !Obj in #13
  LET arrbox7&=40 !Obj in #13
  LET hardfs3&=41 !Obj in #13
  LET spur3&=42 !Obj in #13
  LET arrbox8&=43 !Obj in #13
  LET hardfs4&=44 !Obj in #13
  LET spur4&=45 !Obj in #13
  LET hardst2&=47 !Obj in #13
  LET hardst3&=49 !Obj in #13
  LET hardst4&=51 !Obj in #13
  LET harde2&=53 !Obj in #13
  LET harde3&=55 !Obj in #13
  LET harde4&=57 !Obj in #13
  LET harde1&=59 !Obj in #13
  LET hardlen1&=61 !Obj in #13
  LET hardlen2&=63 !Obj in #13
  LET hardlen3&=65 !Obj in #13
  LET hardlen4&=67 !Obj in #13
  LET hardstrt&=69 !Obj in #13
  LET hardend&=70 !Obj in #13
  LET arrnr1&=72 !Obj in #13
  LET arrnr2&=74 !Obj in #13
  LET arrnr3&=76 !Obj in #13
  LET arrmidi1&=77 !Obj in #13
  LET arrmidi2&=78 !Obj in #13
  LET arrmidi3&=79 !Obj in #13
  LET arrmidi4&=80 !Obj in #13
  LET arrm1&=81 !Obj in #13
  LET arrm2&=82 !Obj in #13
  LET arrm3&=83 !Obj in #13
  LET arrm4&=84 !Obj in #13
  LET hardst1&=86 !Obj in #13
  LET arrnote2&=88 !Obj in #13
  LET arrnote3&=90 !Obj in #13
  LET arrnote4&=92 !Obj in #13
  LET arrnr4&=96 !Obj in #13
  LET arrmem1&=98 !Obj in #13
  LET arrmem2&=100 !Obj in #13
  LET arrmem3&=102 !Obj in #13
  LET arrmem4&=104 !Obj in #13
  LET arrnote1&=106 !Obj in #13
  LET arrch1&=108 !Obj in #13
  LET arrch2&=110 !Obj in #13
  LET arrch3&=112 !Obj in #13
  LET arrch4&=114 !Obj in #13
  LET arrtri1&=117 !Obj in #13
  LET arrtri2&=118 !Obj in #13
  LET arrtri3&=119 !Obj in #13
  LET arrtri4&=120 !Obj in #13
  LET arrloop1&=123 !Obj in #13
  LET arrloop2&=124 !Obj in #13
  LET arrloop3&=125 !Obj in #13
  LET arrloop4&=126 !Obj in #13
  LET arrdel1&=129 !Obj in #13
  LET arrdel2&=130 !Obj in #13
  LET arrdel3&=131 !Obj in #13
  LET arrdel4&=132 !Obj in #13
  LET arrsmpr1&=134 !Obj in #13
  LET arrsmpr2&=136 !Obj in #13
  LET arrsmpr3&=138 !Obj in #13
  LET arrsmpr4&=140 !Obj in #13
  LET slideup&=145 !Obj in #13
  LET arrslide&=146 !Obj in #13
  LET slidedwn&=147 !Obj in #13
  LET arrexit&=148 !Obj in #13
  LET arrhelp&=149 !Obj in #13
  LET arrclip&=150 !Obj in #13
  LET loadbox&=0 !Obj in #14
  LET ladall&=1 !Obj in #14
  LET ladblock&=2 !Obj in #14
  LET ladhelp&=4 !Obj in #14
  LET ladexit&=5 !Obj in #14
  LET setupbox&=0 !Obj in #15
  LET sync&=2 !Obj in #15
  LET fseldef&=4 !Obj in #15
  LET fseltxt&=6 !Obj in #15
  LET wavset&=7 !Obj in #15
  LET avrset&=8 !Obj in #15
  LET sndset&=9 !Obj in #15
  LET auset&=10 !Obj in #15
  LET smpset&=11 !Obj in #15
  LET allset&=12 !Obj in #15
  LET secl&=16 !Obj in #15
  LET secr&=17 !Obj in #15
  LET seclen&=18 !Obj in #15
  LET sram&=21 !Obj in #15
  LET mallmax&=24 !Obj in #15
  LET lenmall&=26 !Obj in #15
  LET sethelp&=27 !Obj in #15
  LET recl&=30 !Obj in #15
  LET recr&=31 !Obj in #15
  LET recm&=32 !Obj in #15
  LET tresl&=36 !Obj in #15
  LET tresr&=37 !Obj in #15
  LET tresdb&=38 !Obj in #15
  LET setexit&=40 !Obj in #15
  LET setsave&=41 !Obj in #15
  LET setload&=42 !Obj in #15
  LET setok&=43 !Obj in #15
  LET dreide&=44 !Obj in #15
  LET grid&=45 !Obj in #15
  LET infobox&=0 !Obj in #16
  LET infoexit&=12 !Obj in #16
  LET helpinfo&=13 !Obj in #16
  LET arrmnbox&=0 !Obj in #17
  LET memname&=2 !Obj in #17
  LET amexit&=4 !Obj in #17
  LET amhelp&=5 !Obj in #17
  LET amok&=6 !Obj in #17
  LET delaybox&=0 !Obj in #18
  LET delayr&=2 !Obj in #18
  LET delayl&=3 !Obj in #18
  LET delaytim&=5 !Obj in #18
  LET delayex&=7 !Obj in #18
  LET delayok&=8 !Obj in #18
  LET delayhlp&=9 !Obj in #18
  LET virtbox&=0 !Obj in #19
  LET virthelp&=2 !Obj in #19
  LET virtbloc&=4 !Obj in #19
  LET virtok&=5 !Obj in #19
  LET virtwork&=6 !Obj in #19
  LET virtdir&=7 !Obj in #19
  LET vslider&=9 !Obj in #19
  LET vlslide&=10 !Obj in #19
  LET vrslide&=11 !Obj in #19
  LET vblkstrt&=13 !Obj in #19
  LET vblkmlen&=14 !Obj in #19
  LET vblkvlen&=17 !Obj in #19
  LET virtbox2&=18 !Obj in #19
  LET vsamples&=19 !Obj in #19
  LET vseconds&=20 !Obj in #19
  LET virtno&=21 !Obj in #19
  LET virtplay&=22 !Obj in #19
  LET cocatbox&=0 !Obj in #20
  LET conins&=1 !Obj in #20
  LET helpcon&=3 !Obj in #20
  LET conexit&=4 !Obj in #20
  LET conmix&=5 !Obj in #20
  LET conspace&=8 !Obj in #20
  LET spacebox&=0 !Obj in #21
  LET spacel1&=1 !Obj in #21
  LET spacer1&=2 !Obj in #21
  LET spacel2&=3 !Obj in #21
  LET spacer2&=4 !Obj in #21
  LET spacetxt&=5 !Obj in #21
  LET okspace&=6 !Obj in #21
  LET exspace&=7 !Obj in #21
  LET hlpspace&=9 !Obj in #21
  LET movngbox&=0 !Obj in #22
  LET movhlp&=1 !Obj in #22
  LET mvcutcpy&=3 !Obj in #22
  LET mvcutins&=4 !Obj in #22
  LET mvclrins&=5 !Obj in #22
  LET mvclrcpy&=6 !Obj in #22
  LET movexit&=7 !Obj in #22
  LET makebox&=0 !Obj in #23
  LET makexit&=2 !Obj in #23
  LET makehelp&=3 !Obj in #23
  LET makeok&=4 !Obj in #23
  LET makefsel&=5 !Obj in #23
  LET maketxt&=7 !Obj in #23
  LET makerate&=8 !Obj in #23
  LET timebox&=0 !Obj in #24
  LET tedtxt&=2 !Obj in #24
  LET tedexit&=4 !Obj in #24
  LET tedhelp&=5 !Obj in #24
  LET tedok&=6 !Obj in #24
  LET tedsmp&=7 !Obj in #24
  LET tedsec&=8 !Obj in #24
  OPTION BASE 0
  IF compile=FALSE THEN
    RESERVE 400000
  ENDIF
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------AUFLôSUNG ERFRAGEN------------------------------------
' ------------------------------------------------------------------------------
IF xwidth<640 OR ywidth<400 THEN
  ALERT 3,"Auflîsung ist zu gering|Mindestens 640x400 nîtig !",1,"EXIT",g
  END
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------RSC LADEN---------------------------------------------
' ------------------------------------------------------------------------------
DEFMOUSE 0
'
IF compile=TRUE THEN
  lfw$=CHR$(GEMDOS(25)+65)+":"+DIR$(0)+"\"       ! funktioniert als COMPILAT !
ELSE
  lfw$="D:\"
ENDIF
s$=lfw$
IF EXIST(s$+setup$)=FALSE THEN
  IF EXIST("C:\"+setup$)=TRUE THEN
    s$="C:\"
  ENDIF
ENDIF
setup$=s$+"SMP16.SET"       ! Name des Setup-Files
arrup$=lfw$+"SMP16.ARR"     ! Name des Arrange-Files
virt2$=lfw$+"SMP16.FIX"     ! Name des Files zur Rettung von Marken/Loop/Midi/Block bei Wechsel zu virt. Bearbeitung
virt$=lfw$+"SMP16.VIR"      ! Name des virtuellen Files fÅr Backup-Zwecke (Backup des Speicherinhalts)
rsc$="SAMPLER6.RSC"         ! Name des RSC-Files
'
'
@setload
ext2$=ext$
IF ext2$="*" THEN
  ext2$="SMP"
ENDIF
virtfile$="VIRTWORK."+ext2$ ! Name des Files fÅr virtuelle Bearbeitung von StÅcken, die lÑnger als Speicherplatz sind
workfile$="WORK."+ext2$     ! Name des Files, zur Auslagerung beim öbergang mem->virt, wenn ein StÅck grîûer als Speicher wird
@rsc_init
a=@xrsrc_init
IF rsc_mtsk!=TRUE THEN
  ~MENU_REGISTER(ap_id&,"  VME_SMP16")
ENDIF
'
' cookie%=C:rsc_cookie%(L:CVL("NVDI"))          ! COOKIE-ABFRAGE
s$=lfw$
IF EXIST(s$+rsc$)=FALSE THEN
  IF EXIST("C:\"+rsc$)=TRUE THEN
    s$="C:\"
  ENDIF
ENDIF
IF @rsc_laden(s$+rsc$,24,9,-1,-1) THEN ! File$,Trees,Popup,Menu,Alert
  rscda=TRUE
  maxcol=WORK_OUT(13)
  IF maxcol=2 OR dreidim=0 THEN
    @colorbox(smp16&,mainbox6&)
    @colorbox(smp16&,mainbox&)
    @colorbox(smp16&,mainbox2&)
    @colorbox(smp16&,mainbox3&)
    @colorbox(smp16&,mainbox4&)
    @colorbox(smp16&,mainbox5&)
    @colorbox(smpedit&,editbox&)
    @colorbox(smpedit&,editbox2&)
    @colorbox(smpedit&,editbox3&)
    @colorbox(smpedit&,editbox4&)
    @colorbox(smpedit&,editbox5&)
    @colorbox(smpedit&,editbox6&)
    @colorbox(smpedit&,editbox7&)
    @colorbox(smpedit&,editbox8&)
    @colorbox(smpedit&,editbox9&)
    @colorbox(smpedit&,editbx10&)
    @colorbox(smpedit&,editbx11&)
    @colorbox(peak&,peakbox&)
    @colorbox(loop&,loopbox&)
    @colorbox(normaliz&,normbox&)
    @colorbox(resample&,resmpbox&)
    @colorbox(midiedit&,midibox&)
    @colorbox(editfade&,fadebox&)
    @colorbox(record&,recbox&)
    @colorbox(cutedit&,cutbox&)
    @colorbox(savebloc&,savebox&)
    @colorbox(arranger&,arrbox&)
    @colorbox(arranger&,arrbox2&)
    @colorbox(arranger&,arrbox3&)
    @colorbox(arranger&,arrbox4&)
    @colorbox(arranger&,arrbox5&)
    @colorbox(arranger&,arrbox6&)
    @colorbox(arranger&,arrbox7&)
    @colorbox(arranger&,arrbox8&)
    @colorbox(loadbloc&,loadbox&)
    @colorbox(setup&,setupbox&)
    @colorbox(info&,infobox&)
    @colorbox(arrmname&,arrmnbox&)
    @colorbox(dspedit&,dspbox&)
    @colorbox(delay&,delaybox&)
    @colorbox(virtual&,virtbox&)
    @colorbox(virtual&,virtbox2&)
    @colorbox(space&,spacebox&)
    @colorbox(concat&,cocatbox&)
    @colorbox(moving&,movngbox&)
    @colorbox(arrmake&,makebox&)
    @colorbox(timeed&,timebox&)
  ENDIF
ELSE
  rscda=FALSE
ENDIF
IF rscda=TRUE THEN
  @main
ENDIF
IF rscda=FALSE THEN
  ALERT 3,"RSC-File nicht gefunden !",1,"EXIT",g
  GEMSYS 109                                        ! Nur ab GEM 1.04!
  '  @rsc_exit
  @xrsrc_exit
ENDIF
IF away=TRUE THEN
  ALERT 3,"Zu wenig Speicher frei !",1,"EXIT",g
  END
ENDIF
IF acc=TRUE THEN
  GOTO ende
ELSE
  END
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------HAUPTPROGRAMM-----------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE main
  ' Weil's im Interpreter schîner aussieht, fÅr den Compiler bitte entfernen!
  '  ~FORM_DIAL(3,deskx&,desky&,deskw&,deskh&,deskx&,desky&,deskw&,deskh&)
  '
  @rsc_draw(smp16&,7)
  IF auflauf=1 THEN
    @setup
  ELSE
    @aufbau
  ENDIF
  ~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
  IF away=FALSE THEN
    IF gohome=FALSE THEN
      REPEAT
        REPEAT
          obj=@rsc_do(smp16&,0,popup&)
          ~@xrsrc_gaddr(0,smp16&,zu%)
          zuadr=zu%
          buttadr=zuadr+24*obj
          but=DPEEK(buttadr+6) AND 255
        UNTIL but<>0
        IF but=22 THEN
          IF obj=dsp& THEN
            a$=@rsc_text$(popups&,5+popup&)
            @textfeld(obj,a$,1)
            IF popup&=1 THEN
              @dspoff
            ENDIF
            IF popup&=2 THEN
              @dspin
            ENDIF
            IF popup&=3 THEN
              @dspout
            ENDIF
          ENDIF
          IF obj=rate2& THEN
            a$=@rsc_text$(popups&,9+popup&)
            @textfeld(obj,a$,1)
            IF popup&=1 THEN
              @adlow
            ENDIF
            IF popup&=2 THEN
              @admid
            ENDIF
            IF popup&=3 THEN
              @adhigh
            ENDIF
          ENDIF
          IF obj=input& THEN
            a$=@rsc_text$(popups&,13+popup&)
            @textfeld(obj,a$,1)
            IF popup&=1 THEN
              @analog
            ENDIF
            IF popup&=2 THEN
              @digital
            ENDIF
          ENDIF
          IF obj=source& THEN
            a$=@rsc_text$(popups&,16+popup&)
            @textfeld(obj,a$,1)
            IF popup&=1 THEN
              @opto
            ENDIF
            IF popup&=2 THEN
              @coax
            ENDIF
          ENDIF
        ENDIF
        IF obj=lock& THEN
          @locking
        ENDIF
        IF obj=edit& THEN
          @setbutton(edit&,32+16)
          @smpedit
        ENDIF
        IF obj=protect& THEN
          @prot
        ENDIF
        IF obj=smpauto& THEN
          @smpauto
        ENDIF
        IF obj=smpstart& THEN
          @smpstart
        ENDIF
        IF obj=play& THEN
          @play
        ENDIF
        IF obj=filesel& THEN
          @fsel
        ENDIF
        IF obj=peaksw& THEN
          @setbutton(peaksw&,32+16)
          @peak
        ENDIF
        IF obj=swdsp& THEN
          @setbutton(swdsp&,32+16)
          @dspwahl
        ENDIF
        IF obj=helporig& THEN
          @helptxt("HAUPTSEITE")
        ENDIF
        ~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
        smark=3
      UNTIL obj=exit&
    ENDIF
  ENDIF
  GEMSYS 109                                        ! Nur ab GEM 1.04!
  @rsc_exit
  @xrsrc_exit
  @exit
RETURN
' ------------------------------------------------------------------------------
' ------------------------PROZEDUREN--------------------------------------------
' ------------------------------------------------------------------------------
'                 HardwareabhÑngiger Teil - Adressenzuordnung
' ------------------------------------------------------------------------------
'
> PROCEDURE write_reglow(a)
  IF demo=FALSE THEN
    POKE adr,a
  ENDIF
RETURN
'
> PROCEDURE write_reghigh(a)
  IF demo=FALSE THEN
    POKE adr+&H40,a
  ENDIF
RETURN
'
> PROCEDURE write_dsp(a)
  IF demo=FALSE THEN
    POKE adr+&H80,a
  ENDIF
RETURN
'
> PROCEDURE write_smp(a)
  IF demo=FALSE THEN
    POKE adr+&HC0,a
  ENDIF
RETURN
'
> PROCEDURE read_statlow
  IF demo=FALSE THEN
    rwert=PEEK(adr)
    rwert=(rwert AND 15)
  ELSE
    rwert=0
  ENDIF
RETURN
'
> PROCEDURE read_statmid
  IF demo=FALSE THEN
    rwert=PEEK(adr+&H20)
    rwert=(rwert AND 7)
  ELSE
    rwert=7
  ENDIF
RETURN
'
> PROCEDURE read_stathigh
  IF demo=FALSE THEN
    rwert=PEEK(adr+&H40)
  ENDIF
RETURN
'
> PROCEDURE read_smp
  IF demo=FALSE THEN
    rwert=DPEEK(adr+&HC0-1)
  ENDIF
RETURN
'
' ------------------------------------------------------------------------------
'          HardwareabhÑngiger Teil - Datenzugriff Register Write/Read
' ------------------------------------------------------------------------------
'
> PROCEDURE digout(swert!)
  IF swert!=TRUE THEN
    sth=(sth AND 11)
    sth=sth+4
    @write_reghigh(sth)
    @analog
  ENDIF
  IF swert!=FALSE THEN
    sth=(sth AND 11)
    @write_reghigh(sth)
    @digital
  ENDIF
RETURN
'
> PROCEDURE subframe(swert!)
  IF swert!=TRUE THEN
    sth=(sth AND 7)
    sth=sth+8
    @write_reghigh(sth)
  ENDIF
  IF swert!=FALSE THEN
    sth=(sth AND 7)
    @write_reghigh(sth)
  ENDIF
RETURN
'
> PROCEDURE emphasis
  @read_statlow
  rwert=(rwert AND 4)
RETURN
'
> PROCEDURE smprate
  @read_statlow
  rwert=3 AND rwert
RETURN
'
> PROCEDURE digin
  sth=(sth AND 11)
  @write_reghigh(sth)
RETURN
'
> PROCEDURE opto
  stl=(stl AND 1)
  IF ad=0 THEN
    @write_reglow(stl)
  ELSE
    @write_reglow(stl+clk)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,17)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE dspoff
  std=(std AND 14)
  @write_dsp(std)
RETURN
'
> PROCEDURE dspin
  std=(std AND 14)
  std=std+1
  @write_dsp(stl)
RETURN
'
> PROCEDURE dspout
  std=(std AND 12)
  std=std+3
  @write_dsp(stl)
RETURN
'
> PROCEDURE coax
  stl=(stl AND 1)
  stl=stl+2
  IF ad=0 THEN
    @write_reglow(stl)
  ELSE
    @write_reglow(stl+clk)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,18)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE prot
  IF protnr=0 THEN
    sth=(sth AND 14)
    sth=sth+1
    @write_reghigh(sth)
    protnr=1
  ELSE
    sth=(sth AND 14)
    @write_reghigh(sth)
    protnr=0
  ENDIF
RETURN
'
> PROCEDURE adlow
  clk=4
  IF ad=1 THEN
    @analog
  ENDIF
RETURN
'
> PROCEDURE admid
  clk=8
  IF ad=1 THEN
    @analog
  ENDIF
RETURN
'
> PROCEDURE adhigh
  clk=12
  IF ad=1 THEN
    @analog
  ENDIF
RETURN
'
> PROCEDURE analog
  IF nr<>smpedit& OR digana=TRUE THEN
    stl=(stl AND 2)
    stl=stl+1
    @write_reglow(stl+clk)
    ad=1
    IF nr=smp16& THEN
      a$=@rsc_text$(popups&,14)
      @textfeld(input&,a$,1)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE digital
  stl=(stl AND 2)
  @write_reglow(stl)
  ad=0
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,15)
    @textfeld(input&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE makehz
  IF ad=1 THEN
    IF clk=0 THEN
      hz=44100
    ENDIF
    IF clk=4 THEN
      hz=32000
    ENDIF
    IF clk=8 THEN
      hz=44100
    ENDIF
    IF clk=12 THEN
      hz=48000
    ENDIF
  ENDIF
  IF ad=0 THEN
    IF ad=0 THEN
      @read_statlow
      hzc=3 AND rwert
    ENDIF
    IF hzc=3 THEN
      hz=32000
    ENDIF
    IF hzc=0 THEN
      hz=44100
    ENDIF
    IF hzc=2 THEN
      hz=48000
    ENDIF
  ENDIF
  IF retime=1 THEN
    hz=hzm
  ENDIF
  hz=INT(hz/100)*100
RETURN
'
' ------------------------------------------------------------------------------
' ------------------------ASSEMBLER-ROUTINEN------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE maschinit
  ' LOAD/SAVE
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0  ; von
  ' 226F0044                       movea.l   68(sp),a1  ; nach
  ' 202F0048                       move.l    72(sp),d0 ; Len
  ' D088                           add.l     a0,d0
  ' 12D8                 anf2:     move.b    (a0)+,(a1)+
  ' B1C0                           cmp.l     d0,a0
  ' 6600FFFA                       bne       anf2
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfmasch:
  DATA &H48e7,&Hfffe
  DATA &H206f,&H0040
  DATA &H226f,&H0044
  DATA &H202F,&H0048
  DATA &Hd088
  DATA &H12d8
  DATA &Hb1c0
  DATA &H6600,&Hfffa
  DATA &H4cdf,&H7fff
  DATA &H4e75
  '
  RESTORE anfmasch
  FOR g=0 TO 30 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf
  ' LOAD/SAVE
  '
  @busy_mouse
  saa%=a
  sba%=b
  ena%=l
  ~C:mdat2%(L:saa%,L:sba%,L:ena%)
RETURN
'
> PROCEDURE maschinit2
  ' PLAY
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 262F0048                       move.l    72(sp),d3 ; loop
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4879000000FE                   pea       ptr
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43F9000000F8                   lea.l     rett,a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43F9000000F0                   lea.l     neuikbd,a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 10BC0004                       move.b    #4,(a0)
  ' 7808                           moveq.l   #8,d4               ; Anzahl der Backstep
  ' 49F900000100                   lea.l     merk,a4
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                 anf0:     movea.l   a3,a2
  ' 1010                 anf1:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf2:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 660C                           bne.s     weg
  ' 95C4                           suba.l    d4,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 66C6                           bne.s     anf1
  ' 4A83                           tst.l     d3
  ' 6702                           beq.s     weg
  ' 60BE                           bra.s     anf0
  ' 4879000000FF         weg:      pea       ptr2
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43F9000000F8                   lea.l     rett,a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 33FC000100000100     neuikbd:  move.w    #1,merk
  ' 4EF9000000F8         rett:     jmp       rett
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 0000                 merk:     Dc.w 0
  '
anfbmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H262F,&H0048
  DATA &H48E7,&HFFFE
  DATA &H4879,&H0000,&H00FE
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43F9,&H0000,&H00F8
  DATA &H2368,&H0020,&H0002
  DATA &H43F9,&H0000,&H00F0
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H10BC,&H0004
  DATA &H7800
  DATA &H49F9,&H0000,&H0100
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H3014
  DATA &H660C
  DATA &H95C4
  DATA &HB5C1
  DATA &H66C6
  DATA &H4A83
  DATA &H6702
  DATA &H60BE
  DATA &H4879,&H0000,&H00FF
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43F9,&H0000,&H00F8
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H0100
  DATA &H4EF9,&H0000,&H00F8
  DATA &H1208
  DATA &H0000
  '
  RESTORE anfbmasch
  FOR g=0 TO 256 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  retanz=117    ! Stelle fuer Anzahl der Rueckspruenge bei RETPLAY
  LPOKE mdat2%+22,mdat2%+254    !ptr
  LPOKE mdat2%+196,mdat2%+255   !ptr2
  LPOKE mdat2%+120,mdat2%+256   !merk
  LPOKE mdat2%+244,mdat2%+256   !merk
  LPOKE mdat2%+88,mdat2%+240   !neuikbd
  LPOKE mdat2%+76,mdat2%+248   !rett
  LPOKE mdat2%+76,mdat2%+248   !rett
  LPOKE mdat2%+224,mdat2%+248   !rett
RETURN
'
> PROCEDURE maschruf2
  @busy_mouse
  ' PLAY
  '
  saa%=a
  sba%=b
  ena%=l
  IF demo=FALSE THEN
    ~C:mdat2%(L:saa%,L:sba%,L:ena%)
  ENDIF
RETURN
'
> PROCEDURE maschinit3
  ' RECORD
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 2A6F0048                       movea.l   72(sp),a5 ; adr
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43F900000100                   lea.l     rett,a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43F9000000F8                   lea.l     neuikbd,a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Word-adressiert !!
  ' 10BC0002                       move.b    #2,(a0)   ; REC-FIFO loeschen, SWDIGOUT=0
  ' 10BC0000                       move.b    #0,(a0)
  ' DBFC00000002                   add.l     #2,a5
  ' 284D                           move.l    a5,a4
  ' 9BFC00000002                   sub.l     #2,a5
  ' 7408                           moveq.l   #8,d2
  ' 7601                           moveq.l   #1,d3
  ' 244B                 anf0:     movea.l   a3,a2
  ' 1010                 ctrl1:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C003                           and.b     d3,d0
  ' 67FA                           beq.s     ctrl1
  ' 3E11                           move.w    (a1),d7   ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0507                           btst      d2,d7
  ' 66F2                           bne.s     anf0      ; fehlerhafte Daten ?
  ' 1010                 ctrl2:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C003                           and.b     d3,d0
  ' 67FA                           beq.s     ctrl2
  ' 3C11                           move.w    (a1),d6   ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0506                           btst      d2,d6
  ' 66E6                           bne.s     anf0      ; fehlerhafte Daten ?
  ' 1010                 ctrl3:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C003                           and.b     d3,d0
  ' 67FA                           beq.s     ctrl3
  ' 3A11                           move.w    (a1),d5   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0505                           btst      d2,d5
  ' 67DA                           beq.s     anf0      ; fehlerhafte Daten ?
  ' 1010                 ctrl4:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C003                           and.b     d3,d0
  ' 67FA                           beq.s     ctrl4
  ' 3811                           move.w    (a1),d4   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0504                           btst      d2,d4
  ' 67CE                           beq.s     anf0      ; fehlerhafte Daten ?
  ' 14C7                           move.b    d7,(a2)+
  ' 14C6                           move.b    d6,(a2)+
  ' 14C5                           move.b    d5,(a2)+
  ' 14C4                           move.b    d4,(a2)+
  ' 3014                           move.w    (a4),d0
  ' 6604                           bne.s     weg
  ' B5C1                           cmpa.l    d1,a2
  ' 66C0                           bne.s     ctrl1
  ' DBFC00000001         weg:      add.l     #1,a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43F900000100                   lea.l     rett,a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 33FC000100000108     neuikbd:  move.w    #1,merk
  ' 4EF900000100         rett:     jmp       rett
  ' 12                   ptr:      DC.b $12
  ' 08                   ptr2:     DC.b $8
  ' 0000                 merk:     DC.w 0
anfcmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H2A6F,&H0048
  DATA &H48E7,&HFFFE
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43F9,&H0000,&H0100
  DATA &H2368,&H0020,&H0002
  DATA &H43F9,&H0000,&H00F8
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H10BC,&H0002
  DATA &H10BC,&H0000
  DATA &HDBFC,&H0000,&H0002
  DATA &H284D
  DATA &H9BFC,&H0000,&H0002
  DATA &H7408
  DATA &H7601
  DATA &H244B
  DATA &H1010
  DATA &HC003
  DATA &H67FA
  DATA &H3E11
  DATA &H0507
  DATA &H66F2
  DATA &H1010
  DATA &HC003
  DATA &H67FA
  DATA &H3C11
  DATA &H0506
  DATA &H66E6
  DATA &H1010
  DATA &HC003
  DATA &H67FA
  DATA &H3A11
  DATA &H0505
  DATA &H67DA
  DATA &H1010
  DATA &HC003
  DATA &H67FA
  DATA &H3811
  DATA &H0504
  DATA &H67CE
  DATA &H14C7
  DATA &H14C6
  DATA &H14C5
  DATA &H14C4
  DATA &H3014
  DATA &H6604
  DATA &HB5C1
  DATA &H66C0
  DATA &HDBFC,&H0000,&H0001
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43F9,&H0000,&H0100
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H0108
  DATA &H4EF9,&H0000,&H0100
  DATA &H1208
  DATA &H0000
  '
  RESTORE anfcmasch
  FOR g=0 TO 264 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  LPOKE mdat2%+72,mdat2%+256    !rett
  LPOKE mdat2%+84,mdat2%+248    !neuikbd
  LPOKE mdat2%+232,mdat2%+256    !rett
  LPOKE mdat2%+252,mdat2%+264    !merk
  adk%=mdat2%+262
RETURN
'
> PROCEDURE maschruf3
  ' RECORD
  '
  @busy_mouse
  sab%=a
  enb%=a+l-4
  IF demo=FALSE THEN
    ~C:mdat2%(L:sab%,L:enb%,L:adk%)
    cached=FALSE
  ENDIF
RETURN
'
> PROCEDURE maschruf3b
  ' RECORD
  '
  IF demo=FALSE THEN
    ~C:mdat2%(L:sab%,L:enb%,L:adk%)
    cached=FALSE
  ENDIF
RETURN
'
> PROCEDURE maschinit4
  ' RECORD AUTO-WAIT
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 2E2F0040                       move.l    64(sp),d7 ; treshold
  ' 13FC000200DF0441               move.b    #2,$df0441      ; REC-FIFO loeschen
  ' 13FC000000DF0441               move.b    #0,$df0441
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 4CDF7FFF             weiter:   movem.l   (sp)+,d0-d7/a0-a6
  ' 48E77FFE             anf2:     movem.l   d1-d7/a0-a6,-(sp)
  ' 3F3C000B                       move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 660000DC                       bne       weg
  ' 323900DF04C0                   move.w    $df04c0,d1      ; auf 1 warten
  ' 08010008                       btst      #8,d1
  ' 67DA                           beq.s     anf2
  ' 323900DF04C0                   move.w    $df04c0,d1      ; wenn 0, weiter
  ' 08010008                       btst      #8,d1
  ' 66CE                           bne.s     anf2
  ' 024100FF                       andi.w    #$ff,d1
  ' E141                           asl.w     #8,d1
  ' 343900DF04C0                   move.w    $df04c0,d2      ; wenn 0, weiter
  ' 08020008                       btst      #8,d2
  ' 66BC                           bne.s     anf2
  ' 024200FF                       andi.w    #$ff,d2
  ' D242                           add.w     d2,d1
  ' 343900DF04C0                   move.w    $df04c0,d2      ; wenn 1, weiter
  ' 08020008                       btst      #8,d2
  ' 67AA                           beq.s     anf2
  ' 024200FF                       andi.w    #$ff,d2
  ' E142                           asl.w     #8,d2
  ' 363900DF04C0                   move.w    $df04c0,d3      ; wenn 1, weiter
  ' 08030008                       btst      #8,d3
  ' 6798                           beq.s     anf2
  ' 024300FF                       andi.w    #$ff,d3
  ' D443                           add.w     d3,d2
  ' 363900DF04C0                   move.w    $df04c0,d3      ; wenn 0, weiter
  ' 08030008                       btst      #8,d3
  ' 6686                           bne.s     anf2
  ' 024300FF                       andi.w    #$ff,d3
  ' E143                           asl.w     #8,d3
  ' 383900DF04C0                   move.w    $df04c0,d4      ; wenn 0, weiter
  ' 08040008                       btst      #8,d4
  ' 6600FF74                       bne       anf2
  ' 024400FF                       andi.w    #$ff,d4
  ' D644                           add.w     d4,d3
  ' 383900DF04C0                   move.w    $df04c0,d4      ; wenn 1, weiter
  ' 08040008                       btst      #8,d4
  ' 6700FF60                       beq       anf2
  ' 024400FF                       andi.w    #$ff,d4
  ' E144                           asl.w     #8,d4
  ' 3A3900DF04C0                   move.w    $df04c0,d5      ; wenn 1, weiter
  ' 08050008                       btst      #8,d5
  ' 6700FF4C                       beq       anf2
  ' 024500FF                       andi.w    #$ff,d5
  ' D845                           add.w     d5,d4
  ' 0801000F                       btst      #15,d1          ; Oberstes Bit da ?
  ' 6702                           beq.s     weiter1         ; dann negieren
  ' 4641                           not.w     d1
  ' 0802000F             weiter1:  btst      #15,d2
  ' 6702                           beq.s     weiter2
  ' 4642                           not.w     d2
  ' 0803000F             weiter2:  btst      #15,d3
  ' 6702                           beq.s     weiter3
  ' 4643                           not.w     d3
  ' 0804000F             weiter3:  btst      #15,d4
  ' 6702                           beq.s     weiter4
  ' 4644                           not.w     d4
  ' B247                 weiter4:  cmp.w     d7,d1           ; treshold vergleichen
  ' 6F00FF20                       ble       anf2
  ' B447                           cmp.w     d7,d2
  ' 6F00FF1A                       ble       anf2
  ' B647                           cmp.w     d7,d3
  ' 6F00FF14                       ble       anf2
  ' B847                           cmp.w     d7,d4
  ' 6F00FF0E                       ble       anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfdmasch:
  DATA &H48E7,&HFFFE
  DATA &H2E2F,&H0040
  DATA &H13FC,&H0002,&H00DF,&H0441
  DATA &H13FC,&H0000,&H00DF,&H0441
  DATA &H48E7,&HFFFE
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H4CDF,&H7FFE
  DATA &H0C80,&H0000,&H0000
  DATA &H6600,&H00DC
  DATA &H3239,&H00DF,&H04C0
  DATA &H0801,&H0008
  DATA &H67DA
  DATA &H3239,&H00DF,&H04C0
  DATA &H0801,&H0008
  DATA &H66CE
  DATA &H0241,&H00FF
  DATA &HE141
  DATA &H3439,&H00DF,&H04C0
  DATA &H0802,&H0008
  DATA &H66BC
  DATA &H0242,&H00FF
  DATA &HD242
  DATA &H3439,&H00DF,&H04C0
  DATA &H0802,&H0008
  DATA &H67AA
  DATA &H0242,&H00FF
  DATA &HE142
  DATA &H3639,&H00DF,&H04C0
  DATA &H0803,&H0008
  DATA &H6798
  DATA &H0243,&H00FF
  DATA &HD443
  DATA &H3639,&H00DF,&H04C0
  DATA &H0803,&H0008
  DATA &H6686
  DATA &H0243,&H00FF
  DATA &HE143
  DATA &H3839,&H00DF,&H04C0
  DATA &H0804,&H0008
  DATA &H6600,&HFF74
  DATA &H0244,&H00FF
  DATA &HD644
  DATA &H3839,&H00DF,&H04C0
  DATA &H0804,&H0008
  DATA &H6700,&HFF60
  DATA &H0244,&H00FF
  DATA &HE144
  DATA &H3A39,&H00DF,&H04C0
  DATA &H0805,&H0008
  DATA &H6700,&HFF4C
  DATA &H0245,&H00FF
  DATA &HD845
  DATA &H0801,&H000F
  DATA &H6702
  DATA &H4641
  DATA &H0802,&H000F
  DATA &H6702
  DATA &H4642
  DATA &H0803,&H000F
  DATA &H6702
  DATA &H4643
  DATA &H0804,&H000F
  DATA &H6702
  DATA &H4644
  DATA &HB247
  DATA &H6F00,&HFF20
  DATA &HB447
  DATA &H6F00,&HFF1A
  DATA &HB647
  DATA &H6F00,&HFF14
  DATA &HB847
  DATA &H6F00,&HFF0E
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfdmasch
  FOR g=0 TO 306 STEP 2
    READ a
    DPOKE mdat3%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf4
  ' RECORD AUTO-WAIT
  '
  IF demo=FALSE THEN
    ~C:mdat3%(L:tr%)
    cached=FALSE
  ENDIF
RETURN
'
> PROCEDURE maschinit5
  ' Mittelwert berechnen fÅr CURVE
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 7200                           moveq.l   #0,d1     ; zaehler pos
  ' 7800                           moveq.l   #0,d4     ; zaehler neg
  ' 7400                           moveq.l   #0,d2     ; zugriffszaehler
  ' 7600                           moveq.l   #0,d3
  ' 3610                 anf2:     move.w    (a0),d3
  ' D1FC00000004                   adda.l    #4,a0
  ' 0803000F                       btst      #15,d3
  ' 6706                           beq.s     positiv
  ' 4443                 negativ:  neg.w     d3
  ' D883                           add.l     d3,d4
  ' 6002                           bra.s     weiter
  ' D283                 positiv:  add.l     d3,d1
  ' 068200000001         weiter:   add.l     #1,d2
  ' B1C9                           cmp.l     a1,a0
  ' 6DE0                           blt.s     anf2
  ' 9284                           sub.l     d4,d1
  ' 6A16                           bpl.s     posgo
  ' 4481                           neg.l     d1
  ' 82C2                           divu.w    d2,d1
  ' 02810000FFFF                   andi.l    #$ffff,d1
  ' 2401                           move.l    d1,d2
  ' 223C00010000                   move.l    #$10000,d1
  ' 9282                           sub.l     d2,d1
  ' 6008                           bra.s     ready
  ' 82C2                 posgo:    divu.w    d2,d1
  ' 02810000FFFF                   andi.l    #$ffff,d1
  ' 45FA000A             ready:    lea.l     wert(pc),a2
  ' 3481                           move.w    d1,(a2)
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 00000000             wert:     dc.l 0
anfemasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H7200
  DATA &H7800
  DATA &H7400
  DATA &H7600
  DATA &H3610
  DATA &HD1FC,&H0000,&H0004
  DATA &H0803,&H000F
  DATA &H6706
  DATA &H4443
  DATA &HD883
  DATA &H6002
  DATA &HD283
  DATA &H0682,&H0000,&H0001
  DATA &HB1C9
  DATA &H6DE0
  DATA &H9284
  DATA &H6A16
  DATA &H4481
  DATA &H82C2
  DATA &H0281,&H0000,&HFFFF
  DATA &H2401
  DATA &H223C,&H0001,&H0000
  DATA &H9282
  DATA &H6008
  DATA &H82C2
  DATA &H0281,&H0000,&HFFFF
  DATA &H45FA,&H000A
  DATA &H3481
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H0000,&H0000
  '
  RESTORE anfemasch
  FOR g=0 TO 100 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf5
  ' MITTELWERT
  '
  IF virtual=FALSE THEN
    sac%=i
    sbc%=i+stp
  ELSE
    sac%=i-vcs
    sbc%=(i+stp)-vcs
  ENDIF
  ~C:mdat2%(L:sac%,L:sbc%)
  a=DPEEK(mdat2%+98)
RETURN
'
> PROCEDURE maschruf5x
  ' MITTELWERT
  '
  LOCAL j,n,z1,z2,k
  z1=0
  z2=0
  FOR j=i TO i+stp-4 STEP 4
    n=DPEEK(j)
    IF n<32768 THEN
      z1=z1+n
    ELSE
      n=65535-n
      n=NOT (n)
      z2=z2+n
    ENDIF
    INC k
  NEXT j
  a=(z1+z2)/k
  a=65536+a
RETURN
'
> PROCEDURE maschinit6
  ' PEAKMETER
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 41FA01F6                       lea.l     wert(pc),a0
  ' 20EF0040                       move.l    64(sp),(a0)+
  ' 20EF0044                       move.l    68(sp),(a0)+
  ' 20EF0048                       move.l    72(sp),(a0)+
  ' 20EF004C                       move.l    76(sp),(a0)+
  ' 20EF0050                       move.l    80(sp),(a0)+
  ' 20EF0054                       move.l    84(sp),(a0)+
  ' 20EF0058                       move.l    88(sp),(a0)+
  ' 20EF005C                       move.l    92(sp),(a0)+
  ' 20EF0060                       move.l    96(sp),(a0)+
  ' 20EF0064                       move.l    100(sp),(a0)+
  ' 20EF0068                       move.l    104(sp),(a0)+
  ' 20EF006C                       move.l    108(sp),(a0)+
  ' 20EF0070                       move.l    112(sp),(a0)+
  ' 20EF0074                       move.l    116(sp),(a0)+
  ' 20EF0078                       move.l    120(sp),(a0)+
  ' 20EF007C                       move.l    124(sp),(a0)+
  ' 20EF0080                       move.l    128(sp),(a0)+
  ' 20EF0084                       move.l    132(sp),(a0)+
  ' 20EF0088                       move.l    136(sp),(a0)+
  ' 20AF008C                       move.l    140(sp),(a0)
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA019C                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA0160                       lea.l     rett(pc),a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43FA014E                       lea.l     neuikbd(pc),a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41FA0152                       lea.l     wert(pc),a0
  ' 49FA019E                       lea.l     merk(pc),a4
  ' 4DF900DF0441                   lea.l     $df0441,a6
  ' 7A01                           moveq.l   #1,d5
  ' 303900DF04C0         anf:      move.w    $df04c0,d0
  ' 08000008                       btst      #8,d0
  ' 6700FFF4                       beq       anf
  ' 1016                 anf2:     move.b    (a6),d0   ; Daten gÅltig ?
  ' C005                           and.b     d5,d0
  ' 670000DA                       beq       test
  ' 323900DF04C0                   move.w    $df04c0,d1
  ' 08010008                       btst      #8,d1
  ' 6600FFEC                       bne       anf2
  ' 1016                 ctrl1:    move.b    (a6),d0   ; Daten gÅltig ?
  ' C005                           and.b     d5,d0
  ' 670000C4                       beq       test
  ' 343900DF04C0                   move.w    $df04c0,d2
  ' 08020008                       btst      #8,d2
  ' 6600FFD6                       bne       anf2
  ' 1016                 anf3:     move.b    (a6),d0   ; Daten gÅltig ?
  ' C005                           and.b     d5,d0
  ' 670000AE                       beq       test
  ' 363900DF04C0                   move.w    $df04c0,d3
  ' 08030008                       btst      #8,d3
  ' 6700FFEC                       beq       anf3
  ' 1016                 ctrl2:    move.b    (a6),d0   ; Daten gÅltig ?
  ' C005                           and.b     d5,d0
  ' 67000098                       beq       test
  ' 383900DF04C0                   move.w    $df04c0,d4
  ' 08040008                       btst      #8,d4
  ' 6700FFD6                       beq       anf3
  ' 024100FF                       and.w     #$ff,d1
  ' E141                           asl.w     #8,d1
  ' 024200FF                       and.w     #$ff,d2
  ' D242                           add.w     d2,d1
  ' 024300FF                       and.w     #$ff,d3
  ' E143                           asl.w     #8,d3
  ' 024400FF                       and.w     #$ff,d4
  ' D644                           add.w     d4,d3
  ' 0801000F                       btst      #15,d1
  ' 6702                           beq.s     anf4
  ' 4641                           not.w     d1
  ' 0803000F             anf4:     btst      #15,d3
  ' 6702                           beq.s     anf5
  ' 4643                           not.w     d3
  ' C2FC000A             anf5:     mulu.w    #10,d1
  ' C6FC000A                       mulu.w    #10,d3
  ' 82FC7FFF                       divu.w    #32767,d1
  ' 86FC7FFF                       divu.w    #32767,d3
  ' 7C00                           moveq.l   #0,d6
  ' 7E00                           moveq.l   #0,d7
  ' 22706000             anfrs:    movea.l   0(a0,d6.w),a1
  ' B207                           cmp.b     d7,d1
  ' 6E06                           bgt.s     anfrs2
  ' 32BC0000                       move.w    #0,(a1)
  ' 6004                           bra.s     anfrs3
  ' 32BC0001             anfrs2:   move.w    #1,(a1)
  ' 5886                 anfrs3:   addq.l    #4,d6
  ' 5287                           addq.l    #1,d7
  ' BE3C000A                       cmp.b     #10,d7
  ' 66E4                           bne.s     anfrs
  ' 7E00                           moveq.l   #0,d7
  ' 22706000             anfls:    movea.l   0(a0,d6.w),a1
  ' B607                           cmp.b     d7,d3
  ' 6E06                           bgt.s     anfls2
  ' 32BC0000                       move.w    #0,(a1)
  ' 6004                           bra.s     anfls3
  ' 32BC0001             anfls2:   move.w    #1,(a1)
  ' 5886                 anfls3:   addq.l    #4,d6
  ' 5287                           addq.l    #1,d7
  ' BE3C000A                       cmp.b     #10,d7
  ' 66E4                           bne.s     anfls
  ' B23C000A                       cmp.b     #10,d1
  ' 6708                           beq.s     nixw1
  ' B63C000A                       cmp.b     #10,d3
  ' 6702                           beq.s     nixw1
  ' 6004                           bra.s     test
  ' 61000036             nixw1:    bsr       pause
  ' 3014                 test:     move.w    (a4),d0
  ' 6604                           bne.s     weg
  ' 6000FF1A                       bra       anf2
  ' 4BFA004B             weg:      lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA0028                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 3C3CFFFF             pause:    move.w    #-1,d6
  ' 3E3CFFFF             pause2:   move.w    #-1,d7
  ' 51CFFFFE             pause3:   dbra      d7,pause3
  ' 51CEFFF6                       dbra      d6,pause2
  ' 4E75                           rts
  ' 33FC00010000024C     neuikbd:  move.w    #1,merk
  ' 4EF9000001F4         rett:     jmp       rett
  ' 12                   ptr:      DC.b $12
  ' 08                   ptr2:     DC.b $8
  ' 00000000             wert:     ds.l 20
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 00000000
  ' 0000                 merk:     DC.w 0
anffmasch:
  '
  DATA &H48E7,&HFFFE
  DATA &H41FA,&H01F6
  DATA &H20EF,&H0040
  DATA &H20EF,&H0044
  DATA &H20EF,&H0048
  DATA &H20EF,&H004C
  DATA &H20EF,&H0050
  DATA &H20EF,&H0054
  DATA &H20EF,&H0058
  DATA &H20EF,&H005C
  DATA &H20EF,&H0060
  DATA &H20EF,&H0064
  DATA &H20EF,&H0068
  DATA &H20EF,&H006C
  DATA &H20EF,&H0070
  DATA &H20EF,&H0074
  DATA &H20EF,&H0078
  DATA &H20EF,&H007C
  DATA &H20EF,&H0080
  DATA &H20EF,&H0084
  DATA &H20EF,&H0088
  DATA &H20AF,&H008C
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H019C
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H0160
  DATA &H2368,&H0020,&H0002
  DATA &H43FA,&H014E
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H41FA,&H0152
  DATA &H49FA,&H019E
  DATA &H4DF9,&H00DF,&H0441
  DATA &H7A01
  DATA &H3039,&H00DF,&H04C0
  DATA &H0800,&H0008
  DATA &H6700,&HFFF4
  DATA &H1016
  DATA &HC005
  DATA &H6700,&H00DA
  DATA &H3239,&H00DF,&H04C0
  DATA &H0801,&H0008
  DATA &H6600,&HFFEC
  DATA &H1016
  DATA &HC005
  DATA &H6700,&H00C4
  DATA &H3439,&H00DF,&H04C0
  DATA &H0802,&H0008
  DATA &H6600,&HFFD6
  DATA &H1016
  DATA &HC005
  DATA &H6700,&H00AE
  DATA &H3639,&H00DF,&H04C0
  DATA &H0803,&H0008
  DATA &H6700,&HFFEC
  DATA &H1016
  DATA &HC005
  DATA &H6700,&H0098
  DATA &H3839,&H00DF,&H04C0
  DATA &H0804,&H0008
  DATA &H6700,&HFFD6
  DATA &H0241,&H00FF
  DATA &HE141
  DATA &H0242,&H00FF
  DATA &HD242
  DATA &H0243,&H00FF
  DATA &HE143
  DATA &H0244,&H00FF
  DATA &HD644
  DATA &H0801,&H000F
  DATA &H6702
  DATA &H4641
  DATA &H0803,&H000F
  DATA &H6702
  DATA &H4643
  DATA &HC2FC,&H000A
  DATA &HC6FC,&H000A
  DATA &H82FC,&H7FFF
  DATA &H86FC,&H7FFF
  DATA &H7C00
  DATA &H7E00
  DATA &H2270,&H6000
  DATA &HB207
  DATA &H6E06
  DATA &H32BC,&H0000
  DATA &H6004
  DATA &H32BC,&H0001
  DATA &H5886
  DATA &H5287
  DATA &HBE3C,&H000A
  DATA &H66E4
  DATA &H7E00
  DATA &H2270,&H6000
  DATA &HB607
  DATA &H6E06
  DATA &H32BC,&H0000
  DATA &H6004
  DATA &H32BC,&H0001
  DATA &H5886
  DATA &H5287
  DATA &HBE3C,&H000A
  DATA &H66E4
  DATA &HB23C,&H000A
  DATA &H6708
  DATA &HB63C,&H000A
  DATA &H6702
  DATA &H6004
  DATA &H6100,&H0036
  DATA &H3014
  DATA &H6604
  '  DATA &H6000,&HFF1A
  '
  DATA &H0803,&H0008
  '
  DATA &H4BFA,&H004B
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H0028
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H3C3C,&HFFFF
  DATA &H3E3C,&HFFFF
  DATA &H51CF,&HFFFE
  DATA &H51CE,&HFFF6
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H024C
  DATA &H4EF9,&H0000,&H01F4
  DATA &H1208
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000,&H0000
  DATA &H0000
  RESTORE anffmasch
  FOR g=0 TO 588 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  LPOKE mdat2%+496,mdat2%+588    !merk
RETURN
'
> PROCEDURE maschruf6
  ' PEAKMETER
  '
  IF demo=FALSE THEN
    ~C:mdat2%(L:sr1%,L:sr2%,L:sr3%,L:sr4%,L:sr5%,L:sr6%,L:sr7%,L:sr8%,L:sr9%,L:sr10%,L:sl1%,L:sl2%,L:sl3%,L:sl4%,L:sl5%,L:sl6%,L:sl7%,L:sl8%,L:sl9%,L:sl10%)
  ENDIF
RETURN
'
> PROCEDURE maschinit7
  ' HARDDISK-PLAY
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       movea.l   68(sp),a6  ; fname
  ' 242F0048                       move.l    72(sp),d2 ; sectors
  ' 2A2F004C                       move.l    76(sp),d5 ; len
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA014A                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 4BFA010E                       lea.l     rett(pc),a5
  ' 2B6800200002                   move.l    32(a0),2(a5)
  ' 4BFA00FC                       lea.l     neuikbd(pc),a5
  ' 214D0020                       move.l    a5,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FEFE                       movem.l   d0-d6/a0-a6,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)  ; Fopen
  ' 2F0E                           move.l    a6,-(sp)
  ' 3F3C003D                       move.w    #61,-(sp)
  ' 4E41                           trap      #1
  ' 508F                           addq.l    #8,sp
  ' 3E00                           move.w    d0,d7
  ' 4CDF7F7F                       movem.l   (sp)+,d0-d6/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0          ; Flagstatus
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 49FA00DC                       lea.l     merk(pc),a4
  ' 220B                           move.l    a3,d1     ; MEMende
  ' D285                           add.l     d5,d1
  ' 7C00                           moveq.l   #0,d6
  ' 10BC0004                       move.b    #4,(a0)   ; DIGOUT setzen
  ' 7804                           moveq.l   #4,d4
  ' 7608                           moveq.l   #8,d3
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                           movea.l   a3,a2
  ' 48E7FFF8                       movem.l   d0-d7/a0-a4,-(sp)
  ' 2F0B                           move.l    a3,-(sp)  ; Fread
  ' 2F05                           move.l    d5,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF1FFF                       movem.l   (sp)+,d0-d7/a0-a4
  ' 1010                           move.b    (a0),d0   ; FIFO halbleer ?
  ' 02000008                       andi.b    #8,d0
  ' 6724                           beq.s     anf2
  ' 2F01                           move.l    d1,-(sp)
  ' 303C03FF                       move.w    #$3ff,d0     ; ...dann FIFO halb-fuellen (FIFO-LEN/2/4-1)!
  ' 121A                 copy:     move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 51C8FFE6                       dbra      d0,copy
  ' 221F                           move.l    (sp)+,d1
  ' 1010                 anf2:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf2
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf3
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf4
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf5:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf5
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 660A                           bne.s     weg
  ' B5C1                           cmpa.l    d1,a2
  ' 66C8                           bne.s     anf2
  ' BC82                           cmp.l     d2,d6
  ' 6600FF7C                       bne       anf
  ' 3F07                 weg:      move.w    d7,-(sp)  ; Fclose
  ' 3F3C003E                       move.w    #62,-(sp)
  ' 4E41                           trap      #1
  ' 588F                           addq.l    #4,sp
  ' 4BFA0039                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA0016                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 33FC000100000166     neuikbd:  move.w    #1,merk
  ' 4EF90000015E         rett:     jmp       rett
  ' 12                   ptr:      DC.b $12
  ' 08                   ptr2:     DC.b $8
  ' 0000                 merk:     DC.w 0
anfgmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H242F,&H0048
  DATA &H2A2F,&H004C
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H014A
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H4BFA,&H010E
  DATA &H2B68,&H0020,&H0002
  DATA &H4BFA,&H00FC
  DATA &H214D,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFEFE
  DATA &H3F3C,&H0000
  DATA &H2F0E
  DATA &H3F3C,&H003D
  DATA &H4E41
  DATA &H508F
  DATA &H3E00
  DATA &H4CDF,&H7F7F
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H49FA,&H00DC
  DATA &H220B
  DATA &HD285
  DATA &H7C00
  DATA &H10BC,&H0004
  DATA &H7804
  DATA &H7608
  DATA &H5286
  DATA &H244B
  DATA &H48E7,&HFFF8
  DATA &H2F0B
  DATA &H2F05
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H1FFF
  DATA &H1010
  DATA &H0200,&H0008
  DATA &H6724
  DATA &H2F01
  DATA &H303C,&H03FF
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H51C8,&HFFE6
  DATA &H221F
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H3014
  DATA &H660A
  DATA &HB5C1
  DATA &H66C8
  DATA &HBC82
  DATA &H6600,&HFF7C
  DATA &H3F07
  DATA &H3F3C,&H003E
  DATA &H4E41
  DATA &H588F
  DATA &H4BFA,&H0039
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H0016
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H0166
  DATA &H4EF9,&H0000,&H015E
  DATA &H1208
  DATA &H0000
  '
  RESTORE anfgmasch
  FOR g=0 TO 358 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  LPOKE mdat2%+346,mdat2%+358    !merk
  fifofill=playfifolen/8-1
  DPOKE mdat2%+194,fifofill
RETURN
'
> PROCEDURE maschruf7
  ' HARDDISK-PLAY
  '
  @busy_mouse
  sbd%=VARPTR(pa$)        !Pfad
  scd%=sectors            !sectors
  sdd%=flen               !len
  IF demo=FALSE THEN
    ~C:mdat2%(L:mdat%,L:sbd%,L:scd%,L:sdd%)
  ENDIF
  CLOSE
RETURN
'
> PROCEDURE maschinit8
  ' HARDDISK-RECORD
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       movea.l   68(sp),a6  ; fname
  ' 2A2F0048                       move.l    72(sp),d5 ; sectors
  ' 282F004C                       move.l    76(sp),d4 ; len
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA0148                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 4BFA010C                       lea.l     rett(pc),a5
  ' 2B6800200002                   move.l    32(a0),2(a5)
  ' 4BFA00FA                       lea.l     neuikbd(pc),a5
  ' 214D0020                       move.l    a5,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FEFE                       movem.l   d0-d6/a0-a6,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)  ; Fcreate
  ' 2F0E                           move.l    a6,-(sp)
  ' 3F3C003C                       move.w    #60,-(sp)
  ' 4E41                           trap      #1
  ' 508F                           addq.l    #8,sp
  ' 3E00                           move.w    d0,d7
  ' 4CDF7F7F                       movem.l   (sp)+,d0-d6/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0          ; Flagstatus
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 49FA00DA                       lea.l     merk(pc),a4
  ' 220B                           move.l    a3,d1         ; MEMende
  ' D284                           add.l     d4,d1
  ' 7401                           moveq.l   #1,d2
  ' 7608                           moveq.l   #8,d3
  ' 10BC0002                       move.b    #2,(a0)   ; REC-FIFO lîschen, SWDIGOUT=0
  ' 10BC0000                       move.b    #0,(a0)
  ' 7C00                           moveq.l   #0,d6
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                 anf1:     movea.l   a3,a2
  ' 1010                 ctrl1:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl1
  ' 3011                           move.w    (a1),d0   ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0700                           btst      d3,d0
  ' 66F4                           bne.s     ctrl1      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl2:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl2
  ' 3011                           move.w    (a1),d0   ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0700                           btst      d3,d0
  ' 66F4                           bne.s     ctrl2      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl3:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl3
  ' 3011                           move.w    (a1),d0   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0700                           btst      d3,d0
  ' 67F4                           beq.s     ctrl3      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl4:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl4
  ' 3011                           move.w    (a1),d0   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0700                           btst      d3,d0
  ' 67F4                           beq.s     ctrl4      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' B5C1                           cmpa.l    d1,a2
  ' 66C4                           bne.s     ctrl1
  ' 48E77FF8                       movem.l   d1-d7/a0-a4,-(sp)
  ' 2F0B                           move.l    a3,-(sp)  ; Fwrite
  ' 2F04                           move.l    d4,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C0040                       move.w    #64,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 6B26                           bmi.s     weg
  ' B880                           cmp.l     d0,d4
  ' 6622                           bne.s     weg
  ' 3014                           move.w    (a4),d0
  ' 661E                           bne.s     weg
  ' 1010                           move.b    (a0),d0   ; Flag lesen
  ' 02000002                       andi.b    #2,d0     ; FIFO mehr als halbvoll ?
  ' 6612                           bne.s     nocopy    ; wenn nein, normal weiter
  ' 244B                           movea.l   a3,a2
  ' 5286                           addq.l    #1,d6
  ' 303C0FFF             copy:     move.w    #$0fff,d0 ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
  ' 14E90001             copy2:    move.b    1(a1),(a2)+   ; FIFO auslesen
  ' 51C8FFFA                       dbra      d0,copy2
  ' 6088                           bra.s     ctrl1
  ' BC85                 nocopy:   cmp.l     d5,d6
  ' 6680                           bne.s     anf
  ' 3F07                 weg:      move.w    d7,-(sp)  ; Fclose
  ' 3F3C003E                       move.w    #62,-(sp)
  ' 4E41                           trap      #1
  ' 588F                           addq.l    #4,sp
  ' 4BFA0039                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA0016                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 33FC000100000164     neuikbd:  move.w    #1,merk
  ' 4EF90000015C         rett:     jmp       rett
  ' 12                   ptr:      DC.b $12
  ' 08                   ptr2:     DC.b $8
  ' 0000                 merk:     DC.w 0
anfhmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H2A2F,&H0048
  DATA &H282F,&H004C
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H0148
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H4BFA,&H010C
  DATA &H2B68,&H0020,&H0002
  DATA &H4BFA,&H00FA
  DATA &H214D,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFEFE
  DATA &H3F3C,&H0000
  DATA &H2F0E
  DATA &H3F3C,&H003C
  DATA &H4E41
  DATA &H508F
  DATA &H3E00
  DATA &H4CDF,&H7F7F
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H49FA,&H00DA
  DATA &H220B
  DATA &HD284
  DATA &H7401
  DATA &H7608
  DATA &H10BC,&H0002
  DATA &H10BC,&H0000
  DATA &H7C00
  DATA &H5286
  DATA &H244B
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H66F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H66F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H67F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H67F4
  DATA &H14C0
  DATA &HB5C1
  DATA &H66C4
  DATA &H48E7,&H7FF8
  DATA &H2F0B
  DATA &H2F04
  DATA &H3F07
  DATA &H3F3C,&H0040
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H1FFE
  DATA &H6B26
  DATA &HB880
  DATA &H6622
  DATA &H3014
  DATA &H661E
  DATA &H1010
  DATA &H0200,&H0002
  DATA &H6612
  DATA &H244B
  DATA &H5286
  DATA &H303C,&H0FFF
  DATA &H14E9,&H0001
  DATA &H51C8,&HFFFA
  DATA &H6088
  DATA &HBC85
  DATA &H6680
  DATA &H3F07
  DATA &H3F3C,&H003E
  DATA &H4E41
  DATA &H588F
  DATA &H4BFA,&H0039
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H0016
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H0164
  DATA &H4EF9,&H0000,&H015C
  DATA &H1208
  DATA &H0000
  '
  RESTORE anfhmasch
  FOR g=0 TO 356 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  LPOKE mdat2%+344,mdat2%+356    !merk
  fifofill=recfifolen/2-1
  DPOKE mdat2%+270,fifofill
RETURN
'
> PROCEDURE maschruf8
  ' HARDDISK-RECORD
  '
  @busy_mouse
  sbe%=VARPTR(pa$)        !Pfad
  sce%=sectors            !sectors
  sde%=flen               !len
  IF demo=FALSE THEN
    ~C:mdat2%(L:mdat%,L:sbe%,L:sce%,L:sde%)
  ENDIF
RETURN
'
> PROCEDURE maschinit9
  ' CUT
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 7000                           moveq.l   #0,d0
  ' 20C0                 anf2:     move.l    d0,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DFA                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfimasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H7000
  DATA &H20C0
  DATA &HB1C9
  DATA &H6DFA
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfimasch
  FOR g=0 TO 24 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf9(ca,cb)
  ' CUT
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  ~C:mdat2%(L:cfa%,L:cfb%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit10
  ' COPY
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 246F0048                       movea.l   72(sp),a2 ; dest
  ' 266F004C                       movea.l   76(sp),a3 ; grenzwert
  ' 24D8                 anf2:     move.l    (a0)+,(a2)+
  ' B1C9                           cmp.l     a1,a0
  ' 6C04                           bge.s     weg
  ' B5CB                           cmp.l     a3,a2
  ' 6DF6                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfjmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H266F,&H004C
  DATA &H24D8
  DATA &HB1C9
  DATA &H6C04
  DATA &HB5CB
  DATA &H6DF6
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfjmasch
  FOR g=0 TO 34 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf10(ca,cb,cc,cd)
  ' COPY
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  cfc%=cc
  cfd%=cd
  ~C:mdat2%(L:cfa%,L:cfb%,L:cfc%,L:cfd%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit11
  ' BACK-COPY
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; ende
  ' 226F0044                       movea.l   68(sp),a1 ; anf
  ' 246F0048                       movea.l   72(sp),a2 ; destende
  ' 2520                 anf2:     move.l    -(a0),-(a2)
  ' B1C9                           cmp.l     a1,a0
  ' 6EFA                           bgt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfkmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H2520
  DATA &HB1C9
  DATA &H6EFA
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfkmasch
  FOR g=0 TO 26 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf11(ca,cb,cc)
  ' BACK-COPY
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  cfc%=cc
  ~C:mdat2%(L:cfa%,L:cfb%,L:cfc%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit12
  ' PEAK-SUCH
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 246F0048                       movea.l   72(sp),a2 ; Returnwert
  ' 7000                           moveq.l   #0,d0
  ' 3218                 anf2:     move.w    (a0)+,d1
  ' 0801000F                       btst      #15,d1
  ' 6702                           beq.s     noneg
  ' 4641                           not.w     d1
  ' B240                 noneg:    cmp.w     d0,d1
  ' 6D02                           blt.s     noadd
  ' 3001                           move.w    d1,d0
  ' B1C9                 noadd:    cmp.l     a1,a0
  ' 6DEC                           blt.s     anf2
  ' 2480                           move.l    d0,(a2)
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anflmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H7000
  DATA &H3218
  DATA &H0801,&H000F
  DATA &H6702
  DATA &H4641
  DATA &HB240
  DATA &H6D02
  DATA &H3001
  DATA &HB1C9
  DATA &H6DEC
  DATA &H2480
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anflmasch
  FOR g=0 TO 44 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf12(ca,cb)
  ' PEAK-SUCH
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  back%=0
  cfc%=VARPTR(back%)
  ~C:mdat2%(L:cfa%,L:cfb%,L:cfc%)
RETURN
'
> PROCEDURE maschinit13
  ' NORMALIZE
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 202F0048                       move.l    72(sp),d0 ; grenz
  ' 222F004C                       move.l    76(sp),d1 ; back%
  ' 7400                 anf2:     moveq.l   #0,d2
  ' 163C0000                       move.b    #0,d3
  ' 3410                           move.w    (a0),d2
  ' 0802000F                       btst      #15,d2
  ' 6714                           beq.s     noneg
  ' 4642                           not.w     d2
  ' C4C0                           mulu.w    d0,d2
  ' 84C1                           divu.w    d1,d2
  ' 4642                           not.w     d2
  ' 30C2                           move.w    d2,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DE4                           blt.s     anf2
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' C4C0                 noneg:    mulu.w    d0,d2
  ' 84C1                           divu.w    d1,d2
  ' 30C2                           move.w    d2,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DD4                           blt.s     anf2
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfmmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H202F,&H0048
  DATA &H222F,&H004C
  DATA &H7400
  DATA &H163C,&H0000
  DATA &H3410
  DATA &H0802,&H000F
  DATA &H6714
  DATA &H4642
  DATA &HC4C0
  DATA &H84C1
  DATA &H4642
  DATA &H30C2
  DATA &HB1C9
  DATA &H6DE4
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &HC4C0
  DATA &H84C1
  DATA &H30C2
  DATA &HB1C9
  DATA &H6DD4
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfmmasch
  FOR g=0 TO 68 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf13(ca,cb,cc,cd)
  ' NORMALIZE
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  cfc%=cc
  cfd%=cd
  ~C:mdat2%(L:cfa%,L:cfb%,L:cfc%,L:cfd%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit14
  ' FIFO-DEL
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 202F0040                       move.l    64(sp),d0 ; adr
  ' 43F900DF04C0                   lea.l     $df04c0,a1
  ' 3211                 loop:     move.w    (a1),d1
  ' 51C8FFFC                       dbra      d0,loop
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfnmasch:
  DATA &H48E7,&HFFFE
  DATA &H202F,&H0040
  DATA &H43F9,&H00DF,&H04C0
  DATA &H3211
  DATA &H51C8,&HFFFC
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfnmasch
  FOR g=0 TO 24 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf14(ca)
  ' FIFO-DEL
  '
  cfa%=ca
  IF demo=FALSE THEN
    ~C:mdat2%(L:cfa%)
  ENDIF
RETURN
'
> PROCEDURE maschinit15
  ' CROSSPLAY
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 262F0048                       move.l    72(sp),d3 ; loop
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA0144                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA011A                       lea.l     rett(pc),a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43FA0108                       lea.l     neuikbd(pc),a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF             anf0:     movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 10BC0004                       move.b    #4,(a0)
  ' 49FA00E6                       lea.l     merk(pc),a4
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                           movea.l   a3,a2
  ' 1010                 anf1:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf2:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 6678                           bne.s     weg
  ' B5C1                           cmpa.l    d1,a2
  ' 66C8                           bne.s     anf1
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 2401                           move.l    d1,d2
  ' 220B                           move.l    a3,d1
  ' 068100000004                   add.l     #4,d1
  ' 2642                           move.l    d2,a3
  ' 97FC00000004                   suba.l    #4,a3
  ' 7808                           moveq.l   #4,d4
  ' 49FA007C                       lea.l     merk(pc),a4
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                           movea.l   a3,a2
  ' 1010                 anfb1:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anfb2:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anfb3:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anfb4:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 660E                           bne.s     weg
  ' 95C4                           suba.l    d4,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 66C6                           bne.s     anfb1
  ' 4A83                           tst.l     d3
  ' 6704                           beq.s     weg
  ' 6000FF34                       bra       anf0
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4BFA002B                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA001A                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 0000                 merk:     Dc.w 0
  ' 33FC00010000015C     neuikbd:  move.w    #1,merk
  ' 4EF900000166         rett:     jmp       rett
  '
anfomasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H262F,&H0048
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H0144
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H011A
  DATA &H2368,&H0020,&H0002
  DATA &H43FA,&H0108
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFFFE
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H10BC,&H0004
  DATA &H49FA,&H00E6
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H3014
  DATA &H6678
  DATA &HB5C1
  DATA &H66C8
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFFFE
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H2401
  DATA &H220B
  DATA &H0681,&H0000,&H0004
  DATA &H2642
  DATA &H97FC,&H0000,&H0004
  DATA &H7808
  DATA &H49FA,&H007C
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H3014
  DATA &H660E
  DATA &H95C4
  DATA &HB5C1
  DATA &H66C6
  DATA &H4A83
  DATA &H6704
  DATA &H6000,&HFF34
  DATA &H4CDF,&H7FFF
  DATA &H4BFA,&H002B
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H001A
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H1208
  DATA &H0000
  DATA &H33FC,&H0001,&H0000,&H015C
  DATA &H4EF9,&H0000,&H0166
  '
  RESTORE anfomasch
  FOR g=0 TO 362 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  LPOKE mdat2%+354,mdat2%+348   !merk
RETURN
'
> PROCEDURE maschruf15
  ' CROSSPLAY
  '
  @busy_mouse
  saa%=a
  sba%=b
  ena%=l
  IF demo=FALSE THEN
    ~C:mdat2%(L:saa%,L:sba%,L:ena%)
  ENDIF
RETURN
'
> PROCEDURE maschinit16
  ' RESAMPLE
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; sourceanf
  ' 226F0044                       movea.l   68(sp),a1 ; sourceende
  ' 246F0048                       movea.l   72(sp),a2 ; destanf
  ' 266F004C                       movea.l   76(sp),a3 ; destende
  ' 262F0050                       move.l    80(sp),d3 ; source-sample-rate (320,441,480)
  ' 282F0054                       move.l    84(sp),d4 ; dest-sample-rate (320,441,480)
  ' 286F0058                       move.l    88(sp),a4 ; destende-RETURN-Wert
  ' 2A03                           move.l    d3,d5
  ' 9A84                           sub.l     d4,d5
  ' 7200                           moveq.l   #0,d1
  ' 2403                           move.l    d3,d2
  ' 84C4                           divu      d4,d2
  ' 0C8200000001                   cmpi.l    #1,d2
  ' 6712                           beq.s     abzanf
  ' 02820000FFFF                   andi.l    #$ffff,d2
  ' 0C420000                       cmpi.w    #0,d2
  ' 6740                           beq.s     dazuanf
  ' 0C420002                       cmpi.w    #2,d2
  ' 6D20                           blt.s     abzanf2
  ' 24D0                 abzanf:   move.l    (a0),(a2)+
  ' D283                           add.l     d3,d1
  ' 2401                           move.l    d1,d2
  ' 84C4                           divu      d4,d2
  ' 02820000FFFF                   andi.l    #$ffff,d2
  ' 2E02                           move.l    d2,d7
  ' CEFC0004                       mulu      #4,d7
  ' C4C4                           mulu      d4,d2
  ' 9282                           sub.l     d2,d1
  ' D1C7                           adda.l    d7,a0
  ' B1C9                           cmpa.l    a1,a0
  ' 6DE2                           blt.s     abzanf
  ' 6066                           bra.s     ende
  ' 2A03                 abzanf2:  move.l    d3,d5
  ' 9A84                           sub.l     d4,d5
  ' 2018                 abzanf3:  move.l    (a0)+,d0
  ' D285                           add.l     d5,d1
  ' 2401                           move.l    d1,d2
  ' 9483                           sub.l     d3,d2
  ' 6B04                           bmi.s     noabz2
  ' 2202                           move.l    d2,d1
  ' 6002                           bra.s     abztest2
  ' 24C0                 noabz2:   move.l    d0,(a2)+
  ' B1C9                 abztest2: cmpa.l    a1,a0
  ' 6DEC                           blt.s     abzanf3
  ' 604C                           bra.s     ende
  ' 2404                 dazuanf:  move.l    d4,d2
  ' 84C3                           divu      d3,d2
  ' 0C420002                       cmpi.w    #2,d2
  ' 6C1E                           bge.s     dazuanf4
  ' 2A04                           move.l    d4,d5
  ' 9A83                           sub.l     d3,d5
  ' 2018                 dazuanf2: move.l    (a0)+,d0
  ' D285                           add.l     d5,d1
  ' 2401                           move.l    d1,d2
  ' 9483                           sub.l     d3,d2
  ' 6B04                           bmi.s     dazuanf3
  ' 2202                           move.l    d2,d1
  ' 24C0                           move.l    d0,(a2)+
  ' 24C0                 dazuanf3: move.l    d0,(a2)+
  ' B5CB                           cmpa.l    a3,a2
  ' 6C2A                           bge.s     ende
  ' B1C9                           cmpa.l    a1,a0
  ' 6DE8                           blt.s     dazuanf2
  ' 6024                           bra.s     ende
  ' 2018                 dazuanf4: move.l    (a0)+,d0
  ' D284                           add.l     d4,d1
  ' 2401                           move.l    d1,d2
  ' 84C3                           divu      d3,d2
  ' 02820000FFFF                   andi.l    #$ffff,d2
  ' 2E02                           move.l    d2,d7
  ' C4C3                           mulu      d3,d2
  ' 9282                           sub.l     d2,d1
  ' 5387                           subq.l    #1,d7
  ' 24C0                 dazuanf5: move.l    d0,(a2)+
  ' B5CB                           cmp.l     a3,a2
  ' 6C08                           bge.s     ende
  ' 51CFFFF8                       dbra      d7,dazuanf5
  ' B1C9                           cmpa.l    a1,a0
  ' 6DDC                           blt.s     dazuanf4
  ' 288A                 ende:     move.l    a2,(a4)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfpmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H266F,&H004C
  DATA &H262F,&H0050
  DATA &H282F,&H0054
  DATA &H286F,&H0058
  DATA &H2A03
  DATA &H9A84
  DATA &H7200
  DATA &H2403
  DATA &H84C4
  DATA &H0C82,&H0000,&H0001
  DATA &H6712
  DATA &H0282,&H0000,&HFFFF
  DATA &H0C42,&H0000
  DATA &H6740
  DATA &H0C42,&H0002
  DATA &H6D20
  DATA &H24D0
  DATA &HD283
  DATA &H2401
  DATA &H84C4
  DATA &H0282,&H0000,&HFFFF
  DATA &H2E02
  DATA &HCEFC,&H0004
  DATA &HC4C4
  DATA &H9282
  DATA &HD1C7
  DATA &HB1C9
  DATA &H6DE2
  DATA &H6066
  DATA &H2A03
  DATA &H9A84
  DATA &H2018
  DATA &HD285
  DATA &H2401
  DATA &H9483
  DATA &H6B04
  DATA &H2202
  DATA &H6002
  DATA &H24C0
  DATA &HB1C9
  DATA &H6DEC
  DATA &H604C
  DATA &H2404
  DATA &H84C3
  DATA &H0C42,&H0002
  DATA &H6C1E
  DATA &H2A04
  DATA &H9A83
  DATA &H2018
  DATA &HD285
  DATA &H2401
  DATA &H9483
  DATA &H6B04
  DATA &H2202
  DATA &H24C0
  DATA &H24C0
  DATA &HB5CB
  DATA &H6C2A
  DATA &HB1C9
  DATA &H6DE8
  DATA &H6024
  DATA &H2018
  DATA &HD284
  DATA &H2401
  DATA &H84C3
  DATA &H0282,&H0000,&HFFFF
  DATA &H2E02
  DATA &HC4C3
  DATA &H9282
  DATA &H5387
  DATA &H24C0
  DATA &HB5CB
  DATA &H6C08
  DATA &H51CF,&HFFF8
  DATA &HB1C9
  DATA &H6DDC
  DATA &H288A
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfpmasch
  FOR g=0 TO 208 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf16(a,b,c,d,e,f)
  ' RESAMPLE
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  ' c - destanf
  ' d - destende
  ' e - source-sample-rate (320,441,480)
  ' f - dest-sample-rate (320,441,480)
  ' back% - destende-RETURN-Wert
  '
  saa%=a
  sba%=b
  sca%=c
  sda%=d
  sea%=e
  sfa%=f
  back%=0
  sga%=VARPTR(back%)
  ~C:mdat2%(L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:sfa%,L:sga%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit17
  ' MONO
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 7200                 anf2:     moveq.l   #0,d1
  ' 2401                           move.l    d1,d2
  ' 3210                           move.w    (a0),d1
  ' 34280002                       move.w    2(a0),d2
  ' 0801000F                       btst      #15,d1
  ' 660A                           bne.s     anf5
  ' 0802000F             anf3:     btst      #15,d2
  ' 6612                           bne.s     anf6
  ' D282                 anf4:     add.l     d2,d1    ; plus und plus = plus
  ' 6016                           bra.s     ende
  ' 0802000F             anf5:     btst      #15,d2
  ' 660E                           bne.s     anf7     ; minus und minus = minus
  ' 4641                           not.w     d1
  ' 9481                           sub.l     d1,d2    ; minus und plus = ?
  ' 2202                           move.l    d2,d1
  ' 6008                           bra.s     ende
  ' 4642                 anf6:     not.w     d2       ; plus und minus = ?
  ' 9282                           sub.l     d2,d1
  ' 6002                           bra.s     ende
  ' D282                 anf7:     add.l     d2,d1    ; add + wech
  ' E281                 ende:     asr.l     #1,d1
  ' 30C1                           move.w    d1,(a0)+
  ' 30C1                           move.w    d1,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DC6                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfqmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H7200
  DATA &H2401
  DATA &H3210
  DATA &H3428,&H0002
  DATA &H0801,&H000F
  DATA &H660A
  DATA &H0802,&H000F
  DATA &H6612
  DATA &HD282
  DATA &H6016
  DATA &H0802,&H000F
  DATA &H660E
  DATA &H4641
  DATA &H9481
  DATA &H2202
  DATA &H6008
  DATA &H4642
  DATA &H9282
  DATA &H6002
  DATA &HD282
  DATA &HE281
  DATA &H30C1
  DATA &H30C1
  DATA &HB1C9
  DATA &H6DC6
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfqmasch
  FOR g=0 TO 74 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf17(a,b)
  ' MONO
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~C:mdat2%(L:saa%,L:sba%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit18
  ' MIDI-PLAY
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 262F0048                       move.l    72(sp),d3 ; loop
  ' 242F004C                       move.l    76(sp),d2 ; midi
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA010E                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 10BC0004                       move.b    #4,(a0)
  ' 7800                           moveq.l   #8,d4               ; Anzahl der Backstep
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                 anf0:     movea.l   a3,a2
  ' 1010                 anf1:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf2:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 48E77FFE                       movem.l   d1-a6,-(sp)
  ' 3F3C0003                       move.w    #3,-(sp)  ; MIDI
  ' 3F3C0001                       move.w    #1,-(sp)  ; Bconstat
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' B07C0000                       cmp.w     #0,d0
  ' 676C                           beq.s     nomidi
  ' 3F3C0003                       move.w    #3,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)  ; Bconin
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-a6
  ' 48E77FFE                       movem.l   d1-a6,-(sp)
  ' 4BFA0088                       lea.l     midiw(pc),a5
  ' 08000007                       btst      #7,d0
  ' 6708                           beq.s     midi2     ; Daten oder Befehl ?
  ' E042                           asr.w     #8,d2     ; Channel im oberen Byte des Wortes
  ' 9002                           sub.b     d2,d0     ; Channel vom Befehl abziehen
  ' 1A80                           move.b    d0,(a5)   ; Befehl schreiben
  ' 6046                           bra.s     nomidi
  ' B002                 midi2:    cmp.b     d2,d0       ; Noten-DATA ?
  ' 671E                           beq.s     midi4
  ' B42D0001                       cmp.b     1(a5),d2    ; Noten-data schon gewesen und korrekt ?
  ' 663C                           bne.s     nomidi
  ' 1B400002             midi3:    move.b    d0,2(a5)    ; Velocitywert schreiben
  ' 0C150080                       cmp.b     #$80,(a5)   ; NOTE OFF ?
  ' 671A                           beq.s     midi5
  ' 0C150090                       cmp.b     #$90,(a5)   ; NOTE ON ?
  ' 671C                           beq.s     midi6
  ' 2ABC00000000         midi3b:   move.l    #0,(a5)     ; Datenwort lîschen
  ' 6024                           bra.s     nomidi
  ' B42D0001             midi4:    cmp.b     1(a5),d2  ; Noten-DATA schon gewesen ?
  ' 67E2                           beq.s     midi3     ; dann ist es nicht Note sondern Velocity
  ' 1B400001                       move.b    d0,1(a5)  ; Notenwert schreiben
  ' 6018                           bra.s     nomidi
  ' B42D0001             midi5:    cmp.b     1(a5),d2  ; NOTE OFF und Note OK ?
  ' 66E6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 6024                           bra.s     weg2      ; Abbruch, da NOTE OFF !
  ' B42D0001             midi6:    cmp.b     1(a5),d2  ; NOTE ON und Note OK ?
  ' 66DE                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 0C2D00000002                   cmp.b     #0,2(a5)  ; Velocity ist Null ?
  ' 66D6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 6014                           bra.s     weg2      ; Abbruch, da NOTE ON und Velo=Null !
  ' 4CDF7FFE             nomidi:   movem.l   (sp)+,d1-a6
  ' 95C4                           suba.l    d4,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 6600FF44                       bne       anf1
  ' 4A83                           tst.l     d3
  ' 6708                           beq.s     weg
  ' 6000FF3A                       bra       anf0
  ' 4CDF7FFE             weg2:     movem.l   (sp)+,d1-a6
  ' 4BFA0017             weg:      lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 00000000             midiw:    dc.l 0
anfrmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H262F,&H0048
  DATA &H242F,&H004C
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H010E
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H4CDF,&H7FFF
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H10BC,&H0004
  DATA &H7800
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &HB07C,&H0000
  DATA &H676C
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0002
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H7FFE
  DATA &H48E7,&H7FFE
  DATA &H4BFA,&H0088
  DATA &H0800,&H0007
  DATA &H6708
  DATA &HE042
  DATA &H9002
  DATA &H1A80
  DATA &H6046
  DATA &HB002
  DATA &H671E
  DATA &HB42D,&H0001
  DATA &H663C
  DATA &H1B40,&H0002
  DATA &H0C15,&H0080
  DATA &H671A
  DATA &H0C15,&H0090
  DATA &H671C
  DATA &H2ABC,&H0000,&H0000
  DATA &H6024
  DATA &HB42D,&H0001
  DATA &H67E2
  DATA &H1B40,&H0001
  DATA &H6018
  DATA &HB42D,&H0001
  DATA &H66E6
  DATA &H6024
  DATA &HB42D,&H0001
  DATA &H66DE
  DATA &H0C2D,&H0000,&H0002
  DATA &H66D6
  DATA &H6014
  DATA &H4CDF,&H7FFE
  DATA &H95C4
  DATA &HB5C1
  DATA &H6600,&HFF44
  DATA &H4A83
  DATA &H6708
  DATA &H6000,&HFF3A
  DATA &H4CDF,&H7FFE
  DATA &H4BFA,&H0017
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H1208
  DATA &H0000,&H0000
  '
  RESTORE anfrmasch
  FOR g=0 TO 300 STEP 2
    READ aw
    DPOKE mdat2%+g,aw
  NEXT g
  retanz=63    ! Stelle fuer Anzahl der Rueckspruenge bei RETPLAY
RETURN
'
> PROCEDURE miditest
  @busy_mouse
  raus=FALSE
  REPEAT
    x=INP?(3)
    y=INP?(2)
    IF x=TRUE THEN
      xx=INP(3)
      IF xx=&H90+(ch-1) THEN
        REPEAT
          x=INP?(3)
          y=INP?(2)
        UNTIL x=TRUE OR y=TRUE
        IF y=FALSE AND x=TRUE THEN
          xx2=INP(3)
          IF xx2=note THEN
            REPEAT
              x=INP?(3)
              y=INP?(2)
            UNTIL x=TRUE OR y=TRUE
            IF y=FALSE AND x=TRUE THEN
              xx3=INP(3)
              IF xx=&H90+(ch-1) AND xx2=note AND xx3<>0 THEN
                raus=TRUE
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    IF y=TRUE THEN
      yy=INP(2)
    ENDIF
  UNTIL y=TRUE OR raus=TRUE
  IF raus=TRUE AND y=FALSE THEN
    raus=FALSE
    PRINT "AN",
    REPEAT
      x=INP?(3)
      y=INP?(2)
      IF x=TRUE THEN
        xx4=INP(3)
        IF xx4=&H90+(ch-1) THEN
          REPEAT
            x=INP?(3)
            y=INP?(2)
          UNTIL x=TRUE OR y=TRUE
          IF y=FALSE AND x=TRUE THEN
            xx5=INP(3)
            IF xx5=note THEN
              REPEAT
                x=INP?(3)
                y=INP?(2)
              UNTIL x=TRUE OR y=TRUE
              IF y=FALSE AND x=TRUE THEN
                xx6=INP(3)
                IF xx4=&H90+(ch-1) AND xx5=note AND xx6=0 THEN
                  raus=TRUE
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      IF y=TRUE THEN
        yy=INP(2)
      ENDIF
    UNTIL y=TRUE OR raus=TRUE
    PRINT "AUS",
  ENDIF
RETURN
'
> PROCEDURE maschruf18
  ' MIDI-PLAY,MIDI-BACKPLAY,MIDI-CROSSPLAY
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  ' l - LÑnge
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  REPEAT
    IF sret=0 THEN
      @maschinit18
      POKE mdat2%+retanz,0
    ENDIF
    IF sret=1 THEN
      @maschinit18
      POKE mdat2%+retanz,8
    ENDIF
    IF sret=2 THEN
      @maschinit21
    ENDIF
    saa%=a
    sba%=b
    sca%=l
    sda%=midiwort
    raus=FALSE
    REPEAT
      x=INP?(3)
      y=INP?(2)
      ~GRAF_MKSTATE(v,v2,v3,v4)
      IF x=TRUE AND v3<>2 THEN
        xx=INP(3)
        IF xx=&H90+(ch-1) THEN
          REPEAT
            x=INP?(3)
            y=INP?(2)
            ~GRAF_MKSTATE(v,v2,v3,v4)
          UNTIL x=TRUE OR y=TRUE OR v3=2
          IF y=FALSE AND x=TRUE AND v3<>2 THEN
            xx2=INP(3)
            IF xx2=note AND v3<>2 THEN
              REPEAT
                x=INP?(3)
                y=INP?(2)
                ~GRAF_MKSTATE(v,v2,v3,v4)
              UNTIL x=TRUE OR y=TRUE OR v3=2
              IF y=FALSE AND x=TRUE AND v3<>2 THEN
                xx3=INP(3)
                IF xx=&H90+(ch-1) AND xx2=note AND xx3<>0 THEN
                  raus=TRUE
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      IF y=TRUE AND v3<>2 THEN
        yy=INP(2)
      ENDIF
      ~GRAF_MKSTATE(v,v2,v3,v4)
    UNTIL y=TRUE OR raus=TRUE OR v3=2
    IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
      IF sret<>2 THEN
        ~C:mdat2%(L:saa%,L:sba%,L:sca%,L:sda%)
      ELSE
        ~C:mdat3%(L:saa%,L:sba%,L:sca%,L:sda%)
      ENDIF
    ENDIF
    ~GRAF_MKSTATE(v,v2,v3,v4)
  UNTIL v3=2
RETURN
'
> PROCEDURE maschruf18b
  ' ARR-MIDIPLAY,ARR-MIDICROSSPLAY,ARR-MIDIBACKPLAY
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  ' l - LÑnge
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  REPEAT
    @maschinit18
    @maschinit21    ! fÅr CROSSPLAY
    raus=FALSE
    REPEAT
      x=INP?(3)
      y=INP?(2)
      ~GRAF_MKSTATE(v,v2,v3,v4)
      IF x=TRUE AND v3<>2 THEN
        xx=INP(3)
        IF xx>=&H90 AND xx<=&H9F THEN     ! xx-&H90 = channel
          REPEAT
            x=INP?(3)
            y=INP?(2)
            ~GRAF_MKSTATE(v,v2,v3,v4)
          UNTIL x=TRUE OR y=TRUE OR v3=2
          IF y=FALSE AND x=TRUE AND v3<>2 THEN
            xx2=INP(3)
            IF v3<>2 THEN             ! xx2 = note
              REPEAT
                x=INP?(3)
                y=INP?(2)
                ~GRAF_MKSTATE(v,v2,v3,v4)
              UNTIL x=TRUE OR y=TRUE OR v3=2
              IF y=FALSE AND x=TRUE AND v3<>2 THEN
                xx3=INP(3)
                IF xx>=&H90 AND xx<=&H9F AND xx3<>0 THEN
                  ch=xx-&H90
                  note=xx2
                  z=0
                  REPEAT
                    REPEAT
                      INC z
                      midiwort=arrmidi(z)
                      vch=INT(midiwort/256)
                      vnote=midiwort AND 255
                      ~GRAF_MKSTATE(v,v2,v3,v4)
                    UNTIL z=lmax2 OR (vch=ch AND vnote=note) OR v3=2
                  UNTIL (arrpath$(z)<>"" AND arrpath$(z)<>"DELAY") OR z=lmax2 OR v3=2
                  IF vch=ch AND vnote=note AND arrpath$(z)<>"" AND arrpath$(z)<>"DELAY" THEN
                    IF arrloop(z)=0 THEN
                      l=0
                    ELSE
                      l=-1
                    ENDIF
                    IF arrtri(z)=0 THEN
                      saa%=arrstrt(z)+meml
                      sba%=arrend(z)+meml
                    ENDIF
                    IF arrtri(z)=1 THEN
                      sba%=arrstrt(z)+meml
                      saa%=arrend(z)+meml
                      IF arrpath$(z)="MEMORY" THEN
                        POKE mdat2%+retanz,8
                      ENDIF
                    ENDIF
                    sca%=l
                    sda%=midiwort
                    raus=TRUE
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      ~GRAF_MKSTATE(v,v2,v3,v4)
      IF y=TRUE AND v3<>2 THEN
        yy=INP(2)
      ENDIF
    UNTIL y=TRUE OR raus=TRUE OR v3=2
    IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
      IF arrpath$(z)="MEMORY" THEN
        IF arrtri(z)<>2 THEN
          ~C:mdat2%(L:saa%,L:sba%,L:sca%,L:sda%)
        ELSE
          ~C:mdat3%(L:saa%,L:sba%,L:sca%,L:sda%)
        ENDIF
        IF arrtri(z)=1 THEN
          POKE mdat2%+retanz,0
        ENDIF
      ENDIF
      IF arrpath$(z)<>"MEMORY" AND arrpath$(z)<>"" AND arrpath$(z)<>"DELAY" THEN
        @digout(TRUE)
        over=0
        @maschinit26
        @maschinit27
        pa$=arrpath$(z)+CHR$(0)
        sectors=arrend(z)-arrstrt(z)
        handle=GEMDOS(61,L:VARPTR(pa$),0)
        REPEAT
          IF arrtri(z)=0 OR arrtri(z)=2 THEN
            seeknr=arrstrt(z)*flen
            seek=GEMDOS(66,L:seeknr,handle,0)
            vhz=arrsrate(z)
            @swtosrate(vhz)
            @maschruf26
          ENDIF
          IF arrtri(z)=1 OR (arrtri(z)=2 AND back%=sectors) THEN
            seeknr=arrend(z)*flen
            seek=GEMDOS(66,L:seeknr,handle,0)
            vhz=arrsrate(z)
            @swtosrate(vhz)
            @maschruf27
          ENDIF
        UNTIL back%<>sectors OR arrloop(z)=0
        ~GEMDOS(62,handle)
        @digout(FALSE)
        @maschinit18
        @maschinit21
      ENDIF
    ENDIF
    ~GRAF_MKSTATE(v,v2,v3,v4)
  UNTIL v3=2
RETURN
'
> PROCEDURE maschinit19
  ' MFORW & MPLAY
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       movea.l   68(sp),a6  ; fname
  ' 242F0048                       move.l    72(sp),d2 ; sectors
  ' 2A2F004C                       move.l    76(sp),d5 ; len
  ' 2E2F0050                       move.l    80(sp),d7 ; handle
  ' 2A6F0054                       move.l    84(sp),a5 ; adder
  ' 286F0058                       move.l    88(sp),a4 ; Returnwert
  ' 41F900DF0441                   lea.l     $df0441,a0          ; Flagstatus
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 220B                           move.l    a3,d1     ; MEMende
  ' D285                           add.l     d5,d1
  ' 7C00                           moveq.l   #0,d6
  ' 7804                           moveq.l   #4,d4
  ' 7608                           moveq.l   #8,d3
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                           movea.l   a3,a2
  ' 48E7FFFC                       movem.l   d0-d7/a0-a5,-(sp)
  ' 2F0B                           move.l    a3,-(sp)  ; Fread
  ' 2F05                           move.l    d5,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF3FFF                       movem.l   (sp)+,d0-d7/a0-a5
  ' 1010                           move.b    (a0),d0   ; FIFO halbleer ?
  ' 02000008                       andi.b    #8,d0
  ' 6724                           beq.s     anf2
  ' 2F01                           move.l    d1,-(sp)
  ' 303C03FF                       move.w    #$3ff,d0     ; ...dann FIFO halb-fuellen (FIFO-LEN/2/4-1)!
  ' 121A                 copy:     move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 51C8FFE6                       dbra      d0,copy
  ' 221F                           move.l    (sp)+,d1
  ' 1010                 anf2:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf2
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf3
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf4
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf5:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf5
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 48E77FFE                       movem.l   d1-d7/a0-a6,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' B07C0000                       cmp.w     #0,d0
  ' 660C                           bne.s     weg
  ' D5CD                           add.l     a5,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 66B0                           bne.s     anf2
  ' BC82                           cmp.l     d2,d6
  ' 6600FF64                       bne       anf
  ' 2886                 weg:      move.l    d6,(a4)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  '
anfsmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H242F,&H0048
  DATA &H2A2F,&H004C
  DATA &H2E2F,&H0050
  DATA &H2A6F,&H0054
  DATA &H286F,&H0058
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H220B
  DATA &HD285
  DATA &H7C00
  DATA &H7804
  DATA &H7608
  DATA &H5286
  DATA &H244B
  DATA &H48E7,&HFFFC
  DATA &H2F0B
  DATA &H2F05
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H3FFF
  DATA &H1010
  DATA &H0200,&H0008
  DATA &H6724
  DATA &H2F01
  DATA &H303C,&H03FF
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H51C8,&HFFE6
  DATA &H221F
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0002
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H7FFE
  DATA &HB07C,&H0000
  DATA &H660C
  DATA &HD5CD
  DATA &HB5C1
  DATA &H66B0
  DATA &HBC82
  DATA &H6600,&HFF64
  DATA &H2886
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfsmasch
  FOR g=0 TO 218 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf19
  ' MFORW,MPLAY,MBACKW
  '
  @busy_mouse
  sbd%=VARPTR(pa$)        !Pfad
  scd%=sectors            !sectors
  sdd%=flen               !len
  sde%=handle
  sdf%=over
  back%=0
  sdg%=VARPTR(back%)
  IF demo=FALSE THEN
    ~C:mdat2%(L:mdat%,L:sbd%,L:scd%,L:sdd%,L:sde%,L:sdf%,L:sdg%)
  ENDIF
RETURN
'
> PROCEDURE maschinit20
  ' MBACKW
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       movea.l   68(sp),a6  ; fname
  ' 242F0048                       move.l    72(sp),d2 ; sectors
  ' 2A2F004C                       move.l    76(sp),d5 ; len
  ' 2E2F0050                       move.l    80(sp),d7 ; handle
  ' 2A6F0054                       move.l    84(sp),a5 ; subber
  ' 286F0058                       move.l    88(sp),a4 ; Returnwert
  ' 41F900DF0441                   lea.l     $df0441,a0          ; Flagstatus
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 220B                           move.l    a3,d1     ; MEManf
  ' 7C00                           moveq.l   #0,d6
  ' 7804                           moveq.l   #4,d4
  ' 7608                           moveq.l   #8,d3
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                           movea.l   a3,a2
  ' D5C5                           add.l     d5,a2     ; auf MEMende setzen
  ' 48E7FFFC                       movem.l   d0-d7/a0-a5,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)  ; Fseek
  ' 3F07                           move.w    d7,-(sp)
  ' 2005                           move.l    d5,d0
  ' D080                           add.l     d0,d0
  ' 4480                           neg.l     d0
  ' 2F00                           move.l    d0,-(sp)
  ' 3F3C0042                       move.w    #66,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000A                       lea.l     $a(sp),sp
  ' 2F0B                           move.l    a3,-(sp)  ; Fread
  ' 2F05                           move.l    d5,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF3FFF                       movem.l   (sp)+,d0-d7/a0-a5
  ' 1010                           move.b    (a0),d0   ; FIFO halbleer ?
  ' 02000008                       andi.b    #8,d0
  ' 6730                           beq.s     anf2
  ' 2F01                           move.l    d1,-(sp)
  ' 303C03FF                       move.w    #$3ff,d0     ; ...dann FIFO halb-fuellen (FIFO-LEN/2/4-1)!
  ' 95FC00000004         copy:     suba.l    #4,a2
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 95FC00000004                   suba.l    #4,a2
  ' 51C8FFDA                       dbra      d0,copy
  ' 221F                           move.l    (sp)+,d1
  ' 95FC00000004         anf2:     suba.l    #4,a2
  ' 1010                 anf2b:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf2b
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf3
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf4
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf5:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf5
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 95FC00000004                   suba.l    #4,a2
  ' 48E77FFE                       movem.l   d1-d7/a0-a6,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' B07C0000                       cmp.w     #0,d0
  ' 660C                           bne.s     weg
  ' 95CD                           sub.l     a5,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 66A4                           bne.s     anf2
  ' BC82                           cmp.l     d2,d6
  ' 6600FF32                       bne       anf
  ' 2886                 weg:      move.l    d6,(a4)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  '
anftmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H242F,&H0048
  DATA &H2A2F,&H004C
  DATA &H2E2F,&H0050
  DATA &H2A6F,&H0054
  DATA &H286F,&H0058
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H220B
  DATA &H7C00
  DATA &H7804
  DATA &H7608
  DATA &H5286
  DATA &H244B
  DATA &HD5C5
  DATA &H48E7,&HFFFC
  DATA &H3F3C,&H0001
  DATA &H3F07
  DATA &H2005
  DATA &HD080
  DATA &H4480
  DATA &H2F00
  DATA &H3F3C,&H0042
  DATA &H4E41
  DATA &H4FEF,&H000A
  DATA &H2F0B
  DATA &H2F05
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H3FFF
  DATA &H1010
  DATA &H0200,&H0008
  DATA &H6730
  DATA &H2F01
  DATA &H303C,&H03FF
  DATA &H95FC,&H0000,&H0004
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H95FC,&H0000,&H0004
  DATA &H51C8,&HFFDA
  DATA &H221F
  DATA &H95FC,&H0000,&H0004
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H95FC,&H0000,&H0004
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0002
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H7FFE
  DATA &HB07C,&H0000
  DATA &H660C
  DATA &H95CD
  DATA &HB5C1
  DATA &H66A4
  DATA &HBC82
  DATA &H6600,&HFF32
  DATA &H2886
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anftmasch
  FOR g=0 TO 266 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschinit21
  mdat3%=mdat2%+500
  ' MIDI-CROSSPLAY
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 262F0048                       move.l    72(sp),d3 ; loop
  ' 242F004C                       move.l    76(sp),d2 ; midi
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 7800                           moveq.l   #0,d4               ; Anzahl der Backstep
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA011E                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 10BC0004                       move.b    #4,(a0)
  ' 7A08                 anf0:     moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                           movea.l   a3,a2
  ' 1010                 anf1:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf2:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 48E77FFE                       movem.l   d1-a6,-(sp)
  ' 3F3C0003                       move.w    #3,-(sp)  ; MIDI
  ' 3F3C0001                       move.w    #1,-(sp)  ; Bconstat
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' B07C0000                       cmp.w     #0,d0
  ' 676C                           beq.s     nomidi
  ' 3F3C0003                       move.w    #3,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)  ; Bconin
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-a6
  ' 48E77FFE                       movem.l   d1-a6,-(sp)
  ' 4BFA00A6                       lea.l     midiw(pc),a5
  ' 08000007                       btst      #7,d0
  ' 6708                           beq.s     midi2     ; Daten oder Befehl ?
  ' E042                           asr.w     #8,d2     ; Channel im oberen Byte des Wortes
  ' 9002                           sub.b     d2,d0     ; Channel vom Befehl abziehen
  ' 1A80                           move.b    d0,(a5)   ; Befehl schreiben
  ' 6046                           bra.s     nomidi
  ' B002                 midi2:    cmp.b     d2,d0       ; Noten-DATA ?
  ' 671E                           beq.s     midi4
  ' B42D0001                       cmp.b     1(a5),d2    ; Noten-data schon gewesen und korrekt ?
  ' 663C                           bne.s     nomidi
  ' 1B400002             midi3:    move.b    d0,2(a5)    ; Velocitywert schreiben
  ' 0C150080                       cmp.b     #$80,(a5)   ; NOTE OFF ?
  ' 671A                           beq.s     midi5
  ' 0C150090                       cmp.b     #$90,(a5)   ; NOTE ON ?
  ' 671C                           beq.s     midi6
  ' 2ABC00000000         midi3b:   move.l    #0,(a5)     ; Datenwort lîschen
  ' 6024                           bra.s     nomidi
  ' B42D0001             midi4:    cmp.b     1(a5),d2  ; Noten-DATA schon gewesen ?
  ' 67E2                           beq.s     midi3     ; dann ist es nicht Note sondern Velocity
  ' 1B400001                       move.b    d0,1(a5)  ; Notenwert schreiben
  ' 6018                           bra.s     nomidi
  ' B42D0001             midi5:    cmp.b     1(a5),d2  ; NOTE OFF und Note OK ?
  ' 66E6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 603E                           bra.s     weg2      ; Abbruch, da NOTE OFF !
  ' B42D0001             midi6:    cmp.b     1(a5),d2  ; NOTE ON und Note OK ?
  ' 66DE                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 0C2D00000002                   cmp.b     #0,2(a5)  ; Velocity ist Null ?
  ' 66D6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 602E                           bra.s     weg2      ; Abbruch, da NOTE ON und Velo=Null !
  ' 4CDF7FFE             nomidi:   movem.l   (sp)+,d1-a6
  ' 95C4                           suba.l    d4,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 6600FF44                       bne       anf1
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' B83C0000                       cmp.b     #0,d4
  ' 6708                           beq.s     backw
  ' 7800                           moveq.l   #0,d4
  ' 4A83                           tst.l     d3
  ' 671A                           beq.s     weg
  ' 6002                           bra.s     forw
  ' 7808                 backw:    moveq.l   #8,d4     ; Anzahl der Backsteps
  ' 2001                 forw:     move.l    d1,d0
  ' 220B                           move.l    a3,d1
  ' 2640                           move.l    d0,a3
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 6000FF1C                       bra       anf0
  ' 4CDF7FFE             weg2:     movem.l   (sp)+,d1-a6
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4BFA0017             weg:      lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 00000000             midiw:    dc.l 0
anfumasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H262F,&H0048
  DATA &H242F,&H004C
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H7800
  DATA &H48E7,&HFFFE
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H011E
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H4CDF,&H7FFF
  DATA &H10BC,&H0004
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &HB07C,&H0000
  DATA &H676C
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0002
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H7FFE
  DATA &H48E7,&H7FFE
  DATA &H4BFA,&H00A6
  DATA &H0800,&H0007
  DATA &H6708
  DATA &HE042
  DATA &H9002
  DATA &H1A80
  DATA &H6046
  DATA &HB002
  DATA &H671E
  DATA &HB42D,&H0001
  DATA &H663C
  DATA &H1B40,&H0002
  DATA &H0C15,&H0080
  DATA &H671A
  DATA &H0C15,&H0090
  DATA &H671C
  DATA &H2ABC,&H0000,&H0000
  DATA &H6024
  DATA &HB42D,&H0001
  DATA &H67E2
  DATA &H1B40,&H0001
  DATA &H6018
  DATA &HB42D,&H0001
  DATA &H66E6
  DATA &H603E
  DATA &HB42D,&H0001
  DATA &H66DE
  DATA &H0C2D,&H0000,&H0002
  DATA &H66D6
  DATA &H602E
  DATA &H4CDF,&H7FFE
  DATA &H95C4
  DATA &HB5C1
  DATA &H6600,&HFF44
  DATA &H4CDF,&H7FFF
  DATA &HB83C,&H0000
  DATA &H6708
  DATA &H7800
  DATA &H4A83
  DATA &H671A
  DATA &H6002
  DATA &H7808
  DATA &H2001
  DATA &H220B
  DATA &H2640
  DATA &H48E7,&HFFFE
  DATA &H6000,&HFF1C
  DATA &H4CDF,&H7FFE
  DATA &H4CDF,&H7FFF
  DATA &H4BFA,&H0017
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H1208
  DATA &H0000,&H0000
  '
  RESTORE anfumasch
  FOR g=0 TO 334 STEP 2
    READ aw
    DPOKE mdat3%+g,aw
  NEXT g
RETURN
'
> PROCEDURE maschinit22
  ' ARRPLAY
  '
  mdat3%=mdat2%+500
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 262F0048                       move.l    72(sp),d3 ; loop
  ' 2C6F004C                       movea.l   76(sp),a6  ; Returnwert
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA00D8                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA00AE                       lea.l     rett(pc),a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43FA009C                       lea.l     neuikbd(pc),a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 10BC0004                       move.b    #4,(a0)
  ' 7800                           moveq.l   #0,d4               ; Anzahl der Backstep
  '
  ' 49FA007C                       lea.l     merk(pc),a4
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                 anf0:     movea.l   a3,a2
  ' 1010                 anf1:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf2:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 660C                           bne.s     weg2
  ' 95C4                           suba.l    d4,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 66C6                           bne.s     anf1
  ' 4A83                           tst.l     d3
  ' 6708                           beq.s     weg
  ' 60BE                           bra.s     anf0
  ' 2CBC00000001         weg2:     move.l    #1,(a6)
  ' 4BFA002B             weg:      lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA001A                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 0000                 merk:     Dc.w 0
  ' 33FC0001000000F4     neuikbd:  move.w    #1,merk
  ' 4EF9000000FE         rett:     jmp       rett
  '
anfvmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H262F,&H0048
  DATA &H2C6F,&H004C
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H00D8
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H00AE
  DATA &H2368,&H0020,&H0002
  DATA &H43FA,&H009C
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H10BC,&H0004
  DATA &H7800
  DATA &H49FA,&H007C
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H3014
  DATA &H660C
  DATA &H95C4
  DATA &HB5C1
  DATA &H66C6
  DATA &H4A83
  DATA &H6708
  DATA &H60BE
  DATA &H2CBC,&H0000,&H0001
  DATA &H4BFA,&H002B
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H001A
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H1208
  DATA &H0000
  DATA &H33FC,&H0001,&H0000,&H00F4
  DATA &H4EF9,&H0000,&H00FE
  '
  RESTORE anfvmasch
  FOR g=0 TO 258 STEP 2
    READ a
    DPOKE mdat3%+g,a
  NEXT g
  retanz=117    ! Stelle fuer Anzahl der Rueckspruenge bei RETPLAY
  LPOKE mdat3%+250,mdat3%+244   !merk
RETURN
'
> PROCEDURE maschruf22
  ' ARRPLAY
  '
  @busy_mouse
  saa%=a
  sba%=b
  ena%=l
  back%=0
  sdg%=VARPTR(back%)
  IF demo=FALSE THEN
    ~C:mdat3%(L:saa%,L:sba%,L:ena%,L:sdg%)
  ENDIF
RETURN
'
> PROCEDURE maschinit23
  ' ARR_HARDPLAY
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       movea.l   68(sp),a6  ; fname
  ' 242F0048                       move.l    72(sp),d2 ; sectors
  ' 2A2F004C                       move.l    76(sp),d5 ; len
  ' 2E2F0050                       move.l    80(sp),d7 ; handle
  ' 2A6F0054                       move.l    84(sp),a5 ; adder
  ' 286F0058                       move.l    88(sp),a4 ; Returnwert
  ' 2F0C                           move.l    a4,-(sp)
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA011C                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA00F2                       lea.l     rett(pc),a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43FA00E0                       lea.l     neuikbd(pc),a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0          ; Flagstatus
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 220B                           move.l    a3,d1     ; MEMende
  ' D285                           add.l     d5,d1
  ' 7C00                           moveq.l   #0,d6
  ' 7804                           moveq.l   #4,d4
  ' 7608                           moveq.l   #8,d3
  ' 49FA00BC                       lea.l     merk(pc),a4
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                           movea.l   a3,a2
  ' 48E7FFFC                       movem.l   d0-d7/a0-a5,-(sp)
  ' 2F0B                           move.l    a3,-(sp)  ; Fread
  ' 2F05                           move.l    d5,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF3FFF                       movem.l   (sp)+,d0-d7/a0-a5
  ' 1010                           move.b    (a0),d0   ; FIFO halbleer ?
  ' 02000008                       andi.b    #8,d0
  ' 6724                           beq.s     anf2
  ' 2F01                           move.l    d1,-(sp)
  ' 303C03FF                       move.w    #$3ff,d0     ; ...dann FIFO halb-fuellen (FIFO-LEN/2/4-1)!
  ' 121A                 copy:     move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 51C8FFE6                       dbra      d0,copy
  ' 221F                           move.l    (sp)+,d1
  ' 1010                 anf2:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf2
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf3
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf4
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf5:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf5
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 660C                           bne.s     weg
  ' D5CD                           add.l     a5,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 66C6                           bne.s     anf2
  ' BC82                           cmp.l     d2,d6
  ' 6600FF7A                       bne       anf
  ' 285F                 weg:      move.l    (sp)+,a4
  ' 2886                           move.l    d6,(a4)
  ' 4BFA002B                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA001A                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 0000                 merk:     Dc.w 0
  ' 33FC000100000146     neuikbd:  move.w    #1,merk
  ' 4EF900000150         rett:     jmp       rett
  '
anfwmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H242F,&H0048
  DATA &H2A2F,&H004C
  DATA &H2E2F,&H0050
  DATA &H2A6F,&H0054
  DATA &H286F,&H0058
  DATA &H2F0C
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H011C
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H00F2
  DATA &H2368,&H0020,&H0002
  DATA &H43FA,&H00E0
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H220B
  DATA &HD285
  DATA &H7C00
  DATA &H7804
  DATA &H7608
  DATA &H49FA,&H00BC
  DATA &H5286
  DATA &H244B
  DATA &H48E7,&HFFFC
  DATA &H2F0B
  DATA &H2F05
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H3FFF
  DATA &H1010
  DATA &H0200,&H0008
  DATA &H6724
  DATA &H2F01
  DATA &H303C,&H03FF
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H51C8,&HFFE6
  DATA &H221F
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H3014
  DATA &H660C
  DATA &HD5CD
  DATA &HB5C1
  DATA &H66C6
  DATA &HBC82
  DATA &H6600,&HFF7A
  DATA &H285F
  DATA &H2886
  DATA &H4BFA,&H002B
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H001A
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H1208
  DATA &H0000
  DATA &H33FC,&H0001,&H0000,&H0146
  DATA &H4EF9,&H0000,&H0150
  '
  RESTORE anfwmasch
  FOR g=0 TO 340 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  LPOKE mdat2%+332,mdat2%+326   !merk
RETURN
'
> PROCEDURE maschruf23
  ' ARR-HARDPLAY
  '
  @busy_mouse
  sbd%=VARPTR(pa$)        !Pfad
  scd%=sectors            !sectors
  sdd%=flen               !len
  sde%=handle
  sdf%=over
  back%=0
  sdg%=VARPTR(back%)
  IF demo=FALSE THEN
    ~C:mdat2%(L:mdat%,L:sbd%,L:scd%,L:sdd%,L:sde%,L:sdf%,L:sdg%)
  ENDIF
RETURN
'
> PROCEDURE maschinit24
  mdat4%=mdat2%+1000
  ' ARR_CROSSPLAY
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 262F0048                       move.l    72(sp),d3 ; loop
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA0144                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA011A                       lea.l     rett(pc),a1
  ' 236800200002                   move.l    32(a0),2(a1)
  ' 43FA0108                       lea.l     neuikbd(pc),a1
  ' 21490020                       move.l    a1,32(a0)
  ' 4CDF7FFF             anf0:     movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 10BC0004                       move.b    #4,(a0)
  ' 49FA00E6                       lea.l     merk(pc),a4
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                           movea.l   a3,a2
  ' 1010                 anf1:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf2:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anf4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 6678                           bne.s     weg
  ' B5C1                           cmpa.l    d1,a2
  ' 66C8                           bne.s     anf1
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 41F900DF0441                   lea.l     $df0441,a0
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; Wordmode
  ' 2401                           move.l    d1,d2
  ' 220B                           move.l    a3,d1
  ' 068100000004                   add.l     #4,d1
  ' 2642                           move.l    d2,a3
  ' 97FC00000004                   suba.l    #4,a3
  ' 7808                           moveq.l   #4,d4
  ' 49FA007C                       lea.l     merk(pc),a4
  ' 7A08                           moveq.l   #8,d5
  ' 7C04                           moveq.l   #4,d6
  ' 244B                           movea.l   a3,a2
  ' 1010                 anfb1:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb1
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anfb2:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb2
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Parity loeschen (Kennung fÅr Rechter Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1010                 anfb3:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb3
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1010                 anfb4:    move.b    (a0),d0
  ' C006                           and.b     d6,d0
  ' 67FA                           beq.s     anfb4
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Parity einfÅgen (Kennung fÅr Linker Kanal)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 3014                           move.w    (a4),d0
  ' 660E                           bne.s     weg
  ' 95C4                           suba.l    d4,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 66C6                           bne.s     anfb1
  ' 4A83                           tst.l     d3
  ' 6704                           beq.s     weg
  ' 6000FF34                       bra       anf0
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4BFA002B                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA001A                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 0000                 merk:     Dc.w 0
  ' 33FC00010000015C     neuikbd:  move.w    #1,merk
  ' 4EF900000166         rett:     jmp       rett
  '
anfxmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H262F,&H0048
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H0144
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H011A
  DATA &H2368,&H0020,&H0002
  DATA &H43FA,&H0108
  DATA &H2149,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFFFE
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H10BC,&H0004
  DATA &H49FA,&H00E6
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H3014
  DATA &H6678
  DATA &HB5C1
  DATA &H66C8
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFFFE
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H2401
  DATA &H220B
  DATA &H0681,&H0000,&H0004
  DATA &H2642
  DATA &H97FC,&H0000,&H0004
  DATA &H7808
  DATA &H49FA,&H007C
  DATA &H7A08
  DATA &H7C04
  DATA &H244B
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1010
  DATA &HC006
  DATA &H67FA
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H3014
  DATA &H660E
  DATA &H95C4
  DATA &HB5C1
  DATA &H66C6
  DATA &H4A83
  DATA &H6704
  DATA &H6000,&HFF34
  DATA &H4CDF,&H7FFF
  DATA &H4BFA,&H002B
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H001A
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H1208
  DATA &H0000
  DATA &H33FC,&H0001,&H0000,&H015C
  DATA &H4EF9,&H0000,&H0166
  '
  RESTORE anfxmasch
  FOR g=0 TO 362 STEP 2
    READ a
    DPOKE mdat4%+g,a
  NEXT g
  LPOKE mdat4%+354,mdat4%+348   !merk
RETURN
'
> PROCEDURE maschruf24
  @busy_mouse
  ' ARR_CROSSPLAY
  '
  back%=0
  saa%=a
  sba%=b
  ena%=l
  IF demo=FALSE THEN
    ~C:mdat4%(L:saa%,L:sba%,L:ena%)
  ENDIF
RETURN
'
> PROCEDURE maschinit25
  ' HARD-RPLAY
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       movea.l   68(sp),a6  ; fname
  ' 242F0048                       move.l    72(sp),d2 ; sectors
  ' 2A2F004C                       move.l    76(sp),d5 ; len
  ' 2E2F0050                       move.l    80(sp),d7 ; handle
  ' 2A6F0054                       move.l    84(sp),a5 ; subber
  ' 286F0058                       move.l    88(sp),a4 ; Returnwert
  ' 2F0C                           move.l    a4,-(sp)
  ' 41F900DF0441                   lea.l     $df0441,a0          ; Flagstatus
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA014E                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 4BFA0112                       lea.l     rett(pc),a5
  ' 2B6800200002                   move.l    32(a0),2(a5)
  ' 4BFA0100                       lea.l     neuikbd(pc),a5
  ' 214D0020                       move.l    a5,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 49FA0104                       lea.l     merk(pc),a4
  ' 220B                           move.l    a3,d1     ; MEManf
  ' 7C00                           moveq.l   #0,d6
  ' 7804                           moveq.l   #4,d4
  ' 7608                           moveq.l   #8,d3
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                           movea.l   a3,a2
  ' D5C5                           add.l     d5,a2     ; auf MEMende setzen
  ' 48E7FFFC                       movem.l   d0-d7/a0-a5,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)  ; Fseek
  ' 3F07                           move.w    d7,-(sp)
  ' 2005                           move.l    d5,d0
  ' D080                           add.l     d0,d0
  ' 4480                           neg.l     d0
  ' 2F00                           move.l    d0,-(sp)
  ' 3F3C0042                       move.w    #66,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000A                       lea.l     $a(sp),sp
  ' 2F0B                           move.l    a3,-(sp)  ; Fread
  ' 2F05                           move.l    d5,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF3FFF                       movem.l   (sp)+,d0-d7/a0-a5
  ' 1010                           move.b    (a0),d0   ; FIFO halbleer ?
  ' 02000008                       andi.b    #8,d0
  ' 6730                           beq.s     anf2
  ' 2F01                           move.l    d1,-(sp)
  ' 303C03FF                       move.w    #$3ff,d0     ; ...dann FIFO halb-fuellen (FIFO-LEN/2/4-1)!
  ' 95FC00000004         copy:     suba.l    #4,a2
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 95FC00000004                   suba.l    #4,a2
  ' 51C8FFDA                       dbra      d0,copy
  ' 221F                           move.l    (sp)+,d1
  ' 95FC00000004         anf2:     suba.l    #4,a2
  ' 1010                 anf2b:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf2b
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf3
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf4
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf5:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf5
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 95FC00000004                   suba.l    #4,a2
  ' 3014                           move.w    (a4),d0
  ' 660C                           bne.s     weg
  ' 95CD                           sub.l     a5,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 66BA                           bne.s     anf2
  ' BC82                           cmp.l     d2,d6
  ' 6600FF48                       bne       anf
  ' 285F                 weg:      move.l    (sp)+,a4
  ' 2886                           move.l    d6,(a4)
  ' 4BFA0039                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA0016                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 33FC000100000184     neuikbd:  move.w    #1,merk
  ' 4EF90000017C         rett:     jmp       rett
  ' 12                   ptr:      DC.b $12
  ' 08                   ptr2:     DC.b $8
  ' 0000                 merk:     DC.w 0
  '
anfymasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H242F,&H0048
  DATA &H2A2F,&H004C
  DATA &H2E2F,&H0050
  DATA &H2A6F,&H0054
  DATA &H286F,&H0058
  DATA &H2F0C
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H014E
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H4BFA,&H0112
  DATA &H2B68,&H0020,&H0002
  DATA &H4BFA,&H0100
  DATA &H214D,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H49FA,&H0104
  DATA &H220B
  DATA &H7C00
  DATA &H7804
  DATA &H7608
  DATA &H5286
  DATA &H244B
  DATA &HD5C5
  DATA &H48E7,&HFFFC
  DATA &H3F3C,&H0001
  DATA &H3F07
  DATA &H2005
  DATA &HD080
  DATA &H4480
  DATA &H2F00
  DATA &H3F3C,&H0042
  DATA &H4E41
  DATA &H4FEF,&H000A
  DATA &H2F0B
  DATA &H2F05
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H3FFF
  DATA &H1010
  DATA &H0200,&H0008
  DATA &H6730
  DATA &H2F01
  DATA &H303C,&H03FF
  DATA &H95FC,&H0000,&H0004
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H95FC,&H0000,&H0004
  DATA &H51C8,&HFFDA
  DATA &H221F
  DATA &H95FC,&H0000,&H0004
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H95FC,&H0000,&H0004
  DATA &H3014
  DATA &H660C
  DATA &H95CD
  DATA &HB5C1
  DATA &H66BA
  DATA &HBC82
  DATA &H6600,&HFF48
  DATA &H285F
  DATA &H2886
  DATA &H4BFA,&H0039
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H0016
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H0184
  DATA &H4EF9,&H0000,&H017C
  DATA &H1208
  DATA &H0000
  '
  RESTORE anfymasch
  FOR g=0 TO 388 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  LPOKE mdat2%+376,mdat2%+388
RETURN
'
> PROCEDURE maschruf25
  ' HARD-RPLAY
  '
  @busy_mouse
  sbd%=VARPTR(pa$)        !Pfad
  scd%=sectors            !sectors
  sdd%=flen               !len
  sde%=handle
  sdf%=over
  back%=0
  sdg%=VARPTR(back%)
  IF demo=FALSE THEN
    ~C:mdat2%(L:mdat%,L:sbd%,L:scd%,L:sdd%,L:sde%,L:sdf%,L:sdg%)
  ENDIF
RETURN
'
> PROCEDURE maschinit26
  ' MIDI-HARDPLAY
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       movea.l   68(sp),a6  ; fname --> schwachsinn, da unbenutzt
  ' 286F0048                       move.l    72(sp),a4 ; sectors
  ' 2A2F004C                       move.l    76(sp),d5 ; len
  ' 2E2F0050                       move.l    80(sp),d7 ; handle
  ' 2A6F0054                       move.l    84(sp),a5 ; adder
  ' 206F0058                       move.l    88(sp),a0 ; Returnwert
  ' 242F005C                       move.l    92(sp),d2 ; midi
  ' 2F08                           move.l    a0,-(sp)
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA015A                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 41F900DF0441                   lea.l     $df0441,a0          ; Flagstatus
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 220B                           move.l    a3,d1     ; MEMende
  ' D285                           add.l     d5,d1
  ' 7C00                           moveq.l   #0,d6
  ' 7804                           moveq.l   #4,d4
  ' 7608                           moveq.l   #8,d3
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                           movea.l   a3,a2
  ' 48E7FFFC                       movem.l   d0-d7/a0-a5,-(sp)
  ' 2F0B                           move.l    a3,-(sp)  ; Fread
  ' 2F05                           move.l    d5,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF3FFF                       movem.l   (sp)+,d0-d7/a0-a5
  ' 1010                           move.b    (a0),d0   ; FIFO halbleer ?
  ' 02000008                       andi.b    #8,d0
  ' 6724                           beq.s     anf2
  ' 2F01                           move.l    d1,-(sp)
  ' 303C03FF                       move.w    #$3ff,d0     ; ...dann FIFO halb-fuellen (FIFO-LEN/2/4-1)!
  ' 121A                 copy:     move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 51C8FFE6                       dbra      d0,copy
  ' 221F                           move.l    (sp)+,d1
  ' 1010                 anf2:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf2
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf3
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf4
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf5:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf5
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 48E77FFE                       movem.l   d1-a6,-(sp)
  ' 3F3C0003                       move.w    #3,-(sp)  ; MIDI
  ' 3F3C0001                       move.w    #1,-(sp)  ; Bconstat
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' B07C0000                       cmp.w     #0,d0
  ' 676C                           beq.s     nomidi
  ' 3F3C0003                       move.w    #3,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)  ; Bconin
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-a6
  ' 48E77FFE                       movem.l   d1-a6,-(sp)
  ' 4BFA008E                       lea.l     midiw(pc),a5
  ' 08000007                       btst      #7,d0
  ' 6708                           beq.s     midi2     ; Daten oder Befehl ?
  ' E042                           asr.w     #8,d2     ; Channel im oberen Byte des Wortes
  ' 9002                           sub.b     d2,d0     ; Channel vom Befehl abziehen
  ' 1A80                           move.b    d0,(a5)   ; Befehl schreiben
  ' 6046                           bra.s     nomidi
  ' B002                 midi2:    cmp.b     d2,d0       ; Noten-DATA ?
  ' 671E                           beq.s     midi4
  ' B42D0001                       cmp.b     1(a5),d2    ; Noten-data schon gewesen und korrekt ?
  ' 663C                           bne.s     nomidi
  ' 1B400002             midi3:    move.b    d0,2(a5)    ; Velocitywert schreiben
  ' 0C150080                       cmp.b     #$80,(a5)   ; NOTE OFF ?
  ' 671A                           beq.s     midi5
  ' 0C150090                       cmp.b     #$90,(a5)   ; NOTE ON ?
  ' 671C                           beq.s     midi6
  ' 2ABC00000000         midi3b:   move.l    #0,(a5)     ; Datenwort lîschen
  ' 6024                           bra.s     nomidi
  ' B42D0001             midi4:    cmp.b     1(a5),d2  ; Noten-DATA schon gewesen ?
  ' 67E2                           beq.s     midi3     ; dann ist es nicht Note sondern Velocity
  ' 1B400001                       move.b    d0,1(a5)  ; Notenwert schreiben
  ' 6018                           bra.s     nomidi
  ' B42D0001             midi5:    cmp.b     1(a5),d2  ; NOTE OFF und Note OK ?
  ' 66E6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 6026                           bra.s     weg2      ; Abbruch, da NOTE OFF !
  ' B42D0001             midi6:    cmp.b     1(a5),d2  ; NOTE ON und Note OK ?
  ' 66DE                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 0C2D00000002                   cmp.b     #0,2(a5)  ; Velocity ist Null ?
  ' 66D6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 6016                           bra.s     weg2      ; Abbruch, da NOTE ON und Velo=Null !
  ' 4CDF7FFE             nomidi:   movem.l   (sp)+,d1-a6
  ' D5CD                           add.l     a5,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 6600FF44                       bne       anf2
  ' BC8C                           cmp.l     a4,d6
  ' 6600FEF6                       bne       anf
  ' 60000006                       bra       weg
  ' 4CDF7FFE             weg2:     movem.l   (sp)+,d1-a6
  ' 205F                 weg:      move.l    (sp)+,a0
  ' 2086                           move.l    d6,(a0)
  ' 4BFA0017                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 00000000             midiw:    dc.l 0
  '
anfzmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H286F,&H0048
  DATA &H2A2F,&H004C
  DATA &H2E2F,&H0050
  DATA &H2A6F,&H0054
  DATA &H206F,&H0058
  DATA &H242F,&H005C
  DATA &H2F08
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H015A
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H4CDF,&H7FFF
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H220B
  DATA &HD285
  DATA &H7C00
  DATA &H7804
  DATA &H7608
  DATA &H5286
  DATA &H244B
  DATA &H48E7,&HFFFC
  DATA &H2F0B
  DATA &H2F05
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H3FFF
  DATA &H1010
  DATA &H0200,&H0008
  DATA &H6724
  DATA &H2F01
  DATA &H303C,&H03FF
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H51C8,&HFFE6
  DATA &H221F
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &HB07C,&H0000
  DATA &H676C
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0002
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H7FFE
  DATA &H48E7,&H7FFE
  DATA &H4BFA,&H008E
  DATA &H0800,&H0007
  DATA &H6708
  DATA &HE042
  DATA &H9002
  DATA &H1A80
  DATA &H6046
  DATA &HB002
  DATA &H671E
  DATA &HB42D,&H0001
  DATA &H663C
  DATA &H1B40,&H0002
  DATA &H0C15,&H0080
  DATA &H671A
  DATA &H0C15,&H0090
  DATA &H671C
  DATA &H2ABC,&H0000,&H0000
  DATA &H6024
  DATA &HB42D,&H0001
  DATA &H67E2
  DATA &H1B40,&H0001
  DATA &H6018
  DATA &HB42D,&H0001
  DATA &H66E6
  DATA &H6026
  DATA &HB42D,&H0001
  DATA &H66DE
  DATA &H0C2D,&H0000,&H0002
  DATA &H66D6
  DATA &H6016
  DATA &H4CDF,&H7FFE
  DATA &HD5CD
  DATA &HB5C1
  DATA &H6600,&HFF44
  DATA &HBC8C
  DATA &H6600,&HFEF6
  DATA &H6000,&H0006
  DATA &H4CDF,&H7FFE
  DATA &H205F
  DATA &H2086
  DATA &H4BFA,&H0017
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H1208
  DATA &H0000,&H0000
  '
  RESTORE anfzmasch
  FOR g=0 TO 394 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf26
  ' MIDI-HARDPLAY
  '
  @busy_mouse
  sbd%=VARPTR(pa$)        !Pfad
  scd%=sectors            !sectors
  sdd%=flen               !len
  sde%=handle
  sdf%=over
  back%=0
  sdg%=VARPTR(back%)
  sda%=midiwort
  IF demo=FALSE THEN
    ~C:mdat2%(L:mdat%,L:sbd%,L:scd%,L:sdd%,L:sde%,L:sdf%,L:sdg%,L:sda%)
  ENDIF
RETURN
'
> PROCEDURE maschinit27
  mdat3%=mdat2%+500
  ' MIDI-HARDBACKPLAY
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       move.l    68(sp),a6 ; sectors
  ' 2A2F0048                       move.l    72(sp),d5 ; len
  ' 2E2F004C                       move.l    76(sp),d7 ; handle
  ' 2A6F0050                       move.l    80(sp),a5 ; subber
  ' 206F0054                       move.l    84(sp),a0 ; Returnwert
  ' 242F0058                       move.l    88(sp),d2 ; midi
  ' 2F08                           move.l    a0,-(sp)
  ' 41F900DF0441                   lea.l     $df0441,a0          ; Flagstatus
  ' 43F900DF04C0                   lea.l     $df04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA017C                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 220B                           move.l    a3,d1     ; MEManf
  ' 7C00                           moveq.l   #0,d6
  ' 7804                           moveq.l   #4,d4
  ' 7608                           moveq.l   #8,d3
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                           movea.l   a3,a2
  ' D5C5                           add.l     d5,a2     ; auf MEMende setzen
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)  ; Fseek
  ' 3F07                           move.w    d7,-(sp)
  ' 2005                           move.l    d5,d0
  ' D080                           add.l     d0,d0
  ' 4480                           neg.l     d0
  ' 2F00                           move.l    d0,-(sp)
  ' 3F3C0042                       move.w    #66,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000A                       lea.l     $a(sp),sp
  ' 2F0B                           move.l    a3,-(sp)  ; Fread
  ' 2F05                           move.l    d5,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 1010                           move.b    (a0),d0   ; FIFO halbleer ?
  ' 02000008                       andi.b    #8,d0
  ' 6730                           beq.s     anf2
  ' 2F01                           move.l    d1,-(sp)
  ' 303C03FF                       move.w    #$3ff,d0     ; ...dann FIFO halb-fuellen (FIFO-LEN/2/4-1)!
  ' 95FC00000004         copy:     suba.l    #4,a2
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 0781                           bclr      d3,d1     ; Rechter Kanal (Bit 8 geloescht)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; High-Byte senden
  ' 121A                           move.b    (a2)+,d1
  ' 07C1                           bset      d3,d1     ; Linker Kanal (Bit 8 gesetzt)
  ' 3281                           move.w    d1,(a1)   ; Low-Byte senden
  ' 95FC00000004                   suba.l    #4,a2
  ' 51C8FFDA                       dbra      d0,copy
  ' 221F                           move.l    (sp)+,d1
  ' 95FC00000004         anf2:     suba.l    #4,a2
  ' 1010                 anf2b:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf2b
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf3:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf3
  ' 101A                           move.b    (a2)+,d0
  ' 0780                           bclr      d3,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 1010                 anf4:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf4
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 anf5:     move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     anf5
  ' 101A                           move.b    (a2)+,d0
  ' 07C0                           bset      d3,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 48E77FFE                       movem.l   d1-a6,-(sp)
  ' 3F3C0003                       move.w    #3,-(sp)  ; MIDI
  ' 3F3C0001                       move.w    #1,-(sp)  ; Bconstat
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' B07C0000                       cmp.w     #0,d0
  ' 676C                           beq.s     nomidi
  ' 3F3C0003                       move.w    #3,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)  ; Bconin
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-a6
  ' 48E77FFE                       movem.l   d1-a6,-(sp)
  ' 4BFA0092                       lea.l     midiw(pc),a5
  ' 08000007                       btst      #7,d0
  ' 6708                           beq.s     midi2     ; Daten oder Befehl ?
  ' E042                           asr.w     #8,d2     ; Channel im oberen Byte des Wortes
  ' 9002                           sub.b     d2,d0     ; Channel vom Befehl abziehen
  ' 1A80                           move.b    d0,(a5)   ; Befehl schreiben
  ' 6046                           bra.s     nomidi
  ' B002                 midi2:    cmp.b     d2,d0       ; Noten-DATA ?
  ' 671E                           beq.s     midi4
  ' B42D0001                       cmp.b     1(a5),d2    ; Noten-data schon gewesen und korrekt ?
  ' 663C                           bne.s     nomidi
  ' 1B400002             midi3:    move.b    d0,2(a5)    ; Velocitywert schreiben
  ' 0C150080                       cmp.b     #$80,(a5)   ; NOTE OFF ?
  ' 671A                           beq.s     midi5
  ' 0C150090                       cmp.b     #$90,(a5)   ; NOTE ON ?
  ' 671C                           beq.s     midi6
  ' 2ABC00000000         midi3b:   move.l    #0,(a5)     ; Datenwort lîschen
  ' 6024                           bra.s     nomidi
  ' B42D0001             midi4:    cmp.b     1(a5),d2  ; Noten-DATA schon gewesen ?
  ' 67E2                           beq.s     midi3     ; dann ist es nicht Note sondern Velocity
  ' 1B400001                       move.b    d0,1(a5)  ; Notenwert schreiben
  ' 6018                           bra.s     nomidi
  ' B42D0001             midi5:    cmp.b     1(a5),d2  ; NOTE OFF und Note OK ?
  ' 66E6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 602A                           bra.s     weg2      ; Abbruch, da NOTE OFF !
  ' B42D0001             midi6:    cmp.b     1(a5),d2  ; NOTE ON und Note OK ?
  ' 66DE                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 0C2D00000002                   cmp.b     #0,2(a5)  ; Velocity ist Null ?
  ' 66D6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 601A                           bra.s     weg2      ; Abbruch, da NOTE ON und Velo=Null !
  ' 4CDF7FFE             nomidi:   movem.l   (sp)+,d1-a6
  ' 95FC00000004                   suba.l    #4,a2
  ' 95CD                           sub.l     a5,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 6600FF38                       bne       anf2
  ' BC8E                           cmp.l     a6,d6
  ' 6600FEC4                       bne       anf
  ' 6004                           bra.s     weg
  ' 4CDF7FFE             weg2:     movem.l   (sp)+,d1-a6
  ' 205F                 weg:      move.l    (sp)+,a0
  ' 2086                           move.l    d6,(a0)      ; RÅckgabewert
  ' 4BFA0017                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 12                   ptr:      dc.b $12
  ' 08                   ptr2:     Dc.b $8
  ' 00000000             midiw:    dc.l 0
  '
anfaamasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H2A2F,&H0048
  DATA &H2E2F,&H004C
  DATA &H2A6F,&H0050
  DATA &H206F,&H0054
  DATA &H242F,&H0058
  DATA &H2F08
  DATA &H41F9,&H00DF,&H0441
  DATA &H43F9,&H00DF,&H04C0
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H017C
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H4CDF,&H7FFF
  DATA &H220B
  DATA &H7C00
  DATA &H7804
  DATA &H7608
  DATA &H5286
  DATA &H244B
  DATA &HD5C5
  DATA &H48E7,&HFFFE
  DATA &H3F3C,&H0001
  DATA &H3F07
  DATA &H2005
  DATA &HD080
  DATA &H4480
  DATA &H2F00
  DATA &H3F3C,&H0042
  DATA &H4E41
  DATA &H4FEF,&H000A
  DATA &H2F0B
  DATA &H2F05
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H7FFF
  DATA &H1010
  DATA &H0200,&H0008
  DATA &H6730
  DATA &H2F01
  DATA &H303C,&H03FF
  DATA &H95FC,&H0000,&H0004
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H0781
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H121A
  DATA &H07C1
  DATA &H3281
  DATA &H95FC,&H0000,&H0004
  DATA &H51C8,&HFFDA
  DATA &H221F
  DATA &H95FC,&H0000,&H0004
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0780
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H07C0
  DATA &H3280
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &HB07C,&H0000
  DATA &H676C
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0002
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H7FFE
  DATA &H48E7,&H7FFE
  DATA &H4BFA,&H0092
  DATA &H0800,&H0007
  DATA &H6708
  DATA &HE042
  DATA &H9002
  DATA &H1A80
  DATA &H6046
  DATA &HB002
  DATA &H671E
  DATA &HB42D,&H0001
  DATA &H663C
  DATA &H1B40,&H0002
  DATA &H0C15,&H0080
  DATA &H671A
  DATA &H0C15,&H0090
  DATA &H671C
  DATA &H2ABC,&H0000,&H0000
  DATA &H6024
  DATA &HB42D,&H0001
  DATA &H67E2
  DATA &H1B40,&H0001
  DATA &H6018
  DATA &HB42D,&H0001
  DATA &H66E6
  DATA &H602A
  DATA &HB42D,&H0001
  DATA &H66DE
  DATA &H0C2D,&H0000,&H0002
  DATA &H66D6
  DATA &H601A
  DATA &H4CDF,&H7FFE
  DATA &H95FC,&H0000,&H0004
  DATA &H95CD
  DATA &HB5C1
  DATA &H6600,&HFF38
  DATA &HBC8E
  DATA &H6600,&HFEC4
  DATA &H6004
  DATA &H4CDF,&H7FFE
  DATA &H205F
  DATA &H2086
  DATA &H4BFA,&H0017
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H1208
  DATA &H0000,&H0000
  '
  RESTORE anfaamasch
  FOR g=0 TO 436 STEP 2
    READ a
    DPOKE mdat3%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf27
  ' MIDI-HARDBACKPLAY
  '
  @busy_mouse
  scd%=sectors            !sectors
  sdd%=flen               !len
  sde%=handle
  sdf%=over
  back%=0
  sdg%=VARPTR(back%)
  sda%=midiwort
  IF demo=FALSE THEN
    ~C:mdat3%(L:mdat%,L:scd%,L:sdd%,L:sde%,L:sdf%,L:sdg%,L:sda%)
  ENDIF
RETURN
'
> PROCEDURE maschinit28
  ' LOAD INTEL-DATA
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 7000                           moveq.l   #0,d0
  ' 3010                 anf2:     move.w    (a0),d0
  ' 10C0                           move.b    d0,(a0)+
  ' E040                           asr.w     #8,d0
  ' 10C0                           move.b    d0,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DF4                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  '
anfabmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H7000
  DATA &H3010
  DATA &H10C0
  DATA &HE040
  DATA &H10C0
  DATA &HB1C9
  DATA &H6DF4
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfabmasch
  FOR g=0 TO 30 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf28(start,datalen)
  ' LOAD-INTEL-DATA
  '
  @busy_mouse
  sad%=start
  sbd%=start+datalen
  ~C:mdat2%(L:sad%,L:sbd%)
RETURN
'
> PROCEDURE maschinit29
  ' COPYBACK
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; dest
  ' 2449                           move.l    a1,a2
  ' 598A                 anf2:     subq.l    #4,a2
  ' 22D2                           move.l    (a2),(a1)+
  ' B5C8                           cmp.l     a0,a2
  ' 6EF8                           bgt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  '
anfacmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H2449
  DATA &H598A
  DATA &H22D2
  DATA &HB5C8
  DATA &H6EF8
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfacmasch
  FOR g=0 TO 26 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf29(start,dest)
  ' COPYBACK
  '
  @busy_mouse
  sad%=start
  sbd%=dest
  ~C:mdat2%(L:sad%,L:sbd%)
RETURN
'
' ------------------------------------------------------------------------------
' ------------------------FLYDIALS--------------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE key
  ' Mîchten Sie erweiterte Tastaturkommandos? Dann entREMen Sie
  ' diese Zeile und ersetzen die Prozedur durch:
  '  cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  '
  ~WIND_GET(MENU(4),10,mrkhandle2,v1,v2,v3)
  '  ~WIND_GET(mrkhandle,10,mrkhandle2,v1,v2,v3)
  '
  a=MENU(13)
  b=MENU(14)
  ascii|=(b AND 255)
  scan|=INT(b/256)
  key&=b
  '  ascii|=BYTE(key&)                                  ! ASCII-Code
  ' scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
  '
  rsc_adr%=rsc_adr%(nr)
  IF ascii|=0                                        ! Kein ASCII-Code...
    '
    IF scan|=97 OR scan|=98                          ! UNDO/HELP...
      ascii|=ADD(SUB(scan|,97),14)
      obj&=0
      '
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
      '
      IF BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE IF scan|>=59 AND scan|<=68                  ! F-Tasten...
      ascii|=SUB(scan|,58)
      obj&=0
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
      IF SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE                                             ! ALT+Buchstabe...
      '
      IF scan|>=120 AND scan|<=129                   ! Zahlen...
        SUB scan|,118
        keytab%={XBIOS(16,L:-1,L:-1,L:-1)}           ! ...ohne Shift
      ELSE                                           ! Alles andere...
        keytab%={ADD(XBIOS(16,L:-1,L:-1,L:-1),4)}    ! ...mit Shift
      ENDIF
      '
      ascii|=BYTE{ADD(keytab%,scan|)}                ! ASCII-Code holen
      IF ascii|<>0                                      ! Tastaturbedienbar...
        CLR a&,obj&
        '
        DO WHILE NOT BTST(OB_FLAGS(rsc_adr%,obj&),5) ! Nicht LASTOBJ
          INC obj&
          '
          scan|=BYTE(SHR(OB_TYPE(rsc_adr%,obj&),8))
          IF scan|=26 OR scan|=28                    ! Ein Button/String...
            a$=@rsc_text$(tree&,obj&)                ! ...Text
            '
            a&=INSTR(a$,"[")
            IF a&                                    ! Tastaturbedienbar...
              a&=ASC(MID$(a$,SUCC(a&),1))
              a&=(BCLR(a&,5)=ascii|) OR (a&>=48 AND a&<=57 AND a&=ascii|)
            ENDIF
            '                                        ! '[' vor Zeichen
          ENDIF
          '
        LOOP UNTIL a&                                ! ...gefunden
        '
        IF a&                                        ! Objekt gefunden...
          key&=0                                     ! ...keine Eingabe mehr
          '                                          ! +SHIFT Circle-Butt?
          IF BTST(shift&,1) AND BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5) AND SHR(OB_TYPE(rsc_adr%,obj&+2),8)=27
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simulieren
            ~OBJC_OFFSET(rsc_adr%,obj&+2,mx&,my&)
            '                                        ! Ist es ein Popup...
          ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5)
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simul.
            ~OBJC_OFFSET(rsc_adr%,obj&,mx&,my&)
          ELSE                                       ! ...Button bedienen
            cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
          ENDIF
        ENDIF
        '
      ENDIF
    ENDIF
    '
  ENDIF
  '
  IF key&
    ~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,2,idx&)  ! ...Eingabe
  ENDIF
  obj=obj&
  '
RETURN
> PROCEDURE message
  handle&=MENU(4)                                    ! ...Fenster-Handle
  ~WIND_GET(handle&,10,mrkhandle2,v1,v2,v3)
  '
  FOR a&=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
    EXIT IF handle&=rsc_handle%(a&)
  NEXT a&
  '
  IF MENU(1)=&H4724 THEN
    accwindopen=TRUE
  ENDIF
  IF MENU(1)=41 OR (MENU(1)=22 AND tree&=a&)         ! AC_CLOSE/Closer...
    MUL rsc_window&,-(MENU(1)=22)
    '
    next_obj&=exit&                          ! ...Exit-Code
    '
    GOTO rsc_dox_ende                                 ! ...rsc_do verlassen
    '
  ELSE IF a&>-1 AND NOT (MENU(1)=21 AND a&<>tree&)   ! Ein RSC-Fenster....
    rsc_message(a&,MENU(1),MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    '
  ELSE IF MENU(1)=40 OR MENU(1)=21                   ! AC_OPEN/Anderes Fenster toppen...
    rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
  ELSE IF MENU(1)<>21 AND MENU(1)<>22                ! nicht toppen/schlieûen...
    '    message_auswerten(MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
  ELSE                                               ! Nichts zu machen...
    ~BIOS(3,2,7)
  ENDIF
  IF (MENU(1)=20 OR MENU(1)=21) AND nr=smpedit& THEN
    IF mrkhandle=mrkhandle2 THEN
      v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
      IF v<>0 AND kenn=mrkhandle2 THEN
        @curve(cs,ce)
        @markprod3
      ENDIF
    ENDIF
  ENDIF
rsc_dox_ende:
  '  RETURN next_obj&
RETURN
> PROCEDURE button
  LOCAL popok
  ~GRAF_MKSTATE(mx&,my&,mb&,shift&)
  mrkhandle2=WIND_FIND(mx&,my&)
  IF mrkhandle=mrkhandle2 THEN
    v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
    IF v<>0 AND kenn=mrkhandle2 THEN
      next_obj&=OBJC_FIND(rsc_adr%,0,100,mx&,my&)
      '                                                  ! String vor Popup...
      IF next_obj&>0
        IF BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND SHR(OB_TYPE(rsc_adr%,next_obj&),8)=28 AND BTST(OB_STATE(rsc_adr%,SUCC(next_obj&)),5)
          ' (TOUCHEXIT, STRING, SUCC: SHADOWED)
          INC next_obj&
        ENDIF
      ENDIF
      '
      IF next_obj&=-1                                    ! Neben die Box...
        '    SOUND 1,15,10,4,10
        '   SOUND 0,0,0,0,0
        next_obj&=0
        '
      ELSE
        cont&=FORM_BUTTON(rsc_adr%,next_obj&,1,next_obj&)
        ' ------------------------------------------------ Flydial-Ecke
        IF BTST(OB_STATE(rsc_adr%,next_obj&),1)          ! (CROSSED)
          rsc_movedial(tree&,edit_obj&,idx&)             ! ...Dialog verschieben
          '
          next_obj&=0                                    ! Damit der Cursor..
          cont&=1                                        ! ..bleibt wo er ist
          ' ---------------------------------------------- Circle-Button...
        ELSE IF SHR(OB_TYPE(rsc_adr%,next_obj&),8)=27 AND BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),5) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),3))
          ' (G_BOXCHAR, PRED: SHADOWED /NOT DISABLED)
          next_obj&=PRED(next_obj&)                      ! Objektnr. Button
          a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
          evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
          '
          obj&=1
          FOR ob_tail&=1 TO PRED(evnt&)
            obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
          NEXT ob_tail&
          '
          evnt&=SUCC(obj&)
          b$=@rsc_text$(rsc_popup&,evnt&)
          DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
            INC evnt&                                    ! Defaulteintrag
          LOOP
          '
          REPEAT
            INC evnt&                                    ! NÑchster Eintrag...
            IF evnt&>OB_TAIL(rsc_adr%(rsc_popup&),obj&)  ! ...gibt es nicht
              evnt&=SUCC(obj&)                           ! ...dann wieder 1.
            ENDIF
            '                                            ! bis nicht DISABLED
          UNTIL NOT BTST(OB_STATE(rsc_adr%(rsc_popup&),evnt&),3)
          '                                              ! Button Ñndern...
          rsc_text(tree&,next_obj&,@rsc_text$(rsc_popup&,evnt&))
          ~OBJC_DRAW(rsc_adr%,next_obj&,1,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
          popup&=SUB(evnt&,obj&)
          REPEAT
            ~GRAF_MKSTATE(v,v2,v3,v4)
          UNTIL v3=0
          ' ---------------------------------------------- Popup-Menue...
        ELSE IF BTST(OB_STATE(rsc_adr%,next_obj&),5) AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND (NOT BTST(OB_STATE(rsc_adr%,next_obj&),3))
          popok=FALSE
          IF ((next_obj&=rate& OR next_obj&=mover&) AND nr=smpedit&) THEN
            popok=TRUE
          ENDIF
          IF ((next_obj&=input& OR next_obj&=source& OR next_obj&=dsp& OR next_obj&=rate2&) AND nr=smp16&) THEN
            popok=TRUE
          ENDIF
          IF next_obj&=makerate& AND nr=arrmake& THEN
            popok=TRUE
          ENDIF
          IF popok=TRUE THEN
            ' (SHADOWED, TOUCHEXIT, NOT DISABLED)
            evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
            obj&=1
            FOR ob_tail&=1 TO PRED(evnt&)
              obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
            NEXT ob_tail&
            ob_tail&=OB_TAIL(rsc_adr%(rsc_popup&),obj&)
            a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
            evnt&=SUCC(obj&)
            DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
              INC evnt&                                    ! Ausrichtung ermitteln
            LOOP UNTIL evnt&>ob_tail&
            '
            IF evnt&<=ob_tail&                             ! Defaulteintrag...
              popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,SUB(evnt&,SUCC(obj&)))
            ELSE                                           ! Sonst ohne...
              IF tree&=smpedit& OR tree&=make& THEN
                popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,1)
              ENDIF
            ENDIF
            IF popup&=0                                    ! Abbruch...
              cont&=1                                      ! ...weiter geht's
              next_obj&=0                                  ! ...Cursor 'festhalten'
            ENDIF
          ENDIF
          ' ---------------------------------------------- Cursor positionieren
          ' Mîchten Sie den Cursor mit der Maus zeichengenau positionieren?
          ' Dann entREMen Sie diese Zeilen und laden diese Prozedur nach:
        ELSE IF BTST(OB_FLAGS(rsc_adr%,next_obj&),3)
          '      rsc_set_cursor(rsc_adr%,mx&,my&,edit_obj&,next_obj&,idx&)
        ENDIF
        '
      ENDIF
      IF cont&=0 OR (next_obj&<>0 AND next_obj&<>edit_obj&)
        ~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
      ENDIF
    ENDIF
  ENDIF
RETURN
> PROCEDURE rsc_init
  LOCAL a&
  '
  ' Initialisiert die von den RSC-Routinen benîtigten Variablen...
  '
  ap_id&=APPL_INIT()                         ! Applikations-ID
  '
  rsc_aes&=INT{{ADD(GB,4)}}                  ! AES-Version
  rsc_mtsk!=INT{ADD({ADD(GB,4)},2)}<>1       ! Multitasking?
  rsc_alert&=-1                              ! Noch keine fliegenden Alerts
  '
  CONTRL(6)=GRAF_HANDLE(wchar&,hchar&,a&,a&) ! AES-Handle, Zeichenbreite/Hîhe
  rsc_vh&=V_OPNVWK(1)                        ! Virt.Workst. fÅr Flydials îffnen
  IF rsc_vh&=0
    rsc_vh&=V~H                              ! ...Fehler, dann eben die alte
  ENDIF
  CONTRL(6)=V~H
  '
  INTIN(0)=1
  VDISYS 102,1,0
  planes&=INTOUT(4)                          ! Bitplanes
  '
  ~WIND_GET(0,7,deskx&,desky&,deskw&,deskh&) ! Hintergrundfenster
  ' ------------------------------------------------------ Inline vorbereiten
  INLINE rsc_flyd%,2834
  '
  rsc_bitblt%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,16)})      ! BITBLT-Routine
  rsc_obspec%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,18)})      ! OB_SPEC-Routine...
  rsc_cookie%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,20)})      ! COOKIE-Routine...
  '
  {ADD(rsc_flyd%,22)}=ADD(GB,24)                         ! VDI-Parameterblock
  INT{ADD(rsc_flyd%,26)}=rsc_vh&                         ! Virt. Workstation
  INT{ADD(rsc_flyd%,28)}=wchar&                          ! Zeichenzellenbreite
  INT{ADD(rsc_flyd%,30)}=hchar&                          ! Zeichenzellenhîhe
  ' ------------------------------------------------------
  ' Berechnet den Speicherbedarf einer Bitmap-Grafik...
  DEFFN getsize(w&,h&)=SHL(SHR(ADD(MUL(MUL(SHR(ADD(w&,15),3),h&),planes&),255),8),8)
  '
  ' GegenstÅck zur Prozedur rsc_text: Universelles Objekt-Text auslesen...
  DEFFN rsc_text$(tree&,obj&)=CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}
  '
RETURN
> PROCEDURE rsc_exit
  '
  CONTRL(6)=rsc_vh&
  VDISYS 38,0,0                              ! vqt_attributes
  IF ABS(INTOUT(0))<>1                       ! Anderer AES-Zeichensatz (MTOS)...
    ~VST_UNLOAD_FONTS(0)                     ! ...freigeben
  ENDIF
  '
  IF rsc_vh&<>V~H                            ! Flydial-Workstation freigeben...
    ~V_CLSVWK()
  ENDIF
  '
  ' Die folgenden Zeilen sind nur im Interpreter relevant und kînnen im
  ' Compilat wegfallen. Tip: Mit dem ERGO!pro-PrÑprozessor ausblenden.
  '
  ~RSRC_FREE()                               ! Resource entfernen
  '
  IF popup_back%
    ~MFREE(popup_back%)                      ! Popup-Hintergrund freigeben
  ENDIF
  '
  IF rsc_userblk%
    ~MFREE(rsc_userblk%)                     ! Userblks freigeben
  ENDIF
  '
RETURN
> FUNCTION rsc_laden(file$,trees&,popup&,menu&,alert&)
$F%
LOCAL tree&,obj&,font_h&,font_id&,color3d&,a%
popup_back%=0
'
' LÑdt die Resource und initialisiert einige globale Variablen...
' ------------------------------------------------------ RSC laden
' Wollen Sie das RSC-File direkt im Programmcode 'aufbewahren'?
' Dann entREMen Sie diese Zeilen und laden Sie die Funktion
' 'rsc_conv' aus EXTENDED.LST hinzu...
' INLINE rsc%,3160
' IF @rsrc_conv(rsc%)=0
IF @xrsrc_load(file$)=0
  ~FORM_ALERT(1,"[3][ | Fehler beim Laden | der RSC-Datei! | ][Abbruch]")
  RETURN FALSE
ENDIF
' ------------------------------------------------------
IF auflauf>1 THEN
  ERASE rsc_adr%()
  ERASE rsc_handle%()
  ERASE rscx&()
  ERASE rscy&()
  ERASE rscw&()
  ERASE rsch&()
ENDIF
DIM rsc_adr%(trees&),rsc_handle%(trees&)
DIM rscx&(trees&),rscy&(trees&),rscw&(trees&),rsch&(trees&)
'
rsc_trees&=trees&                                      ! Anzahl ObjektbÑume-1
rsc_popup&=popup&                                      ! Popup-Baum
rsc_menu&=menu&                                        ! Dropdown-Baum
rsc_alert&=alert&                                      ! Alert-Baum
' ------------------------------------------------------
' Die folgenden Zeilen sind nur nîtig, wenn das Resource-File ALERT-
' oder FREE-BÑume enthÑlt. NÑheres in der Doku.
' alerts&=trees&-SUCC(rsc_alert&)                        ! Alerts & Free Strings...
' FOR tree&=0 TO alerts&
' ~RSRC_GADDR(5,tree&,a%)
' rsc_adr%(rsc_alert&+SUCC(tree&))=a%
' NEXT tree&
' trees&=rsc_alert&
' ------------------------------------------------------ Adressen ermitteln
FOR tree&=0 TO trees&
  '
  ~@xrsrc_gaddr(0,tree&,a%)  ! Kompatibel zu den XRSRC-Routinen
  rsc_adr%(tree&)=a%
  IF tree&<>menu&
    ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
  ENDIF
  '
NEXT tree&
' ------------------------------------------------------ Grîûtes Popup
IF popup&>-1
  obj&=1
  WHILE obj&>0
    popup_back%=MAX(popup_back%,@getsize(ADD(OB_W(rsc_adr%(popup&),obj&),21),OB_H(rsc_adr%(popup&),obj&)))
    obj&=OB_NEXT(rsc_adr%(popup&),obj&)
  WEND
  popup_back%=MALLOC(popup_back%)                      ! Hintergrundpuffer...
  IF popup_back%=0
    RETURN FALSE                                       ! ...nicht geklappt
  ENDIF
ENDIF
' ------------------------------------------------------ Anderer Zeichensatz
IF rsc_aes&>=&H400 OR APPL_FIND("?API")=0              ! Hat APPL_GETINFO()...
  '
  GCONTRL(0)=130
  GCONTRL(1)=1
  GCONTRL(2)=5
  GCONTRL(3)=0
  GCONTRL(4)=0
  GINTIN(0)=0
  '
  GEMSYS                                               ! APPL_GETINFO()
  '
  IF GINTOUT(0)=1                                      ! Hat geklappt...
    font_h&=GINTOUT(1)                                 ! AES-Font Hîhe
    font_id&=GINTOUT(2)                                ! AES-Font ID
    '
    IF ABS(font_id&)<>1 AND GDOS?<>0                   ! Anderer AES-Font...
      V~H=rsc_vh&
      ~VST_LOAD_FONTS(0)                               ! ...Fonts laden
      DEFTEXT ,,,,font_id&
      DEFTEXT ,,,font_h&                               ! ...und einstellen
      V~H=-1
    ENDIF
  ENDIF
ENDIF
' ------------------------------------------------------ 3D-Darstellung
IF rsc_aes&>=&H340                                     ! Ab AES 3.40...
  GCONTRL(0)=48
  GCONTRL(1)=4
  GCONTRL(2)=3
  GCONTRL(3)=0
  GCONTRL(4)=0
  '
  GINTIN(0)=0                                          ! Inquire
  GINTIN(1)=5                                          ! Background
  '
  GEMSYS                                               ! OBJC_SYSVAR()
  '
  IF GINTOUT(0)>0                                      ! Hat geklappt...
    color3d&=GINTOUT(1)                                ! ...3D-Farbe
  ENDIF
  IF dreidim=0 THEN
    color3d&=0
  ENDIF
ENDIF
' ------------------------------------------------------
INT{ADD(rsc_flyd%,32)}=color3d&>0                      ! 3D-Darstellung an/aus
INT{ADD(rsc_flyd%,34)}=color3d&                        ! 3D-Farbe
' ------------------------------------------------------
IF @rsc_walk_tree(trees&)
  RETURN TRUE                                          ! alles ok
ENDIF
'
RETURN FALSE                                           ! Error!
ENDFUNC
> FUNCTION rsc_walk_tree(trees&)
$F%
LOCAL a&,b&,userblk&,tree&,obj&,a%
'
' RSC-Baum durchgehen und userdefs installieren...
'
' ------------------------------------------------------ Userdefs ermitteln
FOR tree&=0 TO trees&
'
obj&=-1
'
REPEAT
  '
  INC obj&
  '
  a&=SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)           ! Es ist ein userdef...
  ADD userblk&,-AND(a&>=17,a&<=22)
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! ...bis LAST_OBJ
'
NEXT tree&
'
rsc_userblk%=MALLOC(SHL(SUCC(userblk&),3))             ! Userblks(+1) anfordern (*8)
IF rsc_userblk%=0                                      ! Zu wenig Speicher...
RETURN FALSE                                         ! ...Error!
ENDIF
a%=rsc_userblk%                                        ! Merken
' ------------------------------------------------------ ObjektbÑume modifiz.
FOR tree&=0 TO trees&
'
obj&=-1
REPEAT
  '
  INC obj&
  '
  SELECT SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)       ! OB_TYPE
    ' ------------------------------------------------ Flydial-Ecke...
  CASE 17
    rsc_instal_userdef(tree&,obj&,5)
    ' ------------------------------------------------ Button/String...
  CASE 18
    '
    a&=OB_FLAGS(rsc_adr%(tree&),obj&)                ! OB_FLAGS
    b&=BYTE(OB_TYPE(rsc_adr%(tree&),obj&))           ! Alter OB_TYPE
    '
    IF BTST(a&,4)                                    ! Radiobutton...
      rsc_instal_userdef(tree&,obj&,1)
      '                                              ! BUTTON, nicht EXIT
    ELSE IF b&=26 AND (NOT BTST(a&,2))               ! Checkbutton...
      rsc_instal_userdef(tree&,obj&,2)
      '
    ELSE                                             ! Normale EXIT-Buttons...
      '
      IF b&<>28                                      ! Kein STRING...
        a&=SUCC(-BTST(a&,1)-BTST(a&,2)-BTST(a&,6))
        IF a&>1 !EXIT       DEFAULT    TOUCHEXIT
          OB_X(rsc_adr%(tree&),obj&)=SUB(OB_X(rsc_adr%(tree&),obj&),a&)
          OB_Y(rsc_adr%(tree&),obj&)=SUB(OB_Y(rsc_adr%(tree&),obj&),a&)
          OB_W(rsc_adr%(tree&),obj&)=ADD(OB_W(rsc_adr%(tree&),obj&),ADD(a&,a&))
          OB_H(rsc_adr%(tree&),obj&)=SUCC(ADD(OB_H(rsc_adr%(tree&),obj&),ADD(a&,a&)))
        ENDIF                                        ! ...fÅr Redraw grîûer
      ENDIF
      '
      rsc_instal_userdef(tree&,obj&,6)
      '
    ENDIF
    ' ------------------------------------------------ Unterstr. Text...
  CASE 19
    rsc_instal_userdef(tree&,obj&,4)
    OB_FLAGS(rsc_adr%(tree&),obj&)=BSET(OB_FLAGS(rsc_adr%(tree&),obj&),13)
    ' ...OB_FLAG 13 setzen, wird in 'rsc_draw' benîtigt
    ' ------------------------------------------------ Rahmen...
  CASE 20
    rsc_instal_userdef(tree&,obj&,3)
    ' ------------------------------------------------ Niceline...
  CASE 21
    rsc_instal_userdef(tree&,obj&,8)
    ' ------------------------------------------------ Circlebutton...
  CASE 22
    IF hchar&=8 OR hchar&=16                         ! ...nur wenn mîglich
      rsc_instal_userdef(tree&,obj&,7)               ! ...als Bitmap
    ELSE
      OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(27,8),BYTE(OB_TYPE(rsc_adr%(tree&),obj&)))
    ENDIF                                            ! ...sonst Pfeil lassen
    '
  ENDSELECT
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! Bis LAST_OB gesetzt
'
NEXT tree&
'
{rsc_userblk%}=0                                       ! FÅr Nullstrings
rsc_userblk%=a%                                        ! FÅr MFREE() am Ende
'
RETURN TRUE                                            ! Alles OK
ENDFUNC
> PROCEDURE rsc_instal_userdef(tree&,obj&,nr&)
'
' Userdef-Objekt installieren...
'
' nr& bezeichnet eine der folgenden Ausgaberoutinen:
' 1  Radiobutton, rund
' 2  Check-Button
' 3  Rahmen
' 4  Unterstr. Text
' 5  Flydial
' 6  Button
' 7  Circlebutton
' 8  Niceline
'
{rsc_userblk%}=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,SHL(PRED(nr&),1))})
{ADD(rsc_userblk%,4)}=OB_SPEC(rsc_adr%(tree&),obj&)
'
OB_SPEC(rsc_adr%(tree&),obj&)=rsc_userblk%             ! userdef und alter Typ
OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(BYTE(OB_TYPE(rsc_adr%(tree&),obj&)),8),24)
'                                                      ! im oberen Byte
ADD rsc_userblk%,8
'
RETURN
> PROCEDURE rsc_draw(tree&,flag%)
LOCAL fly&,title&,obj&,x&,y&,w&,h&,rx&,ry&,rb&,rh&,handle&,a%,rsc_adr%
'
' Stellt einen Dialog auf dem Bildschirm dar...
'
' tree&   : Index des Dialogbaumes
' flag%   : Bitbelegung
'           Bit 0 -> Fensterdialog
'           Bit 1 -> Schlieûfeld
'           Bit 2 -> Bei Fensterdialogen: Sofort zeichnen
'
rsc_adr%=rsc_adr%(tree&)
' --------------------------------------------------- Titel & Flugecke suchen
DO WHILE NOT (fly&>0 AND title&>0)
INC obj&
IF BTST(OB_STATE(rsc_adr%,obj&),1)                ! Flugecke...
  fly&=obj&
ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),13)          ! Dialogtitel...
  title&=obj&
ENDIF
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
' --------------------------------------------------- Als Fenster-Dialog
IF BTST(flag%,0)
x&=SUCC(rscx&(tree&))
y&=ADD(ADD(rscy&(tree&),SHL(hchar&,1)),5)
w&=SUB(rscw&(tree&),2)
h&=SUB(SUB(rsch&(tree&),SHL(hchar&,1)),5)
'
IF fly&                                           ! Flugecke hidden...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                 ! Rahmen: 1 Pixel auûen...
OB_SPEC(rsc_adr%,0)=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
'
rx&=OR(&X1001,SHL(-BTST(flag%,1),1))              ! Ggf. Schlieûfeld
handle&=WIND_CREATE(rx&,deskx&,desky&,deskw&,deskh&)
'    ~WIND_SET(handle&,10,handle&,0,0,0)  ! Fenstertitel setzen
IF handle&>0                                      ! Fenster vorhanden...
  '
  ~WIND_UPDATE(1)                                 ! BEG_UPDATE
  '
  INC rsc_window&                                 ! Anz. offene Fenster+1
  rsc_menu_ienable(FALSE)                         ! MenÅtitel disablen
  '
  IF title&                                       ! Dialogtitel existiert...
    a%=C:rsc_obspec%(L:rsc_adr%,title&)           ! ...Adresse des Titels
  ELSE
    a%=rsc_userblk%                               ! ...sonst Nullstring
  ENDIF
  ~WIND_SET(handle&,2,INT(SWAP(a%)),INT(a%),0,0)  ! Fenstertitel setzen
  mrkhandle=handle&
  '
  ~WIND_CALC(0,&X1001,x&,y&,w&,h&,rx&,ry&,rb&,rh&)! WC_BORDER
  ~WIND_OPEN(handle&,rx&,ry&,rb&,rh&)
  '
  rsc_handle%(tree&)=handle&
  '
  IF BTST(flag%,2)                                ! Sofort zeichnen...
    rsc_message(tree&,20,x&,y&,w&,h&,0,0)         ! ...redrawen
    REPEAT
      obj&=EVNT_MULTI(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1000)
      IF BTST(obj&,4) AND (MENU(4)<>rsc_handle%(tree&))
        '           message_auswerten(MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
      ENDIF
    UNTIL BTST(obj&,5)                            ! ...bis Timer-Event
  ENDIF
  '
  ~WIND_UPDATE(0)                                 ! END_UPDATE
  '
ENDIF
ENDIF
' --------------------------------------------------- Als normaler Dialog
IF rsc_handle%(tree&)=0
a%=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
OB_SPEC(rsc_adr%,0)=OR(a%,SHL(2,16))              ! Rahmen: 2 Pixel innen
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'                                                 ! Auûerhalb des Screens...
IF rscy&(tree&)<desky& OR ADD(rscx&(tree&),PRED(w&))>ADD(deskx&,PRED(deskw&)) OR ADD(rscy&(tree&),PRED(h&))>ADD(desky&,PRED(deskh&))
  ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                             ! ...wieder in die Mitte
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
'
rsc_list$=rsc_list$+MKI$(tree&)                   ! Dialog in die Liste aufnehmen
'
rsc_handle%(tree&)=MALLOC(@getsize(w&,h&))
IF rsc_handle%(tree&)                             ! Hintergrund retten...
  rsc_bitblt(0,0,0,rsc_handle%(tree&),w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
  '
ENDIF
'
IF fly&>0 AND rsc_handle%(tree&)>0               ! Flugecke sichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BCLR(OB_FLAGS(rsc_adr%,fly&),7)
ELSE IF fly&                                     ! unsichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                ! Zeichnen...
~OBJC_DRAW(rsc_adr%,0,7,rscx&(tree&),rscy&(tree&),w&,h&)
ENDIF
'  mrkhandle=WIND_FIND(x&,y&)
RETURN
> PROCEDURE rsc_menu_ienable(stat!)
LOCAL obj&,title&,rsc_adr%
'
' Disabled/enabled alle MenÅ-Titel und den 'About...'-MenÅ-Eintrag...
'                                ! Gibt es ein MenÅ..
IF rsc_menu&>-1 AND rsc_window&=1! und ist es das 1. Fenster?
'
rsc_adr%=rsc_adr%(rsc_menu&)
'                              ! Objektbreite verÑndern...
IF stat!                       ! Enablen...
  OB_W(rsc_adr%,2)=rscw&(rsc_menu&)
ELSE                           ! Disablen...
  rscw&(rsc_menu&)=OB_W(rsc_adr%,2)
  OB_W(rsc_adr%,2)=OB_W(rsc_adr%,3)
ENDIF
'
obj&=3                         ! Ersten MenÅtitel Åberspringen
'
REPEAT
  INC obj&
  '                            ! G_TITEL...
  IF BYTE(OB_TYPE(rsc_adr%,obj&))=32
    '
    ~MENU_IENABLE(rsc_adr%,obj&,stat!)
    '
    title&=obj&                ! Wird fÅr 'About...' gebraucht
  ENDIF
  '
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
'                              ! 'About...' dis/enablen
~MENU_IENABLE(rsc_adr%,ADD(title&,3),stat!)
'                              ! Unter MultiTOS...
IF (rsc_aes&>=&H400) AND rsc_mtsk!
  IF ap_id&=MENU_BAR(rsc_adr%,-1)
    ~MENU_BAR(rsc_adr%,1)      ! ...Menu nur neu anzeigen, wenn erlaubt
  ENDIF
ELSE                           ! Unter SingleTOS...
  ~MENU_BAR(rsc_adr%,1)        ! ...Menu immer neu anzeigen
ENDIF
'
ENDIF
'
RETURN
> FUNCTION rsc_do(tree&,next_obj&,VAR popup&)
$F%
LOCAL a&,handle&,a$
LOCAL edit_obj&,cont&,ob_tail&,obj&,idx&,flags&,rsc_adr%,keytab%
LOCAL ascii|,scan|,evnt&,mx&,my&,mb&,mc&,shift&,key&
'
' Dialog auswerten...
'
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(1)                                      ! ...BEG_UPDATE
~WIND_UPDATE(3)                                      ! ...BEG_MCTRL
flags&=&X11                                          ! ...BUTTON/KEYBD-Events
'
ELSE                                                   ! Fenster-Dialog...
flags&=&X10011                                       ! ...zus. MESSAGE-Events
ENDIF
'
rsc_adr%=rsc_adr%(tree&)
cont&=TRUE
' ------------------------------------------------------ Editierbares Objekt
DO WHILE (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3)) OR BTST(OB_STATE(rsc_adr%,next_obj&),3)
INC next_obj&
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,next_obj&),5)
IF BTST(OB_FLAGS(rsc_adr%,next_obj&),5) AND (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3))
next_obj&=0
ENDIF
' ------------------------------------------------------
'
IF next_obj&<>0 AND edit_obj&<>next_obj&             ! Ggf. Cursor setzen...
edit_obj&=next_obj&                                ! ...Exit-Code zurÅck
next_obj&=0                                        ! ...'rsc_do' verlassen
~OBJC_EDIT(rsc_adr%,edit_obj&,27,idx&,1,idx&)       ! ...Cursor ein
ENDIF
'
ON MENU KEY GOSUB key
ON MENU MESSAGE GOSUB message
next_obj&=0
REPEAT
ON MENU
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
IF mb&=1 THEN
GOSUB button
ENDIF
IF nr=smp16& THEN
@edhandler
ENDIF
IF nr=smpedit& THEN
@edhandler2
ENDIF
'    ~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(0)                                      ! END_UPDATE
~WIND_UPDATE(2)                                      ! END_MCTRL
ENDIF
IF mc&=2 AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6)      ! Doppelklick auf
next_obj&=WORD(BSET(next_obj&,15))                   ! TOUCHEXIT...
ENDIF                                                  ! ...15. Bit setzen
UNTIL next_obj&<>0
rsc_do_ende:
RETURN next_obj&
ENDFUNC
> FUNCTION rsc_popup(a!,tree&,button&,popup&,def&)
$F%
LOCAL x&,y&,b&,h&,m!
LOCAL evnt&,mx&,my&,mb&,shift&,key&,mc&,ascii|,scan|
LOCAL obj&,old_obj&,first&,anz&
LOCAL rsc&,rsc_adr%
'
' Popup-MenÅ darstellen und auswerten...
'
' a!       : TRUE: Button verÑndern, FALSE: Nur Popup
' tree&    : Index des Dialogbaumes
' button&  : Objektnr. des betÑtigten Buttons
' popup&   : Index des Popups
' def&     : Default-Eintrag (1-x)
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~WIND_UPDATE(3)                                   ! BEG_MCTRL
'
rsc_adr%=rsc_adr%(rsc_popup&)
'
first&=OB_HEAD(rsc_adr%,popup&)                   ! erster Eintrag
anz&=SUB(OB_TAIL(rsc_adr%,popup&),first&)         ! Anzahl EintrÑge-1
' ------------------------------------------------- Popup positionieren
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)
OB_X(rsc_adr%,0)=SUB(x&,OB_X(rsc_adr%,popup&))
OB_Y(rsc_adr%,0)=MAX(ADD(hchar&,4),MIN(SUB(WORK_OUT(1),4)-OB_H(rsc_adr%,popup&),SUB(y&,MUL(def&,hchar&))))-OB_Y(rsc_adr%,popup&)
'
x&=ADD(OB_X(rsc_adr%,0),PRED(OB_X(rsc_adr%,popup&)))
y&=ADD(OB_Y(rsc_adr%,0),PRED(OB_Y(rsc_adr%,popup&)))
b&=ADD(OB_W(rsc_adr%,popup&),4)
h&=ADD(OB_H(rsc_adr%,popup&),4)
' -------------------------------------------------
'
rsc_bitblt(0,0,0,popup_back%,b&,h&,x&,y&,b&,h&,0,0)
'
~OBJC_DRAW(rsc_adr%,0,7,x&,y&,b&,h&)              ! Popup zeichnen
'
IF a!                                             ! Button verÑndern...
'
~GRAF_MOUSE(256,0)                              ! Hidem
V~H=rsc_vh&                                     ! ...Default-Eintrag mit...
GRAPHMODE 2
'
INTIN(0)=8                                      ! ...HÑkchen versehen
PTSIN(0)=ADD(x&,DIV(wchar&,2))
PTSIN(1)=y&-DIV(hchar&,6)+MUL(SUCC(def&),hchar&)
VDISYS 8,1,1                                    ! ...v_gtext()
'
GRAPHMODE 1
V~H=-1
~GRAF_MOUSE(257,0)                              ! Showm
'
ENDIF
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)      ! Objekt unter der Maus...
'
IF obj&<=0                                        ! Daneben...
obj&=ADD(first&,def&)                           ! ...Default-Eintrag nehmen
ENDIF
'
old_obj&=obj&
IF (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))   ! Nicht disabled...
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
ENDIF                                             ! ...selektieren
'
~EVNT_TIMER(200)
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
IF mb&=1
m!=TRUE
evnt&=4
ENDIF
'
' --------------------------------------------------
DO
'
IF NOT m!
evnt&=EVNT_MULTI(&X111,1,1,1,1,mx&,my&,1,1,0,0,0,0,0,0,0,mx&,my&,mb&,shift&,key&,mc&)
ELSE
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
ENDIF
'
IF BTST(evnt&,0)                                 ! Tastaturereignis...
ascii|=BYTE(key&)
scan|=BYTE(SHR(key&,8))
'                                              ! Noch kein sel. Eintrag...
IF NOT (obj&>=first& AND obj&<=ADD(first&,anz&))
obj&=first&
'
ELSE IF scan|=80                               ! ...Cursor runter
INC obj&
IF obj&>ADD(first&,anz&)
  obj&=first&
ENDIF
'
ELSE IF scan|=72                               ! ...Cursor runter
DEC obj&
IF obj&<first&
  obj&=ADD(first&,anz&)
ENDIF
'
ENDIF
'
ENDIF
'
IF BTST(evnt&,2)                                 ! Mausereignis...
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)
ENDIF
'                                                ! Alten Eintrag deselekt...
IF obj&<>old_obj&
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),1)
ENDIF
'                                                ! Im MenÅ und nicht disabled...
IF (obj&>=first& AND obj&<=ADD(first&,anz&)) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
'                                              ! ...neuen selektieren
old_obj&=obj&
rsc&=SUB(obj&,first&)                          ! RÅckgabe
ENDIF
'
LOOP UNTIL BTST(evnt&,1) OR (mb&<>1 AND m!) OR ascii|=13 OR ascii|=27 OR scan|=97
' --------------------------------------------------
rsc_bitblt(popup_back%,b&,h&,0,0,0,0,0,b&,h&,x&,y&)! Hintergrund restaurieren
'
IF rsc&=SUB(obj&,first&) AND scan|<>97 AND ascii|<>27 ! Eintrag ausgewÑhlt...
'
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,obj&),0),0)
'
IF a!                                            ! Button verÑndern...
'                                              ! Neuen Text eintragen:
rsc_text(tree&,button&,@rsc_text$(rsc_popup&,obj&))
'
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)    ! Button zeichnen
~OBJC_DRAW(rsc_adr%(tree&),button&,1,x&,y&,OB_W(rsc_adr%(tree&),button&),OB_H(rsc_adr%(tree&),button&))
'
ENDIF
'
ELSE                                               ! Daneben => Abbruch...
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),0)
'
rsc&=-1                                          ! ...Abbruch markieren
'
ENDIF
'
REPEAT
~GRAF_MKSTATE(mx&,my&,mb&,shift&)                ! Mausknopf 'entprellen'
UNTIL mb&=0
'
~WIND_UPDATE(2)                                    ! END_MCTRL
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN SUCC(rsc&)
ENDFUNC
> PROCEDURE rsc_movedialx(tree&,edit_obj&,idx&)
LOCAL ghost!,x&,y&,a%
'
' Dialogbox bewegen...
' Mîchten Sie SOLID-Flydials? Dann ersetzen Sie diese Prozedur
' durch die entsprechenden aus der EXTENDED.LST-Datei.
'
~GRAF_MKSTATE(x&,x&,x&,y&)
ghost!=AND(y&,&X1111) OR x&=3                            ! Geisterdials...
IF ghost!
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
ENDIF
'
~GRAF_MOUSE(4,0)                                         ! Bewegen...
~GRAF_DRAGBOX(rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),deskx&,desky&,deskw&,deskh&,x&,y&)
~GRAF_MOUSE(0,0)
'
IF x&<>rscx&(tree&) OR y&<>rscy&(tree&) OR ghost!        ! öberhaupt bewegt...
'
IF NOT ghost!
a%=MALLOC(@getsize(rscw&(tree&),rsch&(tree&)))       ! Dialog getten
IF a%                                                ! ...hat geklappt
rsc_bitblt(0,0,0,a%,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
ENDIF
ENDIF
'                                                      ! Hintergr. restaur.
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
'
rscx&(tree&)=x&                                        ! Neue Position setzen...
rscy&(tree&)=y&
'
OB_X(rsc_adr%(tree&),0)=ADD(x&,3)
OB_Y(rsc_adr%(tree&),0)=ADD(y&,3)
'                                                      ! Neuen Hintergr. holen
rsc_bitblt(0,0,0,rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
'                                                      ! Dialog hinsetzen...
IF a%                                                  ! Hintergrund gerettet...
rsc_bitblt(a%,rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~MFREE(a%)
ELSE                                                   ! Sonst wenigstens...
~OBJC_DRAW(rsc_adr%(tree&),0,7,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
IF edit_obj&
rsc_cursor(rsc_adr%(tree&),edit_obj&,idx&)           ! ...Cursor ein
ENDIF
ENDIF
'
ENDIF
'
RETURN
> PROCEDURE rsc_message(tree&,message&,x&,y&,w&,h&,edit_obj&,idx&)
LOCAL a|,ax&,ay&,ab&,ah&,handle&,obj&,rsc_adr%,a%,a$
'
' Wertet ein innerhalb des 'rsc_do' eingetroffenes Message-Ereignis aus...
'
handle&=rsc_handle%(tree&)                         ! Fensterhandle des Dialogs
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
SELECT message&
' --------------------------------------------------------------------------
CASE 20,21                                         ! WM_REDRAW/WM_TOPPED
IF message&=20                                   ! WM_REDRAW...
~GRAF_MOUSE(256,0)                           ! Hidem
~WIND_GET(handle&,11,ax&,ay&,ab&,ah&)          ! 1. Rechteck
'
REPEAT
'
IF RC_INTERSECT(x&,y&,w&,h&,ax&,ay&,ab&,ah&) ! ...redrawen
  ~OBJC_DRAW(rsc_adr%(tree&),0,7,ax&,ay&,ab&,ah&)
ENDIF
'
~WIND_GET(handle&,12,ax&,ay&,ab&,ah&)        ! NÑchstes Rechteck...
UNTIL ab&=0 AND ah&=0                          ! ...kein Redraw mehr nîtig
'
~GRAF_MOUSE(257,0)                           ! Showm
'
ELSE                                             ! WM_TOPPED...
~WIND_SET(handle&,10,0,0,0,0)                  ! ...toppen
ENDIF
'
~WIND_GET(0,10,ax&,ay&,ay&,ay&)                  ! Oberstes Fenster...
IF ax&=handle& AND edit_obj&>0                   ! Ist das unsrige...
' ---------------------------------------------- Cursor-Setz-Orgie...
rsc_adr%=rsc_adr%(tree&)
'
obj&=edit_obj&                                 ! Parent ermitteln...
'
REPEAT
obj&=OB_NEXT(rsc_adr%,obj&)
UNTIL obj&<edit_obj&
'
~OBJC_OFFSET(rsc_adr%,edit_obj&,ax&,ay&)       ! Koordinaten des Objekts
'
a$=CHAR{{ADD(OB_SPEC(rsc_adr%,edit_obj&),4)}}  ! Maske: "Eingabe:______"
ah&=1
WHILE MID$(a$,ah&,1)<>"_"                      ! LÑnge des Vortextes...
INC ah&
WEND                                           ! ...ermitteln
'
ADD ax&,MUL(wchar&,ADD(PRED(ah&),idx&))        ! Cursor-Position im Pixeln
ah&=ADD(OB_H(rsc_adr%,edit_obj&),6)            ! Cursor ist grîûer hchar&
'                                              ! Cursor lîschen...
~OBJC_DRAW(rsc_adr%,obj&,7,ax&,SUB(ay&,3),wchar&,ah&)
rsc_cursor(rsc_adr%,edit_obj&,idx&)            ! ...und setzen
'
ENDIF
' --------------------------------------------------------------------------
CASE 28                                            ! WM_MOVED
~WIND_CALC(1,&X1001,x&,y&,w&,h&,ax&,ay&,ab&,ah&)
'
rscx&(tree&)=PRED(ax&)
rscy&(tree&)=SUB(SUB(ay&,5),MUL(hchar&,2))
OB_X(rsc_adr%(tree&),0)=ADD(rscx&(tree&),3)
OB_Y(rsc_adr%(tree&),0)=ADD(rscy&(tree&),3)
'
~WIND_SET(handle&,5,x&,y&,w&,h&)
'
ENDSELECT
'
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN
> PROCEDURE rsc_back(tree&)
'
' Entfernt den Dialog vom Bildschirm...
'
' ---------------------------------------------------- Als Fenster-Dialog
IF rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
rsc_menu_ienable(TRUE)                             ! ...MenÅ wieder wÑhlbar
'
IF rsc_window&                                     ! Fenster existiert...
'
~WIND_CLOSE(rsc_handle%(tree&))
~WIND_DELETE(rsc_handle%(tree&))                 ! ...schlieûen & abmelden
'
DEC rsc_window&                                  ! Anz. offene Fenster-1
'
ELSE                                               ! Sonst Redraw auslîsen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF
' -------------------------------------------------- Als normaler Dialog
ELSE
rsc_list$=LEFT$(rsc_list$,SUB(LEN(rsc_list$),2))   ! Dialog aus der Liste entf.
'
IF rsc_handle%(tree&)                              ! Hintergrund gerettet...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~MFREE(rsc_handle%(tree&))
'
ELSE                                               ! Desktop redrawen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
IF rsc_list$<>""                                 ! Noch ein Dialog drunter...
~OBJC_DRAW(rsc_adr%(CVI(RIGHT$(rsc_list$,2))),0,7,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                            ! ...diesen auch redrawen
ENDIF
ENDIF
'
rsc_handle%(tree&)=0
'
~WIND_UPDATE(0)                                      ! END_UPDATE
'
RETURN
> PROCEDURE rsc_text(tree&,obj&,a$)
'
' Universelle Objekt-Text Belegung...
'
'  CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}=a$
RETURN
> PROCEDURE rsc_bitblt(a%,w&,h&,b%,rb&,rh&,ax&,ay&,ab&,ah&,gx&,gy&)
'
' Universeller Raster-Kopierer (benutzt vro_cpyfm oder vrt_cpyfm)...
'
IF ab&>0 AND ah&>0                 ! Breite und Hîhe vorhanden...
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:a%,w&,h&,0,planes&,L:b%,rb&,rh&,0,planes&,ax&,ay&,ab&,ah&,gx&,gy&,1)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_cursor(rsc_adr%,edit_obj&,idx&)
LOCAL a|,a%
'
' Zeichengenaue Positionierung des Cursors...
'
a%=ADD({OB_SPEC(rsc_adr%,edit_obj&)},idx&)
'
a|=BYTE{a%}                                        ! Zeichen merken
BYTE{a%}=0                                         ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)       ! Cursor setzen
BYTE{a%}=a|                                        ! ...Zeichen restaurieren
'
RETURN
> PROCEDURE busy_mouse
' Eine Busy-Maus in der Form eines kleines Balles...
'
IF m_adr%=ADD(m_busy%,518)
m_adr%=m_busy%
'
ELSE
ADD m_adr%,74
ENDIF
'
~GRAF_MOUSE(255,m_adr%)
'
RETURN
> FUNCTION rsc_get(x&,y&,w&,h&)
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%
'
a%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
a%=MALLOC(a%)                      ! Speicher anfordern
'
IF a%                              ! Hat geklappt...
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
'                                ! Kopieren...
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> PROCEDURE rsc_put(a%,x&,y&,m&)
LOCAL w&,h&
'
IF a%                              ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,0,0,w&,h&,x&,y&,m&)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
' ------------------------------------------------------------------------------
' ------------------------INTERFACE-FARBICONS-----------------------------------
' ------------------------------------------------------------------------------
> FUNCTION xrsrc_init
LOCAL a%,tl%,dl%,bl%,p$
'
' Initialisierungsroutine fÅr die Xrsrc-Routinen
' XRSRC-Routinen Copyright (c)1992 Olaf Meisiek
'
' -----------------------------------------------------------
INLINE xrsrc%,9423
INLINE relo%,94
'
f.base%=GEMDOS(75,5,L:0,L:0,L:0)     ! CREATE BASEPAGE
'
IF f.base%<=0
RETURN FALSE                       ! ERROR!
ENDIF
'
tl%={xrsrc%+2}                       ! LÑnge TEXT
dl%={xrsrc%+6}                       ! LÑnge DATA
bl%={xrsrc%+10}                      ! LÑnge BSS
'
{f.base%+8}=f.base%+256              ! Adresse TEXT
{f.base%+16}={f.base%+8}+{xrsrc%+2}  ! Adresse DATA
{f.base%+24}={f.base%+16}+{xrsrc%+6} ! Adresse BSS
'
{f.base%+12}=tl%                     ! LÑnge TEXT
{f.base%+20}=dl%                     ! LÑnge DATA
{f.base%+28}=bl%                     ! LÑnge BSS
'
' {f.base%+32}=dta%                  ! Addresse DTA
'
BMOVE xrsrc%+28,f.base%+256,9423-28  ! Relozieren...
~C:relo%(L:f.base%+256,L:tl%,L:dl%,L:INT{xrsrc%+14})
'
~MSHRINK(f.base%,256+tl%+dl%+bl%)
' -----------------------------------------------------------
f.init%={f.base%+8}
'
p$=STRING$(100,0)
{f.init%+4}=V:p$
'
$C+
a%=C:f.init%(L:f.base%)              ! Initialisierung
$C-
'
IF a%=0                              ! Hat geklappt...
f.scalc%={f.init%+42}
'
WORD{f.init%+4+36}=128             ! Nummer der Function
$C+
r%=C:f.scalc%()
$C-
'
RETURN TRUE
ENDIF
'
RETURN FALSE                         ! ERROR!
ENDFUNC
> PROCEDURE xrsrc_exit
'
WORD{f.init%+4+36}=129          ! Nummer der Funktion
$C+
r%=C:f.scalc%()
$C-
'
~MFREE(f.base%)
'
RETURN
> FUNCTION xrsrc_load(file$)
LOCAL r%
'
file$=file$+CHR$(0)
'
WORD{f.init%+4+36}=1          ! Nummer der Funktion
'
{f.init%+4+16}=V:file$
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_free
LOCAL r%
'
WORD{f.init%+4+36}=2          ! Nummer der Function
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_gaddr(re_gtype&,re_gindex&,VAR re_gaddr%)
LOCAL r%
'
WORD{f.init%+4+36}=3          ! Nummer der Funktion
'
WORD{f.init%+4+0}=re_gtype&
WORD{f.init%+4+2}=re_gindex&
'
{f.init%+4+16}=V:re_gaddr%
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_saddr(re_gtype&,re_gindex&,VAR re_gaddr%)
LOCAL r%
'
WORD{f.init%+4+36}=4          ! Nummer der Funktion
'
WORD{f.init%+4+0}=re_gtype&
WORD{f.init%+4+2}=re_gindex&
'
{f.init%+4+16}=V:re_gaddr%
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_obfix(re_gaddr%,re_obj&)
LOCAL r%
'
WORD{f.init%+4+36}=5          ! Nummer der Funktion
'
WORD{f.init%+4+0}=re_obj&
'
{f.init%+4+16}=re_gaddr%
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
' ------------------------------------------------------------------------------
' ------------------------ENHANCED-FLYDIALS-------------------------------------
' ------------------------------------------------------------------------------
DEFFN rsc_flags(tree&,obj&,bit&)=BTST(OB_FLAGS(rsc_adr%(tree&),obj&),bit&)
DEFFN rsc_state(tree&,obj&,bit&)=BTST(OB_STATE(rsc_adr%(tree&),obj&),bit&)
> FUNCTION form_keybd(rsc_adr%,edit_obj&,key&,a&,VAR next_obj&,key_back&,idx&)
' ZusÑtzliche Tastaturkommandos...
' Einfach FORM_KEYBD in 'rsc_do' durch @form_keybd ersetzen.
$F%
LOCAL scan|,cont&
'
' Ersetzt FORM_KEYBD()...
'
key_back&=0
cont&=1
'
SELECT key&
'
' ------------------------------------------------- SHIFT right
CASE &H4D36
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
' ------------------------------------------------- SHIFT left
CASE &H4B34
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
'
a&=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=0
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=a&
'
' ------------------------------------------------- Cursor runter
CASE &H5000
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
' ------------------------------------------------- Cursor rauf
CASE &H4800
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,-1)
' ------------------------------------------------- SHIFT runter/HOME
CASE &H5032,&H4737                                  ! =>letztes Feld
REPEAT
next_obj&=edit_obj&
edit_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
UNTIL edit_obj&=0
' ------------------------------------------------- SHIFT rauf, HOME
CASE &H4838,&H4700                                  ! =>erstes Feld
next_obj&=@form_search_flag(rsc_adr%,0,3,1)
' ------------------------------------------------- HELP/UNDO
CASE &H6200,&H6100
key_back&=key&
' ------------------------------------------------- Alles andere
DEFAULT
scan|=BYTE(SHR(key&,8))                           ! SCAN-Code
'
IF BYTE(key&)>0 OR scan|=75 OR scan|=77           ! Cursor rauf/runter
cont&=FORM_KEYBD(rsc_adr%,edit_obj&,key&,0,next_obj&,key&)
'                                               ! Kein Ende&TAB u. EDITABLE
IF cont&>0 AND BYTE(key&)<>9 AND BTST(OB_FLAGS(rsc_adr%,edit_obj&),3)
'
scan|=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)+8}+idx&}! Maske 'A' oder 'N'...
IF scan|=65 OR (scan|=78 AND (BYTE(key&)<48 OR BYTE(key&)>57))
key&=BCLR(key&,5)                             ! ...Groûschrift setzen
ENDIF
'
~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,2,idx&) ! ...Eingabe
ENDIF
'
ELSE
key_back&=key&
ENDIF
'
ENDSELECT
'
RETURN cont&
ENDFUNC
> FUNCTION form_search_flag(rsc_adr%,obj&,flag&,step&)
$F%
'
' Unterroutine fÅr form_keybd. Sucht das nÑchste/vorhergehende Objekt mit
' dem gesetzten Bit 'flag&' in OB_FLAGS...
'
' Sonderfall: Letztes Objekt ist edierbar, Cursor runter:
IF NOT (BTST(OB_FLAGS(rsc_adr%,obj&),5)=TRUE AND step&>0)
'
REPEAT
ADD obj&,step&
'
IF BTST(OB_FLAGS(rsc_adr%,obj&),flag&) AND (NOT BTST(OB_STATE(rsc_adr%,obj&),3))
RETURN obj&
ENDIF
UNTIL (obj&<=0) OR BTST(OB_FLAGS(rsc_adr%,obj&),5)
'
ENDIF
'
RETURN 0
ENDFUNC
> PROCEDURE rsc_movedial(tree&,edit_obj&,idx&)
' SOLID Flydials...
' Einfach die Prozedur 'rsc_movedial' ersetzen.
LOCAL x&,y&,w&,h&,fx&,fy&,mx&,my&,mb&,shift&,rsc%
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'
~GRAF_MKSTATE(mx&,my&,x&,y&)
' Nicht zusÑtzl. rechte Maustaste oder SHIFT/CONTROL/ALT...
IF NOT (x&=3 OR AND(y&,&X1111)>0)
rsc%=MALLOC(@getsize(w&,h&))                    ! Dialog retten
ENDIF
IF rsc%                                           ! Hat geklappt...
rsc_bitblt(0,0,0,rsc%,w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
ENDIF
'
~GRAF_MOUSE(4,0)                                  ! FLAT_HAND
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
fx&=SUB(mx&,SUCC(rscx&(tree&)))                   ! Relativer Mausfaktor
fy&=SUB(my&,SUCC(rscy&(tree&)))
'
mx&=rscx&(tree&)
my&=rscy&(tree&)
' ------------------------------------------------- Bewegen
IF rsc%                                           ! SOLID...
REPEAT
'
~GRAF_MKSTATE(x&,y&,mb&,shift&)
'
x&=SUB(PRED(x&),fx&)
y&=SUB(PRED(y&),fy&)                          ! Clipping...
x&=MIN(MAX(x&,deskx&),SUB(ADD(deskx&,deskw&),w&))
y&=MIN(MAX(y&,desky&),SUB(ADD(desky&,deskh&),h&))
'
IF mx&<>x& OR my&<>y&
rsc_flipping(rsc_handle%(tree&),rsc%,mx&,my&,w&,h&,x&,y&)
mx&=x&
my&=y&
'
ENDIF
'
UNTIL mb&=0
'
~MFREE(rsc%)
'
ELSE                                              ! Nicht SOLID...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~GRAF_DRAGBOX(rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),deskx&,desky&,deskw&,deskh&,x&,y&)
ENDIF
' ------------------------------------------------- Hinsetzen
rscx&(tree&)=x&
rscy&(tree&)=y&
OB_X(rsc_adr%(tree&),0)=ADD(x&,3)
OB_Y(rsc_adr%(tree&),0)=ADD(y&,3)
'
IF rsc%=0                                         ! Nicht SOLID...
rsc_bitblt(0,0,0,rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
~OBJC_DRAW(rsc_adr%(tree&),0,10,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
'
IF edit_obj&
rsc_cursor(rsc_adr%(tree&),edit_obj&,idx&)    ! ...Cursor ein
ENDIF
ENDIF
'
~GRAF_MOUSE(0,0)
'
RETURN
> PROCEDURE rsc_flipping(rsc_back%,rsc%,ax&,ay&,w&,h&,x&,y&)
LOCAL rb&,rh&,gw&,gh&
'
gw&=ABS(SUB(x&,ax&))         ! Verschiebbreite
gh&=ABS(SUB(y&,ay&))         ! Verschiebhîhe
rb&=SUB(w&,gw&)              ! Restbreite
rh&=SUB(h&,gh&)              ! Resthîhe
'
IF rb&<0 OR rh&<0            ! rsc% auûerhalb von rsc_back%
'
' Gesamten Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,h&,ax&,ay&)
'
' Gesamten Dialog aktualisieren -----
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,h&,0,0)
'
ELSE IF x&>ax&               ! nach rechts...
'
IF y&>ay&                  ! nach rechts-unten veschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,gh&,gw&,rh&,ax&,ADD(ay&,gh&))
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,gh&,ax&,ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,gh&,rb&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),rb&,gh&,0,rh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ELSE                      ! nach rechts-oben / rechts verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,gw&,rh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,0,rb&,rh&,0,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,rb&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ENDIF
'                         ! nach links / oben / unten...
ELSE IF y&>ay&              ! nach links-unten / unten verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,rb&,gh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,h&,ADD(ax&,rb&),ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,gh&,rb&,rh&,gw&,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,gw&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),w&,gh&,0,rh&)
'
ELSE                        ! nach links-oben / links / oben verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,rh&,ADD(ax&,rb&),ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,0,rb&,rh&,gw&,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,gh&),gw&,rh&,0,gh&)
'
ENDIF
'
rsc_bitblt(rsc%,w&,h&,0,0,0,0,0,w&,h&,x&,y&)
'
RETURN
> PROCEDURE rsc_set_cursor(rsc_adr%,mx&,my&,VAR edit_obj&,next_obj&,idx&)
' Zeichengenaues Cursor-Positionieren mit der Maus...
' Nur die entsprechenden 2 Zeilen in 'rsc_do' (ziemlich am Ende) entREMen.
LOCAL x&,a&,i&,ob_spec%,a$
'
ob_spec%=OB_SPEC(rsc_adr%,next_obj&)
'
~OBJC_OFFSET(rsc_adr%,next_obj&,x&,a&)          ! Absolute X-Position
'
x&=DIV(SUB(mx&+SHR(wchar&,2),x&),wchar&)        ! Spaltenposition
'
a$=CHAR{{ADD(ob_spec%,4)}}                      ! Maske lesen
'
FOR a&=1 TO x&                                  ! Pos. im Eingabefeld...
IF MID$(a$,a&,1)="_"
INC i&                                      ! ...nur relevante
ENDIF
NEXT a&
SUB x&,(x&-i&)
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)    ! Cursor aus
'
ob_spec%=ADD({ob_spec%},x&)
'
a&=BYTE{ob_spec%}                               ! Zeichen merken
BYTE{ob_spec%}=0                                ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,next_obj&,0,idx&,1,idx&)    ! Cursor setzen
BYTE{ob_spec%}=a&                               ! ...und Zeichen restaurieren
'
edit_obj&=next_obj&
'
RETURN
> PROCEDURE rsc_write_popup(tree&,button&,default&)
' Setzen und Auslesen der Popup-MenÅeintrÑge...
LOCAL i&,popup&,obj&
'
' Belegt einen Popup-Button mit dem Text des Popup-Eintrags
' 'default&' (also von 1-x)...
'
' tree&   : Index des Objektbaumes
' button& : Objektnummer des Buttons
' default&: Nummer des zu setzenden MenÅ-Eintrages (1-x)
'
popup&=SUB(SHR&(OB_TYPE(rsc_adr%(tree&),button&),8),30)! Nr. des Popup-Baumes
obj&=1
'
FOR i&=1 TO PRED(popup&)
obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)              ! Objektnr. des Popups
NEXT i&
'                                                      ! Button belegen
rsc_text(tree&,button&,@rsc_text$(rsc_popup&,ADD(obj&,default&)))
RETURN
> FUNCTION rsc_read_popup(tree&,button&)
$F%
LOCAL a&,i&,popup&,obj&,a$
'
' Gibt den Index des gesetzten Popup-Eintrags zurÅck...
'
' tree&   : Index des Objektbaumes
' button& : Objektnummer des Buttons
'
popup&=SHR&(OB_TYPE(rsc_adr%(tree&),button&),8)-30     ! Nr. des Popup-Baumes
obj&=1
'
FOR i&=1 TO PRED(popup&)
obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)              ! Objektnr. des Popups
NEXT i&
'                                                      ! Button belegen
a$=@rsc_text$(tree&,button&)
'
a&=OB_TAIL(rsc_adr%(rsc_popup&),obj&)
DO WHILE a$<>@rsc_text$(rsc_popup&,a&)
DEC a&
LOOP UNTIL a&<=obj&
'
RETURN SUB(a&,obj&)
ENDFUNC
> PROCEDURE rsc_set_popup(popup&,anz&)
' Setzt ein Popup auf 'anz&' EintrÑge...
LOCAL a&,obj&
'
' popup&: Objektnummer des Popup-MenÅs
' anz&  : Neue Anzahl EintrÑge
'
' ----------------------------------------- Alle EintrÑge aktivieren...
obj&=OB_TAIL(rsc_adr%(rsc_popup&),popup&) ! Letzter Eintrag des Popup's
'
a&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)     ! Darauf folgender
'
WHILE a&=popup&                           ! Zeigt auf's Parent-Objekt...
INC obj&                                ! ...nÑchster Eintrag
'
a&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)
IF a&>0 AND a&<=SUCC(obj&)              ! Existiert...
~OBJC_ADD(rsc_adr%(rsc_popup&),popup&,obj&)
ENDIF                                   ! ...wieder aktivieren
'
WEND
'
' ----------------------------------------- EintrÑge entfernen...
a&=OB_TAIL(rsc_adr%(rsc_popup&),popup&)   ! Letzter Eintrag des Popup's
'
FOR obj&=a& DOWNTO ADD(popup&,SUCC(anz&)) ! Von hinten nach vorne...
~OBJC_DELETE(rsc_adr%(rsc_popup&),obj&) ! ...entfernen
NEXT obj&
'
' ----------------------------------------- Neue Hîhe setzen
OB_H(rsc_adr%(rsc_popup&),popup&)=MUL(hchar&,anz&)
'
RETURN
> FUNCTION rsc_shortcut(tree&,scan|,shift&,VAR title&)
' MenÅshortcut ermitteln...
$F%
LOCAL a&,obj&,rsc_adr%,s$,t$
'
' tree&      : Index des MenÅbaumes
' scan|      : SCAN-Code der gedrÅckten Taste
' shift&     : Status der tastaturumschalttasten
' VAR title& : Bei Erfolg Objektnummer des MenÅtitels
'
SELECT scan|
CASE 2 TO 10                                   ! 1-2...
s$=CHR$(ADD(47,scan|))
CASE 15                                        ! TAB...
s$="I"
shift&=BSET(shift&,2)                        ! ...entspricht "^I"
'
CASE 59 TO 68,84 TO 93                         ! Ftasten...
IF scan|<84
s$="F"+STR$(SUB(scan|,58))                 ! ...normal
ELSE
s$="F"+STR$(SUB(scan|,83))                 ! ...mit Shift
ENDIF
CASE 71                                        ! ClrHome...
s$="CLR"
CASE 83                                        ! DELETE...
s$="DEL"
CASE 97                                        ! UNDO...
s$="UNDO"
CASE 98                                        ! HELP...
s$="HELP"
DEFAULT                                        ! Alles andere...
rsc_adr%={XBIOS(16,L:-1,L:-1,L:-1)}
s$=CHR$(BCLR(BYTE{ADD(rsc_adr%,scan|)},5))
ENDSELECT
'
IF BTST(shift&,3)                              ! Alternate...
s$=CHR$(7)+s$
ENDIF
IF BTST(shift&,2)                              ! Control...
s$="^"+s$
ENDIF
IF BTST(shift&,0) OR BTST(shift&,1)            ! Shift...
s$=CHR$(1)+s$
ENDIF
'
title&=2                                       ! Position des Titels
obj&=5                                         ! Beginn der eigentl. MenÅs
rsc_adr%=rsc_adr%(tree&)                       ! öbersichtlicher
'
REPEAT                                         ! alle Objekte d. MenÅbaums
INC obj&
'
IF BYTE(OB_TYPE(rsc_adr%,obj&))=28           ! G_STRING...
IF NOT BTST(OB_STATE(rsc_adr%,obj&),3)     ! disabled ?
'
t$=TRIM$(CHAR{OB_SPEC(rsc_adr%,obj&)})   ! MenÅpunkt-Text
'
a&=RINSTR(t$," ")
IF a&                                    ! Shortcut vorhanden ?
'
IF MID$(t$,SUCC(a&))=s$                ! hier der vermutete Shortcut
RETURN obj&                          ! gefunden
ENDIF
'
ENDIF
ENDIF
'
ELSE IF BYTE(OB_TYPE(rsc_adr%,obj&))=20      ! G_STRING ?
INC title&
ENDIF
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)          ! LAST_OB ?
'
title&=0
RETURN 0                                       ! nicht gef. oder disabled
ENDFUNC
> FUNCTION rsc_alert(icon&,text$,button$,def&)
' Fliegende ALERT-Box...
$F%
LOCAL a&,b&,h&,i&,l&,len&,w&,x&,y&,z&,ab&,ah&,rsc&,rsc_adr%,a$
'
' Alert-Box darstellen...
'
IF rsc_alert&>-1                                       ! Wenn's den Baum gibt:
rsc_adr%=rsc_adr%(rsc_alert&)                        ! rsc_alert=GLOBAL
'
text$=text$+"|"
button$=button$+"|"
' ---------------------------------------------------- Icon bestimmen
OB_FLAGS(rsc_adr%,2)=BSET(OB_FLAGS(rsc_adr%,2),7)    ! Hidden...
OB_FLAGS(rsc_adr%,3)=BSET(OB_FLAGS(rsc_adr%,3),7)
OB_FLAGS(rsc_adr%,4)=BSET(OB_FLAGS(rsc_adr%,4),7)
'
OB_FLAGS(rsc_adr%,SUCC(icon&))=BCLR(OB_FLAGS(rsc_adr%,SUCC(icon&)),7)
' ---------------------------------------------------- Buttons
OB_FLAGS(rsc_adr%,10)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,10)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,11)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,11)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,12)=OR(&X100101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,12))) ! LAST_OB+EXIT+SELECT.
'                                                    ! Default-Button...
OB_FLAGS(rsc_adr%,9+def&)=BSET(OB_FLAGS(rsc_adr%,9+def&),1)
' ---------------------------------------------------- Textzeilen setzen
FOR i&=1 TO 5
a&=INSTR(text$,"|")
a$=LEFT$(text$,MIN(30,MAX(0,PRED(a&))))
text$=MID$(text$,SUCC(a&))
'
z&=MAX(z&,-i&*(a$<>""))                            ! Hîchste belegte Zeile
l&=MAX(l&,LEN(a$))                                 ! LÑngste Zeile
'
rsc_text(rsc_alert&,ADD(4,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Button-Texte setzen
FOR i&=1 TO 3
a&=INSTR(button$,"|")
a$=LEFT$(button$,MIN(10,MAX(0,PRED(a&))))
button$=MID$(button$,SUCC(a&))
'
ADD b&,-(a$<>"")                                   ! Anzahl Buttons
len&=MAX(len&,LEN(a$))                             ! LÑngster Button
'
rsc_text(rsc_alert&,ADD(9,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Dialog-Breite Ñndern
l&=MAX(l&,MUL(10,b&))                                ! Minimal-Breite
'
w&=OB_W(rsc_adr%,3)+MUL(wchar&,ADD(l&,5))
OB_W(rsc_adr%,0)=w&                                  ! Neue Breite
'
OB_X(rsc_adr%,1)=w&-PRED(OB_W(rsc_adr%,1))           ! Flydial verschieben
rscw&(rsc_alert&)=ADD(w&,6)
' ---------------------------------------------------- Dialog-Hîhe Ñndern
h&=OB_H(rsc_adr%,10)+MUL(hchar&,ADD(z&,2))
OB_H(rsc_adr%,0)=h&                                  ! Neue Hîhe
rsch&(rsc_alert&)=ADD(h&,6)
' ---------------------------------------------------- Buttons plazieren
len&=MUL(wchar&,MAX(8,SUCC(len&)))
OB_W(rsc_adr%,10)=len&                               ! Breite anpassen..
OB_W(rsc_adr%,11)=len&
OB_W(rsc_adr%,12)=len&
'
SELECT b&                                            ! Anzahl Buttons...
CASE 1
OB_FLAGS(rsc_adr%,11)=BSET(OB_FLAGS(rsc_adr%,11),7)! ...hidden
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
' OB_X(rsc_adr%,10)=SHR(SUB(w&,OB_W(rsc_adr%,10)),1)
OB_X(rsc_adr%,10)=SUB(w&,OB_W(rsc_adr%,10))-2*wchar&
'
CASE 2
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
x&=w&-OB_W(rsc_adr%,11)-2*wchar&
OB_X(rsc_adr%,11)=x&
OB_X(rsc_adr%,10)=x&-OB_W(rsc_adr%,10)-wchar&
'
CASE 3
x&=w&-OB_W(rsc_adr%,12)-SHL(wchar&,1)              ! ...Mitte
OB_X(rsc_adr%,12)=x&
OB_X(rsc_adr%,11)=x&-OB_W(rsc_adr%,10)-wchar&
OB_X(rsc_adr%,10)=OB_X(rsc_adr%,11)-OB_W(rsc_adr%,10)-wchar&
'
ENDSELECT
'
y&=h&-OB_H(rsc_adr%,10)-SHR(hchar&,1)
OB_Y(rsc_adr%,10)=y&
OB_Y(rsc_adr%,11)=y&
OB_Y(rsc_adr%,12)=y&
' ---------------------------------------------------- Anzeigen
~FORM_CENTER(rsc_adr%(rsc_alert&),rscx&(rsc_alert&),rscy&(rsc_alert&),rscw&(rsc_alert&),rsch&(rsc_alert&))
'
rsc_draw(rsc_alert&,FALSE)
'
rsc&=@rsc_do(rsc_alert&,0,a&)
'
rsc_back(rsc_alert&)
' ----------------------------------------------------
OB_STATE(rsc_adr%,rsc&)=BCLR(OB_STATE(rsc_adr%,rsc&),0)! SELECTED lîschen
'
RETURN SUB(rsc&,9)                                   ! Nummer des Buttons 1-3
ENDIF
'                                                      ! Normaler Alert...
WHILE INSTR(button$,"[")>0
button$=LEFT$(button$,PRED(INSTR(button$,"[")))+MID$(button$,SUCC(INSTR(button$,"[")))
WEND                                                   ! ...'[' rausfiltern
'
RETURN FORM_ALERT(def&,"["+STR$(icon&)+"]["+text$+"]["+button$+"]")
ENDFUNC
> FUNCTION rsrc_conv(r_ra%)
' Ersatz fÅr RSRC_LOAD(file$). Die RSC-Datei kann in einem INLINE direkt im
' Programmcode abgelegt werden, diese Funktion bekommt die Adresse des INLINES
' Åbergeben und initialisiert die Resource...
$F%
'     r_ra%                            ! RSC INLINE Adresse
LOCAL r_buf!                           ! TRUE=RSC Daten puffern
LOCAL r_pa%                            ! Puffer-Adresse
LOCAL r_o&,r_t&                        ! Laufvar
LOCAL r_ob&                            ! Beginn des Objekt Feldes
LOCAL r_no&                            ! Anzahl OBJECTS
LOCAL r_nt&                            ! Anzahl TREES
LOCAL r_rs&                            ! LÑnge des INLINEs
LOCAL r_napt%                          ! neue TREE Table Adresse
LOCAL r_gb%                            ! Adresse des AES Global Feldes
LOCAL r_of%                            ! Objekt Feld
LOCAL r_ns&                            ! Anzahl der freien Strings
LOCAL r_ni&                            ! Anzahl der freien Images
LOCAL r_adr%,r_i&                      ! Hilfsvar, Laufvar
'
r_buf!=(BYTE{ADD(BASEPAGE,256)}=96)    ! Im Interpreter? ==>puffern
'
r_rs&=WORD{ADD(r_ra%,&H22)}            ! LÑnge des INLINEs
IF r_buf! AND DIM?(rsc_buf|())>0       ! Ist RSC Buf schon dimensioniert?...
r_rs&=0
ENDIF
'
IF r_rs&>0
'
IF r_buf!                            ! RSC Daten puffern (nur Interpreter)...
DIM rsc_buf|(r_rs&)
r_pa%=ADD({*rsc_buf|()},4)
BMOVE r_ra%,r_pa%,r_rs&
r_ra%=r_pa%
ENDIF
'
r_napt%=ADD(r_ra%,WORD{ADD(r_ra%,&H12)})       ! neue Adresse der Tree Tabelle
r_gb%={ADD(GB,4)}                    ! Adr. des AES-GLOBAL-Feldes
{ADD(r_gb%,10)}=r_napt%              ! GLOBAL(5/6): neue Tabellen Adr.
r_ob&=WORD{ADD(r_ra%,2)}             ! bisheriger Start Objekt Feld
r_of%=ADD(r_ra%,r_ob&)               ! Neue Startadr. Objekt Feld
r_no&=PRED(WORD{ADD(r_ra%,&H14)})    ! Anzahl der Objekte im File -1
r_nt&=PRED(WORD{ADD(r_ra%,&H16)})    ! Anzahl der Trees in File  -1
'
FOR r_o&=0 TO r_no&                  ! Alle Objekte durchgehen...
~RSRC_OBFIX(r_of%,r_o&)            ! ...Koordinaten umrechnen
'
SELECT BYTE(OB_TYPE(r_of%,r_o&))   ! Objekt-Typ...
'
CASE 21,22,29,30,31                ! ...G_TEXT,G_BOXTEXT,G_FTEXT,G_FBOXTEXT,G_ICON
OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
{OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
{ADD(OB_SPEC(r_of%,r_o&),4)}=ADD({ADD(OB_SPEC(r_of%,r_o&),4)},r_ra%)
{ADD(OB_SPEC(r_of%,r_o&),8)}=ADD({ADD(OB_SPEC(r_of%,r_o&),8)},r_ra%)
'
CASE 24                            ! ...G_USERDEF
OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
{OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
{ADD(OB_SPEC(r_of%,r_o&),4)}=ADD({ADD(OB_SPEC(r_of%,r_o&),4)},r_ra%)
'
CASE 23                            ! ...G_IMAGE
OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
{OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
'
CASE 26,28,32                      ! ...G_BUTTON,G_STRING,G_TITLE
OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
ENDSELECT
'
NEXT r_o&
'
FOR r_t&=0 TO r_nt&
{ADD(r_napt%,MUL(4,r_t&))}=ADD({ADD(r_napt%,MUL(4,r_t&))},r_ra%)
NEXT r_t&
'
r_ns&=PRED(WORD{ADD(r_ra%,&H1E)})
IF r_ns&>-1
r_adr%=ADD(r_ra%,WORD{ADD(r_ra%,&HA)})
FOR r_i&=0 TO r_ns&
{ADD(r_adr%,MUL(4,r_i&))}=ADD({ADD(r_adr%,MUL(4,r_i&))},r_ra%)
NEXT r_i&
ENDIF
'
r_ni&=PRED(WORD{ADD(r_ra%,&H20)})
IF r_ni&>-1
r_adr%=ADD(r_ra%,WORD{ADD(r_ra%,&H10)})
'
FOR r_i&=0 TO r_ni&
{ADD(r_adr%,MUL(4,r_i&))}=ADD({ADD(r_adr%,MUL(4,r_i&))},r_ra%)
{{ADD(r_adr%,MUL(4,r_i&))}}=ADD({{ADD(r_adr%,MUL(4,r_i&))}},r_ra%)
NEXT r_i&
'
ENDIF
'
ENDIF
'
RETURN r_rs&
ENDFUNC
> PROCEDURE rsc_save_dialog(tree&)
' Retten und Restaurieren eines Dialogs zum Aufruf einer Dateiauswahlbox...
LOCAL x&,y&,w&,h&,i&,a%
'
' Rettet den(die) Dialog(e) z.B. fÅr den Aufruf eines Fileselectors...
'                                               ! Kein Fenster-Dialog...
IF NOT (rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000)
'
x&=rscx&(tree&)
y&=rscy&(tree&)
FOR i&=1 TO SHR(LEN(rsc_list$),1)             ! Grîûten Dialog rausfinden...
tree&=CVI(MID$(rsc_list$,SUCC(SHL(PRED(i&),1))))
x&=MIN(x&,rscx&(tree&))
y&=MIN(y&,rscy&(tree&))
w&=MAX(w&,ADD(rscx&(tree&),rscw&(tree&)))
h&=MAX(h&,ADD(rscy&(tree&),rsch&(tree&)))
NEXT i&
SUB w&,x&
SUB h&,y&
'
a%=MALLOC(@getsize(w&,h&)+8)
IF a%                                         ! Hintergrund retten...
rsc_bitblt(0,0,0,ADD(a%,8),w&,h&,x&,y&,w&,h&,0,0)
'
INT{a%}=x&                                  ! Koordinaten eintragen...
INT{ADD(a%,2)}=y&
INT{ADD(a%,4)}=w&
INT{ADD(a%,6)}=h&
'
rsc_save%=a%                                ! In globaler Variablen merken...
'
GRAPHMODE 4                                 ! Dialog disablen...
DEFFILL 0,2,4
~GRAF_MOUSE(256,0)                          ! Hidem
'
PBOX SUCC(x&),SUCC(y&),ADD(PRED(x&),PRED(w&)),ADD(PRED(y&),PRED(h&))
'
~GRAF_MOUSE(257,0)                          ! Showm
DEFFILL 1,0
GRAPHMODE 1
'
ENDIF
'
ENDIF
'
RETURN
> PROCEDURE rsc_restore_dialog(tree&)
LOCAL w&,h&,i&
'
' Restauriert den(die) Dialog(e) z.B. nach einem Fileselector...
'                                               ! Kein Fenster-Dialog...
IF NOT (rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000)
'
IF rsc_save%                                  ! Hintergrund wurde gerettet...
w&=INT{ADD(rsc_save%,4)}
h&=INT{ADD(rsc_save%,6)}
rsc_bitblt(ADD(rsc_save%,8),w&,h&,0,0,0,0,0,w&,h&,INT{rsc_save%},INT{ADD(rsc_save%,2)})
'
~MFREE(rsc_save%)                           ! ...freigeben
rsc_save%=0
'
ELSE                                          ! Nicht gerettet...
'
FOR i&=1 TO SHR(LEN(rsc_list$),1)           ! Dialog-Liste durchgehen...
tree&=CVI(MID$(rsc_list$,SUCC(SHL(PRED(i&),1))))
~OBJC_DRAW(rsc_adr%(tree&),0,100,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
NEXT i&                                     ! ...und zeichnen
'
ENDIF
'
ENDIF
'
RETURN
> PROCEDURE rsc_state(tree&,obj&,bit&,stat!)
' Setzen und Abfragen einzelner Bits in OB_STATE und OB_FLAGS...
'
' tree& : Index des Objektbaumes
' obj&  : Objektnummer
' bit&  : Zu setzendes Bit
' stat! : TRUE =Bit setzen, FALSE =Bit lîschen
'
IF stat!
OB_STATE(rsc_adr%(tree&),obj&)=BSET(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ELSE
OB_STATE(rsc_adr%(tree&),obj&)=BCLR(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ENDIF
'
RETURN
> PROCEDURE rsc_flags(tree&,obj&,bit&,stat!)
'
' tree& : Index des Objektbaumes
' obj&  : Objektnummer
' bit&  : Zu setzendes Bit
' stat! : TRUE =Bit setzen, FALSE =Bit lîschen
'
IF stat!
OB_FLAGS(rsc_adr%(tree&),obj&)=BSET(OB_FLAGS(rsc_adr%(tree&),obj&),bit&)
ELSE
OB_FLAGS(rsc_adr%(tree&),obj&)=BCLR(OB_FLAGS(rsc_adr%(tree&),obj&),bit&)
ENDIF
'
RETURN
> PROCEDURE rsc_tristate(tree&,obj&)
' Behandlung eines Tristate-Buttons...
'
INC tri
IF tri=3 THEN
tri=0
ENDIF
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
RETURN
> PROCEDURE rsc_tristate2(tree&,obj&)
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
RETURN
> PROCEDURE rsc_draw_obj(tree&,obj&)
' Zeichnen eines einzelnen Objektes...
LOCAL x&,y&
'
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
~OBJC_DRAW(rsc_adr%(tree&),obj&,8,x&,y&,OB_W(rsc_adr%(tree&),obj&),OB_H(rsc_adr%(tree&),obj&))
'
RETURN
> PROCEDURE rsc_set_radio(tree&,anz&,select&,VAR obj&())
' Globales Setzen und Abfragen mehrerer Radio-Buttons...
LOCAL i&
'
' tree&   : Index des Objektbaumes
' anz&    : Anzahl Objekte
' select& : Index des zu selektierenden Objektes (1-x)
' obj&()  : Feld mit den Objektnummern
'
FOR i&=0 TO anz&           ! Alle Buttons deselektieren...
OB_STATE(rsc_adr%(tree&),obj&(i&))=BCLR(OB_STATE(rsc_adr%(tree&),obj&(i&)),0)
NEXT i&
'                          ! Nur den gewÅnschten selektieren...
OB_STATE(rsc_adr%(tree&),obj&(select&))=BSET(OB_STATE(rsc_adr%(tree&),obj&(select&)),0)
'
RETURN
> FUNCTION rsc_get_radio(tree&,anz&,obj&,VAR obj&())
$F%
LOCAL i&
'
IF obj&>0                  ! Objekt suchen...
'
FOR i&=0 TO anz&
IF obj&(i&)=obj&
RETURN i&            ! ...der gewÅnschte Button ist selektiert
ENDIF
NEXT i&
'
ELSE                       ! Radio-Button suchen...
FOR i&=0 TO anz&
IF BTST(OB_STATE(rsc_adr%(tree&),obj&(i&)),0)
RETURN i&            ! ...selektierter zurÅck
ENDIF
NEXT i&
'
ENDIF
'
RETURN -1                  ! Kein Button selektiert
ENDFUNC
> FUNCTION rsc_get_radio2(tree&,anz&,rsc&,obj&)
$F%
LOCAL i&
'
' obj& = Erstes Objekt
' --------------------------------------------------
IF rsc&>0                                          ! Objekt suchen...
'
FOR i&=0 TO anz&
IF obj&+i&=rsc&
RETURN i&
ENDIF
NEXT i&
'
ELSE                                               ! Radio-Button suchen...
FOR i&=0 TO anz&
IF @rsc_state(tree&,obj&+i&,0)
RETURN i&
ENDIF
NEXT i&
'
ENDIF
'
RETURN -1
ENDFUNC
> FUNCTION rsc_clicks(VAR rsc&)
' Gibt die Anzahl der MaustastendrÅcke (1 oder 2) zurÅck, mit denen ein Dialog
' verlassen wurde und maskiert das Bit 15 wieder aus...
$F%
LOCAL mc&
'
mc&=BTST(rsc&,15)                                  ! Doppelklick?
IF mc&
rsc&=AND(rsc&,&X111111111111111)                 ! Bit 15 ausmaskieren
ENDIF
'
RETURN 1-mc&
ENDFUNC
> PROCEDURE rsc_redraw_obj(tree&,obj&)
' Sauberer Redraw eines Objektes, nur fÅr Fensterdialoge!...
LOCAL x&,y&,w&,h&
'
' Sendet einen Redraw-Event fÅr ein Objekt
' --------------------------------------------------
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
w&=OB_W(rsc_adr%(tree&),obj&)
h&=OB_H(rsc_adr%(tree&),obj&)
'
appl_write(ap_id&,20,rsc_handle%(tree&),x&-3,y&-3,w&+6,h&+6,"")   ! WM_REDRAW
'
RETURN
> PROCEDURE appl_write(id&,msg&,handle&,x&,y&,w&,h&,a$)
' LOCAL b$
'
' Sendet eine Message an ein Programm. Dabei kann es sich auch um
' das eigene Programm handeln (id&=ap_id&), siehe 'rsc_redraw_obj'
' --------------------------------------------------
INLINE msg%,256
'
INT{msg%}=msg&                                     ! 0 Message-ID
INT{msg%+2}=ap_id&                                 ! 1 Unsere ID
INT{msg%+4}=0                                      ! 2 Keine öberlÑnge
INT{msg%+6}=handle&                                ! 3
INT{msg%+8}=x&                                     ! 4 MenÅpunkt
INT{msg%+10}=y&                                    ! 5
INT{msg%+12}=w&                                    ! 6
INT{msg%+14}=h&                                    ! 7
'
IF x&=0                                            ! String (z.B. fÅr VA_START)...
CHAR{msg%+16}=LEFT$(a$,240)
{msg%+6}=msg%+16
ENDIF
'
~APPL_WRITE(id&,16,msg%)                           ! Weg damit
'
RETURN
' ------------------------------------------------------------------------------
'          HardwareunabhÑngiger Teil - GEM
' ------------------------------------------------------------------------------
'
> PROCEDURE helptxt(search$)
hpath$="D:\SAMPLER\HELPTXT\1STGUIDE.IDX"
msg_id=APPL_FIND("1STGUIDE")
IF msg_id<>-1 THEN
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
@appl_write(msg_id,&H4711,0,0,0,0,0,hpath$)    ! VA_START
accwindopen=FALSE
ON MENU MESSAGE GOSUB message
REPEAT
ON MENU
UNTIL accwindopen=TRUE
@appl_write(msg_id,1025,0,0,0,0,0,search$)                           ! AC_HELP
accwindopen=FALSE
ON MENU MESSAGE GOSUB message
REPEAT
ON MENU
UNTIL accwindopen=TRUE
ELSE
ALERT 1,"1stGuide ist nicht installiert|daher keine Hilfe,sorry !!!",1,"OK",g
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
ENDIF
RETURN
'
> PROCEDURE markhlp
handle&=rsc_handle%(nr)                         ! Fensterhandle des Dialogs
~WIND_GET(handle&,4,ax&,ay&,ab&,ah&)          ! 1. Rechteck
yv=32   ! verschiebung in y-Richtung
xd=ax&+10
yd=ay&-11+yv
xm=615
ym=85
ym2=100
ym3=181
dazu=yd+216
d=22
stay1=yd+d
stay2=yd+d+ym3
DEFTEXT 1,0,0,4
RETURN
'
> PROCEDURE markhlp2
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
LINE xd,stay1,xd,stay2
GRAPHMODE 1
TEXT xd-3,yd+21,t$
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
RETURN
'
> PROCEDURE markhlp3(stxnr,smptnr)
LOCAL sc,sc$
IF tedart=0 THEN
sc=stxnr/(hz*4)
ELSE
sc=INT(stxnr/4)
ENDIF
sc$=STR$(sc)
sc$=LEFT$(sc$+SPACE$(9),9)+CHR$(0)
@textfeld(smptnr,sc$,1)
RETURN
'
> PROCEDURE normalize
makecurve=0
@rsc_back(nr)
vornr=nr
nr=normaliz&
@rsc_draw(nr,5)
@markhlp
@setbutton(normadj&,0)
@setbutton(normauto&,1)
norma=1
@normtest
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,v,v2)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
IF obj=norml1& OR obj=norml2& OR obj=norml3& OR obj=normr1& OR obj=normr2& OR obj=normr3& THEN
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=norml1& OR obj=norml2& OR obj=norml3& THEN
@norml
ENDIF
IF obj=normr1& OR obj=normr2& OR obj=normr3& THEN
@normr
ENDIF
IF obj=normauto& THEN
norma=1
ENDIF
IF obj=normadj& THEN
norma=0
ENDIF
IF obj=helpnorm& THEN
@helptxt("NORMALIZE")
ENDIF
UNTIL obj=normok& OR obj=normexit&
IF obj=normok& THEN
IF norma=1 THEN
@normauto
ENDIF
IF norma=0 THEN
@normadj
ENDIF
ENDIF
@setbutton(obj,0)
@restaura2
@setbutton(norm&,0)
obj=0
RETURN
'
> PROCEDURE fade
GRAPHMODE 3
'  cached=FALSE
vornr=nr
@rsc_back(nr)
nr=editfade&
@rsc_draw(nr,5)
~@xrsrc_gaddr(0,nr,zu%)
boxadr=zu%
@markhlp
tree&=nr
IF fadericht=0 THEN
@setbutton(infade&,33)
ELSE
@setbutton(ausfade&,33)
ENDIF
yma=dazu
FOR i=1 TO fadnr
IF fadericht=0 THEN
y=fadeni(i)+yd+48
ELSE
y=fadeno(i)+yd+48
ENDIF
IF y<>yd+48 THEN
LINE i+xd+8,yma,i+xd+8,y-1
ENDIF
NEXT i
ON MENU MESSAGE GOSUB message
REPEAT
REPEAT
REPEAT
obj=0
REPEAT
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,k,v2)
ON MENU
UNTIL k=1 OR obj<>0
@markhlp
yma=dazu
IF obj=0 THEN
obj=OBJC_FIND(boxadr,0,10,x,y)
ENDIF
UNTIL obj<>0 AND obj<>-1
IF obj=helpfade& THEN
@helptxt("FADE-EDITOR")
ENDIF
IF obj=infade& THEN
@infade
ENDIF
IF obj=ausfade& THEN
@ausfade
ENDIF
IF obj=1 THEN
IF x<xd+8 THEN
x=xd+8
ENDIF
LINE x,y,x,y
xm=x
ym=y
IF fadericht=1 THEN
IF xm>xd+10 THEN
xm=xd+10
ENDIF
ENDIF
REPEAT
~GRAF_MKSTATE(x,y,k,v2)
IF fadericht=0 THEN
IF x>=xm AND x>xd+7 AND x<xd+255 THEN
IF y>ym THEN
y=ym
ENDIF
IF y<(dazu-222) THEN
y=dazu-222
ENDIF
LINE xm,ym,x,y
FOR i=xm TO x
LINE i,yma,i,y
fadeni(i-xd-8)=y-(yd+48)
NEXT i
xm=x
ym=y
ENDIF
ELSE
IF x>=xm AND x>xd+7 AND x<xd+255 THEN
IF ym>y THEN
y=ym
ENDIF
LINE xm,ym,x,y
FOR i=xm TO x
LINE i,yma,i,y
fadeno(i-xd-8)=y-(yd+48)
NEXT i
xm=x
ym=y
ENDIF
ENDIF
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
IF x<xd+255 THEN
@rsc_back(nr)
@rsc_draw(nr,5)
ELSE
FOR i=1 TO fadnr-1
LINE i+xd+8,fadeni(i)+yd+48,i+xd+9,fadeni(i+1)+yd+48
NEXT i
ENDIF
ENDIF
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
IF obj<>fadeup& AND obj<>fadedown& AND obj<>fadeli& AND obj<>fadere& AND obj<>fadelin& AND obj<>helpfade& THEN
aw=FORM_BUTTON(boxadr,obj,1,a)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
ELSE
@setbutton(obj,33)
PAUSE 1
@setbutton(obj,32)
ENDIF
PAUSE 1
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=fadedown& THEN
@fadedown
ENDIF
IF obj=fadeup& THEN
@fadeup
ENDIF
IF obj=fadeli& THEN
@fadelinks
ENDIF
IF obj=fadere& THEN
@faderechts
ENDIF
IF obj=fadelin& THEN
@fadelinear
ENDIF
UNTIL obj=fadeok&
@setbutton(obj,32)
@restaura2
obj=0
@setbutton(edfade&,0)
RETURN
'
> PROCEDURE fadelinear
GRAPHMODE 3
@markhlp
yw=222/fadnr
IF fadericht=0 THEN
ym=dazu
y=ym
FOR i=1 TO fadnr
LINE i+xd+8,ym,i+xd+9,y
fadeni(i)=y-yd-48
y=y-yw
NEXT i
ELSE
ym=dazu
y=dazu-223
FOR i=1 TO fadnr
LINE i+xd+8,ym,i+xd+9,y
fadeno(i)=y-yd-48
y=y+yw
NEXT i
ENDIF
RETURN
'
> PROCEDURE infade
GRAPHMODE 3
@markhlp
fadericht=0
@rsc_back(nr)
@rsc_draw(nr,5)
@setbutton(ausfade&,0)
@setbutton(infade&,1)
'  ~OBJC_DRAW(boxadr,0,99,17,17,yma+20,yma-16)
yma=dazu
FOR i=1 TO fadnr
y=fadeni(i)+yd+48
IF y<>yd+48 THEN
LINE i+xd+8,yma,i+xd+8,y-1
ENDIF
NEXT i
RETURN
'
> PROCEDURE ausfade
GRAPHMODE 3
@markhlp
fadericht=1
@rsc_back(nr)
@rsc_draw(nr,5)
@setbutton(infade&,0)
@setbutton(ausfade&,1)
'  ~OBJC_DRAW(boxadr,0,99,17,17,yma+20,yma-16)
yma=dazu
FOR i=1 TO fadnr
y=fadeno(i)+yd+48
IF y<>yd+48 THEN
LINE i+xd+8,yma,i+xd+8,y-1
ENDIF
NEXT i
RETURN
'
> PROCEDURE blocklook
IF master>10 THEN
sms=msms
sme=msme
ENDIF
IF sms=1 THEN
c1=stax
ENDIF
IF sms=2 THEN
c1=stbx
ENDIF
IF sms=3 THEN
c1=stcx
ENDIF
IF sms=4 THEN
c1=stdx
ENDIF
IF sms=5 THEN
c1=stex
ENDIF
IF sme=1 THEN
c2=eax
ENDIF
IF sme=2 THEN
c2=ebx
ENDIF
IF sme=3 THEN
c2=ecx
ENDIF
IF sme=4 THEN
c2=edx
ENDIF
IF sme=5 THEN
c2=eex
ENDIF
IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 THEN
mce=c2+meml
mce=INT(mce/4)*4
mcs=c1+meml
mcs=INT(mcs/4)*4
ENDIF
RETURN
'
> PROCEDURE smptime
IF hrd=1 THEN
@markhlp
vornr=nr
@rsc_back(nr)
nr=record&
@rsc_draw(nr,5)
@markhlp
min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
@textfeld(timetxt&,min$,1)
oldmin=min
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
PAUSE 2
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=rechelp& THEN
@helptxt("RECORD-TIME")
ENDIF
UNTIL obj=recexit& OR obj=recok& OR obj=recl1& OR obj=recl2& OR obj=recr1& OR obj=recr2&
IF obj=recr1& OR obj=recr2& THEN
IF obj=recr1& AND min<9999 THEN
min=min+1
ENDIF
IF obj=recr2& AND min<9995 THEN
min=min+5
ENDIF
min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
@textfeld(timetxt&,min$,1)
ENDIF
IF obj=recl1& OR obj=recl2& THEN
IF obj=recl1& AND min>1 THEN
min=min-1
ENDIF
IF obj=recl2& AND min>5 THEN
min=min-5
ENDIF
min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
@textfeld(timetxt&,min$,1)
ENDIF
@setbutton(obj,0)
UNTIL obj=recexit& OR obj=recok&
@restaura2
IF obj=recok& THEN
min$=RIGHT$("00000"+STR$(min),5)
min$=min$+" MIN"+CHR$(0)
'     @textfeld(mintext&,min$,1)
ELSE
min=oldmin
ENDIF
ELSE
obj=recok&
ENDIF
RETURN
'
> PROCEDURE smpkhlp
LOCAL makev
makev=FALSE
mrkp$=mp$
ALERT 2,"Kopieren ?",1,"JA|NEIN",g
IF g=1 THEN
IF sms<>0 AND sme<>0 AND sms<6 AND sme<6 THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 AND ((c<>0 AND xmp=-1) OR (c=0 AND xmp=0)) THEN
IF virtual=FALSE THEN
@maschinit10
IF mcs>=meml AND mce+4<memh AND c=1 THEN     !vorwÑrts key
sms=1
sme=1
stax=c2
eax=c2+(c2-c1)
IF eax>vmem THEN
makev=TRUE
ENDIF
IF makev=FALSE THEN
@maschruf10(mcs,mce,mce+4,memh)
ENDIF
ENDIF
IF mcs>=meml AND mce+4<memh AND c=2 THEN   ! ans Ende
sms=1
sme=1
stax=vmem
eax=vmem+(c2-c1)
makev=TRUE
ENDIF
IF mcs>meml AND c=-1 THEN
mcd=mcs-(mce-mcs)
IF mcd<meml THEN
mcd=meml
mcs=mce-(mcs-meml)
ENDIF
@maschruf10(mcs,mce,mcd,mcs)
sms=1
sme=1
eax=c1
stax=c1-(c2-c1)
IF stax<0 THEN
stax=c1
eax=c2
ENDIF
ENDIF
IF mcs>meml AND c=-2 THEN
noms=0
mcd=mcs-(mce-mcs)
IF mcd<meml THEN
noms=1
mcd=meml
mcs=mce-(mcs-meml)
ELSE
mcd=meml
ENDIF
@maschruf10(mcs,mce,mcd,mcs)
sms=1
sme=1
eax=c2-c1
stax=0
IF noms=1 THEN
stax=c1
eax=c2
ENDIF
ENDIF
IF xmp=0 AND c=0 THEN
stax=INT((c1+xmo)/4)*4
eax=INT((c2+xmo)/4)*4
sms=1
sme=1
IF stax<0 THEN
stax=0
eax=c2-c1
ENDIF
IF eax>vmem THEN         ! vor per Maus
makev=TRUE
ENDIF
IF makev=FALSE THEN
ncs=stax+meml
ncs=INT(ncs/4)*4
nce=eax+meml
nce=INT(nce/4)*4
IF ncs>=mce THEN
@maschruf10(mcs,mce,ncs,memh)
ENDIF
IF ncs<mcs THEN
@maschruf10(mcs,mce,ncs,mce)
ENDIF
IF ncs<mce AND ncs>mcs THEN
@maschinit11
@maschruf11(mce,mcs,nce)
ENDIF
ENDIF
ENDIF
IF makev=TRUE THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF stfx>=0 AND efx<=mlen AND sblock=1 THEN
a=stfx
b=efx
ELSE
a=0
b=mlen
ENDIF
b=INT(b/4)*4
a=INT(a/4)*4
v=b-a
v=INT(v/4)*4
IF a>=0 AND b<=mlen THEN
@busy_mouse
BPUT #1,meml+a,v
ENDIF
IF stax>b THEN
seek=v
ELSE
seek=stax
ENDIF
SEEK #1,seek
c=INT((c2-c1)/4)*4
BPUT #1,meml+c1,c
bytes=LOF(#1)
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
vmem=bytes
noblkdel=TRUE
@rettmem
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
IF c=1 THEN
IF virtwfile=FALSE THEN
stax=c2
eax=c2+(c2-c1)
ENDIF
@virtcopy(c1,c2,c2-c1)
ENDIF
IF c=-1 THEN
mm=c1-(c2-c1)
IF mm<0 THEN
mm=0
ENDIF
IF virtwfile=FALSE THEN
eax=c1
stax=c1-(c2-c1)
IF stax<0 THEN
stax=c1
eax=c2
ENDIF
ENDIF
@virtcopy(c1,mm,c2-c1)
ENDIF
IF c=-2 THEN
IF virtwfile=FALSE THEN
eax=c2-c1
stax=0
ENDIF
@virtcopy(c1,0,c2-c1)
ENDIF
IF c=2 THEN
IF virtwfile=FALSE THEN
stax=vmem-(c2-c1)
eax=vmem
ENDIF
@virtcopy(c1,virtln-(c2-c1),c2-c1)
ENDIF
IF xmp=0 AND c=0 THEN
xmo=INT(xmo/4)*4
c1=INT(c1/4)*4
c2=INT(c2/4)*4
@virtcopy(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
@restaura
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE smpmhlp
@movefrag
IF moveart>0 THEN
IF sms<>0 AND sme<>0 AND sms<6 AND sme<6 THEN
@markhlp
@blocklook
'
IF sblock=1 THEN
IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 THEN
IF virtual=FALSE THEN
sms=1
sme=1
'
'
'            IF moveart=3 THEN     ! CLEAR/COPY
IF moveart=100 THEN
IF stfx>=0 AND efx<=mlen THEN
IF mlen>=(c2+xmo) AND (c1+xmo)>=0 THEN
xmo=INT(xmo/4)*4
IF ((c1+xmo)<=efx AND (efx+(c2-c1))<=mlen) OR ((c1+xmo)>efx AND (c1+xmo+(c2-c1))<=mlen) THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>=(c2-c1) THEN
OPEN "O",#1,virt$
@busy_mouse
BPUT #1,c1+meml,c2-c1
CLOSE #1
IF ((c1+xmo)<=efx AND (efx+(c2-c1))<=mlen) THEN
BMOVE ncs,ncs+(c2-c1),efx-stax
efx=efx+(c2-c1)
ENDIF
OPEN "I",#1,virt$
@busy_mouse
BGET #1,ncs,c2-c1
CLOSE #1
KILL virt$
cached=FALSE
ELSE
@nomem
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
makev=TRUE
ENDIF
ENDIF
'
'
IF moveart=4 OR moveart=1 OR moveart=2 THEN
IF xmp=1 AND mcs>meml THEN          ! zum Anfang
@maschinit9
IF moveart=4 THEN
BMOVE mcs,meml,mce-mcs
IF mcs>meml+(mce-mcs) THEN
@maschruf9(mcs,mce)
ELSE
@maschruf9(meml+(mce-mcs),mce)
ENDIF
ENDIF
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
IF moveart=2 THEN                            ! CUT/INS
BMOVE meml,meml+(mce-mcs),mlen-(mce-mcs)
ENDIF
OPEN "I",#1,virt$
BGET #1,meml,mce-mcs
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ENDIF
stax=0
eax=c2-c1
ENDIF
IF xmp=3 THEN                        ! ans Ende
@maschinit9
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
IF moveart=1 THEN
OPEN "I",#1,virt$
BGET #1,memh-(mce-mcs),mce-mcs
CLOSE #1
KILL virt$
eax=(INT(vmem/4)*4)
stax=eax-(c2-c1)
ENDIF
IF moveart=2 THEN
@maschruf9(memh-(mce-mcs),memh)
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
BPUT #1,meml,mlen
OPEN "I",#2,virt$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
CLOSE #2
KILL virt$
bytes=LOF(#1)
stax=mlen
eax=bytes
stax=INT(stax/4)*4
eax=INT(eax/4)*4
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
vmem=bytes
noblkdel=TRUE
@rettmem
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 THEN
IF mce<memh-(mce-mcs) THEN
BMOVE mcs,memh-(mce-mcs),mce-mcs
@maschruf9(mcs,mce)
eax=(INT(vmem/4)*4)
stax=eax-(c2-c1)
ELSE
BMOVE mcs,memh-(mce-mcs),mce-mcs
@maschruf9(mcs,memh-(mce-mcs))
eax=INT(vmem/4)*4
stax=eax-(c2-c1)
ENDIF
ENDIF
ENDIF
IF xmp=2 THEN                        ! zur Mitte
m=((memh-meml)/2)+meml-((mce-mcs)/2)
m=INT(m/4)*4
@maschinit9
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
IF moveart=2 THEN                            ! CUT/INS
BMOVE m,m+(mce-mcs),memh-m-(mce-mcs)
ENDIF
OPEN "I",#1,virt$
BGET #1,m,mce-mcs
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 THEN
IF mcs>=m+(mce-mcs) OR mce<m THEN
BMOVE mcs,m,mce-mcs
@maschruf9(mcs,mce)
ENDIF
IF mcs<m+(mce-mcs) AND mcs>=m AND mce>m+(mce-mcs) THEN
BMOVE mcs,m,mce-mcs
@maschruf9(m+(mce-mcs),mce)
ENDIF
IF mcs<m AND mce>=m AND mce<m+(mce-mcs) THEN
BMOVE mcs,m,mce-mcs
@maschruf9(mcs,m-1)
ENDIF
ENDIF
n=INT((c2-c1)/2)
stax=INT((vmem/2-n)/4)*4
eax=stax+(c2-c1)
ENDIF
IF xmp=0 THEN                     ! Maus-move
mrkstax=stax
mrkeax=eax
stax=INT((c1+xmo)/4)*4
eax=INT((c2+xmo)/4)*4
IF stax<0 THEN
stax=0
eax=c2-c1
ENDIF
IF eax>vmem THEN
eax=INT(vmem/4)*4
stax=eax-(c2-c1)
ENDIF
ncs=stax+meml
ncs=INT(ncs/4)*4
@maschinit9
IF moveart=1 OR moveart=2 THEN
IF ncs<mcs OR ncs>mce THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
OPEN "I",#1,virt$
IF mce<=ncs THEN
IF moveart=2 THEN                            ! CUT/INS
BMOVE ncs-(mce-mcs),ncs,memh-ncs
ENDIF
BGET #1,ncs-(mce-mcs),mce-mcs
stax=stax-(mce-mcs)
stax=INT(stax/4)*4
eax=eax-(mce-mcs)
eax=INT(eax/4)*4
ELSE
IF moveart=2 THEN                            ! CUT/INS
BMOVE ncs,ncs+(mce-mcs),memh-ncs-(mce-mcs)
ENDIF
BGET #1,ncs,mce-mcs
ENDIF
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ELSE
stax=mrkstax
eax=mrkeax
ALERT 1,"Sorry, aber das macht|keinen Sinn !",1,"EXIT",g
ENDIF
ENDIF
IF moveart=4 THEN
BMOVE mcs,ncs,mce-mcs
IF mcs>=ncs+(mce-mcs) OR mce<ncs THEN
@maschruf9(mcs,mce)
ENDIF
IF mcs<ncs+(mce-mcs) AND mcs>=ncs AND mce>ncs+(mce-mcs) THEN
@maschruf9(ncs+(mce-mcs),mce)
ENDIF
IF mcs<ncs AND mce>=ncs AND mce<ncs+(mce-mcs) THEN
@maschruf9(mcs,ncs-1)
ENDIF
ENDIF
ENDIF
ENDIF
ELSE
IF moveart>0 THEN
IF xmp=1 AND mcs>meml THEN        ! an Anfang
IF virtwfile=FALSE THEN
eax=c2-c1
stax=0
ENDIF
@virtmove(c1,0,c2-c1)
ENDIF
IF xmp=2 THEN                     ! zur Mitte
n=INT((c2-c1)/2)
n=INT((vmem/2-n)/4)*4
IF virtwfile=FALSE THEN
stax=n
eax=stax+(c2-c1)
ENDIF
@virtmove(c1,n,c2-c1)
ENDIF
IF xmp=3 THEN                     ! ans Ende
IF virtwfile=FALSE THEN
IF moveart=4 OR moveart=1 THEN
stax=vmem-(c2-c1)
eax=vmem
ELSE
stax=vmem
eax=vmem+(c2-c1)
ENDIF
ENDIF
IF moveart=4 OR moveart=1 THEN
@virtmove(c1,virtln-(c2-c1),c2-c1)
ELSE
@virtmove(c1,virtln,c2-c1)
ENDIF
ENDIF
IF xmp=0 THEN             ! Maus-move
xmo=INT(xmo/4)*4
c1=INT(c1/4)*4
c2=INT(c2/4)*4
@virtmove(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
ENDIF
cached=FALSE
@restaura
ENDIF
ELSE
ALERT 1,"Block undefiniert !",1,"EXIT",g
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE smpihlp                     ! Routine fÅr mem fehlt noch
LOCAL makev
mrkp$=mp$
makev=FALSE
ALERT 2,"EinfÅgen ?",1,"JA|NEIN",g
IF g=1 THEN
IF sms<>0 AND sme<>0 AND sms<6 AND sme<6 THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 THEN
IF virtual=FALSE THEN
IF sblock=1 THEN
IF xmp=1 THEN
xmo=-c1
ENDIF
IF xmp=3 THEN
xmo=mlen-c2
ENDIF
IF xmp=2 THEN
m=mlen/2
m=INT(m/4)*4
xmo=m-c1
ENDIF
IF stfx>=0 AND efx<=mlen THEN
sms=1
sme=1
IF mlen>=(c2+xmo) AND (c1+xmo)>=0 THEN
xmo=INT(xmo/4)*4
IF ((c1+xmo)<=efx AND (efx+(c2-c1))<=mlen) OR ((c1+xmo)>efx AND (c1+xmo+(c2-c1))<=mlen) THEN
stax=INT((c1+xmo)/4)*4
eax=INT((c2+xmo)/4)*4
IF stax<0 THEN
stax=0
eax=c2-c1
ENDIF
IF eax>vmem THEN
eax=INT(vmem/4)*4
stax=eax-(c2-c1)
ENDIF
ncs=stax+meml
ncs=INT(ncs/4)*4
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>=(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
@busy_mouse
BPUT #1,c1+meml,c2-c1
CLOSE #1
IF ((c1+xmo)<=efx AND (efx+(c2-c1))<=mlen) THEN
BMOVE ncs,ncs+(c2-c1),efx-stax
efx=efx+(c2-c1)
ENDIF
OPEN "I",#1,lfw$+workfile$
@busy_mouse
BGET #1,ncs,c2-c1
CLOSE #1
KILL lfw$+workfile$
cached=FALSE
ELSE
@nomem
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
ALERT 1,"Block undefiniert !",1,"EXIT",g
ENDIF
IF makev=TRUE THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF stfx>=0 AND efx<=mlen AND sblock=1 THEN
a=stfx
b=efx
ELSE
a=0
b=mlen
ENDIF
IF a>=0 AND b<=mlen THEN
IF (c1+xmo)<a THEN
@busy_mouse
BPUT #1,meml+c1,c2-c1
BPUT #1,meml+a,b-a
ENDIF
IF (c1+xmo)>=a AND (c1+xmo)<=b THEN
@busy_mouse
BPUT #1,meml+a,(c1+xmo)-a
BPUT #1,meml+c1,c2-c1
IF (c1+xmo)<b THEN
BPUT #1,meml+c1+xmo,b-(c1+xmo)
ENDIF
ENDIF
IF (c1+xmo)>b THEN
@busy_mouse
BPUT #1,meml,b-a
BPUT #1,meml+c1,c2-c1
ENDIF
ENDIF
bytes=LOF(#1)
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
vmem=bytes
noblkdel=TRUE
@rettmem
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
IF xmp=1 THEN
IF virtwfile=FALSE THEN
stax=0
eax=c2-c1
ENDIF
@virtins(c1,0,c2-c1)
ENDIF
IF xmp=2 THEN
m=(virtln/2)
m=INT(m/4)*4
IF virtwfile=FALSE THEN
stax=m
eax=m+(c2-c1)
ENDIF
@virtins(c1,m,c2-c1)
ENDIF
IF xmp=3 THEN
IF virtwfile=FALSE THEN
stax=virtln
eax=virtln+(c2-c1)
ENDIF
@virtins(c1,virtln,c2-c1)
ENDIF
IF xmp=0 THEN
xmo=INT(xmo/4)*4
c1=INT(c1/4)*4
c2=INT(c2/4)*4
@virtins(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
@restaura
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE markprod2
IF stax<>-1 THEN
t$="A"
@markhandler(stax,*stax,stay1,stay2,xd,ym)
@markhlp3(stax,smptsa&)
ENDIF
IF stbx<>-1 THEN
t$="B"
@markhandler(stbx,*stbx,stay1,stay2,xd,ym)
@markhlp3(stbx,smptsb&)
ENDIF
IF stcx<>-1 THEN
t$="C"
@markhandler(stcx,*stcx,stay1,stay2,xd,ym)
@markhlp3(stcx,smptsc&)
ENDIF
IF stdx<>-1 THEN
t$="D"
@markhandler(stdx,*stdx,stay1,stay2,xd,ym)
@markhlp3(stdx,smptsd&)
ENDIF
IF stex<>-1 THEN
t$="E"
@markhandler(stex,*stex,stay1,stay2,xd,ym)
@markhlp3(stex,smptse&)
ENDIF
IF stfx<>-1 THEN
t$="S"
@markhandler(stfx,*stfx,stay1,stay2,xd,ym)
@markhlp3(stfx,smptsava&)
ENDIF
IF eax<>-1 THEN
t$="A"
@markhandler(eax,*eax,stay1,stay2,xd,ym)
@markhlp3(eax,smptea&)
ENDIF
IF ebx<>-1 THEN
t$="B"
@markhandler(ebx,*ebx,stay1,stay2,xd,ym)
@markhlp3(ebx,smpteb&)
ENDIF
IF ecx<>-1 THEN
t$="C"
@markhandler(ecx,*ecx,stay1,stay2,xd,ym)
@markhlp3(ecx,smptec&)
ENDIF
IF edx<>-1 THEN
t$="D"
@markhandler(edx,*edx,stay1,stay2,xd,ym)
@markhlp3(edx,smpted&)
ENDIF
IF eex<>-1 THEN
t$="E"
@markhandler(eex,*eex,stay1,stay2,xd,ym)
@markhlp3(eex,smptee&)
ENDIF
IF efx<>-1 THEN
t$="S"
@markhandler(efx,*efx,stay1,stay2,xd,ym)
@markhlp3(efx,smptsavb&)
ENDIF
RETURN
'
> PROCEDURE markprod3
IF nr=smpedit& THEN
IF stax<>-1 THEN
t$="A"
@markhlp3(stax,smptsa&)
@markhlp4(stax)
@markhlp5(stax)
ENDIF
IF stbx<>-1 THEN
t$="B"
@markhlp3(stbx,smptsb&)
@markhlp4(stbx)
@markhlp5(stbx)
ENDIF
IF stcx<>-1 THEN
t$="C"
@markhlp3(stcx,smptsc&)
@markhlp4(stcx)
@markhlp5(stcx)
ENDIF
IF stdx<>-1 THEN
t$="D"
@markhlp3(stdx,smptsd&)
@markhlp4(stdx)
@markhlp5(stdx)
ENDIF
IF stex<>-1 THEN
t$="E"
@markhlp3(stex,smptse&)
@markhlp4(stex)
@markhlp5(stex)
ENDIF
IF stfx<>-1 THEN
t$="S"
@markhlp3(stfx,smptsava&)
@markhlp4(stfx)
@markhlp5(stfx)
ENDIF
IF eax<>-1 THEN
t$="A"
@markhlp3(eax,smptea&)
@markhlp4(eax)
@markhlp5(eax)
ENDIF
IF ebx<>-1 THEN
t$="B"
@markhlp3(ebx,smpteb&)
@markhlp4(ebx)
@markhlp5(ebx)
ENDIF
IF ecx<>-1 THEN
t$="C"
@markhlp3(ecx,smptec&)
@markhlp4(ecx)
@markhlp5(ecx)
ENDIF
IF edx<>-1 THEN
t$="D"
@markhlp3(edx,smpted&)
@markhlp4(edx)
@markhlp5(edx)
ENDIF
IF eex<>-1 THEN
t$="E"
@markhlp3(eex,smptee&)
@markhlp4(eex)
@markhlp5(eex)
ENDIF
IF efx<>-1 THEN
t$="S"
@markhlp3(efx,smptsavb&)
@markhlp4(efx)
@markhlp5(efx)
ENDIF
IF master=0 AND sms=1 THEN
master=1
ENDIF
IF master=0 AND sms=2 THEN
master=2
ENDIF
IF master=0 AND sms=3 THEN
master=3
ENDIF
IF master=0 AND sms=4 THEN
master=4
ENDIF
IF master=0 AND sms=5 THEN
master=5
ENDIF
IF master=0 AND sme=1 THEN
master=6
ENDIF
IF master=0 AND sme=2 THEN
master=7
ENDIF
IF master=0 AND sme=3 THEN
master=8
ENDIF
IF master=0 AND sme=4 THEN
master=9
ENDIF
IF master=0 AND sme=5 THEN
master=10
ENDIF
IF master=1 THEN
masthlp=hacksa&
ENDIF
IF master=2 THEN
masthlp=hacksb&
ENDIF
IF master=3 THEN
masthlp=hacksc&
ENDIF
IF master=4 THEN
masthlp=hacksd&
ENDIF
IF master=5 THEN
masthlp=hackse&
ENDIF
IF master=6 THEN
masthlp=hackea&
ENDIF
IF master=7 THEN
masthlp=hackeb&
ENDIF
IF master=8 THEN
masthlp=hackec&
ENDIF
IF master=9 THEN
masthlp=hacked&
ENDIF
IF master=10 THEN
masthlp=hackee&
ENDIF
IF master<>0 AND master<11 THEN
@textfeld(masthlp,""+CHR$(0),1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE smph2
IF master=1 THEN
t$="A"
@markhandl2(stax,*stax,stay1,stay2,xd,ym)
@markhlp3(stax,smptsa&)
ENDIF
IF master=2 THEN
t$="B"
@markhandl2(stbx,*stbx,stay1,stay2,xd,ym)
@markhlp3(stbx,smptsb&)
ENDIF
IF master=3 THEN
t$="C"
@markhandl2(stcx,*stcx,stay1,stay2,xd,ym)
@markhlp3(stcx,smptsc&)
ENDIF
IF master=4 THEN
t$="D"
@markhandl2(stdx,*stdx,stay1,stay2,xd,ym)
@markhlp3(stdx,smptsd&)
ENDIF
IF master=5 THEN
t$="E"
@markhandl2(stex,*stex,stay1,stay2,xd,ym)
@markhlp3(stex,smptse&)
ENDIF
IF master=6 THEN
t$="A"
@markhandl2(eax,*eax,stay1,stay2,xd,ym)
@markhlp3(eax,smptea&)
ENDIF
IF master=7 THEN
t$="B"
@markhandl2(ebx,*ebx,stay1,stay2,xd,ym)
@markhlp3(ebx,smpteb&)
ENDIF
IF master=8 THEN
t$="C"
@markhandl2(ecx,*ecx,stay1,stay2,xd,ym)
@markhlp3(ecx,smptec&)
ENDIF
IF master=9 THEN
t$="D"
@markhandl2(edx,*edx,stay1,stay2,xd,ym)
@markhlp3(edx,smpted&)
ENDIF
IF master=10 THEN
t$="E"
@markhandl2(eex,*eex,stay1,stay2,xd,ym)
@markhlp3(eex,smptee&)
ENDIF
IF master=11 THEN
t$="S"
@markhandl2(stfx,*stfx,stay1,stay2,xd,ym)
@markhlp3(stfx,smptsava&)
ENDIF
IF master=12 THEN
t$="S"
@markhandl2(efx,*efx,stay1,stay2,xd,ym)
@markhlp3(efx,smptsavb&)
ENDIF
RETURN
'
> PROCEDURE smpanf
IF smark=6 THEN
xmo=0
xmp=1
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=0
xmp=1
@smpihlp
ENDIF
IF smark=5 THEN
c=-2
@smpkhlp
ENDIF
'  IF smark=4 THEN
'  min=1
'  min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
'  @textfeld(recmin&,min$,1)
' ENDIF
IF smark=3 THEN
@smph1
x=0
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=1
@zoomhelp
ENDIF
@setbutton(smpanf&,0)
RETURN
'
> PROCEDURE smpend
IF smark=6 THEN
xmp=3
xmo=xm
@smpmhlp
ENDIF
IF smark=4 THEN
xmp=3
xmo=xm
@smpihlp
ENDIF
IF smark=5 THEN
c=2
@smpkhlp
ENDIF
'  IF smark=4 THEN
'  min=9999
'  min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
'  @textfeld(recmin&,min$,1)
' ENDIF
IF smark=3 THEN
@smph1
x=vmem
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=lzmrk
@zoomhelp
ENDIF
@setbutton(smpend&,0)
RETURN
'
> PROCEDURE smpmid
IF smark=6 THEN
xmo=xm/2
xmp=2
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=xm/2
xmp=2
@smpihlp
ENDIF
'  IF smark=4 THEN
'  min=5000
'  min$=RIGHT$("00000"+STR$(min),5)+CHR$(0)
'  @textfeld(recmin&,min$,1)
' ENDIF
IF smark=3 THEN
@smph1
x=INT(vmem/2)
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=INT(lzmrk/2)
IF lz=0 THEN
lz=1
ENDIF
@zoomhelp
ENDIF
@setbutton(smpmid&,0)
RETURN
'
> PROCEDURE zoomhelp
cs=lcs(lz)
ce=lce(lz)
@curvetest(cs,ce)
IF zoomstop=FALSE THEN
@markhlp
ELSE
lz=lzhold
ENDIF
IF xm>0 AND ce>cs THEN
cached=FALSE
@restaura
ENDIF
RETURN
'
> PROCEDURE smpl
LOCAL mf
@markhlp
c=0
IF smark=6 OR smark=4 THEN
xmp=0
@blocklook
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
IF obj=smpl1& THEN
xmo=INT((c2-c1)/16)*4
xmo=-xmo
ENDIF
IF obj=smpl2& THEN
xmo=INT((c2-c1)/8)*4
xmo=-xmo
ENDIF
IF obj=smpl3& THEN
xmo=INT((c2-c1)/4)*4
xmo=-xmo
ENDIF
IF smark=6 THEN
@smpmhlp
ELSE
@smpihlp
ENDIF
ENDIF
ENDIF
IF smark=5 THEN
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
c=-1
@smpkhlp
ENDIF
ENDIF
IF smark=3 THEN
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
@smph1
mf=INT((ce-cs)/xm/4)*4
IF obj=smpl1& THEN
IF ((ce-cs)/4)>xm THEN
x=x-1*mf
ELSE
x=x-4
ENDIF
ENDIF
IF obj=smpl2& THEN
IF ((ce-cs)/4)>xm THEN
x=x-3*mf
ELSE
x=x-3*4
ENDIF
ENDIF
IF obj=smpl3& THEN
IF ((ce-cs)/4)>xm THEN
x=x-10*mf
ELSE
x=x-10*4
ENDIF
ENDIF
@smph2
ENDIF
ENDIF
IF smark=2 THEN
IF lz>1 THEN
@smph1
IF obj=smpl1& THEN
xs=1
ENDIF
IF obj=smpl2& THEN
xs=2
ENDIF
IF obj=smpl3& THEN
xs=3
ENDIF
IF lz>xs AND (obj=smpl1& OR obj=smpl2& OR obj=smpl3&) THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& AND v4=0 THEN
lzhold=lz
lz=lz-xs
@zoomhelp
ENDIF
IF obj=smpl1& AND v4<>0 THEN
ce=((ce-cs)*1.5)+cs
IF ce>memh THEN
ce=memh
ENDIF
ce=INT(ce/4)*4
IF xm>0 AND ce>cs THEN
cached=FALSE
@restaura
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF smark=1 THEN
IF obj=smpl1& THEN
xs=(ce-cs)/4
ENDIF
IF obj=smpl2& THEN
xs=(ce-cs)/2
ENDIF
IF obj=smpl3& THEN
xs=ce-cs
ENDIF
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
IF cs-xs>0 THEN
cs=cs-xs
cs=INT(cs/4)*4
ce=ce-xs
ce=INT(ce/4)*4
ELSE
u=cs
cs=0
ce=ce-u
ce=INT(ce/4)*4
ENDIF
cached=FALSE
@restaura
ENDIF
ENDIF
RETURN
'
> PROCEDURE smpr
LOCAL mf
@markhlp
c=0
IF smark=6 OR smark=4 THEN
xmp=0
@blocklook
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
IF obj=smpr1& THEN
xmo=INT((c2-c1)/16)*4
ENDIF
IF obj=smpr2& THEN
xmo=INT((c2-c1)/8)*4
ENDIF
IF obj=smpr3& THEN
xmo=INT((c2-c1)/4)*4
ENDIF
IF smark=6 THEN
@smpmhlp
ELSE
@smpihlp
ENDIF
ENDIF
ENDIF
IF smark=5 THEN
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
c=1
@smpkhlp
ENDIF
ENDIF
IF smark=3 THEN
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@smph1
mf=INT((ce-cs)/xm/4)*4
IF obj=smpr1& THEN
IF ((ce-cs)/4)>xm THEN
x=x+1*mf
ELSE
x=x+4
ENDIF
ENDIF
IF obj=smpr2& THEN
IF ((ce-cs)/4)>xm THEN
x=x+3*mf
ELSE
x=x+3*4
ENDIF
ENDIF
IF obj=smpr3& THEN
IF ((ce-cs)/4)>xm THEN
x=x+10*mf
ELSE
x=x+10*4
ENDIF
ENDIF
@smph2
ENDIF
ENDIF
IF smark=2 THEN
IF lz<lmax THEN
@smph1
IF obj=smpr1& THEN
xs=1
xmul=1.5
ENDIF
IF obj=smpr2& THEN
xs=1
xmul=2
ENDIF
IF obj=smpr3& THEN
xs=1
xmul=3
ENDIF
IF (lz+xs)<lmax AND (obj=smpr1& OR obj=smpr2& OR obj=smpr3&) THEN
@curvetest(cs,ce)
IF zoomstop=FALSE THEN
lcs(lz)=cs
lce(lz)=ce
@markhlp
IF sms=1 THEN
dcs=stax
ENDIF
IF sms=2 THEN
dcs=stbx
ENDIF
IF sms=3 THEN
dcs=stcx
ENDIF
IF sms=4 THEN
dcs=stdx
ENDIF
IF sms=5 THEN
dcs=stex
ENDIF
IF sme=1 THEN
dce=eax
ENDIF
IF sme=2 THEN
dce=ebx
ENDIF
IF sme=3 THEN
dce=ecx
ENDIF
IF sme=4 THEN
dce=edx
ENDIF
IF sme=5 THEN
dce=eex
ENDIF
IF sms=0 THEN
dcs=0
ENDIF
IF sme=0 THEN
dce=INT(ce-cs)
ENDIF
lz=lz+xs
lzmrk=lz
cs=dcs
IF dce>=ce THEN
ce=INT(((ce-cs)/xmul)+cs)
ELSE
ce=dce
ENDIF
ce=INT(ce/4)*4
lcs(lz)=cs
lce(lz)=ce
IF xm>0 AND ce>cs THEN
cached=FALSE
@restaura
ENDIF
ELSE
ALERT 1,"Sample-Auflîsungsgrenze|erreicht !",1,"OK",g
ENDIF
ENDIF
ENDIF
ENDIF
IF smark=1 THEN
IF obj=smpr1& THEN
xs=(ce-cs)/4
ENDIF
IF obj=smpr2& THEN
xs=(ce-cs)/2
ENDIF
IF obj=smpr3& THEN
xs=ce-cs
ENDIF
IF ce+xs<vmem THEN
cs=cs+xs
cs=INT(cs/4)*4
ce=ce+xs
ce=INT(ce/4)*4
ELSE
u=vmem-ce
cs=cs+u
cs=INT(cs/4)*4
ce=ce+u
ce=INT(ce/4)*4
ENDIF
cached=FALSE
@restaura
ENDIF
RETURN
'
> PROCEDURE movemark(strtmark,mdif)
IF (stax>(strtmark-mdif) AND mdif<0) OR (stax<strtmark AND mdif>0) THEN
stax=stax+mdif
ENDIF
IF (stbx>(strtmark-mdif) AND mdif<0) OR (stbx<strtmark AND mdif>0) THEN
stbx=stbx+mdif
ENDIF
IF (stcx>(strtmark-mdif) AND mdif<0) OR (stcx<strtmark AND mdif>0) THEN
stcx=stcx+mdif
ENDIF
IF (stdx>(strtmark-mdif) AND mdif<0) OR (stdx<strtmark AND mdif>0) THEN
stdx=stdx+mdif
ENDIF
IF (stex>(strtmark-mdif) AND mdif<0) OR (stex<strtmark AND mdif>0) THEN
stex=stex+mdif
ENDIF
IF (stfx>(strtmark-mdif) AND mdif<0) OR (stfx<strtmark AND mdif>0) THEN
stfx=stfx+mdif
ENDIF
IF (eax>(strtmark-mdif) AND mdif<0) OR (eax<strtmark AND mdif>0) THEN
eax=eax+mdif
ENDIF
IF (ebx>(strtmark-mdif) AND mdif<0) OR (ebx<strtmark AND mdif>0) THEN
ebx=ebx+mdif
ENDIF
IF (ecx>(strtmark-mdif) AND mdif<0) OR (ecx<strtmark AND mdif>0) THEN
ecx=ecx+mdif
ENDIF
IF (edx>(strtmark-mdif) AND mdif<0) OR (edx<strtmark AND mdif>0) THEN
edx=edx+mdif
ENDIF
IF (eex>(strtmark-mdif) AND mdif<0) OR (eex<strtmark AND mdif>0) THEN
eex=eex+mdif
ENDIF
IF (efx>(strtmark-mdif) AND mdif<0) OR (efx<strtmark AND mdif>0) THEN
efx=efx+mdif
ENDIF
RETURN
'
> PROCEDURE movemark2(strtmark,endmark,mdif)
IF stax>=strtmark AND stax<=endmark THEN
stax=stax+mdif
ENDIF
IF stbx>=strtmark AND stbx<=endmark THEN
stbx=stbx+mdif
ENDIF
IF stcx>=strtmark AND stcx<=endmark THEN
stcx=stcx+mdif
ENDIF
IF stdx>=strtmark AND stdx<=endmark THEN
stdx=stdx+mdif
ENDIF
IF stex>=strtmark AND stex<=endmark THEN
stex=stex+mdif
ENDIF
IF stfx>=strtmark AND stfx<=endmark THEN
stfx=stfx+mdif
ENDIF
IF eax>=strtmark AND eax<=endmark THEN
eax=eax+mdif
ENDIF
IF ebx>=strtmark AND ebx<=endmark THEN
ebx=ebx+mdif
ENDIF
IF ecx>=strtmark AND ecx<=endmark THEN
ecx=ecx+mdif
ENDIF
IF edx>=strtmark AND edx<=endmark THEN
edx=edx+mdif
ENDIF
IF eex>=strtmark AND eex<=endmark THEN
eex=eex+mdif
ENDIF
IF efx>=strtmark AND efx<=endmark THEN
efx=efx+mdif
ENDIF
RETURN
'
> PROCEDURE smpcut
LOCAL okay,vln,ml,delrange
vornr=nr
@rsc_back(nr)
nr=cutedit&
@rsc_draw(nr,5)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
PAUSE 2
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=cuthelp& THEN
@helptxt("CUT")
ENDIF
UNTIL obj=cutexit& OR obj=cutin& OR obj=cutout& OR obj=cutdel&
@setbutton(obj,0)
IF sms<>0 AND sme<>0 AND sms<6 AND sme<6 AND obj<>cutexit& THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 THEN
@maschinit9
IF virtual=FALSE THEN
IF obj=cutout& THEN
IF mcs>meml THEN
@maschruf9(meml,mcs)
ENDIF
IF memh>mce THEN
@maschruf9(mce,memh)
ENDIF
ENDIF
IF obj=cutin& THEN
@maschruf9(mcs,mce)
ENDIF
IF obj=cutdel& THEN
IF mce>mcs AND mcs>=meml THEN
mce=INT(mce/4)*4
@maschinit9
@maschruf9(mcs,mce)
IF mce<memh THEN
delrange=(memh-(mce+4))
BMOVE mce+4,mcs,delrange
@maschruf9(memh-(mce-mcs),memh)
@movemark(c1,c1-c2)
ENDIF
ENDIF
ENDIF
ELSE
virtln2=virtln
c1=INT(c1/4)*4
c2=INT(c2/4)*4
virtln2=INT(virtln2/4)*4
okay=FALSE
IF virtwfile=FALSE AND obj<>cutdel& THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
seekz=0
ml=INT(mlen/4)*4
IF c1>0 THEN
IF okay=TRUE THEN
vln=c1
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=ml
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutout& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln=0
ENDIF
ENDIF
virtln2=virtln2-seekz
IF c2>c1 AND c2<=virtln THEN
IF okay=TRUE THEN
vln=c2-c1
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutin& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
IF obj<>cutdel& THEN
BPUT #2,meml,bytes
ENDIF
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln=0
virtln2=virtln2-(c2-c1)
ENDIF
ENDIF
IF c2<virtln THEN
IF okay=TRUE THEN
vln=virtln2
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutout& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
ENDIF
ENDIF
IF okay=TRUE THEN
CLOSE #1
IF virtwfile=TRUE OR obj=cutdel& THEN
CLOSE #2
ENDIF
IF virtwfile=FALSE AND obj=cutdel& THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
path$=virtpath$
@hardproof3
vmem=INT(virtln/4)*4
@memtovirt2
ENDIF
IF virtwfile=FALSE AND (obj=cutin& OR obj=cutout&) THEN
path$=virtpath$
@hardproof3
vmem=INT(virtln/4)*4
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@restaura2
obj=0
@setbutton(cut&,0)
RETURN
'
> PROCEDURE movefrag
vornr=nr
@rsc_back(nr)
nr=moving&
@rsc_draw(nr,5)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
PAUSE 2
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=movhlp& THEN
@helptxt("MOVE")
ENDIF
UNTIL obj=mvcutcpy& OR obj=mvcutins& OR obj=mvclrins& OR obj=mvclrcpy& OR obj=movexit&
@setbutton(obj,0)
moveart=0
IF obj=mvcutcpy& THEN
moveart=1
ENDIF
IF obj=mvcutins& THEN
moveart=2
ENDIF
IF obj=mvclrins& THEN
moveart=3
ENDIF
IF obj=mvclrcpy& THEN
moveart=4
ENDIF
@restaura2
obj=0
@setbutton(moving&,0)
RETURN
'
> PROCEDURE virtmove(ks,kd,kl)
IF ks<>kd THEN
sms=1
sme=1
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=vln+kl THEN
IF moveart=4 OR ((moveart=1 OR moveart=3 OR moveart=2) AND (kd>ks+kl OR kd<ks))
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 OR moveart=3 OR moveart=2 THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
IF moveart=4 THEN               ! CLR/COPY
vln=virtln
ENDIF
IF moveart=1 OR (moveart=2 AND kd>ks+kl) THEN               ! CUT/COPY
vln=ks
ENDIF
IF moveart=3 OR (moveart=2 AND kd<ks) THEN               ! CLR/INS
vln=kd
ENDIF
bytes=INT(mlen/4)*4
IF vln>0 THEN
REPEAT                          ! Source in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
IF moveart=3 OR (moveart=2 AND kd<ks) THEN
seek=0
vln=kl
bytes=INT(mlen/4)*4
REPEAT                          ! Sourceblock in Destblock kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
SEEK #1,ks+seek
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
IF moveart=1 OR moveart=3 OR (moveart=2 AND (kd>ks+kl OR kd<ks)) THEN    ! bei CUT/COPY den Sourceteil weglassen, den Rest kopieren
IF moveart=1 THEN
SEEK #1,ks+kl
vln=virtln-(ks+kl)
ENDIF
IF moveart=3 THEN
SEEK #1,kd
vln=virtln-kd
ENDIF
IF moveart=2 AND kd>ks+kl THEN    ! StÅck zwischen Sourceende und Destanfang kopieren
SEEK #1,ks+kl
vln=kd-(ks+kl)
ENDIF
IF moveart=2 AND kd<ks THEN   ! StÅck zwischen Destende und Sourceanfang kopieren
SEEK #1,kd
vln=ks-kd
ENDIF
vln=INT(vln/4)*4
bytes=INT(mlen/4)*4
IF vln>0 THEN
REPEAT                          ! Source in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ENDIF
IF moveart=2 AND (kd>ks+kl OR kd<ks) THEN
IF kd>ks+kl THEN
SEEK #1,ks
vln=kl
vln=INT(vln/4)*4
bytes=INT(mlen/4)*4
REPEAT                          ! Sourceblock in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
IF kd>ks+kl THEN
SEEK #1,kd
vln=virtln-kd
ENDIF
IF kd<ks THEN
SEEK #1,ks+kl
vln=virtln-(ks+kl)
ENDIF
vln=INT(vln/4)*4
bytes=INT(mlen/4)*4
IF vln>0 THEN
REPEAT                          ! Von Dest bis Ende in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ENDIF
CLOSE #2
OPEN "U",#2,virtp$
IF moveart<>2 THEN
IF kd<ks OR moveart=4 THEN
SEEK #2,kd
ELSE
SEEK #2,kd-kl
ENDIF
ENDIF
ELSE
OPEN "U",#1,virtpath$
ENDIF
IF moveart=1 OR moveart=4 THEN
vln=INT(kl/4)*4
bytes=INT(mlen/4)*4
seek=0
REPEAT                                ! Sourceblock nach Destblock kopieren
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
IF moveart=4 OR moveart=3 THEN                   ! nur fÅr CLR/COPY und CLR/INS
vln=INT(kl/4)*4
IF moveart=3 AND kd<ks AND kd+kl>ks THEN
vln=ks-kd
vln=INT(vln/4)*4
ENDIF
bytes=INT(mlen/4)*4
@maschinit9
IF vln>=bytes THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+vln)
ENDIF
seek=0
IF moveart=3 AND kd<ks
seek=kl
ENDIF
IF moveart=3 AND kd<ks AND kd+kl>ks THEN
seek=kl*2-vln
ENDIF
IF kd>ks AND kd<(ks+kl) AND moveart=4 THEN
vln=kd-ks
vln=INT(vln/4)*4
ENDIF
IF kd<ks AND kd+kl>ks AND moveart=4 THEN
vln=ks-kd
vln=INT(vln/4)*4
seek=kd+kl-ks
seek=INT(seek/4)*4
ENDIF
IF vln>0 THEN
REPEAT                             ! Source mit Zero Åberschreiben
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=3 THEN
SEEK #2,ks+seek
BPUT #2,meml,bytes
ELSE
SEEK #1,ks+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
ENDIF
CLOSE #1
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 OR moveart=3 OR moveart=2 THEN ! Source del,Dest-Source rename
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
ENDIF
IF virtwfile=FALSE THEN                                ! Display erneuern
path$=virtpath$
@hardproof3
vmem=INT(virtln/4)*4
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF (moveart=2 OR moveart=3 OR moveart=1) AND kd<=ks+kl AND kd>ks
ALERT 1,"Sorry, aber das macht|keinen Sinn !",1,"EXIT",g
ENDIF
ELSE
@nomem
ENDIF
ENDIF
RETURN
'
> PROCEDURE virtcopy(ks,kd,kl)
IF ks<>kd THEN
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=vln+kl THEN
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
vln=virtln
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #2
OPEN "U",#2,virtp$
SEEK #2,kd
ELSE
OPEN "U",#1,virtpath$
ENDIF
vln=INT(kl/4)*4
bytes=INT(mlen/4)*4
seek=0
REPEAT
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
CLOSE #1
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
ENDIF
IF virtwfile=FALSE THEN
path$=virtpath$
@hardproof3
vmem=INT(virtln/4)*4
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
ENDIF
RETURN
'
> PROCEDURE virtins(ks,kd,kl)
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=vln+kl THEN
IF virtwfile=TRUE OR kd<virtln THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
vln=INT(kd/4)*4
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
'
vln=INT(kl/4)*4
bytes=INT(mlen/4)*4
SEEK #1,ks
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
'
vln=INT((virtln-kd)/4)*4
bytes=INT(mlen/4)*4
SEEK #1,kd
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
CLOSE #1
CLOSE #2
ELSE
OPEN "U",#1,virtpath$
vln=INT(kl/4)*4
bytes=INT(mlen/4)*4
seek=0
REPEAT
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
CLOSE #1
ENDIF
IF virtwfile=FALSE AND kd<virtln THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
IF virtwfile=FALSE THEN
path$=virtpath$
@hardproof3
vmem=INT(virtln/4)*4
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE markhandl4
~GRAF_MKSTATE(v,y,v3,v4)
IF y>=stay1 AND y<=stay2 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
IF smark=6 OR smark=5 OR smark=4 THEN
xmp=0
c=0
ENDIF
tx=x-(x-vc1)
tx2=x+(vc2-x)
tm=tx
tm2=tx2
COLOR 0
GRAPHMODE 3
FOR i=vc1-5 TO vc1+5
'      LINE i+xd,stay1+1,i+xd,stay1-5
NEXT i
FOR i=vc2-5 TO vc2+5
'     LINE i+xd,stay1+1,i+xd,stay1-5
NEXT i
COLOR 1
d1=x-vc1
d2=vc2-x
GRAPHMODE 3
REPEAT
~GRAF_MKSTATE(x,y,k,v4)
IF x-d1>=0 AND x+d2<=xm AND y>=stay1 AND y<=stay2 AND x<>x2 THEN
LINE tx+xd,stay1+1,tx+xd,stay2
LINE tx2+xd,stay1+1,tx2+xd,stay2
tx=x-d1
tx2=x+d2
x2=x
LINE tx+xd,stay1+1,tx+xd,stay2
LINE tx2+xd,stay1+1,tx2+xd,stay2
ENDIF
UNTIL k=0
GRAPHMODE 3
TEXT tx+xd-3,stay1,t$
TEXT tx2+xd-3,stay1,t2$
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE edhandler2
LOCAL xw
xmp=-1
c=0
~GRAF_MKSTATE(x,y,k,v4)
IF k=2 AND y>=stay1 AND y<=stay2 THEN
xw=x
IF k=2 AND xw>=xd AND xw<=(xm+xd) AND xm>0 AND ce>cs THEN
@markhlp
IF xw>=xd AND xw<=(xm+xd) AND xm>0 AND ce>cs THEN
@smph1
IF master>0 AND x>ce OR x<cs THEN
xx=INT(((ce-cs)/xm*(xw-xd)+cs)/4)*4
IF master=1 THEN
stax=xx
t$="A"
@markhlp3(stax,smptsa&)
ENDIF
IF master=2 THEN
stbx=xx
t$="B"
@markhlp3(stbx,smptsb&)
ENDIF
IF master=3 THEN
stcx=xx
t$="C"
@markhlp3(stcx,smptsc&)
ENDIF
IF master=4 THEN
stdx=xx
t$="D"
@markhlp3(stdx,smptsd&)
ENDIF
IF master=5 THEN
stex=xx
t$="E"
@markhlp3(stex,smptse&)
ENDIF
IF master=6 THEN
eax=xx
t$="A"
@markhlp3(eax,smptea&)
ENDIF
IF master=7 THEN
ebx=xx
t$="B"
@markhlp3(ebx,smpteb&)
ENDIF
IF master=8 THEN
ecx=xx
t$="C"
@markhlp3(ecx,smptec&)
ENDIF
IF master=9 THEN
edx=xx
t$="D"
@markhlp3(edx,smpted&)
ENDIF
IF master=10 THEN
eex=xx
t$="E"
@markhlp3(eex,smptee&)
ENDIF
IF master=11 THEN
stfx=xx
t$="S"
@markhlp3(stfx,smptsava&)
ENDIF
IF master=12 THEN
efx=xx
t$="S"
@markhlp3(efx,smptsavb&)
ENDIF
@markhlp6(xx)
REPEAT
~GRAF_MKSTATE(v,v2,k,v4)
UNTIL k=0
ENDIF
ENDIF
ENDIF
ENDIF
IF k=1 THEN
@markhlp
IF smark=6 OR smark=5 OR smark=4 THEN
IF sms=1 THEN
c1=stax
t$="A"
ENDIF
IF sms=2 THEN
c1=stbx
t$="B"
ENDIF
IF sms=3 THEN
c1=stcx
t$="C"
ENDIF
IF sms=4 THEN
c1=stdx
t$="D"
ENDIF
IF sms=5 THEN
c1=stex
t$="E"
ENDIF
IF sme=1 THEN
c2=eax
t2$="A"
ENDIF
IF sme=2 THEN
c2=ebx
t2$="B"
ENDIF
IF sme=3 THEN
c2=ecx
t2$="C"
ENDIF
IF sme=4 THEN
c2=edx
t2$="D"
ENDIF
IF sme=5 THEN
c2=eex
t2$="E"
ENDIF
IF (ce-cs)>0 AND c1>=cs AND c2<=ce AND c2>c1 THEN
vc1=INT(xm/(ce-cs)*(c1-cs))
vc2=INT(xm/(ce-cs)*(c2-cs))
IF x>=vc1+xd AND x<=vc2+xd THEN
@markhandl4
IF sms=1 THEN
stax=c1
ENDIF
IF sms=2 THEN
stbx=c1
ENDIF
IF sms=3 THEN
stcx=c1
ENDIF
IF sms=4 THEN
stdx=c1
ENDIF
IF sms=5 THEN
stex=c1
ENDIF
IF sme=1 THEN
eax=c2
ENDIF
IF sme=2 THEN
ebx=c2
ENDIF
IF sme=3 THEN
ecx=c2
ENDIF
IF sme=4 THEN
edx=c2
ENDIF
IF sme=5 THEN
eex=c2
ENDIF
IF smark=5 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpkhlp
ENDIF
IF smark=6 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpihlp
ENDIF
ENDIF
ENDIF
ENDIF
IF smark=1 OR smark=2 OR smark=3 THEN
@markprod2
xmp=0
c=0
ENDIF
ENDIF
RETURN
'
> PROCEDURE blkstest
IF master=0 AND shlp=1 THEN
blksa=meml
blkse=smrk
ELSE
@markhlp
c1=stfx
c2=efx
blkse=c2+meml
blkse=INT(blkse/4)*4
blksa=c1+meml
blksa=INT(blksa/4)*4
ENDIF
RETURN
'
> PROCEDURE markhlp7
IF sms=1 THEN
lmin=stax
ENDIF
IF sms=2 THEN
lmin=stbx
ENDIF
IF sms=3 THEN
lmin=stcx
ENDIF
IF sms=4 THEN
lmin=stdx
ENDIF
IF sms=5 THEN
lmin=stex
ENDIF
IF sme=1 THEN
lma=eax
ENDIF
IF sme=2 THEN
lma=ebx
ENDIF
IF sme=3 THEN
lma=ecx
ENDIF
IF sme=4 THEN
lma=edx
ENDIF
IF sme=5 THEN
lma=eex
ENDIF
IF blks=0 THEN
lmin=INT(lmin/4)*4
lma=INT(lma/4)*4
ELSE
lmin=lmin-(blksa-meml)
lmin=INT(lmin/4)*4
lma=lma-(blksa-meml)
lma=INT(lma/4)*4
ENDIF
RETURN
'
> PROCEDURE smpsave
@markhlp
vornr=nr
@rsc_back(nr)
nr=savebloc&
@rsc_draw(nr,5)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
PAUSE 2
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=savehelp& THEN
@helptxt("SAVE")
ENDIF
UNTIL obj=savexit& OR obj=savall& OR obj=savblock&
IF obj=savall& THEN
blks=0
ENDIF
IF obj=savblock& THEN
blks=1
ENDIF
@setbutton(obj,0)
@restaura2
IF obj<>savexit& THEN
@blkstest
@makehz
IF sms>5 THEN
sms=msms
ENDIF
IF sme>5 THEN
sme=msme
ENDIF
@maschinit
IF big=0 THEN
IF blks=0 THEN
anfloadx=MALLOC(mlen+&H200)
ELSE
anfloadx=MALLOC((blkse-blksa)+&H200)
ENDIF
ELSE
IF blks=0 THEN
anfloadx=meml
ELSE
anfloadx=blksa
ENDIF
ENDIF
IF anfloadx<>0 AND anfloadx<>-1 THEN
IF big=0 THEN
datx=((INT(anfloadx/4))*4)+4
ELSE
datx=anfloadx
ENDIF
danf=mdat%
@busy_mouse
IF virtual=TRUE THEN
g=RINSTR(virtpath$,"\")
IF g>0 THEN
op$=LEFT$(virtpath$,g)
ENDIF
IF virtwfile=TRUE THEN
mp$=""
ENDIF
ENDIF
@fileselect(op$+"*."+ext$,mp$,"SAVE:")
rp$=path$
IF path$<>"" AND RIGHT$(path$,1)<>"\" AND pret<>0 AND pbutt=1 THEN
IF blks=0 THEN
a=meml
l=mlen
ELSE
a=blksa
l=blkse-blksa
ENDIF
b=datx
IF big=0 THEN
@maschruf
ENDIF
REPEAT
g=INSTR(path$,"\")
IF g>0 THEN
path$=RIGHT$(path$,(LEN(path$)-g))
ENDIF
g2=INSTR(path$,":")
IF g2>0 THEN
path$=RIGHT$(path$,(LEN(path$)-g2))
ENDIF
UNTIL g=0 AND g2=0
vext$=ext$
IF vext$="*" THEN
vext$="SMP"
ENDIF
IF INSTR(path$,".")=0 THEN
path$=path$+"."+vext$
ENDIF
IF INSTR(rp$,".")=0 THEN
rp$=rp$+"."+vext$
ENDIF
IF RIGHT$(rp$,4)=".SMP" THEN
fileart=1
head=20
ENDIF
IF RIGHT$(rp$,4)=".AVR" THEN
fileart=2
head=128
ENDIF
IF RIGHT$(rp$,4)=".WAV" THEN
fileart=3
head=44
ENDIF
IF RIGHT$(rp$,3)=".AU" OR RIGHT$(rp$,4)=".SND" THEN
fileart=4
head=28
ENDIF
'
hz=INT(hz/100)*100
IF fileart=1 THEN                          ! SMP-File
mp$=path$
DPOKE danf,&HF07E                        ! SDS-Startkennung
POKE danf+2,1                            ! MIDI-Kanalnummer
POKE danf+3,1
DPOKE danf+4,&H100                       ! Sample-Nr.
POKE danf+6,16                           ! Bits
per=10^9/hz
x=INT(per/65536)
y=per-x*65536
POKE danf+7,x                            ! Periodendauer eines Samples
DPOKE danf+8,y                           ! Periodendauer eines Samples
IF blks=0 THEN
mlh=INT(mlen/2)
ELSE
mlh=INT((blkse-blksa)/2)
ENDIF
x2=INT(mlh/256)
y2=mlh-x2*256
DPOKE danf+10,x2                          ! Sample Len in Worten
POKE danf+12,y2                           ! Sample Len in Worten
@markhlp
@markhlp7
x3=INT(lmin/65536)
y3=lmin-x3*65536
POKE danf+13,x3                           ! Sustain Loop-Start
DPOKE danf+14,y3                          ! Sustain Loop-Start
x4=INT(lma/256)
y4=lma-x4*256
DPOKE danf+16,x4                          ! Sustain Loop-End
POKE danf+18,y4                           ! Sustain Loop-End
IF sret=0 THEN
la=0
ELSE
la=1
ENDIF
IF sblock=0 THEN
la=&H7F
ENDIF
POKE danf+19,la                           ! Loop-Art
'      POKE danf+20,&HF7                  ! SDS-Endkennung
ENDIF
'
IF fileart=2 THEN                          ! AVR-File
mp$=path$
LPOKE danf,&H32424954                    ! AVR-Kennung
i=INSTR(rp$,".")
a$=LEFT$(rp$,i-1)
FOR i=1 TO LEN(a$)
POKE danf+3+i,ASC(MID$(a$,i,1))        ! Name des Samples
NEXT i
DPOKE danf+12,&HFFFF                     ! mode
DPOKE danf+14,16                         ! resolution
DPOKE danf+16,&HFFFF                     ! sign
la=0
IF sblock=1 THEN
la=&HFFFF
ENDIF
DPOKE danf+18,la                         ! loop
DPOKE danf+20,&HFFFF                     ! note
LPOKE danf+22,hz                         ! speed
IF blks=0 THEN
mlh=INT(mlen/2)
ELSE
mlh=INT((blkse-blksa)/2)
ENDIF
LPOKE danf+26,mlh                        ! len
@markhlp
IF sblock=1 THEN
@markhlp7
LPOKE danf+30,INT(lmin/2)              ! beg_loop
LPOKE danf+34,INT(lma/2)               ! end_loop
ELSE
LPOKE danf+30,0
LPOKE danf+34,mlh
ENDIF
FOR i=38 TO 127
POKE danf+i,0
NEXT i
ENDIF
'
IF fileart=3 THEN                          ! WAV-File
mp$=path$
LPOKE danf,&H52494646                    ! "RIFF"
IF blks=0 THEN
len=mlen
ELSE
len=blkse-blksa
ENDIF
len2=len+head-4
a=INT(len2/&H1000000)
len2=len2-a*&H1000000
a2=INT(len2/65536)
len2=len2-a*65536
a3=INT(len2/256)
a4=len2-a*256
POKE danf+4,a4
POKE danf+5,a3
POKE danf+6,a2
POKE danf+7,a1
LPOKE danf+8,&H57415645                  ! "WAVE"
LPOKE danf+12,&H666D7420                 ! "fmt "
POKE danf+16,16                          ! LÑnge des fmt-Chunks
POKE danf+17,0
POKE danf+18,0
POKE danf+19,0
POKE danf+20,1                           ! format PCM
POKE danf+21,0
POKE danf+22,2                           ! channels
POKE danf+23,0
len2=hz
a=INT(len2/&H1000000)
len2=len2-a*&H1000000
a2=INT(len2/65536)
len2=len2-a*65536
a3=INT(len2/256)
a4=len2-a*256
POKE danf+24,a4                           ! frequency
POKE danf+25,a3
POKE danf+26,a2
POKE danf+27,a1
len2=hz*4                                 ! average
a=INT(len2/&H1000000)
len2=len2-a*&H1000000
a2=INT(len2/65536)
len2=len2-a*65536
a3=INT(len2/256)
a4=len2-a*256
POKE danf+28,a4                           ! average
POKE danf+29,a3
POKE danf+30,a2
POKE danf+31,a1
POKE danf+32,4                            ! align
POKE danf+33,0
POKE danf+34,16                           ! bps
POKE danf+35,0
LPOKE danf+36,&H64617461                  ! "data"
len2=len
a=INT(len2/&H1000000)
len2=len2-a*&H1000000
a2=INT(len2/65536)
len2=len2-a*65536
a3=INT(len2/256)
a4=len2-a*256
POKE danf+40,a4                           ! LÑnge des data-chunks
POKE danf+41,a3
POKE danf+42,a2
POKE danf+43,a1
ENDIF
'
IF fileart=4 THEN                          ! AU-File
mp$=path$
LPOKE danf,&H2E736E64                    ! AVR-Kennung
LPOKE danf+4,28                          ! datalocation
LPOKE danf+12,3                          ! dataformat
LPOKE danf+20,2                          ! channelcount
LPOKE danf+24,0                          ! info
LPOKE danf+16,hz                         ! samplingrate
IF blks=0 THEN
mlh=mlen
ELSE
mlh=blkse-blksa
ENDIF
LPOKE danf+8,mlh                         ! datasize
@markhlp
ENDIF
'
a=ASC(LEFT$(rp$,1))-64
oeffne=FALSE
IF DFREE(a)>(head+(blkse-blksa)) THEN
oeffne=TRUE
ELSE
IF virtual=FALSE THEN
@nomem
ENDIF
ENDIF
IF oeffne=TRUE THEN
IF blks=0 THEN
len=mlen
ELSE
len=blkse-blksa
ENDIF
IF fileart=3 THEN
@maschinit28
@maschruf28(datx,len)
ENDIF
IF virtual=FALSE THEN
IF len>0 THEN
OPEN "O",#1,rp$
BPUT #1,danf,head
BPUT #1,datx,len
CLOSE #1
ELSE
ALERT 1,"Kein Block markiert !",1,"OK",g
ENDIF
ELSE
IF blks=0 THEN
vln=virtln
stt=0
ELSE
vln=c2-c1
stt=c1
ENDIF
IF vln>0 THEN
a=ASC(LEFT$(rp$,1))-64
IF DFREE(a)>=vln THEN
IF virtwfile=TRUE THEN
a=RINSTR(virtpath$,"\")
IF a>0 THEN
vp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
ELSE
vp$=virtpath$
ENDIF
IF EXIST(vp$)=FALSE THEN
vp$=virtpath$
ENDIF
OPEN "I",#1,vp$
OPEN "O",#2,rp$
vln=INT(vln/4)*4
seekz=INT(stt/4)*4
bytes=INT(mlen/4)*4
IF seekz>0 THEN
SEEK #1,seekz
ENDIF
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #1
CLOSE #2
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
ELSE
ALERT 1,"Kein Block markiert !",1,"OK",g
ENDIF
ENDIF
IF fileart=3 THEN
@maschinit28
@maschruf28(datx,len)
ENDIF
ENDIF
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)
@textfeld(smpfile&,path$,1)
ENDIF
ENDIF
IF big=0 AND anfloadx<>0 THEN
~MFREE(anfloadx)
ENDIF
@restaura
ENDIF
@setbutton(smpsave&,0)
RETURN
'
> PROCEDURE blklfrag
@markhlp
vornr=nr
@rsc_back(nr)
nr=loadbloc&
@rsc_draw(nr,5)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
PAUSE 2
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=ladhelp& THEN
@helptxt("LOAD")
ENDIF
UNTIL obj=ladexit& OR obj=ladall& OR obj=ladblock&
IF obj=ladall& THEN
blks=0
ENDIF
IF obj=ladblock& THEN
blks=1
ENDIF
@setbutton(obj,0)
@restaura2
RETURN
'
> PROCEDURE restaura
IF nr=smpedit& THEN
@rsc_back(nr)
IF nr=smp16& THEN
i=7
ELSE
i=5
ENDIF
@rsc_draw(nr,i)
@curve(cs,ce)
@markprod3
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF sloop=0 THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE restaura2
@rsc_back(nr)
nr=vornr
IF nr=smp16& THEN
i=7
ELSE
i=5
ENDIF
@rsc_draw(nr,i)
IF nr=smpedit& THEN
@curve(cs,ce)
@markprod3
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF sloop=0 THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE smpload
mrkobj=0
pathmrk$=path$
lnmrk=ln
memlmrk=meml
secmrk=sec
@ldhlp
IF anfloadx<>0 AND anfloadx<>-1 AND (ln-abz)<=vmem AND lready=1 AND mrkobj<>ladexit& THEN
IF path$<>"" AND RIGHT$(path$,1)<>"\" AND pathda=TRUE THEN
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
sec=INT(ln/(hz*4))+1
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
@restaura
IF hz=32000 THEN
a$=@rsc_text$(popups&,2)
@textfeld(rate&,a$,1)
@adlow
ENDIF
IF hz=44100 THEN
a$=@rsc_text$(popups&,3)
@textfeld(rate&,a$,1)
@admid
ENDIF
IF hz=48000 THEN
a$=@rsc_text$(popups&,4)
@textfeld(rate&,a$,1)
@adhigh
ENDIF
ELSE
@restaura
ENDIF
ELSE
IF mrkobj<>ladexit& THEN
@restaura
ENDIF
ENDIF
@setbutton(smpload&,0)
RETURN
'
> PROCEDURE marksearch
LOCAL ex
ex=FALSE
IF (stax=0 AND eax=0) OR (stax=-1 AND eax=-1) THEN
markfre=1
ex=TRUE
ENDIF
IF ((stbx=0 AND ebx=0) OR (stbx=-1 AND ebx=-1)) AND ex=FALSE THEN
markfre=2
ex=TRUE
ENDIF
IF ((stcx=0 AND ecx=0) OR (stcx=-1 AND ecx=-1)) AND ex=FALSE THEN
markfre=3
ex=TRUE
ENDIF
IF ((stdx=0 AND edx=0) OR (stdx=-1 AND edx=-1)) AND ex=FALSE THEN
markfre=4
ex=TRUE
ENDIF
IF ((stex=0 AND eex=0) OR (stex=-1 AND eex=-1)) AND ex=FALSE THEN
markfre=5
ex=TRUE
ENDIF
IF ex=FALSE THEN
markfre=1
ENDIF
RETURN
'
> PROCEDURE blkltest
@markhlp
bpos=0
IF master=0 THEN
bstart=0
ENDIF
IF master=1 THEN
bstart=stax
ENDIF
IF master=2 THEN
bstart=stbx
ENDIF
IF master=3 THEN
bstart=stcx
ENDIF
IF master=4 THEN
bstart=stdx
ENDIF
IF master=5 THEN
bstart=stex
ENDIF
IF master=6 THEN
bstart=eax
ENDIF
IF master=7 THEN
bstart=ebx
ENDIF
IF master=8 THEN
bstart=ecx
ENDIF
IF master=9 THEN
bstart=edx
ENDIF
IF master=10 THEN
bstart=eex
ENDIF
dist=ce-cs
IF blks=1 THEN
bpos=bstart
ENDIF
conc=bstart
bstart=bstart+meml
bstart=INT(bstart/4)*4
RETURN
'
> PROCEDURE fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
LPOKE ADDRIN,fs_iinpath%
LPOKE ADDRIN+4,fs_iinsel%
LPOKE ADDRIN+8,fs_iinlabel%
@ain(91,0,2,3,0)
pret=GINTOUT(0)
pbutt=GINTOUT(1)
RETURN
'
> PROCEDURE ain(g0%,g2%,g4%,g6%,g8%)
DPOKE GCONTRL,g0%
DPOKE GCONTRL+2,g2%
DPOKE GCONTRL+4,g4%
DPOKE GCONTRL+6,g6%
DPOKE GCONTRL+8,g8%
GEMSYS
RETURN
'
> PROCEDURE fileselect(a$,b$,c$)
'  @rsc_save_dialog(nr)
a$=a$+CHR$(0)+SPACE$(100)
fs_iinpath%=VARPTR(a$)
b$=b$+CHR$(0)+SPACE$(100)
fs_iinsel%=VARPTR(b$)
c$=c$+CHR$(0)+SPACE$(100)
fs_iinlabel%=VARPTR(c$)
@fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
a=INSTR(a$,CHR$(0))
a$=LEFT$(a$,a-1)
a=INSTR(b$,CHR$(0))
b$=LEFT$(b$,a-1)
a=RINSTR(a$,"\")
IF LEN(a$)=0 THEN
ordner$=""
ELSE
ordner$=LEFT$(a$,a)
ENDIF
IF LEN(b$)=0 THEN
path$=""
ELSE
path$=LEFT$(a$,a)+b$
ENDIF
'  @rsc_restore_dialog(nr)
RETURN
'
> PROCEDURE markset
IF markfre=1 THEN
sms=1
sme=1
eax=ah
t$="A"
stax=ah2
IF nr=smpedit& THEN
@setbutton(smpsta&,1)
@setbutton(smpea&,1)
ENDIF
ENDIF
IF markfre=2 THEN
sms=2
sme=2
ebx=ah
t$="B"
stbx=ah2
IF nr=smpedit& THEN
@setbutton(smpstb&,1)
@setbutton(smpeb&,1)
ENDIF
ENDIF
IF markfre=3 THEN
sms=3
sme=3
ecx=ah
t$="C"
stcx=ah2
IF nr=smpedit& THEN
@setbutton(smpstc&,1)
@setbutton(smpec&,1)
ENDIF
ENDIF
IF markfre=4 THEN
sms=4
sme=4
edx=ah
t$="D"
stdx=ah2
IF nr=smpedit& THEN
@setbutton(smpstd&,1)
@setbutton(smped&,1)
ENDIF
ENDIF
IF markfre=5 THEN
sms=5
sme=5
eex=ah
t$="E"
stex=ah2
IF nr=smpedit& THEN
@setbutton(smpste&,1)
@setbutton(smpee&,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE ldhlp
loded=FALSE
IF virtual=FALSE AND rett=TRUE THEN
IF EXIST(virt$)=TRUE AND EXIST(virt2$)=TRUE THEN
KILL virt$
KILL virt2$
ENDIF
rett=FALSE
ENDIF
IF (virtld=TRUE AND (blockld=TRUE OR virtual=TRUE)) OR (virtld=FALSE AND blockld=FALSE AND virtual=FALSE) THEN
IF virtld=FALSE THEN
IF nr=smpedit& THEN
@blklfrag
ELSE
obj=ladall&
blks=0
ENDIF
mrkobj=obj
ENDIF
IF obj<>ladexit& THEN
retime=0
shlp=0
lready=0
cs=0
ce=vmem
head=20   ! HeaderlÑnge fÅr SMP-Files
@maschinit
x=100
y=100
w=400
h=400
IF virtld=FALSE THEN
@fileselect(op$+"*."+ext$,"","LOAD:")
ENDIF
@busy_mouse
pathda=EXIST(path$)
IF pathda=TRUE AND pbutt=1 AND pret<>0 THEN
oldp$=path$
ENDIF
IF path$<>"" AND RIGHT$(path$,1)<>"\" AND pathda=TRUE AND pret<>0 AND pbutt=1 THEN
datx=mdat%
OPEN "I",#1,path$
IF virtld=FALSE THEN
ln=LOF(#1)
ENDIF
BGET #1,datx,4
CLOSE #1
@blkltest
IF (virtld=FALSE AND (ln-head)<=mlen) OR blockld=TRUE THEN
IF blks=0 THEN
anfloadx=meml
mt=memh-meml
@maschinit9
@maschruf9(meml,memh)
ELSE
anfloadx=bstart
mt=memh-bstart
ENDIF
ELSE
IF blks=0 OR virtual=TRUE THEN
anfloadx=meml
mt=memh-meml
ELSE
anfloadx=bstart
mt=memh-bstart
ENDIF
ENDIF
head=0
fileart=0
abz=DPEEK(datx)
abz2=LPEEK(datx)
IF abz=&HF07E THEN
head=20   ! HeaderlÑnge fÅr SMP-Files
fileart=1
ENDIF
IF abz2=&H32424954 THEN
head=128   ! HeaderlÑnge fÅr AVR-Files
fileart=2
ENDIF
IF abz2=&H52494646 THEN
head=44   ! HeaderlÑnge fÅr WAV-Files
fileart=3
ENDIF
IF abz2=&H2E736E64 THEN
head=28   ! HeaderlÑnge fÅr AU und SND-Files
fileart=4
ENDIF
abz=head
IF anfloadx<>0 AND anfloadx<>-1 AND (ln-abz)<=mt THEN
lready=1
ln2=ln
pam$=path$
IF blks=0 THEN
@markdel
ENDIF
path$=pam$
rpath$=path$
ln=ln2
datx=((INT(anfloadx/4))*4)+4
OPEN "I",#1,path$
BGET #1,datx,head
lded=1
@clsed
danf=datx
'
IF blockld=TRUE AND virtld=TRUE THEN
fileart=vfileart
head=vhead
SEEK #1,vhbldstrt+head
ln=hbldlen
ENDIF
'
IF fileart=4 THEN        ! AU-Format
@markhlp
a=datx
tst1=LPEEK(danf+12)    ! dataformat
tst2=LPEEK(danf+20)    ! channelcount
IF tst1=3 AND tst2=2 THEN
per=LPEEK(danf+16)    ! Sample-Rate
IF per=32000 THEN
hz=per
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,10)
@textfeld(rate2&,a$,1)
ENDIF
@adlow
ENDIF
IF per=44100 THEN
hz=per
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,11)
@textfeld(rate2&,a$,1)
ENDIF
@admid
ENDIF
IF per=48000 THEN
hz=per
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,12)
@textfeld(rate2&,a$,1)
ENDIF
@adhigh
ENDIF
IF per<>32000 AND per<>44100 AND per<>48000 THEN
retime=1
per=INT(per/100)*100
hz=per
p$=STR$(hz/1000)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
hzm=hz
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
@deladbutt
ENDIF
ELSE
p$="    "+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
ENDIF
sblock=0
sret=0
IF nr=smpedit& THEN
@setbutton(smppmark&,0)
ENDIF
samlen=LPEEK(danf+8)        ! datasize
okmark=0
sms=0
sme=0
dazu=LPEEK(danf+4)-28       !datalocation
IF dazu>0 THEN
BGET #1,datx,dazu
ENDIF
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
BGET #1,datx,samlen
loded=TRUE
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,path$
ENDIF
lz=1
cached=FALSE
ENDIF
'
IF fileart=3 THEN        ! WAV-Format
@markhlp
a=datx
tst1=LPEEK(danf+8)     ! "WAVE"
tst2=LPEEK(danf+12)    ! "fmt "
tst3=PEEK(danf+20)     ! format
tst4=PEEK(danf+22)     ! channels
tst5=PEEK(danf+32)     ! align
tst6=PEEK(danf+34)     ! bps
IF tst1=&H57415645 AND tst2=&H666D7420 AND tst3=1 AND tst4=2 AND tst5=4 AND tst6=16 THEN
per=PEEK(danf+24)+256*PEEK(danf+25)    ! Sample-Rate
IF per=32000 THEN
hz=per
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,10)
@textfeld(rate2&,a$,1)
ENDIF
@adlow
ENDIF
IF per=44100 THEN
hz=per
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,11)
@textfeld(rate2&,a$,1)
ENDIF
@admid
ENDIF
IF per=48000 THEN
hz=per
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,12)
@textfeld(rate2&,a$,1)
ENDIF
@adhigh
ENDIF
IF per<>32000 AND per<>44100 AND per<>48000 THEN
retime=1
per=INT(per/100)*100
hz=per
p$=STR$(hz/1000)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
hzm=hz
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
@deladbutt
ENDIF
ELSE
p$="    "+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
ENDIF
sblock=0
sret=0
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
dmagic=&H64617461
IF LPEEK(danf+36)=dmagic THEN
samlen=PEEK(danf+40)+256*PEEK(danf+41)+65536*PEEK(danf+42)+&H1000000*PEEK(danf+43)
ov=danf+36
ELSE
ov=40
REPEAT
dazu=PEEK(danf+ov)+256*PEEK(danf+ov+1)+65536*PEEK(danf+ov+2)+&H1000000*PEEK(danf+ov+3)
head=head+dazu+8
ov=4
IF ln>=head THEN
BGET #1,datx,dazu+8
IF LPEEK(danf+dazu)=dmagic THEN
samlen=PEEK(danf+dazu+4)+256*PEEK(danf+dazu+5)+65536*PEEK(danf+dazu+6)+&H1000000*PEEK(danf+dazu+7)
ENDIF
ENDIF
UNTIL LPEEK(danf+dazu)=dmagic OR ln<head
ov=danf+dazu
ENDIF
okmark=0
sms=0
sme=0
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
IF LPEEK(ov)=dmagic THEN
BGET #1,datx,samlen
@maschinit28
@maschruf28(datx,samlen)
ENDIF
CLOSE #1
loded=TRUE
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,path$
ENDIF
lz=1
cached=FALSE
ENDIF
'
IF fileart=2 THEN        ! AVR-Format
@markhlp
a=datx
tst1=DPEEK(danf+12)    ! mode
tst2=DPEEK(danf+14)    ! resolution
tst3=DPEEK(danf+16)    ! sign
IF tst1=&HFFFF AND tst2=16 AND tst3=&HFFFF THEN
per=DPEEK(danf+24)    ! Sample-Rate
IF per=32000 THEN
hz=per
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,10)
@textfeld(rate2&,a$,1)
ENDIF
@adlow
ENDIF
IF per=44100 THEN
hz=per
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,11)
@textfeld(rate2&,a$,1)
ENDIF
@admid
ENDIF
IF per=48000 THEN
hz=per
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,12)
@textfeld(rate2&,a$,1)
ENDIF
@adhigh
ENDIF
IF per<>32000 AND per<>44100 AND per<>48000 THEN
retime=1
per=INT(per/100)*100
hz=per
p$=STR$(hz/1000)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
hzm=hz
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
@deladbutt
ENDIF
ELSE
p$="    "+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
ENDIF
la=DPEEK(danf+18)                           ! Loop ?
sblock=0
sret=0
IF la=&HFFFF THEN
sblock=1
ENDIF
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
samlen=LPEEK(danf+26)*2
IF sblock=1 THEN
'              samlen=SWAP(samlen)
lmin=LPEEK(danf+30)*2                          ! Sustain Loop-Start
'             lmin=SWAP(lmin)
lma=LPEEK(danf+34)*2                           ! Sustain Loop-End
'            lma=SWAP(lma)
IF lma<lmin THEN
sret=1                ! RÅckwÑrts-Loop
a=lmin
lmin=lma
lma=a
ENDIF
ah=lma+bpos
ah=INT(ah)
ah2=lmin+bpos
ah2=INT(ah2)
IF ah>vmem THEN
ah=vmem
ENDIF
IF ah2>vmem THEN
ah2=vmem
ENDIF
@marksearch
@markset
ELSE
okmark=0
sms=0
sme=0
ENDIF
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
BGET #1,datx,samlen
CLOSE #1
loded=TRUE
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,path$
ENDIF
lz=1
cached=FALSE
ENDIF
'
IF fileart=1 THEN                   ! SMP-Format
@markhlp
a=datx
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
x2=DPEEK(danf+10)                          ! Sample Len in Worten
y2=PEEK(danf+12)                           ! Sample Len in Worten
ldlen=(x2*256+y2)*2
per=INT(10^9/(x*65536+y))
perm=INT(per/100)*100
per=INT(per/1000)
IF per=32 THEN
hz=32000
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,10)
@textfeld(rate2&,a$,1)
ENDIF
@adlow
ENDIF
IF per=44 THEN
hz=44100
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,11)
@textfeld(rate2&,a$,1)
ENDIF
@admid
ENDIF
IF per=48 THEN
hz=48000
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
a$=@rsc_text$(popups&,12)
@textfeld(rate2&,a$,1)
ENDIF
@adhigh
ENDIF
IF per<>32 AND per<>44 AND per<>48 THEN
retime=1
hz=perm
p$=STR$(hz/1000)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
hzm=hz
sec=INT(mlen/(hz*4))+1
IF nr=smp16& THEN
@deladbutt
ENDIF
ELSE
p$="    "+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
ENDIF
la=PEEK(danf+19)                           ! Loop-Art
sblock=1
IF la=0 THEN
sret=0
ENDIF
IF la=1 THEN
sret=1
ENDIF
IF la=&H7F THEN
sblock=0
ENDIF
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
IF sblock=1 THEN
x3=PEEK(danf+13)                           ! Sustain Loop-Start
y3=DPEEK(danf+14)                          ! Sustain Loop-Start
lmin=x3*65536+y3
x4=DPEEK(danf+16)                          ! Sustain Loop-End
y4=PEEK(danf+18)                           ! Sustain Loop-End
lma=x4*256+y4
ah=lma+bpos
ah=INT(ah)
ah2=lmin+bpos
ah2=INT(ah2)
IF ah>vmem THEN
ah=vmem
ENDIF
IF ah2>vmem THEN
ah2=vmem
ENDIF
@marksearch
@markset
ELSE
okmark=0
sms=0
sme=0
ENDIF
samlen=ln-head
BGET #1,datx,samlen
CLOSE #1
loded=TRUE
lz=1
cached=FALSE
ENDIF
'
IF fileart=0 THEN              ! Rohdaten-Format
samlen=ln-head
BGET #1,datx+head,samlen
CLOSE #1
loded=TRUE
lz=1
cached=FALSE
a=datx
okmark=0
sms=0
sme=0
hzm=hz
ENDIF
a=datx
IF blks=0 THEN
b=meml
l=memh-meml
shlp=1
smrk=meml+(ln-head)
smrk=INT(smrk/4)*4
ELSE
shlp=0
b=bstart
l=memh-bstart
ENDIF
IF big=0 THEN
@maschruf
ENDIF
REPEAT
g=INSTR(path$,"\")
IF g>0 THEN
path$=RIGHT$(path$,(LEN(path$)-g))
ENDIF
g2=INSTR(path$,":")
IF g2>0 THEN
path$=RIGHT$(path$,(LEN(path$)-g2))
ENDIF
UNTIL g=0 AND g2=0
mp$=path$
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
IF vmem<=mlen AND (virtual=TRUE OR blockld=TRUE) THEN
virtual=FALSE
blockld=FALSE
virtld=FALSE
virtcurve=FALSE
maxcwert=0
ce=mlen
cs=0
vmem=INT(mlen-1)
ENDIF
IF virtual=FALSE AND blockld=FALSE THEN
profpath$=mp$
profln=ln
profhz=hz
ENDIF
ELSE
vhead=head
vfileart=fileart
@virtual
IF blockld=TRUE THEN
IF blks=0 THEN
mbs=0
ENDIF
ln=mt
obj=mrkobj
virtld=TRUE
@ldhlp
virtld=FALSE
lnmrk=ln
pathmrk$=path$
memlmrk=meml
secmrk=sec
lz=1
ENDIF
IF virtual=TRUE THEN
mbs=0
IF nr=smpedit& THEN
@setbutton(hard&,1)
ENDIF
vmem=ln-head
vmeml=0
vmemh=mt
hrd=1
@hardproof
ln=mt
obj=mrkobj
blks=0
virtld=TRUE
@ldhlp
virtld=FALSE
@markdel
@clsed
ln=vmem
sec=INT(ln/(hz*4))+1
vce=0
vcs=0
lz=1
ENDIF
IF blockld=FALSE AND virtual=FALSE THEN
ln=lnmrk
path$=pathmrk$
meml=memlmrk
sec=secmrk
maxcwert=0
ENDIF
IF nr=smpedit& THEN
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
ENDIF
ENDIF
ENDIF
ENDIF
ELSE
ALERT 1,"Sample in virt. Bearbeitung !|Sample mit Trash lîschen.",1,"OK",g
ENDIF
obj=0
blockld=FALSE
IF loded=TRUE AND virtual=FALSE THEN
INC mbs
IF blks=1 THEN
mblocks(mbs)=bstart-meml
mblocke(mbs)=bstart+samlen-meml
ELSE
mbs=1
mblocks(mbs)=0
mblocke(mbs)=samlen
ENDIF
mblockp$(mbs)=oldp$
IF mbs>lmax3 THEN
mbs=1
ENDIF
vmbs=mbs
ENDIF
RETURN
'
> PROCEDURE ldhead
datx=mdat%
OPEN "I",#1,pat$
f=LOF(#1)
BGET #1,datx,4
abz=DPEEK(datx)
abz2=LPEEK(datx)
IF abz=&HF07E THEN
head=20   ! HeaderlÑnge fÅr SMP-Files
fileart=1
ENDIF
IF abz2=&H32424954 THEN
head=128   ! HeaderlÑnge fÅr AVR-Files
fileart=2
ENDIF
IF abz2=&H52494646 THEN
head=44   ! HeaderlÑnge fÅr WAV-Files
fileart=3
ENDIF
IF abz2=&H2E736E64 THEN
head=28   ! HeaderlÑnge fÅr AU und SND-Files
fileart=4
ENDIF
BGET #1,datx+4,head-4
CLOSE #1
danf=datx
IF fileart=4 THEN        ! AU-Format
tst1=LPEEK(danf+12)    ! dataformat
tst2=LPEEK(danf+20)    ! channelcount
IF tst1=3 AND tst2=2 THEN
per=LPEEK(danf+16)    ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=3 THEN        ! WAV-Format
tst1=LPEEK(danf+8)     ! "WAVE"
tst2=LPEEK(danf+12)    ! "fmt "
tst3=PEEK(danf+20)     ! format
tst4=PEEK(danf+22)     ! channels
tst5=PEEK(danf+32)     ! align
tst6=PEEK(danf+34)     ! bps
IF tst1=&H57415645 AND tst2=&H666D7420 AND tst3=1 AND tst4=2 AND tst5=4 AND tst6=16 THEN
per=PEEK(danf+24)+256*PEEK(danf+25)    ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=2 THEN        ! AVR-Format
tst1=DPEEK(danf+12)    ! mode
tst2=DPEEK(danf+14)    ! resolution
tst3=DPEEK(danf+16)    ! sign
IF tst1=&HFFFF AND tst2=16 AND tst3=&HFFFF THEN
per=DPEEK(danf+24)    ! Sample-Rate
ENDIF
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
IF fileart=1 THEN                   ! SMP-Format
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
per=INT(10^9/(x*65536+y))
per=INT(per)
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
IF fileart=0 THEN
vhz=hz
ENDIF
RETURN
'
> PROCEDURE clsed
LOCAL hac$,mem$
mem$="     "+CHR$(0)
hac$=" "+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smptsa&,mem$,1)
@textfeld(smptsb&,mem$,1)
@textfeld(smptsc&,mem$,1)
@textfeld(smptsd&,mem$,1)
@textfeld(smptse&,mem$,1)
@textfeld(smptsava&,mem$,1)
@textfeld(smptea&,mem$,1)
@textfeld(smpteb&,mem$,1)
@textfeld(smptec&,mem$,1)
@textfeld(smpted&,mem$,1)
@textfeld(smptee&,mem$,1)
@textfeld(smptsavb&,mem$,1)
@textfeld(hacksa&,hac$,1)
@textfeld(hacksb&,hac$,1)
@textfeld(hacksc&,hac$,1)
@textfeld(hacksd&,hac$,1)
@textfeld(hackse&,hac$,1)
@textfeld(hackss&,hac$,1)
@textfeld(hackea&,hac$,1)
@textfeld(hackeb&,hac$,1)
@textfeld(hackec&,hac$,1)
@textfeld(hacked&,hac$,1)
@textfeld(hackee&,hac$,1)
@textfeld(hackes&,hac$,1)
@setbutton(smpsta&,0)
@setbutton(smpstb&,0)
@setbutton(smpstc&,0)
@setbutton(smpstd&,0)
@setbutton(smpste&,0)
@setbutton(smpsavl&,0)
@setbutton(smpea&,0)
@setbutton(smpeb&,0)
@setbutton(smpec&,0)
@setbutton(smped&,0)
@setbutton(smpee&,0)
@setbutton(smpsavr&,0)
ENDIF
sms=0
sme=0
master=0
sblock=0
IF nr=smpedit& THEN
@setbutton(smppmark&,0)
IF sloop=1 THEN
@setbutton(smploop&,1)
ELSE
@setbutton(smploop&,0)
ENDIF
a$=@rsc_text$(popups&,20)
@textfeld(mover&,a$,1)
ENDIF
smark=3
RETURN
'
> PROCEDURE curvetest(cs,ce)
zoomstop=FALSE
LOCAL xm,len,stp,bs
xm=617
len=ce-cs
stp=(INT(len/xm))
stp=(INT((stp+1)/4)*4)
bs=0
IF stp=0 THEN
stp=4
IF len>xm*4 THEN
bs=len/xm/4
ELSE
bs=xm*4/len
ENDIF
ENDIF
IF bs>7 THEN
zoomstop=TRUE
ENDIF
RETURN
'
> PROCEDURE curve(cs,ce)
LOCAL c$,s,e,l,y,len,adr,i,a,z,m,k,d,xm,ym,xdi,ydi
zoomstop=FALSE
GRAPHMODE 1
@markhlp
'
' COLORS: 0=weiss,1=schwarz,2=rot,3=grÅn,4=blau,5=cyan,6=gelb,7=magenta,8=hellgrau
'         9=dunkelgrau,10=dunkelrot,11=dunkelgrÅn,12=dunkelblau,13=dunkelcyan,14=dunkelgelb,15=dunkelmagenta
'
IF grids=1 THEN
IF maxcol<=2 THEN
DEFFILL 0,1,8
ELSE
DEFFILL 8,1,8
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX xd+1,stay1+4,xd+xm-1,stay1+ym-4
PBOX xd+1,stay1+ym2,xd+xm-1,stay1+ym2+ym-8
'
IF mbs>0 THEN
col=1
FOR i=1 TO mbs
INC col
ax=mblocks(i)
bx=mblocke(i)
IF (ce-cs)>0 AND (bx-ax)>0 THEN
IF ax<cs AND bx>cs THEN
ax=cs
ENDIF
IF bx>ce AND ax>=cs AND ax<=ce THEN
bx=ce
ENDIF
IF ax>=cs AND ax<=ce AND bx>=cs AND bx<=ce AND (ce-cs)>0 AND (bx-ax)>0 THEN
ax=ax-cs
ax=ax/(ce-cs)*xm
bx=bx-cs
bx=bx/(ce-cs)*xm
IF maxcol<=2 THEN
DEFFILL 1,3,col
IF col=13 THEN
col=1
ENDIF
ELSE
IF col=8 THEN
col=10
ENDIF
IF col=16 THEN
col=2
ENDIF
DEFFILL col,1,8
ENDIF
PBOX xd+ax+1,stay1+4,xd+bx-1,stay1+ym-4
PBOX xd+ax+1,stay1+ym2,xd+bx-1,stay1+ym2+ym-8
ENDIF
ENDIF
NEXT i
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
'
virtcurve=FALSE
IF virtual=TRUE AND maxcwert>0 THEN
IF ce-cs>mlen THEN
vce=0
vcs=0
virtcurve=TRUE
cached=TRUE
IF cs>0 THEN
wa=vmem/cs
wa=(maxcwert/wa)
ELSE
wa=0
ENDIF
IF ce>0 THEN
wb=vmem/ce
wb=(maxcwert/wb)
ELSE
wb=0
ENDIF
wa=INT(wa)
wb=INT(wb)
stp=(wb-wa)/xm
'      bs=1
'     IF stp<1 THEN
'    stp=1
'   IF (wb-wa)>xm THEN
'  bs=(wb-wa)/xm
'    ELSE
'     bs=xm/(wb-wa)
'  ENDIF
'   ELSE
'    IF ((wb-wa)/stp)<xm THEN
'   bs=xm/((wb-wa)/stp)
'   ENDIF
'  ENDIF
j=0
m1=0
m2=0
m3=0
m4=0
i=wa+1
REPEAT
INC j
IF j<=xm THEN
a=LPEEK(cwerte1+INT(i)*4)
IF m1<a AND a>0 THEN
m1=a
ENDIF
IF m2>a AND a<0 THEN
m2=a
ENDIF
cache1(j)=a
a=LPEEK(cwerte2+INT(i)*4)
IF m3<a AND a>0 THEN
m3=a
ENDIF
IF m4>a AND a<0 THEN
m4=a
ENDIF
cache2(j)=a
ENDIF
i=i+stp
UNTIL i>=wb
m2=ABS(m2)
IF m1>m2 THEN
max=m1
ELSE
max=m2
ENDIF
m4=ABS(m4)
IF m3>m4 THEN
max2=m3
ELSE
max2=m4
ENDIF
IF max2>max THEN
max=max2
ENDIF
ELSE
IF cs<vcs OR ce>vce OR vce=0 THEN
IF cs<vcs THEN
IF mlen>ce-cs AND ce-mlen>=0 THEN
ldlen=mlen
ELSE
ldlen=ce-cs
ENDIF
virtcurve=FALSE
cached=FALSE
vce=ce
vcs=ce-ldlen
IF vcs=0 THEN
ldlen=mlen
vce=mlen
ENDIF
OPEN "I",#1,mrkp$
SEEK #1,vcs
ELSE
IF mlen>ce-cs AND vmem-cs>=mlen THEN
ldlen=mlen
ELSE
ldlen=ce-cs
ENDIF
IF cs+ldlen>vmem THEN
ldlen=vmem-cs
ENDIF
virtcurve=FALSE
cached=FALSE
vcs=cs
vce=cs+ldlen
OPEN "I",#1,mrkp$
SEEK #1,cs
ENDIF
BGET #1,meml,ldlen
CLOSE #1
ENDIF
ENDIF
ENDIF
'
IF mrkhandle=mrkhandle2 THEN
v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
IF v<>0 AND kenn=mrkhandle2 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
@maschinit5
xdi=xd+1   ! Anfang X
ydi=yd+65  ! Anfang Y
xm=615     ! Breite der Horizontalen
ym=38      ! Hîhe der Y-Achsen
sline=96   ! Abstand zur zweiten Horizontal-Linie
len=ce-cs
LINE xdi,ydi,xdi+xm,ydi
LINE xdi,ydi+sline,xdi+xm,ydi+sline
stp=(INT(len/xm))
stp=(INT((stp+1)/4)*4)
COLOR 0
l=xdi-2
y=ydi
IF virtcurve=FALSE THEN
bs=1
IF stp=0 THEN
stp=4
IF len>xm*4 THEN
bs=len/xm/4
ELSE
bs=xm*4/len
ENDIF
ELSE
IF (len/stp)<xm THEN
bs=xm/(len/stp)
ENDIF
ENDIF
adr=meml
ELSE
adr=0
ENDIF
COLOR 1
IF cached=FALSE THEN
ci=0
m1=0
m2=0
FOR i=adr+cs TO adr+ce-stp STEP stp
@maschruf5
IF a>32767 THEN
a=a-65536
ENDIF
IF m1<a AND a>0 THEN
m1=a
ENDIF
IF m2>a AND a<0 THEN
m2=a
ENDIF
INC ci
IF l<=(xm+xdi) THEN
cache1(ci)=a
ENDIF
l=l+bs
NEXT i
m2=ABS(m2)
IF m1>m2 THEN
max=m1
ELSE
max=m2
ENDIF
ci=0
m1=0
m2=0
l=xdi-2
FOR i=adr+cs+2 TO adr+ce-stp STEP stp
@maschruf5
IF a>32767 THEN
a=a-65536
ENDIF
IF m1<a AND a>0 THEN
m1=a
ENDIF
IF m2>a AND a<0 THEN
m2=a
ENDIF
INC ci
IF l<=(xm+xdi) THEN
cache2(ci)=a
ENDIF
l=l+bs
NEXT i
m2=ABS(m2)
IF m1>m2 THEN
max2=m1
ELSE
max2=m2
ENDIF
IF max2>max THEN
max=max2
ENDIF
ci=0
l=xdi-2
FOR i=adr+cs TO adr+ce-stp STEP stp
INC ci
IF l<=(xm+xdi) THEN
a=cache1(ci)
IF max>0 THEN
IF stp>4 THEN
a=INT(a/max*ym)
ELSE
a=INT(a/32767*ym)
ENDIF
ELSE
a=0
ENDIF
a=a+ydi
IF (ce-cs)<=xm THEN
FOR u=l TO l+bs
LINE u,y,u,a
NEXT u
ELSE
LINE l,y,l+bs,a
y=a
ENDIF
ENDIF
l=l+bs
NEXT i
y=ydi+sline
ci=0
l=xdi-2
ydi=ydi+sline
FOR i=adr+cs+2 TO adr+ce-stp STEP stp
INC ci
IF l<=(xm+xdi) THEN
a=cache2(ci)
IF max>0 THEN
IF stp>4 THEN
a=INT(a/max*ym)
ELSE
a=INT(a/32767*ym)
ENDIF
ELSE
a=0
ENDIF
a=a+ydi
IF (ce-cs)<=xm THEN
FOR u=l TO l+bs
LINE u,y,u,a
NEXT u
ELSE
LINE l,y,l+bs,a
y=a
ENDIF
ENDIF
l=l+bs
NEXT i
cached=TRUE
ELSE
l=xdi-2
ci=0
FOR i=adr+cs TO adr+ce-stp STEP stp
INC ci
IF l<=(xm+xdi) THEN
a=cache1(ci)
IF max>0 THEN
IF stp>4 THEN
a=INT(a/max*ym)
ELSE
a=INT(a/32767*ym)
ENDIF
ELSE
a=0
ENDIF
a=a+ydi
IF (ce-cs)<=xm THEN
FOR u=l TO l+bs
LINE u,y,u,a
NEXT u
ELSE
LINE l,y,l+bs,a
y=a
ENDIF
ENDIF
l=l+bs
NEXT i
ydi=ydi+sline
l=xdi-2
y=ydi
ci=0
FOR i=adr+cs+2 TO adr+ce-stp STEP stp
INC ci
IF l<=(xm+xdi) THEN
a=cache2(ci)
IF max>0 THEN
IF stp>4 THEN
a=INT(a/max*ym)
ELSE
a=INT(a/32767*ym)
ENDIF
ELSE
a=0
ENDIF
a=a+ydi
IF (ce-cs)<=xm THEN
FOR u=l TO l+bs
LINE u,y,u,a
NEXT u
ELSE
LINE l,y,l+bs,a
y=a
ENDIF
ENDIF
l=l+bs
NEXT i
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
RETURN
'
> PROCEDURE resample
makecurve=0
@rsc_back(nr)
vornr=nr
nr=resample&
@makehz
@rsc_draw(nr,5)
@markhlp
resorig=hz/1000
db$=STR$(resorig)+CHR$(0)
@editfeld(restxt&,db$)
resoth=44.1
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
REPEAT
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,v3,v4)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
IF obj=resl1& OR obj=resl2& OR obj=resl3& OR obj=resr1& OR obj=resr2& OR obj=resr3& THEN
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=resl1& OR obj=resl2& OR obj=resl3& THEN
@resl
ENDIF
IF obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@resr
ENDIF
IF obj=res32& THEN
@resoth32
ENDIF
IF obj=res44& THEN
@resoth44
ENDIF
IF obj=res48& THEN
@resoth48
ENDIF
IF obj=helprsmp& THEN
@helptxt("RESAMPLING")
ENDIF
UNTIL obj=resok& OR obj=resexit&
IF obj=resok& THEN
@editread(restxt&)
noresok=FALSE
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF (a<48 OR a>57) AND a<>46 THEN
noresok=TRUE
ENDIF
IF (i=1 OR i=4) AND a=46 THEN
noresok=TRUE
ENDIF
NEXT i
ELSE
noresok=TRUE
ENDIF
ENDIF
@setbutton(obj,0)
UNTIL (obj=resok& AND noresok=FALSE) OR obj=resexit&
IF obj=resok& AND noresok=FALSE THEN
resorig=VAL(a$)
@makeresmp
ENDIF
@restaura2
@setbutton(resmp&,0)
IF makecurve=1 THEN
p$=STR$(hz/1000)+CHR$(0)
@textfeld(smprate&,p$,1)
sec=INT(ln/(hz*4))+1
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
@timecorr
ENDIF
obj=0
RETURN
'
> PROCEDURE arrnrset
'
' akkuberechnung muû geÑndert werden wegen unterschiedlichen Sampleraten !!!
'
LOCAL p$,i,akku,z,ap$
mrkch=ch
mrknote=note
@textfeld(arrnr1&,RIGHT$("  "+STR$(pbz*4+1),3)+CHR$(0),1)
@textfeld(arrnr2&,RIGHT$("  "+STR$(pbz*4+2),3)+CHR$(0),1)
@textfeld(arrnr3&,RIGHT$("  "+STR$(pbz*4+3),3)+CHR$(0),1)
@textfeld(arrnr4&,RIGHT$("  "+STR$(pbz*4+4),3)+CHR$(0),1)
IF arrherr=pbz*4+1 THEN
@setbutton(arrm1&,1)
ELSE
@setbutton(arrm1&,0)
ENDIF
IF arrherr=pbz*4+2 THEN
@setbutton(arrm2&,1)
ELSE
@setbutton(arrm2&,0)
ENDIF
IF arrherr=pbz*4+3 THEN
@setbutton(arrm3&,1)
ELSE
@setbutton(arrm3&,0)
ENDIF
IF arrherr=pbz*4+4 THEN
@setbutton(arrm4&,1)
ELSE
@setbutton(arrm4&,0)
ENDIF
akku=0
IF realtime=TRUE THEN
IF pbz>0 THEN
FOR i=1 TO pbz*4
vhz=arrsrate(i)
IF arrpath$(i)="DELAY" THEN
akku=akku+arrend(i)*vhz*4/100
ENDIF
IF arrpath$(i)="MEMORY" THEN
IF arrend(i)-arrstrt(i)>=0 THEN
akku=akku+(arrend(i)-arrstrt(i))
IF arrtri(i)=2 AND arrpath$(i)="MEMORY" THEN
akku=akku+(arrend(i)-arrstrt(i))
ENDIF
ENDIF
ENDIF
IF arrpath$(i)<>"" AND arrpath$(i)<>"MEMORY" AND arrpath$(i)<>"DELAY" THEN
IF arrend(i)-arrstrt(i)>=0 THEN
akku=akku+(arrend(i)-arrstrt(i))*flen
IF arrtri(i)=2 THEN
akku=akku+(arrend(i)-arrstrt(i))*flen
ENDIF
ENDIF
ENDIF
NEXT i
ENDIF
ENDIF
FOR z=1 TO 4
ap$=arrpath$(pbz*4+z)
IF ap$="MEMORY" OR ap$="DELAY" THEN
IF ap$="DELAY" THEN
IF z=1 THEN
@setbutton(arrloop1&,8)
@setbutton(arrmidi1&,8)
@setbutton(arrtri1&,8)
@textfeld(arrch1&,SPACE$(2)+CHR$(0),1)
@textfeld(arrnote1&,SPACE$(4)+CHR$(0),1)
@textfeld(arrsmpr1&,SPACE$(4)+CHR$(0),1)
@setbutton(arrsmpr1&,8)
ENDIF
IF z=2 THEN
@setbutton(arrloop2&,8)
@setbutton(arrmidi2&,8)
@setbutton(arrtri2&,8)
@textfeld(arrch2&,SPACE$(2)+CHR$(0),1)
@textfeld(arrnote2&,SPACE$(4)+CHR$(0),1)
@textfeld(arrsmpr2&,SPACE$(4)+CHR$(0),1)
@setbutton(arrsmpr2&,8)
ENDIF
IF z=3 THEN
@setbutton(arrloop3&,8)
@setbutton(arrmidi3&,8)
@setbutton(arrtri3&,8)
@textfeld(arrch3&,SPACE$(2)+CHR$(0),1)
@textfeld(arrnote3&,SPACE$(4)+CHR$(0),1)
@textfeld(arrsmpr3&,SPACE$(4)+CHR$(0),1)
@setbutton(arrsmpr3&,8)
ENDIF
IF z=4 THEN
@setbutton(arrloop4&,8)
@setbutton(arrmidi4&,8)
@setbutton(arrtri4&,8)
@textfeld(arrch4&,SPACE$(2)+CHR$(0),1)
@textfeld(arrnote4&,SPACE$(4)+CHR$(0),1)
@textfeld(arrsmpr4&,SPACE$(4)+CHR$(0),1)
@setbutton(arrsmpr4&,8)
ENDIF
IF realtime=FALSE THEN
hsec=arrstrt(pbz*4+z)
ELSE
vhz=arrsrate(pbz*4+z)
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
a1$=a$
hsec=arrend(pbz*4+z)
@htimeset
a3$=a$
IF realtime=FALSE THEN
a2$=a3$
ELSE
sectpos=INT(arrend(pbz*4+z)*vhz*4/100)+akku
hsec=INT(sectpos/vhz/4*100)
@htimeset
a2$=a$
akku=sectpos
ENDIF
ENDIF
IF ap$="MEMORY" THEN
sectpos=arrstrt(pbz*4+z)
IF realtime=TRUE THEN
sectpos=akku
ENDIF
vhz=arrsrate(pbz*4+z)
IF vhz=0 THEN
vhz=44100
ENDIF
hsec=INT(sectpos/vhz/4*100)
@htimeset
a1$=a$
sectpos=arrend(pbz*4+z)
IF realtime=TRUE THEN
IF arrend(pbz*4+z)-arrstrt(pbz*4+z)>=0 THEN
IF arrtri(pbz*4+z)=2 THEN
sectpos=(arrend(pbz*4+z)-arrstrt(pbz*4+z))*2+akku
ELSE
sectpos=(arrend(pbz*4+z)-arrstrt(pbz*4+z))+akku
ENDIF
ELSE
sectpos=akku
ENDIF
ENDIF
hsec=INT(sectpos/vhz/4*100)
@htimeset
a2$=a$
sectpos=arrlen(pbz*4+z)
hsec=INT(sectpos/vhz/4*100)
@htimeset
a3$=a$
IF arrend(pbz*4+z)-arrstrt(pbz*4+z)>=0 THEN
IF arrtri(pbz*4+z)=2 THEN
akku=akku+(arrend(pbz*4+z)-arrstrt(pbz*4+z))*2
ELSE
akku=akku+(arrend(pbz*4+z)-arrstrt(pbz*4+z))
ENDIF
ENDIF
ENDIF
ELSE
sectpos=arrstrt(pbz*4+z)
vhz=arrsrate(pbz*4+z)
IF vhz=0 THEN
vhz=44100
ENDIF
IF realtime=FALSE THEN
hsec=INT(sectpos*flen/vhz/4*100)
ELSE
sectpos=akku
hsec=INT(sectpos/vhz/4*100)
ENDIF
@htimeset
a1$=a$
sectpos=arrend(pbz*4+z)
IF realtime=FALSE THEN
hsec=INT(sectpos*flen/vhz/4*100)
ELSE
IF arrend(pbz*4+z)-arrstrt(pbz*4+z)>=0 THEN
IF arrtri(pbz*4+z)=2 THEN
sectpos=(sectpos-arrstrt(pbz*4+z))*2*flen+akku
ELSE
sectpos=(sectpos-arrstrt(pbz*4+z))*flen+akku
ENDIF
ELSE
sectpos=akku
ENDIF
hsec=INT(sectpos/vhz/4*100)
ENDIF
@htimeset
a2$=a$
sectpos=arrlen(pbz*4+z)
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
a3$=a$
IF arrend(pbz*4+z)-arrstrt(pbz*4+z)>=0 THEN
IF arrtri(pbz*4+z)=2 THEN
akku=akku+(arrend(pbz*4+z)-arrstrt(pbz*4+z))*2*flen
ELSE
akku=akku+(arrend(pbz*4+z)-arrstrt(pbz*4+z))*flen
ENDIF
ENDIF
ENDIF
pat$=LEFT$(arrfn$(pbz*4+z)+SPACE$(12),12)
midiwort=arrmidi(pbz*4+z)
note=(midiwort AND 255)
ch=INT(midiwort/256)+1
ch$=RIGHT$(" "+STR$(ch),2)+CHR$(0)
@midinote
p$=arrpath$(pbz*4+z)
IF pat$="            " THEN
m$=" "+CHR$(0)
ENDIF
IF p$="DELAY" THEN
m$="D"+CHR$(0)
ENDIF
IF p$="MEMORY" THEN
m$="M"+CHR$(0)
ENDIF
IF p$<>"MEMORY" AND p$<>"DELAY" AND pat$<>"            " THEN
m$="H"+CHR$(0)
ENDIF
tri=arrtri(pbz*4+z)
l=arrloop(pbz*4+z)
a4=INT(arrsrate(pbz*4+z)/100)/10
IF a4>0 THEN
a4$=LEFT$(STR$(a4)+SPACE$(4),4)+CHR$(0)
ELSE
a4$=SPACE$(4)+CHR$(0)
ENDIF
IF z=1 THEN
@textfeld(hardst1&,a1$,1)
@textfeld(harde1&,a2$,1)
@textfeld(spur1&,pat$,1)
@textfeld(hardlen1&,a3$,1)
IF p$<>"DELAY" THEN
@textfeld(arrch1&,ch$,1)
@textfeld(arrnote1&,db$,1)
@setbutton(arrmidi1&,0)
@setbutton(arrloop1&,l)
@setbutton(arrtri1&,0)
@setbutton(arrsmpr1&,0)
@textfeld(arrsmpr1&,a4$,1)
@rsc_tristate2(nr,arrtri1&)
ENDIF
@textfeld(arrmem1&,m$,1)
ENDIF
IF z=2 THEN
@textfeld(hardst2&,a1$,1)
@textfeld(harde2&,a2$,1)
@textfeld(spur2&,pat$,1)
@textfeld(hardlen2&,a3$,1)
IF p$<>"DELAY" THEN
@textfeld(arrch2&,ch$,1)
@textfeld(arrnote2&,db$,1)
@setbutton(arrmidi2&,0)
@setbutton(arrloop2&,l)
@setbutton(arrtri2&,0)
@setbutton(arrsmpr2&,0)
@textfeld(arrsmpr2&,a4$,1)
@rsc_tristate2(nr,arrtri2&)
ENDIF
@textfeld(arrmem2&,m$,1)
ENDIF
IF z=3 THEN
@textfeld(hardst3&,a1$,1)
@textfeld(harde3&,a2$,1)
@textfeld(spur3&,pat$,1)
@textfeld(hardlen3&,a3$,1)
IF p$<>"DELAY" THEN
@textfeld(arrch3&,ch$,1)
@textfeld(arrnote3&,db$,1)
@setbutton(arrmidi3&,0)
@setbutton(arrloop3&,l)
@setbutton(arrtri3&,0)
@setbutton(arrsmpr3&,0)
@textfeld(arrsmpr3&,a4$,1)
@rsc_tristate2(nr,arrtri3&)
ENDIF
@textfeld(arrmem3&,m$,1)
ENDIF
IF z=4 THEN
@textfeld(hardst4&,a1$,1)
@textfeld(harde4&,a2$,1)
@textfeld(spur4&,pat$,1)
@textfeld(hardlen4&,a3$,1)
IF p$<>"DELAY" THEN
@textfeld(arrch4&,ch$,1)
@textfeld(arrnote4&,db$,1)
@setbutton(arrmidi4&,0)
@setbutton(arrloop4&,l)
@setbutton(arrtri4&,0)
@setbutton(arrsmpr4&,0)
@textfeld(arrsmpr4&,a4$,1)
@rsc_tristate2(nr,arrtri4&)
ENDIF
@textfeld(arrmem4&,m$,1)
ENDIF
NEXT z
ch=mrkch
note=mrknote
RETURN
'
> PROCEDURE vslideinit
pbmax=143           ! Hîhe des Sliders in Pixeln
pbg=lmax2/4         ! Einteilungsanzahl
pbl=INT(pbmax/pbg)  ! Grîûe des Schiebers
pbz=0               ! Stelle des Schiebers
RETURN
'
> PROCEDURE vslidezeig
@markhlp
pba=xd+599          ! X-Koordinate Anfangspunkt
pbb=yd+136          ! Y-Koordinate Anfangspunkt
pbla=INT(pbmax/pbg*pbz)
vpbla=INT(pbmax/pbg*pbold)
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 1
DEFFILL 1,2,2
'  IF pbold<pbz AND pbz>1 THEN
'    PBOX pba,pbb+vpbla+1,pba+16,pbb+pbla
' ENDIF
' IF pbold>pbz AND pbz<(pbg-1) THEN
'   PBOX pba,pbb+pbla+17,pba+16,pbb+vpbla
' ENDIF
'
'
PBOX pba,pbb+1,pba+16,pbb+pbla
DEFFILL 0,1,8
PBOX pba,pbb+pbla+1,pba+16,pbb+pbla+pbl
DEFFILL 1,2,2
PBOX pba,pbb+pbla+pbl+1,pba+16,pbb+pbmax
~GRAF_MOUSE(257,0)                              ! Showm
RETURN
'
> PROCEDURE slideup
IF pbz>0 THEN
pbold=pbz
DEC pbz
@vslidezeig
@arrnrset
ENDIF
RETURN
'
> PROCEDURE slidedwn
IF pbz<(pbg-1) THEN
pbold=pbz
INC pbz
@vslidezeig
@arrnrset
ENDIF
RETURN
'
> PROCEDURE arranger
LOCAL vy,merkhz
merkhz=hz
merkpfad$=path$
@makehz
arrz=0
merkclip=0
spring=FALSE
drag=FALSE
arrherr=0
hardopen=FALSE
playstop=0
vornr=nr
@rsc_back(nr)
nr=arranger&
@rsc_draw(nr,5)
IF realtime=FALSE THEN
@setbutton(arreal&,0)
ELSE
@setbutton(arreal&,1)
ENDIF
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
tri=arrtri(1)
l=arrloop(1)
@setbutton(arrloop1&,l)
@rsc_tristate2(nr,arrtri1&)
tri=arrtri(2)
l=arrloop(2)
@setbutton(arrloop2&,l)
@rsc_tristate2(nr,arrtri2&)
tri=arrtri(3)
l=arrloop(3)
@setbutton(arrloop3&,l)
@rsc_tristate2(nr,arrtri3&)
tri=arrtri(4)
l=arrloop(4)
@setbutton(arrloop4&,l)
@rsc_tristate2(nr,arrtri4&)
@vslideinit
@arrnrset
@textfeld(playname&,"            "+CHR$(0),1)
REPEAT
@vslidezeig
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,k,v4)
UNTIL (obj<>0 AND obj<>-1) OR k=1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
butstate=OB_STATE(rsc_adr%(nr),obj)
UNTIL (but<>0 AND butstate<>8)
IF obj=arrclip& THEN
@dragging2
ENDIF
IF (obj=arrslide& AND k=1) THEN
@markhlp
pba=xd+599
pbb=yd+136
IF pbz<24 AND y>(pbb+pbla+pbl) THEN
@slidedwn
ENDIF
IF pbz>0 AND y<(pbb+pbla) THEN
@slideup
ENDIF
IF y>=pbb+pbla AND y<=pbb+pbla+pbl THEN
vy=y
REPEAT
~GRAF_MKSTATE(v,y,v3,v4)
IF y>=pbb AND y<=pbb+pbmax-pbl AND y<>vy THEN
pbold=pbz
pbz=INT(pbg/pbmax*(y-pbb))
pbla=INT(pbmax/pbg*pbz)
@vslidezeig
vy=y
ENDIF
UNTIL v3=0
@arrnrset
ENDIF
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
ELSE
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=smpplay2& THEN
over=0
@mforw
@setbutton(smpplay2&,0)
ENDIF
IF obj=pause& THEN
@mpause
ENDIF
IF obj=stop& THEN
@mstop
ENDIF
IF obj=forward& THEN
over=12
@mforw
@setbutton(forward&,0)
ENDIF
IF obj=rewind& THEN
over=12
@mbackw
@setbutton(rewind&,0)
ENDIF
IF obj=smprplay& THEN
over=0
@mbackw
@setbutton(smprplay&,0)
ENDIF
IF obj=smpauto3& THEN
hrdmrk=hrd
hrd=1
@smpauto
hrd=hrdmrk
ENDIF
IF obj=smpstrt3& THEN
hrdmrk=hrd
hrd=1
@smpstart
hrd=hrdmrk
ENDIF
IF obj=recplay& THEN
@recplay
ENDIF
IF obj=hardmerg& THEN
@make
ENDIF
IF obj=arrload& THEN
@arrload
ENDIF
IF obj=arrsave& THEN
@arrsave
ENDIF
IF obj=hardfs1& OR obj=hardfs2& OR obj=hardfs3& OR obj=hardfs4& THEN
@hardfs
ENDIF
IF obj=arrmidi1& OR obj=arrmidi2& OR obj=arrmidi3& OR obj=arrmidi4& THEN
@arrmidi
ENDIF
IF obj=arrsmpr1& OR obj=arrsmpr2& OR obj=arrsmpr3& OR obj=arrsmpr4& THEN
@arrsmpr
ENDIF
IF obj=hardstrt& THEN
@hardstrt
ENDIF
IF obj=hardend& THEN
@hardend
ENDIF
IF obj=arrplay& THEN
@arrplay
ENDIF
IF obj=slideup& THEN
@slideup
@setbutton(slideup&,0)
ENDIF
IF obj=slidedwn& THEN
@slidedwn
@setbutton(slidedwn&,0)
ENDIF
IF obj=arrmidi& THEN
@arrmidplay
ENDIF
IF obj=arrtri1& OR obj=arrtri2& OR obj=arrtri3& OR obj=arrtri4& THEN
@arrtristate
ENDIF
IF obj=arrdel1& OR obj=arrdel2& OR obj=arrdel3& OR obj=arrdel4& THEN
@arrdel
ENDIF
IF obj=arrloop1& OR obj=arrloop2& OR obj=arrloop3& OR obj=arrloop4& THEN
@arrloop
ENDIF
IF obj=arrm1& OR obj=arrm2& OR obj=arrm3& OR obj=arrm4& THEN
@arrtowork
ENDIF
IF obj=arrstrt& THEN
@arrstrt
ENDIF
IF obj=arrend& THEN
@arrend
ENDIF
IF obj=arrhelp& THEN
@helptxt("ARRANGER")
ENDIF
IF obj=arreal& THEN
@realtime
ENDIF
IF obj=arrins& THEN
@arrinsert
ENDIF
IF obj=arrdel& THEN
@arrdelete
ENDIF
IF obj=arrdelay& THEN
@arrdelay
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
UNTIL obj=arrexit&
@setbutton(obj,0)
vornr=smpedit&
path$=merkpfad$
@restaura2
obj=0
@setbutton(arrange&,0)
GRAPHMODE 3
IF hz<>merkhz THEN
hz=merkhz
@swtosrate(hz)
ENDIF
RETURN
'
> PROCEDURE arrsmpr
LOCAL i,j
IF obj=arrsmpr1& THEN
i=1
ENDIF
IF obj=arrsmpr2& THEN
i=2
ENDIF
IF obj=arrsmpr3& THEN
i=3
ENDIF
IF obj=arrsmpr4& THEN
i=4
ENDIF
IF arrpath$(pbz*4+i)<>"" THEN
mrkobj=obj
vorvornr=vornr
vornr=nr
@rsc_back(nr)
nr=resample&
~@xrsrc_gaddr(0,resample&,zu%)
versatz=1
a$="SAMPLERATE"
string=LPEEK(LPEEK(zu%+24*rsmptxt1&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
a$="  NEW  "
string=LPEEK(LPEEK(zu%+24*rsmptxt2&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
@rsc_draw(nr,5)
resorig=INT(arrsrate(pbz*4+i)/100)/10
db$=STR$(resorig)+CHR$(0)
@editfeld(restxt&,db$)
resoth=44.1
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
REPEAT
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,v3,v4)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
IF obj=resl1& OR obj=resl2& OR obj=resl3& OR obj=resr1& OR obj=resr2& OR obj=resr3& THEN
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=resl1& OR obj=resl2& OR obj=resl3& THEN
@resl
ENDIF
IF obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@resr
ENDIF
IF obj=res32& THEN
@resoth32
ENDIF
IF obj=res44& THEN
@resoth44
ENDIF
IF obj=res48& THEN
@resoth48
ENDIF
IF obj=helprsmp& THEN
@helptxt("ARR-SAMPLERATE")
ENDIF
UNTIL obj=resok& OR obj=resexit&
IF obj=resok& THEN
@editread(resother&)
noresok=FALSE
IF LEN(a$)>0 THEN
FOR j=1 TO LEN(a$)
a=ASC(MID$(a$,j,1))
IF (a<48 OR a>57) AND a<>46 THEN
noresok=TRUE
ENDIF
IF (j=1 OR j=4) AND a=46 THEN
noresok=TRUE
ENDIF
NEXT j
ELSE
noresok=TRUE
ENDIF
ENDIF
@setbutton(obj,0)
UNTIL (obj=resok& AND noresok=FALSE) OR obj=resexit&
IF obj=resok& AND noresok=FALSE THEN
resoth=VAL(a$)*1000
arrsrate(pbz*4+i)=resoth
ENDIF
@restaura2
~@xrsrc_gaddr(0,resample&,zu%)
a$="RESAMPLING"
string=LPEEK(LPEEK(zu%+24*rsmptxt1&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
a$="CONVERT"
string=LPEEK(LPEEK(zu%+24*rsmptxt2&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
vornr=vorvornr
@setbutton(mrkobj,0)
@arrnrset
ELSE
@setbutton(obj,0)
ENDIF
obj=0
RETURN
'
> PROCEDURE realtime
IF realtime=FALSE THEN
realtime=TRUE
@arrnrset
ELSE
realtime=FALSE
@arrnrset
ENDIF
RETURN
'
> PROCEDURE arrstrt
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=0
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
seeknr=sectpos
seek=GEMDOS(66,L:seeknr,handle,0)
IF seek<0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=0
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
seeknr=sectpos
seek=GEMDOS(66,L:seeknr,handle,0)
ENDIF
ENDIF
IF seek<0 OR handle<0 THEN
ALERT 1,"Zuerst Sample laden !",1,"OK",g
handle=0
seek=0
ENDIF
@setbutton(arrstrt&,0)
RETURN
'
> PROCEDURE arrend
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=sectall
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
seeknr=sectpos*flen
seek=GEMDOS(66,L:seeknr,handle,0)
IF seek<0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=sectall
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
seeknr=sectpos*flen
seek=GEMDOS(66,L:seeknr,handle,0)
ENDIF
ENDIF
IF seek<0 OR handle<0 THEN
ALERT 1,"Zuerst Sample laden !",1,"OK",g
handle=0
seek=0
ENDIF
@setbutton(arrend&,0)
RETURN
'
> PROCEDURE dragging1
LOCAL z
IF obj=arrm1& THEN
z=1
ENDIF
IF obj=arrm2& THEN
z=2
ENDIF
IF obj=arrm3& THEN
z=3
ENDIF
IF obj=arrm4& THEN
z=4
ENDIF
IF arrherr=pbz*4+z THEN
IF arrpath$(arrherr)<>"" THEN
dragm=FALSE
mobj2=obj
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
@readpos(obj)
GRAPHMODE 3
~GRAF_MKSTATE(vmp,vmp2,v3,v4)
vm=vmp
vm2=vmp2
~GRAF_MOUSE(256,0)                              ! Hidem
BOX xd+bx-1,yd+by+121,xd+bx+28,yd+by+17+121
REPEAT
~GRAF_MKSTATE(v,v2,k,v4)
IF k=1 AND (v<>vm OR v2<>vm2) THEN
BOX xd+bx-1+(vm-vmp),yd+by+121+(vm2-vmp2),xd+bx+28+(vm-vmp),yd+by+17+121+(vm2-vmp2)
BOX xd+bx-1+(v-vmp),yd+by+121+(v2-vmp2),xd+bx+28+(v-vmp),yd+by+17+121+(v2-vmp2)
vm=v
vm2=v2
ENDIF
fobj=OBJC_FIND(zu%,0,10,v,v2)
IF fobj=arrclip& THEN
@readbutton(arrclip&)
IF hardtype<>0 AND arrherr=pbz*4+z THEN
IF buttflag=0 AND arrpath$(pbz*4+z)<>"" THEN
@setbutton(arrclip&,1)
dragm=TRUE
merkclip=pbz*4+z
ENDIF
ENDIF
ENDIF
IF fobj<>arrclip& AND dragm=TRUE THEN
@readbutton(arrclip&)
IF buttflag<>0 THEN
@setbutton(arrclip&,0)
ENDIF
ENDIF
UNTIL k=0
BOX xd+bx-1+(vm-vmp),yd+by+121+(vm2-vmp2),xd+bx+28+(vm-vmp),yd+by+17+121+(vm2-vmp2)
~GRAF_MOUSE(257,0)                              ! Showm
IF fobj=arrclip& AND drag=TRUE THEN
@setbutton(arrclip&,0)
FOR i=0 TO 2
PAUSE 2
@setbutton(arrclip&,1)
PAUSE 2
@setbutton(arrclip&,0)
NEXT i
merkclip=pbz*4+z
ENDIF
GRAPHMODE 3
IF dragm=TRUE THEN
drag=TRUE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE dragging2
LOCAL z
IF drag=TRUE THEN
@markhlp
drag2=FALSE
~@xrsrc_gaddr(0,nr,zu%)
@readpos(obj)
GRAPHMODE 3
~GRAF_MKSTATE(vmp,vmp2,v3,v4)
vm=vmp
vm2=vmp2
~GRAF_MOUSE(256,0)                              ! Hidem
BOX xd+bx-1,yd+by-50,xd+bx+28,yd+by+17-50
REPEAT
~GRAF_MKSTATE(v,v2,k,v4)
IF k=1 AND (v<>vm OR v2<>vm2) THEN
BOX xd+bx-1+(vm-vmp),yd+by-50+(vm2-vmp2),xd+bx+28+(vm-vmp),yd+by+17-50+(vm2-vmp2)
BOX xd+bx-1+(v-vmp),yd+by-50+(v2-vmp2),xd+bx+28+(v-vmp),yd+by+17-50+(v2-vmp2)
vm=v
vm2=v2
ENDIF
obj=OBJC_FIND(zu%,0,10,v,v2)
IF obj=arrm1& OR obj=arrm2& OR obj=arrm3& OR obj=arrm4& THEN
z=0
IF obj=arrm1& THEN
z=1
ENDIF
IF obj=arrm2& THEN
z=2
ENDIF
IF obj=arrm3& THEN
z=3
ENDIF
IF obj=arrm4& THEN
z=4
ENDIF
IF z=>0 THEN
IF arrpath$(pbz*4+z)="" THEN
@readbutton(obj)
IF buttflag=0 THEN
@setbutton(obj,1)
drag2=TRUE
mobj=obj
ENDIF
ENDIF
ENDIF
ENDIF
IF obj<>arrm1& AND obj<>arrm2& AND obj<>arrm3& AND obj<>arrm4& AND drag2=TRUE THEN
@setbutton(mobj,0)
drag2=FALSE
ENDIF
UNTIL k=0
BOX xd+bx-1+(vm-vmp),yd+by-50+(vm2-vmp2),xd+bx+28+(vm-vmp),yd+by+17-50+(vm2-vmp2)
~GRAF_MOUSE(257,0)                              ! Showm
IF drag2=TRUE THEN
@setbutton(mobj2,0)
@setbutton(mobj,1)
FOR i=0 TO 2
PAUSE 2
@setbutton(mobj,0)
PAUSE 2
@setbutton(mobj,1)
NEXT i
arrfn$(pbz*4+z)=arrfn$(merkclip)
arrpath$(pbz*4+z)=arrpath$(merkclip)
arrstrt(pbz*4+z)=arrstrt(merkclip)
arrend(pbz*4+z)=arrend(merkclip)
arrlen(pbz*4+z)=arrlen(merkclip)
arrmidi(pbz*4+z)=arrmidi(merkclip)
arrloop(pbz*4+z)=arrloop(merkclip)
arrtri(pbz*4+z)=arrtri(merkclip)
arrsrate(pbz*4+z)=arrsrate(merkclip)
obj=mobj
@setbutton(arrclip&,0)
spring=TRUE
@arrtowork
spring=FALSE
@arrnrset
ENDIF
GRAPHMODE 3
ELSE
REPEAT
~GRAF_MKSTATE(v,v2,k,v4)
UNTIL k=0
ENDIF
@setbutton(arrclip&,0)
RETURN
'
> PROCEDURE arrtowork
IF spring=FALSE THEN
@dragging1
ENDIF
IF obj=arrm1& THEN
hardtype=1
arrherr=pbz*4+1
ENDIF
IF obj=arrm2& THEN
hardtype=2
arrherr=pbz*4+2
ENDIF
IF obj=arrm3& THEN
hardtype=3
arrherr=pbz*4+3
ENDIF
IF obj=arrm4& THEN
hardtype=4
arrherr=pbz*4+4
ENDIF
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF arrpath$(pbz*4+hardtype)<>"MEMORY" AND arrpath$(pbz*4+hardtype)<>"DELAY" AND arrpath$(pbz*4+hardtype)<>"" THEN
pat$=arrpath$(pbz*4+hardtype)
vhz=arrsrate(pbz*4+hardtype)
arrz=hardtype
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pa$=pat$+CHR$(0)
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
sectors=INT(f/flen)
sectall=sectors
sectpos=arrstrt(pbz*4+hardtype)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=LEFT$(pat$+SPACE$(12),12)+CHR$(0)
hardopen=TRUE
hsec=INT(sectpos*flen/hz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
a$=LEFT$(arrfn$(pbz*4+hardtype)+SPACE$(12),12)
@textfeld(playname&,a$,1)
ENDIF
'  @setbutton(obj,0)
RETURN
'
> PROCEDURE copytoarr
LOCAL i
i=0
REPEAT
INC i
UNTIL i=lmax2 OR arrfn$(i)=""
IF arrfn$(i)="" THEN
@blocklook
IF sms<>0 AND sme<>0 THEN
IF virtual=FALSE THEN
arrstrt(i)=mcs-meml
arrend(i)=mce-meml
arrlen(i)=mce-mcs
arrpath$(i)="MEMORY"
ELSE
arrstrt(i)=INT((mcs-meml)/flen)
arrend(i)=INT((mce-meml)/flen)
arrlen(i)=INT((mce-mcs)/flen)
arrpath$(i)=rpath$
ENDIF
arrsrate(i)=hz
arrloop(i)=sloop
arrtri(i)=sret
IF mp$<>"" THEN
arrfn$(i)=mp$
ELSE
arrfn$(i)="MEMORY"
ENDIF
i$=RIGHT$("  "+STR$(i),3)+CHR$(0)
@textfeld(coptotxt&,i$,1)
ELSE
g=@rsc_alert(1,"Blockmarkierung fehlt !","OK",1)
'      ALERT 1,"Blockmarkierung fehlt !",1,"OK",g
ENDIF
ELSE
ALERT 1,"Alle EintrÑge belegt !",1,"OK",g
ENDIF
@setbutton(coptoarr&,0)
RETURN
'
> PROCEDURE arrtristate
IF obj=arrtri1& THEN
z=1
ENDIF
IF obj=arrtri2& THEN
z=2
ENDIF
IF obj=arrtri3& THEN
z=3
ENDIF
IF obj=arrtri4& THEN
z=4
ENDIF
tri=arrtri(pbz*4+z)
@rsc_tristate(nr,obj)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
arrtri(pbz*4+z)=tri
IF realtime=TRUE THEN
@arrnrset
ENDIF
RETURN
'
> PROCEDURE arrmidi
mrkch=ch
mrknote=note
IF obj=arrmidi1& THEN
arrmz=1
ENDIF
IF obj=arrmidi2& THEN
arrmz=2
ENDIF
IF obj=arrmidi3& THEN
arrmz=3
ENDIF
IF obj=arrmidi4& THEN
arrmz=4
ENDIF
mrkobj=obj
z=arrmidi(pbz*4+arrmz)
note=(z AND 255)
ch=INT(z/256)+1
@midi
ch$=RIGHT$(" "+STR$(ch),2)+CHR$(0)
arrmidi(pbz*4+arrmz)=midiwort
IF mrkobj=arrmidi1& THEN
@textfeld(arrch1&,ch$,1)
@textfeld(arrnote1&,db$,1)
ENDIF
IF mrkobj=arrmidi2& THEN
@textfeld(arrch2&,ch$,1)
@textfeld(arrnote2&,db$,1)
ENDIF
IF mrkobj=arrmidi3& THEN
@textfeld(arrch3&,ch$,1)
@textfeld(arrnote3&,db$,1)
ENDIF
IF mrkobj=arrmidi4& THEN
@textfeld(arrch4&,ch$,1)
@textfeld(arrnote4&,db$,1)
ENDIF
ch=mrkch
note=mrknote
RETURN
'
> PROCEDURE arrmidplay
@wait
POKE mdat2%+retanz,0
a=meml
b=memh
IF sret=1 THEN
POKE mdat2%+retanz,8
c=a
a=b-4
b=c
ENDIF
adm=ad
IF adm=0 THEN
@analog
ENDIF
IF sret=0 AND a<b THEN
@maschruf18b
@digin
ENDIF
IF sret=1 AND a>b THEN
@maschruf18b
@digin
ENDIF
IF adm=0 THEN
@digital
ENDIF
IF sret=1 THEN
POKE mdat2%+retanz,0
ENDIF
@setbutton(arrmidi&,0)
RETURN
'
> PROCEDURE arrdel
LOCAL z
IF obj=arrdel1& THEN
z=1
ENDIF
IF obj=arrdel2& THEN
z=2
ENDIF
IF obj=arrdel3& THEN
z=3
ENDIF
IF obj=arrdel4& THEN
z=4
ENDIF
arrfn$(pbz*4+z)=""
arrpath$(pbz*4+z)=""
arrstrt(pbz*4+z)=0
arrend(pbz*4+z)=0
arrlen(pbz*4+z)=0
arrloop(pbz*4+z)=0
arrtri(pbz*4+z)=0
arrsrate(pbz*4+z)=0
a$="            "+CHR$(0)
a2$="00:00:00 00"+CHR$(0)
a3$=" "+CHR$(0)
a4$=SPACE$(4)+CHR$(0)
tri=0
IF z=1 THEN
@textfeld(arrsmpr1&,a4$,1)
@setbutton(arrmidi1&,0)
@setbutton(arrtri1&,0)
@textfeld(arrmem1&,a3$,1)
@textfeld(spur1&,a$,1)
@textfeld(hardst1&,a2$,1)
@textfeld(harde1&,a2$,1)
@textfeld(hardlen1&,a2$,1)
@setbutton(arrloop1&,0)
@rsc_tristate2(nr,arrtri1&)
ENDIF
IF z=2 THEN
@textfeld(arrsmpr2&,a4$,1)
@setbutton(arrmidi2&,0)
@setbutton(arrtri2&,0)
@textfeld(arrmem2&,a3$,1)
@textfeld(spur2&,a$,1)
@textfeld(hardst2&,a2$,1)
@textfeld(harde2&,a2$,1)
@textfeld(hardlen2&,a2$,1)
@setbutton(arrloop2&,0)
@rsc_tristate2(nr,arrtri2&)
ENDIF
IF z=3 THEN
@textfeld(arrsmpr3&,a4$,1)
@setbutton(arrmidi3&,0)
@setbutton(arrtri3&,0)
@textfeld(arrmem3&,a3$,1)
@textfeld(spur3&,a$,1)
@textfeld(hardst3&,a2$,1)
@textfeld(harde3&,a2$,1)
@textfeld(hardlen3&,a2$,1)
@setbutton(arrloop3&,0)
@rsc_tristate2(nr,arrtri3&)
ENDIF
IF z=4 THEN
@textfeld(arrsmpr4&,a4$,1)
@setbutton(arrmidi4&,0)
@setbutton(arrtri4&,0)
@textfeld(arrmem4&,a3$,1)
@textfeld(spur4&,a$,1)
@textfeld(hardst4&,a2$,1)
@textfeld(harde4&,a2$,1)
@textfeld(hardlen4&,a2$,1)
@setbutton(arrloop4&,0)
@rsc_tristate2(nr,arrtri4&)
ENDIF
IF realtime=TRUE THEN
@arrnrset
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE arrinsert
LOCAL s,i,a1,a2,g
IF arrherr<>0 THEN
s=arrherr
a1=0
a2=0
IF s<lmax2 THEN
i=lmax2+1
@busy_mouse
REPEAT
DEC i
UNTIL arrpath$(i)<>"" OR i=s
IF arrpath$(i)<>"" THEN
a2=i
ENDIF
IF a2=0 THEN
ALERT 1,"Ist doch genug Platz !",1,"OK",g
ENDIF
IF a2=lmax2 THEN
ALERT 1,"Der letzte Platz ist belegt,|daher kein INSERT mîglich!",1,"OK",g
ENDIF
IF a2<>0 AND a2<>lmax2 THEN
i=s-1
REPEAT
INC i
UNTIL arrpath$(i)<>"" OR i=lmax2
IF arrpath$(i)<>"" THEN
a1=i
ENDIF
FOR i=a2 TO a1 STEP -1
arrpath$(i+1)=arrpath$(i)
arrfn$(i+1)=arrfn$(i)
arrstrt(i+1)=arrstrt(i)
arrend(i+1)=arrend(i)
arrlen(i+1)=arrlen(i)
arrmidi(i+1)=arrmidi(i)
arrloop(i+1)=arrloop(i)
arrtri(i+1)=arrtri(i)
arrsrate(i+1)=arrsrate(i)
NEXT i
arrpath$(a1)=""
arrfn$(a1)=""
arrstrt(a1)=0
arrend(a1)=0
arrlen(a1)=0
arrmidi(a1)=0
arrloop(a1)=0
arrtri(a1)=0
arrsrate(a1)=0
@arrnrset
ENDIF
ENDIF
ELSE
@hardwahl
ENDIF
@setbutton(arrins&,0)
RETURN
'
> PROCEDURE arrdelete
LOCAL s,i,a1,a2
IF arrherr<>0 THEN
s=arrherr
a1=0
a2=0
arrpath$(s)=""
arrfn$(s)=""
arrstrt(s)=0
arrend(s)=0
arrlen(s)=0
arrmidi(s)=0
arrloop(s)=0
arrtri(s)=0
arrsrate(s)=0
IF s<lmax2 THEN
i=s
@busy_mouse
REPEAT
INC i
UNTIL arrpath$(i)<>"" OR i=lmax2
IF arrpath$(i)<>"" THEN
a1=i
ENDIF
IF a1<>0 THEN
i=lmax2+1
REPEAT
DEC i
UNTIL arrpath$(i)<>"" OR i=1
IF arrpath$(i)<>"" THEN
a2=i
ENDIF
FOR i=a1 TO a2
arrpath$(i-1)=arrpath$(i)
arrfn$(i-1)=arrfn$(i)
arrstrt(i-1)=arrstrt(i)
arrend(i-1)=arrend(i)
arrlen(i-1)=arrlen(i)
arrmidi(i-1)=arrmidi(i)
arrloop(i-1)=arrloop(i)
arrtri(i-1)=arrtri(i)
arrsrate(i-1)=arrsrate(i)
NEXT i
arrpath$(a2)=""
arrfn$(a2)=""
arrstrt(a2)=0
arrend(a2)=0
arrlen(a2)=0
arrmidi(a2)=0
arrloop(a2)=0
arrtri(a2)=0
arrsrate(a2)=0
ENDIF
ENDIF
@arrnrset
ELSE
@hardwahl
ENDIF
@setbutton(arrdel&,0)
RETURN
'
> PROCEDURE delaytxt
LOCAL b$,a,dtt
dtt=dt
a$=""
b$=""
IF dtt>=360000 THEN
a=INT(dtt/360000)
dtt=dtt-a*360000
a$=STR$(a)
ENDIF
IF LEN(a$)=0 THEN
a$="00"
ENDIF
IF LEN(a$)=1 THEN
a$="0"+a$
ENDIF
IF dtt>=6000 THEN
a=INT(dtt/6000)
dtt=dtt-a*6000
b$=STR$(a)
ENDIF
IF LEN(b$)=0 THEN
b$="00"
ENDIF
IF LEN(b$)=1 THEN
b$="0"+b$
ENDIF
a$=a$+b$
b$=""
IF dtt>=100 THEN
a=INT(dtt/100)
dtt=dtt-a*100
b$=STR$(a)
ENDIF
IF LEN(b$)=0 THEN
b$="00"
ENDIF
IF LEN(b$)=1 THEN
b$="0"+b$
ENDIF
a$=a$+b$
a=INT(dtt)
b$=STR$(a)
IF LEN(b$)=0 THEN
b$="00"
ENDIF
IF LEN(b$)=1 THEN
b$="0"+b$
ENDIF
a$=a$+b$+CHR$(0)
RETURN
'
> PROCEDURE txtdelay
LOCAL g
wandel=TRUE
IF VAL(MID$(a$,5,2))>59 THEN
wandel=FALSE
ENDIF
IF VAL(MID$(a$,3,2))>59 THEN
wandel=FALSE
ENDIF
IF (VAL(RIGHT$(a$,1)) AND 1)=1 THEN
wandel=FALSE
ENDIF
IF LEN(a$)<>8 THEN
wandel=FALSE
ENDIF
IF wandel=FALSE THEN
ALERT 1,"unkorrekte Eingabe !",1,"OK",g
ELSE
dt=0
dt=VAL(RIGHT$(a$,2))
dt=dt+VAL(MID$(a$,5,2))*100
dt=dt+VAL(MID$(a$,3,2))*6000
dt=dt+VAL(LEFT$(a$,2))*360000
ENDIF
RETURN
'
> PROCEDURE arrdelay
IF arrherr<>0 THEN
IF arrpath$(arrherr)="" OR arrpath$(arrherr)="DELAY" THEN
vornr=nr
@rsc_back(nr)
nr=delay&
@rsc_draw(nr,5)
@markhlp
IF arrend(arrherr)<>0 THEN
deltime=arrend(arrherr)
ENDIF
dt=deltime
IF deltime=0 THEN
a$="00000000"+CHR$(0)
ELSE
@delaytxt
ENDIF
@editfeld(delaytim&,a$)
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
PAUSE 2
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=delayhlp& THEN
@helptxt("DELAY")
ENDIF
IF obj=delayr& THEN
@delayr
ENDIF
IF obj=delayl& THEN
@delayl
ENDIF
UNTIL obj=delayex& OR obj=delayok&
@setbutton(obj,0)
IF obj=delayok& THEN
@editread(delaytim&)  ! RÅckgabewert in a$
@txtdelay
IF wandel=TRUE THEN
deltime=dt
arrpath$(arrherr)="DELAY"
arrstrt(arrherr)=0
arrend(arrherr)=deltime
arrlen(arrherr)=deltime
arrsrate(arrherr)=hz
IF arrfn$(arrherr)="" THEN
arrfn$(arrherr)="DELAY"
ENDIF
ENDIF
ENDIF
@restaura2
IF obj=delayok& THEN
@arrnrset
ENDIF
obj=0
ELSE
ALERT 1,"Platz ist besetzt !",1,"OK",g
ENDIF
ELSE
@hardwahl
ENDIF
@setbutton(arrdelay&,0)
RETURN
'
> PROCEDURE hardwahl
LOCAL g
ALERT 1,"Zuerst Platz auswÑhlen !",1,"OK",g
RETURN
'
> PROCEDURE delayr
@editread(delaytim&)  ! RÅckgabewert in a$
@txtdelay
IF wandel=TRUE THEN
IF dt<35999999 THEN
dt=dt+2
@delaytxt
@editfeld(delaytim&,a$)
ENDIF
ENDIF
@setbutton(delayr&,0)
RETURN
'
> PROCEDURE delayl
@editread(delaytim&)  ! RÅckgabewert in a$
@txtdelay
IF wandel=TRUE THEN
IF dt>0 THEN
dt=dt-2
@delaytxt
@editfeld(delaytim&,a$)
ENDIF
ENDIF
@setbutton(delayl&,0)
RETURN
'
> PROCEDURE arrmname
mrkobj=obj
vorvornr=vornr
vornr=nr
@rsc_back(nr)
nr=arrmname&
@rsc_draw(nr,5)
@markhlp
IF arrfn$(pbz*4+hardtype)="MEMORY" THEN
a$=mp$+CHR$(0)
a=INSTR(a$,".")
IF a>1 THEN
a$=LEFT$(a$,a-1)+CHR$(0)
ENDIF
ELSE
a$=arrfn$(pbz*4+hardtype)+CHR$(0)
ENDIF
IF LEN(a$)>12 THEN
a$=LEFT$(a$,12)
ENDIF
@editfeld(memname&,a$)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,v3,v4)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=amhelp& THEN
@helptxt("ARRANGE-NAME Ñndern")
ENDIF
UNTIL obj=amexit& OR obj=amok&
IF obj=amok& THEN
editread(memname&)
arrfn$(pbz*4+hardtype)=a$
ENDIF
@setbutton(obj,0)
@restaura2
IF obj=amok& THEN
a$=LEFT$(arrfn$(pbz*4+hardtype)+"            ",12)+CHR$(0)
IF hardtype=1 THEN
@textfeld(spur1&,a$,1)
ENDIF
IF hardtype=2 THEN
@textfeld(spur2&,a$,1)
ENDIF
IF hardtype=3 THEN
@textfeld(spur3&,a$,1)
ENDIF
IF hardtype=4 THEN
@textfeld(spur4&,a$,1)
ENDIF
ENDIF
obj=mrkobj
vornr=vorvornr
RETURN
'
> PROCEDURE arrloop
IF obj=arrloop1& THEN
z=1
ENDIF
IF obj=arrloop2& THEN
z=2
ENDIF
IF obj=arrloop3& THEN
z=3
ENDIF
IF obj=arrloop4& THEN
z=4
ENDIF
IF arrloop(pbz*4+z)=0 THEN
arrloop(pbz*4+z)=1
ELSE
arrloop(pbz*4+z)=0
ENDIF
RETURN
'
> PROCEDURE wait
LOCAL v,v2,v3,v4
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
REPEAT
IF INP?(2)=TRUE THEN
~INP(2)
ENDIF
UNTIL INP?(2)=FALSE
UNTIL v3=0 AND v4=0
PAUSE 3
RETURN
'
> PROCEDURE arrplay
LOCAL r,akku,j,rr
IF virtual=TRUE THEN
ALERT 1,"Kein PLAY von Memory-Daten !|Wegen virt. Bearbeitung|gesperrt.",1,"OK",g
ENDIF
@wait
over=0
@makehz
@digout(TRUE)
@maschinit23
@maschinit22
@maschinit24
i=0
j=0
rr=0
akku=0
rpat$=""
vvhz=hz
REPEAT
INC i
pat$=arrpath$(i)
vhz=arrsrate(i)
IF vhz=0 THEN
vhz=44100
ENDIF
IF pat$="DELAY" THEN
IF realtime=FALSE THEN
hsec=arrstrt(i)
ELSE
hsec=INT(akku/vhz/4*100)
akku=akku+arrend(i)*vhz*4/100
ENDIF
@htimeset
@textfeld(playlen&,a$,1)
a$=LEFT$(arrfn$(i)+SPACE$(12),12)
@textfeld(playname&,a$,1)
t=arrend(i)*2
aready=FALSE
tim=TIMER
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
a=TIMER
IF (a-tim)<0 THEN
tim=0
ENDIF
IF (a-tim)>=t THEN
aready=TRUE
ENDIF
UNTIL aready=TRUE OR v3<>0
IF aready=TRUE THEN
back%=0
ELSE
back%=1
ENDIF
ENDIF
IF arrend(i)<>0 AND pat$<>"" AND pat$<>"DELAY" THEN
IF pat$="MEMORY" THEN
l=0
IF arrloop(i)=1 THEN
l=-1
ENDIF
r=arrtri(i)
IF realtime=FALSE THEN
IF r=0 OR r=2 THEN
hsec=INT(arrstrt(i)/vhz/4*100)
ENDIF
IF r=1 THEN
hsec=INT(arrend(i)/vhz/4*100)
ENDIF
ELSE
hsec=INT(akku/vhz/4*100)
IF r=2 THEN
akku=akku+(arrend(i)-arrstrt(i))*2
ELSE
akku=akku+arrend(i)-arrstrt(i)
ENDIF
ENDIF
@htimeset
@textfeld(playlen&,a$,1)
a$=LEFT$(arrfn$(i)+SPACE$(12),12)
@textfeld(playname&,a$,1)
IF r=0 OR r=2 THEN
a=arrstrt(i)+meml
b=arrend(i)+meml
ENDIF
IF r=1 THEN
b=arrstrt(i)+meml
a=arrend(i)+meml
POKE mdat3%+retanz,8
ENDIF
IF virtual=FALSE THEN
@swtosrate(vhz)
IF r=0 OR r=1 THEN
@maschruf22
ELSE
@maschruf24
ENDIF
ELSE
back%=0
ENDIF
IF r=1 THEN
POKE mdat3%+retanz,0
ENDIF
ELSE
IF EXIST(pat$) THEN
loop=arrloop(i)
REPEAT
r=arrtri(i)
IF r=0 OR r=2 THEN
IF realtime=FALSE THEN
hsec=INT(arrstrt(i)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
akku=akku+(arrend(i)-arrstrt(i))*flen
ENDIF
@htimeset
@textfeld(playlen&,a$,1)
pa$=pat$+CHR$(0)
a$=LEFT$(arrfn$(i)+SPACE$(12),12)
@textfeld(playname&,a$,1)
sectors=arrend(i)-arrstrt(i)
sectpos=arrstrt(i)
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
seeknr=arrstrt(i)*flen
seek=GEMDOS(66,L:seeknr,handle,0)
IF seek>=0 THEN
@swtosrate(vhz)
@maschruf23
~GEMDOS(62,handle)
ENDIF
ENDIF
ENDIF
IF r=1 OR (r=2 AND back%=sectors) THEN
IF realtime=FALSE THEN
hsec=INT(arrend(i)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
akku=akku+(arrend(i)-arrstrt(i))*flen
ENDIF
@htimeset
@textfeld(playlen&,a$,1)
pa$=pat$+CHR$(0)
a$=LEFT$(arrfn$(i)+SPACE$(12),12)
@textfeld(playname&,a$,1)
sectors=arrend(i)-arrstrt(i)
sectpos=arrend(i)
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
seeknr=arrend(i)*flen
seek=GEMDOS(66,L:seeknr,handle,0)
IF seek>=0 THEN
@maschinit25
@swtosrate(vhz)
@maschruf25
~GEMDOS(62,handle)
@maschinit23
ENDIF
ENDIF
ENDIF
UNTIL loop=0 OR back%<>sectors
ENDIF
ENDIF
ENDIF
IF pat$<>"" THEN
j=i
rr=r
rpat$=pat$
vvhz=vhz
ENDIF
UNTIL i=lmax2 OR (back%<>sectors AND pat$<>"MEMORY" AND pat$<>"" AND pat$<>"DELAY") OR (back%<>0 AND (pat$="MEMORY" OR pat$="DELAY"))
vhz=vvhz
@textfeld(playname&,"            "+CHR$(0),1)
IF rpat$="DELAY" AND back%=0 THEN
IF realtime=FALSE THEN
hsec=arrend(j)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF pat$="DELAY" AND back%<>0 THEN
a$="   BREAK   "+CHR$(0)
ENDIF
IF pat$="MEMORY" AND back%<>0 THEN
a$="   BREAK   "+CHR$(0)
ENDIF
IF pat$<>"MEMORY" AND pat$<>"DELAY" AND pat$<>"" AND back%<>sectors THEN
IF r=0 THEN
IF realtime=FALSE THEN
hsec=INT((arrstrt(i)+back%)*flen/vhz/4*100)
ELSE
hsec=INT(((akku-((arrend(i)-arrstrt(i))*flen)+(back%*flen)))/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF r=1 THEN
IF realtime=FALSE THEN
hsec=INT((arrend(i)-back%)*flen/vhz/4*100)
ELSE
hsec=INT(((akku-((arrend(i)-arrstrt(i))*flen)+(back%*flen)))/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF r=2 AND back%<>sectors THEN
a$="   BREAK   "+CHR$(0)
ENDIF
ENDIF
IF rpat$<>"" AND rpat$<>"MEMORY" AND rpat$<>"DELAY" THEN
IF rr=0 AND back%=sectors THEN
IF realtime=FALSE THEN
hsec=INT(arrend(j)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=1 AND back%=sectors THEN
IF realtime=FALSE THEN
hsec=INT(arrstrt(j)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=2 AND back%=sectors THEN
IF realtime=FALSE THEN
hsec=INT(arrstrt(j)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
ENDIF
IF rpat$="MEMORY" THEN
IF rr=0 AND back%=0 THEN
IF realtime=FALSE THEN
hsec=INT(arrend(j)/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=1 AND back%=0 THEN
IF realtime=FALSE THEN
hsec=INT(arrstrt(j)/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=2 THEN
b$="   BREAK   "+CHR$(0)
IF b$<>a$ THEN
IF realtime=FALSE THEN
hsec=INT(arrstrt(j)/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
ENDIF
ENDIF
@textfeld(playlen&,a$,1)
@digout(FALSE)
@setbutton(arrplay&,0)
RETURN
'
> PROCEDURE swtosrate(swhz)
IF swhz=32000 THEN
@adlow
ENDIF
IF swhz=44100 THEN
@admid
ENDIF
IF swhz=48000 THEN
@adhigh
ENDIF
RETURN
'
> PROCEDURE hardstrt
arrstrt(pbz*4+arrz)=sectpos
IF realtime=FALSE THEN
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
IF hardtype=1 AND hardopen=TRUE THEN
@textfeld(hardst1&,a$,1)
ENDIF
IF hardtype=2 AND hardopen=TRUE THEN
@textfeld(hardst2&,a$,1)
ENDIF
IF hardtype=3 AND hardopen=TRUE THEN
@textfeld(hardst3&,a$,1)
ENDIF
IF hardtype=4 AND hardopen=TRUE THEN
@textfeld(hardst4&,a$,1)
ENDIF
ELSE
@arrnrset
ENDIF
@setbutton(hardstrt&,0)
RETURN
'
> PROCEDURE hardend
arrend(pbz*4+arrz)=sectpos
IF realtime=FALSE THEN
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
IF hardtype=1 AND hardopen=TRUE THEN
@textfeld(harde1&,a$,1)
ENDIF
IF hardtype=2 AND hardopen=TRUE THEN
@textfeld(harde2&,a$,1)
ENDIF
IF hardtype=3 AND hardopen=TRUE THEN
@textfeld(harde3&,a$,1)
ENDIF
IF hardtype=4 AND hardopen=TRUE THEN
@textfeld(harde4&,a$,1)
ENDIF
ELSE
@arrnrset
ENDIF
@setbutton(hardend&,0)
RETURN
'
> PROCEDURE hardfs
IF obj=hardfs1& THEN
hardtype=1
ENDIF
IF obj=hardfs2& THEN
hardtype=2
ENDIF
IF obj=hardfs3& THEN
hardtype=3
ENDIF
IF obj=hardfs4& THEN
hardtype=4
ENDIF
IF arrpath$(pbz*4+hardtype)="" THEN
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
IF obj=hardfs1& THEN
arrherr=pbz*4+1
ENDIF
IF obj=hardfs2& THEN
arrherr=pbz*4+2
ENDIF
IF obj=hardfs3& THEN
arrherr=pbz*4+3
ENDIF
IF obj=hardfs4& THEN
arrherr=pbz*4+4
ENDIF
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
@fileselect(op$+"*."+ext$,"","ARRANGE-FILE:")
pat$=path$
IF EXIST(pat$) THEN
patm$=pat$
@rsc_back(nr)
@rsc_draw(nr,5)
@busy_mouse
@ldhead
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pa$=pat$+CHR$(0)
sectors=INT(f/flen)
sectall=sectors
sectpos=0
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
IF LEN(pat$)>12 THEN
pat$=LEFT$(pat$,12)
ENDIF
hardopen=TRUE
hsec=INT(sectall*flen/vhz/4*100)
@htimeset
mz$="H"+CHR$(0)
a4$=LEFT$(STR$(INT(vhz/100)/10)+SPACE$(4),4)+CHR$(0)
IF obj=hardfs1& THEN
@textfeld(spur1&,pat$,1)
@textfeld(hardlen1&,a$,1)
@textfeld(arrmem1&,mz$,1)
@textfeld(arrsmpr1&,a4$,1)
ENDIF
IF obj=hardfs2& THEN
@textfeld(spur2&,pat$,1)
@textfeld(hardlen2&,a$,1)
@textfeld(arrmem2&,mz$,1)
@textfeld(arrsmpr2&,a4$,1)
ENDIF
IF obj=hardfs3& THEN
@textfeld(spur3&,pat$,1)
@textfeld(hardlen3&,a$,1)
@textfeld(arrmem3&,mz$,1)
@textfeld(arrsmpr3&,a4$,1)
ENDIF
IF obj=hardfs4& THEN
@textfeld(spur4&,pat$,1)
@textfeld(hardlen4&,a$,1)
@textfeld(arrmem4&,mz$,1)
@textfeld(arrsmpr4&,a4$,1)
ENDIF
arrz=hardtype
arrpath$(pbz*4+arrz)=patm$
arrfn$(pbz*4+arrz)=pat$
arrlen(pbz*4+arrz)=sectall
arrsrate(pbz*4+arrz)=vhz
a$=LEFT$(pat$+SPACE$(12),12)
@textfeld(playname&,a$,1)
@arrnrset
pbla=INT(pbmax/pbg*pbz)
pbf=pbmax-pbla
DEFFILL 1,2,2
PBOX pba,pbb+1,pba+16,pbb+pbla
DEFFILL 0,2,2
PBOX pba,pbb+pbla+1,pba+16,pbb+pbla+pbl
DEFFILL 1,2,2
PBOX pba,pbb+pbla+pbl+1,pba+16,pbb+pbmax
ENDIF
ELSE
@arrmname
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE hardmerg
@setbutton(hardmerg&,0)
RETURN
'
> PROCEDURE virtual
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
vornr=nr
@rsc_back(nr)
nr=virtual&
@rsc_draw(nr,5)
@hslideinit
@hslidezeig
@blockcalc
a$=LEFT$("MEM "+STR$(INT(mlen/4))+SPACE$(10),14)
@textfeld(vblkmlen&,a$,1)
a$=LEFT$("LEN "+STR$(INT(ln/4))+SPACE$(10),14)
@textfeld(vblkvlen&,a$,1)
a$=SPACE$(8)+CHR$(0)
@editfeld(vblkstrt&,a$)
tedart=1
@blkart
IF tedart=0 THEN
@setbutton(vseconds&,1)
@setbutton(vsamples&,0)
ELSE
@setbutton(vsamples&,1)
@setbutton(vseconds&,0)
ENDIF
@markhlp
IF virtwfile=TRUE THEN
@setbutton(virtwork&,1)
@setbutton(virtdir&,0)
ELSE
@setbutton(virtwork&,0)
@setbutton(virtdir&,1)
ENDIF
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,v3,v4)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
~GRAF_MKSTATE(x,v2,k,v4)
IF (obj=vslider& AND k=1) THEN
@markhlp
pba=xd+136
pbb=yd+56
IF ldzeig<hbg AND x>(hba+hbla+hbl) THEN
@rslide
ENDIF
IF ldzeig>1 AND x<(hba+hbla) THEN
@lslide
ENDIF
IF x>=hba+hbla AND x<=hba+hbla+hbl THEN
vx=x
REPEAT
~GRAF_MKSTATE(x,v2,v3,v4)
IF x>=hba AND x<=hba+hbmax AND x<>vx AND ldzeig<=hbg THEN
vldzeig=INT(hbg/hbmax*(x-hba))+1
IF vldzeig<ldzeig AND ldzeig>0 THEN
@lslide
ENDIF
IF vldzeig>ldzeig AND ldzeig<hbg THEN
@rslide
ENDIF
vx=x
ENDIF
UNTIL v3=0
ENDIF
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
ELSE
IF obj=virthelp& THEN
@helptxt("VIRTUAL")
ENDIF
IF obj=virtwork& THEN
virtwfile=TRUE
ENDIF
IF obj=virtdir& THEN
virtwfile=FALSE
ENDIF
IF obj=vlslide& THEN
@lslide
@setbutton(vlslide&,0)
ENDIF
IF obj=vrslide& THEN
@rslide
@setbutton(vrslide&,0)
ENDIF
ENDIF
IF obj=vsamples& THEN
vtedart=1
IF vtedart<>tedart THEN
@blkproof
IF notedok=FALSE THEN
tedart=vtedart
@blkart
ELSE
@setbutton(vseconds&,1)
@setbutton(vsamples&,0)
ENDIF
ENDIF
ENDIF
IF obj=vseconds& THEN
vtedart=0
IF vtedart<>tedart THEN
@blkproof
IF notedok=FALSE THEN
tedart=vtedart
@blkart
ELSE
@setbutton(vseconds&,0)
@setbutton(vsamples&,1)
ENDIF
ENDIF
ENDIF
IF obj=virtplay& THEN
@blkproof
@blockcalc
@maschinit23
handle=GEMDOS(61,L:VARPTR(path$),0)
IF handle>0 THEN
seek=GEMDOS(66,L:vhbldstrt,handle,0)
IF seek>=0 THEN
pa$=path$
sectors=INT(hbldlen/flen)
over=0
@digout(TRUE)
@maschruf23
@digout(FALSE)
~GEMDOS(62,handle)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
@setbutton(virtplay&,0)
ENDIF
UNTIL obj=virtbloc& OR obj=virtno& OR obj=virtok&
IF obj=virtbloc& THEN
blockld=FALSE
@blkproof
@blockcalc
mt=hbldlen
ELSE
blockld=FALSE
ENDIF
IF obj=virtok& THEN
virtual=TRUE
ELSE
virtual=FALSE
ENDIF
PAUSE 3
@setbutton(obj,0)
@restaura2
obj=0
' vhbldstrt,hbldlen
RETURN
'
> PROCEDURE blkart
IF tedart=0 THEN
u=vhbldstrt/(hz*4)
a$=STR$(u)
ELSE
u=INT(vhbldstrt/4)
a$=STR$(u)
ENDIF
IF LEN(a$)>8 THEN
a$=LEFT$(a$,8)
ENDIF
a$=a$+CHR$(0)
@editfeld(vblkstrt&,SPACE$(8)+CHR$(0))
@editfeld(vblkstrt&,a$)
RETURN
'
> PROCEDURE blkproof
@editread(vblkstrt&)
notedok=FALSE
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF (a<48 OR a>57) AND a<>46 THEN
notedok=TRUE
ENDIF
IF (i=1 OR i=8) AND a=46 THEN
notedok=TRUE
ENDIF
NEXT i
ELSE
notedok=TRUE
ENDIF
IF notedok=FALSE THEN
vhbldstrt=VAL(a$)
IF tedart=0 THEN
vhbldstrt=vhbldstrt*hz*4
ELSE
vhbldstrt=vhbldstrt*4
ENDIF
vhbldstrt=INT(vhbldstrt/4)*4
IF vhbldstrt<0 OR vhbldstrt>ln THEN
notedok=TRUE
ALERT 3,"Der Wert ist auûerhalb des|gÅltigen Bereichs !",1,"EXIT",g
ENDIF
ENDIF
IF notedok=FALSE THEN
blockld=TRUE
ENDIF
RETURN
'
> PROCEDURE blockcalc
hbldlen=INT(mlen/4)*4
IF vhbldstrt=0 THEN
vhbldstrt=INT((ln/hbg*(ldzeig-1))/4)*4
ENDIF
IF vhbldstrt+hbldlen>ln THEN
hbldlen=ln-vhbldstrt
ENDIF
RETURN
'
> PROCEDURE hslideinit
hbmax=143                  ! Hîhe des Sliders in Pixeln
hbg=INT((ln/mlen))+1       ! Einteilungsanzahl
hbl=hbmax/hbg              ! Grîûe des Schiebers
hbz=0                      ! Stelle des Schiebers
ldzeig=1
hbldlen=0
vhbldstrt=0
RETURN
'
> PROCEDURE hslidezeig
@markhlp
hba=xd+136          ! X-Koordinate Anfangspunkt
hbb=yd+56          ! Y-Koordinate Anfangspunkt
hbla=hbz
hpbla=hbold
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 1
DEFFILL 1,2,2
PBOX hba,hbb,hba+hbla,hbb+17
DEFFILL 0,1,8
PBOX hba+hbla+1,hbb+1,hba+hbla+hbl,hbb+16
DEFFILL 1,2,2
PBOX hba+hbla+hbl+1,hbb,hba+hbmax,hbb+17
~GRAF_MOUSE(257,0)                              ! Showm
RETURN
'
> PROCEDURE lslide
IF hbz>0 AND ldzeig>1 THEN
hbold=hbz
hbz=hbz-hbl
@hslidezeig
DEC ldzeig
vhbldstrt=INT((ln/hbg*(ldzeig-1))/4)*4
@blkart
ENDIF
RETURN
'
> PROCEDURE rslide
IF hbz<(hbmax-hbl) THEN
hbold=hbz
hbz=hbz+hbl
@hslidezeig
INC ldzeig
vhbldstrt=INT((ln/hbg*(ldzeig-1))/4)*4
@blkart
ENDIF
RETURN
'
> PROCEDURE hardproof
IF EXIST(path$)=TRUE THEN
@rettmem
@hardproof2
ENDIF
RETURN
'
> PROCEDURE hardproof2
LOCAL j,z,hl,glen,dh
IF EXIST(path$)=TRUE THEN
@busy_mouse
virtpath$=path$
OPEN "I",#1,path$
virtln=LOF(#1)
hl=virtln-2
@maschinit5
stp=(INT(mlen/xm))
stp=(INT((stp+1)/4)*4)
z=INT(hl/stp+stp)
IF cwerte1>0 THEN
~MFREE(cwert)
ENDIF
cwerte1=MALLOC((z+xm)*8)
IF cwerte1>0 THEN
cwert=cwerte1
cwerte1=INT((cwerte1+2)/2)*2
cwerte2=cwerte1+((z+xm)*4)
z=0
REPEAT
i=meml
IF hl<=mlen
glen=hl
ELSE
glen=mlen
ENDIF
werte=INT(glen/stp)
IF werte>0 THEN
glen=werte*stp
hl=hl-glen
BGET #1,meml,glen
FOR j=1 TO werte
@maschruf5
@busy_mouse
INC z
IF a>32767 THEN
a=a-65536
ENDIF
LPOKE (cwerte1+z*4),a
i=i+2
@maschruf5
IF a>32767 THEN
a=a-65536
ENDIF
LPOKE (cwerte2+z*4),a
i=i-2
i=i+stp
NEXT j
ENDIF
UNTIL hl<stp
CLOSE #1
maxcwert=z
mrkp$=path$
ELSE
ALERT 3,"Zu wenig Speicher frei !",1,"EXIT",g
virtual=FALSE
virtcurve=FALSE
@trash
ENDIF
ENDIF
RETURN
'
> PROCEDURE hardproof3
OPEN "I",#1,path$
virtln=LOF(#1)
CLOSE #1
RETURN
'
> PROCEDURE rettmem
@busy_mouse
IF profhz=0 AND hz<>0 THEN
profhz=hz
ENDIF
IF profhz=0 THEN
profhz=44100
ENDIF
IF profpath$="" THEN
profpath$=path$
ENDIF
IF profpath$="" THEN
profpath$=" MEMORY.SMP "+CHR$(0)
ENDIF
OPEN "O",#4,virt2$
PRINT #4,profpath$
PRINT #4,profln
PRINT #4,profhz
PRINT #4,sblock
PRINT #4,sloop
PRINT #4,sms
PRINT #4,sme
PRINT #4,master
PRINT #4,stax
PRINT #4,stbx
PRINT #4,stcx
PRINT #4,stdx
PRINT #4,stex
PRINT #4,stfx
PRINT #4,eax
PRINT #4,ebx
PRINT #4,ecx
PRINT #4,edx
PRINT #4,eex
PRINT #4,efx
CLOSE #4
BSAVE virt$,meml,mlen
RETURN
'
> PROCEDURE getmem
OPEN "I",#1,virt2$
INPUT #1,mp$
INPUT #1,ln
INPUT #1,hz
INPUT #1,sblock
INPUT #1,sloop
INPUT #1,sms
INPUT #1,sme
INPUT #1,master
INPUT #1,stax
INPUT #1,stbx
INPUT #1,stcx
INPUT #1,stdx
INPUT #1,stex
INPUT #1,stfx
INPUT #1,eax
INPUT #1,ebx
INPUT #1,ecx
INPUT #1,edx
INPUT #1,eex
INPUT #1,efx
CLOSE #1
BLOAD virt$,meml
KILL virt$
KILL virt2$
RETURN
'
> PROCEDURE arrload
LOCAL i,a,b
IF EXIST(arrup$) THEN
@rettmem
rett=TRUE
@busy_mouse
OPEN "I",#1,arrup$
FOR i=1 TO lmax2
INPUT #1,arrfn$(i)
INPUT #1,arrpath$(i)
INPUT #1,arrstrt(i)
INPUT #1,arrend(i)
INPUT #1,arrlen(i)
INPUT #1,arrmidi(i)
INPUT #1,arrloop(i)
INPUT #1,arrtri(i)
INPUT #1,arrsrate(i)
NEXT i
'
INPUT #1,mp$
INPUT #1,ln
INPUT #1,hz
INPUT #1,sblock
INPUT #1,sloop
INPUT #1,sms
INPUT #1,sme
INPUT #1,master
INPUT #1,stax
INPUT #1,stbx
INPUT #1,stcx
INPUT #1,stdx
INPUT #1,stex
INPUT #1,stfx
INPUT #1,eax
INPUT #1,ebx
INPUT #1,ecx
INPUT #1,edx
INPUT #1,eex
INPUT #1,efx
'
INPUT #1,mbs
IF mbs>0 THEN
FOR i=1 TO mbs
INPUT #1,mblocks(i)
INPUT #1,mblocke(i)
INPUT #1,mblockp$(i)
NEXT i
ENDIF
CLOSE #1
IF mbs>0 THEN
FOR i=1 TO mbs
IF EXIST(mblockp$(i))=TRUE THEN
IF mblocke(i)<=mlen THEN
OPEN "I",#1,mblockp$(i)
a=mblocke(i)-mblocks(i)
b=LOF(#1)
IF a>b THEN
a=b
ENDIF
BGET #1,meml+mblocks(i),a
CLOSE #1
ENDIF
ENDIF
NEXT i
cached=FALSE
ENDIF
pbz=0
pbla=0
arrz=0
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
@arrnrset
ENDIF
@setbutton(arrload&,0)
RETURN
'
> PROCEDURE arrsave
@busy_mouse
IF virtual=TRUE THEN
mbs=0
ENDIF
OPEN "O",#1,arrup$
FOR i=1 TO lmax2
PRINT #1,arrfn$(i)
PRINT #1,arrpath$(i)
PRINT #1,arrstrt(i)
PRINT #1,arrend(i)
PRINT #1,arrlen(i)
PRINT #1,arrmidi(i)
PRINT #1,arrloop(i)
PRINT #1,arrtri(i)
PRINT #1,arrsrate(i)
NEXT i
'
PRINT #1,profpath$
PRINT #1,profln
PRINT #1,profhz
PRINT #1,sblock
PRINT #1,sloop
PRINT #1,sms
PRINT #1,sme
PRINT #1,master
PRINT #1,stax
PRINT #1,stbx
PRINT #1,stcx
PRINT #1,stdx
PRINT #1,stex
PRINT #1,stfx
PRINT #1,eax
PRINT #1,ebx
PRINT #1,ecx
PRINT #1,edx
PRINT #1,eex
PRINT #1,efx
'
PRINT #1,mbs
IF mbs>0 THEN
FOR i=1 TO mbs
PRINT #1,mblocks(i)
PRINT #1,mblocke(i)
PRINT #1,mblockp$(i)
NEXT i
ENDIF
CLOSE #1
@setbutton(arrsave&,0)
RETURN
'
> PROCEDURE recplay
@setbutton(recplay&,0)
RETURN
'
> PROCEDURE mpause
@setbutton(pause&,0)
RETURN
'
> PROCEDURE mstop
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
a$=SPACE$(12)
@textfeld(playname&,a$,1)
@setbutton(stop&,0)
RETURN
'
> PROCEDURE mforw
vhz=arrsrate(pbz*4+arrz)
IF playstop=2 AND hardopen=TRUE THEN
@maschinit19
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
b=mdat%
POKE b,7
POKE b+1,4
a=XBIOS(25,1,L:b)
IF sectall>sectpos THEN
sectors=sectall-sectpos
@maschruf19
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
ENDIF
@digout(FALSE)
PAUSE 20
POKE b,7
POKE b+1,0
a=XBIOS(25,1,L:b)
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
@maschinit19
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
b=mdat%
POKE b,7
POKE b+1,4
a=XBIOS(25,1,L:b)
@maschruf19
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
@digout(FALSE)
PAUSE 20
POKE b,7
POKE b+1,0
a=XBIOS(25,1,L:b)
playstop=2
ENDIF
ELSE
@rsc_back(nr)
@rsc_draw(nr,5)
ENDIF
ENDIF
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
RETURN
'
> PROCEDURE mbackw
vhz=arrsrate(pbz*4+arrz)
IF playstop=2 AND hardopen=TRUE THEN
@maschinit20
@digout(TRUE)
@swtosrate(vhz)
b=mdat%
POKE b,7
POKE b+1,4
a=XBIOS(25,1,L:b)
IF sectpos>0 THEN
sectors=sectpos
@maschruf19
IF sectpos>0 THEN
sectpos=sectpos-back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
ENDIF
@digout(FALSE)
PAUSE 20
POKE b,7
POKE b+1,0
a=XBIOS(25,1,L:b)
ENDIF
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
RETURN
'
> PROCEDURE htimeset
hh=INT(hsec/100/60/60)
hrest=hsec-(hh*100*60*60)
hm=INT(hrest/100/60)
hrest=hrest-(hm*100*60)
hs=INT(hrest/100)
hms=hrest-(hs*100)
IF hh<10 THEN
a$="0"+STR$(hh)+":"
ELSE
a$=STR$(hh)+":"
ENDIF
IF hm<10 THEN
a$=a$+"0"+STR$(hm)+":"
ELSE
a$=a$+STR$(hm)+":"
ENDIF
IF hs<10 THEN
a$=a$+"0"+STR$(hs)+" "
ELSE
a$=a$+STR$(hs)+" "
ENDIF
IF hms<10 THEN
a$=a$+"0"+STR$(hms)+CHR$(0)
ELSE
a$=a$+STR$(hms)+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE smpedit
cs=0
ce=vmem
lz=1
ldlen=0
cutp=0
blks=0
fadericht=0
mamidi=0
admrk=ad
@rsc_back(nr)
nr=smpedit&
@rsc_draw(nr,5)
@markhlp
a$=@rsc_text$(popups&,20)
@textfeld(mover&,a$,1)
ch=1
note=60
@makehz
IF hz=32000 THEN
a$=@rsc_text$(popups&,2)
@textfeld(rate&,a$,1)
@adlow
ENDIF
IF hz=44100 THEN
a$=@rsc_text$(popups&,3)
@textfeld(rate&,a$,1)
@admid
ENDIF
IF hz=48000 THEN
a$=@rsc_text$(popups&,4)
@textfeld(rate&,a$,1)
@adhigh
ENDIF
min$=RIGHT$("00000"+STR$(min),5)
min$=min$+" MIN"+CHR$(0)
@textfeld(mintext&,min$,1)
IF sms<>0 AND sme<>0 THEN
okmark=1
ENDIF
IF lded=0 AND okmark=0 THEN
@markdel
@clsed
ELSE
IF DPEEK(datx)=&HF07E OR okmark=1 THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ELSE
@markdel
@clsed
ENDIF
'
IF lded=1 THEN
path$=pam$
ENDIF
REPEAT
g=INSTR(path$,"\")
IF g>0 THEN
path$=RIGHT$(path$,(LEN(path$)-g))
ENDIF
g2=INSTR(path$,":")
IF g2>0 THEN
path$=RIGHT$(path$,(LEN(path$)-g2))
ENDIF
UNTIL g=0 AND g2=0
mp$=path$
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
sec=INT(ln/(hz*4))+1
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
ENDIF
@curve(cs,ce)
IF (lded=1 AND DPEEK(datx)=&HF07E) OR okmark=1 THEN
@markprod3
ENDIF
REPEAT
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
IF but=22 THEN
IF obj=rate& THEN
a$=@rsc_text$(popups&,1+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@adlow
ENDIF
IF popup&=2 THEN
@admid
ENDIF
IF popup&=3 THEN
@adhigh
ENDIF
ENDIF
IF obj=mover& THEN
a$=@rsc_text$(popups&,19+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@smpmark
ENDIF
IF popup&=2 THEN
@smpzoom
ENDIF
IF popup&=3 THEN
@smpscrol
ENDIF
IF popup&=4 THEN
@smpkopie
ENDIF
IF popup&=5 THEN
@smpmove
ENDIF
IF popup&=6 THEN
@smpmerge
ENDIF
IF popup&=7 THEN
@makefade
ENDIF
IF popup&=8 THEN
@smpinsert
ENDIF
ENDIF
ENDIF
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& OR obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@setbutton(obj,1)
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
@smpl
ENDIF
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@smpr
ENDIF
IF obj=smpanf& THEN
@smpanf
ENDIF
IF obj=smpend& THEN
@smpend
ENDIF
IF obj=smpmid& THEN
@smpmid
ENDIF
IF obj=smpload& THEN
@smpload
ENDIF
IF obj=smpsta& THEN
@smpsta
ENDIF
IF obj=smpstb& THEN
@smpstb
ENDIF
IF obj=smpstc& THEN
@smpstc
ENDIF
IF obj=smpstd& THEN
@smpstd
ENDIF
IF obj=smpste& THEN
@smpste
ENDIF
IF obj=smpea& THEN
@smpea
ENDIF
IF obj=smpeb& THEN
@smpeb
ENDIF
IF obj=smpec& THEN
@smpec
ENDIF
IF obj=smped& THEN
@smped
ENDIF
IF obj=smpee& THEN
@smpee
ENDIF
IF obj=smpsave& THEN
@smpsave
ENDIF
IF obj=smpplay& THEN
@smpplay
ENDIF
IF obj=smppmark& THEN
@smppmark
ENDIF
IF obj=smploop& THEN
@smploop
ENDIF
IF obj=smpauto2& THEN
@smpauto
ENDIF
IF obj=smpstrt2& THEN
@smpstart
ENDIF
IF obj=peaksw2& THEN
@peak
ENDIF
IF obj=hard& THEN
@harddisk
ENDIF
IF obj=blkstore& THEN
@blkstore
ENDIF
IF obj=loopart& THEN
@loopwahl
ENDIF
IF obj=loopauto& THEN
@loopauto
ENDIF
IF obj=edmidi& THEN
@midi
ENDIF
IF obj=edfade& THEN
@fade
ENDIF
IF obj=midi& THEN
@machmidi
ENDIF
IF obj=smpsavl& THEN
@smpstf
ENDIF
IF obj=smpsavr& THEN
@smpef
ENDIF
IF obj=norm& THEN
@normalize
ENDIF
IF obj=resmp& THEN
@resample
ENDIF
IF obj=mono& THEN
@mono
ENDIF
IF obj=mix& THEN
@mix
ENDIF
IF obj=cut& THEN
@smpcut
ENDIF
IF obj=monitor& THEN
@monitor
ENDIF
IF obj=arrange& THEN
@arranger
ENDIF
IF obj=setuper& THEN
@setupdat
ENDIF
IF obj=infoicon& THEN
@info
ENDIF
IF obj=trash& THEN
@trash
ENDIF
IF obj=coptoarr& THEN
@copytoarr
ENDIF
IF obj=smptsa& OR obj=smptsb& OR obj=smptsc& OR obj=smptsd& OR obj=smptse& OR obj=smptsava& OR obj=smptea& OR obj=smpteb& OR obj=smptec& OR obj=smpted& OR obj=smptee& OR obj=smptsavb& THEN
@time_edit
@setbutton(obj,0)
ENDIF
IF obj=smpedhlp& THEN
@helptxt("SAMPLE-EDITOR")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj<>smpexit& THEN
obj=0
but=0
popup&=0
ENDIF
UNTIL obj=smpexit&
cached=FALSE
@setbutton(smpexit&,0)
@rsc_back(nr)
nr=smp16&
@rsc_draw(nr,7)
path$=mp$
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
@textfeld(datei&,path$,2)
ad=admrk
IF ad=0 THEN
@digital
ENDIF
IF clk=4 THEN
a$=@rsc_text$(popups&,10)
@textfeld(rate2&,a$,1)
ENDIF
IF clk=8 THEN
a$=@rsc_text$(popups&,11)
@textfeld(rate2&,a$,1)
ENDIF
IF clk=12 THEN
a$=@rsc_text$(popups&,12)
@textfeld(rate2&,a$,1)
ENDIF
obj=0
RETURN
'
> PROCEDURE time_edit
LOCAL notedok,robj
mrkobj=obj
vorvornr=vornr
vornr=nr
@rsc_back(nr)
nr=timeed&
@rsc_draw(nr,5)
@markhlp
@makehz
IF tedart=0 THEN
@setbutton(tedsec&,1)
@setbutton(tedsmp&,0)
ELSE
@setbutton(tedsmp&,1)
@setbutton(tedsec&,0)
ENDIF
IF obj=smptsa& THEN
s=stax
t=1
ENDIF
IF obj=smptsb& THEN
s=stbx
t=2
ENDIF
IF obj=smptsc& THEN
s=stcx
t=3
ENDIF
IF obj=smptsd& THEN
s=stdx
t=4
ENDIF
IF obj=smptse& THEN
s=stex
t=5
ENDIF
IF obj=smptsava& THEN
s=stfx
t=6
ENDIF
IF obj=smptea& THEN
s=eax
t=7
ENDIF
IF obj=smpteb& THEN
s=ebx
t=8
ENDIF
IF obj=smptec& THEN
s=ecx
t=9
ENDIF
IF obj=smpted& THEN
s=edx
t=10
ENDIF
IF obj=smptee& THEN
s=eex
t=11
ENDIF
IF obj=smptsavb& THEN
s=efx
t=12
ENDIF
IF s=-1 THEN
s=0
ENDIF
@tedart
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=makefsel& THEN
ENDIF
IF obj=tedhelp& THEN
@helptxt("TIME/SAMPLES-EDITING")
ENDIF
IF obj=tedsmp& THEN
vtedart=1
IF vtedart<>tedart THEN
@tedproof
IF notedok=FALSE THEN
tedart=vtedart
@tedart
ELSE
@setbutton(tedsec&,1)
@setbutton(tedsmp&,0)
ENDIF
ENDIF
ENDIF
IF obj=tedsec& THEN
vtedart=0
IF vtedart<>tedart THEN
@tedproof
IF notedok=FALSE THEN
tedart=vtedart
@tedart
ELSE
@setbutton(tedsec&,0)
@setbutton(tedsmp&,1)
ENDIF
ENDIF
ENDIF
IF obj=tedok& THEN
@tedproof
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=tedexit& OR obj=tedok& OR obj=tedhelp& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=tedexit& OR (obj=tedok& AND notedok=FALSE)
IF obj=tedok& THEN
IF t=1 THEN
stax=s
ENDIF
IF t=2 THEN
stbx=s
ENDIF
IF t=3 THEN
stcx=s
ENDIF
IF t=4 THEN
stdx=s
ENDIF
IF t=5 THEN
stex=s
ENDIF
IF t=6 THEN
stfx=s
ENDIF
IF t=7 THEN
eax=s
ENDIF
IF t=8 THEN
ebx=s
ENDIF
IF t=9 THEN
ecx=s
ENDIF
IF t=10 THEN
edx=s
ENDIF
IF t=11 THEN
eex=s
ENDIF
IF t=12 THEN
efx=s
ENDIF
ENDIF
@restaura2
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE tedart
IF tedart=0 THEN
u=s/(hz*4)
a$=STR$(u)
ELSE
u=INT(s/4)
a$=STR$(u)
ENDIF
IF LEN(a$)>8 THEN
a$=LEFT$(a$,8)
ENDIF
a$=a$+CHR$(0)
@editfeld(tedtxt&,SPACE$(8)+CHR$(0))
@editfeld(tedtxt&,a$)
RETURN
'
> PROCEDURE tedproof
@editread(tedtxt&)
notedok=FALSE
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF (a<48 OR a>57) AND a<>46 THEN
notedok=TRUE
ENDIF
IF (i=1 OR i=8) AND a=46 THEN
notedok=TRUE
ENDIF
NEXT i
ELSE
notedok=TRUE
ENDIF
IF notedok=FALSE THEN
s=VAL(a$)
IF tedart=0 THEN
s=s*hz*4
ELSE
s=s*4
ENDIF
s=INT(s/4)*4
IF s<0 OR s>vmem THEN
notedok=TRUE
ALERT 3,"Der Wert ist auûerhalb des|gÅltigen Bereichs !",1,"EXIT",g
ENDIF
ENDIF
RETURN
'
> PROCEDURE make
LOCAL mpath$,mhz,nomem,a,b,c,d,e,mrkhz,vm
mrkobj=obj
vorvornr=vornr
vornr=nr
@rsc_back(nr)
nr=arrmake&
@rsc_draw(nr,5)
@markhlp
@makehz
make$="             "
@textfeld(maketxt&,make$,1)
makename$=""
makepath$=""
mhz=2
IF hz=32000 THEN
a$=@rsc_text$(popups&,2)
@textfeld(makerate&,a$,1)
mhz=1
ENDIF
IF hz=44100 THEN
a$=@rsc_text$(popups&,3)
@textfeld(makerate&,a$,1)
mhz=2
ENDIF
IF hz=48000 THEN
a$=@rsc_text$(popups&,4)
@textfeld(makerate&,a$,1)
mhz=3
ENDIF
@swtosrate(hz)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
IF but=24 THEN
IF obj=makerate& THEN
a$=@rsc_text$(popups&,1+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
mhz=1
@adlow
ENDIF
IF popup&=2 THEN
mhz=2
@admid
ENDIF
IF popup&=3 THEN
mhz=3
@adhigh
ENDIF
ENDIF
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=makefsel& THEN
mpath$=path$
@fileselect(op$+"*."+ext$,"","MAKEFILE:")
vext$=ext$
IF vext$="*" THEN
vext$="SMP"
ENDIF
IF INSTR(path$,".")=0 THEN
path$=path$+"."+vext$
ENDIF
makepath$=path$
path$=mpath$
IF makepath$<>"" AND RIGHT$(makepath$,1)<>"\" AND pret<>0 AND pbutt=1 THEN
makename$=makepath$
REPEAT
g=INSTR(makename$,"\")
IF g>0 THEN
makename$=RIGHT$(makename$,(LEN(makename$)-g))
ENDIF
g2=INSTR(makename$,":")
IF g2>0 THEN
makename$=RIGHT$(makename$,(LEN(makename$)-g2))
ENDIF
UNTIL g=0 AND g2=0
mname$=SPACE$(6)+makename$+SPACE$(6)
mname$=MID$(mname$,INT(LEN(mname$)/2)-5,12)+CHR$(0)
@textfeld(maketxt&,mname$,1)
ENDIF
ENDIF
IF obj=makehelp& THEN
@helptxt("MAKE")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=makeok& OR obj=makexit& OR obj=makefsel& OR obj=makehelp& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=makexit& OR (obj=makeok& AND makepath$<>"" AND makename$<>"")
IF obj=makeok& THEN
IF mhz=1 THEN
mhz=32000
ENDIF
IF mhz=2 THEN
mhz=44100
ENDIF
IF mhz=3 THEN
mhz=48000
ENDIF
' makepath$,mhz
'
b=0
nomem=FALSE
@busy_mouse
FOR i=1 TO lmax2
e=0
IF arrpath$(i)<>"" AND arrpath$(i)<>"MEMORY" AND arrpath$(i)<>"DELAY" THEN
e=(arrend(i)-arrstrt(i))*flen
IF arrtri(i)=2 THEN
e=e+(arrend(i)-arrstrt(i))*flen
ENDIF
nomem=TRUE
ENDIF
IF arrpath$(i)="DELAY" THEN
e=INT(arrend(i)/100*60*mhz)*4
nomem=TRUE
ENDIF
IF arrpath$(i)="MEMORY" THEN
e=(arrend(i)-arrstrt(i))
IF arrtri(i)=2 THEN
e=e+(arrend(i)-arrstrt(i))
ENDIF
ENDIF
IF arrsrate(i)<>mhz AND arrpath$(i)<>"" AND arrpath$(i)<>"DELAY" THEN
nomem=TRUE
mrkhz=arrsrate(i)
e=e/mrkhz*mhz
ENDIF
b=b+e
NEXT i
@busy_mouse
a=ASC(LEFT$(makepath$,1))-64
IF DFREE(a)>=b THEN
okay=TRUE
ENDIF
IF nomem=TRUE AND okay=TRUE THEN
a2=ASC(LEFT$(virt$,1))-64
c=mlen
IF a=a2 THEN
c=mlen+b
ENDIF
IF DFREE(a2)>=c THEN
okay=TRUE
ELSE
okay=FALSE
ENDIF
BSAVE virt$,meml,mlen
ENDIF
IF okay=TRUE THEN
OPEN "O",#1,makepath$
FOR i=1 TO lmax2
@busy_mouse
a$=arrpath$(i)
'
IF a$<>"" AND a$<>"MEMORY" AND a$<>"DELAY" THEN
OPEN "I",#2,a$
IF arrtri(i)=0 OR arrtri(i)=2 THEN
vln=(arrend(i)-arrstrt(i))*flen
anf=arrstrt(i)*flen
SEEK #2,anf
bytes=INT(mlen/4)*4
IF arrsrate(i)<>mhz THEN
@arr_resmp
ELSE
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #2,meml,bytes
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #2,meml,vln
BPUT #1,meml,vln
ENDIF
ENDIF
ENDIF
IF arrtri(i)=1 OR arrtri(i)=2 THEN
@maschinit29
vln=(arrend(i)-arrstrt(i))
bytes=INT(mlen/8)*4
len=INT(bytes/flen)
start=arrend(i)*flen
IF arrsrate(i)<>mhz THEN
CLOSE #1
a=ASC(LEFT$(makepath$,1))-64
IF DFREE(a)>=vln THEN
virtp$=CHR$(a+64)+":\"+virtfile$
OPEN "O",#1,virtp$
ELSE
okay=FALSE
ENDIF
ENDIF
IF okay=TRUE THEN
REPEAT
IF vln<len THEN
len=vln
ENDIF
start=start-len*flen
SEEK #2,start
BGET #2,meml,len*flen
@maschruf29(meml,meml+len*flen)
BPUT #1,meml+len*flen,len*flen
vln=vln-len
UNTIL vln<1
IF arrsrate(i)<>mhz THEN
CLOSE #1
CLOSE #2
OPEN "U",#1,makepath$
SEEK #1,LOF(#1)
OPEN "I",#2,virtp$
vln=LOF(#2)
anf=0
bytes=INT(mlen/4)*4
@arr_resmp
ENDIF
ENDIF
ENDIF
CLOSE #2
IF arrsrate(i)<>mhz AND (arrtri(i)=1 OR arrtri(i)=2) AND okay=TRUE THEN
KILL virtp$
ENDIF
ENDIF
'
IF a$="DELAY" THEN
vln=INT(arrend(i)/100*mhz)*4
bytes=INT(mlen/4)*4
@maschinit9
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
@maschruf9(meml,meml+bytes)
bytes=INT(mlen/4)*4
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BPUT #1,meml,vln
ENDIF
ENDIF
'
IF a$="MEMORY" THEN
IF arrtri(i)=0 OR arrtri(i)=2 THEN
a$=virt$
OPEN "I",#2,a$
len=LOF(#2)
vln=(arrend(i)-arrstrt(i))
vln=INT(vln/4)*4
anf=arrstrt(i)
SEEK #2,anf
bytes=INT(mlen/4)*4
IF arrsrate(i)<>mhz THEN
@arr_resmp
ELSE
IF nomem=TRUE THEN
SEEK #2,0
BGET #2,meml,len
ENDIF
BPUT #1,meml+arrstrt(i),vln
ENDIF
CLOSE #2
ENDIF
IF arrtri(i)=1 OR arrtri(i)=2 THEN
OPEN "I",#2,virt$
@maschinit29
vln=(arrend(i)-arrstrt(i))
bytes=INT(mlen/8)*4
start=arrend(i)
'
IF arrsrate(i)<>mhz THEN
CLOSE #1
a=ASC(LEFT$(makepath$,1))-64
IF DFREE(a)>=vln THEN
virtp$=CHR$(a+64)+":\"+virtfile$
OPEN "O",#1,virtp$
ELSE
okay=FALSE
ENDIF
ENDIF
IF okay=TRUE THEN
REPEAT
IF vln<bytes THEN
bytes=vln
ENDIF
start=start-bytes
SEEK #2,start
BGET #2,meml,bytes
@maschruf29(meml,meml+bytes)
BPUT #1,meml+bytes,bytes
vln=vln-bytes
UNTIL vln<1
IF arrsrate(i)<>mhz THEN
CLOSE #1
CLOSE #2
OPEN "U",#1,makepath$
SEEK #1,LOF(#1)
OPEN "I",#2,virtp$
vln=LOF(#2)
anf=0
bytes=INT(mlen/4)*4
@arr_resmp
ENDIF
ENDIF
CLOSE #2
IF arrsrate(i)<>mhz AND (arrtri(i)=1 OR arrtri(i)=2) AND okay=TRUE THEN
KILL virtp$
ENDIF
ENDIF
ENDIF
'
NEXT i
CLOSE #1
IF nomem=TRUE AND EXIST(virt$)=TRUE THEN
BLOAD virt$,meml
KILL virt$
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF okay=FALSE AND obj<>makexit& THEN
@nomem
ENDIF
ENDIF
@restaura2
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE arr_resmp
@maschinit16
f=INT(mhz/100)
e=INT(arrsrate(i)/100)
bedarf=f/e
okay=FALSE
drittel=(memh-meml)/(e+f)*e
drittel=INT(drittel/4)*4
IF drittel>15 THEN
drittel=drittel-8
ENDIF
a=ASC(LEFT$(makepath$,1))-64
IF DFREE(a)>=vln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
seekz=anf
REPEAT
IF vln>=bytes THEN
IF bedarf<=1 THEN
bytes=INT(mlen/4)*4
ELSE
bytes=drittel
ENDIF
ELSE
bytes=INT(vln/4)*4
ENDIF
SEEK #2,seekz
IF bytes>3 THEN
BGET #2,meml,bytes
a=meml
b=meml+bytes
IF bedarf<=1 THEN
c=meml
ELSE
c=meml+bytes
ENDIF
d=memh
@maschruf16(a,b,c,d,e,f)
back%=INT(back%/4)*4
BPUT #1,c,back%-c
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
ENDIF
RETURN
'
> PROCEDURE info
vornr=nr
@rsc_back(nr)
nr=info&
@rsc_draw(nr,5)
@markhlp
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,v3,v4)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=helpinfo& THEN
@helptxt("INFO")
ENDIF
UNTIL obj=infoexit&
@setbutton(obj,0)
@restaura2
obj=0
@setbutton(infoicon&,0)
RETURN
'
> PROCEDURE rebuild
IF nr=smpedit& THEN
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
sec=INT(ln/(hz*4))+1
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
IF hz=32000 THEN
a$=@rsc_text$(popups&,2)
@textfeld(rate&,a$,1)
@adlow
ENDIF
IF hz=44100 THEN
a$=@rsc_text$(popups&,3)
@textfeld(rate&,a$,1)
@admid
ENDIF
IF hz=48000 THEN
a$=@rsc_text$(popups&,4)
@textfeld(rate&,a$,1)
@adhigh
ENDIF
ENDIF
RETURN
'
> PROCEDURE trash
@rsc_back(nr)
@rsc_draw(nr,5)
mbs=0
IF virtual=FALSE AND rett=TRUE THEN
@getmem
rett=FALSE
ENDIF
IF virtual=TRUE THEN
op$=rop$
virtual=FALSE
virtcurve=FALSE
virtld=FALSE
blockld=FALSE
cached=FALSE
@markhlp
maxcwert=0
ce=mlen
cs=0
vmem=INT(mlen-1)
@markdel
@clsed
@busy_mouse
@getmem
mbs=vmbs
IF hz=0 THEN
@makehz
ENDIF
IF ln=0 THEN
ln=mlen
ENDIF
IF mp$="" THEN
mp$="MEMORY."+ext$
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
hrd=0
IF nr=smpedit& THEN
@setbutton(hard&,0)
ENDIF
path$=mp$
@rebuild
ELSE
cached=FALSE
@markhlp
@blocklook
@maschinit9
IF sblock=1 AND sms>0 AND sme>0 AND c2>c1 AND xm>0 THEN
@maschruf9(mcs,mce)   ! Delete Memory
ELSE
@maschruf9(meml,memh)   ! Delete Memory
@clsed
FOR i=1 TO lmax2
IF arrpath$(i)="MEMORY" THEN
arrfn$(i)=""
arrpath$(i)=""
arrstrt(i)=0
arrend(i)=0
arrlen(i)=0
arrloop(i)=0
arrtri(i)=0
ENDIF
NEXT i
@markdel
@rebuild
ENDIF
ENDIF
lz=1
@restaura
@setbutton(trash&,0)
RETURN
'
> PROCEDURE setupdat
vornr=nr
@rsc_back(nr)
nr=setup&
@rsc_draw(nr,5)
@markhlp
@setdat
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,v3,v4)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=sync& THEN
@sync
ENDIF
IF obj=fseldef& THEN
@fseldef
ENDIF
IF obj=secl& OR obj=secr& THEN
@secbutt
ENDIF
IF obj=dreide& THEN
@dreide
ENDIF
IF obj=grid& THEN
@grid
ENDIF
IF obj=sram& THEN
@sram
ENDIF
IF obj=mallmax& THEN
@mallmax
ENDIF
IF obj=recl& OR obj=recr& THEN
@recbutt
ENDIF
IF obj=tresl& OR obj=tresr& THEN
@tresbutt
ENDIF
IF obj=setsave& THEN
@setsave
ENDIF
IF obj=setload& THEN
@setload
@setdat
ENDIF
IF obj=wavset& OR obj=avrset& OR obj=sndset& OR obj=auset& OR obj=smpset& OR obj=allset& THEN
@extender
ENDIF
IF obj=sethelp& THEN
@helptxt("SETUP")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
UNTIL obj=setexit& OR obj=setok&
IF obj=setok& THEN
@editread(lenmall&)
a$="&H"+a$
memmx=VAL(a$)
digana=vdigana
op$=vop$
flen=vflen
sramda=vsramda
min=vmin
mallmax=vmallmax
th=vth
dreidim=vdreidim
grids=vgrid
ext$=vext$
ENDIF
@setbutton(obj,0)
@restaura2
obj=0
@setbutton(setuper&,0)
RETURN
'
> PROCEDURE extender
IF obj=avrset& THEN
vext$="AVR"
ENDIF
IF obj=sndset& THEN
vext$="SND"
ENDIF
IF obj=auset& THEN
vext$="AU"
ENDIF
IF obj=smpset& THEN
vext$="SMP"
ENDIF
IF obj=allset& THEN
vext$="*"
ENDIF
IF obj=wavset& THEN
vext$="WAV"
ENDIF
RETURN
'
> PROCEDURE setload
IF EXIST(setup$) THEN
@busy_mouse
OPEN "I",#1,setup$
INPUT #1,memmx
INPUT #1,digana
INPUT #1,op$
INPUT #1,flen
INPUT #1,sramda
INPUT #1,min
INPUT #1,mallmax
INPUT #1,th
INPUT #1,dreidim
INPUT #1,grids
INPUT #1,ext$
CLOSE #1
ELSE
memmx=&H100000         ! Wenn mallmax=FALSE,dann memmx-Speicher anfordern
digana=TRUE            ! wenn TRUE, dann DIGITAL->ANALOG-Umschaltung bei Wiedergabe
op$=lfw$              ! Default-Zugriffspfad
flen=&H2000            ! SektorlÑnge
sramda=FALSE           ! wenn TRUE, dann SRAM vorhanden
mallmax=TRUE           ! TRUE, wenn maximalen Speicher anfordern
th=257                 ! Schwelle fÅr AUTO-RECORD
min=4                  ! RECORD-Aufnahmezeit in Minuten
ext$="SMP"
dreidim=1
grids=1
ENDIF
rop$=op$
IF obj=setload& AND nr=setup& THEN
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE setdat
~GRAF_MOUSE(256,0)                              ! Hidem
vdigana=digana
vop$=op$
vflen=flen
vsramda=sramda
vmin=min
vmallmax=mallmax
vth=th
vdreidim=dreidim
vgrid=grids
vext$=ext$
IF LEN(op$)>57 THEN
oop$=RIGHT$(op$,57)
a=INSTR(oop$,"\")
oop$=RIGHT$(oop$,LEN(oop$)-(a-1))
ELSE
oop$=op$
ENDIF
@textfeld(fseltxt&,oop$+CHR$(0),1)
f$=RIGHT$(SPACE$(5)+STR$(flen),5)+CHR$(0)
@textfeld(seclen&,f$,1)
f$=RIGHT$(SPACE$(5)+STR$(min),5)+CHR$(0)
@textfeld(recm&,f$,1)
tdb=th
tdb=20*LOG10(tdb)
tdb=tdb-aufloes
tdb=INT(tdb*1000)/1000
tdb$=STR$(tdb)+CHR$(0)
@textfeld(tresdb&,tdb$,1)
IF ext$="AVR" THEN
@setbutton(avrset&,1)
ELSE
@setbutton(avrset&,0)
ENDIF
IF ext$="SND" THEN
@setbutton(sndset&,1)
ELSE
@setbutton(sndset&,0)
ENDIF
IF ext$="AU" THEN
@setbutton(auset&,1)
ELSE
@setbutton(auset&,0)
ENDIF
IF ext$="SMP" THEN
@setbutton(smpset&,1)
ELSE
@setbutton(smpset&,0)
ENDIF
IF ext$="WAV" THEN
@setbutton(wavset&,1)
ELSE
@setbutton(wavset&,0)
ENDIF
IF ext$="*" THEN
@setbutton(allset&,1)
ELSE
@setbutton(allset&,0)
ENDIF
IF digana=FALSE THEN
@setbutton(sync&,1)
ELSE
@setbutton(sync&,0)
ENDIF
IF dreidim=1 THEN
@setbutton(dreide&,1)
ELSE
@setbutton(dreide&,0)
ENDIF
IF grids=1 THEN
@setbutton(grid&,1)
ELSE
@setbutton(grid&,0)
ENDIF
IF sramda=TRUE THEN
@setbutton(sram&,1)
ELSE
@setbutton(sram&,0)
ENDIF
IF mallmax=FALSE THEN
@setbutton(mallmax&,1)
ELSE
@setbutton(mallmax&,0)
ENDIF
a$=HEX$(memmx)+CHR$(0)
@editfeld(lenmall&,a$)
~GRAF_MOUSE(257,0)                              ! Hidem
RETURN
'
> PROCEDURE setsave
@busy_mouse
@editread(lenmall&)
a$="&H"+a$
memmx=VAL(a$)
OPEN "O",#1,setup$
PRINT #1,memmx
PRINT #1,vdigana
PRINT #1,vop$
PRINT #1,vflen
PRINT #1,vsramda
PRINT #1,vmin
PRINT #1,vmallmax
PRINT #1,vth
PRINT #1,vdreidim
PRINT #1,vgrid
PRINT #1,vext$
CLOSE #1
@setbutton(obj,0)
RETURN
'
> PROCEDURE sync
IF vdigana=TRUE THEN
vdigana=FALSE
ELSE
vdigana=TRUE
ENDIF
RETURN
'
> PROCEDURE dreide
IF vdreidim=1 THEN
vdreidim=0
ELSE
vdreidim=1
ENDIF
RETURN
'
> PROCEDURE grid
IF vgrid=1 THEN
vgrid=0
ELSE
vgrid=1
ENDIF
RETURN
'
> PROCEDURE fseldef
@fileselect(vop$+"*."+ext$,"","PATH:")
@busy_mouse
IF ordner$<>"" AND pret<>0 AND pbutt=1 THEN
vop$=ordner$
IF LEN(vop$)>57 THEN
oop$=RIGHT$(vop$,57)
a=INSTR(oop$,"\")
oop$=RIGHT$(oop$,LEN(oop$)-(a-1))
ELSE
oop$=vop$
ENDIF
@textfeld(fseltxt&,oop$+CHR$(0),1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE secbutt
IF obj=secl& AND vflen>511 THEN
vflen=vflen/2
ENDIF
IF obj=secr& AND vflen<32768 THEN
vflen=vflen*2
ENDIF
f$=RIGHT$(SPACE$(5)+STR$(vflen),5)+CHR$(0)
@textfeld(seclen&,f$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE sram
IF vsramda=FALSE THEN
vsramda=TRUE
ELSE
vsramda=FALSE
ENDIF
RETURN
'
> PROCEDURE recbutt
IF obj=recl& AND vmin>1 THEN
DEC vmin
ENDIF
IF obj=recr& AND vmin<100 THEN
INC vmin
ENDIF
f$=RIGHT$(SPACE$(5)+STR$(vmin),5)+CHR$(0)
@textfeld(recm&,f$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE mallmax
IF vmallmax=TRUE THEN
vmallmax=FALSE
ELSE
vmallmax=TRUE
ENDIF
RETURN
'
> PROCEDURE tresbutt
IF obj=tresl& AND vth>199 THEN
vth=vth-100
ENDIF
IF obj=tresr& AND vth<32668 THEN
vth=vth+100
ENDIF
tdb=vth
tdb=20*LOG10(tdb)
tdb=tdb-aufloes
tdb=INT(tdb*1000)/1000
tdb$=STR$(tdb)+CHR$(0)
@textfeld(tresdb&,tdb$,1)
setbutton(obj,0)
RETURN
'
> PROCEDURE timecorr
IF stax<>-1 THEN
@markhlp3(stax,smptsa&)
ENDIF
IF stbx<>-1 THEN
@markhlp3(stbx,smptsb&)
ENDIF
IF stcx<>-1 THEN
@markhlp3(stcx,smptsc&)
ENDIF
IF stdx<>-1 THEN
@markhlp3(stdx,smptsd&)
ENDIF
IF stex<>-1 THEN
@markhlp3(stex,smptse&)
ENDIF
IF stfx<>-1 THEN
@markhlp3(stfx,smptsava&)
ENDIF
IF eax<>-1 THEN
@markhlp3(eax,smptea&)
ENDIF
IF ebx<>-1 THEN
@markhlp3(ebx,smpteb&)
ENDIF
IF ecx<>-1 THEN
@markhlp3(ecx,smptec&)
ENDIF
IF edx<>-1 THEN
@markhlp3(edx,smpted&)
ENDIF
IF eex<>-1 THEN
@markhlp3(eex,smptee&)
ENDIF
IF efx<>-1 THEN
@markhlp3(efx,smptsavb&)
ENDIF
RETURN
'
> PROCEDURE markdel
ln=vmem
sec=INT(ln/(hz*4))+1
stax=-1
stbx=-1
stcx=-1
stdx=-1
stex=-1
stfx=-1
eax=-1
ebx=-1
ecx=-1
edx=-1
eex=-1
efx=-1
smark=3
IF nr=smpedit& THEN
a$=@rsc_text$(popups&,20)
@textfeld(mover&,a$,1)
ENDIF
master=0
path$=mp$
IF nr=smpedit& THEN
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
ENDIF
IF nr=smp16& THEN
mp$=path$
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
@textfeld(datei&,path$,2)
ENDIF
RETURN
'
> PROCEDURE smpsta
sms=1
t$="A"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=1
masthlp=hacksa&
@textfeld(hacksa&,""+CHR$(0),1)
IF stax=-1 THEN
@markhlp
stax=0
@markhlp2
@markhlp3(stax,smptsa&)
ELSE
@markhlp4(stax)
ENDIF
RETURN
'
> PROCEDURE smpstb
sms=2
t$="B"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=2
masthlp=hacksb&
@textfeld(hacksb&,""+CHR$(0),1)
IF stbx=-1 THEN
@markhlp
stbx=0
@markhlp2
@markhlp3(stbx,smptsb&)
ELSE
@markhlp4(stbx)
ENDIF
RETURN
'
> PROCEDURE smpstc
sms=3
t$="C"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=3
masthlp=hacksc&
@textfeld(hacksc&,""+CHR$(0),1)
IF stcx=-1 THEN
@markhlp
stcx=0
@markhlp2
@markhlp3(stcx,smptsc&)
ELSE
@markhlp4(stcx)
ENDIF
RETURN
'
> PROCEDURE smpstd
sms=4
t$="D"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=4
masthlp=hacksd&
@textfeld(hacksd&,""+CHR$(0),1)
IF stdx=-1 THEN
@markhlp
stdx=0
@markhlp2
@markhlp3(stdx,smptsd&)
ELSE
@markhlp4(stdx)
ENDIF
RETURN
'
> PROCEDURE smpste
sms=5
t$="E"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=5
masthlp=hackse&
@textfeld(hackse&,""+CHR$(0),1)
IF stex=-1 THEN
@markhlp
stex=0
@markhlp2
@markhlp3(stex,smptse&)
ELSE
@markhlp4(stex)
ENDIF
RETURN
'
> PROCEDURE smpstf
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
@setbutton(smpsavl&,0)
t$="S"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
IF sms<6 THEN
msms=sms
ENDIF
sms=6
master=11
masthlp=hackss&
@textfeld(hackss&,""+CHR$(0),1)
IF stfx=-1 THEN
@markhlp
stfx=0
@markhlp2
@markhlp3(stfx,smptsava&)
ELSE
@markhlp4(stfx)
ENDIF
RETURN
'
> PROCEDURE smpea
sme=1
t$="A"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=6
masthlp=hackea&
@textfeld(hackea&,""+CHR$(0),1)
IF eax=-1 THEN
@markhlp
eax=0
@markhlp2
@markhlp3(eax,smptea&)
ELSE
@markhlp4(eax)
ENDIF
RETURN
'
> PROCEDURE smpeb
sme=2
t$="B"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=7
masthlp=hackeb&
@textfeld(hackeb&,""+CHR$(0),1)
IF ebx=-1 THEN
@markhlp
ebx=0
@markhlp2
@markhlp3(ebx,smpteb&)
ELSE
@markhlp4(ebx)
ENDIF
RETURN
'
> PROCEDURE smpec
sme=3
t$="C"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=8
masthlp=hackec&
@textfeld(hackec&,""+CHR$(0),1)
IF ecx=-1 THEN
@markhlp
ecx=0
@markhlp2
@markhlp3(ecx,smptec&)
ELSE
@markhlp4(ecx)
ENDIF
RETURN
'
> PROCEDURE smped
sme=4
t$="D"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=9
masthlp=hacked&
@textfeld(hacked&,""+CHR$(0),1)
IF edx=-1 THEN
@markhlp
edx=0
@markhlp2
@markhlp3(edx,smpted&)
ELSE
@markhlp4(edx)
ENDIF
RETURN
'
> PROCEDURE smpee
sme=5
t$="E"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=10
masthlp=hackee&
@textfeld(hackee&,""+CHR$(0),1)
IF eex=-1 THEN
@markhlp
eex=0
@markhlp2
@markhlp3(eex,smptee&)
ELSE
@markhlp4(eex)
ENDIF
RETURN
'
> PROCEDURE smpef
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
@setbutton(smpsavr&,0)
t$="S"
IF master<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
IF sme<6 THEN
msme=sme
ENDIF
sme=6
master=12
masthlp=hackes&
@textfeld(hackes&,""+CHR$(0),1)
IF efx=-1 THEN
@markhlp
efx=0
@markhlp2
@markhlp3(efx,smptsavb&)
ELSE
@markhlp4(efx)
ENDIF
RETURN
'
> PROCEDURE smph1
IF master=1 THEN
x=stax
ENDIF
IF master=2 THEN
x=stbx
ENDIF
IF master=3 THEN
x=stcx
ENDIF
IF master=4 THEN
x=stdx
ENDIF
IF master=5 THEN
x=stex
ENDIF
IF master=6 THEN
x=eax
ENDIF
IF master=7 THEN
x=ebx
ENDIF
IF master=8 THEN
x=ecx
ENDIF
IF master=9 THEN
x=edx
ENDIF
IF master=10 THEN
x=eex
ENDIF
IF master=11 THEN
x=stfx
ENDIF
IF master=12 THEN
x=efx
ENDIF
RETURN
'
> PROCEDURE markhlp4(bx)
LOCAL cx
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
LINE cx+xd,stay1,cx+xd,stay2
LINE cx+xd,stay1,cx+xd,stay2
GRAPHMODE 1
TEXT cx+xd-3,yd+21,t$
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE markhlp6(bx)
LOCAL cx
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
LINE cx+xd,stay1,cx+xd,stay2
GRAPHMODE 1
TEXT cx+xd-3,yd+22,t$
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE markhlp5(bx)
LOCAL cx
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
LINE cx+xd,stay1,cx+xd,stay2
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE setup
rett=FALSE
cached=FALSE
away=FALSE
virtual=FALSE
virtwfile=FALSE
virtld=FALSE
makevirt3=FALSE
makevirt2=FALSE
makevirt=FALSE
blockld=FALSE
deltime=0
spc=3
vcs=0
vce=0
aufloes=90.3           ! dB-Aufloesung der Wandler (16Bit)
lmax=100               ! Feldgrîûe fÅr SCROLL
lmax2=100              ! Feldgrîûe fÅr ARRANGER
lmax3=100              ! Feldgrîûe fÅr loaded Blockanfang und Ende
recfifolen=&H2000      ! Grîûe des RECORD-FIFO
playfifolen=&H2000     ! Grîûe des PLAY-FIFO
sram=&H900000          ! Anfang des SRAM
mdat%=MALLOC(50000)    ! Buffer fÅr HARD-REC/PLAY-Buffer und anderes
mdat2%=MALLOC(2000)    ! Buffer fÅr Assembler-Code
tedart=1               ! Darstellung der Blockmarken in Sekunden oder in Samples im SMP-Editor
mdatf=mdat%
mdatf2=mdat2%
IF mdat%=0 OR mdat2%=0 THEN
away=TRUE
ELSE
mdat%=INT(mdat%/2)*2+2
mdat2%=INT(mdat2%/2)*2+2
mdat3%=mdat2%+1000
gohome=FALSE
@makehz
adr=&HDF0401
mtst=MALLOC(-1)
IF mallmax=FALSE AND mtst>=memmx AND memmx<>0 THEN
mtst=memmx
ENDIF
IF mtst>&H110000 THEN
mtst=INT((mtst-&H70000)/4)*4
manf=MALLOC(mtst)
merkfrei=manf
IF manf>0 THEN
manf=INT(manf/4)*4+4
meml=manf
memh=meml+mtst-4
mlen=mtst-8
big=1
ELSE
IF sramda=TRUE THEN
meml=sram
memh=sram+&H100000-4
mlen=&H100000
big=0
ELSE
mtst=MALLOC(-1)
manf=MALLOC(mtst)
merkfrei=manf
IF manf>0 THEN
manf=INT(manf/4)*4+4
meml=manf
memh=meml+mtst-4
mlen=mtst-8
big=1
ELSE
ALERT 3,"Zu wenig freier Speicher !",1,"EXIT",g
gohome=TRUE
ENDIF
ENDIF
ENDIF
ELSE
IF sramda=TRUE THEN
meml=sram
memh=sram+&H100000-4
mlen=&H100000
big=0
ELSE
mtst=MALLOC(-1)
IF mallmax=FALSE AND mtst>=memmx AND memmx<>0 THEN
mtst=memmx
ENDIF
manf=MALLOC(mtst)
merkfrei=manf
IF manf>0 THEN
manf=INT(manf/4)*4+4
meml=manf
memh=meml+mtst-4
mlen=mtst-8
big=1
ELSE
ALERT 3,"Zu wenig freier Speicher !",1,"EXIT",g
gohome=TRUE
ENDIF
ENDIF
ENDIF
IF gohome=FALSE THEN
dat=((INT(anfload/2))*2)+2
cs=0
ce=mlen-1
vmem=INT(mlen-1)
DIM ls(lmax)
DIM le(lmax)
DIM lcs(lmax)
DIM lce(lmax)
DIM arrfn$(lmax2)
DIM arrpath$(lmax2)
DIM arrstrt(lmax2)
DIM arrend(lmax2)
DIM arrlen(lmax2)
DIM arrmidi(lmax2)
DIM arrloop(lmax2)
DIM arrtri(lmax2)
DIM arrsrate(lmax2)
@markhlp
DIM cache1(xm+100)
DIM cache2(xm+100)
'      DIM cwerte(10000)
DIM mblocks(lmax3)
DIM mblocke(lmax3)
DIM mblockp$(lmax3)
cwerte1=0
mbs=0
n=60
FOR i=1 TO lmax2
arrmidi(i)=n
INC n
IF n>127 THEN
n=0
ENDIF
NEXT i
fadnr=246
DIM fadeni(fadnr)
DIM fadeno(fadnr)
lz=1
ln=mlen
@makehz
sec=INT(ln/(hz*4))+1
ext2$=ext$
IF ext2$="*" THEN
ext2$="SMP"
ENDIF
path$="MEMORY."+ext2$
mp$=path$
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
~WIND_GET(mrkhandle,10,mrkhandle2,v1,v2,v3)
@textfeld(datei&,path$,2)
mem$=RIGHT$("00000000"+STR$(ln),8)
@textfeld(memused&,mem$,2)
@maschinit9
@maschruf9(meml,memh)
nr=smp16&
retime=0
ad=0
xmp=0
okmark=0
merkerr=0
merkfreq=0
a$=@rsc_text$(popups&,15)
@textfeld(input&,a$,1)
a$=@rsc_text$(popups&,17)
@textfeld(source&,a$,1)
a$=@rsc_text$(popups&,11)
@textfeld(rate2&,a$,1)
a$=@rsc_text$(popups&,6)
@textfeld(dsp&,a$,1)
protnr=0
locknr=0
lded=0
hrd=0
merk1=0
merk2=0
merk3=0
merk4=0
merkc=-1
stl=0
clk=8
sth=0
std=0
@write_reglow(stl)
@write_reghigh(sth)
@write_dsp(std)
ENDIF
ENDIF
RETURN
'
> PROCEDURE aufbau
IF (stl AND 2)=0 THEN
@setbutton(opto&,1)
ELSE
@setbutton(coax&,1)
ENDIF
IF locknr=1 THEN
@setbutton(lock&,1)
ENDIF
IF protnr=1 THEN
@setbutton(protect&,1)
ENDIF
IF clk=4 THEN
@setbutton(ad32&,1)
ENDIF
IF clk=8 THEN
@setbutton(ad44&,1)
ENDIF
IF clk=12 THEN
@setbutton(ad48&,1)
ENDIF
IF ad=0 THEN
@setbutton(digital&,1)
ELSE
@setbutton(analog&,1)
ENDIF
RETURN
'
> PROCEDURE mix
makevirt3=FALSE
vornr=nr
@rsc_back(nr)
nr=concat&
@rsc_draw(nr,5)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
PAUSE 2
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=helpcon& THEN
@helptxt("CONCAT")
ENDIF
UNTIL obj=conexit& OR obj=conins& OR obj=conmix& OR obj=conspace&
@setbutton(obj,0)
IF obj=conins& THEN
@coninsert
ENDIF
IF obj=conmix& THEN
@conmix
cached=FALSE
ENDIF
IF obj=conspace& THEN
@conspace
cached=FALSE
ENDIF
@restaura2
obj=0
@setbutton(mix&,0)
RETURN
'
> PROCEDURE conmix
RETURN
'
> PROCEDURE conspace
@markhlp
@rsc_back(concat&)
nr=space&
@rsc_draw(nr,5)
@markhlp
spc$=RIGHT$("00000"+STR$(spc),5)+CHR$(0)
@textfeld(spacetxt&,spc$,1)
oldspc=spc
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
PAUSE 2
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=hlpspace& THEN
@helptxt("SPACE")
ENDIF
UNTIL obj=exspace& OR obj=okspace& OR obj=spacel1& OR obj=spacel2& OR obj=spacer1& OR obj=spacer2&
IF obj=spacer1& OR obj=spacer2& THEN
IF obj=spacer1& AND spc<9999 THEN
spc=spc+1
ENDIF
IF obj=spacer2& AND min<9995 THEN
spc=spc+5
ENDIF
spc$=RIGHT$("00000"+STR$(spc),5)+CHR$(0)
@textfeld(spacetxt&,spc$,1)
ENDIF
IF obj=spacel1& OR obj=spacel2& THEN
IF obj=spacel1& AND spc>1 THEN
spc=spc-1
ENDIF
IF obj=spacel2& AND spc>5 THEN
spc=spc-5
ENDIF
spc$=RIGHT$("00000"+STR$(spc),5)+CHR$(0)
@textfeld(spacetxt&,spc$,1)
ENDIF
@setbutton(obj,0)
UNTIL obj=exspace& OR obj=okspace&
IF obj=exspace& THEN
spc=oldspc
ENDIF
IF obj=okspace& THEN
IF sblock=1 THEN
@blkltest
ELSE
IF virtual=TRUE THEN
conc=virtln
ELSE
conc=mlen
ENDIF
ENDIF
@makehz
df=spc*hz*4
IF virtual=FALSE THEN
inspace=TRUE
@coninsert
inspace=FALSE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF virtwfile=FALSE AND conc=virtln AND df>0 THEN
IF DFREE(a)>=df THEN
OPEN "U",#1,virtpath$
a=RINSTR(virtpath$,"\")
SEEK #1,virtln
bytes=INT(mlen/4)*4
vln=INT(df/4)*4
@maschinit9
IF df>mlen THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+df)
ENDIF
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
IF (virtwfile=TRUE OR (conc<virtln AND virtwfile=FALSE)) AND df>0 THEN
inspace=TRUE
@coninsert
inspace=FALSE
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE coninsert
LOCAL rp$,okay,okay2
makevirt=FALSE
makevirt2=FALSE
okay=FALSE
okay2=FALSE
IF inspace=FALSE THEN
opath$=path$
oldpath2$=oldp$
@fileselect(op$+"*."+ext$,mp$,"INSERT:")
rp$=path$
path$=opath$
@rsc_back(nr)
@rsc_draw(nr,5)
IF EXIST(rp$) AND pbutt=1 THEN
OPEN "I",#1,rp$
df=LOF(#1)
CLOSE #1
okay2=TRUE
ELSE
okay2=FALSE
ENDIF
IF sblock=1 THEN
@blkltest
ELSE
IF virtual=TRUE THEN
conc=virtln
ELSE
conc=mlen
ENDIF
ENDIF
ELSE
rp$=oldp$
okay2=TRUE
ENDIF
IF virtual=FALSE AND okay2=TRUE AND df>0 THEN
IF sblock=1 AND conc+df<=mlen AND stfx>=0 AND efx>0 AND (efx+df)<=mlen THEN
IF conc<efx THEN
BMOVE meml+conc,meml+conc+df,efx-conc
ENDIF
vln=INT(df/4)*4
conc=INT(conc/4)*4
IF inspace=FALSE THEN
OPEN "I",#1,rp$
IF vln>3 THEN
BGET #1,meml+conc,vln
ENDIF
CLOSE #1
ELSE
@maschinit9
@maschruf9(meml+conc,meml+conc+vln)
ENDIF
cached=FALSE
ELSE
a=RINSTR(oldpath2$,"\")
IF a>0 THEN
workf$=LEFT$(oldpath2$,a)+workfile$
ELSE
workf$=lfw$+workfile$
ENDIF
a=ASC(LEFT$(workf$,1))-64
vln=INT(df/4)*4
df=vln
IF stfx>=0 AND efx>stfx AND sblock=1 THEN
dazu=INT(stfx/4)*4
ELSE
dazu=0
ENDIF
IF efx>0 AND efx<=mlen AND sblock=1 THEN
bytes=(INT(efx/4)*4)-dazu
ELSE
bytes=mlen-dazu
ENDIF
mbytes=bytes
conc=conc-dazu
IF conc<0 THEN
conc=0
ENDIF
IF conc>bytes THEN
conc=bytes
ENDIF
IF DFREE(a)>=mlen+vln THEN
OPEN "O",#1,workf$
BPUT #1,meml+dazu,bytes
CLOSE #1
virtual=TRUE
path$=workf$
mbs=0
IF nr=smpedit& THEN
@setbutton(hard&,1)
ENDIF
makevirt=TRUE
virtln=bytes
conc=INT(conc/4)*4
okay2=TRUE
virtpath$=workf$
@rettmem
ENDIF
ENDIF
ENDIF
IF virtual=TRUE AND okay2=TRUE THEN
a=ASC(LEFT$(virtpath$,1))-64
IF virtwfile=FALSE AND conc=virtln AND df>0 AND inspace=FALSE THEN
IF DFREE(a)>=df THEN
OPEN "U",#1,virtpath$
a=RINSTR(virtpath$,"\")
OPEN "I",#2,rp$
SEEK #1,virtln
bytes=INT(mlen/4)*4
vln=INT(df/4)*4
makevirt2=TRUE
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #2,meml,bytes
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
CLOSE #1
CLOSE #2
ELSE
@nomem
makevirt2=FALSE
makevirt=FALSE
ENDIF
ELSE
IF DFREE(a)>=(virtln+df) AND df>0 THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
IF inspace=FALSE THEN
OPEN "I",#3,rp$
ENDIF
IF conc>0 AND conc<=virtln THEN
bytes=INT(mlen/4)*4
vln=INT(conc/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
ENDIF
IF inspace=TRUE THEN
@maschinit9
IF df>mlen THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+df)
ENDIF
ENDIF
bytes=INT(mlen/4)*4
vln=INT(df/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF inspace=FALSE THEN
BGET #3,meml,bytes
ENDIF
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
IF conc<virtln THEN
bytes=INT(mlen/4)*4
vln=INT((virtln-conc)/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
ENDIF
CLOSE #1
CLOSE #2
IF inspace=FALSE THEN
CLOSE #3
ENDIF
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
makevirt2=TRUE
ENDIF
ELSE
@nomem
makevirt2=FALSE
makevirt=FALSE
ENDIF
ENDIF
@memtovirt
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE memtovirt
IF makevirt=TRUE OR makevirt2=TRUE OR makevirt3=TRUE THEN
IF makevirt=TRUE OR makevirt3=TRUE THEN
path$=workf$
vmem=mbytes+df
ELSE
path$=oldpath2$
vmem=vmem+df
ENDIF
vmeml=0
vmemh=mlen
hrd=1
cached=FALSE
virtcurve=FALSE
IF vmem>mlen THEN
@hardproof2
vvv=TRUE
ln=vmem
sec=INT(ln/(hz*4))+1
ELSE
IF vmem<mlen THEN
@maschinit9
@maschruf9(meml+vmem,memh)
ENDIF
IF makevirt=TRUE OR makevirt3=TRUE THEN
BLOAD workf$,meml
KILL workf$
ENDIF
vvv=FALSE
virtual=FALSE
cached=FALSE
ln=vmem
sec=INT(ln/(hz*4))+1
vmem=mlen
ENDIF
blks=0
vce=0
vcs=0
lz=1
IF makevirt3=FALSE THEN
@rsc_back(nr)
nr=vornr
@rsc_draw(nr,5)
ENDIF
@markdel
@clsed
path$=workf$
IF makevirt2=TRUE AND makevirt=FALSE THEN
path$=oldpath2$
ENDIF
REPEAT
g=INSTR(path$,"\")
IF g>0 THEN
path$=RIGHT$(path$,(LEN(path$)-g))
ENDIF
g2=INSTR(path$,":")
IF g2>0 THEN
path$=RIGHT$(path$,(LEN(path$)-g2))
ENDIF
UNTIL g=0 AND g2=0
mp$=path$
IF nr=smpedit& THEN
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
IF vvv=TRUE THEN
@setbutton(hard&,1)
hrd=1
ELSE
@setbutton(hard&,0)
hrd=0
ENDIF
ENDIF
cs=0
ce=vmem
ELSE
cached=FALSE
ENDIF
makevirt=FALSE
makevirt2=FALSE
makevirt3=FALSE
RETURN
'
> PROCEDURE memtovirt2
vmeml=0
vmemh=mlen
cached=FALSE
virtcurve=FALSE
IF vmem>mlen THEN
@hardproof2
vvv=TRUE
ln=vmem
sec=INT(ln/(hz*4))+1
ELSE
IF vmem<mlen THEN
@maschinit9
@maschruf9(meml+vmem,memh)
ENDIF
IF makevirt=TRUE OR makevirt3=TRUE THEN
BLOAD workf$,meml
KILL workf$
ENDIF
vvv=FALSE
virtual=FALSE
cached=FALSE
ln=vmem
sec=INT(ln/(hz*4))+1
vmem=mlen
ENDIF
blks=0
vce=0
vcs=0
lz=1
IF makevirt3=FALSE THEN
@rsc_back(nr)
nr=vornr
@rsc_draw(nr,5)
ENDIF
IF noblkdel=FALSE THEN
@markdel
@clsed
ENDIF
path$=mrkp$
REPEAT
g=INSTR(path$,"\")
IF g>0 THEN
path$=RIGHT$(path$,(LEN(path$)-g))
ENDIF
g2=INSTR(path$,":")
IF g2>0 THEN
path$=RIGHT$(path$,(LEN(path$)-g2))
ENDIF
UNTIL g=0 AND g2=0
mp$=path$
IF nr=smpedit& THEN
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
IF vvv=TRUE THEN
@setbutton(hard&,1)
hrd=1
ELSE
@setbutton(hard&,0)
hrd=0
ENDIF
ENDIF
cs=0
ce=vmem
makevirt3=FALSE
RETURN
'
> PROCEDURE speaker
@setbutton(hear&,0)
RETURN
'
> PROCEDURE monitor
@setbutton(monitor&,0)
RETURN
'
> PROCEDURE mono
LOCAL okay,a,vln
@maschinit17
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf17(meml,memh)
ELSE
@blocklook
@maschruf17(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@restaura
@setbutton(mono&,0)
obj=0
ELSE
a=meml
b=memh
vln=virtln
bytes=INT(mlen/4)*4
okay=FALSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
seekz=0
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
@maschruf17(meml,meml+bytes)
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
@hardproof3
vmem=INT(virtln/4)*4
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
@restaura
@setbutton(mono&,0)
obj=0
RETURN
'
> PROCEDURE harddisk
IF hrd=0 THEN
hrd=1
ELSE
hrd=0
ENDIF
RETURN
'
> PROCEDURE peak
vornr=nr
@rsc_back(nr)
nr=peak&
@rsc_draw(nr,1)
@markhlp
MENU OFF
~@xrsrc_gaddr(0,nr,zu%)
boxadr=zu%
@findbutton(prmin&)
sr1%=buttadr
@findbutton(pr2&)
sr2%=buttadr
@findbutton(pr3&)
sr3%=buttadr
@findbutton(pr4&)
sr4%=buttadr
@findbutton(pr5&)
sr5%=buttadr
@findbutton(pr6&)
sr6%=buttadr
@findbutton(pr7&)
sr7%=buttadr
@findbutton(pr8&)
sr8%=buttadr
@findbutton(pr9&)
sr9%=buttadr
@findbutton(prmax&)
sr10%=buttadr
@findbutton(plmin&)
sl1%=buttadr
@findbutton(pl2&)
sl2%=buttadr
@findbutton(pl3&)
sl3%=buttadr
@findbutton(pl4&)
sl4%=buttadr
@findbutton(pl5&)
sl5%=buttadr
@findbutton(pl6&)
sl6%=buttadr
@findbutton(pl7&)
sl7%=buttadr
@findbutton(pl8&)
sl8%=buttadr
@findbutton(pl9&)
sl9%=buttadr
@findbutton(plmax&)
sl10%=buttadr
@maschinit14
ON MENU MESSAGE GOSUB message
REPEAT
ON MENU
@peakread
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=2 OR v3=3
IF vornr=smp16& THEN
@rsc_back(nr)
nr=vornr
@rsc_draw(nr,7)
ENDIF
obj=0
IF vornr=smpedit& THEN
@restaura2
@setbutton(peaksw2&,0)
ENDIF
RETURN
'
> PROCEDURE midi
oldobj=obj
vornr=nr
@rsc_back(nr)
nr=midiedit&
@rsc_draw(nr,5)
@markhlp
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,v3,v4)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
IF obj<>midinup& AND obj<>midindwn& AND obj<>midioup& AND obj<>midiodwn& AND obj<>midicup& AND obj<>midicdwn& THEN
aw=FORM_BUTTON(boxadr,obj,1,a)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
ELSE
@setbutton(obj,1)
PAUSE 1
@setbutton(obj,0)
ENDIF
PAUSE 1
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=midicup& THEN
@channelup
ENDIF
IF obj=midicdwn& THEN
@channeldown
ENDIF
IF obj=midinup& THEN
@noteup
ENDIF
IF obj=midindwn& THEN
@notedown
ENDIF
IF obj=midioup& THEN
@oktup
ENDIF
IF obj=midiodwn& THEN
@oktdown
ENDIF
IF obj=helpmidi& THEN
@helptxt("MIDI")
ENDIF
UNTIL obj=midiok&
@setbutton(obj,0)
@restaura2
obj=0
@setbutton(oldobj,0)
RETURN
'
> PROCEDURE fadedown
RETURN
'
> PROCEDURE fadeup
RETURN
'
> PROCEDURE fadelinks
RETURN
'
> PROCEDURE faderechts
RETURN
'
> PROCEDURE makefade
smark=8
RETURN
'
> PROCEDURE channelup
IF ch<16 THEN
ch=ch+1
ENDIF
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
RETURN
'
> PROCEDURE channeldown
IF ch>1 THEN
ch=ch-1
ENDIF
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
RETURN
'
> PROCEDURE makenote
@midinote
@textfeld(notetxt&,db$,1)
midiwort=(ch-1)*256+note
RETURN
'
> PROCEDURE midinote
o=INT(note/12)
n=note-o*12
IF n=0 THEN
IF o<3 THEN
db$="C "
ELSE
db$="c "
ENDIF
ENDIF
IF n=1 THEN
IF o<3 THEN
db$="C#"
ELSE
db$="c#"
ENDIF
ENDIF
IF n=2 THEN
IF o<3 THEN
db$="D "
ELSE
db$="d "
ENDIF
ENDIF
IF n=3 THEN
IF o<3 THEN
db$="D#"
ELSE
db$="d#"
ENDIF
ENDIF
IF n=4 THEN
IF o<3 THEN
db$="E "
ELSE
db$="e "
ENDIF
ENDIF
IF n=5 THEN
IF o<3 THEN
db$="F "
ELSE
db$="f "
ENDIF
ENDIF
IF n=6 THEN
IF o<3 THEN
db$="F#"
ELSE
db$="f#"
ENDIF
ENDIF
IF n=7 THEN
IF o<3 THEN
db$="G "
ELSE
db$="g "
ENDIF
ENDIF
IF n=8 THEN
IF o<3 THEN
db$="G#"
ELSE
db$="g#"
ENDIF
ENDIF
IF n=9 THEN
IF o<3 THEN
db$="A "
ELSE
db$="a "
ENDIF
ENDIF
IF n=10 THEN
IF o<3 THEN
db$="A#"
ELSE
db$="a#"
ENDIF
ENDIF
IF n=11 THEN
IF o<3 THEN
db$="B "
ELSE
db$="b "
ENDIF
ENDIF
IF o=0 THEN
db$=db$+"3"
ENDIF
IF o=1 THEN
db$=db$+"2"
ENDIF
IF o=2 THEN
db$=db$+"1"
ENDIF
IF o=3 THEN
db$=db$+"0"
ENDIF
IF o=4 THEN
db$=db$+"1"
ENDIF
IF o=5 THEN
db$=db$+"2"
ENDIF
IF o=6 THEN
db$=db$+"3"
ENDIF
IF o=7 THEN
db$=db$+"4"
ENDIF
IF o=8 THEN
db$=db$+"5"
ENDIF
IF o=9 THEN
db$=db$+"6"
ENDIF
IF o=10 THEN
db$=db$+"7"
ENDIF
db$=db$+CHR$(0)
RETURN
'
> PROCEDURE notedown
IF note>0 THEN
note=note-1
ENDIF
@makenote
RETURN
'
> PROCEDURE noteup
IF note<127 THEN
note=note+1
ENDIF
@makenote
RETURN
'
> PROCEDURE oktdown
IF (note-12)>=0 THEN
note=note-12
ENDIF
@makenote
RETURN
'
> PROCEDURE oktup
IF (note+12)<=127 THEN
note=note+12
ENDIF
@makenote
RETURN
'
> PROCEDURE machmidi
IF mamidi=0 THEN
mamidi=1
ELSE
mamidi=0
ENDIF
RETURN
'
> PROCEDURE helpedit
@setbutton(helpedit&,0)
RETURN
'
> PROCEDURE loopwahl
vornr=nr
@rsc_back(nr)
nr=loop&
@rsc_draw(nr,5)
@markhlp
IF sret=0 THEN
@setbutton(forw&,1)
ENDIF
IF sret=1 THEN
@setbutton(backw&,1)
ENDIF
IF sret=2 THEN
@setbutton(cross&,1)
ENDIF
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3=0
PAUSE 2
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=helploop& THEN
@helptxt("LOOPS")
ENDIF
UNTIL obj=loopexit& OR obj=forw& OR obj=backw& OR obj=cross&
IF obj=forw& THEN
@loopfor
ENDIF
IF obj=backw& THEN
@loopret
ENDIF
IF obj=cross& THEN
@loopcross
ENDIF
@setbutton(obj,0)
@restaura2
obj=0
@setbutton(loopart&,0)
RETURN
'
> PROCEDURE dspwahl
vornr=nr
@rsc_back(nr)
nr=dspedit&
@rsc_draw(nr,5)
@markhlp
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
~GRAF_MKSTATE(x,y,v3,v4)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
IF obj=dspload& THEN
PAUSE 2
@setbutton(dspload&,0)
ENDIF
IF obj=dspsave& THEN
PAUSE 2
@setbutton(dspsave&,0)
ENDIF
IF obj=dsphall& THEN
PAUSE 2
@setbutton(dsphall&,0)
ENDIF
IF obj=dspecho& THEN
PAUSE 2
@setbutton(dspecho&,0)
ENDIF
IF obj=dspret& THEN
PAUSE 2
@setbutton(dspret&,0)
ENDIF
IF obj=dspeq& THEN
PAUSE 2
@setbutton(dspeq&,0)
ENDIF
IF obj=helpdsp& THEN
@helptxt("DSP")
ENDIF
UNTIL obj=dspexit&
@setbutton(obj,0)
@rsc_back(nr)
nr=vornr
@rsc_draw(nr,5)
obj=0
RETURN
'
> PROCEDURE loopauto
'  @setbutton(loopauto&,0)
RETURN
'
> PROCEDURE loopfor
sret=0
RETURN
'
> PROCEDURE loopret
sret=1
RETURN
'
> PROCEDURE loopcross
sret=2
RETURN
'
> PROCEDURE normadj
grenz=(db+aufloes)/20
grenz=10^grenz
IF grenz>32767 THEN
grenz=32767
ENDIF
grenz=INT(grenz)
@makenorm
RETURN
'
> PROCEDURE normauto
db=0
grenz=32767
@makenorm
RETURN
'
> PROCEDURE makenorm
LOCAL okay,a,vln
@maschinit13
IF virtual=FALSE THEN
IF sblock=0 THEN
a=meml
b=memh
ELSE
@blocklook
a=mcs
b=mce
ENDIF
IF sblock=0 OR (sblock=1 AND c2>c1 AND mce<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0) THEN
@maschruf13(a,b,grenz,back%)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
makecurve=1
ENDIF
ELSE
a=meml
b=memh
vln=virtln
bytes=INT(mlen/4)*4
okay=FALSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
seekz=0
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
@maschruf13(meml,meml+bytes,grenz,back%)
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
@hardproof3
vmem=INT(virtln/4)*4
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
makecurve=1
ELSE
@nomem
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
RETURN
'
> PROCEDURE normtest
@maschinit12
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf12(meml,memh)
ELSE
@blocklook
@maschruf12(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF back%>0 THEN
db=back%
db=20*LOG10(db)
db=db-aufloes
db=INT(db*100)/100
ELSE
back%=32767
db=0
ENDIF
ELSE
vln=virtln
bhold=0
bytes=0
OPEN "I",#1,virtpath$
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschruf12(meml,meml+bytes)
ENDIF
vln=vln-bytes
IF back%>bhold THEN
bhold=back%
ENDIF
UNTIL vln<4
CLOSE #1
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF bhold>0 THEN
db=bhold
db=20*LOG10(db)
db=db-aufloes
db=INT(db*100)/100
ELSE
bhold=32767
db=0
ENDIF
back%=bhold
ENDIF
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
RETURN
'
> PROCEDURE norml
IF norma=0 THEN
auflh=INT(0-(aufloes*100))
dbx=INT(db*100)
IF obj=norml1& THEN
nz=2
ENDIF
IF obj=norml2& THEN
nz=20
ENDIF
IF obj=norml3& THEN
nz=400
ENDIF
dbx=dbx-nz
IF dbx>=auflh THEN
db=INT(dbx)/100
ENDIF
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
ENDIF
RETURN
'
> PROCEDURE normr
IF norma=0 THEN
dbx=INT(db*100)
IF obj=normr1& THEN
nz=2
ENDIF
IF obj=normr2& THEN
nz=20
ENDIF
IF obj=normr3& THEN
nz=400
ENDIF
t=1
dbx=dbx+nz
IF t>dbx THEN
db=INT(dbx)/100
ENDIF
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
ENDIF
RETURN
'
> PROCEDURE resl
IF obj=resl1& THEN
nz=0.1
ENDIF
IF obj=resl2& THEN
nz=1
ENDIF
IF obj=resl3& THEN
nz=5
ENDIF
t=5
IF (resoth-nz)>=t THEN
resoth=resoth-nz
ENDIF
resoth=INT(resoth*10)/10
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
RETURN
'
> PROCEDURE resr
IF obj=resr1& THEN
nz=0.1
ENDIF
IF obj=resr2& THEN
nz=1
ENDIF
IF obj=resr3& THEN
nz=5
ENDIF
t=96
IF (resoth+nz)<=t THEN
resoth=resoth+nz
ENDIF
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
RETURN
'
> PROCEDURE resoth32
resoth=32
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
@setbutton(res32&,0)
RETURN
'
> PROCEDURE resoth44
resoth=44.1
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
@setbutton(res44&,0)
RETURN
'
> PROCEDURE resoth48
resoth=48
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
@setbutton(res48&,0)
RETURN
'
> PROCEDURE makeresmp
LOCAL okay,vln
@maschinit16
e=INT(resorig*10)
f=INT(resoth*10)
bedarf=f/e
IF virtual=FALSE THEN
IF sblock=0 THEN
IF bedarf<=1 THEN
a=meml
b=memh
c=meml
d=memh
@maschruf16(a,b,c,d,e,f)
IF back%<memh AND back%>meml THEN
@maschinit9
@maschruf9(back%,memh-4)
ENDIF
makecurve=1
hz=resoth*1000
hzm=hz
retime=1
ELSE
a=meml
drittel=(memh-meml)/(e+f)*e
IF drittel>15 THEN
drittel=drittel-8
ENDIF
IF ldlen=0 OR (ldlen<>0 AND ldlen<=drittel) THEN
drittel=drittel+meml
drittel=INT(drittel/4)*4
b=drittel
c=drittel
d=memh
@maschruf16(a,b,c,d,e,f)
makecurve=1
hz=resoth*1000
hzm=hz
retime=1
@maschinit10
@maschruf10(c,d,meml,memh)
@maschinit9
b=INT((d-c)/4)*4
@maschruf9(meml+b,d)
ELSE
ALERT 3,"Zu wenig Speicher !|Bitte Block verkleinern !",1,"OK",a
ENDIF
ENDIF
ELSE
@blocklook
a=mcs
b=mce
drittel=(memh-meml)/(mce-mcs)
IF bedarf<=1 THEN
c=mcs
d=mce
@maschruf16(a,b,c,d,e,f)
makecurve=1
hz=resoth*1000
hzm=hz
retime=1
IF back%<mce AND back%>mcs THEN
@maschinit9
@maschruf9(back%,mce)
ENDIF
ELSE
IF mce+4<memh AND drittel>=bedarf THEN
c=mce
d=memh-4
@maschruf16(a,b,c,d,e,f)
makecurve=1
hz=resoth*1000
hzm=hz
retime=1
@maschinit10
@maschruf10(c,d,mcs,memh-4)
@maschinit9
b=INT((d-c)/4)*4
@maschruf9(mcs+b,d)
ELSE
ALERT 3,"Zu wenig Speicher !|Bitte Block verkleinern !",1,"OK",a
ENDIF
ENDIF
ENDIF
ELSE                      ! virtual=true
vln=virtln
bytes=INT(mlen/4)*4
okay=FALSE
drittel=(memh-meml)/(e+f)*e
drittel=INT(drittel/4)*4
IF drittel>15 THEN
drittel=drittel-8
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
IF okay=TRUE THEN
seekz=0
seekz2=0
REPEAT
IF vln>=bytes THEN
IF bedarf<=1 THEN
bytes=INT(mlen/4)*4
ELSE
bytes=drittel
ENDIF
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
a=meml
b=meml+bytes
IF bedarf<=1 THEN
c=meml
ELSE
c=meml+bytes
ENDIF
d=memh
@maschruf16(a,b,c,d,e,f)
back%=INT(back%/4)*4
BPUT #2,c,back%-c
ENDIF
vln=vln-bytes
seekz=seekz+bytes
seekz2=seekz2+(back%-c)
UNTIL vln<4
CLOSE #1
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
path$=virtpath$
@hardproof3
vmem=INT(virtln/4)*4
@memtovirt2
hz=resoth*1000
retime=1
makecurve=1
ELSE
hz=resorig*1000
retime=0
makecurve=0
ENDIF
hzm=hz
ELSE
@nomem
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
RETURN
'
> PROCEDURE nomem
ALERT 1,"Zu wenig Platz|auf dem Speichermedium !",1,"EXIT",g
RETURN
'
> PROCEDURE npeakread
@maschinit6
REPEAT
@maschruf6
@rsc_back(nr)
@rsc_draw(nr,4)
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL v3<>0 OR INP?(2)=TRUE
RETURN
'
> PROCEDURE peakwert
IF demo=FALSE THEN
REPEAT
@read_smp
pr=rwert
UNTIL (pr AND 256)=0
REPEAT
REPEAT
@read_smp
pr=rwert
UNTIL (pr AND 256)=256
@read_smp
pr2=rwert
UNTIL (pr2 AND 256)=256
REPEAT
REPEAT
@read_smp
pl=rwert
UNTIL (pl AND 256)=0
@read_smp
pl2=rwert
UNTIL (pl2 AND 256)=0
pr=(pr AND 255)*256+(pr2 AND 255)
pl=(pl AND 255)*256+(pl2 AND 255)
IF pr>32767 THEN
pr=ABS(pr-65536)
ENDIF
IF pl>32767 THEN
pl=ABS(pl-65536)
ENDIF
pr=pr/32767*10
pl=pl/32767*10
ELSE
INC pr
INC pl
IF pr>gr1 THEN
pr=0
gr1=INT(RND(1)*9)
ENDIF
IF pl>gr2 THEN
pl=0
gr2=INT(RND(1)*9)
ENDIF
FOR n=0 TO 300
NEXT n
ENDIF
RETURN
'
> PROCEDURE peakread
@maschruf14(4096)
a=0
b=0
raus=FALSE
i=0
REPEAT
@peakwert
IF pr>9 OR pl>9 THEN
a=pr
b=pl
raus=TRUE
ENDIF
IF pr>a THEN
a=pr
ENDIF
IF pl>b THEN
b=pl
ENDIF
INC i
UNTIL i=100 OR raus=TRUE
pr=a
pl=b
erlaub=TRUE
IF erlaub=TRUE THEN
IF pr>0 THEN
DPOKE sr1%,1
ELSE
DPOKE sr1%,0
ENDIF
IF pl>0 THEN
DPOKE sl1%,1
ELSE
DPOKE sl1%,0
ENDIF
IF pr>1 THEN
DPOKE sr2%,1
ELSE
DPOKE sr2%,0
ENDIF
IF pl>1 THEN
DPOKE sl2%,1
ELSE
DPOKE sl2%,0
ENDIF
IF pr>2 THEN
DPOKE sr3%,1
ELSE
DPOKE sr3%,0
ENDIF
IF pl>2 THEN
DPOKE sl3%,1
ELSE
DPOKE sl3%,0
ENDIF
IF pr>3 THEN
DPOKE sr4%,1
ELSE
DPOKE sr4%,0
ENDIF
IF pl>3 THEN
DPOKE sl4%,1
ELSE
DPOKE sl4%,0
ENDIF
IF pr>4 THEN
DPOKE sr5%,1
ELSE
DPOKE sr5%,0
ENDIF
IF pl>4 THEN
DPOKE sl5%,1
ELSE
DPOKE sl5%,0
ENDIF
IF pr>5 THEN
DPOKE sr6%,1
ELSE
DPOKE sr6%,0
ENDIF
IF pl>5 THEN
DPOKE sl6%,1
ELSE
DPOKE sl6%,0
ENDIF
IF pr>6 THEN
DPOKE sr7%,1
ELSE
DPOKE sr7%,0
ENDIF
IF pl>6 THEN
DPOKE sl7%,1
ELSE
DPOKE sl7%,0
ENDIF
IF pr>7 THEN
DPOKE sr8%,1
ELSE
DPOKE sr8%,0
ENDIF
IF pl>7 THEN
DPOKE sl8%,1
ELSE
DPOKE sl8%,0
ENDIF
IF pr>8 THEN
DPOKE sr9%,1
ELSE
DPOKE sr9%,0
ENDIF
IF pl>8 THEN
DPOKE sl9%,1
ELSE
DPOKE sl9%,0
ENDIF
IF pr>9 THEN
DPOKE sr10%,1
ELSE
DPOKE sr10%,0
ENDIF
IF pl>9 THEN
DPOKE sl10%,1
ELSE
DPOKE sl10%,0
ENDIF
rsc_message(nr,20,0,0,xwidth,ywidth,0,0)         ! ...redrawen
IF pr>9 OR pl>9 THEN
PAUSE 20
ENDIF
ENDIF
RETURN
'
> PROCEDURE smpscrol
smark=1
RETURN
'
> PROCEDURE smpzoom
smark=2
RETURN
'
> PROCEDURE smpkopie
smark=5
RETURN
'
> PROCEDURE smpmove
smark=6
RETURN
'
> PROCEDURE smpinsert
smark=4
RETURN
'
> PROCEDURE smpmerge
smark=7
RETURN
'
> PROCEDURE smpmark
smark=3
RETURN
'
> PROCEDURE markhandler(tx,utx,ty1,ty2,dx,tym)
LOCAL ux
IF tx>=cs AND tx<=ce AND (ce-cs)>0 THEN
ux=tx-cs
ux=INT(ux/(ce-cs)*xm)
IF x>ux+xd-2 AND x<ux+xd+2 AND y>=ty1 AND y<=ty2 THEN
~GRAF_MKSTATE(v,v2,k,v4)
~GRAF_MOUSE(256,0)                              ! Hidem
IF k=1 THEN
COLOR 0
GRAPHMODE 1
FOR i=x-5 TO x+5
LINE i,ty1+1,i,ty1-5
NEXT i
GRAPHMODE 3
f=0
x3=-1
REPEAT
~GRAF_MKSTATE(x2,v2,k,v4)
IF x<>x2 THEN
INC f
ENDIF
x=x2
IF x>=xd AND x<=xm+xd AND y>=ty1 AND y<=ty2 AND x<>ux+xd AND x3<>x THEN
GRAPHMODE 3
COLOR 0
LINE ux+xd,ty1+2,ux+xd,ty2
COLOR 1
tx=INT(((ce-cs)/xm*(x-xd)+cs)/4)*4
ux=tx-cs
ux=INT(ux/(ce-cs)*xm)
x3=x
LINE ux+xd,ty1+2,ux+xd,ty2
*utx=tx
GRAPHMODE 3
ENDIF
UNTIL k=0
COLOR 1
TEXT ux+xd-3,ty1-1,t$
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
obj=0
RETURN
'
> PROCEDURE markhandl2(tx,utx,ty1,ty2,dx,tym)
LOCAL ux,i
IF x>=0 AND x<=vmem AND x>=cs AND x<=ce AND (ce-cs)>0 THEN
ux=tx-cs
ux=INT(ux/(ce-cs)*xm)
GRAPHMODE 3
COLOR 1
LINE ux+xd,ty1,ux+xd,ty2
COLOR 0
GRAPHMODE 1
FOR i=ux-5 TO ux+5
LINE i+xd,ty1+1,i+xd,ty1-5
NEXT i
GRAPHMODE 1
COLOR 1
LINE ux+xd-1,ty1+2,ux+xd+1,ty1+2
LINE ux+xd-1,ty1+tym-2,ux+xd+1,ty1+tym-2
LINE ux+xd-1,ty1+ym2-2,ux+xd+1,ty1+ym2-2
LINE ux+xd-1,ty1+ym3-2,ux+xd+1,ty1+ym3-2
ux=x-cs
ux=INT(ux/(ce-cs)*xm)
GRAPHMODE 3
LINE ux+xd,ty1,ux+xd,ty2
GRAPHMODE 1
TEXT ux+xd-3,ty1-1,t$
GRAPHMODE 3
ENDIF
IF x>=0 AND x<=vmem AND (ce-cs)>0 THEN
*utx=x
ENDIF
RETURN
'
> PROCEDURE markhandl3(tx,ty1,ty2,dx,tym)
COLOR 1
GRAPHMODE 3
LINE tx-1,ty1+2,tx+1,ty1+2
LINE tx-1,ty1+tym-2,tx+1,ty1+tym-2
LINE tx-1,ty1+ym2-2,tx+1,ty1+ym2-2
LINE tx-1,ty1+ym3-2,tx+1,ty1+ym3-2
GRAPHMODE 3
LINE tx,ty1,tx,ty2
GRAPHMODE 3
TEXT tx-3,ty1,t$
RETURN
'
> PROCEDURE blkstore
IF blks=0 THEN
blks=1
ELSE
blks=0
ENDIF
RETURN
'
> PROCEDURE deladbutt
IF clk=4 THEN
a$=@rsc_text$(popups&,10)
@textfeld(rate2&,a$,1)
ENDIF
IF clk=8 THEN
a$=@rsc_text$(popups&,11)
@textfeld(rate2&,a$,1)
ENDIF
IF clk=12 THEN
a$=@rsc_text$(popups&,12)
@textfeld(rate2&,a$,1)
ENDIF
RETURN
'
> PROCEDURE smpplay
@wait
IF sret=2 THEN
@crossplay
ELSE
IF hrd=0 THEN
IF sblock=0 THEN
IF mamidi=0 THEN
@maschinit2
ELSE
@maschinit18
POKE mdat2%+retanz,0
ENDIF
a=meml
b=memh
IF sloop=0 THEN
l=0
ELSE
l=-1
ENDIF
IF sret=1 THEN
POKE mdat2%+retanz,8
c=a
a=b-4
b=c
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,14)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF sret=0 AND a<b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF sret=1 AND a>b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,15)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF sret=1 THEN
POKE mdat2%+retanz,0
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
ELSE
@smppmhlp
ENDIF
ELSE
oldpath$=path$
IF virtual=FALSE THEN
@fileselect(op$+"*."+ext$,"","PLAY:")
ELSE
path$=mrkp$
ENDIF
pat$=path$
path$=oldpath$
IF pret<>0 AND pbutt=1 THEN
IF EXIST(pat$) THEN
IF nr=smpedit& THEN
@restaura
ENDIF
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
pa$=pat$+CHR$(0)
sectors=INT(f/flen)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=SPACE$(6)+pat$+SPACE$(6)
pat$=MID$(pat$,INT(LEN(pat$)/2)-5,12)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smpfile&,pat$,1)
mem$=RIGHT$("00000000"+STR$(f),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
@makehz
hsec=INT(f/(hz*4))
mem$=RIGHT$("00000000"+STR$(hsec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
ENDIF
IF nr=smp16& THEN
@textfeld(datei&,pat$,2)
mem$=RIGHT$("00000000"+STR$(f),8)
@textfeld(memused&,mem$,2)
ENDIF
@digout(TRUE)
IF sret=0 THEN
REPEAT
@maschinit23
over=0
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
IF virtual=TRUE AND sblock=1 THEN
@blocklook
IF sms<>0 AND sme<>0 AND c1<>-1 AND c2>0 AND c2>c1 THEN
sectors=INT((c2-c1)/flen)
seeknr=c1
seek=GEMDOS(66,L:seeknr,handle,0)
ENDIF
ENDIF
@maschruf23
~GEMDOS(62,handle)
ENDIF
UNTIL sloop=0 OR back%<>sectors
ENDIF
IF sret=1 AND mamidi=0 THEN
REPEAT
@maschinit25
over=0
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
seeknr=sectors*flen
seek=GEMDOS(66,L:seeknr,handle,0)
IF seek>=0 THEN
@maschinit25
@maschruf25
~GEMDOS(62,handle)
ENDIF
ENDIF
UNTIL sloop=0 OR back%<>sectors
ENDIF
IF nr=smpedit& THEN
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
ENDIF
IF nr=smp16& THEN
@textfeld(datei&,path$,2)
mem$=RIGHT$("00000000"+STR$(ln),8)
@textfeld(memused&,mem$,2)
ENDIF
ENDIF
ELSE
IF nr=smpedit& THEN
@restaura
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
ENDIF
@digout(FALSE)
ENDIF
RETURN
'
> PROCEDURE smppmhlp
IF sret=2 THEN
@crossplay
ELSE
IF mamidi=0 THEN
@maschinit2
ELSE
@maschinit18
POKE mdat2%+retanz,0
ENDIF
a=meml
ama=a
amb=memh
IF sms=1 THEN
stxnr=stax
ENDIF
IF sms=2 THEN
stxnr=stbx
ENDIF
IF sms=3 THEN
stxnr=stcx
ENDIF
IF sms=4 THEN
stxnr=stdx
ENDIF
IF sms=5 THEN
stxnr=stex
ENDIF
IF sms=6 THEN
stxnr=stfx
ENDIF
IF xm>0 AND stxnr<>-1 THEN
a=a+stxnr
a=INT(a/4)*4
ENDIF
b=meml
IF sme=1 THEN
stxnr=eax
ENDIF
IF sme=2 THEN
stxnr=ebx
ENDIF
IF sme=3 THEN
stxnr=ecx
ENDIF
IF sme=4 THEN
stxnr=edx
ENDIF
IF sme=5 THEN
stxnr=eex
ENDIF
IF sme=6 THEN
stxnr=efx
ENDIF
IF xm>0 AND stxnr>0 THEN
b=b+stxnr
b=INT(b/4)*4
ENDIF
IF sloop=0 THEN
l=0
ELSE
l=-1
ENDIF
lmin=a
lma=b
IF sms<>0 AND sme<>0 AND a>=ama AND b<=amb AND xm<>0 AND stxnr<>0 THEN
IF sret=1 THEN
POKE mdat2%+retanz,8
c=a
a=b-4
b=c
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,14)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF sret=0 AND a<b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF sret=1 AND a>b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,15)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF sret=1 THEN
POKE mdat2%+retanz,0
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
ENDIF
RETURN
'
> PROCEDURE crossplay
IF hrd=0 THEN
IF sblock=0 THEN
IF mamidi=0 THEN
@maschinit15
ELSE
@maschinit21
ENDIF
l=0
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,14)
@textfeld(input&,a$,1)
ENDIF
ENDIF
a=meml
b=memh-4
IF sloop=0 THEN
l=0
ELSE
l=-1
ENDIF
IF a<b THEN
IF mamidi=0 THEN
@maschruf15
ELSE
@maschruf18
ENDIF
ENDIF
@digin
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,15)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
ELSE
IF mamidi=0 THEN
@maschinit15
ELSE
@maschinit21
ENDIF
a=meml
ama=a
amb=memh
IF sms=1 THEN
stxnr=stax
ENDIF
IF sms=2 THEN
stxnr=stbx
ENDIF
IF sms=3 THEN
stxnr=stcx
ENDIF
IF sms=4 THEN
stxnr=stdx
ENDIF
IF sms=5 THEN
stxnr=stex
ENDIF
IF sms=6 THEN
stxnr=stfx
ENDIF
IF xm>0 AND stxnr>0 THEN
a=a+stxnr
a=INT(a/4)*4
ENDIF
b=meml
IF sme=1 THEN
stxnr=eax
ENDIF
IF sme=2 THEN
stxnr=ebx
ENDIF
IF sme=3 THEN
stxnr=ecx
ENDIF
IF sme=4 THEN
stxnr=edx
ENDIF
IF sme=5 THEN
stxnr=eex
ENDIF
IF sme=6 THEN
stxnr=efx
ENDIF
IF xm>0 AND stxnr>0 THEN
b=b+stxnr
b=INT(b/4)*4
b=b-4
ENDIF
l=0
lmin=a
lma=b
IF sms<>0 AND sme<>0 AND a>=ama AND b<=amb AND xm<>0 AND stxnr<>0 THEN
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,14)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF sloop=0 THEN
l=0
ELSE
l=-1
ENDIF
IF a<b THEN
IF mamidi=0 THEN
@maschruf15
ELSE
@maschruf18
ENDIF
ENDIF
@digin
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,15)
@textfeld(input&,a$,1)
ENDIF
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
ENDIF
ELSE
oldpath$=path$
IF virtual=FALSE THEN
@fileselect(op$+"*."+ext$,"","PLAY:")
ELSE
path$=mrkp$
ENDIF
pat$=path$
path$=oldpath$
IF pret<>0 AND pbutt=1 THEN
IF EXIST(pat$) THEN
IF nr=smpedit& THEN
@restaura
ENDIF
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
pa$=pat$+CHR$(0)
sectors=INT(f/flen)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=SPACE$(6)+pat$+SPACE$(6)
pat$=MID$(pat$,INT(LEN(pat$)/2)-5,12)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smpfile&,pat$,1)
mem$=RIGHT$("00000000"+STR$(f),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
@makehz
hsec=INT(f/(hz*4))
mem$=RIGHT$("00000000"+STR$(hsec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
ENDIF
IF nr=smp16& THEN
@textfeld(datei&,pat$,2)
mem$=RIGHT$("00000000"+STR$(f),8)
@textfeld(memused&,mem$,2)
ENDIF
IF mamidi=0 THEN
@digout(TRUE)
REPEAT
@maschinit23
over=0
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
@maschruf23
~GEMDOS(62,handle)
ENDIF
IF back%=sectors THEN
over=0
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
seeknr=sectors*flen
seek=GEMDOS(66,L:seeknr,handle,0)
IF seek>=0 THEN
@maschinit25
@maschruf25
~GEMDOS(62,handle)
ENDIF
ENDIF
ENDIF
UNTIL sloop=0 OR back%<>sectors
ENDIF
IF nr=smpedit& THEN
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
ENDIF
IF nr=smp16& THEN
@textfeld(datei&,path$,2)
mem$=RIGHT$("00000000"+STR$(ln),8)
@textfeld(memused&,mem$,2)
ENDIF
ENDIF
ELSE
IF nr=smpedit& THEN
@restaura
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
ENDIF
@digout(FALSE)
RETURN
'
> PROCEDURE play
@digout(TRUE)
mem$=RIGHT$("00000000"+STR$(ln),8)
textfeld(memused&,mem$,2)
@smpplay
@setbutton(play&,32)
@digout(FALSE)
RETURN
'
> PROCEDURE smppmark
IF sblock=0 THEN
sblock=1
ELSE
sblock=0
ENDIF
RETURN
'
> PROCEDURE smploop
IF sloop=0 THEN
sloop=1
ELSE
sloop=0
ENDIF
RETURN
'
> PROCEDURE locking
IF locknr=0 THEN
locknr=1
@setbutton(noval&,0)
@setbutton(confid&,0)
@setbutton(slipped&,0)
@setbutton(crc&,0)
@setbutton(parity&,0)
@setbutton(biphase&,0)
@setbutton(nolock&,0)
ELSE
locknr=0
ENDIF
RETURN
'
> PROCEDURE smpauto
@wait
@smptime
IF obj=recok& THEN
retime=0
ldlen=0
mem$=RIGHT$("00000000"+STR$(ln),8)
IF nr=smp16& THEN
textfeld(memused&,mem$,2)
ENDIF
@maschinit4
IF hrd=0 THEN
@maschinit3
POKE mdat2%+111,0      ! REC-FIFO nicht loeschen
IF blocks=0 THEN
a=meml
l=mlen
ELSE
@blocklook
a=mcs
l=mce-mcs
ENDIF
tr%=th
sab%=a
enb%=a+l
ELSE
@record3
ENDIF
IF (hrd=0 AND sblock=0) OR (hrd=0 AND sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0) OR (hrd=1 AND frag=1 AND nofile=0) THEN
@maschruf4
ENDIF
IF ad=0 THEN
@smprate
hzc=rwert
ENDIF
IF (hrd=0 AND sblock=0) OR (hrd=0 AND sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0) THEN
@maschruf3b
POKE mdat2%+111,2     ! REC_FIFO loeschen
ENDIF
IF hrd=1 THEN
@record4
ENDIF
IF nr=smp16& THEN
@setbutton(smpauto&,0)
ENDIF
IF nr=smpedit& THEN
@setbutton(smpauto2&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpauto3&,0)
ENDIF
@record2
ELSE
IF nr=smp16& THEN
@setbutton(smpauto&,0)
ENDIF
IF nr=smpedit& THEN
@setbutton(smpauto2&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpauto3&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE smpstart
@wait
@smptime
IF obj=recok& THEN
ldlen=0
IF hrd=0 THEN
@record
ELSE
@record3
@record4
ENDIF
IF nr=smp16& THEN
@setbutton(smpstart&,0)
ENDIF
IF nr=smpedit& THEN
@setbutton(smpstrt2&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpstrt3&,0)
ENDIF
IF hrd=0 THEN
@record2
ENDIF
ELSE
IF nr=smp16& THEN
@setbutton(smpstart&,0)
ENDIF
IF nr=smpedit& THEN
@setbutton(smpstrt2&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpstrt3&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE record
retime=0
ldlen=0
IF nr=smp16& THEN
mem$=RIGHT$("00000000"+STR$(ln),8)
textfeld(memused&,mem$,2)
ENDIF
IF nr=smpedit& THEN
p$="    "+CHR$(0)
@textfeld(smprate&,p$,1)
ENDIF
@maschinit3
IF sblock=0 THEN
a=meml
l=mlen
ELSE
@blocklook
a=mcs
l=mce-mcs
ENDIF
IF ad=0 THEN
@smprate
hzc=rwert
ENDIF
IF sblock=0 OR (sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0) THEN
@maschruf3
ENDIF
RETURN
'
> PROCEDURE record2
@rsc_back(nr)
@rsc_draw(nr,5)
IF sblock=0 THEN
@markdel
@clsed
ENDIF
path$="MEMORY."+ext$
mp$=path$
lded=0
IF nr=smpedit& THEN
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
ENDIF
IF nr=smp16& THEN
path$=SPACE$(6)+path$+SPACE$(6)
path$=MID$(path$,INT(LEN(path$)/2)-5,12)+CHR$(0)
@textfeld(datei&,path$,2)
ENDIF
IF nr=smpedit& THEN
@curve(cs,ce)
@markprod3
ENDIF
RETURN
'
> PROCEDURE record3
retime=0
ldlen=0
nofile=0
IF hrd=1 THEN
oldpath$=path$
@fileselect(op$+"*."+ext$,"","RECORD:")
pat$=path$
path$=oldpath$
IF pat$="" OR pret=0 OR pbutt=0 THEN
nofile=1
ELSE
IF RIGHT$(pat$,1)="\" THEN
nofile=1
ENDIF
ENDIF
IF nofile=0 THEN
IF INSTR(pat$,".")=0 THEN
pat$=pat$+"."+ext$
ENDIF
pa$=pat$+CHR$(0)
@makehz
f=min*60*hz*4
sectors=INT(f/flen)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=SPACE$(6)+pat$+SPACE$(6)
pat$=MID$(pat$,INT(LEN(pat$)/2)-5,12)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smpfile&,pat$,1)
mem$=RIGHT$("00000000"+STR$(f),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
hsec=INT(f/(hz*4))
mem$=RIGHT$("00000000"+STR$(hsec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
ENDIF
IF nr=smp16& THEN
@textfeld(datei&,pat$,2)
mem$=RIGHT$("00000000"+STR$(f),8)
@textfeld(memused&,mem$,2)
ENDIF
@maschinit8
IF hrd=1 THEN
ALERT 2,"HD-AUFNAHME ?",2,"JA|NEIN",frag
ENDIF
ENDIF
@restaura
ENDIF
RETURN
'
> PROCEDURE record4
IF hrd=1 THEN
IF frag=1 AND nofile=0 THEN
@maschruf8
ENDIF
IF nr=smpedit& THEN
@textfeld(smpfile&,path$,1)
mem$=RIGHT$("00000000"+STR$(ln),8)
mem$="LEN "+mem$+" BYTES"+CHR$(0)
@textfeld(smplen&,mem$,1)
mem$=RIGHT$("00000000"+STR$(sec),8)
mem$="IST CA."+mem$+" SEC"+CHR$(0)
@textfeld(smpsec&,mem$,1)
ENDIF
IF nr=smp16& THEN
@textfeld(datei&,path$,2)
mem$=RIGHT$("00000000"+STR$(ln),8)
@textfeld(memused&,mem$,2)
ENDIF
ENDIF
RETURN
'
> PROCEDURE fsel
pathmrk$=path$
lnmrk=ln
memlmrk=meml
secmrk=sec
@ldhlp
IF anfloadx<>0 AND anfloadx<>-1 AND (ln-abz)<=vmem AND lready=1 THEN
IF path$<>"" AND RIGHT$(path$,1)<>"\" AND pathda=TRUE THEN
@textfeld(datei&,path$,2)
mem$=RIGHT$("00000000"+STR$(ln),8)
@textfeld(memused&,mem$,2)
ENDIF
~MFREE(anfloadx)
IF hz=32000 THEN
a$=@rsc_text$(popups&,10)
@textfeld(rate2&,a$,1)
@adlow
ENDIF
IF hz=44100 THEN
a$=@rsc_text$(popups&,11)
@textfeld(rate2&,a$,1)
@admid
ENDIF
IF hz=48000 THEN
a$=@rsc_text$(popups&,12)
@textfeld(rate2&,a$,1)
@adhigh
ENDIF
ENDIF
@setbutton(filesel&,0)
RETURN
'
> PROCEDURE edhandler
IF locknr=0 THEN
@smprate
c=rwert
IF c<>merkc THEN
merkc=c
IF c=3 THEN
IF merkfreq<>0 THEN
@setbutton(merkfreq,0)
ENDIF
@setbutton(smp32&,1)
merkfreq=smp32&
ENDIF
IF c=0 THEN
IF merkfreq<>0 THEN
@setbutton(merkfreq,0)
ENDIF
@setbutton(smp44&,1)
merkfreq=smp44&
ENDIF
IF c=2 THEN
IF merkfreq<>0 THEN
@setbutton(merkfreq,0)
ENDIF
@setbutton(smp48&,1)
merkfreq=smp48&
ENDIF
ENDIF
ENDIF
IF locknr=0 THEN
@read_statlow
a=rwert           ! Status Low
@read_statmid
b=rwert           ! Status Mid
IF merk1<>a OR merk2<>b THEN
merk1=a
merk2=b
@subframe(FALSE)
@subframe(TRUE)
@subframe(FALSE)
IF b=0 THEN
IF merkerr<>0 THEN
@setbutton(merkerr,0)
merkerr=0
errdel=1
ENDIF
ENDIF
IF b=1 THEN
IF merkerr<>0 THEN
@setbutton(merkerr,0)
ENDIF
@setbutton(noval&,1)
merkerr=noval&
errdel=1
ENDIF
IF b=2 THEN
IF merkerr<>0 THEN
@setbutton(merkerr,0)
ENDIF
@setbutton(confid&,1)
merkerr=confid&
errdel=1
ENDIF
IF b=3 THEN
IF merkerr<>0 THEN
@setbutton(merkerr,0)
ENDIF
@setbutton(slipped&,1)
merkerr=slipped&
errdel=1
ENDIF
IF b=4 THEN
IF merkerr<>0 THEN
@setbutton(merkerr,0)
ENDIF
@setbutton(crc&,1)
merkerr=crc&
errdel=1
ENDIF
IF b=5 THEN
IF merkerr<>0 THEN
@setbutton(merkerr,0)
ENDIF
@setbutton(parity&,1)
merkerr=parity&
errdel=1
ENDIF
IF b=6 THEN
IF merkerr<>0 THEN
@setbutton(merkerr,0)
ENDIF
@setbutton(biphase&,1)
merkerr=biphase&
errdel=1
ENDIF
IF b=7 THEN
IF merkerr<>0 THEN
@setbutton(merkerr,0)
ENDIF
@setbutton(nolock&,1)
merkerr=nolock&
errdel=1
ENDIF
ENDIF
zi=zi+1
IF zi=2000 OR errdel=1 THEN
zi=0
errdel=0
@subframe(TRUE)
@emphasis
a=rwert
@read_statmid
b=rwert      ! Status Mid
IF merk3<>a OR merk4<>b THEN
merk3=a
merk4=b
IF (b AND 4)=4 THEN
@setbutton(prot&,1)
ELSE
@setbutton(prot&,0)
ENDIF
IF (a AND 4)=4 THEN
@setbutton(emph&,0)
ELSE
@setbutton(emph&,1)
ENDIF
IF (b AND 1)=1 THEN
'    "CONSUMER"
@setbutton(use&,0)
ELSE
'    "PROFI"
@setbutton(use&,1)
ENDIF
IF (b AND 2)=2 THEN
'    "DIGITAL"
@setbutton(audio&,1)
ELSE
'    "DATA"
@setbutton(audio&,0)
ENDIF
ENDIF
PAUSE 3
@subframe(FALSE)
ENDIF
ENDIF
RETURN
'
> PROCEDURE textfeld(txtname,txt$,versatz)
IF mrkhandle=mrkhandle2 THEN
v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
IF v<>0 AND kenn=mrkhandle2 THEN
~@xrsrc_gaddr(0,nr,zu%)
string=LPEEK(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
POKE string+it-1+(versatz-1),ASC(MID$(txt$,it,1))
NEXT it
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,txtname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
RETURN
'
> PROCEDURE setbutton(buttnr,buttflag)
IF mrkhandle=mrkhandle2 THEN
v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
IF v<>0 AND kenn=mrkhandle2 THEN
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
RETURN
'
> PROCEDURE readbutton(buttnr)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+10)
RETURN
'
> PROCEDURE readpos(buttnr)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
bx=DPEEK(buttadr+16)
by=DPEEK(buttadr+18)
RETURN
'
> PROCEDURE colorbox(nrr,buttnr)
~@xrsrc_gaddr(0,nrr,zu%)
buttadr=zu%+24*buttnr
colflag=DPEEK(buttadr+14)
colmerk=(colflag AND 15)
colflag=(colflag AND &HFFF0)
'  colflag=(colflag AND &HFF8F)+&H40
DPOKE buttadr+14,colflag
RETURN
'
> PROCEDURE editread(edread)
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edread+12
erd=LPEEK(LPEEK(editadr))
a$=""
WHILE PEEK(erd)<>0
bv$=CHR$(PEEK(erd))
a$=a$+bv$
erd=erd+1
WEND
RETURN
'
> PROCEDURE findbutton(buttnr)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=(zu%+24*buttnr)+10
RETURN
'
> PROCEDURE editfeld(edname,ed$)
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edname+12
edanf=LPEEK(LPEEK(editadr))
'  FOR ef=0 TO LEN(edw$)-1
'  POKE edanf+ef,32
' NEXT ef
edz=LEN(ed$)
FOR ef=1 TO edz
ap=ASC(MID$(ed$,ef,1))
POKE edanf+ef-1,ap
NEXT ef
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,edname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE exit
IF cwerte1>0 THEN
~MFREE(cwert)
ENDIF
IF merkfrei>0 THEN
~MFREE(merkfrei)
ENDIF
IF mdatf2>0 THEN
~MFREE(mdatf2)
ENDIF
IF mdatf>0 THEN
~MFREE(mdatf)
ENDIF
IF big=0 AND anfloadx>0 THEN
~MFREE(anfloadx)
ENDIF
IF EXIST(virt$) THEN
KILL virt$
ENDIF
IF EXIST(virt2$) THEN
KILL virt2$
ENDIF
RETURN
