0000
demo=FALSE
'
' ON ERROR GOSUB fehler
'
' ------------------------------------------------------------------------------
' -------STARTRAK.PRG   Sample-Editor & Midi-Player for VME-Atari's-------------
' ----------------------for VME_SMP16 VME-16Bit Stereo-Harddisksampler----------
' ------------mit integrierter Interruptsteuerung Åber XBIOS-Erweiterung--------
' ------------------------First Release 22.8.1994-------------------------------
' ------------------------------------------------------------------------------
' ---------------------V 1.0 - Revision 23.03.1996 Alpha-Stadium----------------
' ------------------------------------------------------------------------------
'
' ------------------------------------------------------------------------------
' ------------------------STARTRACK-REGISTER------------------------------------
' ------------------------------------------------------------------------------
'
' READ  401h   Status Low                          Bit 0-2,7 -> MAGICVOL,MAGICXLR,MAGICDIGI,MAGICADDA
'
'                                 0  MAGICVOL    - 0=kein zweiter Volume-Controller fÅr Ausgang vorhanden
'                                                  1=zweiter Volume-Controller fÅr Ausgang vorhanden
'                                 1  MAGICXLR    - 0=keine XLR-Erweiterung vorhanden
'                                                  1=XLR-Erweiterung vorhanden
'                                 2  MAGICDIGI   - 0=keine digitalen Schnittstellen vorhanden
'                                                  1=digitale Schnittstellen vorhanden
'                                 6  MAGICHS96   - 0=keine 96KHz-Highsampling,Takt kommt von ICLK-Anschluss
'                                                  1=96KHz-Highsampling mîglich,interne Taktverdopplung des 18.432MHz-Taktes
'                                 7  MAGICADDA   - 0=keine A/D und D/A-Wandler vorhanden
'                                                  1=A/D und D/A-Wandler vorhanden
'
'
'
' WRITE 401h   Register Low  Bytewide              Bit0-7 -> SWAES,SWDIGIN,TAKT0,TAKT1,EXTAKT,EXTEX,EXTTF,EXTTW
'
'                                 0  SWAES       - 0=digitaler Eingang, 1=Analogeingang
'                                 1  SWDIGIN     - 0=optischer Digitaleingang, 1=koaxialer Digitaleingang
'                               2,3  TAKT0,TAKT1 - 0=Takt vom A/D & D/A, 1=32khz, 2=44.1khz, 3=48khz
'                                                  Wird ein externer Takt eingespeist wird das Signal TAKT0 miûbraucht, um
'                                                  zwischen 256/384facher Teilung des Mastertaktes umzuschalten. Das Ergebnis sind
'                                                  die Samples/s
'                                                  TAKT0:  0=256facher Takt, 1=384facher Takt
'                                 4  EXTAKT      - 0=intern generierter MCLK-Takt, 1=Åber EXTMCLK zugefÅhrter 256/384facher
'                                                    Sampletakt
'
'                                 folgende Register wirken nur in Verbindung mit EXTAKT=1, also extern zugefÅhrter Takt
'
'                                 5  EXTEX       - 0=internen MCLK-Takt fÅr Taktteiler nutzen (16.9344/24.576 MHz)
'                                                  1=extern Åber EXTMCLK zugefÅhrten MCLK fÅr Taktteiler nutzen
'                                 6  EXTTF       - 0=durch 2(bei EXTEX=0) geteilten Takt fÅr EXTMCLK nutzen. Bei EXTEX=1 keine
'                                                    Teilung
'                                                - 1=durch 4(bei EXTEX=0) geteilten Takt fÅr EXTMCLK nutzen. Bei EXTEX=1 Teilung
'                                                    durch 2
'                                 7  EXTTW       - 0=16.9344 MHz, 1=12.288MHz fÅr Taktteiler - nur in Verbindung mit EXTEX=0
'                                                    relevant
'
'
'
' READ  421h   Status Mid                          Bit0-2,7 -> ERR0,ERR1,ERR2,EMPH
'
'            wenn  SUBFR=0        0  ERR0        - Fehlercodes vom Digitaleingang
'            wenn  SUBFR=0        1  ERR1        - Fehlercodes vom Digitaleingang
'            wenn  SUBFR=0        2  ERR2        - Fehlercodes vom Digitaleingang
'                                                  Fehlercodes: 0=no error, 1=validity bit high, 2=confidence flag,
'                                                               3=slipped sample
'                                                               4=CRC-error, 5=parity-error, 6=Bi-Phase coding error, 7=no lock
'                                                               (siehe auch CS8412-Manual)
'
'            wenn  SUBFR=1        0  USE         - 0=Profi, 1=Consumer
'            wenn  SUBFR=1        1  AUDIO       - 0=DATA, 1=Audio
'            wenn  SUBFR=1        2  PROT        - 0=no Copy-prohibit - SCMS not active, 1=Copy prohibit - SCMS is active
'            wenn  SUBFR=1        7  EMPH        - 0=no emphasis, 1=emphasis is active
'
'
' READ  441h   Status High                         Bit0-2 -> FIFO-WRempty,FIFO-WRhalf,FIFO-WRfull
'                                                  Die Flags des Play-FIFOs
'                                 0  WRempty     - 0=FIFO leer, muû nachgefÅllt werden sonst Datenverlust
'                                 1  WRhalf      - 0=FIFO mehr als halb gefÅllt, 1=FIFO weniger/bis halb gefÅllt, lîst
'                                                  auch INT aus
'                                 2  WRfull      - 0=FIFO voll, weiterschreiben wird mit Datenverlust bestraft :-)
'
' WRITE 441h   Register High  Bytewide             Bit0-7 -> SWPROT,SWRES-FIFO,SWDIGOUT,SWSUBFR,PREEMPH,GENERA,CATEG0,CATEG1
'
'                                 0  SWPROT(C2)  - 0=SCMS-Copybit aktiv, 1=SCMS-Copybit entfernen - Digitalkopie erlaubt (Bit C2)
'                                                  Wenn SWPROT=1 ist und der Categorycode 11 (DAT) ist,
'                                                  hat das GENERA-Bit keine Bedeutung
'                                                  und der Kopierschutz ist vollstÑndig entfernt.
'                                                  Wenn SWPROT=0 ist und der Categorycode 11 (DAT) ist, und das
'                                                  GENERA-Bit 1 ist, dann kann nach der öberspielung noch einmal kopiert werden.
'                                                  Wenn SWPROT=1 ist und der Categorycode 00 (General) ist, und das
'                                                  GENERA-Bit 0 ist, dann
'                                                  kann nach der öberspielung nicht mehr digital Åberspielt werden (SCMS)
'                                 1  SWRES-FIFO  - 0=REC-FIFO-Reset deaktiviert, 1=REC-FIFO-Reset aktiv - muû manuell
'                                                  rÅckgesetzt werden
'                                 2  SWDIGOUT    - 0=D/A und DigitalausgÑnge geben Daten vom A/D bzw. Digitaleingang wieder
'                                                  1=D/A und DigitalausgÑnge geben Daten vom Play-FIFO wieder
'                                 3  SWSUBFR(SEL)- 0=Error information des Digitaleingangs (siehe Status Mid: ERR0,ERR1,ERR2)
'                                                  1=Channel status information des Digitaleingangs (siehe Status Mid: USE,
'                                                  AUDIO,PROT)
'
'                                                  Die folgenden Bits PREEMPH,CATEG0,CATEG1 & GENERA wirken nur bei
'                                                  Sampler-PLAY auf den
'                                                  Digitalausgang und nicht bei direkten DigitalÅberspielungen als SCMS-Dekoder
'                                 4  PREEMPH(C3) - 0=Preemphasis aus, 1=Preemphasis an, nur wirksam bei Digital-Ausgang (Bit C3)
'                                 5  GENERA(C15) - 0=no indication, einmal kopierbar 1=orginal/nicht kopierbar
'                                                  Das GENERA-Bit hat nur eine Bedeutung, wenn Digitalkopie erlaubt, also SWPROT=1
'                                                  und der Categorycode 00 ist, dann kann 1x kopiert werden
'                                 6  CATEG0(C8)  - Categorycode
'                                 7  CATEG1(C9)  - Categorycode
'                                                  00=General, 01=PCM encoder/decoder, 10=laser optical(CD,MD),
'                                                  11=magnetic tape(DAT,DCC)
'                                 Im Professional-Mode haben einige Leitungen andere Bedeutungen. Alle wichtigen Steuerleitungen
'                                 sind vorhanden um auch den Professional-Mode nutzen zu kînnen. Damit sind auch AES/EBU-
'                                 AnschlÅsse denkbar.'
'
'
' READ  461h   Status xHigh                        Bit0-2 -> FIFO-RDempty,FIFO-RDhalf,FIFO-RDfull
'                                                  Die Flags des Record-FIFOs
'                                 0  RDempty     - 0=FIFO leer, weiterlesen wird mit Zufallsdaten bestraft
'                                 1  RDhalf      - 0=FIFO mehr als halb gefÅllt, 1=FIFO weniger/bis halb gefÅllt,
'                                                  lîst auch INT aus
'                                 2  RDfull      - 0=FIFO voll, muû ausgelesen werden sonst Datenverlust
'
'
' WRITE 481h   DSP-Register  Bytewide              Bit0-7 -> DSPON,DSPIN,VOLCS1,VOLCLK,VOLDATAI(CKS wenn EXTAKT=1),VOLCS2,AESC24,AESC25
'
'                                 0  DSPON       - 0=DSP-Ausgang nicht im Signalweg
'                                                    Bearbeitung der Eingangsdaten Åber DSP-Eingang (digital-in oder A/D)
'                                                    ist mîglich
'                                                  1=DSP-Ausgang im Signalweg, Ausgabe der DSP-Daten im Record oder Play-Zweig
'                                 1  DSPIN       - 0=DSP-Ausgang einschleifen im Record-Zweig
'                                                  1=DSP-Ausgang einschleifen im Play-Zweig
'                                 2  VOLCS1      - /CS-Signal fÅr A/D Volume-Controller
'                                 3  VOLCLK      - Clock-Signal fÅr Volume-Controller um Volume-Daten 8Bit Stereo l/r einzutakten
'                                 4  VOLDATAI    - Dateneingang des Volume-Controllers
'                                 5  VOLCS2      - /CS-Signal fÅr D/A Volume-Controller
'                                 6  AESC24      - Zeigt die Samplerate des Digital-Eingangssignals an (dekodiert dafÅr das
'                                 7  AESC25        Eingangssignal)
'                                                  0=44.1khz, 2=48khz, 3=32khz
'
'
'
' WRITE 4C1h   AES-Register  Bytewide              Bit0,1,7 -> SWPROF,SWCOPY,SPEBU
'
'                                 0  SWPROF      - 0=Consumer-Mode und Transparent-Mode
'                                                  1=Professional-Mode
'                                 1  SWCOPY      - 0=SCMS-Kopierschutz im Kopiermodus vollstÑndig entfernen
'                                                  1=SCMS-Kopierschutz erlaubt im Kopiermodus nur eine Kopie, danach ist
'                                                    SCMS wieder drinn
'                                 2  SWMAL2      - 0=normalen externen Takt benutzen
'                                                  1=externen Takt verdoppeln fÅr HighSampling mit 96KHz
'                                                    (18.432x2 = 36.864 MHz / 384 = 96000KHz)
'                                 7  SPEBU       - 0=SP/DIF-AnschlÅsse nutzen
'                                                  1=AES/EBU-ProfianschlÅsse nutzen
'
'
' RD/WR 501h  DSP-ChipSelect  Bytewide
'
'                               0-7  DSP-DATA    - /CS fÅr den DSP. Der DSP hat 8 Hostregister von 501h-50Fh. Das spiegelt sich im
'                                                  Adreûbereich bis 17Fh. Die HI-Register ICR,CVR,ISR,IVR,RXH,RXM,RXL bzw.
'                                                  ICR,CVR,ISR,IVR,TXH,TXM,TXL sind hierÅber zu erreichen.
'
' RD/WR 541h  SMPTE             0-7  SMPTE-DATA  - Bereich fÅr optionalen SMPTE-Coder/Decoder
'
'
' RD/WR 581h  Interrupt-Freigabe  Bytewide         Bit 0,1 -> PLAY-INT,REC-INT
'
'                                                  Der Startrack-Sampler erzeugt getrennte Vektoren fÅr Aufnahme und Wiedergabe
'                                                  Soll eine Interruptgesteuerte Aufnahme/Wiedergabe gestartet werden muû dafÅr
'                                                  eine Interruptroutine geschrieben/installiert werden. Das ganze wird aber erst
'                                                  gestartet, wenn das zustÑndige INT-Register gesetzt wird.
'                                                  Die Aufnahme/Wiedergabe kann durch RÅcksetzen des zustÑndigen INT-Registers
'                                                  gestoppt werden.
'                                  0  PLAY-INT   - 0=kein Play-Interrupt, 1=PLAY-Interrupt aktiviert bzw. ausgelîst
'                                                  Vector Nr.122
'                                  1  REC-INT    - 0=kein Record-Interrupt, 1=Record-Interrupt aktiviert bzw. ausgelîst
'                                                  Vector Nr.123
'
'
' RD/WR 600h   Sample Read/Write  Wordwide
'
'                               0-8  FIFO        - Hier werden die Samples eingeschrieben oder ausgelesen, und zwar in
'                                                  8Bit-HÑppchen
'                                                  Beim Lesen (REC) mit einer Kennung im Bit8 die anzeigt, ob das Sample zum
'                                                  linken oder rechten Kanal gehîrt.
'                                                  Bit8=0 - Rechter Kanal
'                                                  Bit8=1 - Linker Kanal
'                                                  Beim Schreiben werden auch 8Bit-HÑppchen geschrieben, dabei zeigt Adreûleitung
'                                                  A1 an, ob der rechte oder linke Kanal Åbertragen wird.
'                                                  A1=0 - Rechter Kanal
'                                                  A1=1 - Linker Kanal
'                                                  Zuerst wird das Highbyte des 16Bit-Samples geschrieben/gelesen, und dann
'                                                  das Lowbyte.
'
'
'
'
' Sample-Editor zum STARTRACK-Sampler
'
' Bedienung aller wichtiger Parameter des 16Bit-Stereo-Samplers und Sample-Editor/Arranger
'
CLIP OFF
compile=BYTE{ADD(BASEPAGE,256)}<>96
acc=({ADD(BASEPAGE,36)}=0)
INLINE m_busy%,592
m_adr%=m_busy%
xwidth=WORK_OUT(0)+1
ywidth=WORK_OUT(1)+1
@busy_mouse
'
' ------------------------------------------------------------------------------
' ------------------------RSC-VARIABLEN-----------------------------------------
' ------------------------------------------------------------------------------
REM Resource Datei Indizes fÅr STARTRAK
'
LET smp16&=0 ! Formular/Dialog
LET mainbox&=0 ! BOX in Baum SMP16
LET exit&=1 ! BUTTON in Baum SMP16
LET mainbox2&=2 ! BOX in Baum SMP16
LET emph&=4 ! BUTTON in Baum SMP16
LET audio&=5 ! BUTTON in Baum SMP16
LET use&=6 ! BUTTON in Baum SMP16
LET smp32&=8 ! BUTTON in Baum SMP16
LET smp44&=9 ! BUTTON in Baum SMP16
LET smp48&=10 ! BUTTON in Baum SMP16
LET noval&=12 ! BUTTON in Baum SMP16
LET confid&=13 ! BUTTON in Baum SMP16
LET parity&=14 ! BUTTON in Baum SMP16
LET biphase&=15 ! BUTTON in Baum SMP16
LET nolock&=16 ! BUTTON in Baum SMP16
LET prot&=18 ! BUTTON in Baum SMP16
LET mainbox5&=19 ! BOX in Baum SMP16
LET ydsp&=20 ! STRING in Baum SMP16
LET dsp&=21 ! BOXTEXT in Baum SMP16
LET dspcirc&=22 ! BOXCHAR in Baum SMP16
LET mainbox6&=23 ! BOX in Baum SMP16
LET input&=25 ! BOXTEXT in Baum SMP16
LET incirc&=26 ! BOXCHAR in Baum SMP16
LET rate2&=28 ! BOXTEXT in Baum SMP16
LET ratecir2&=29 ! BOXCHAR in Baum SMP16
LET helporig&=30 ! BOXTEXT in Baum SMP16
LET mainbox4&=31 ! BOX in Baum SMP16
LET source&=33 ! BOXTEXT in Baum SMP16
LET srccirc&=34 ! BOXCHAR in Baum SMP16
LET protect&=36 ! BOXTEXT in Baum SMP16
LET protcirc&=37 ! BOXCHAR in Baum SMP16
LET mode&=39 ! BOXTEXT in Baum SMP16
LET modecirc&=40 ! BOXCHAR in Baum SMP16
LET emphasis&=42 ! BOXTEXT in Baum SMP16
LET emphcirc&=43 ! BOXCHAR in Baum SMP16
LET bridge&=44 ! BUTTON in Baum SMP16
'
LET smpedit&=1 ! Formular/Dialog
LET editbox7&=0 ! BOX in Baum SMPEDIT
LET editbox&=2 ! BOX in Baum SMPEDIT
LET smplen&=3 ! BOXTEXT in Baum SMPEDIT
LET smpsec&=4 ! BOXTEXT in Baum SMPEDIT
LET smpexit&=7 ! BUTTON in Baum SMPEDIT
LET rate&=9 ! BOXTEXT in Baum SMPEDIT
LET ratecirc&=10 ! BOXCHAR in Baum SMPEDIT
LET editbox6&=11 ! BOX in Baum SMPEDIT
LET smppmark&=12 ! USERDEF in Baum SMPEDIT
LET midi&=13 ! USERDEF in Baum SMPEDIT
LET mintext&=14 ! BOXTEXT in Baum SMPEDIT
LET smploop&=16 ! USERDEF in Baum SMPEDIT
LET smpfile&=17 ! BOXTEXT in Baum SMPEDIT
LET smprate&=18 ! BOXTEXT in Baum SMPEDIT
LET editbox5&=19 ! BOX in Baum SMPEDIT
LET mover&=20 ! BOXTEXT in Baum SMPEDIT
LET movecirc&=21 ! BOXCHAR in Baum SMPEDIT
LET smpcblk&=22 ! USERDEF in Baum SMPEDIT
LET trash&=23 ! USERDEF in Baum SMPEDIT
LET editbox3&=25 ! BOX in Baum SMPEDIT
LET editbox8&=26 ! BOX in Baum SMPEDIT
LET smpsta&=27 ! BUTTON in Baum SMPEDIT
LET smpstb&=28 ! BUTTON in Baum SMPEDIT
LET smpstc&=29 ! BUTTON in Baum SMPEDIT
LET smpstd&=30 ! BUTTON in Baum SMPEDIT
LET smpste&=31 ! BUTTON in Baum SMPEDIT
LET editbox9&=32 ! BOX in Baum SMPEDIT
LET hacksa&=33 ! BOXTEXT in Baum SMPEDIT
LET hacksb&=34 ! BOXTEXT in Baum SMPEDIT
LET hacksc&=35 ! BOXTEXT in Baum SMPEDIT
LET hacksd&=36 ! BOXTEXT in Baum SMPEDIT
LET hackse&=37 ! BOXTEXT in Baum SMPEDIT
LET hackss&=38 ! BOXTEXT in Baum SMPEDIT
LET smptsa&=39 ! BOXTEXT in Baum SMPEDIT
LET smptsb&=40 ! BOXTEXT in Baum SMPEDIT
LET smptsc&=41 ! BOXTEXT in Baum SMPEDIT
LET smptsd&=42 ! BOXTEXT in Baum SMPEDIT
LET smptse&=43 ! BOXTEXT in Baum SMPEDIT
LET smptsava&=44 ! BOXTEXT in Baum SMPEDIT
LET smpsavl&=46 ! BUTTON in Baum SMPEDIT
LET editbox4&=47 ! BOX in Baum SMPEDIT
LET editbx10&=48 ! BOX in Baum SMPEDIT
LET smpea&=49 ! BUTTON in Baum SMPEDIT
LET smpeb&=50 ! BUTTON in Baum SMPEDIT
LET smpec&=51 ! BUTTON in Baum SMPEDIT
LET smped&=52 ! BUTTON in Baum SMPEDIT
LET smpee&=53 ! BUTTON in Baum SMPEDIT
LET editbx11&=54 ! BOX in Baum SMPEDIT
LET hackea&=55 ! BOXTEXT in Baum SMPEDIT
LET hackeb&=56 ! BOXTEXT in Baum SMPEDIT
LET hackec&=57 ! BOXTEXT in Baum SMPEDIT
LET hacked&=58 ! BOXTEXT in Baum SMPEDIT
LET hackee&=59 ! BOXTEXT in Baum SMPEDIT
LET hackes&=60 ! BOXTEXT in Baum SMPEDIT
LET smptea&=61 ! BOXTEXT in Baum SMPEDIT
LET smpteb&=62 ! BOXTEXT in Baum SMPEDIT
LET smptec&=63 ! BOXTEXT in Baum SMPEDIT
LET smpted&=64 ! BOXTEXT in Baum SMPEDIT
LET smptee&=65 ! BOXTEXT in Baum SMPEDIT
LET smptsavb&=66 ! BOXTEXT in Baum SMPEDIT
LET smpsavr&=68 ! BUTTON in Baum SMPEDIT
LET coptoarr&=70 ! USERDEF in Baum SMPEDIT
LET coptotxt&=71 ! BOXTEXT in Baum SMPEDIT
LET smpedhlp&=72 ! BOXTEXT in Baum SMPEDIT
LET zomslide&=73 ! BOX in Baum SMPEDIT
LET zoombutt&=74 ! BUTTON in Baum SMPEDIT
LET cstxt&=77 ! BOXTEXT in Baum SMPEDIT
LET cetxt&=78 ! BOXTEXT in Baum SMPEDIT
LET pixzoom&=80 ! USERDEF in Baum SMPEDIT
LET showxy&=81 ! BOXTEXT in Baum SMPEDIT
LET pntprsmp&=82 ! BOXTEXT in Baum SMPEDIT
LET freemem&=83 ! BOXTEXT in Baum SMPEDIT
LET clock&=84 ! BOXTEXT in Baum SMPEDIT
LET smpname&=85 ! BOXTEXT in Baum SMPEDIT
LET smpundo&=86 ! BOXTEXT in Baum SMPEDIT
LET flyer&=88 ! USERDEF in Baum SMPEDIT
LET smpr1&=89 ! USERDEF in Baum SMPEDIT
LET smpl1&=90 ! USERDEF in Baum SMPEDIT
LET smpl2&=91 ! USERDEF in Baum SMPEDIT
LET smpr2&=92 ! USERDEF in Baum SMPEDIT
LET smpl3&=93 ! USERDEF in Baum SMPEDIT
LET smpanf&=94 ! USERDEF in Baum SMPEDIT
LET smpend&=95 ! USERDEF in Baum SMPEDIT
LET smpmid&=96 ! USERDEF in Baum SMPEDIT
LET smpr3&=97 ! USERDEF in Baum SMPEDIT
LET zooml&=98 ! USERDEF in Baum SMPEDIT
LET zoomr&=99 ! USERDEF in Baum SMPEDIT
LET editbox2&=100 ! BOX in Baum SMPEDIT
LET setuper&=101 ! USERDEF in Baum SMPEDIT
LET edfade&=102 ! USERDEF in Baum SMPEDIT
LET peaksw2&=103 ! USERDEF in Baum SMPEDIT
LET monitor&=104 ! USERDEF in Baum SMPEDIT
LET smpauto2&=105 ! USERDEF in Baum SMPEDIT
LET smpstrt2&=106 ! USERDEF in Baum SMPEDIT
LET smpplay&=107 ! USERDEF in Baum SMPEDIT
LET loopart&=108 ! USERDEF in Baum SMPEDIT
LET blocfunc&=109 ! USERDEF in Baum SMPEDIT
LET hard&=110 ! USERDEF in Baum SMPEDIT
LET arrange&=111 ! USERDEF in Baum SMPEDIT
LET smpload&=112 ! USERDEF in Baum SMPEDIT
LET smpsave&=113 ! USERDEF in Baum SMPEDIT
LET infoicon&=114 ! USERDEF in Baum SMPEDIT
LET edmidi&=115 ! USERDEF in Baum SMPEDIT
LET trak&=116 ! USERDEF in Baum SMPEDIT
LET edsmp16&=117 ! USERDEF in Baum SMPEDIT
LET swdsp&=118 ! USERDEF in Baum SMPEDIT
LET smpdbank&=119 ! USERDEF in Baum SMPEDIT
LET rm80&=125 ! TEXT in Baum SMPEDIT
LET rp0&=126 ! TEXT in Baum SMPEDIT
LET rp80&=127 ! TEXT in Baum SMPEDIT
LET rp60&=128 ! TEXT in Baum SMPEDIT
LET rp40&=129 ! TEXT in Baum SMPEDIT
LET rm60&=130 ! TEXT in Baum SMPEDIT
LET rm40&=131 ! TEXT in Baum SMPEDIT
LET lp80&=132 ! TEXT in Baum SMPEDIT
LET lm80&=133 ! TEXT in Baum SMPEDIT
LET lp40&=134 ! TEXT in Baum SMPEDIT
LET lp60&=135 ! TEXT in Baum SMPEDIT
LET lm60&=136 ! TEXT in Baum SMPEDIT
LET lm40&=137 ! TEXT in Baum SMPEDIT
LET lm20&=138 ! TEXT in Baum SMPEDIT
LET lp0&=139 ! TEXT in Baum SMPEDIT
LET rp20&=140 ! TEXT in Baum SMPEDIT
LET rm20&=141 ! TEXT in Baum SMPEDIT
LET lp20&=142 ! TEXT in Baum SMPEDIT
LET scrlslde&=143 ! BOX in Baum SMPEDIT
LET scrolbut&=144 ! BUTTON in Baum SMPEDIT
LET recplay3&=145 ! USERDEF in Baum SMPEDIT
LET lscroll&=146 ! USERDEF in Baum SMPEDIT
LET rscroll&=147 ! USERDEF in Baum SMPEDIT
'
LET dspedit&=2 ! Formular/Dialog
LET dspbox&=0 ! BOX in Baum DSPEDIT
LET dspecho&=3 ! BUTTON in Baum DSPEDIT
LET dsphall&=4 ! BUTTON in Baum DSPEDIT
LET dsplow&=5 ! BUTTON in Baum DSPEDIT
LET dsphigh&=6 ! BUTTON in Baum DSPEDIT
LET dspband&=7 ! BUTTON in Baum DSPEDIT
LET dspflang&=8 ! BUTTON in Baum DSPEDIT
LET dspchor&=9 ! BUTTON in Baum DSPEDIT
LET dspeq&=10 ! BUTTON in Baum DSPEDIT
LET dsppink&=11 ! BUTTON in Baum DSPEDIT
LET dsppass&=12 ! BUTTON in Baum DSPEDIT
LET dspload&=13 ! BUTTON in Baum DSPEDIT
LET dspsave&=14 ! BUTTON in Baum DSPEDIT
LET helpdsp&=15 ! BOXTEXT in Baum DSPEDIT
LET dspexit&=16 ! BUTTON in Baum DSPEDIT
'
LET peak&=3 ! Formular/Dialog
LET peakbox&=0 ! BOX in Baum PEAK
LET plmax&=4 ! BUTTON in Baum PEAK
LET prmax&=5 ! BUTTON in Baum PEAK
LET peakbox2&=6 ! BOX in Baum PEAK
LET volbox&=17 ! BOX in Baum PEAK
LET volume&=18 ! USERDEF in Baum PEAK
LET smpautop&=20 ! USERDEF in Baum PEAK
LET smpstrtp&=21 ! USERDEF in Baum PEAK
LET playpeak&=22 ! USERDEF in Baum PEAK
LET peakexit&=23 ! BUTTON in Baum PEAK
LET peakpos&=24 ! BOXTEXT in Baum PEAK
LET peakmax&=25 ! BOXTEXT in Baum PEAK
LET recerror&=28 ! BOXTEXT in Baum PEAK
LET peakhelp&=30 ! BOXTEXT in Baum PEAK
LET balbox&=31 ! BOXTEXT in Baum PEAK
LET balance&=32 ! USERDEF in Baum PEAK
LET peakl&=34 ! USERDEF in Baum PEAK
LET peakr&=35 ! USERDEF in Baum PEAK
LET recpeaks&=36 ! BOXTEXT in Baum PEAK
LET peakdb&=39 ! BOXTEXT in Baum PEAK
LET peakmute&=40 ! USERDEF in Baum PEAK
LET balzero&=41 ! USERDEF in Baum PEAK
LET peakbal&=42 ! BOXTEXT in Baum PEAK
LET monitorp&=65 ! USERDEF in Baum PEAK
LET hardpeak&=66 ! USERDEF in Baum PEAK
'
LET loop&=4 ! Formular/Dialog
LET loopbox&=0 ! BOX in Baum LOOP
LET loopexit&=1 ! BUTTON in Baum LOOP
LET forw&=3 ! BUTTON in Baum LOOP
LET cross&=4 ! BUTTON in Baum LOOP
LET backw&=5 ! BUTTON in Baum LOOP
LET helploop&=7 ! BOXTEXT in Baum LOOP
LET autoloop&=8 ! BUTTON in Baum LOOP
'
LET normaliz&=5 ! Formular/Dialog
LET normbox&=0 ! BOX in Baum NORMALIZ
LET normok&=2 ! BUTTON in Baum NORMALIZ
LET normexit&=3 ! BUTTON in Baum NORMALIZ
LET maxdb&=4 ! BOXTEXT in Baum NORMALIZ
LET normauto&=7 ! BUTTON in Baum NORMALIZ
LET normadj&=8 ! BUTTON in Baum NORMALIZ
LET norml1&=10 ! USERDEF in Baum NORMALIZ
LET norml2&=11 ! USERDEF in Baum NORMALIZ
LET norml3&=12 ! USERDEF in Baum NORMALIZ
LET normr1&=13 ! USERDEF in Baum NORMALIZ
LET normr2&=14 ! USERDEF in Baum NORMALIZ
LET normr3&=15 ! USERDEF in Baum NORMALIZ
LET helpnorm&=16 ! BOXTEXT in Baum NORMALIZ
LET normdb&=18 ! BOXTEXT in Baum NORMALIZ
'
LET resample&=6 ! Formular/Dialog
LET resmpbox&=0 ! BOX in Baum RESAMPLE
LET adjresmp&=1 ! BUTTON in Baum RESAMPLE
LET helprsmp&=2 ! BOXTEXT in Baum RESAMPLE
LET rsmptxt1&=3 ! TEXT in Baum RESAMPLE
LET resmpbx2&=4 ! BOX in Baum RESAMPLE
LET restxt&=5 ! FTEXT in Baum RESAMPLE
LET resmpsec&=6 ! BOXTEXT in Baum RESAMPLE
LET resmplen&=7 ! BOXTEXT in Baum RESAMPLE
LET resmpfac&=8 ! BOXTEXT in Baum RESAMPLE
LET rsmptxt2&=10 ! TEXT in Baum RESAMPLE
LET resother&=11 ! BOXTEXT in Baum RESAMPLE
LET resok&=12 ! BUTTON in Baum RESAMPLE
LET resexit&=13 ! BUTTON in Baum RESAMPLE
LET res32&=15 ! BUTTON in Baum RESAMPLE
LET res44&=16 ! BUTTON in Baum RESAMPLE
LET res48&=17 ! BUTTON in Baum RESAMPLE
LET resr3&=18 ! USERDEF in Baum RESAMPLE
LET resr2&=19 ! USERDEF in Baum RESAMPLE
LET resr1&=20 ! USERDEF in Baum RESAMPLE
LET resl1&=21 ! USERDEF in Baum RESAMPLE
LET resl2&=22 ! USERDEF in Baum RESAMPLE
LET resl3&=23 ! USERDEF in Baum RESAMPLE
'
LET midiedit&=7 ! Formular/Dialog
LET midibox&=0 ! BOX in Baum MIDIEDIT
LET notetxt&=1 ! BOXTEXT in Baum MIDIEDIT
LET chtxt&=3 ! BOXTEXT in Baum MIDIEDIT
LET midiok&=5 ! BUTTON in Baum MIDIEDIT
LET helpmidi&=7 ! BOXTEXT in Baum MIDIEDIT
LET midinup&=10 ! USERDEF in Baum MIDIEDIT
LET midioup&=11 ! USERDEF in Baum MIDIEDIT
LET midindwn&=12 ! USERDEF in Baum MIDIEDIT
LET midiodwn&=13 ! USERDEF in Baum MIDIEDIT
LET midicup&=14 ! USERDEF in Baum MIDIEDIT
LET midicdwn&=15 ! USERDEF in Baum MIDIEDIT
'
LET editfade&=8 ! Formular/Dialog
LET fadebox&=0 ! BOX in Baum EDITFADE
LET fadeok&=2 ! BUTTON in Baum EDITFADE
LET fadelin&=4 ! BUTTON in Baum EDITFADE
LET infade&=6 ! BUTTON in Baum EDITFADE
LET ausfade&=7 ! BUTTON in Baum EDITFADE
LET helpfade&=8 ! BOXTEXT in Baum EDITFADE
LET fadexp&=9 ! BUTTON in Baum EDITFADE
LET fadesqrt&=10 ! BUTTON in Baum EDITFADE
LET fadexit&=11 ! BUTTON in Baum EDITFADE
LET fadedel&=12 ! BUTTON in Baum EDITFADE
LET fdsquare&=13 ! BUTTON in Baum EDITFADE
LET fadelog&=14 ! BUTTON in Baum EDITFADE
LET fadload&=15 ! BUTTON in Baum EDITFADE
LET fadsave&=16 ! BUTTON in Baum EDITFADE
'
LET popups&=9 ! Formular/Dialog
LET smppopup&=1 ! BOX in Baum POPUPS
LET rate32&=2 ! STRING in Baum POPUPS
LET rate44&=3 ! STRING in Baum POPUPS
LET rate48&=4 ! STRING in Baum POPUPS
LET rate8&=5 ! STRING in Baum POPUPS
LET rate11&=6 ! STRING in Baum POPUPS
LET rate12&=7 ! STRING in Baum POPUPS
LET rate16&=8 ! STRING in Baum POPUPS
LET rate17&=9 ! STRING in Baum POPUPS
LET rate22&=10 ! STRING in Baum POPUPS
LET rate24&=11 ! STRING in Baum POPUPS
LET rate33&=12 ! STRING in Baum POPUPS
LET ratexth2&=13 ! STRING in Baum POPUPS
LET ratextl2&=14 ! STRING in Baum POPUPS
LET ratexth1&=15 ! STRING in Baum POPUPS
LET ratextl1&=16 ! STRING in Baum POPUPS
LET dsppopup&=17 ! BOX in Baum POPUPS
LET dspoff&=18 ! STRING in Baum POPUPS
LET dspin&=19 ! STRING in Baum POPUPS
LET dspout&=20 ! STRING in Baum POPUPS
LET smppop2&=21 ! BOX in Baum POPUPS
LET ad32&=22 ! STRING in Baum POPUPS
LET ad44&=23 ! STRING in Baum POPUPS
LET ad48&=24 ! STRING in Baum POPUPS
LET ad8&=25 ! STRING in Baum POPUPS
LET ad11&=26 ! STRING in Baum POPUPS
LET ad12&=27 ! STRING in Baum POPUPS
LET ad16&=28 ! STRING in Baum POPUPS
LET ad17&=29 ! STRING in Baum POPUPS
LET ad22&=30 ! STRING in Baum POPUPS
LET ad24&=31 ! STRING in Baum POPUPS
LET ad33&=32 ! STRING in Baum POPUPS
LET adexth2&=33 ! STRING in Baum POPUPS
LET adextl2&=34 ! STRING in Baum POPUPS
LET adexth1&=35 ! STRING in Baum POPUPS
LET adextl1&=36 ! STRING in Baum POPUPS
LET inpop&=37 ! BOX in Baum POPUPS
LET analog&=38 ! STRING in Baum POPUPS
LET digital&=39 ! STRING in Baum POPUPS
LET srcpop&=40 ! BOX in Baum POPUPS
LET opto&=41 ! STRING in Baum POPUPS
LET coax&=42 ! STRING in Baum POPUPS
LET aesebu&=43 ! STRING in Baum POPUPS
LET popmark&=44 ! BOX in Baum POPUPS
LET smpmark&=45 ! STRING in Baum POPUPS
LET smpzoom&=46 ! STRING in Baum POPUPS
LET smpscrol&=47 ! STRING in Baum POPUPS
LET kopy&=48 ! STRING in Baum POPUPS
LET move&=49 ! STRING in Baum POPUPS
LET insert&=50 ! STRING in Baum POPUPS
LET merge&=51 ! STRING in Baum POPUPS
LET fade&=52 ! STRING in Baum POPUPS
LET popmake&=53 ! BOX in Baum POPUPS
LET make32&=54 ! STRING in Baum POPUPS
LET make44&=55 ! STRING in Baum POPUPS
LET make48&=56 ! STRING in Baum POPUPS
LET popform&=57 ! BOX in Baum POPUPS
LET sets16&=58 ! STRING in Baum POPUPS
LET setwav&=59 ! STRING in Baum POPUPS
LET setavr&=60 ! STRING in Baum POPUPS
LET setsnd&=61 ! STRING in Baum POPUPS
LET setsd&=62 ! STRING in Baum POPUPS
LET setau&=63 ! STRING in Baum POPUPS
LET setsmp&=64 ! STRING in Baum POPUPS
LET setall&=65 ! STRING in Baum POPUPS
LET popscms&=66 ! BOX in Baum POPUPS
LET scmsno&=67 ! STRING in Baum POPUPS
LET scmsone&=68 ! STRING in Baum POPUPS
LET scmsfree&=69 ! STRING in Baum POPUPS
LET modepop&=70 ! BOX in Baum POPUPS
LET consumer&=71 ! STRING in Baum POPUPS
LET profess&=72 ! STRING in Baum POPUPS
LET emphpop&=73 ! BOX in Baum POPUPS
LET emphoff&=74 ! STRING in Baum POPUPS
LET emphon&=75 ! STRING in Baum POPUPS
'
LET record&=10 ! Formular/Dialog
LET recbox&=0 ! BOX in Baum RECORD
LET recfree&=1 ! BOXTEXT in Baum RECORD
LET recok&=2 ! BUTTON in Baum RECORD
LET recexit&=3 ! BUTTON in Baum RECORD
LET rechelp&=5 ! BOXTEXT in Baum RECORD
LET timetxt&=9 ! FTEXT in Baum RECORD
LET recl2&=15 ! USERDEF in Baum RECORD
LET recl1&=16 ! USERDEF in Baum RECORD
LET recl0&=17 ! USERDEF in Baum RECORD
LET recr0&=18 ! USERDEF in Baum RECORD
LET recr1&=19 ! USERDEF in Baum RECORD
LET recr2&=20 ! USERDEF in Baum RECORD
'
LET blkfunc&=11 ! Formular/Dialog
LET blkbox&=0 ! BOX in Baum BLKFUNC
LET cutin&=1 ! USERDEF in Baum BLKFUNC
LET cutout&=2 ! USERDEF in Baum BLKFUNC
LET blkexit&=3 ! BUTTON in Baum BLKFUNC
LET blkhelp&=5 ! BOXTEXT in Baum BLKFUNC
LET cutdel&=6 ! USERDEF in Baum BLKFUNC
LET norm&=10 ! USERDEF in Baum BLKFUNC
LET resmp&=11 ! USERDEF in Baum BLKFUNC
LET mono&=12 ! USERDEF in Baum BLKFUNC
LET conmix&=13 ! USERDEF in Baum BLKFUNC
LET conins&=14 ! USERDEF in Baum BLKFUNC
LET conspace&=15 ! USERDEF in Baum BLKFUNC
LET negate&=23 ! USERDEF in Baum BLKFUNC
LET lrchange&=25 ! USERDEF in Baum BLKFUNC
'
LET savebloc&=12 ! Formular/Dialog
LET savebox&=0 ! BOX in Baum SAVEBLOC
LET savall&=1 ! USERDEF in Baum SAVEBLOC
LET savblock&=2 ! USERDEF in Baum SAVEBLOC
LET savexit&=3 ! BUTTON in Baum SAVEBLOC
LET savetxt&=4 ! TEXT in Baum SAVEBLOC
LET savehelp&=5 ! BOXTEXT in Baum SAVEBLOC
'
LET arranger&=13 ! Formular/Dialog
LET arrbox&=0 ! BOX in Baum ARRANGER
LET arrbox2&=1 ! BOX in Baum ARRANGER
LET hlpedit2&=2 ! USERDEF in Baum ARRANGER
LET hardmerg&=3 ! USERDEF in Baum ARRANGER
LET arrload&=4 ! USERDEF in Baum ARRANGER
LET arrsave&=5 ! USERDEF in Baum ARRANGER
LET arrplay&=6 ! USERDEF in Baum ARRANGER
LET arrmidi&=7 ! USERDEF in Baum ARRANGER
LET arrins&=8 ! USERDEF in Baum ARRANGER
LET arrdel&=9 ! USERDEF in Baum ARRANGER
LET arrdelay&=10 ! USERDEF in Baum ARRANGER
LET smpauto3&=12 ! USERDEF in Baum ARRANGER
LET smpstrt3&=13 ! USERDEF in Baum ARRANGER
LET pause&=14 ! USERDEF in Baum ARRANGER
LET rewind&=15 ! USERDEF in Baum ARRANGER
LET stop&=16 ! USERDEF in Baum ARRANGER
LET recplay&=17 ! USERDEF in Baum ARRANGER
LET smpplay2&=18 ! USERDEF in Baum ARRANGER
LET smprplay&=19 ! USERDEF in Baum ARRANGER
LET forward&=20 ! USERDEF in Baum ARRANGER
LET arrstrt&=21 ! USERDEF in Baum ARRANGER
LET arrend&=22 ! USERDEF in Baum ARRANGER
LET arrbox4&=23 ! BOX in Baum ARRANGER
LET playlen&=24 ! BOXTEXT in Baum ARRANGER
LET arreal&=25 ! USERDEF in Baum ARRANGER
LET arrbox3&=27 ! BOX in Baum ARRANGER
LET arrbox5&=28 ! BOX in Baum ARRANGER
LET hardfs1&=29 ! BUTTON in Baum ARRANGER
LET spur1&=30 ! BOXTEXT in Baum ARRANGER
LET arrbox6&=31 ! BOX in Baum ARRANGER
LET hardfs2&=32 ! BUTTON in Baum ARRANGER
LET spur2&=33 ! BOXTEXT in Baum ARRANGER
LET arrbox7&=34 ! BOX in Baum ARRANGER
LET hardfs3&=35 ! BUTTON in Baum ARRANGER
LET spur3&=36 ! BOXTEXT in Baum ARRANGER
LET arrbox8&=37 ! BOX in Baum ARRANGER
LET hardfs4&=38 ! BUTTON in Baum ARRANGER
LET spur4&=39 ! BOXTEXT in Baum ARRANGER
LET hardst2&=41 ! BOXTEXT in Baum ARRANGER
LET hardst3&=43 ! BOXTEXT in Baum ARRANGER
LET hardst4&=45 ! BOXTEXT in Baum ARRANGER
LET harde2&=47 ! BOXTEXT in Baum ARRANGER
LET harde3&=49 ! BOXTEXT in Baum ARRANGER
LET harde4&=51 ! BOXTEXT in Baum ARRANGER
LET harde1&=53 ! BOXTEXT in Baum ARRANGER
LET hardlen1&=55 ! BOXTEXT in Baum ARRANGER
LET hardlen2&=57 ! BOXTEXT in Baum ARRANGER
LET hardlen3&=59 ! BOXTEXT in Baum ARRANGER
LET hardlen4&=61 ! BOXTEXT in Baum ARRANGER
LET arrnr1&=64 ! BOXTEXT in Baum ARRANGER
LET arrnr2&=66 ! BOXTEXT in Baum ARRANGER
LET arrnr3&=68 ! BOXTEXT in Baum ARRANGER
LET arrm1&=69 ! USERDEF in Baum ARRANGER
LET arrm2&=70 ! USERDEF in Baum ARRANGER
LET arrm3&=71 ! USERDEF in Baum ARRANGER
LET arrm4&=72 ! USERDEF in Baum ARRANGER
LET hardst1&=74 ! BOXTEXT in Baum ARRANGER
LET arrnote2&=76 ! BOXTEXT in Baum ARRANGER
LET arrnote3&=78 ! BOXTEXT in Baum ARRANGER
LET arrnote4&=80 ! BOXTEXT in Baum ARRANGER
LET arrnr4&=84 ! BOXTEXT in Baum ARRANGER
LET arrmem1&=86 ! BOXTEXT in Baum ARRANGER
LET arrmem2&=88 ! BOXTEXT in Baum ARRANGER
LET arrmem3&=90 ! BOXTEXT in Baum ARRANGER
LET arrmem4&=92 ! BOXTEXT in Baum ARRANGER
LET arrnote1&=94 ! BOXTEXT in Baum ARRANGER
LET arrch1&=96 ! BOXTEXT in Baum ARRANGER
LET arrch2&=98 ! BOXTEXT in Baum ARRANGER
LET arrch3&=100 ! BOXTEXT in Baum ARRANGER
LET arrch4&=102 ! BOXTEXT in Baum ARRANGER
LET arrtri1&=104 ! BUTTON in Baum ARRANGER
LET arrtri2&=105 ! BUTTON in Baum ARRANGER
LET arrtri3&=106 ! BUTTON in Baum ARRANGER
LET arrtri4&=107 ! BUTTON in Baum ARRANGER
LET arrloop1&=110 ! USERDEF in Baum ARRANGER
LET arrloop2&=111 ! USERDEF in Baum ARRANGER
LET arrloop3&=112 ! USERDEF in Baum ARRANGER
LET arrloop4&=113 ! USERDEF in Baum ARRANGER
LET arrsmpr1&=117 ! BOXTEXT in Baum ARRANGER
LET arrsmpr2&=119 ! BOXTEXT in Baum ARRANGER
LET arrsmpr3&=121 ! BOXTEXT in Baum ARRANGER
LET arrsmpr4&=123 ! BOXTEXT in Baum ARRANGER
LET arrtrk1&=127 ! BOXTEXT in Baum ARRANGER
LET arrtrk2&=128 ! BOXTEXT in Baum ARRANGER
LET arrtrk3&=129 ! BOXTEXT in Baum ARRANGER
LET arrtrk4&=130 ! BOXTEXT in Baum ARRANGER
LET arrdel1&=132 ! USERDEF in Baum ARRANGER
LET arrdel2&=133 ! USERDEF in Baum ARRANGER
LET arrdel3&=134 ! USERDEF in Baum ARRANGER
LET arrdel4&=135 ! USERDEF in Baum ARRANGER
LET hardstrt&=136 ! USERDEF in Baum ARRANGER
LET hardend&=137 ! USERDEF in Baum ARRANGER
LET arrslide&=140 ! BOX in Baum ARRANGER
LET arrslbut&=141 ! BUTTON in Baum ARRANGER
LET arrexit&=142 ! BUTTON in Baum ARRANGER
LET arrhelp&=143 ! BOXTEXT in Baum ARRANGER
LET arrclip&=144 ! USERDEF in Baum ARRANGER
LET arrprint&=145 ! USERDEF in Baum ARRANGER
LET klavier&=146 ! USERDEF in Baum ARRANGER
LET slideup&=147 ! USERDEF in Baum ARRANGER
LET slidedwn&=148 ! USERDEF in Baum ARRANGER
LET playname&=149 ! BOXTEXT in Baum ARRANGER
'
LET setup&=14 ! Formular/Dialog
LET setupbox&=0 ! BOX in Baum SETUP
LET sync&=2 ! BUTTON in Baum SETUP
LET fseldef&=4 ! BUTTON in Baum SETUP
LET fseltxt&=6 ! BOXTEXT in Baum SETUP
LET setform&=8 ! BOXTEXT in Baum SETUP
LET setfbut&=9 ! BOXCHAR in Baum SETUP
LET seclen&=13 ! BOXTEXT in Baum SETUP
LET secl&=14 ! BUTTON in Baum SETUP
LET secr&=15 ! BUTTON in Baum SETUP
LET sram&=17 ! BUTTON in Baum SETUP
LET mallmax&=20 ! BUTTON in Baum SETUP
LET setupbx2&=21 ! BOX in Baum SETUP
LET lenmall&=22 ! FTEXT in Baum SETUP
LET sethelp&=23 ! BOXTEXT in Baum SETUP
LET recm&=26 ! BOXTEXT in Baum SETUP
LET recl&=27 ! BUTTON in Baum SETUP
LET recr&=28 ! BUTTON in Baum SETUP
LET tresdb&=31 ! BOXTEXT in Baum SETUP
LET tresl&=32 ! BUTTON in Baum SETUP
LET tresr&=33 ! BUTTON in Baum SETUP
LET setexit&=34 ! BUTTON in Baum SETUP
LET setsave&=35 ! BUTTON in Baum SETUP
LET setload&=36 ! BUTTON in Baum SETUP
LET setok&=37 ! BUTTON in Baum SETUP
LET dreide&=38 ! BUTTON in Baum SETUP
LET flip&=39 ! BUTTON in Baum SETUP
LET timeset&=40 ! BUTTON in Baum SETUP
LET setshow&=41 ! BUTTON in Baum SETUP
LET setupbx3&=43 ! BOX in Baum SETUP
LET vertline&=44 ! BUTTON in Baum SETUP
LET linkdot&=45 ! BUTTON in Baum SETUP
LET spacefil&=46 ! BUTTON in Baum SETUP
LET zoomy&=47 ! BUTTON in Baum SETUP
LET grid&=48 ! BUTTON in Baum SETUP
LET posy&=49 ! BUTTON in Baum SETUP
LET zerosnap&=50 ! BUTTON in Baum SETUP
LET frec&=51 ! BUTTON in Baum SETUP
LET menuset&=52 ! BUTTON in Baum SETUP
LET freeze&=54 ! BUTTON in Baum SETUP
'
LET info&=15 ! Formular/Dialog
LET infobox&=0 ! BOX in Baum INFO
LET infoexit&=1 ! BUTTON in Baum INFO
LET helpinfo&=2 ! BOXTEXT in Baum INFO
LET infobild&=3 ! USERDEF in Baum INFO
'
LET arrmname&=16 ! Formular/Dialog
LET arrmnbox&=0 ! BOX in Baum ARRMNAME
LET arrmnbx2&=1 ! BOX in Baum ARRMNAME
LET memname&=2 ! FTEXT in Baum ARRMNAME
LET amexit&=4 ! BUTTON in Baum ARRMNAME
LET amhelp&=5 ! BOXTEXT in Baum ARRMNAME
LET amok&=6 ! BUTTON in Baum ARRMNAME
'
LET delay&=17 ! Formular/Dialog
LET delaybox&=0 ! BOX in Baum DELAY
LET delaybx2&=2 ! BOX in Baum DELAY
LET delaytim&=3 ! FTEXT in Baum DELAY
LET delayl&=4 ! USERDEF in Baum DELAY
LET delayr&=5 ! USERDEF in Baum DELAY
LET delayex&=6 ! BUTTON in Baum DELAY
LET delayok&=7 ! BUTTON in Baum DELAY
LET delayhlp&=8 ! BOXTEXT in Baum DELAY
'
LET virtual&=18 ! Formular/Dialog
LET virtbox&=0 ! BOX in Baum VIRTUAL
LET virthelp&=2 ! BOXTEXT in Baum VIRTUAL
LET virtbloc&=4 ! BUTTON in Baum VIRTUAL
LET virtok&=5 ! BUTTON in Baum VIRTUAL
LET virtbox3&=6 ! BOX in Baum VIRTUAL
LET vblkstrt&=7 ! FTEXT in Baum VIRTUAL
LET vseconds&=8 ! BUTTON in Baum VIRTUAL
LET vsamples&=9 ! BUTTON in Baum VIRTUAL
LET vblkmlen&=10 ! BOXTEXT in Baum VIRTUAL
LET vblkvlen&=12 ! BOXTEXT in Baum VIRTUAL
LET vslider&=13 ! BOX in Baum VIRTUAL
LET vslbut&=14 ! BUTTON in Baum VIRTUAL
LET virtwork&=16 ! BUTTON in Baum VIRTUAL
LET virtdir&=17 ! BUTTON in Baum VIRTUAL
LET vrslide&=18 ! USERDEF in Baum VIRTUAL
LET vlslide&=19 ! USERDEF in Baum VIRTUAL
LET virtno&=20 ! BUTTON in Baum VIRTUAL
LET virtplay&=21 ! USERDEF in Baum VIRTUAL
'
LET space&=19 ! Formular/Dialog
LET spacebox&=0 ! BOX in Baum SPACE
LET spacetxt&=1 ! BOXTEXT in Baum SPACE
LET okspace&=2 ! BUTTON in Baum SPACE
LET exspace&=3 ! BUTTON in Baum SPACE
LET hlpspace&=5 ! BOXTEXT in Baum SPACE
LET spacel1&=8 ! USERDEF in Baum SPACE
LET spacer1&=9 ! USERDEF in Baum SPACE
LET spacel2&=10 ! USERDEF in Baum SPACE
LET spacer2&=11 ! USERDEF in Baum SPACE
'
LET moving&=20 ! Formular/Dialog
LET movngbox&=0 ! BOX in Baum MOVING
LET movhlp&=1 ! BOXTEXT in Baum MOVING
LET mvcutcpy&=3 ! BUTTON in Baum MOVING
LET mvcutins&=4 ! BUTTON in Baum MOVING
LET mvclrins&=5 ! BUTTON in Baum MOVING
LET mvclrcpy&=6 ! BUTTON in Baum MOVING
LET movexit&=7 ! BUTTON in Baum MOVING
'
LET arrmake&=21 ! Formular/Dialog
LET makebox&=0 ! BOX in Baum ARRMAKE
LET maketxt&=4 ! BOXTEXT in Baum ARRMAKE
LET makefsel&=5 ! BUTTON in Baum ARRMAKE
LET makerate&=6 ! BOXTEXT in Baum ARRMAKE
LET makehelp&=9 ! BOXTEXT in Baum ARRMAKE
LET makeok&=10 ! BUTTON in Baum ARRMAKE
LET makexit&=11 ! BUTTON in Baum ARRMAKE
'
LET timeed&=22 ! Formular/Dialog
LET timebox&=0 ! BOX in Baum TIMEED
LET timebox2&=1 ! BOX in Baum TIMEED
LET tedtxt&=2 ! FTEXT in Baum TIMEED
LET tedsmp&=3 ! BUTTON in Baum TIMEED
LET tedsec&=4 ! BUTTON in Baum TIMEED
LET tedexit&=6 ! BUTTON in Baum TIMEED
LET tedhelp&=7 ! BOXTEXT in Baum TIMEED
LET tedok&=8 ! BUTTON in Baum TIMEED
'
LET abackup&=23 ! Formular/Dialog
LET abackbox&=0 ! BOX in Baum ABACKUP
LET abacktxt&=1 ! BOXTEXT in Baum ABACKUP
LET abackok&=2 ! BUTTON in Baum ABACKUP
LET abackex&=3 ! BUTTON in Baum ABACKUP
LET abackhlp&=5 ! BOXTEXT in Baum ABACKUP
LET abackr1&=8 ! USERDEF in Baum ABACKUP
LET abackr2&=9 ! USERDEF in Baum ABACKUP
LET abackl1&=10 ! USERDEF in Baum ABACKUP
LET abackl2&=11 ! USERDEF in Baum ABACKUP
LET abackbo2&=12 ! BOX in Baum ABACKUP
LET aback&=13 ! BUTTON in Baum ABACKUP
LET abacknam&=14 ! BUTTON in Baum ABACKUP
'
LET inftxt&=24 ! Formular/Dialog
LET infbox&=0 ! BOX in Baum INFTXT
LET infbox2&=1 ! BOX in Baum INFTXT
LET inftitel&=2 ! BUTTON in Baum INFTXT
'
LET smpinf&=25 ! Formular/Dialog
LET sinfbox&=0 ! BOX in Baum SMPINF
LET sinfok&=1 ! BUTTON in Baum SMPINF
LET sinfexit&=2 ! BUTTON in Baum SMPINF
LET sinfhelp&=3 ! BOXTEXT in Baum SMPINF
LET sinfname&=6 ! BOXTEXT in Baum SMPINF
LET sinflen&=8 ! BOXTEXT in Baum SMPINF
LET sinfrate&=10 ! BOXTEXT in Baum SMPINF
LET sinfsus2&=15 ! BOXTEXT in Baum SMPINF
LET sinfrel2&=16 ! BOXTEXT in Baum SMPINF
LET sinfl5&=18 ! BOXTEXT in Baum SMPINF
LET sinfl6&=19 ! BOXTEXT in Baum SMPINF
LET sinfl7&=22 ! BOXTEXT in Baum SMPINF
LET sinfl8&=23 ! BOXTEXT in Baum SMPINF
LET sinfl1&=24 ! BOXTEXT in Baum SMPINF
LET sinfl2&=26 ! BOXTEXT in Baum SMPINF
LET sinfl3&=28 ! BOXTEXT in Baum SMPINF
LET sinfl4&=30 ! BOXTEXT in Baum SMPINF
LET sinfdate&=32 ! BOXTEXT in Baum SMPINF
LET sinfrel1&=33 ! BOXTEXT in Baum SMPINF
LET sinfsus1&=34 ! BOXTEXT in Baum SMPINF
LET sinfbox2&=35 ! BOX in Baum SMPINF
LET sinfcomm&=36 ! FTEXT in Baum SMPINF
LET sinfsrc&=37 ! FTEXT in Baum SMPINF
LET sinfl9&=40 ! BOXTEXT in Baum SMPINF
LET sinfl10&=41 ! BOXTEXT in Baum SMPINF
LET sinfl11&=42 ! BOXTEXT in Baum SMPINF
LET sinfl12&=43 ! BOXTEXT in Baum SMPINF
'
LET trakker&=26 ! Formular/Dialog
LET trakbox&=0 ! BOX in Baum TRAKKER
LET trakbox2&=1 ! BOX in Baum TRAKKER
LET trakbox5&=2 ! BOX in Baum TRAKKER
LET trakk1&=3 ! BOXTEXT in Baum TRAKKER
LET trakk2&=4 ! BOXTEXT in Baum TRAKKER
LET trakk3&=5 ! BOXTEXT in Baum TRAKKER
LET trakk4&=6 ! BOXTEXT in Baum TRAKKER
LET trakk5&=7 ! BOXTEXT in Baum TRAKKER
LET trakk6&=8 ! BOXTEXT in Baum TRAKKER
LET trakk7&=9 ! BOXTEXT in Baum TRAKKER
LET trakk8&=10 ! BOXTEXT in Baum TRAKKER
LET timeline&=13 ! BOXTEXT in Baum TRAKKER
LET traknam1&=14 ! BOXTEXT in Baum TRAKKER
LET trakexit&=70 ! BUTTON in Baum TRAKKER
LET trakprt&=71 ! USERDEF in Baum TRAKKER
LET trakhelp&=72 ! BOXTEXT in Baum TRAKKER
LET trakclip&=73 ! USERDEF in Baum TRAKKER
LET trakslid&=74 ! BOX in Baum TRAKKER
LET trakxbut&=75 ! BUTTON in Baum TRAKKER
LET trakbox4&=76 ! BOX in Baum TRAKKER
LET traktime&=77 ! BOXTEXT in Baum TRAKKER
LET trakname&=78 ! BOXTEXT in Baum TRAKKER
LET pause2&=80 ! USERDEF in Baum TRAKKER
LET rewind2&=81 ! USERDEF in Baum TRAKKER
LET stop2&=82 ! USERDEF in Baum TRAKKER
LET recplay2&=83 ! USERDEF in Baum TRAKKER
LET smpplay3&=84 ! USERDEF in Baum TRAKKER
LET smprpla2&=85 ! USERDEF in Baum TRAKKER
LET forward2&=86 ! USERDEF in Baum TRAKKER
LET trakanf&=87 ! USERDEF in Baum TRAKKER
LET trakfull&=88 ! USERDEF in Baum TRAKKER
LET smpstrt4&=89 ! USERDEF in Baum TRAKKER
LET smpauto4&=90 ! USERDEF in Baum TRAKKER
LET trakbox3&=91 ! BOX in Baum TRAKKER
LET hlpedit3&=92 ! USERDEF in Baum TRAKKER
LET hrdmerg2&=93 ! USERDEF in Baum TRAKKER
LET trakload&=94 ! USERDEF in Baum TRAKKER
LET traksave&=95 ! USERDEF in Baum TRAKKER
LET trakplay&=96 ! USERDEF in Baum TRAKKER
LET trakins&=97 ! USERDEF in Baum TRAKKER
LET trakdel&=98 ! USERDEF in Baum TRAKKER
LET trakinfo&=102 ! BOXTEXT in Baum TRAKKER
LET trakloop&=103 ! USERDEF in Baum TRAKKER
LET traktri&=104 ! BUTTON in Baum TRAKKER
LET trakstrt&=107 ! BOXTEXT in Baum TRAKKER
LET trakend&=108 ! BOXTEXT in Baum TRAKKER
LET traklen&=109 ! BOXTEXT in Baum TRAKKER
LET trkvslid&=110 ! BOX in Baum TRAKKER
LET trakybut&=111 ! BUTTON in Baum TRAKKER
LET trksmpte&=112 ! BOXTEXT in Baum TRAKKER
LET trakxr&=114 ! USERDEF in Baum TRAKKER
LET trakxl&=115 ! USERDEF in Baum TRAKKER
LET trkslido&=116 ! USERDEF in Baum TRAKKER
LET trkslidu&=117 ! USERDEF in Baum TRAKKER
'
LET dropdown&=27 ! Menuebaum
LET ddinfo&=9 ! STRING in Baum DROPDOWN
LET ddload&=18 ! STRING in Baum DROPDOWN
LET ddsave&=19 ! STRING in Baum DROPDOWN
LET ddexit&=20 ! STRING in Baum DROPDOWN
LET ddsmp16&=22 ! STRING in Baum DROPDOWN
LET ddblock&=23 ! STRING in Baum DROPDOWN
LET ddpeak&=24 ! STRING in Baum DROPDOWN
LET ddarr&=25 ! STRING in Baum DROPDOWN
LET ddtrakk&=26 ! STRING in Baum DROPDOWN
LET ddloop&=27 ! STRING in Baum DROPDOWN
LET dddsp&=28 ! STRING in Baum DROPDOWN
LET ddsetup&=30 ! STRING in Baum DROPDOWN
LET ddfader&=31 ! STRING in Baum DROPDOWN
LET ddmidi&=32 ! STRING in Baum DROPDOWN
LET ddbank&=33 ! STRING in Baum DROPDOWN
LET ddmon&=35 ! STRING in Baum DROPDOWN
LET ddauto&=36 ! STRING in Baum DROPDOWN
LET ddmanu&=37 ! STRING in Baum DROPDOWN
LET ddplay&=38 ! STRING in Baum DROPDOWN
'
LET fsel&=28 ! Formular/Dialog
LET fselbox&=0 ! BOX in Baum FSEL
LET fselbox2&=1 ! BOX in Baum FSEL
LET fsbut1&=2 ! BOXTEXT in Baum FSEL
LET fsbut2&=3 ! BOXTEXT in Baum FSEL
LET fsbut3&=4 ! BOXTEXT in Baum FSEL
LET fsbut4&=5 ! BOXTEXT in Baum FSEL
LET fsbut5&=6 ! BOXTEXT in Baum FSEL
LET fsbut6&=7 ! BOXTEXT in Baum FSEL
LET fsbut7&=8 ! BOXTEXT in Baum FSEL
LET fsbut8&=9 ! BOXTEXT in Baum FSEL
LET fsbut9&=10 ! BOXTEXT in Baum FSEL
LET fsbut10&=11 ! BOXTEXT in Baum FSEL
LET fsbut11&=12 ! BOXTEXT in Baum FSEL
LET fsbut12&=13 ! BOXTEXT in Baum FSEL
LET fsbut13&=14 ! BOXTEXT in Baum FSEL
LET fsbut14&=15 ! BOXTEXT in Baum FSEL
LET fsbut15&=16 ! BOXTEXT in Baum FSEL
LET fstxt1&=17 ! BOXTEXT in Baum FSEL
LET fstxt2&=18 ! BOXTEXT in Baum FSEL
LET fstxt3&=19 ! BOXTEXT in Baum FSEL
LET fstxt4&=20 ! BOXTEXT in Baum FSEL
LET fstxt5&=21 ! BOXTEXT in Baum FSEL
LET fstxt6&=22 ! BOXTEXT in Baum FSEL
LET fstxt7&=23 ! BOXTEXT in Baum FSEL
LET fstxt8&=24 ! BOXTEXT in Baum FSEL
LET fstxt9&=25 ! BOXTEXT in Baum FSEL
LET fstxt10&=26 ! BOXTEXT in Baum FSEL
LET fstxt11&=27 ! BOXTEXT in Baum FSEL
LET fstxt12&=28 ! BOXTEXT in Baum FSEL
LET fstxt13&=29 ! BOXTEXT in Baum FSEL
LET fstxt14&=30 ! BOXTEXT in Baum FSEL
LET fstxt15&=31 ! BOXTEXT in Baum FSEL
LET fsslide&=32 ! BOX in Baum FSEL
LET fssldbut&=33 ! BUTTON in Baum FSEL
LET fsok&=34 ! BUTTON in Baum FSEL
LET fshelp&=35 ! BOXTEXT in Baum FSEL
LET fsplay&=36 ! USERDEF in Baum FSEL
LET fsexit&=37 ! BUTTON in Baum FSEL
LET fsordner&=39 ! BUTTON in Baum FSEL
LET fsotxt&=40 ! BOXTEXT in Baum FSEL
LET fsmatic&=41 ! USERDEF in Baum FSEL
LET fsins&=42 ! USERDEF in Baum FSEL
LET fsdel&=43 ! USERDEF in Baum FSEL
LET fsadd&=44 ! BUTTON in Baum FSEL
LET fsnew&=45 ! BUTTON in Baum FSEL
LET fsload&=46 ! USERDEF in Baum FSEL
LET fssave&=47 ! USERDEF in Baum FSEL
LET fsclf&=48 ! USERDEF in Baum FSEL
LET fssldup&=49 ! USERDEF in Baum FSEL
LET fsslddwn&=50 ! USERDEF in Baum FSEL
'
OPTION BASE 0
IF compile=FALSE THEN
  RESERVE 800000
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------AUFLôSUNG ERFRAGEN------------------------------------
' ------------------------------------------------------------------------------
IF xwidth<640 OR ywidth<400 THEN
  ALERT 3,"Auflîsung ist zu gering|Mindestens 640x400 nîtig !",1,"EXIT",g
  END
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------RSC LADEN---------------------------------------------
' ------------------------------------------------------------------------------
DEFMOUSE 0
'
IF compile=TRUE THEN
  lfw$=CHR$(GEMDOS(25)+65)+":"+DIR$(0)+"\"       ! funktioniert als COMPILAT !
ELSE
  lfw$="D:\"
ENDIF
s$=lfw$
IF EXIST(s$+setup$)=FALSE THEN
  IF EXIST("C:\"+setup$)=TRUE THEN
    s$="C:\"
  ENDIF
ENDIF
setup$=s$+"SMP16.SET"       ! Name des Setup-Files
fsel$=s$+"SMP16.SEL"        ! Name des Fileselector-Files
arrup$=lfw$+"SMP16.ARR"     ! Name des Arrange-Files
fade$=lfw$+"SMP16.FAD"      ! Name des Fader-Files
virt2$=lfw$+"SMP16.FIX"     ! Name des Files zur Rettung von Marken/Loop/Midi/Block bei Wechsel zu virt. Bearbeitung
virt$=lfw$+"SMP16.VIR"      ! Name des virtuellen Files fÅr Backup-Zwecke (Backup des Speicherinhalts)
aback2$=lfw$+"BACKUP.ARR"   ! Name des Backup-Arrange-files
inf$="INF"                  ! Extender fÅr INF-File
mbox$="BOX"                 ! Extender fÅr Musicbox-files
rsc$="STARTRAK.RSC"         ! Name des RSC-Files
'
'
btree=28                    ! Anzahl der BÑume-1
DIM rx(btree)
DIM ry(btree)
@setload
ext2$=ext$
IF ext2$="*" THEN
  ext2$="S16"
ENDIF
virtfile$="VIRTWORK."+ext2$ ! Name des Files fÅr virtuelle Bearbeitung von StÅcken, die lÑnger als Speicherplatz sind
workfile$="WORK."+ext2$     ! Name des Files, zur Auslagerung beim öbergang mem->virt, wenn ein StÅck grîûer als Speicher wird
aback$="BACKUP."+ext2$       ! Name des Backup-Samplefiles
@rsc_init
a=@xrsrc_init
IF rsc_mtsk!=TRUE THEN
  ~MENU_REGISTER(ap_id&,"  VME_SMP16")
ENDIF
'
mtype=INT(C:rsc_cookie%(L:CVL("_MCH"))/&H10000)          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
IF mtype=2 THEN
  vme=&HFEFF0000
ELSE
  vme=&HDF0000
ENDIF
adr=vme+&H401
s$=lfw$
IF EXIST(s$+rsc$)=FALSE THEN
  IF EXIST("C:\"+rsc$)=TRUE THEN
    s$="C:\"
  ENDIF
ENDIF
@treiberload
IF menuda=FALSE THEN
  mensa=-1
  m=@rsc_laden(s$+rsc$,btree,9,mensa,-1)  ! File$,Trees,Popup,Menu,Alert
ELSE
  mensa=27
  m=@rsc_laden(s$+rsc$,btree,9,mensa,-1)  ! File$,Trees,Popup,Menu,Alert
ENDIF
IF m=TRUE THEN ! File$,Trees,Popup,Menu,Alert
  rscda=TRUE
  IF freez=TRUE THEN
    FOR i=0 TO ctree
      IF BTST(winh,i)=TRUE THEN
        rscx&(i)=rx(i)
        rscy&(i)=ry(i)
        IF i<>mensa THEN
          OB_X(rsc_adr%(i),0)=ADD(rscx&(i),3)
          OB_Y(rsc_adr%(i),0)=ADD(rscy&(i),3)
        ENDIF
      ENDIF
    NEXT i
  ENDIF
  maxcol=WORK_OUT(13)
  IF rsc_mtsk!=FALSE THEN
    @colorbox(smp16&,mainbox6&,0,7)
    @colorbox(smp16&,mainbox2&,0,7)
    @colorbox(smp16&,mainbox4&,0,7)
    @colorbox(smp16&,mainbox5&,0,7)
    '    @colorbox(arranger&,arrbox4&,0,7)
    '    @colorbox(arranger&,arrbox5&,0,7)
    '    @colorbox(arranger&,arrbox6&,0,7)
    '    @colorbox(arranger&,arrbox7&,0,7)
    '    @colorbox(arranger&,arrbox8&,0,7)
    '    @colorbox(trakker&,trakbox4&,0,7)
    @colorbox(setup&,setupbox&,0,7)
    @colorbox(setup&,setupbx3&,0,7)
    '    @colorbox(timeed&,timebox&,0,7)
    '    @colorbox(timeed&,timebox2&,0,7)
    @colorbox(abackup&,abackbo2&,0,7)
    '   @colorbox(smpinf&,sinfbox&,0,7)
    '   @colorbox(smpinf&,sinfbox2&,0,7)
    '    @colorbox(arrmake&,makebox&,0,7)
    '    @colorbox(delay&,delaybox&,0,7)
    '    @colorbox(delay&,delaybx2&,0,7)
    '    @colorbox(moving&,movngbox&,0,7)
    '    @colorbox(resample&,resmpbox&,0,7)
    '   @colorbox(virtual&,virtbox&,0,7)
    '   @colorbox(virtual&,virtbox3&,0,7)
  ENDIF
  IF maxcol=2 THEN
    @textcolor(peak&,peakmax&,0,1,1)  !text,rahmen,fill
  ENDIF
  IF maxcol=2 OR dreidim=0 THEN
    @textcolor(smp16&,helporig&,1,1,0)
    @textcolor(smpedit&,smpedhlp&,1,1,0)
    @textcolor(dspedit&,helpdsp&,1,1,0)
    @textcolor(peak&,peakhelp&,1,1,0)
    @textcolor(peak&,peakmax&,1,1,0)
    @textcolor(peak&,peakpos&,1,1,0)
    @textcolor(peak&,peakdb&,1,1,0)
    @textcolor(peak&,peakbal&,1,1,0)
    @textcolor(peak&,recpeaks&,1,1,0)
    @textcolor(peak&,recerror&,1,1,0)
    @textcolor(peak&,balbox&,1,1,0)
    @textcolor(loop&,helploop&,1,1,0)
    @textcolor(normaliz&,helpnorm&,1,1,0)
    @textcolor(normaliz&,normdb&,1,1,0)
    @textcolor(normaliz&,maxdb&,1,1,0)
    @textcolor(resample&,helprsmp&,1,1,0)
    @textcolor(resample&,resmplen&,1,1,0)
    @textcolor(resample&,resmpsec&,1,1,0)
    @textcolor(resample&,resmpfac&,1,1,0)
    @textcolor(resample&,resother&,1,1,0)
    @textcolor(midiedit&,helpmidi&,1,1,0)
    @textcolor(midiedit&,notetxt&,1,1,0)
    @textcolor(midiedit&,chtxt&,1,1,0)
    @textcolor(editfade&,helpfade&,1,1,0)
    @textcolor(record&,rechelp&,1,1,0)
    @textcolor(record&,recfree&,1,1,0)
    @textcolor(blkfunc&,blkhelp&,1,1,0)
    @textcolor(savebloc&,savehelp&,1,1,0)
    @textcolor(arranger&,arrhelp&,1,1,0)
    @textcolor(arranger&,playlen&,1,1,0)
    @textcolor(arranger&,playname&,1,1,0)
    @textcolor(arranger&,arrnr1&,1,1,0)
    @textcolor(arranger&,arrmem1&,1,1,0)
    @textcolor(arranger&,spur1&,1,1,0)
    @textcolor(arranger&,arrsmpr1&,1,1,0)
    @textcolor(arranger&,arrnote1&,1,1,0)
    @textcolor(arranger&,arrch1&,1,1,0)
    @textcolor(arranger&,arrtrk1&,1,1,0)
    @textcolor(arranger&,hardst1&,1,1,0)
    @textcolor(arranger&,harde1&,1,1,0)
    @textcolor(arranger&,hardlen1&,1,1,0)
    @textcolor(arranger&,arrnr2&,1,1,0)
    @textcolor(arranger&,arrmem2&,1,1,0)
    @textcolor(arranger&,spur2&,1,1,0)
    @textcolor(arranger&,arrsmpr2&,1,1,0)
    @textcolor(arranger&,arrnote2&,1,1,0)
    @textcolor(arranger&,arrch2&,1,1,0)
    @textcolor(arranger&,arrtrk2&,1,1,0)
    @textcolor(arranger&,hardst2&,1,1,0)
    @textcolor(arranger&,harde2&,1,1,0)
    @textcolor(arranger&,hardlen2&,1,1,0)
    @textcolor(arranger&,arrnr3&,1,1,0)
    @textcolor(arranger&,arrmem3&,1,1,0)
    @textcolor(arranger&,spur3&,1,1,0)
    @textcolor(arranger&,arrsmpr3&,1,1,0)
    @textcolor(arranger&,arrnote3&,1,1,0)
    @textcolor(arranger&,arrch3&,1,1,0)
    @textcolor(arranger&,arrtrk3&,1,1,0)
    @textcolor(arranger&,hardst3&,1,1,0)
    @textcolor(arranger&,harde3&,1,1,0)
    @textcolor(arranger&,hardlen3&,1,1,0)
    @textcolor(arranger&,arrnr4&,1,1,0)
    @textcolor(arranger&,arrmem4&,1,1,0)
    @textcolor(arranger&,spur4&,1,1,0)
    @textcolor(arranger&,arrsmpr4&,1,1,0)
    @textcolor(arranger&,arrnote4&,1,1,0)
    @textcolor(arranger&,arrch4&,1,1,0)
    @textcolor(arranger&,arrtrk4&,1,1,0)
    @textcolor(arranger&,hardst4&,1,1,0)
    @textcolor(arranger&,harde4&,1,1,0)
    @textcolor(arranger&,hardlen4&,1,1,0)
    @textcolor(setup&,sethelp&,1,1,0)
    @textcolor(setup&,tresdb&,1,1,0)
    @textcolor(setup&,recm&,1,1,0)
    @textcolor(setup&,seclen&,1,1,0)
    @textcolor(info&,helpinfo&,1,1,0)
    @textcolor(arrmname&,amhelp&,1,1,0)
    @textcolor(virtual&,virthelp&,1,1,0)
    @textcolor(virtual&,vblkmlen&,1,1,0)
    @textcolor(virtual&,vblkvlen&,1,1,0)
    @textcolor(arrmake&,makehelp&,1,1,0)
    @textcolor(arrmake&,maketxt&,1,1,0)
    @textcolor(timeed&,tedhelp&,1,1,0)
    @textcolor(smpinf&,sinfhelp&,1,1,0)
    @textcolor(smpinf&,sinfname&,1,1,0)
    @textcolor(smpinf&,sinflen&,1,1,0)
    @textcolor(smpinf&,sinfrate&,1,1,0)
    @textcolor(smpinf&,sinfdate&,1,1,0)
    @textcolor(smpinf&,sinfsus1&,1,1,0)
    @textcolor(smpinf&,sinfsus2&,1,1,0)
    @textcolor(smpinf&,sinfrel1&,1,1,0)
    @textcolor(smpinf&,sinfrel2&,1,1,0)
    @textcolor(smpinf&,sinfl1&,1,1,0)
    @textcolor(smpinf&,sinfl2&,1,1,0)
    @textcolor(smpinf&,sinfl3&,1,1,0)
    @textcolor(smpinf&,sinfl4&,1,1,0)
    @textcolor(smpinf&,sinfl5&,1,1,0)
    @textcolor(smpinf&,sinfl6&,1,1,0)
    @textcolor(smpinf&,sinfl7&,1,1,0)
    @textcolor(smpinf&,sinfl8&,1,1,0)
    @textcolor(smpinf&,sinfl9&,1,1,0)
    @textcolor(smpinf&,sinfl10&,1,1,0)
    @textcolor(smpinf&,sinfl11&,1,1,0)
    @textcolor(smpinf&,sinfl12&,1,1,0)
    @textcolor(trakker&,trakhelp&,1,1,0)
    @textcolor(trakker&,trakk1&,1,1,0)
    @textcolor(trakker&,trakk2&,1,1,0)
    @textcolor(trakker&,trakk3&,1,1,0)
    @textcolor(trakker&,trakk4&,1,1,0)
    @textcolor(trakker&,trakk5&,1,1,0)
    @textcolor(trakker&,trakk6&,1,1,0)
    @textcolor(trakker&,trakk7&,1,1,0)
    @textcolor(trakker&,trakk8&,1,1,0)
    @textcolor(trakker&,trakstrt&,1,1,0)
    @textcolor(trakker&,trakend&,1,1,0)
    @textcolor(trakker&,traklen&,1,1,0)
    @textcolor(trakker&,trksmpte&,1,1,0)
    @textcolor(trakker&,trakinfo&,1,1,0)
    @textcolor(trakker&,trakname&,1,1,0)
    @textcolor(trakker&,traktime&,1,1,0)
    @textcolor(trakker&,timeline&,1,1,0)
    @textcolor(fsel&,fshelp&,1,1,0)
    @textcolor(fsel&,fsotxt&,1,1,0)
    @textcolor(fsel&,fsbut1&,1,1,0)
    @textcolor(fsel&,fsbut2&,1,1,0)
    @textcolor(fsel&,fsbut3&,1,1,0)
    @textcolor(fsel&,fsbut4&,1,1,0)
    @textcolor(fsel&,fsbut5&,1,1,0)
    @textcolor(fsel&,fsbut6&,1,1,0)
    @textcolor(fsel&,fsbut7&,1,1,0)
    @textcolor(fsel&,fsbut8&,1,1,0)
    @textcolor(fsel&,fsbut9&,1,1,0)
    @textcolor(fsel&,fsbut10&,1,1,0)
    @textcolor(fsel&,fsbut11&,1,1,0)
    @textcolor(fsel&,fsbut12&,1,1,0)
    @textcolor(fsel&,fsbut13&,1,1,0)
    @textcolor(fsel&,fsbut14&,1,1,0)
    @textcolor(fsel&,fsbut15&,1,1,0)
    @textcolor(fsel&,fstxt1&,1,1,0)
    @textcolor(fsel&,fstxt2&,1,1,0)
    @textcolor(fsel&,fstxt3&,1,1,0)
    @textcolor(fsel&,fstxt4&,1,1,0)
    @textcolor(fsel&,fstxt5&,1,1,0)
    @textcolor(fsel&,fstxt6&,1,1,0)
    @textcolor(fsel&,fstxt7&,1,1,0)
    @textcolor(fsel&,fstxt8&,1,1,0)
    @textcolor(fsel&,fstxt9&,1,1,0)
    @textcolor(fsel&,fstxt10&,1,1,0)
    @textcolor(fsel&,fstxt11&,1,1,0)
    @textcolor(fsel&,fstxt12&,1,1,0)
    @textcolor(fsel&,fstxt13&,1,1,0)
    @textcolor(fsel&,fstxt14&,1,1,0)
    @textcolor(fsel&,fstxt15&,1,1,0)
    @textcolor(arranger&,hlpedit2&,1,1,0)
    @textcolor(delay&,delayhlp&,1,1,0)
    @textcolor(space&,hlpspace&,1,1,0)
    @textcolor(space&,spacetxt&,1,1,0)
    @textcolor(moving&,movhlp&,1,1,0)
    @textcolor(abackup&,abackhlp&,1,1,0)
    @textcolor(abackup&,abacktxt&,1,1,0)
    @colorbox(abackup&,abackbo2&,0,7)
    @textcolor(smpedit&,cstxt&,1,1,0)
    @textcolor(smpedit&,cetxt&,1,1,0)
    @textcolor(smpedit&,smptsa&,1,1,0)
    @textcolor(smpedit&,smptsb&,1,1,0)
    @textcolor(smpedit&,smptsc&,1,1,0)
    @textcolor(smpedit&,smptsd&,1,1,0)
    @textcolor(smpedit&,smptse&,1,1,0)
    @textcolor(smpedit&,smptsava&,1,1,0)
    @textcolor(smpedit&,smptea&,1,1,0)
    @textcolor(smpedit&,smpteb&,1,1,0)
    @textcolor(smpedit&,smptec&,1,1,0)
    @textcolor(smpedit&,smpted&,1,1,0)
    @textcolor(smpedit&,smptee&,1,1,0)
    @textcolor(smpedit&,smptsavb&,1,1,0)
    @textcolor(smpedit&,coptotxt&,1,1,0)
    @textcolor(smpedit&,smplen&,1,1,0)
    @textcolor(smpedit&,smpfile&,1,1,0)
    @textcolor(smpedit&,smpname&,1,1,0)
    @textcolor(smpedit&,showxy&,1,1,0)
    @textcolor(smpedit&,freemem&,1,1,0)
    @textcolor(smpedit&,clock&,1,1,0)
    @textcolor(smpedit&,pntprsmp&,1,1,0)
    @textcolor(smpedit&,smprate&,1,1,0)
    @textcolor(smpedit&,smpsec&,1,1,0)
    @textcolor(smpedit&,mintext&,1,1,0)
    @textcolor(smpedit&,hacksa&,1,1,0)
    @textcolor(smpedit&,hacksb&,1,1,0)
    @textcolor(smpedit&,hacksc&,1,1,0)
    @textcolor(smpedit&,hacksd&,1,1,0)
    @textcolor(smpedit&,hackse&,1,1,0)
    @textcolor(smpedit&,hackss&,1,1,0)
    @textcolor(smpedit&,hackea&,1,1,0)
    @textcolor(smpedit&,hackeb&,1,1,0)
    @textcolor(smpedit&,hackec&,1,1,0)
    @textcolor(smpedit&,hacked&,1,1,0)
    @textcolor(smpedit&,hackee&,1,1,0)
    @textcolor(smpedit&,hackes&,1,1,0)
  ENDIF
  IF maxcol=2 OR dreidim=0 THEN
    @colorbox(smp16&,mainbox6&,0,7)
    @colorbox(smp16&,mainbox&,0,7)
    @colorbox(smp16&,mainbox2&,0,7)
    @colorbox(smp16&,mainbox4&,0,7)
    @colorbox(smp16&,mainbox5&,0,7)
    @colorbox(smpedit&,editbox&,0,7)
    @colorbox(smpedit&,editbox2&,0,7)
    @colorbox(smpedit&,editbox3&,0,7)
    @colorbox(smpedit&,editbox4&,0,7)
    @colorbox(smpedit&,editbox5&,0,7)
    @colorbox(smpedit&,editbox6&,0,7)
    @colorbox(smpedit&,editbox7&,0,7)
    @colorbox(smpedit&,editbox8&,0,7)
    @colorbox(smpedit&,editbox9&,0,7)
    @colorbox(smpedit&,editbx10&,0,7)
    @colorbox(smpedit&,editbx11&,0,7)
    @colorbox(smpedit&,zomslide&,1,1)
    @colorbox(smpedit&,scrlslde&,1,1)
    @colorbox(peak&,peakbox&,0,7)
    @colorbox(peak&,peakbox2&,0,7)
    @colorbox(peak&,volbox&,0,7)
    @colorbox(loop&,loopbox&,0,7)
    @colorbox(normaliz&,normbox&,0,7)
    @colorbox(resample&,resmpbox&,0,7)
    @colorbox(midiedit&,midibox&,0,7)
    @colorbox(editfade&,fadebox&,0,7)
    @colorbox(record&,recbox&,0,7)
    @colorbox(blkfunc&,blkbox&,0,7)
    @colorbox(savebloc&,savebox&,0,7)
    @colorbox(arranger&,arrbox&,0,7)
    @colorbox(arranger&,arrbox2&,0,7)
    @colorbox(arranger&,arrbox3&,0,7)
    @colorbox(arranger&,arrbox4&,0,7)
    @colorbox(arranger&,arrbox5&,0,7)
    @colorbox(arranger&,arrbox6&,0,7)
    @colorbox(arranger&,arrbox7&,0,7)
    @colorbox(arranger&,arrbox8&,0,7)
    @colorbox(arranger&,arrslide&,1,1)
    @colorbox(info&,infobox&,0,7)
    @colorbox(arrmname&,arrmnbox&,0,7)
    @colorbox(arrmname&,arrmnbx2&,0,7)
    @colorbox(dspedit&,dspbox&,0,7)
    @colorbox(delay&,delaybox&,0,7)
    @colorbox(delay&,delaybx2&,0,7)
    @colorbox(virtual&,virtbox&,0,7)
    @colorbox(virtual&,virtbox3&,0,7)
    @colorbox(virtual&,vslider&,1,1)
    @colorbox(space&,spacebox&,0,7)
    @colorbox(moving&,movngbox&,0,7)
    @colorbox(arrmake&,makebox&,0,7)
    @colorbox(timeed&,timebox&,0,7)
    @colorbox(timeed&,timebox2&,0,7)
    @colorbox(abackup&,abackbox&,0,7)
    @colorbox(inftxt&,infbox&,0,7)
    @colorbox(inftxt&,infbox2&,0,7)
    @colorbox(trakker&,trakbox&,0,7)
    @colorbox(trakker&,trakbox2&,0,7)
    @colorbox(trakker&,trakbox3&,0,7)
    @colorbox(trakker&,trakbox4&,0,7)
    @colorbox(trakker&,trakbox5&,0,7)
    @colorbox(trakker&,trakslid&,1,1)
    @colorbox(trakker&,trkvslid&,1,1)
    @colorbox(setup&,setupbox&,0,7)
    @colorbox(setup&,setupbx2&,0,7)
    @colorbox(setup&,setupbx3&,0,7)
    @colorbox(fsel&,fselbox&,0,7)
    @colorbox(fsel&,fselbox2&,0,7)
    @colorbox(fsel&,fsslide&,1,1)
    @colorbox(smpinf&,sinfbox&,0,7)
    @colorbox(smpinf&,sinfbox2&,0,7)
  ENDIF
ELSE
  rscda=FALSE
ENDIF
IF rscda=TRUE THEN
  @smpedit
  END
ELSE
  ALERT 3,"RSC-File nicht gefunden !",1,"EXIT",g
  GEMSYS 109                                        ! Nur ab GEM 1.04!
  @xrsrc_exit
ENDIF
IF away=TRUE THEN
  ALERT 3,"Zu wenig Speicher frei !",1,"EXIT",g
  END
ENDIF
END
'
' ------------------------------------------------------------------------------
' ------------------------PROZEDUREN--------------------------------------------
' ------------------------------------------------------------------------------
'                 HardwareabhÑngiger Teil - Adressenzuordnung
' ------------------------------------------------------------------------------
'
> PROCEDURE write_reglow(a)
  .| Glob. Var.: demo#,adr#
  .| Aufruf in : digout-1,opto-2,coax-2,adlow-2,admid-2,adhigh-2,ext32l-1
  .|     ext44l-1,ext48l-1,ext32h-1,ext44h-1,ext48h-1,ext256-1,ext384-1
  .|     analog-2,digital-1,setupdat-1,setup2-1,
  IF demo=FALSE THEN
    POKE adr,a
  ENDIF
RETURN
'
> PROCEDURE write_reghigh(a)
  .| Glob. Var.: demo#,adr#
  .| Aufruf in : digout-1,subframe-2,digin-1,prot-2,fifodel-2,setup2-1,
  IF demo=FALSE THEN
    POKE adr+&H40,a
  ENDIF
RETURN
'
> PROCEDURE write_dsp(a)
  .| Glob. Var.: demo#,adr#
  .| Aufruf in : dspoff-1,dspin-1,dspout-1,volcs-2,volclk-2,voldatai-2
  .|     setup2-1,
  IF demo=FALSE THEN
    POKE adr+&H80,a
  ENDIF
RETURN
'
> PROCEDURE write_aes(a)
  IF demo=FALSE THEN
    POKE adr+&HC0,a
  ENDIF
RETURN
'
> PROCEDURE write_int(a)
  IF demo=FALSE THEN
    POKE adr+&H180,a
  ENDIF
RETURN
'
> PROCEDURE read_statmid
  .| Glob. Var.: demo#,rwert#,adr#
  .| Aufruf in : edhandler-2,
  IF demo=FALSE THEN
    rwert=PEEK(adr+&H20)
    rwert=(rwert AND 135)
  ELSE
    rwert=7
  ENDIF
RETURN
'
> PROCEDURE read_smp
  .| Glob. Var.: demo#,rwert#,adr#
  .| Aufruf in : peakwert-5,
  IF demo=FALSE THEN
    rwert=DPEEK(adr+&H200-1)
  ENDIF
RETURN
'
> PROCEDURE read_dsp
  IF demo=FALSE THEN
    rwert=PEEK(adr+&H80)
  ELSE
    rwert=0
  ENDIF
RETURN
'
' ------------------------------------------------------------------------------
'          HardwareabhÑngiger Teil - Datenzugriff Register Write/Read
' ------------------------------------------------------------------------------
'
> PROCEDURE digout(swert!)
  .| Glob. Var.: sth#,extclock#,digana#,ad#,stl#,clk#
  .| Ruft auf  : write_reghigh,write_reglow,digital,digin,analog
  .| Aufruf in : maschruf2-1,maschinit2b-1,maschinit5b-1,maschruf18-1
  .|     maschruf18b-1,newfsel-4,arrsethz-1,traksethz-1,trakforw-4,trkbackw-4
  .|     trkplay-3,arrplay-3,virtual-2,mforw-4,mbackw-4,monitor-2,smpplay-2
  .|     smpauto-1,record-1,
  IF swert!=TRUE THEN
    sth=(sth AND 251)
    sth=sth+4
    @write_reghigh(sth)
    IF digana=TRUE AND ad=1 THEN
      stl=(stl AND 254)
      stl=stl+1
      @write_reglow(stl+clk)
    ENDIF
    IF digana=TRUE AND ad=0 THEN
      @digital
    ENDIF
    @proffmake(TRUE)
  ENDIF
  IF swert!=FALSE THEN
    @digin
    IF ad=1 THEN
      @analog
    ELSE
      @digital
    ENDIF
    @proffmake(FALSE)
  ENDIF
RETURN
'
> PROCEDURE subframe(swert!)
  .| Glob. Var.: sth#
  .| Ruft auf  : write_reghigh
  .| Aufruf in : edhandler-5,
  IF swert!=TRUE THEN
    sth=(sth AND 247)
    sth=sth+8
    @write_reghigh(sth)
  ENDIF
  IF swert!=FALSE THEN
    sth=(sth AND 247)
    @write_reghigh(sth)
  ENDIF
RETURN
'
> PROCEDURE genera(state)
  IF state=TRUE THEN
    IF proff=FALSE THEN
      sth=(sth AND 223)
      sth=sth+32
      @write_reghigh(sth)
    ENDIF
    gen=TRUE
  ELSE
    IF proff=FALSE THEN
      sth=(sth AND 223)
      @write_reghigh(sth)
    ENDIF
    gen=FALSE
  ENDIF
RETURN
'
> PROCEDURE categ0(state)
  IF state=TRUE THEN
    sth=(sth AND 191)
    sth=sth+64
    @write_reghigh(sth)
    cat0=TRUE
  ELSE
    sth=(sth AND 191)
    @write_reghigh(sth)
    cat0=FALSE
  ENDIF
RETURN
'
> PROCEDURE categ1(state)
  IF state=TRUE THEN
    sth=(sth AND 127)
    sth=sth+128
    @write_reghigh(sth)
    cat1=TRUE
  ELSE
    sth=(sth AND 127)
    @write_reghigh(sth)
    cat1=FALSE
  ENDIF
RETURN
'
> PROCEDURE smprate
  .| Glob. Var.: rwert#
  .| Ruft auf  : read_statlow
  .| Aufruf in : edhandler3-1,smpauto-1,record-1,edhandler-1,
  LOCAL r&
  @read_dsp
  r&=rwert
  rwert=SHR(r&,6)
  rwert=(3 AND rwert)
RETURN
'
> PROCEDURE digin
  .| Glob. Var.: sth#
  .| Ruft auf  : write_reghigh
  .| Aufruf in : digout-1,arrmidplay-2,smpplay-2,smppmhlp-2,
  sth=(sth AND 251)
  @write_reghigh(sth)
RETURN
'
> PROCEDURE dspoff
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : do_main-1,
  dspw=0
  std=(std AND 252)
  @write_dsp(std)
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,dspoff&)
    @textfeld(dsp&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE dspin
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : do_main-1,
  dspw=1
  std=(std AND 252)
  std=std+1
  @write_dsp(std)
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,dspin&)
    @textfeld(dsp&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE dspout
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : do_main-1,
  dspw=2
  std=(std AND 252)
  std=std+3
  @write_dsp(std)
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,dspout&)
    @textfeld(dsp&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE volcs(swert!)
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : volwrite-2,
  IF swert!=TRUE THEN
    std=(std AND 27)
    std=std+4
    @write_dsp(std)
  ELSE
    std=(std AND 27)
    @write_dsp(std)
  ENDIF
RETURN
'
> PROCEDURE volclk(swert!)
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : volwrite-5,
  IF swert!=TRUE THEN
    std=(std AND 23)
    std=std+8
    @write_dsp(std)
  ELSE
    std=(std AND 23)
    @write_dsp(std)
  ENDIF
RETURN
'
> PROCEDURE voldatai(swert!)
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : volwrite-3,ext32l-1,ext44l-1,ext48l-1,ext32h-1,ext44h-1
  .|     ext48h-1,ext256-1,ext384-1,
  IF swert!=TRUE THEN
    std=(std AND 15)
    std=std+16
    @write_dsp(std)
  ELSE
    std=(std AND 15)
    @write_dsp(std)
  ENDIF
RETURN
'
> PROCEDURE volwrite(a)
  .| Ruft auf  : volcs,waitchip,voldatai,volclk
  .| Aufruf in : setup-1,peak-1,do_peak-3,
  LOCAL i
  @volcs(FALSE)
  @waitchip
  FOR i=7 TO 0 STEP -1      ! Right Channel
    @voldatai(BTST(a,i))
    @waitchip
    @volclk(TRUE)
    @waitchip
    @volclk(FALSE)
    @waitchip
  NEXT i
  FOR i=7 TO 0 STEP -1      ! Left Channel
    @voldatai(BTST(a,i))
    @waitchip
    @volclk(TRUE)
    @waitchip
    @volclk(FALSE)
    @waitchip
  NEXT i
  @volcs(TRUE)
  @waitchip
  @volclk(FALSE)
  @waitchip
  @voldatai(FALSE)
RETURN
'
> PROCEDURE balwrite(volume,balance,balmax)
  LOCAL i,anfwert
  lbal=volume
  rbal=volume
  anfwert=4 ! maximal bis 9
  dev=anfwert/balmax
  IF balance>0 THEN
    lbal=INT(vol*LOG10(10-dev*balance))
  ENDIF
  IF balance<0 THEN
    rbal=INT(vol*LOG10(10-dev*ABS(balance)))
  ENDIF
  @volcs(FALSE)
  @waitchip
  FOR i=7 TO 0 STEP -1      ! Right Channel
    @voldatai(BTST(rbal,i))
    @waitchip
    @volclk(TRUE)
    @waitchip
    @volclk(FALSE)
    @waitchip
  NEXT i
  FOR i=7 TO 0 STEP -1      ! Left Channel
    @voldatai(BTST(lbal,i))
    @waitchip
    @volclk(TRUE)
    @waitchip
    @volclk(FALSE)
    @waitchip
  NEXT i
  @volcs(TRUE)
  @waitchip
  @volclk(FALSE)
  @waitchip
  @voldatai(FALSE)
RETURN
'
> PROCEDURE waitchip
  .| Aufruf in : volwrite-9,
  LOCAL j
  FOR j=0 TO 10
  NEXT j
RETURN
'
> PROCEDURE opto
  .| Glob. Var.: stl#,ad#,clk#,nr#,smp16&,a$,popups&,opto&,source&
  .| Ruft auf  : write_reglow,textfeld
  .| Aufruf in : do_main-1,
  digsource=0
  stl=(stl AND 17)
  IF ad=0 THEN
    @write_reglow(stl)
  ELSE
    @write_reglow(stl+clk)
  ENDIF
  staes=(staes AND 127)
  @write_aes(staes)
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,opto&)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE coax
  .| Glob. Var.: stl#,ad#,clk#,nr#,smp16&,a$,popups&,coax&,source&
  .| Ruft auf  : write_reglow,textfeld
  .| Aufruf in : do_main-1,
  digsource=1
  stl=(stl AND 17)
  stl=stl+2
  IF ad=0 THEN
    @write_reglow(stl)
  ELSE
    @write_reglow(stl+clk)
  ENDIF
  staes=(staes AND 127)
  @write_aes(staes)
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,coax&)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE aesebu
  .| Glob. Var.: stl#,ad#,clk#,nr#,smp16&,a$,popups&,coax&,source&
  .| Ruft auf  : write_reglow,textfeld
  .| Aufruf in : do_main-1,
  digsource=2
  staes=(staes AND 127)+128
  @write_aes(staes)
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,aesebu&)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE copyone(state)
  copyonebit=state
  staes=(staes AND 253)
  IF state=TRUE THEN
    staes=staes+2
  ENDIF
  @write_aes(staes)
RETURN
'
> PROCEDURE highsampling(state)
  hsbit=state
  staes=(staes AND 251)
  IF state=TRUE THEN
    staes=staes+4
  ENDIF
  @write_aes(staes)
RETURN
'
> PROCEDURE emphoff
  @highsampling(FALSE)
  IF proff=FALSE THEN
    sth=(sth AND 239)
    @write_reghigh(sth)
  ELSE
    @categ1(TRUE)
    @categ0(TRUE)
  ENDIF
  empha=FALSE
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,emphoff&)
    @textfeld(emphasis&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE emphon
  @highsampling(TRUE)
  IF proff=FALSE THEN
    sth=(sth AND 239)
    sth=sth+16
    @write_reghigh(sth)
  ELSE
    @categ1(TRUE)
    @categ0(FALSE)
  ENDIF
  empha=TRUE
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,emphon&)
    @textfeld(emphasis&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE emphproff(state)
  sth=(sth AND 239)
  IF state=TRUE THEN
    sth=sth+16
  ENDIF
  @write_reghigh(sth)
RETURN
'
> PROCEDURE generaproff(state)
  IF state=TRUE THEN
    sth=(sth AND 223)
    sth=sth+32
    @write_reghigh(sth)
  ELSE
    sth=(sth AND 223)
    @write_reghigh(sth)
  ENDIF
RETURN
'
> PROCEDURE emphasis
  @read_statmid
  rwert=(rwert AND 128)
RETURN
'
> PROCEDURE consumer
  IF proffm=TRUE THEN
    proffm=FALSE
    cat0=catb0
    cat1=catb1
    @prot(scms)
    @genera(gen)
    @categ0(cat0)
    @categ1(cat1)
    IF empha=TRUE THEN
      @emphon
    ELSE
      @emphoff
    ENDIF
  ENDIF
  staes=(staes AND 254)
  @write_aes(staes)
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,consumer&)
    @textfeld(mode&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE proffhz
  IF hz=32000 THEN
    @protproff(TRUE)
    @emphproff(TRUE)
    @generaproff(TRUE)
  ENDIF
  IF hz=44100 THEN
    @protproff(TRUE)
    @emphproff(FALSE)
    @generaproff(TRUE)
  ENDIF
  IF hz=48000 THEN
    @protproff(FALSE)
    @emphproff(TRUE)
    @generaproff(TRUE)
  ENDIF
RETURN
'
> PROCEDURE proffmake(state)
  IF proffm=TRUE THEN
    IF state=TRUE THEN
      proff=TRUE
      catb0=cat0
      catb1=cat1
      @proffhz
      IF empha=TRUE THEN
        @emphon
      ELSE
        @emphoff
      ENDIF
      @generaproff(TRUE)
      staes=(staes AND 254)+1
      @write_aes(staes)
    ELSE
      proff=FALSE
      cat0=catb0
      cat1=catb1
      @prot(scms)
      @genera(gen)
      @categ0(cat0)
      @categ1(cat1)
      IF empha=TRUE THEN
        @emphon
      ELSE
        @emphoff
      ENDIF
      staes=(staes AND 254)
      @write_aes(staes)
    ENDIF
  ELSE
    IF state=TRUE THEN
      @copyone(bridg1)
      @prot(bridg2)
    ELSE
      @copyone(bridg3)
      @prot(bridg4)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE profess
  proffm=TRUE
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,profess&)
    @textfeld(mode&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE prot(state)
  IF state=TRUE THEN
    IF proff=FALSE THEN
      sth=(sth AND 254)
      sth=sth+1
      @write_reghigh(sth)
    ENDIF
    scms=TRUE
  ELSE
    IF proff=FALSE THEN
      sth=(sth AND 254)
      @write_reghigh(sth)
    ENDIF
    scms=FALSE
  ENDIF
RETURN
'
> PROCEDURE protproff(state)
  IF state=TRUE THEN
    sth=(sth AND 254)
    sth=sth+1
    @write_reghigh(sth)
  ELSE
    sth=(sth AND 254)
    @write_reghigh(sth)
  ENDIF
RETURN
'
> PROCEDURE scmsfree
  scmsw=2
  IF proff=FALSE THEN
    @genera(TRUE)    ! false geht auch
    @categ0(TRUE)
    @categ1(TRUE)
    bridg1=FALSE
    bridg2=TRUE
    IF bridge=FALSE THEN
      @copyone(bridg1)
      @prot(bridg2)
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,scmsfree&)
    @textfeld(protect&,a$,1)
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE scmsone
  scmsw=1
  IF proff=FALSE THEN
    @genera(FALSE)
    @categ0(FALSE)
    @categ1(FALSE)
    bridg1=TRUE
    bridg2=TRUE
    IF bridge=FALSE THEN
      @copyone(bridg1)
      @prot(bridg2)
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,scmsone&)
    @textfeld(protect&,a$,1)
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE scmsno
  scmsw=0
  IF proff=FALSE THEN
    @genera(TRUE)
    @categ0(TRUE)
    @categ1(TRUE)
    bridg1=FALSE
    bridg2=FALSE
    IF bridge=FALSE THEN
      @copyone(bridg1)
      @prot(bridg2)
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,scmsno&)
    @textfeld(protect&,a$,1)
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE digibridge
  IF bridge=FALSE THEN
    bridge=TRUE
    staes=(staes AND 253)+2
    @write_aes(staes)
    bridg3=TRUE
    bridg4=FALSE
    IF proff=FALSE THEN
      @prot(bridg4)
    ENDIF
    IF nr=smp16& THEN
      setbutton(bridge&,1)
    ENDIF
  ELSE
    bridge=FALSE
    bridg3=copyonebit
    bridg4=scms
    @copyone(copyonebit)
    @prot(scms)
    IF nr=smp16& THEN
      setbutton(bridge&,0)
    ENDIF
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE fifodel
  .| Glob. Var.: sth#
  .| Ruft auf  : write_reghigh
  .| Aufruf in : maschruf4-1,peak-1,peakread-1,smpauto-1,smpstart-1,
  sth=(sth AND 253)+2
  @write_reghigh(sth)
  sth=(sth AND 253)
  @write_reghigh(sth)
RETURN
'
> PROCEDURE adlow
  hz=32000
  clk=4
  @adctrl
RETURN
'
> PROCEDURE admid
  hz=44100
  clk=8
  @adctrl
RETURN
'
> PROCEDURE adhigh
  hz=48000
  clk=12
  @adctrl
RETURN
'
> PROCEDURE ad8
  hz=8000
  clk=4+16+64+128
  @adctrl
RETURN
'
> PROCEDURE ad11
  hz=11000
  clk=4+16+64
  @adctrl
RETURN
'
> PROCEDURE ad12
  hz=12000
  clk=16+64+128
  @adctrl
RETURN
'
> PROCEDURE ad16
  hz=16000
  clk=4+16+128
  @adctrl
RETURN
'
> PROCEDURE ad17
  hz=17000
  clk=16+64
  @adctrl
RETURN
'
> PROCEDURE ad22
  hz=22000
  clk=4+16
  @adctrl
RETURN
'
> PROCEDURE ad24
  hz=24000
  clk=16+128
  @adctrl
RETURN
'
> PROCEDURE ad33
  hz=33000
  clk=16
  @adctrl
RETURN
'
> PROCEDURE adextl1
  hz=256
  clk=16+32
  @adctrl
RETURN
'
> PROCEDURE adexth1
  hz=384
  clk=4+16+32
  @adctrl
RETURN
'
> PROCEDURE adextl2
  hz=512
  clk=16+32+64
  @adctrl
RETURN
'
> PROCEDURE adexth2
  hz=768
  clk=4+16+32+64
  @adctrl
RETURN
'
> PROCEDURE adctrl
  stl=(stl AND 3)
  IF ad=0 THEN
    @digital
  ELSE
    @analog
  ENDIF
  @makehz
RETURN
'
> PROCEDURE analog
  .| Glob. Var.: extclock#,stl#,digana#,clk#,ad#,nr#,smp16&,a$,popups&,analog&
  .|     input&
  .| Ruft auf  : write_reglow,textfeld,makehz
  .| Aufruf in : digout-1,adlow-1,admid-1,adhigh-1,do_main-1,arrsethz-1
  .|     traksethz-1,trkplay-1,arrmidplay-1,arrplay-1,setup2-1,smpplay-2
  .|     smppmhlp-1,
  stl=(stl AND 2)
  stl=stl+1
  IF digana=TRUE THEN
    @write_reglow(stl+clk)
  ELSE
    @write_reglow(stl)
  ENDIF
  ad=1
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,analog&)
    @textfeld(input&,a$,1)
  ENDIF
  @makehz
  IF digana=FALSE THEN
    @digital
  ELSE
    '    @digout(TRUE)
  ENDIF
RETURN
'
> PROCEDURE digital
  .| Glob. Var.: extclock#,stl#,ad#,nr#,smp16&,a$,popups&,digital&,input&
  .| Ruft auf  : write_reglow,textfeld,makehz
  .| Aufruf in : digout-2,do_main-1,trkplay-1,arrmidplay-1,arrplay-1
  .|     smpplay-2,smppmhlp-1,
  @write_reghigh(sth)
  stl=(stl AND 2)
  @write_reglow(stl)
  ad=0
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,digital&)
    @textfeld(input&,a$,1)
  ENDIF
  @makehz
RETURN
'
> PROCEDURE makehz
  .| Glob. Var.: digana#,extclock#,clk#,hz#,hzc#,rwert#,ohz#,retime#,hzm#
  .| Ruft auf  : fliphz,read_statlow
  .| Aufruf in : adlow-1,admid-1,adhigh-1,ext32l-1,ext44l-1,ext48l-1,ext32h-1
  .|     ext44h-1,ext48h-1,ext256-1,ext384-1,analog-1,digital-1,smpsave-1
  .|     ldhlp-2,infrett-1,smpinfbutt-1,ldhead-1,resample-1,arranger-1
  .|     trakker-1,trkplay-1,arrplay-1,smpedit-1,time_edit-1,make-1,trash-1
  .|     setupdat-1,setup2-1,conspace-1,
  IF digana=TRUE THEN
    @fliphz
  ENDIF
  IF digana=FALSE THEN
    @smprate
    hzc=rwert
    ohz=hz
    IF hzc=3 THEN
      hz=32000
    ENDIF
    IF hzc=0 THEN
      hz=44100
    ENDIF
    IF hzc=2 THEN
      hz=48000
    ENDIF
    IF digana=FALSE AND ohz<>hz THEN
      @fliphz
    ENDIF
  ENDIF
  IF retime=1 THEN
    hz=hzm
  ENDIF
  IF hz<>256 AND hz<>384 AND hz<>512 AND hz<>768 THEN
    hz=INT(hz/100)*100
  ENDIF
  IF hz=0 THEN
    hz=44100
  ENDIF
RETURN
'
> PROCEDURE makehz2
  .| Glob. Var.: ad#,digana#,extclock#,clk#,hz#,hzc#,rwert#,ohz#,retime#,hzm#
  .| Ruft auf  : fliphz,read_statlow
  .| Aufruf in : smpauto-1,smpstart-1,
  IF ad=1 AND digana=TRUE THEN
    @fliphz
  ENDIF
  IF ad=0 OR digana=FALSE THEN
    @smprate
    hzc=rwert
    ohz=hz
    IF hzc=3 THEN
      hz=32000
    ENDIF
    IF hzc=0 THEN
      hz=44100
    ENDIF
    IF hzc=2 THEN
      hz=48000
    ENDIF
    IF digana=FALSE AND ohz<>hz THEN
      @fliphz
    ENDIF
  ENDIF
  IF retime=1 THEN
    hz=hzm
  ENDIF
  IF hz<>256 AND hz<>384 AND hz<>512 AND hz<>768 THEN
    hz=INT(hz/100)*100
  ENDIF
RETURN
'
> PROCEDURE fliphz
  .| Glob. Var.: nr#,smpedit&,extclock#,hz#,a$,popups&,rate32&,rate&,rate44&
  .|     rate48&,ext#,ext32l&,ext44l&,ext48l&,ext32h&,ext44h&,ext48h&
  .|     rateextl&,rateexth&,smp16&,ad32&,rate2&,ad44&,ad48&,adext32l&
  .|     adext44l&,adext48l&,adext32h&,adext44h&,adext48h&,adextl&,adexth&
  .| Ruft auf  : textfeld
  .| Aufruf in : makehz-2,makehz2-2,sethertz-1,rebuild-1,
  IF nr=smpedit& THEN
    IF hz=32000 THEN
      a$=@rsc_text$(popups&,rate32&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=44100 THEN
      a$=@rsc_text$(popups&,rate44&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=48000 THEN
      a$=@rsc_text$(popups&,rate48&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=8000 THEN
      a$=@rsc_text$(popups&,rate8&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=11000 THEN
      a$=@rsc_text$(popups&,rate11&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=12000 THEN
      a$=@rsc_text$(popups&,rate12&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=16000 THEN
      a$=@rsc_text$(popups&,rate16&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=17000 THEN
      a$=@rsc_text$(popups&,rate17&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=22000 THEN
      a$=@rsc_text$(popups&,rate22&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=24000 THEN
      a$=@rsc_text$(popups&,rate24&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=33000 THEN
      a$=@rsc_text$(popups&,rate33&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext=768 THEN
      a$=@rsc_text$(popups&,ratexth2&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=512 THEN
      a$=@rsc_text$(popups&,ratextl2&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext=384 THEN
      a$=@rsc_text$(popups&,ratexth1&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=256 THEN
      a$=@rsc_text$(popups&,ratextl1&)
      @textfeld(rate&,a$,1)
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    IF hz=32000 THEN
      a$=@rsc_text$(popups&,ad32&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=44100 THEN
      a$=@rsc_text$(popups&,ad44&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=48000 THEN
      a$=@rsc_text$(popups&,ad48&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=8000 THEN
      a$=@rsc_text$(popups&,ad8&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=11000 THEN
      a$=@rsc_text$(popups&,ad11&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=12000 THEN
      a$=@rsc_text$(popups&,ad12&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=16000 THEN
      a$=@rsc_text$(popups&,ad16&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=17000 THEN
      a$=@rsc_text$(popups&,ad17&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=22000 THEN
      a$=@rsc_text$(popups&,ad22&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=24000 THEN
      a$=@rsc_text$(popups&,ad24&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=33000 THEN
      a$=@rsc_text$(popups&,ad33&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=768 THEN
      a$=@rsc_text$(popups&,adexth2&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=512 THEN
      a$=@rsc_text$(popups&,adextl2&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=384 THEN
      a$=@rsc_text$(popups&,adexth1&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=256 THEN
      a$=@rsc_text$(popups&,adextl1&)
      @textfeld(rate2&,a$,1)
    ENDIF
  ENDIF
  IF proff=TRUE THEN
    @proffhz
  ENDIF
RETURN
'
> PROCEDURE fliphz2
  IF hz=32000 THEN
    @adlow
  ENDIF
  IF hz=44100 THEN
    @admid
  ENDIF
  IF hz=48000 THEN
    @adhigh
  ENDIF
  IF hz=8000 THEN
    @ad8
  ENDIF
  IF hz=11000 THEN
    @ad11
  ENDIF
  IF hz=12000 THEN
    @ad12
  ENDIF
  IF hz=16000 THEN
    @ad16
  ENDIF
  IF hz=17000 THEN
    @ad17
  ENDIF
  IF hz=22000 THEN
    @ad22
  ENDIF
  IF hz=24000 THEN
    @ad24
  ENDIF
  IF hz=33000 THEN
    @ad33
  ENDIF
  IF hz=768 THEN
    @adexth2
  ENDIF
  IF hz=512 THEN
    @adextl2
  ENDIF
  IF hz=384 THEN
    @adexth1
  ENDIF
  IF hz=256 THEN
    @adextl1
  ENDIF
  IF proff=TRUE THEN
    @proffhz
  ENDIF
RETURN
'
'
' ------------------------------------------------------------------------------
' ------------------------ASSEMBLER-ROUTINEN------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE maschinit
  .| Glob. Var.: mdat2%
  .| Aufruf in : smpsave-1,ldhlp-1,
  LOCAL a,g
  ' LOAD/SAVE
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0  ; von
  ' 226F0044                       movea.l   68(sp),a1  ; nach
  ' 202F0048                       move.l    72(sp),d0 ; Len
  ' D088                           add.l     a0,d0
  ' 12D8                 anf2:     move.b    (a0)+,(a1)+
  ' B1C0                           cmp.l     d0,a0
  ' 6600FFFA                       bne       anf2
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfmasch:
  DATA &H48e7,&Hfffe
  DATA &H206f,&H0040
  DATA &H226f,&H0044
  DATA &H202F,&H0048
  DATA &Hd088
  DATA &H12d8
  DATA &Hb1c0
  DATA &H6600,&Hfffa
  DATA &H4cdf,&H7fff
  DATA &H4e75
  '
  RESTORE anfmasch
  FOR g=0 TO 30 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf
  .| Glob. Var.: saa%,a#,sba%,b#,ena%,l#,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpsave-1,ldhlp-1,
  ' LOAD/SAVE
  '
  @busy_mouse
  saa%=a
  sba%=b
  ena%=l
  ~C:mdat2%(L:saa%,L:sba%,L:ena%)
RETURN
'
> PROCEDURE maschinit2
  .| Glob. Var.: mdat2%,back%
  .| Aufruf in : smpplay-1,smppmhlp-1,
  LOCAL a,g
  ' PLAY
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 282F0048                       move.l    72(sp),d4  ; Anzahl der For/Backstep
  ' 262F004C                       move.l    76(sp),d3  ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi)
  ' 242F0050                       move.l    80(sp),d2  ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
  ' 202F0054                       move.l    84(sp),d0  ; midi
  ' 206F0058                       move.l    88(sp),a0  ; StatH im Bytemode
  ' 226F005C                       move.l    92(sp),a1  ; Playread im Wordmode
  ' 286F0060                       move.l    96(sp),a4  ; Returnwert (momentanes Playbyte & Anzahl der loops)
  ' 45FA015C                       lea.l     midisuch(pc),a2
  ' 3480                           move.w    d0,(a2)
  ' 45FA0158                       lea.l     midiw(pc),a2
  ' 24BC00000000                   move.l    #0,(a2)
  ' 7C00                           moveq.l   #0,d6      ; LoopzÑhler
  ' 7A08                           moveq.l   #8,d5
  ' 61000044             anf:      bsr       play
  ' 4A40                           tst.w     d0
  ' 6632                           bne.s     weg
  ' 08030001             crosstst: btst      #1,d3
  ' 6724                           beq.s     looptst
  ' 5084                           addq.l    #8,d4
  ' 4484                           neg.l     d4
  ' 2001                           move.l    d1,d0
  ' 5980                           subq.l    #4,d0
  ' 220B                           move.l    a3,d1
  ' 5881                           addq.l    #4,d1
  ' 2640                           movea.l   d0,a3
  ' 61000028                       bsr       play
  ' 4A40                           tst.w     d0
  ' 6616                           bne.s     weg
  ' 4484                           neg.l     d4
  ' 5184                           subq.l    #8,d4
  ' 2001                           move.l    d1,d0
  ' 5980                           subq.l    #4,d0
  ' 220B                           move.l    a3,d1
  ' 5881                           addq.l    #4,d1
  ' 2640                           movea.l   d0,a3
  ' 08030000             looptst:  btst      #0,d3
  ' 6702                           beq.s     weg
  ' 60C6                           bra.s     anf
  ' 288A                 weg:      move.l    a2,(a4)   ; Returnwert Playbyte speichern
  ' 29460004                       move.l    d6,4(a4)  ; Returnwert Anzahl loops speichern
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 244B                 play:     movea.l   a3,a2
  ' 1010                 fill:     move.b    (a0),d0   ; FIFO halbleer ?
  ' C005                           and.b     d5,d0
  ' 660A                           bne.s     copyanf
  ' 610000E4                       bsr       brktst
  ' 4A40                           tst.w     d0
  ' 6642                           bne.s     playex
  ' 60F0                           bra.s     fill
  ' 3002                 copyanf:  move.w    d2,d0     ; ...dann FIFO halb-fuellen (fifolen)!
  ' 1E1A                 copy:     move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Rechter Kanal (Bit 8 geloescht)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Rechter Kanal (Bit 8 geloescht)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Linker Kanal (Bit 8 gesetzt)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Linker Kanal (Bit 8 gesetzt)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' B5C1                           cmpa.l    d1,a2
  ' 671E                           beq.s     playend
  ' D5C4                           adda.l    d4,a2
  ' 51C8FFE0                       dbra      d0,copy
  ' 610000B6                       bsr       brktst
  ' 4A40                           tst.w     d0
  ' 6614                           bne.s     playex
  ' 08030002                       btst      #2,d3
  ' 67BE                           beq.s     fill
  ' 6100000E                       bsr       midi
  ' 4A40                           tst.w     d0
  ' 6606                           bne.s     playex
  ' 60B4                           bra.s     fill
  ' 7000                 playend:  moveq.l   #0,d0
  ' 5286                           addq.l    #1,d6
  ' 4E75                 playex:   rts
  ' 48E77FF8             midi:     movem.l   d1-d7/a0-a4,-(sp)
  ' 41FA00AA                       lea.l     midisuch(pc),a0
  ' 3410                           move.w    (a0),d2
  ' 3F02                           move.w    d2,-(sp)
  ' 3F3C0003                       move.w    #3,-(sp)  ; MIDI
  ' 3F3C0001                       move.w    #1,-(sp)  ; Bconstat
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' B07C0000                       cmp.w     #0,d0
  ' 6768                           beq.s     nomidi
  ' 3F3C0003                       move.w    #3,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)  ; Bconin
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 341F                           move.w    (sp)+,d2
  ' 3F02                           move.w    d2,-(sp)
  ' 41FA0082                       lea.l     midiw(pc),a0
  ' 08000007                       btst      #7,d0
  ' 6708                           beq.s     midi2     ; Daten oder Befehl ?
  ' E042                           asr.w     #8,d2     ; Channel im oberen Byte des Wortes
  ' 9002                           sub.b     d2,d0     ; Channel vom Befehl abziehen
  ' 1080                           move.b    d0,(a0)   ; Befehl schreiben
  ' 6046                           bra.s     nomidi
  ' B002                 midi2:    cmp.b     d2,d0       ; Noten-DATA ?
  ' 671E                           beq.s     midi4
  ' B4280001                       cmp.b     1(a0),d2    ; Noten-data schon gewesen und korrekt ?
  ' 663C                           bne.s     nomidi
  ' 11400002             midi3:    move.b    d0,2(a0)    ; Velocitywert schreiben
  ' 0C100080                       cmp.b     #$80,(a0)   ; NOTE OFF ?
  ' 671A                           beq.s     midi5
  ' 0C100090                       cmp.b     #$90,(a0)   ; NOTE ON ?
  ' 671C                           beq.s     midi6
  ' 20BC00000000         midi3b:   move.l    #0,(a0)     ; Datenwort lîschen
  ' 6024                           bra.s     nomidi
  ' B4280001             midi4:    cmp.b     1(a0),d2    ; Noten-DATA schon gewesen ?
  ' 67E2                           beq.s     midi3       ; dann ist es nicht Note sondern Velocity
  ' 11400001                       move.b    d0,1(a0)    ; Notenwert schreiben
  ' 6018                           bra.s     nomidi
  ' B4280001             midi5:    cmp.b     1(a0),d2    ; NOTE OFF und Note OK ?
  ' 66E6                           bne.s     midi3b      ; wenn nein, Datenwort lîschen
  ' 601A                           bra.s     midiex      ; Abbruch, da NOTE OFF !
  ' B4280001             midi6:    cmp.b     1(a0),d2    ; NOTE ON und Note OK ?
  ' 66DE                           bne.s     midi3b      ; wenn nein, Datenwort lîschen
  ' 0C2800000002                   cmp.b     #0,2(a0)    ; Velocity ist Null ?
  ' 66D6                           bne.s     midi3b      ; wenn nein, Datenwort lîschen
  ' 600A                           bra.s     midiex      ; Abbruch, da NOTE ON und Velo=Null !
  ' 341F                 nomidi:   move.w    (sp)+,d2
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 7000                           moveq.w   #0,d0
  ' 4E75                           rts
  ' 341F                 midiex:   move.w    (sp)+,d2
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 7001                           moveq.w   #1,d0
  ' 4E75                           rts
  ' 48E77FF8             brktst:   movem.l   d1-d7/a0-a4,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 4E75                           rts
  ' 0000                 midisuch: dc.w 0
  ' 00000000             midiw:    dc.l 0
anfbmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H282F,&H0048
  DATA &H262F,&H004C
  DATA &H242F,&H0050
  DATA &H202F,&H0054
  DATA &H206F,&H0058
  DATA &H226F,&H005C
  DATA &H286F,&H0060
  DATA &H45FA,&H015C
  DATA &H3480
  DATA &H45FA,&H0158
  DATA &H24BC,&H0000,&H0000
  DATA &H7C00
  DATA &H7A08
  DATA &H6100,&H0044
  DATA &H4A40
  DATA &H6632
  DATA &H0803,&H0001
  DATA &H6724
  DATA &H5084
  DATA &H4484
  DATA &H2001
  DATA &H5980
  DATA &H220B
  DATA &H5881
  DATA &H2640
  DATA &H6100,&H0028
  DATA &H4A40
  DATA &H6616
  DATA &H4484
  DATA &H5184
  DATA &H2001
  DATA &H5980
  DATA &H220B
  DATA &H5881
  DATA &H2640
  DATA &H0803,&H0000
  DATA &H6702
  DATA &H60C6
  DATA &H288A
  DATA &H2946,&H0004
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H244B
  DATA &H1010
  DATA &HC005
  DATA &H660A
  DATA &H6100,&H00E4
  DATA &H4A40
  DATA &H6642
  DATA &H60F0
  DATA &H3002
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &HB5C1
  DATA &H671E
  DATA &HD5C4
  DATA &H51C8,&HFFE0
  DATA &H6100,&H00B6
  DATA &H4A40
  DATA &H6614
  DATA &H0803,&H0002
  DATA &H67BE
  DATA &H6100,&H000E
  DATA &H4A40
  DATA &H6606
  DATA &H60B4
  DATA &H7000
  DATA &H5286
  DATA &H4E75
  DATA &H48E7,&H7FF8
  DATA &H41FA,&H00AA
  DATA &H3410
  DATA &H3F02
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &HB07C,&H0000
  DATA &H6768
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0002
  DATA &H4E4D
  DATA &H588F
  DATA &H341F
  DATA &H3F02
  DATA &H41FA,&H0082
  DATA &H0800,&H0007
  DATA &H6708
  DATA &HE042
  DATA &H9002
  DATA &H1080
  DATA &H6046
  DATA &HB002
  DATA &H671E
  DATA &HB428,&H0001
  DATA &H663C
  DATA &H1140,&H0002
  DATA &H0C10,&H0080
  DATA &H671A
  DATA &H0C10,&H0090
  DATA &H671C
  DATA &H20BC,&H0000,&H0000
  DATA &H6024
  DATA &HB428,&H0001
  DATA &H67E2
  DATA &H1140,&H0001
  DATA &H6018
  DATA &HB428,&H0001
  DATA &H66E6
  DATA &H601A
  DATA &HB428,&H0001
  DATA &H66DE
  DATA &H0C28,&H0000,&H0002
  DATA &H66D6
  DATA &H600A
  DATA &H341F
  DATA &H4CDF,&H1FFE
  DATA &H7000
  DATA &H4E75
  DATA &H341F
  DATA &H4CDF,&H1FFE
  DATA &H7001
  DATA &H4E75
  DATA &H48E7,&H7FF8
  DATA &H3F3C,&H0002
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H1FFE
  DATA &H4E75
  DATA &H0000
  DATA &H0000,&H0000
  '
  RESTORE anfbmasch
  FOR g=0 TO 394 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  back%=-1
RETURN
'
> PROCEDURE maschruf2
  .| Glob. Var.: demo#,saa%,a#,sba%,b#,sca%,adder#,sda%,l#,sea%,playfifolen#
  .|     sfa%,midiwort#,sga%,adr#,sha%,wback%,sia%,mdat%,t#,meml#,nr#,smpedit&
  .|     back%,back2%,back3%,hsec2#,hsec#,smpsec&,a$,sec$,mdat2%
  .| Ruft auf  : busy_mouse,digout,intzeiger1,htimeset,textfeld,intzeiger2
  .|     mousek,intzeiger3
  .| Aufruf in : smpplay-2,smppmhlp-2,
  LOCAL p,b$
  @busy_mouse
  ' PLAY
  '
  IF demo=FALSE THEN
    @digout(TRUE)
    saa%=a
    sba%=b
    sca%=adder
    sda%=l
    sea%=playfifolen/8-1
    sfa%=midiwort
    sga%=adr+&H40
    sha%=adr+&H200
    LPOKE wback%,0
    LPOKE wback%+4,0
    sia%=wback%
    p=mdat%
    IF XBIOS(500)=&H71273800 THEN
      a=XBIOS(111,L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:sfa%,L:sga%,L:sha%)
      PAUSE 5
      @write_int(1)
      t=TIMER
      b=4*INT((saa%-meml)/4)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      LPOKE a+16,0
      REPEAT
      UNTIL @mousek=0
      wleer=0
      REPEAT
        back%=LPEEK(a)
        back2%=LPEEK(a+4)
        back3%=LPEEK(a+8)
        wleer2=LPEEK(a+16)
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF wleer2<>wleer THEN
              wleer=wleer2
              b$=STR$(wleer)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            b=4*INT((back%-meml)/4)
            @intzeiger2(b)
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
      UNTIL back3%=1 OR k=3 OR k=2
      @write_int(0)
      IF nr=smpedit& THEN
        @intzeiger3
        @textfeld(smpsec&,sec$,1)
      ENDIF
    ELSE
      POKE p,7
      POKE p+1,4
      ~XBIOS(25,1,L:p)
      ~C:mdat2%(L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:sfa%,L:sga%,L:sha%,L:sia%)
      p=mdat%
      PAUSE 20
      POKE p,7
      POKE p+1,0
      ~XBIOS(25,1,L:p)
    ENDIF
    IF XBIOS(500)<>&H71273800 THEN
      back%=LPEEK(wback%)
      back2%=LPEEK(wback%+4)
    ENDIF
  ELSE
    back%=0
    back2%=0
  ENDIF
RETURN
'
> PROCEDURE maschinit2b
  .| Glob. Var.: mdat2%,demo#,sea%,playfifolen#,sga%,adr#,sha%,sia%,wback%
  .|     mdat%,back%
  .| Ruft auf  : busy_mouse,digout
  .| Aufruf in : maschruf18-1,maschruf18b-1,trkplay-1,arrplay-1,
  LOCAL a,g,p
  ' PLAY (fÅr Midiplay) - vorher
  '
  RESTORE anfbmasch
  FOR g=0 TO 394 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  @busy_mouse
  IF demo=FALSE THEN
    @digout(TRUE)
    sea%=playfifolen/8-1
    sga%=adr+&H40
    sha%=adr+&H200
    sia%=wback%
  ENDIF
  IF XBIOS(500)<>&H71273800 THEN
    p=mdat%
    POKE p,7
    POKE p+1,4
    ~XBIOS(25,1,L:p)
  ENDIF
  back%=-1
RETURN
'
> PROCEDURE maschruf2c
  .| Glob. Var.: sca%,adder#,sda%,l#,sfa%,midiwort#,wback%,back%,demo#,a#,saa%
  .|     sba%,sea%,sga%,sha%,back2%,mdat2%,sia%
  .| Aufruf in : maschruf18-1,maschruf18b-1,trkplay-1,arrplay-1,
  ' PLAY (fÅr Midiplay) - jedesmal aufrufen
  sca%=adder
  sda%=l+4
  sfa%=midiwort
  LPOKE wback%,0
  LPOKE wback%+4,0
  back%=-1
  IF demo=FALSE THEN
    IF XBIOS(500)=&H71273800 THEN
      a=XBIOS(101,L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:sfa%,L:sga%,L:sha%)
      back%=LPEEK(a)
      back2%=LPEEK(a+4)
    ELSE
      ~C:mdat2%(L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:sfa%,L:sga%,L:sha%,L:sia%)
      back%=LPEEK(wback%)
      back2%=LPEEK(wback%+4)
    ENDIF
  ELSE
    back%=0
    back2%=0
  ENDIF
RETURN
'
> PROCEDURE maschinit2d
  .| Glob. Var.: mdat%
  .| Aufruf in : maschruf18-1,maschruf18b-1,trkplay-1,arrplay-1,
  LOCAL p
  ' PLAY (fÅr Midiplay) - nachher
  PAUSE 20
  p=mdat%
  POKE p,7
  POKE p+1,0
  ~XBIOS(25,1,L:p)
RETURN
'
> PROCEDURE maschinit3
  .| Glob. Var.: mdat2%
  .| Aufruf in : smpauto-1,record-1,
  LOCAL a,g
  ' RECORD
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 246F0040                       movea.l   64(sp),a2  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 242F0048                       move.l    72(sp),d2  ; Inhalt REGH
  ' 286F004C                       movea.l   76(sp),a4  ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
  ' 206F0050                       move.l    80(sp),a0  ; StatH im Bytemode
  ' 226F0054                       move.l    84(sp),a1  ; Playread im Wordmode
  ' 08C20001                       bset      #1,d2      ; REC-FIFO loeschen
  ' 1082                           move.b    d2,(a0)
  ' 08820001                       bclr      #1,d2
  ' 1082                           move.b    d2,(a0)
  ' 7408                           moveq.l   #8,d2
  ' 7602                           moveq.l   #2,d3
  ' 7008                 anf:      moveq.w   #8,d0
  ' 3A11                 anf2:     move.w    (a1),d5   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0505                           btst      d2,d5
  ' 6708                           beq.s     anf3      ; fehlerhafte Daten ?
  ' 3811                           move.w    (a1),d4   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0504                           btst      d2,d4
  ' 6702                           beq.s     anf3      ; fehlerhafte Daten ?
  ' 600E                           bra.s     anf4
  ' 51C8FFF0             anf3:     dbra      d0,anf2   ; 8x versuchen zu synchronisieren
  ' 61000052                       bsr       brktst    ; dann abbruch testen
  ' 4A40                           tst.w     d0
  ' 6646                           bne.s     weg
  ' 60E2                           bra.s     anf       ; wiederholen bis synchronisiert
  ' 1010                 anf4:     move.b    (a0),d0   ; Flag lesen
  ' C003                           and.b     d3,d0     ; FIFO mehr als halbvoll ?
  ' 670A                           beq.s     copy      ; wenn ja, daten einlesen
  ' 61000042                       bsr       brktst    ; dann abbruch testen
  ' 4A40                           tst.w     d0
  ' 6636                           bne.s     weg
  ' 60F0                           bra.s     anf4
  ' 300C                 copy:     move.w    a4,d0     ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
  ' 3E11                 copy2:    move.w    (a1),d7   ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0507                           btst      d2,d7
  ' 661E                           bne.s     copy3     ; fehlerhafte Daten ?
  ' 3C11                           move.w    (a1),d6   ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0506                           btst      d2,d6
  ' 6618                           bne.s     copy3     ; fehlerhafte Daten ?
  ' 3A11                           move.w    (a1),d5   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0505                           btst      d2,d5
  ' 6712                           beq.s     copy3     ; fehlerhafte Daten ?
  ' 3811                           move.w    (a1),d4   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0504                           btst      d2,d4
  ' 670C                           beq.s     copy3     ; fehlerhafte Daten ?
  ' 14C7                           move.b    d7,(a2)+
  ' 14C6                           move.b    d6,(a2)+
  ' 14C5                           move.b    d5,(a2)+
  ' 14C4                           move.b    d4,(a2)+
  ' B5C1                           cmpa.l    d1,a2     ; Speicher voll ?
  ' 670E                           beq.s     weg
  ' 51C8FFDA             copy3:    dbra      d0,copy2
  ' 6100000E                       bsr       brktst    ; abbruch testen
  ' 4A40                           tst.w     d0
  ' 6602                           bne.s     weg
  ' 60BC                           bra.s     anf4
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 48E77FF8             brktst:   movem.l   d1-d7/a0-a4,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 4E75                           rts
anfcmasch:
  DATA &H48E7,&HFFFE
  DATA &H246F,&H0040
  DATA &H222F,&H0044
  DATA &H242F,&H0048
  DATA &H286F,&H004C
  DATA &H206F,&H0050
  DATA &H226F,&H0054
  DATA &H08C2,&H0001
  DATA &H1082
  DATA &H0882,&H0001
  DATA &H1082
  DATA &H7408
  DATA &H7602
  DATA &H7008
  DATA &H3A11
  DATA &H0505
  DATA &H6708
  DATA &H3811
  DATA &H0504
  DATA &H6702
  DATA &H600E
  DATA &H51C8,&HFFF0
  DATA &H6100,&H0052
  DATA &H4A40
  DATA &H6646
  DATA &H60E2
  DATA &H1010
  DATA &HC003
  DATA &H670A
  DATA &H6100,&H0042
  DATA &H4A40
  DATA &H6636
  DATA &H60F0
  DATA &H300C
  DATA &H3E11
  DATA &H0507
  DATA &H661E
  DATA &H3C11
  DATA &H0506
  DATA &H6618
  DATA &H3A11
  DATA &H0505
  DATA &H6712
  DATA &H3811
  DATA &H0504
  DATA &H670C
  DATA &H14C7
  DATA &H14C6
  DATA &H14C5
  DATA &H14C4
  DATA &HB5C1
  DATA &H670E
  DATA &H51C8,&HFFDA
  DATA &H6100,&H000E
  DATA &H4A40
  DATA &H6602
  DATA &H60BC
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H48E7,&H7FF8
  DATA &H3F3C,&H0002
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H1FFE
  DATA &H4E75
  '
  RESTORE anfcmasch
  FOR g=0 TO 168 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf3
  .| Glob. Var.: demo#,sab%,a#,sbb%,l#,scb%,sth#,sdb%,recfifolen#,seb%,adr#
  .|     sfb%,nr#,peak&,t#,b#,saa%,meml#,smpedit&,hsec#,hz#,peakmax&,a$
  .|     peakint#,back%,back3%,hsec2#,smpsec&,peakpos&,peakret#,sec$,edit_obj&
  .|     idx&,tree&,mdat%,mdat2%,cached#
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,peakrec
  .|     mousek,intzeiger3,rsc_message,markhlp
  .| Aufruf in : record-1,
  LOCAL p,b$
  ' RECORD
  '
  @busy_mouse
  IF demo=FALSE THEN
    sab%=a
    sbb%=a+l-4
    scb%=sth
    sdb%=recfifolen/8-1
    seb%=adr+&H60
    sfb%=adr+&H200-1
    IF XBIOS(500)=&H71273800 THEN
      IF nr=peak& THEN
        a=XBIOS(117,L:sab%,L:sbb%,L:scb%,L:sdb%,L:seb%,L:sfb%)
      ELSE
        a=XBIOS(112,L:sab%,L:sbb%,L:scb%,L:sdb%,L:seb%,L:sfb%)
      ENDIF
      PAUSE 5
      IF autorec=FALSE THEN
        @fifodel
      ENDIF
      @write_int(2)
      t=TIMER
      peaktime=t
      b=4*INT((saa%-meml)/4)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      IF nr=peak& THEN
        hsec=INT(l/hz/4*100)
        @htimeset
        @textfeld(peakmax&,a$,1)
        @textfeld(recerror&,"0"+CHR$(0),1)
        @textfeld(recpeaks&,"0"+CHR$(0),1)
      ENDIF
      peakint=FALSE
      LPOKE a+16,0
      REPEAT
      UNTIL @mousek=0
      rfull=0
      peaks=0
      peaks2=0
      REPEAT
        peakret=a+12
        peakexit=a+8
        peakfull=a+16
        back%=LPEEK(a)
        rfull2=LPEEK(peakfull)
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF rfull2<>rfull THEN
              rfull=rfull2
              b$=STR$(rfull)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            b=4*INT((back%-meml)/4)
            @intzeiger2(b)
          ENDIF
          IF nr=peak& THEN
            @textfeld(peakpos&,a$,1)
            IF rfull2<>rfull THEN
              rfull=rfull2
              b$=STR$(rfull)+CHR$(0)
              @textfeld(recerror&,b$,1)
            ENDIF
            IF peaks2<>peaks THEN
              peaks=peaks2
              b$=STR$(peaks)+CHR$(0)
              @textfeld(recpeaks&,b$,1)
            ENDIF
            @peakrec
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
        back3%=LPEEK(peakexit)
      UNTIL back3%=1 OR k=3 OR k=2
      @write_int(0)
      IF nr=smpedit& THEN
        @intzeiger3
        @textfeld(smpsec&,sec$,1)
      ENDIF
      IF nr=peak& THEN
        a$=SPACE$(11)+CHR$(0)
        @textfeld(peakmax&,a$,1)
        @textfeld(peakpos&,a$,1)
        @setbutton(ed_obj,0)
        rsc_message(smpedit&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
        nr=smpedit&
        tree&=nr
        @markhlp
      ENDIF
    ELSE
      p=mdat%
      POKE p,7
      POKE p+1,4
      ~XBIOS(25,1,L:p)
      ~C:mdat2%(L:sab%,L:sbb%,L:scb%,L:sdb%,L:seb%,L:sfb%)
      PAUSE 20
      p=mdat%
      POKE p,7
      POKE p+1,0
      ~XBIOS(25,1,L:p)
    ENDIF
    cached=FALSE
  ENDIF
RETURN
'
> PROCEDURE maschruf3b
  .| Glob. Var.: demo#,scb%,sth#,sdb%,recfifolen#,seb%,adr#,sfb%,nr#,peak&,a#
  .|     sab%,sbb%,t#,b#,meml#,smpedit&,hsec#,l#,hz#,peakmax&,a$,peakint#
  .|     back%,back3%,hsec2#,smpsec&,peakpos&,peakret#,sec$,edit_obj&,idx&
  .|     tree&,p#,mdat%,mdat2%,cached#
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,peakrec
  .|     mousek,intzeiger3,rsc_message,markhlp
  .| Aufruf in : smpauto-1,
  ' RECORD
  '
  LOCAL b$
  @busy_mouse
  IF demo=FALSE THEN
    scb%=sth
    sdb%=recfifolen/8-1
    seb%=adr+&H60
    sfb%=adr+&H200-1
    IF XBIOS(500)=&H71273800 THEN
      IF nr=peak& THEN
        a=XBIOS(117,L:sab%,L:sbb%,L:scb%,L:sdb%,L:seb%,L:sfb%)
      ELSE
        a=XBIOS(112,L:sab%,L:sbb%,L:scb%,L:sdb%,L:seb%,L:sfb%)
      ENDIF
      PAUSE 5
      IF autorec=FALSE THEN
        @fifodel
      ENDIF
      @write_int(2)
      t=TIMER
      peaktime=t
      b=4*INT((sab%-meml)/4)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      IF nr=peak& THEN
        hsec=INT(l/hz/4*100)
        @htimeset
        @textfeld(peakmax&,a$,1)
        @textfeld(recerror&,"0"+CHR$(0),1)
        @textfeld(recpeaks&,"0"+CHR$(0),1)
      ENDIF
      peakint=FALSE
      REPEAT
      UNTIL @mousek=0
      rfull=0
      peaks=0
      peaks2=0
      REPEAT
        peakret=a+12
        peakexit=a+8
        peakfull=a+16
        back%=LPEEK(a)
        rfull2=LPEEK(peakfull)
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF rfull2<>rfull THEN
              rfull=rfull2
              b$=STR$(rfull)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            b=4*INT((back%-meml)/4)
            @intzeiger2(b)
          ENDIF
          IF nr=peak& THEN
            @textfeld(peakpos&,a$,1)
            IF rfull2<>rfull THEN
              rfull=rfull2
              b$=STR$(rfull)+CHR$(0)
              @textfeld(recerror&,b$,1)
            ENDIF
            IF peaks2<>peaks THEN
              peaks=peaks2
              b$=STR$(peaks)+CHR$(0)
              @textfeld(recpeaks&,b$,1)
            ENDIF
            peakret=a+12
            @peakrec
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
        back3%=LPEEK(peakexit)
      UNTIL back3%=1 OR k=3 OR k=2
      @write_int(0)
      IF nr=smpedit& THEN
        @intzeiger3
        @textfeld(smpsec&,sec$,1)
      ENDIF
      IF nr=peak& THEN
        a$=SPACE$(11)+CHR$(0)
        @textfeld(peakmax&,a$,1)
        @textfeld(peakpos&,a$,1)
        @setbutton(ed_obj,0)
        rsc_message(smpedit&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
        nr=smpedit&
        tree&=nr
        @markhlp
      ENDIF
    ELSE
      p=mdat%
      POKE p,7
      POKE p+1,4
      ~XBIOS(25,1,L:p)
      ~C:mdat2%(L:sab%,L:sbb%,L:scb%,L:sdb%,L:seb%,L:sfb%)
      PAUSE 20
      p=mdat%
      POKE p,7
      POKE p+1,0
      ~XBIOS(25,1,L:p)
    ENDIF
    cached=FALSE
  ENDIF
RETURN
'
> PROCEDURE maschinit4
  .| Glob. Var.: mdat3%
  .| Aufruf in : maschruf4-1,
  LOCAL a,g
  ' RECORD AUTO-WAIT
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 2E2F0040                       move.l    64(sp),d7 ; treshold
  ' 206F0044                       movea.l   68(sp),a0 ; statH im Bytemode
  ' 226F0048                       movea.l   72(sp),a1 ; REC-Read im Wordmode
  ' 1010                 anf1:     move.b    (a0),d0   ; Flag lesen
  ' 08000001                       btst      #1,d0     ; FIFO mehr als halbvoll ?
  ' 6716                           beq.s     anf2      ; wenn ja, daten einlesen
  ' 48E701C0                       movem.l   d7/a0/a1,-(sp)
  ' 3F3C000B                       move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 4CDF0380                       movem.l   (sp)+,d7/a0/a1
  ' 4A80                           tst.l     d0
  ' 666E                           bne.s     weg
  ' 60E2                           bra.s     anf1
  ' 7C08                 anf2:     moveq.l   #8,d6
  ' 7AFF                           moveq.l   #$ff,d5
  ' 7800                           moveq.l   #0,d4
  ' 0900                 anf3:     btst      d4,d0
  ' 67FC                           beq.s     anf3
  ' 3211                           move.w    (a1),d1   ; auf 1 warten
  ' 0D01                           btst      d6,d1
  ' 67F0                           beq.s     anf2
  ' 0900                 anf4:     btst      d4,d0
  ' 67FC                           beq.s     anf4
  ' 3211                           move.w    (a1),d1   ; wenn 0, weiter
  ' 0D01                           btst      d6,d1
  ' 66E6                           bne.s     anf2
  ' C245                           and.w     d5,d1
  ' ED61                           asl.w     d6,d1
  ' 0900                 anf5:     btst      d4,d0
  ' 67FC                           beq.s     anf5
  ' 3411                           move.w    (a1),d2   ; wenn 0, weiter
  ' 0D02                           btst      d6,d2
  ' 66D8                           bne.s     anf2
  ' C445                           and.w     d5,d2
  ' D242                           add.w     d2,d1
  ' 0900                 anf6:     btst      d4,d0
  ' 67FC                           beq.s     anf6
  ' 3411                           move.w    (a1),d2   ; wenn 1, weiter
  ' 0D02                           btst      d6,d2
  ' 67CA                           beq.s     anf2
  ' C445                           and.w     d5,d2
  ' ED62                           asl.w     d6,d2
  ' 0900                 anf7:     btst      d4,d0
  ' 67FC                           beq.s     anf7
  ' 3611                           move.w    (a1),d3   ; wenn 1, weiter
  ' 0D03                           btst      d6,d3
  ' 67BC                           beq.s     anf2
  ' C645                           and.w     d5,d3
  ' D443                           add.w     d3,d2
  ' 0801000F                       btst      #15,d1    ; Oberstes Bit da ?
  ' 6702                           beq.s     weiter1   ; dann negieren
  ' 4641                           not.w     d1
  ' 0802000F             weiter1:  btst      #15,d2
  ' 6702                           beq.s     weiter2
  ' 4642                           not.w     d2
  ' B247                 weiter2:  cmp.w     d7,d1     ; treshold vergleichen
  ' 6E10                           bgt.s     weg
  ' B447                           cmp.w     d7,d2
  ' 6E0C                           bgt.s     weg
  ' 1010                           move.b    (a0),d0   ; Flag lesen
  ' 08000001                       btst      #1,d0     ; FIFO mehr als halbvoll ?
  ' 67A8                           beq.s     anf4      ; wenn ja, daten einlesen
  ' 6000FF78                       bra       anf1
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfdmasch:
  DATA &H48E7,&HFFFE
  DATA &H2E2F,&H0040
  DATA &H206F,&H0044
  DATA &H226F,&H0048
  DATA &H1010
  DATA &H0800,&H0001
  DATA &H6716
  DATA &H48E7,&H01C0
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H4CDF,&H0380
  DATA &H4A80
  DATA &H666E
  DATA &H60E2
  DATA &H7C08
  DATA &H7AFF
  DATA &H7800
  DATA &H0900
  DATA &H67FC
  DATA &H3211
  DATA &H0D01
  DATA &H67F0
  DATA &H0900
  DATA &H67FC
  DATA &H3211
  DATA &H0D01
  DATA &H66E6
  DATA &HC245
  DATA &HED61
  DATA &H0900
  DATA &H67FC
  DATA &H3411
  DATA &H0D02
  DATA &H66D8
  DATA &HC445
  DATA &HD242
  DATA &H0900
  DATA &H67FC
  DATA &H3411
  DATA &H0D02
  DATA &H67CA
  DATA &HC445
  DATA &HED62
  DATA &H0900
  DATA &H67FC
  DATA &H3611
  DATA &H0D03
  DATA &H67BC
  DATA &HC645
  DATA &HD443
  DATA &H0801,&H000F
  DATA &H6702
  DATA &H4641
  DATA &H0802,&H000F
  DATA &H6702
  DATA &H4642
  DATA &HB247
  DATA &H6E10
  DATA &HB447
  DATA &H6E0C
  DATA &H1010
  DATA &H0800,&H0001
  DATA &H67A8
  DATA &H6000,&HFF78
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfdmasch
  FOR g=0 TO 158 STEP 2
    READ a
    DPOKE mdat3%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf4
  .| Glob. Var.: demo#,tr%,th#,sac%,adr#,sbc%,a#,mdat3%,cached#
  .| Ruft auf  : maschinit4,fifodel
  .| Aufruf in : smpauto-1,
  ' RECORD AUTO-WAIT
  '
  IF demo=FALSE THEN
    tr%=th
    sac%=adr+&H60
    sbc%=adr+&H200-1
    @maschinit4
    @fifodel
    IF XBIOS(500)=&H71273800 THEN
      a=XBIOS(104,L:tr%,L:sac%,L:sbc%)
    ELSE
      ~C:mdat3%(L:tr%,L:sac%,L:sbc%)
    ENDIF
    cached=FALSE
  ENDIF
RETURN
'
> PROCEDURE maschruf4b
  .| Glob. Var.: peakint#,wymax#,pr#,th#,pl#
  .| Ruft auf  : peakwert,mousek
  .| Aufruf in : smpauto-1,
  LOCAL k
  peakint=FALSE
  wymax=32767
  REPEAT
    @peakwert
    k=@mousek
    ~FRE(0)
  UNTIL pr>=th OR pl>=th OR k>1
  @write_int(0)
  wymax=187
  peakint=FALSE
RETURN
'
> PROCEDURE maschinit5
  .| Glob. Var.: mdat2%
  .| Aufruf in : newfsel-2,trakforw-1,trkbackw-1,virtual-1,mforw-1,mbackw-1,
  LOCAL a,g
  ' HARDDISK-PLAY
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3 ; adr
  ' 2A6F0044                       movea.l   68(sp),a5 ; len
  ' 2E2F0048                       move.l    72(sp),d7 ; handle
  ' 2C6F004C                       movea.l   76(sp),a6 ; seekbyte
  ' 242F0050                       move.l    80(sp),d2 ; sectors
  ' 2A2F0054                       move.l    84(sp),d5 ; Anzahl der For/Backstep
  ' 262F0058                       move.l    88(sp),d3 ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzl
  '                                                            iche brkabfrage)
  ' 282F005C                       move.l    92(sp),d4 ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
  ' 202F0060                       move.l    96(sp),d0 ; midi
  ' 206F0064                       movea.l   100(sp),a0          ; StatH im Bytemode
  ' 226F0068                       movea.l   104(sp),a1          ; Playread im Wordmode
  ' 286F006C                       movea.l   108(sp),a4          ; Returnwert (momentanes Playbyte & Anzahl der loops)
  ' 45FA0278                       lea.l     midisuch(pc),a2
  ' 3480                           move.w    d0,(a2)
  ' 45FA0274                       lea.l     midiw(pc),a2
  ' 24BC00000000                   move.l    #0,(a2)
  ' 4A85                           tst.l     d5
  ' 6B06                           bmi.s     backset
  ' 220B                           move.l    a3,d1     ; MEMende
  ' D28D                           add.l     a5,d1
  ' 6008                           bra.s     anf0
  ' 220B                 backset:  move.l    a3,d1
  ' 5981                           subq.l    #4,d1
  ' D7CD                           adda.l    a5,a3
  ' 598B                           subq.l    #4,a3
  ' 297C000000000008     anf0:     move.l    #0,8(a4)  ; Anzahl loops lîschen
  ' 297C000000000004               move.l    #0,4(a4)  ; Anzahl sektoren lîschen
  ' 28BC00000000                   move.l    #0,(a4)   ; playbyte lîschen
  ' 48E77FFE             anf:      movem.l   d1-d7/a0-a6,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)  ; Fseek
  ' 3F07                           move.w    d7,-(sp)
  ' 2F0E                           move.l    a6,-(sp)
  ' 3F3C0042                       move.w    #66,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000A                       lea.l     $a(sp),sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 61000044                       bsr       play
  ' 4A40                           tst.w     d0
  ' 6632                           bne.s     weg
  ' 08030001             crosstst: btst      #1,d3
  ' 6724                           beq.s     looptst
  ' 5085                           addq.l    #8,d5
  ' 4485                           neg.l     d5
  ' 2001                           move.l    d1,d0
  ' 5980                           subq.l    #4,d0
  ' 220B                           move.l    a3,d1
  ' 5881                           addq.l    #4,d1
  ' 2640                           movea.l   d0,a3
  ' 61000028                       bsr       play
  ' 4A40                           tst.w     d0
  ' 6616                           bne.s     weg
  ' 4485                           neg.l     d5
  ' 5185                           subq.l    #8,d5
  ' 2001                           move.l    d1,d0
  ' 5980                           subq.l    #4,d0
  ' 220B                           move.l    a3,d1
  ' 5881                           addq.l    #4,d1
  ' 2640                           movea.l   d0,a3
  ' 08030000             looptst:  btst      #0,d3
  ' 6702                           beq.s     weg
  ' 60AC                           bra.s     anf
  ' 288A                 weg:      move.l    a2,(a4)   ; Returnwert Playbyte speichern
  ' 29460004                       move.l    d6,4(a4)  ; Returnwert Anzahl sectors speichern
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 7C00                 play:     moveq.l   #0,d6
  ' 5286                 play2:    addq.l    #1,d6
  ' 244B                           movea.l   a3,a2
  ' 48E77FFE                       movem.l   d1-d7/a0-a6,-(sp)
  ' 4A85                           tst.l     d5
  ' 6B02                           bmi.s     fseek
  ' 6018                           bra.s     fread
  ' 3F3C0001             fseek:    move.w    #1,-(sp)  ; Fseek
  ' 3F07                           move.w    d7,-(sp)
  ' 200D                           move.l    a5,d0
  ' D080                           add.l     d0,d0
  ' 4480                           neg.l     d0
  ' 2F00                           move.l    d0,-(sp)
  ' 3F3C0042                       move.w    #66,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000A                       lea.l     $a(sp),sp
  ' 200B                 fread:    move.l    a3,d0
  ' 4A85                           tst.l     d5
  ' 6A04                           bpl.s     readpos
  ' 2001                           move.l    d1,d0
  ' 5880                           addq.l    #4,d0
  ' 2F00                 readpos:  move.l    d0,-(sp)  ; Fread
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 1010                 fill:     move.b    (a0),d0   ; FIFO halbleer ?
  ' 08000003                       btst      #3,d0
  ' 666A                           bne.s     copyanf
  ' 08030003                       btst      #3,d3     ; mehr Abbruchabfragen ?
  ' 6710                           beq.s     tstrest
  ' 08030002                       btst      #2,d3
  ' 670A                           beq.s     tstrest
  ' 610000D6                       bsr       midi
  ' 4A40                           tst.w     d0
  ' 660000CE                       bne       playex
  ' 4A85                 tstrest:  tst.l     d5
  ' 6B06                           bmi.s     tstmin
  ' 2001                           move.l    d1,d0
  ' 908A                           sub.l     a2,d0
  ' 6004                           bra.s     tstrest2
  ' 200A                 tstmin:   move.l    a2,d0
  ' 9081                           sub.l     d1,d0
  ' E480                 tstrest2: asr.l     #2,d0
  ' B044                           cmp.w     d4,d0
  ' 6ECE                           bgt.s     fill
  ' 3F07                 restplay: move.w    d7,-(sp)
  ' 3F04                           move.w    d4,-(sp)
  ' 7E08                           moveq.l   #8,d7
  ' 7804                           moveq.l   #4,d4
  ' 1010                 rest2:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     rest2
  ' 101A                           move.b    (a2)+,d0
  ' 0F80                           bclr      d7,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 rest3:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     rest3
  ' 101A                           move.b    (a2)+,d0
  ' 0F80                           bclr      d7,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 1010                 rest4:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     rest4
  ' 101A                           move.b    (a2)+,d0
  ' 0FC0                           bset      d7,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 rest5:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     rest5
  ' 101A                           move.b    (a2)+,d0
  ' 0FC0                           bset      d7,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' D5C5                           adda.l    d5,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 674C                           beq.s     bufend
  ' 60C8                           bra.s     rest2
  ' 3004                 copyanf:  move.w    d4,d0     ; ...dann FIFO halb-fuellen (fifolen)!
  ' 3F07                           move.w    d7,-(sp)
  ' 3F04                           move.w    d4,-(sp)
  ' 7808                           moveq.l   #8,d4
  ' 1E1A                 copy:     move.b    (a2)+,d7
  ' 0987                           bclr      d4,d7     ; Rechter Kanal (Bit 8 geloescht)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 0987                           bclr      d4,d7     ; Rechter Kanal (Bit 8 geloescht)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 09C7                           bset      d4,d7     ; Linker Kanal (Bit 8 gesetzt)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 09C7                           bset      d4,d7     ; Linker Kanal (Bit 8 gesetzt)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' D5C5                 faster:   adda.l    d5,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 6724                           beq.s     bufend
  ' 51C8FFE0                       dbra      d0,copy
  ' 381F                           move.w    (sp)+,d4
  ' 3E1F                           move.w    (sp)+,d7
  ' 610000E4                       bsr       brktst
  ' 4A40                           tst.w     d0
  ' 6642                           bne.s     playex
  ' 08030002                       btst      #2,d3
  ' 6700FF52                       beq       fill
  ' 6100003A                       bsr       midi
  ' 4A40                           tst.w     d0
  ' 6632                           bne.s     playex
  ' 6000FF46                       bra       fill
  ' 381F                 bufend:   move.w    (sp)+,d4
  ' 3E1F                           move.w    (sp)+,d7
  ' BC82                           cmp.l     d2,d6
  ' 671C                           beq.s     playend
  ' 610000C0                       bsr       brktst
  ' 4A40                           tst.w     d0
  ' 661E                           bne.s     playex
  ' 08030002                       btst      #2,d3
  ' 6700FEEA                       beq       play2
  ' 61000016                       bsr       midi
  ' 4A40                           tst.w     d0
  ' 660E                           bne.s     playex
  ' 6000FEDE                       bra       play2
  ' 7000                 playend:  moveq.l   #0,d0
  ' 06AC000000010008               addi.l    #1,8(a4)
  ' 4E75                 playex:   rts
  ' 48E77FFE             midi:     movem.l   d1-d7/a0-a6,-(sp)
  ' 41FA00AA                       lea.l     midisuch(pc),a0
  ' 3410                           move.w    (a0),d2
  ' 3F02                           move.w    d2,-(sp)
  ' 3F3C0003                       move.w    #3,-(sp)  ; MIDI
  ' 3F3C0001                       move.w    #1,-(sp)  ; Bconstat
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 0C400000                       cmpi.w    #0,d0
  ' 6768                           beq.s     nomidi
  ' 3F3C0003                       move.w    #3,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)  ; Bconin
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 341F                           move.w    (sp)+,d2
  ' 3F02                           move.w    d2,-(sp)
  ' 41FA0082                       lea.l     midiw(pc),a0
  ' 08000007                       btst      #7,d0
  ' 6708                           beq.s     midi2     ; Daten oder Befehl ?
  ' E042                           asr.w     #8,d2     ; Channel im oberen Byte des Wortes
  ' 9002                           sub.b     d2,d0     ; Channel vom Befehl abziehen
  ' 1080                           move.b    d0,(a0)   ; Befehl schreiben
  ' 6046                           bra.s     nomidi
  ' B002                 midi2:    cmp.b     d2,d0     ; Noten-DATA ?
  ' 671E                           beq.s     midi4
  ' B4280001                       cmp.b     1(a0),d2  ; Noten-data schon gewesen und korrekt ?
  ' 663C                           bne.s     nomidi
  ' 11400002             midi3:    move.b    d0,2(a0)  ; Velocitywert schreiben
  ' 0C100080                       cmpi.b    #$80,(a0) ; NOTE OFF ?
  ' 671A                           beq.s     midi5
  ' 0C100090                       cmpi.b    #$90,(a0) ; NOTE ON ?
  ' 671C                           beq.s     midi6
  ' 20BC00000000         midi3b:   move.l    #0,(a0)   ; Datenwort lîschen
  ' 6024                           bra.s     nomidi
  ' B4280001             midi4:    cmp.b     1(a0),d2  ; Noten-DATA schon gewesen ?
  ' 67E2                           beq.s     midi3     ; dann ist es nicht Note sondern Velocity
  ' 11400001                       move.b    d0,1(a0)  ; Notenwert schreiben
  ' 6018                           bra.s     nomidi
  ' B4280001             midi5:    cmp.b     1(a0),d2  ; NOTE OFF und Note OK ?
  ' 66E6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 601A                           bra.s     midiex    ; Abbruch, da NOTE OFF !
  ' B4280001             midi6:    cmp.b     1(a0),d2  ; NOTE ON und Note OK ?
  ' 66DE                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 0C2800000002                   cmpi.b    #0,2(a0)  ; Velocity ist Null ?
  ' 66D6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 600A                           bra.s     midiex    ; Abbruch, da NOTE ON und Velo=Null !
  ' 341F                 nomidi:   move.w    (sp)+,d2
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 7000                           moveq.l   #0,d0
  ' 4E75                           rts
  ' 341F                 midiex:   move.w    (sp)+,d2
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 7001                           moveq.l   #1,d0
  ' 4E75                           rts
  ' 48E77FFE             brktst:   movem.l   d1-d7/a0-a6,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 4E75                           rts
  ' 0000                 midisuch: DC.w 0
  ' 00000000             midiw:    DC.l 0
anfgmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2A6F,&H0044
  DATA &H2E2F,&H0048
  DATA &H2C6F,&H004C
  DATA &H242F,&H0050
  DATA &H2A2F,&H0054
  DATA &H262F,&H0058
  DATA &H282F,&H005C
  DATA &H202F,&H0060
  DATA &H206F,&H0064
  DATA &H226F,&H0068
  DATA &H286F,&H006C
  DATA &H45FA,&H0278
  DATA &H3480
  DATA &H45FA,&H0274
  DATA &H24BC,&H0000,&H0000
  DATA &H4A85
  DATA &H6B06
  DATA &H220B
  DATA &HD28D
  DATA &H6008
  DATA &H220B
  DATA &H5981
  DATA &HD7CD
  DATA &H598B
  DATA &H297C,&H0000,&H0000,&H0008
  DATA &H297C,&H0000,&H0000,&H0004
  DATA &H28BC,&H0000,&H0000
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0000
  DATA &H3F07
  DATA &H2F0E
  DATA &H3F3C,&H0042
  DATA &H4E41
  DATA &H4FEF,&H000A
  DATA &H4CDF,&H7FFE
  DATA &H6100,&H0044
  DATA &H4A40
  DATA &H6632
  DATA &H0803,&H0001
  DATA &H6724
  DATA &H5085
  DATA &H4485
  DATA &H2001
  DATA &H5980
  DATA &H220B
  DATA &H5881
  DATA &H2640
  DATA &H6100,&H0028
  DATA &H4A40
  DATA &H6616
  DATA &H4485
  DATA &H5185
  DATA &H2001
  DATA &H5980
  DATA &H220B
  DATA &H5881
  DATA &H2640
  DATA &H0803,&H0000
  DATA &H6702
  DATA &H60AC
  DATA &H288A
  DATA &H2946,&H0004
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H7C00
  DATA &H5286
  DATA &H244B
  DATA &H48E7,&H7FFE
  DATA &H4A85
  DATA &H6B02
  DATA &H6018
  DATA &H3F3C,&H0001
  DATA &H3F07
  DATA &H200D
  DATA &HD080
  DATA &H4480
  DATA &H2F00
  DATA &H3F3C,&H0042
  DATA &H4E41
  DATA &H4FEF,&H000A
  DATA &H200B
  DATA &H4A85
  DATA &H6A04
  DATA &H2001
  DATA &H5880
  DATA &H2F00
  DATA &H2F0D
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H7FFE
  DATA &H1010
  DATA &H0800,&H0003
  DATA &H666A
  DATA &H0803,&H0003
  DATA &H6710
  DATA &H0803,&H0002
  DATA &H670A
  DATA &H6100,&H00D6
  DATA &H4A40
  DATA &H6600,&H00CE
  DATA &H4A85
  DATA &H6B06
  DATA &H2001
  DATA &H908A
  DATA &H6004
  DATA &H200A
  DATA &H9081
  DATA &HE480
  DATA &HB044
  DATA &H6ECE
  DATA &H3F07
  DATA &H3F04
  DATA &H7E08
  DATA &H7804
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0F80
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0F80
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0FC0
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0FC0
  DATA &H3280
  DATA &HD5C5
  DATA &HB5C1
  DATA &H674C
  DATA &H60C8
  DATA &H3004
  DATA &H3F07
  DATA &H3F04
  DATA &H7808
  DATA &H1E1A
  DATA &H0987
  DATA &H3287
  DATA &H1E1A
  DATA &H0987
  DATA &H3287
  DATA &H1E1A
  DATA &H09C7
  DATA &H3287
  DATA &H1E1A
  DATA &H09C7
  DATA &H3287
  DATA &HD5C5
  DATA &HB5C1
  DATA &H6724
  DATA &H51C8,&HFFE0
  DATA &H381F
  DATA &H3E1F
  DATA &H6100,&H00E4
  DATA &H4A40
  DATA &H6642
  DATA &H0803,&H0002
  DATA &H6700,&HFF52
  DATA &H6100,&H003A
  DATA &H4A40
  DATA &H6632
  DATA &H6000,&HFF46
  DATA &H381F
  DATA &H3E1F
  DATA &HBC82
  DATA &H671C
  DATA &H6100,&H00C0
  DATA &H4A40
  DATA &H661E
  DATA &H0803,&H0002
  DATA &H6700,&HFEEA
  DATA &H6100,&H0016
  DATA &H4A40
  DATA &H660E
  DATA &H6000,&HFEDE
  DATA &H7000
  DATA &H06AC,&H0000,&H0001,&H0008
  DATA &H4E75
  DATA &H48E7,&H7FFE
  DATA &H41FA,&H00AA
  DATA &H3410
  DATA &H3F02
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H0C40,&H0000
  DATA &H6768
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0002
  DATA &H4E4D
  DATA &H588F
  DATA &H341F
  DATA &H3F02
  DATA &H41FA,&H0082
  DATA &H0800,&H0007
  DATA &H6708
  DATA &HE042
  DATA &H9002
  DATA &H1080
  DATA &H6046
  DATA &HB002
  DATA &H671E
  DATA &HB428,&H0001
  DATA &H663C
  DATA &H1140,&H0002
  DATA &H0C10,&H0080
  DATA &H671A
  DATA &H0C10,&H0090
  DATA &H671C
  DATA &H20BC,&H0000,&H0000
  DATA &H6024
  DATA &HB428,&H0001
  DATA &H67E2
  DATA &H1140,&H0001
  DATA &H6018
  DATA &HB428,&H0001
  DATA &H66E6
  DATA &H601A
  DATA &HB428,&H0001
  DATA &H66DE
  DATA &H0C28,&H0000,&H0002
  DATA &H66D6
  DATA &H600A
  DATA &H341F
  DATA &H4CDF,&H7FFE
  DATA &H7000
  DATA &H4E75
  DATA &H341F
  DATA &H4CDF,&H7FFE
  DATA &H7001
  DATA &H4E75
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0002
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H7FFE
  DATA &H4E75
  DATA &H0000
  DATA &H0000,&H0000
  '
  RESTORE anfgmasch
  FOR g=0 TO 690 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf5
  .| Glob. Var.: demo#,mdat%,fastrec#,sad%,over#,flen#,sbd%,playfifolen#,scd%
  .|     handle#,sdd%,playpos#,sectors#,sed%,sfd%,sgd%,l#,shd%,sid%,midiwort#
  .|     sjd%,adr#,skd%,sld%,wback%,a#,t#,fxlen#,b2#,nr#,smpedit&,virtual#
  .|     sret#,sloop#,back%,back2%,back3%,hsec2#,hsec#,smpsec&,a$,b#,sec$
  .|     mdat2%
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,mousek
  .|     intzeiger3
  .| Aufruf in : newfsel-2,trakforw-2,trkbackw-2,virtual-1,mforw-2,mbackw-2,
  LOCAL p,b$
  ' HARDDISK-PLAY
  '
  @busy_mouse
  IF demo=FALSE THEN
    p=mdat%
    IF XBIOS(500)<>&H71273800 OR oldplay=TRUE THEN
      IF fastrec=FALSE THEN
        POKE p,&H12
        ~XBIOS(25,0,L:p)
      ELSE
        POKE p,7
        POKE p+1,4
        ~XBIOS(25,1,L:p)
      ENDIF
    ENDIF
    sad%=mdat%
    IF over<0 THEN
      sad%=mdat%+flen-4
    ENDIF
    sbd%=flen               !len
    scd%=handle
    sdd%=playpos            !playposition
    IF sectors<=1 THEN
      sectors=2
    ENDIF
    sed%=sectors            !sectors
    sfd%=over
    '
    sgd%=l+8
    '
    shd%=playfifolen/8-1
    sid%=midiwort
    sjd%=adr+&H40
    skd%=adr+&H200
    sld%=wback%
    IF XBIOS(500)=&H71273800 AND oldplay=FALSE THEN
      a=XBIOS(113,L:sad%,L:sbd%,L:scd%,L:sdd%,L:sed%,L:sfd%,L:sgd%,L:shd%,L:sid%,L:sjd%,L:skd%)
      PAUSE 5
      @write_int(1)
      intplay=TRUE
      t=TIMER
      fxlen=flen/2
      b2=4*INT(playpos/4)
      IF nr=smpedit& AND virtual=TRUE AND sret=0 AND sloop=0 THEN
        @intzeiger1(b2)
      ENDIF
      IF nr=smpedit& THEN
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      LPOKE a+16,0
      REPEAT
      UNTIL @mousek=0
      wleer=0
      REPEAT
        back%=LPEEK(a+4)      ! Patch
        back2%=LPEEK(a+8)
        back3%=LPEEK(a+12)
        wleer2=LPEEK(a+16)
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          @busy_mouse
          IF nr=arranger& THEN
            bc=back%/2
            hsec=INT((sectpos+bc)*flen/vhz/4*100)
            @htimeset
            @textfeld(playlen&,a$,1)
          ENDIF
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF wleer2<>wleer THEN
              wleer=wleer2
              b$=STR$(wleer)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            IF virtual=TRUE AND sret=0 AND sloop=0 THEN
              b=b2+4*INT((back%*fxlen)/4)
              @intzeiger2(b)
            ENDIF
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
      UNTIL back3%=1 OR k=3 OR k=2 OR nr=arranger&
      IF nr<>arranger& THEN
        @write_int(0)
      ENDIF
      IF nr=smpedit& THEN
        IF virtual=TRUE AND sret=0 AND sloop=0 THEN
          @intzeiger3
        ENDIF
        @textfeld(smpsec&,sec$,1)
      ENDIF
    ELSE
      ~C:mdat2%(L:sad%,L:sbd%,L:scd%,L:sdd%,L:sed%,L:sfd%,L:sgd%,L:shd%,L:sid%,L:sjd%,L:skd%,L:sld%)
    ENDIF
    p=mdat%
    IF XBIOS(500)<>&H71273800 OR oldplay=TRUE THEN
      IF fastrec=FALSE THEN
        POKE p,8
        ~XBIOS(25,0,L:p)
      ELSE
        PAUSE 20
        POKE p,7
        POKE p+1,0
        ~XBIOS(25,1,L:p)
      ENDIF
    ENDIF
  ENDIF
  IF XBIOS(500)=&H71273800 AND oldplay=FALSE THEN
    back%=LPEEK(a+4)
  ELSE
    back%=LPEEK(wback%+4)
  ENDIF
RETURN
'
> PROCEDURE maschinit5b
  .| Glob. Var.: mdat3%,demo#,sad%,mdat%,sbd%,flen#,playfifolen#,shd%,sjd%
  .|     adr#,skd%,sld%,wback%,fastrec#
  .| Ruft auf  : busy_mouse,digout
  .| Aufruf in : maschruf18b-1,trkplay-1,arrplay-1,smpplay-1,
  LOCAL g,a,p
  RESTORE anfgmasch
  FOR g=0 TO 690 STEP 2
    READ a
    DPOKE mdat3%+g,a
  NEXT g
  @busy_mouse
  IF demo=FALSE THEN
    @digout(TRUE)
    sad%=mdat%
    sbd%=flen               !len
    shd%=playfifolen/8-1
    sjd%=adr+&H40
    skd%=adr+&H200
    sld%=wback%
  ENDIF
  IF fastrec=TRUE AND XBIOS(500)<>&H71273800 THEN
    p=mdat%
    POKE p,7
    POKE p+1,4
    ~XBIOS(25,1,L:p)
  ENDIF
RETURN
'
> PROCEDURE maschruf5c
  .| Glob. Var.: demo#,fastrec#,mdat%,over#,sad%,flen#,scd%,handle#,sdd%
  .|     playpos#,sectors#,sed%,sfd%,sgd%,l#,sid%,midiwort#,a#,sbd%,shd%,sjd%
  .|     skd%,t#,fxlen#,b2#,nr#,smpedit&,virtual#,sret#,sloop#,back%,back2%
  .|     back3%,hsec2#,hsec#,smpsec&,a$,b#,sec$,mdat3%,sld%,wback%
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,mousek
  .|     intzeiger3
  .| Aufruf in : maschruf18b-2,trkplay-2,arrplay-2,smpplay-4,
  LOCAL p,b$
  ' HARDDISK-PLAY
  '
  @busy_mouse
  IF demo=FALSE THEN
    IF fastrec=FALSE AND XBIOS(500)<>&H71273800 THEN
      p=mdat%
      POKE p,&H12
      ~XBIOS(25,0,L:p)
    ENDIF
    IF over<0 THEN
      sad%=mdat%+flen-4
    ENDIF
    scd%=handle
    sdd%=playpos            !playposition
    IF sectors<=1 THEN
      sectors=2
    ENDIF
    sed%=sectors            !sectors
    sfd%=over
    '
    sgd%=l+8
    '
    sid%=midiwort
    IF XBIOS(500)=&H71273800 THEN
      a=XBIOS(113,L:sad%,L:sbd%,L:scd%,L:sdd%,L:sed%,L:sfd%,L:sgd%,L:shd%,L:sid%,L:sjd%,L:skd%)
      PAUSE 5
      @write_int(1)
      intplay=TRUE
      t=TIMER
      fxlen=flen/2
      b2=4*INT(playpos/4)
      IF nr=smpedit& AND virtual=TRUE AND sret=0 AND sloop=0 THEN
        @intzeiger1(b2)
      ENDIF
      IF nr=smpedit& THEN
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      LPOKE a+16,0
      REPEAT
      UNTIL @mousek=0
      wleer=0
      REPEAT
        back%=LPEEK(a+4)
        back2%=LPEEK(a+8)
        back3%=LPEEK(a+12)
        wleer2=LPEEK(a+16)
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          @busy_mouse
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF wleer2<>wleer THEN
              wleer=wleer2
              b$=STR$(wleer)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            IF virtual=TRUE AND sret=0 AND sloop=0 THEN
              b=b2+4*INT((back%*fxlen)/4)
              @intzeiger2(b)
            ENDIF
          ENDIF
          IF nr=trakker& THEN
            @edhandler5
          ENDIF
          IF nr=arranger& THEN
            @edhandler4
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
      UNTIL back3%=1 OR k=3 OR k=2
      intplay=FALSE
      @write_int(0)
      IF nr=smpedit& THEN
        IF virtual=TRUE AND sret=0 AND sloop=0 THEN
          @intzeiger3
        ENDIF
        @textfeld(smpsec&,sec$,1)
      ENDIF
    ELSE
      ~C:mdat3%(L:sad%,L:sbd%,L:scd%,L:sdd%,L:sed%,L:sfd%,L:sgd%,L:shd%,L:sid%,L:sjd%,L:skd%,L:sld%)
      back%=LPEEK(wback%+4)
    ENDIF
    IF fastrec=FALSE AND XBIOS(500)<>&H71273800 THEN
      p=mdat%
      POKE p,8
      ~XBIOS(25,0,L:p)
    ENDIF
  ELSE
    back%=0
  ENDIF
RETURN
'
> PROCEDURE maschinit5d
  .| Glob. Var.: fastrec#,mdat%
  .| Aufruf in : smpplay-1,
  LOCAL p
  ' HARDPLAY - nachher
  IF fastrec=TRUE AND XBIOS(500)<>&H71273800 THEN
    PAUSE 20
    p=mdat%
    POKE p,7
    POKE p+1,0
    ~XBIOS(25,1,L:p)
  ENDIF
RETURN
'
> PROCEDURE maschinit6
  .| Glob. Var.: mdat2%
  .| Aufruf in : monitor-1,
  LOCAL a,g
  ' MONITOR
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 286F0040                       movea.l   64(sp),a4 ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
  ' 206F0044                       movea.l   68(sp),a0 ; StatH im Bytemode
  ' 226F0048                       movea.l   72(sp),a1 ; Playread im Wordmode
  ' 7408                           moveq.l   #8,d2
  ' 1010                 fifowait: move.b    (a0),d0   ; PLAY-FIFO halbleer ?
  ' C002                           and.b     d2,d0
  ' 660A                           bne.s     copy      ; wenn ja, halben RECFIFO in PLAYFIFO kopieren
  ' 6100003E                       bsr       brktst    ; dann abbruch testen
  ' 4A40                           tst.w     d0
  ' 6632                           bne.s     weg
  ' 60F0                           bra.s     fifowait
  ' 300C                 copy:     move.w    a4,d0     ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
  ' 3E11                 copy2:    move.w    (a1),d7   ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0507                           btst      d2,d7
  ' 661A                           bne.s     copy3     ; fehlerhafte Daten ?
  ' 3C11                           move.w    (a1),d6   ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0506                           btst      d2,d6
  ' 6614                           bne.s     copy3     ; fehlerhafte Daten ?
  ' 3A11                           move.w    (a1),d5   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0505                           btst      d2,d5
  ' 670E                           beq.s     copy3     ; fehlerhafte Daten ?
  ' 3811                           move.w    (a1),d4   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0504                           btst      d2,d4
  ' 6708                           beq.s     copy3     ; fehlerhafte Daten ?
  ' 3287                           move.w    d7,(a1)
  ' 3286                           move.w    d6,(a1)
  ' 3285                           move.w    d5,(a1)
  ' 3284                           move.w    d4,(a1)
  ' 51C8FFDE             copy3:    dbra      d0,copy2
  ' 6100000E                       bsr       brktst    ; abbruch testen
  ' 4A40                           tst.w     d0
  ' 6602                           bne.s     weg
  ' 60C0                           bra.s     fifowait
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 48E77FF8             brktst:   movem.l   d1-d7/a0-a4,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 4E75                           rts
anffmasch:
  DATA &H48E7,&HFFFE
  DATA &H286F,&H0040
  DATA &H206F,&H0044
  DATA &H226F,&H0048
  DATA &H7408
  DATA &H1010
  DATA &HC002
  DATA &H660A
  DATA &H6100,&H003E
  DATA &H4A40
  DATA &H6632
  DATA &H60F0
  DATA &H300C
  DATA &H3E11
  DATA &H0507
  DATA &H661A
  DATA &H3C11
  DATA &H0506
  DATA &H6614
  DATA &H3A11
  DATA &H0505
  DATA &H670E
  DATA &H3811
  DATA &H0504
  DATA &H6708
  DATA &H3287
  DATA &H3286
  DATA &H3285
  DATA &H3284
  DATA &H51C8,&HFFDE
  DATA &H6100,&H000E
  DATA &H4A40
  DATA &H6602
  DATA &H60C0
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H48E7,&H7FF8
  DATA &H3F3C,&H0002
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H1FFE
  DATA &H4E75
  '
  RESTORE anffmasch
  FOR g=0 TO 108 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf6
  .| Glob. Var.: demo#,sad%,playfifolen#,sbd%,adr#,scd%,a#,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : monitor-1,
  ' MONITOR
  '
  @busy_mouse
  IF demo=FALSE THEN
    sad%=playfifolen/8-1
    sbd%=adr+&H40
    scd%=adr+&H200-1
    @write_int(0)
    IF XBIOS(500)=&H71273800 THEN
      a=XBIOS(106,L:sad%,L:sbd%,L:scd%)
    ELSE
      ~C:mdat2%(L:sad%,L:sbd%,L:scd%)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE maschruf7
  .| Glob. Var.: demo#,saa%,a#,sba%,b#,sca%,adder#,sda%,l#,sea%,playfifolen#
  .|     sfa%,midiwort#,sga%,adr#,sha%,wback%,sia%,mdat%,t#,meml#,nr#,smpedit&
  .|     back%,back2%,back3%,hsec2#,hsec#,smpsec&,a$,sec$,mdat2%
  .| Ruft auf  : busy_mouse,digout,intzeiger1,htimeset,textfeld,intzeiger2
  .|     mousek,intzeiger3
  .| Aufruf in : smpplay-2,smppmhlp-2,
  LOCAL b$
  @busy_mouse
  ' RECPLAY
  '
  IF demo=FALSE THEN
    @digout(TRUE)
    saa%=a
    saap%=a+16384
    sba%=a+l-4
    sca%=sth
    sda%=0
    sea%=recfifolen/8-1
    sga%=adr+&H40
    sha%=adr+&H200-1
    sia%=adr+&H180-1
    LPOKE a,0                  ! Returnwert play lîschen
    LPOKE a+4,0                ! Returnwert rec lîschen
    IF XBIOS(500)=&H71273800 THEN
      a=XBIOS(114,L:saap%,L:sba%,L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:sga%,L:sha%,L:sia%)
      PAUSE 5
      @write_int(3)
      t=TIMER
      b=4*INT((saa%-meml)/4)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      LPOKE a+16,0               ! Fehler play lîschen
      LPOKE a+20,0               ! Fehler rec lîschen
      REPEAT
      UNTIL @mousek=0
      wleer=0
      REPEAT
        back%=LPEEK(a)           ! Returnwert play
        back2%=LPEEK(a+4)        ! Returnwert rec
        back3%=LPEEK(a+8)        ! Break play
        back4%=LPEEK(a+12)       ! Break rec
        wleer2=LPEEK(a+16)       ! Fehler play
        wleer3=LPEEK(a+20)       ! Fehler rec
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF wleer3<>wleer THEN
              wleer=wleer3
              b$=STR$(wleer)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            b=4*INT((back%-meml)/4)
            @intzeiger2(b)
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
      UNTIL back4%=1 OR k=3 OR k=2
      @write_int(0)
      cached=FALSE
      IF nr=smpedit& THEN
        @intzeiger3
        @textfeld(smpsec&,sec$,1)
      ENDIF
    ENDIF
  ELSE
    back%=0
    back2%=0
  ENDIF
RETURN
'
> PROCEDURE maschinit8
  .| Glob. Var.: mdat2%,fifofill#,recfifolen#
  .| Aufruf in : record4-1,
  LOCAL a,g
  ' HARDDISK-RECORD
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; adr
  ' 2C6F0044                       movea.l   68(sp),a6  ; fname
  ' 2A2F0048                       move.l    72(sp),d5 ; sectors
  ' 282F004C                       move.l    76(sp),d4 ; len
  ' 2C2F0050                       move.l    80(sp),d6 ; REGH
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 4BFA014C                       lea.l     ptr(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C000B             clear:    move.w    #11,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 0C8000000000                   cmpi.l    #0,d0
  ' 670A                           beq.s     weiter
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E41                           trap      #1
  ' 548F                           addq.l    #2,sp
  ' 60E6                           bra.s     clear
  ' 3F3C0022             weiter:   move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 4BFA0110                       lea.l     rett(pc),a5
  ' 2B6800200002                   move.l    32(a0),2(a5)
  ' 4BFA00FE                       lea.l     neuikbd(pc),a5
  ' 214D0020                       move.l    a5,32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 48E7FEFE                       movem.l   d0-d6/a0-a6,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)  ; Fcreate
  ' 2F0E                           move.l    a6,-(sp)
  ' 3F3C003C                       move.w    #60,-(sp)
  ' 4E41                           trap      #1
  ' 508F                           addq.l    #8,sp
  ' 3E00                           move.w    d0,d7
  ' 4CDF7F7F                       movem.l   (sp)+,d0-d6/a0-a6
  ' 41F9FEFF0441                   lea.l     $feff0441,a0          ; Flagstatus
  ' 43F9FEFF04C0                   lea.l     $feff04c0,a1          ; SDATA Word-Read (wegen PARITY)
  ' 49FA00DE                       lea.l     merk(pc),a4
  ' 220B                           move.l    a3,d1         ; MEMende
  ' D284                           add.l     d4,d1
  ' 7401                           moveq.l   #1,d2
  ' 7608                           moveq.l   #8,d3
  ' 08C60001                       bset      #1,d6
  ' 1086                           move.b    d6,(a0)   ; REC-FIFO lîschen
  ' 08860001                       bclr      #1,d6
  ' 1086                           move.b    d6,(a0)
  ' 7C00                           moveq.l   #0,d6
  ' 5286                 anf:      addq.l    #1,d6
  ' 244B                 anf1:     movea.l   a3,a2
  ' 1010                 ctrl1:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl1
  ' 3011                           move.w    (a1),d0   ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0700                           btst      d3,d0
  ' 66F4                           bne.s     ctrl1      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl2:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl2
  ' 3011                           move.w    (a1),d0   ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0700                           btst      d3,d0
  ' 66F4                           bne.s     ctrl2      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl3:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl3
  ' 3011                           move.w    (a1),d0   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0700                           btst      d3,d0
  ' 67F4                           beq.s     ctrl3      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl4:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl4
  ' 3011                           move.w    (a1),d0   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0700                           btst      d3,d0
  ' 67F4                           beq.s     ctrl4      ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' B5C1                           cmpa.l    d1,a2
  ' 66C4                           bne.s     ctrl1
  ' 48E77FF8                       movem.l   d1-d7/a0-a4,-(sp)
  ' 2F0B                           move.l    a3,-(sp)  ; Fwrite
  ' 2F04                           move.l    d4,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C0040                       move.w    #64,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 6B26                           bmi.s     weg
  ' B880                           cmp.l     d0,d4
  ' 6622                           bne.s     weg
  ' 3014                           move.w    (a4),d0
  ' 661E                           bne.s     weg
  ' 1010                           move.b    (a0),d0   ; Flag lesen
  ' 02000002                       andi.b    #2,d0     ; FIFO mehr als halbvoll ?
  ' 6612                           bne.s     nocopy    ; wenn nein, normal weiter
  ' 244B                           movea.l   a3,a2
  ' 5286                           addq.l    #1,d6
  ' 303C0FFF             copy:     move.w    #$0fff,d0 ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
  ' 14E90001             copy2:    move.b    1(a1),(a2)+   ; FIFO auslesen
  ' 51C8FFFA                       dbra      d0,copy2
  ' 6088                           bra.s     ctrl1
  ' BC85                 nocopy:   cmp.l     d5,d6
  ' 6680                           bne.s     anf
  ' 3F07                 weg:      move.w    d7,-(sp)  ; Fclose
  ' 3F3C003E                       move.w    #62,-(sp)
  ' 4E41                           trap      #1
  ' 588F                           addq.l    #4,sp
  ' 4BFA0039                       lea.l     ptr2(pc),a5
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)
  ' 3F3C0019                       move.w    #25,-(sp)
  ' 4E4E                           trap      #14
  ' 508F                           addq.l    #8,sp
  ' 3F3C0022                       move.w    #34,-(sp)
  ' 4E4E                           trap      #14
  ' 548F                           addq.l    #2,sp
  ' 2040                           movea.l   d0,a0
  ' 43FA0016                       lea.l     rett(pc),a1
  ' 216900020020                   move.l    2(a1),32(a0)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 33FC00010000016C     neuikbd:  move.w    #1,merk
  ' 4EF900000164         rett:     jmp       rett
  ' 12                   ptr:      DC.b $12
  ' 08                   ptr2:     DC.b $8
  ' 0000                 merk:     DC.w 0
anfhmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2C6F,&H0044
  DATA &H2A2F,&H0048
  DATA &H282F,&H004C
  DATA &H2C2F,&H0050
  DATA &H48E7,&HFFFE
  DATA &H4BFA,&H014C
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H000B
  DATA &H4E41
  DATA &H548F
  DATA &H0C80,&H0000,&H0000
  DATA &H670A
  DATA &H3F3C,&H0001
  DATA &H4E41
  DATA &H548F
  DATA &H60E6
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H4BFA,&H0110
  DATA &H2B68,&H0020,&H0002
  DATA &H4BFA,&H00FE
  DATA &H214D,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H48E7,&HFEFE
  DATA &H3F3C,&H0000
  DATA &H2F0E
  DATA &H3F3C,&H003C
  DATA &H4E41
  DATA &H508F
  DATA &H3E00
  DATA &H4CDF,&H7F7F
  DATA &H41F9,&HFEFF,&H0441
  DATA &H43F9,&HFEFF,&H04C0
  DATA &H49FA,&H00DE
  DATA &H220B
  DATA &HD284
  DATA &H7401
  DATA &H7608
  DATA &H08C6,&H0001
  DATA &H1086
  DATA &H0886,&H0001
  DATA &H1086
  DATA &H7C00
  DATA &H5286
  DATA &H244B
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H66F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H66F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H67F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H67F4
  DATA &H14C0
  DATA &HB5C1
  DATA &H66C4
  DATA &H48E7,&H7FF8
  DATA &H2F0B
  DATA &H2F04
  DATA &H3F07
  DATA &H3F3C,&H0040
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H1FFE
  DATA &H6B26
  DATA &HB880
  DATA &H6622
  DATA &H3014
  DATA &H661E
  DATA &H1010
  DATA &H0200,&H0002
  DATA &H6612
  DATA &H244B
  DATA &H5286
  DATA &H303C,&H0FFF
  DATA &H14E9,&H0001
  DATA &H51C8,&HFFFA
  DATA &H6088
  DATA &HBC85
  DATA &H6680
  DATA &H3F07
  DATA &H3F3C,&H003E
  DATA &H4E41
  DATA &H588F
  DATA &H4BFA,&H0039
  DATA &H2F0D
  DATA &H3F3C,&H0000
  DATA &H3F3C,&H0019
  DATA &H4E4E
  DATA &H508F
  DATA &H3F3C,&H0022
  DATA &H4E4E
  DATA &H548F
  DATA &H2040
  DATA &H43FA,&H0016
  DATA &H2169,&H0002,&H0020
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H33FC,&H0001,&H0000,&H016C
  DATA &H4EF9,&H0000,&H0164
  DATA &H1208
  DATA &H0000
  '
  RESTORE anfhmasch
  FOR g=0 TO 364 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  LPOKE mdat2%+352,mdat2%+364    !merk
  IF mtype=2 THEN
    DPOKE mdat2%+130,&HFEFF
    DPOKE mdat2%+136,&HFEFF
  ELSE
    DPOKE mdat2%+130,&HDF
    DPOKE mdat2%+136,&HDF
  ENDIF
  fifofill=recfifolen/2-1
  DPOKE mdat2%+278,fifofill
RETURN
'
> PROCEDURE maschruf8
  .| Glob. Var.: fastrec#,p#,mdat%,a$,fil$,sectors#,sce%,sde%,flen#,sdf%,sth#
  .|     demo#,sbe%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : record4-1,
  ' HARDDISK-RECORD
  '
  @busy_mouse
  IF fastrec=FALSE
    p=mdat%
    POKE p,&H12
    ~XBIOS(25,0,L:p)
  ENDIF
  a$=fil$+CHR$(0)
  IF sectors<=1 THEN
    sectors=2
  ENDIF
  sce%=sectors            !sectors
  sde%=flen               !len
  sdf%=sth
  IF demo=FALSE THEN
    sbe%=VARPTR(a$)        !Pfad
    ~C:mdat2%(L:mdat%,L:sbe%,L:sce%,L:sde%,L:sdf%)
  ENDIF
  IF fastrec=FALSE
    PAUSE 20
    p=mdat%
    POKE p,8
    ~XBIOS(25,0,L:p)
  ENDIF
RETURN
'
> PROCEDURE maschinit8b
  .| Glob. Var.: mdat2%
  .| Aufruf in : record4-1,
  LOCAL a,g
  ' HARDDISK-RECORD Type 2  (verbessert,aber langsamer)
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3 ; adr
  ' 2A6F0044                       movea.l   68(sp),a5 ; len
  ' 2C6F0048                       movea.l   72(sp),a6 ; handle
  ' 242F004C                       move.l    76(sp),d2 ; sectors
  ' 286F0050                       movea.l   80(sp),a4 ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
  ' 206F0054                       movea.l   84(sp),a0 ; StatH im Bytemode
  ' 226F0058                       movea.l   88(sp),a1 ; Playread im Wordmode
  ' 202F005C                       move.l    92(sp),d0 ; Returnwert (momentanes recbyte)
  ' 2F00                           move.l    d0,-(sp)  ; Returnwert retten
  ' 2F02                           move.l    d2,-(sp)  ; sectors
  ' 220B                           move.l    a3,d1     ; MEMende
  ' D28D                           add.l     a5,d1
  ' 7408                           moveq.l   #8,d2
  ' 7602                           moveq.l   #2,d3
  ' 7008                 anf:      moveq.l   #8,d0
  ' 3A11                 anf2:     move.w    (a1),d5   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0505                           btst      d2,d5
  ' 6708                           beq.s     anf3      ; fehlerhafte Daten ?
  ' 3A11                           move.w    (a1),d5   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0505                           btst      d2,d5
  ' 6702                           beq.s     anf3      ; fehlerhafte Daten ?
  ' 6010                           bra.s     holanf
  ' 51C8FFF0             anf3:     dbra      d0,anf2   ; 8x versuchen zu synchronisieren
  ' 610000CC                       bsr       brktst    ; dann abbruch testen
  ' 4A40                           tst.w     d0
  ' 660000B6                       bne       weg
  ' 60E0                           bra.s     anf       ; wiederholen bis synchronisiert
  ' 244B                 holanf:   movea.l   a3,a2
  ' 610000BE             anf4:     bsr       brktst    ; dann abbruch testen
  ' 4A40                           tst.w     d0
  ' 660000A8                       bne       weg
  ' 2001                           move.l    d1,d0
  ' 908A                           sub.l     a2,d0
  ' E480                           asr.l     #2,d0
  ' B04C                           cmp.w     a4,d0     ; Rest kleiner als halber FIFO ?
  ' 6F34                           ble.s     ctrl1     ; dann Rest holen und abspeichern
  ' 1010                           move.b    (a0),d0   ; Flag lesen
  ' C003                           and.b     d3,d0     ; FIFO mehr als halbvoll ?
  ' 6702                           beq.s     copy      ; wenn ja, daten schnell einlesen
  ' 60E4                           bra.s     anf4
  ' 300C                 copy:     move.w    a4,d0     ; wenn ja, halbes FIFO auslesen und in Puffer schreiben
  ' 3E11                 copy2:    move.w    (a1),d7   ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0507                           btst      d2,d7
  ' 661E                           bne.s     copy3     ; fehlerhafte Daten ?
  ' 3C11                           move.w    (a1),d6   ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0506                           btst      d2,d6
  ' 6618                           bne.s     copy3     ; fehlerhafte Daten ?
  ' 3A11                           move.w    (a1),d5   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0505                           btst      d2,d5
  ' 6712                           beq.s     copy3     ; fehlerhafte Daten ?
  ' 3811                           move.w    (a1),d4   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0504                           btst      d2,d4
  ' 670C                           beq.s     copy3     ; fehlerhafte Daten ?
  ' 14C7                           move.b    d7,(a2)+
  ' 14C6                           move.b    d6,(a2)+
  ' 14C5                           move.b    d5,(a2)+
  ' 14C4                           move.b    d4,(a2)+
  ' B5C1                           cmpa.l    d1,a2     ; sektorbuffer voll ?
  ' 6742                           beq.s     save
  ' 51C8FFDA             copy3:    dbra      d0,copy2
  ' 60B8                           bra.s     anf4
  ' 1010                 ctrl1:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl1
  ' 3011                           move.w    (a1),d0   ; High-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0700                           btst      d3,d0
  ' 66F4                           bne.s     ctrl1     ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl2:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl2
  ' 3011                           move.w    (a1),d0   ; Low-Byte,Rechter Kanal (Bit 8 geloescht ?)...
  ' 0700                           btst      d3,d0
  ' 66F4                           bne.s     ctrl2     ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl3:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl3
  ' 3011                           move.w    (a1),d0   ; High-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0700                           btst      d3,d0
  ' 67F4                           beq.s     ctrl3     ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' 1010                 ctrl4:    move.b    (a0),d0   ; Daten gÅltig ?
  ' C002                           and.b     d2,d0
  ' 67FA                           beq.s     ctrl4
  ' 3011                           move.w    (a1),d0   ; Low-Byte,Linker Kanal (Bit 8 gesetzt ?)...
  ' 0700                           btst      d3,d0
  ' 67F4                           beq.s     ctrl4     ; fehlerhafte Daten ?
  ' 14C0                           move.b    d0,(a2)+
  ' B5C1                           cmpa.l    d1,a2
  ' 66C4                           bne.s     ctrl1
  ' 48E77FFE             save:     movem.l   d1-d7/a0-a6,-(sp)
  ' 2F0B                           move.l    a3,-(sp)  ; Fwrite
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F0E                           move.w    a6,-(sp)
  ' 3F3C0040                       move.w    #64,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 6B12                           bmi.s     weg
  ' BBC0                           cmpa.l    d0,a5
  ' 660E                           bne.s     weg
  ' 201F                           move.l    (sp)+,d0
  ' 5380                           subq.l    #1,d0
  ' 2F00                           move.l    d0,-(sp)
  ' 4A80                           tst.l     d0        ; alle Sektoren geschrieben ?
  ' 6704                           beq.s     weg
  ' 6000FF50                       bra       holanf
  ' 201F                 weg:      move.l    (sp)+,d0  ; geschriebene sektoren
  ' 285F                           movea.l   (sp)+,a4
  ' 288A                           move.l    a2,(a4)
  ' 29400004                       move.l    d0,4(a4)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 48E77FFE             brktst:   movem.l   d1-d7/a0-a6,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 4E75                           rts
anfh2masch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2A6F,&H0044
  DATA &H2C6F,&H0048
  DATA &H242F,&H004C
  DATA &H286F,&H0050
  DATA &H206F,&H0054
  DATA &H226F,&H0058
  DATA &H202F,&H005C
  DATA &H2F00
  DATA &H2F02
  DATA &H220B
  DATA &HD28D
  DATA &H7408
  DATA &H7602
  DATA &H7008
  DATA &H3A11
  DATA &H0505
  DATA &H6708
  DATA &H3A11
  DATA &H0505
  DATA &H6702
  DATA &H6010
  DATA &H51C8,&HFFF0
  DATA &H6100,&H00CC
  DATA &H4A40
  DATA &H6600,&H00B6
  DATA &H60E0
  DATA &H244B
  DATA &H6100,&H00BE
  DATA &H4A40
  DATA &H6600,&H00A8
  DATA &H2001
  DATA &H908A
  DATA &HE480
  DATA &HB04C
  DATA &H6F34
  DATA &H1010
  DATA &HC003
  DATA &H6702
  DATA &H60E4
  DATA &H300C
  DATA &H3E11
  DATA &H0507
  DATA &H661E
  DATA &H3C11
  DATA &H0506
  DATA &H6618
  DATA &H3A11
  DATA &H0505
  DATA &H6712
  DATA &H3811
  DATA &H0504
  DATA &H670C
  DATA &H14C7
  DATA &H14C6
  DATA &H14C5
  DATA &H14C4
  DATA &HB5C1
  DATA &H6742
  DATA &H51C8,&HFFDA
  DATA &H60B8
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H66F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H66F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H67F4
  DATA &H14C0
  DATA &H1010
  DATA &HC002
  DATA &H67FA
  DATA &H3011
  DATA &H0700
  DATA &H67F4
  DATA &H14C0
  DATA &HB5C1
  DATA &H66C4
  DATA &H48E7,&H7FFE
  DATA &H2F0B
  DATA &H2F0D
  DATA &H3F0E
  DATA &H3F3C,&H0040
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H7FFE
  DATA &H6B12
  DATA &HBBC0
  DATA &H660E
  DATA &H201F
  DATA &H5380
  DATA &H2F00
  DATA &H4A80
  DATA &H6704
  DATA &H6000,&HFF50
  DATA &H201F
  DATA &H285F
  DATA &H288A
  DATA &H2940,&H0004
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0002
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H7FFE
  DATA &H4E75
  '
  RESTORE anfh2masch
  FOR g=0 TO 294 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf8b
  .| Glob. Var.: fastrec#,p#,mdat%,fil$,sce%,sbe%,flen#,recfifolen#,sectors#
  .|     sde%,see%,sfe%,adr#,sge%,she%,wback%,demo#,nr#,peak&,t#,hsec#,hz#
  .|     peakmax&,peakint#,back%,back3%,hsec2#,smpedit&,smpsec&,peakpos&
  .|     peakret#,sec$,edit_obj&,idx&,tree&,mdat2%
  .| Ruft auf  : busy_mouse,htimeset,textfeld,peakrec,mousek,rsc_message
  .|     markhlp
  .| Aufruf in : record4-1,
  LOCAL a,a$,b$
  ' HARDDISK-RECORD Type 2 (verbessert,aber langsamer)
  '
  @busy_mouse
  IF XBIOS(500)<>&H71273800 THEN
    p=mdat%
    IF fastrec=FALSE THEN
      POKE p,&H12
      ~XBIOS(25,0,L:p)
    ELSE
      POKE p,7
      POKE p+1,4
      ~XBIOS(25,1,L:p)
    ENDIF
  ENDIF
  a$=fil$+CHR$(0)
  a=VARPTR(a$)        !Pfad
  filadr=a
  sce%=GEMDOS(60,L:a,L:0)
  @rec_headinit(a$)
  IF sce%>=0 THEN
    sbe%=flen               !pufferlen
    IF sectors<=1 THEN
      sectors=2
    ENDIF
    sde%=sectors            !sectors (grîûe jeweils pufferlen)
    see%=recfifolen/2/4-1
    sfe%=adr+&H60
    sge%=adr+&H200-1
    she%=wback%
    IF demo=FALSE THEN
      IF XBIOS(500)=&H71273800 THEN
        IF nr=peak& THEN
          a=XBIOS(118,L:mdat%,L:sbe%,L:sce%,L:sde%,L:see%,L:sfe%,L:sge%)
        ELSE
          a=XBIOS(115,L:mdat%,L:sbe%,L:sce%,L:sde%,L:see%,L:sfe%,L:sge%)
        ENDIF
        PAUSE 5
        IF autorec=FALSE THEN
          @fifodel
        ENDIF
        @write_int(2)
        t=TIMER
        peaktime=t
        IF nr=smpedit& THEN
          @textfeld(smprate&,"0"+CHR$(0),1)
        ENDIF
        IF nr=peak& THEN
          hsec=INT(sbe%*sde%/hz/4*100)
          @htimeset
          @textfeld(peakmax&,a$,1)
          @textfeld(recerror&,"0"+CHR$(0),1)
          @textfeld(recpeaks&,"0"+CHR$(0),1)
        ENDIF
        peakint=FALSE
        LPOKE a+16,0
        REPEAT
        UNTIL @mousek=0
        rfull=0
        peaks=0
        peaks2=0
        REPEAT
          peakret=a+12
          peakexit=a+8
          peakfull=a+16
          back%=LPEEK(a)
          rfull2=LPEEK(peakfull)
          hsec2=INT((TIMER-t)/2)
          IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
            hsec=hsec2
            @htimeset
            @busy_mouse
            IF nr=smpedit& THEN
              @textfeld(smpsec&,a$,1)
              IF rfull2<>rfull THEN
                rfull=rfull2
                b$=STR$(rfull)+CHR$(0)
                @textfeld(smprate&,b$,1)
              ENDIF
            ENDIF
            IF nr=peak& THEN
              @textfeld(peakpos&,a$,1)
              IF rfull2<>rfull THEN
                rfull=rfull2
                b$=STR$(rfull)+CHR$(0)
                @textfeld(recerror&,b$,1)
              ENDIF
              IF peaks2<>peaks THEN
                peaks=peaks2
                b$=STR$(peaks)+CHR$(0)
                @textfeld(recpeaks&,b$,1)
              ENDIF
              @peakrec
            ENDIF
          ENDIF
          k=@mousek
          ~FRE(0)
          back3%=LPEEK(peakexit)
        UNTIL back3%=1 OR k=3 OR k=2
        @write_int(0)
        PAUSE 10
        @rec_header
        IF nr=smpedit& THEN
          @textfeld(smpsec&,sec$,1)
        ENDIF
        IF nr=peak& THEN
          a$=SPACE$(11)+CHR$(0)
          @textfeld(peakmax&,a$,1)
          @textfeld(peakpos&,a$,1)
          @setbutton(ed_obj,0)
          rsc_message(smpedit&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
          nr=smpedit&
          tree&=nr
          @markhlp
        ENDIF
      ELSE
        ~C:mdat2%(L:mdat%,L:sbe%,L:sce%,L:sde%,L:see%,L:sfe%,L:sge%,L:she%)
      ENDIF
    ENDIF
    ~GEMDOS(62,sce%)
  ENDIF
  IF XBIOS(500)<>&H71273800 THEN
    p=mdat%
    IF fastrec=FALSE THEN
      POKE p,8
      ~XBIOS(25,0,L:p)
    ELSE
      PAUSE 20
      POKE p,7
      POKE p+1,0
      ~XBIOS(25,1,L:p)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE maschinit9
  .| Glob. Var.: mdat2%
  .| Aufruf in : smpmhlp-8,smpcut-2,virtmove-1,sampleinf-1,make-1,trash-1
  .|     setup-1,conspace-1,coninsert-2,memtovirt-1,memtovirt2-1,makeresmp-4,
  LOCAL a,g
  ' CUT
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 7000                           moveq.l   #0,d0
  ' 20C0                 anf2:     move.l    d0,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DFA                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfimasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H7000
  DATA &H20C0
  DATA &HB1C9
  DATA &H6DFA
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfimasch
  FOR g=0 TO 24 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf9(ca,cb)
  .| Glob. Var.: cfa%,cfb%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpmhlp-18,smpcut-8,virtmove-2,sampleinf-1,make-1,trash-1
  .|     setup-1,conspace-2,coninsert-3,memtovirt-1,memtovirt2-1,makeresmp-4,
  ' CUT
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  ~C:mdat2%(L:cfa%,L:cfb%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit10
  .| Glob. Var.: mdat2%
  .| Aufruf in : smpkhlp-1,makeresmp-2,
  LOCAL a,g
  ' COPY
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 246F0048                       movea.l   72(sp),a2 ; dest
  ' 266F004C                       movea.l   76(sp),a3 ; grenzwert
  ' 24D8                 anf2:     move.l    (a0)+,(a2)+
  ' B1C9                           cmp.l     a1,a0
  ' 6C04                           bge.s     weg
  ' B5CB                           cmp.l     a3,a2
  ' 6DF6                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfjmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H266F,&H004C
  DATA &H24D8
  DATA &HB1C9
  DATA &H6C04
  DATA &HB5CB
  DATA &H6DF6
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfjmasch
  FOR g=0 TO 34 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf10(ca,cb,cc,cd)
  .| Glob. Var.: cfa%,cfb%,cfc%,cfd%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpkhlp-5,makeresmp-2,
  ' COPY
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  cfc%=cc
  cfd%=cd
  ~C:mdat2%(L:cfa%,L:cfb%,L:cfc%,L:cfd%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit11
  .| Glob. Var.: mdat2%
  .| Aufruf in : smpkhlp-1,
  LOCAL a,g
  ' BACK-COPY
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; ende
  ' 226F0044                       movea.l   68(sp),a1 ; anf
  ' 246F0048                       movea.l   72(sp),a2 ; destende
  ' 2520                 anf2:     move.l    -(a0),-(a2)
  ' B1C9                           cmp.l     a1,a0
  ' 6EFA                           bgt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfkmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H2520
  DATA &HB1C9
  DATA &H6EFA
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfkmasch
  FOR g=0 TO 26 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf11(ca,cb,cc)
  .| Glob. Var.: cfa%,cfb%,cfc%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpkhlp-1,
  ' BACK-COPY
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  cfc%=cc
  ~C:mdat2%(L:cfa%,L:cfb%,L:cfc%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit12
  .| Glob. Var.: mdat2%
  .| Aufruf in : normtest-1,
  LOCAL a,g
  ' PEAK-SUCH
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 246F0048                       movea.l   72(sp),a2 ; Returnwert
  ' 7000                           moveq.l   #0,d0
  ' 3218                 anf2:     move.w    (a0)+,d1
  ' 0801000F                       btst      #15,d1
  ' 6702                           beq.s     noneg
  ' 4641                           not.w     d1
  ' B240                 noneg:    cmp.w     d0,d1
  ' 6D02                           blt.s     noadd
  ' 3001                           move.w    d1,d0
  ' B1C9                 noadd:    cmp.l     a1,a0
  ' 6DEC                           blt.s     anf2
  ' 2480                           move.l    d0,(a2)
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anflmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H7000
  DATA &H3218
  DATA &H0801,&H000F
  DATA &H6702
  DATA &H4641
  DATA &HB240
  DATA &H6D02
  DATA &H3001
  DATA &HB1C9
  DATA &H6DEC
  DATA &H2480
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anflmasch
  FOR g=0 TO 44 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf12(ca,cb)
  .| Glob. Var.: cfa%,cfb%,wback%,cfc%,mdat2%,back%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : normtest-3,
  ' PEAK-SUCH
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  LPOKE wback%,0
  cfc%=wback%
  ~C:mdat2%(L:cfa%,L:cfb%,L:cfc%)
  back%=LPEEK(wback%)
RETURN
'
> PROCEDURE maschinit13
  .| Glob. Var.: mdat2%
  .| Aufruf in : makenorm-1,
  LOCAL a,g
  ' NORMALIZE
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 202F0048                       move.l    72(sp),d0 ; grenz
  ' 222F004C                       move.l    76(sp),d1 ; back%
  ' 7400                 anf2:     moveq.l   #0,d2
  ' 163C0000                       move.b    #0,d3
  ' 3410                           move.w    (a0),d2
  ' 0802000F                       btst      #15,d2
  ' 6714                           beq.s     noneg
  ' 4642                           not.w     d2
  ' C4C0                           mulu.w    d0,d2
  ' 84C1                           divu.w    d1,d2
  ' 4642                           not.w     d2
  ' 30C2                           move.w    d2,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DE4                           blt.s     anf2
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' C4C0                 noneg:    mulu.w    d0,d2
  ' 84C1                           divu.w    d1,d2
  ' 30C2                           move.w    d2,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DD4                           blt.s     anf2
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfmmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H202F,&H0048
  DATA &H222F,&H004C
  DATA &H7400
  DATA &H163C,&H0000
  DATA &H3410
  DATA &H0802,&H000F
  DATA &H6714
  DATA &H4642
  DATA &HC4C0
  DATA &H84C1
  DATA &H4642
  DATA &H30C2
  DATA &HB1C9
  DATA &H6DE4
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &HC4C0
  DATA &H84C1
  DATA &H30C2
  DATA &HB1C9
  DATA &H6DD4
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfmmasch
  FOR g=0 TO 68 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf13(ca,cb,cc,cd)
  .| Glob. Var.: cfa%,cfb%,cfc%,cfd%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : makenorm-2,
  ' NORMALIZE
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  cfc%=cc
  cfd%=cd
  ~C:mdat2%(L:cfa%,L:cfb%,L:cfc%,L:cfd%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit16
  .| Glob. Var.: mdat2%
  .| Aufruf in : arr_resmp-1,makeresmp-1,
  LOCAL a,g
  ' RESAMPLE
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; sourceanf
  ' 226F0044                       movea.l   68(sp),a1 ; sourceende
  ' 246F0048                       movea.l   72(sp),a2 ; destanf
  ' 266F004C                       movea.l   76(sp),a3 ; destende
  ' 262F0050                       move.l    80(sp),d3 ; source-sample-rate (320,441,480)
  ' 282F0054                       move.l    84(sp),d4 ; dest-sample-rate (320,441,480)
  ' 286F0058                       move.l    88(sp),a4 ; destende-RETURN-Wert
  ' 2A03                           move.l    d3,d5
  ' 9A84                           sub.l     d4,d5
  ' 7200                           moveq.l   #0,d1
  ' 2403                           move.l    d3,d2
  ' 84C4                           divu      d4,d2
  ' 0C8200000001                   cmpi.l    #1,d2
  ' 6712                           beq.s     abzanf
  ' 02820000FFFF                   andi.l    #$ffff,d2
  ' 0C420000                       cmpi.w    #0,d2
  ' 6740                           beq.s     dazuanf
  ' 0C420002                       cmpi.w    #2,d2
  ' 6D20                           blt.s     abzanf2
  ' 24D0                 abzanf:   move.l    (a0),(a2)+
  ' D283                           add.l     d3,d1
  ' 2401                           move.l    d1,d2
  ' 84C4                           divu      d4,d2
  ' 02820000FFFF                   andi.l    #$ffff,d2
  ' 2E02                           move.l    d2,d7
  ' CEFC0004                       mulu      #4,d7
  ' C4C4                           mulu      d4,d2
  ' 9282                           sub.l     d2,d1
  ' D1C7                           adda.l    d7,a0
  ' B1C9                           cmpa.l    a1,a0
  ' 6DE2                           blt.s     abzanf
  ' 6066                           bra.s     ende
  ' 2A03                 abzanf2:  move.l    d3,d5
  ' 9A84                           sub.l     d4,d5
  ' 2018                 abzanf3:  move.l    (a0)+,d0
  ' D285                           add.l     d5,d1
  ' 2401                           move.l    d1,d2
  ' 9483                           sub.l     d3,d2
  ' 6B04                           bmi.s     noabz2
  ' 2202                           move.l    d2,d1
  ' 6002                           bra.s     abztest2
  ' 24C0                 noabz2:   move.l    d0,(a2)+
  ' B1C9                 abztest2: cmpa.l    a1,a0
  ' 6DEC                           blt.s     abzanf3
  ' 604C                           bra.s     ende
  ' 2404                 dazuanf:  move.l    d4,d2
  ' 84C3                           divu      d3,d2
  ' 0C420002                       cmpi.w    #2,d2
  ' 6C1E                           bge.s     dazuanf4
  ' 2A04                           move.l    d4,d5
  ' 9A83                           sub.l     d3,d5
  ' 2018                 dazuanf2: move.l    (a0)+,d0
  ' D285                           add.l     d5,d1
  ' 2401                           move.l    d1,d2
  ' 9483                           sub.l     d3,d2
  ' 6B04                           bmi.s     dazuanf3
  ' 2202                           move.l    d2,d1
  ' 24C0                           move.l    d0,(a2)+
  ' 24C0                 dazuanf3: move.l    d0,(a2)+
  ' B5CB                           cmpa.l    a3,a2
  ' 6C2A                           bge.s     ende
  ' B1C9                           cmpa.l    a1,a0
  ' 6DE8                           blt.s     dazuanf2
  ' 6024                           bra.s     ende
  ' 2018                 dazuanf4: move.l    (a0)+,d0
  ' D284                           add.l     d4,d1
  ' 2401                           move.l    d1,d2
  ' 84C3                           divu      d3,d2
  ' 02820000FFFF                   andi.l    #$ffff,d2
  ' 2E02                           move.l    d2,d7
  ' C4C3                           mulu      d3,d2
  ' 9282                           sub.l     d2,d1
  ' 5387                           subq.l    #1,d7
  ' 24C0                 dazuanf5: move.l    d0,(a2)+
  ' B5CB                           cmp.l     a3,a2
  ' 6C08                           bge.s     ende
  ' 51CFFFF8                       dbra      d7,dazuanf5
  ' B1C9                           cmpa.l    a1,a0
  ' 6DDC                           blt.s     dazuanf4
  ' 288A                 ende:     move.l    a2,(a4)
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfpmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H266F,&H004C
  DATA &H262F,&H0050
  DATA &H282F,&H0054
  DATA &H286F,&H0058
  DATA &H2A03
  DATA &H9A84
  DATA &H7200
  DATA &H2403
  DATA &H84C4
  DATA &H0C82,&H0000,&H0001
  DATA &H6712
  DATA &H0282,&H0000,&HFFFF
  DATA &H0C42,&H0000
  DATA &H6740
  DATA &H0C42,&H0002
  DATA &H6D20
  DATA &H24D0
  DATA &HD283
  DATA &H2401
  DATA &H84C4
  DATA &H0282,&H0000,&HFFFF
  DATA &H2E02
  DATA &HCEFC,&H0004
  DATA &HC4C4
  DATA &H9282
  DATA &HD1C7
  DATA &HB1C9
  DATA &H6DE2
  DATA &H6066
  DATA &H2A03
  DATA &H9A84
  DATA &H2018
  DATA &HD285
  DATA &H2401
  DATA &H9483
  DATA &H6B04
  DATA &H2202
  DATA &H6002
  DATA &H24C0
  DATA &HB1C9
  DATA &H6DEC
  DATA &H604C
  DATA &H2404
  DATA &H84C3
  DATA &H0C42,&H0002
  DATA &H6C1E
  DATA &H2A04
  DATA &H9A83
  DATA &H2018
  DATA &HD285
  DATA &H2401
  DATA &H9483
  DATA &H6B04
  DATA &H2202
  DATA &H24C0
  DATA &H24C0
  DATA &HB5CB
  DATA &H6C2A
  DATA &HB1C9
  DATA &H6DE8
  DATA &H6024
  DATA &H2018
  DATA &HD284
  DATA &H2401
  DATA &H84C3
  DATA &H0282,&H0000,&HFFFF
  DATA &H2E02
  DATA &HC4C3
  DATA &H9282
  DATA &H5387
  DATA &H24C0
  DATA &HB5CB
  DATA &H6C08
  DATA &H51CF,&HFFF8
  DATA &HB1C9
  DATA &H6DDC
  DATA &H288A
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfpmasch
  FOR g=0 TO 208 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf16(a,b,c,d,e,f)
  .| Glob. Var.: saa%,sba%,sca%,sda%,sea%,sfa%,wback%,sga%,mdat2%,back%
  .|     cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : arr_resmp-1,makeresmp-5,
  ' RESAMPLE
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  ' c - destanf
  ' d - destende
  ' e - source-sample-rate (320,441,480)
  ' f - dest-sample-rate (320,441,480)
  ' back% - destende-RETURN-Wert
  '
  saa%=a
  sba%=b
  sca%=c
  sda%=d
  sea%=e
  sfa%=f
  LPOKE wback%,0
  sga%=wback%
  ~C:mdat2%(L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:sfa%,L:sga%)
  back%=LPEEK(wback%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit17
  .| Glob. Var.: mdat2%
  .| Aufruf in : mono-1,
  LOCAL a,g
  ' MONO
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 7200                 anf2:     moveq.l   #0,d1
  ' 2401                           move.l    d1,d2
  ' 3210                           move.w    (a0),d1
  ' 34280002                       move.w    2(a0),d2
  ' 0801000F                       btst      #15,d1
  ' 660A                           bne.s     anf5
  ' 0802000F             anf3:     btst      #15,d2
  ' 6612                           bne.s     anf6
  ' D282                 anf4:     add.l     d2,d1    ; plus und plus = plus
  ' 6016                           bra.s     ende
  ' 0802000F             anf5:     btst      #15,d2
  ' 660E                           bne.s     anf7     ; minus und minus = minus
  ' 4641                           not.w     d1
  ' 9481                           sub.l     d1,d2    ; minus und plus = ?
  ' 2202                           move.l    d2,d1
  ' 6008                           bra.s     ende
  ' 4642                 anf6:     not.w     d2       ; plus und minus = ?
  ' 9282                           sub.l     d2,d1
  ' 6002                           bra.s     ende
  ' D282                 anf7:     add.l     d2,d1    ; add + wech
  ' E281                 ende:     asr.l     #1,d1
  ' 30C1                           move.w    d1,(a0)+
  ' 30C1                           move.w    d1,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DC6                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfqmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H7200
  DATA &H2401
  DATA &H3210
  DATA &H3428,&H0002
  DATA &H0801,&H000F
  DATA &H660A
  DATA &H0802,&H000F
  DATA &H6612
  DATA &HD282
  DATA &H6016
  DATA &H0802,&H000F
  DATA &H660E
  DATA &H4641
  DATA &H9481
  DATA &H2202
  DATA &H6008
  DATA &H4642
  DATA &H9282
  DATA &H6002
  DATA &HD282
  DATA &HE281
  DATA &H30C1
  DATA &H30C1
  DATA &HB1C9
  DATA &H6DC6
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfqmasch
  FOR g=0 TO 74 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf17(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : mono-3,
  ' MONO
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~C:mdat2%(L:saa%,L:sba%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf18
  .| Glob. Var.: saa%,a#,sba%,b#,sret#,adder#,l#,sloop#,raus#,x#,y#,v#,v2#,v3#
  .|     v4#,xx#,ch#,xx2#,note#,xx3#,yy#,demo#
  .| Ruft auf  : digout,maschinit2b,maschruf2c,maschinit2d
  .| Aufruf in : smpplay-2,smppmhlp-2,
  ' MIDI-PLAY,MIDI-BACKPLAY,MIDI-CROSSPLAY
  '
  ' a - sourceanf
  ' b - sourceende
  ' l - LÑnge
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  @digout(TRUE)
  saa%=a
  sba%=b
  @maschinit2b
  REPEAT
    IF sret=0 THEN
      adder=0
      l=0
    ENDIF
    IF sret=1 THEN
      adder=-8
      l=0
    ENDIF
    IF sret=2 THEN
      adder=0
      l=2
    ENDIF
    IF sloop=1 THEN
      l=l+1
    ENDIF
    raus=FALSE
    REPEAT
      x=INP?(3)
      y=INP?(2)
      ~GRAF_MKSTATE(v,v2,v3,v4)
      IF x=TRUE AND v3<>2 THEN
        xx=INP(3)
        IF xx=&H90+(ch-1) THEN
          REPEAT
            x=INP?(3)
            y=INP?(2)
            ~GRAF_MKSTATE(v,v2,v3,v4)
          UNTIL x=TRUE OR y=TRUE OR v3=2
          IF y=FALSE AND x=TRUE AND v3<>2 THEN
            xx2=INP(3)
            IF xx2=note AND v3<>2 THEN
              REPEAT
                x=INP?(3)
                y=INP?(2)
                ~GRAF_MKSTATE(v,v2,v3,v4)
              UNTIL x=TRUE OR y=TRUE OR v3=2
              IF y=FALSE AND x=TRUE AND v3<>2 THEN
                xx3=INP(3)
                IF xx=&H90+(ch-1) AND xx2=note AND xx3<>0 THEN
                  raus=TRUE
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      IF y=TRUE AND v3<>2 THEN
        yy=INP(2)
      ENDIF
      ~GRAF_MKSTATE(v,v2,v3,v4)
    UNTIL y=TRUE OR raus=TRUE OR v3=2
    IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
      @maschruf2c
    ENDIF
    ~GRAF_MKSTATE(v,v2,v3,v4)
  UNTIL v3=2 OR y=TRUE OR INP?(2)=TRUE
  @maschinit2d
RETURN
'
> PROCEDURE maschruf18b
  .| Glob. Var.: lmax2#,n#,midiwort#,raus#,x#,y#,v#,v2#,v3#,v4#,xx#,xx2#,xx3#
  .|     ch#,note#,z#,vch#,vnote#,l#,saa%,meml#,sba%,adder#,yy#,demo#,vhz#,pa$
  .|     sectors#,handle#,playpos#,flen#,over#
  .| Felder    : midi#(),arrmidi#(),arrpath$(),arrloop#(),arrtri#(),arrstrt#()
  .|     arrend#(),arrsrate#()
  .| Ruft auf  : busy_mouse,digout,maschinit2b,maschinit5b,swtosrate
  .|     maschruf2c,maschruf5c,maschinit2d
  .| Aufruf in : arrmidplay-2,
  LOCAL i,j,m
  ' ARR-MIDIPLAY,ARR-MIDICROSSPLAY,ARR-MIDIBACKPLAY
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  ' l - LÑnge
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  @digout(TRUE)
  @maschinit2b
  @maschinit5b
  FOR j=0 TO 15
    FOR i=0 TO 127
      midi(j,i)=0
    NEXT i
  NEXT j
  FOR i=1 TO lmax2
    m=(arrmidi(i) AND 255)
    n=INT(midiwort/256)
    IF m>=0 AND m<128 AND n>=0 AND n<16 THEN
      IF midi(n,m)=0 THEN
        midi(n,m)=i
      ENDIF
    ENDIF
  NEXT i
  REPEAT
    raus=FALSE
    REPEAT
      x=INP?(3)
      y=INP?(2)
      ~GRAF_MKSTATE(v,v2,v3,v4)
      IF x=TRUE AND v3<>2 THEN
        xx=INP(3)
        IF xx>=&H90 AND xx<=&H9F THEN     ! xx-&H90 = channel
          REPEAT
            x=INP?(3)
            y=INP?(2)
            ~GRAF_MKSTATE(v,v2,v3,v4)
          UNTIL x=TRUE OR y=TRUE OR v3=2
          IF y=FALSE AND x=TRUE AND v3<>2 THEN
            xx2=INP(3)
            IF v3<>2 THEN             ! xx2 = note
              REPEAT
                x=INP?(3)
                y=INP?(2)
                ~GRAF_MKSTATE(v,v2,v3,v4)
              UNTIL x=TRUE OR y=TRUE OR v3=2
              IF y=FALSE AND x=TRUE AND v3<>2 THEN
                xx3=INP(3)
                IF xx>=&H90 AND xx<=&H9F AND xx3<>0 THEN
                  ch=xx-&H90
                  note=xx2
                  z=midi(ch,note)
                  midiwort=arrmidi(z)
                  vch=INT(midiwort/256)
                  vnote=midiwort AND 255
                  ~GRAF_MKSTATE(v,v2,v3,v4)
                  IF vch=ch AND vnote=note AND arrpath$(z)<>"" AND arrpath$(z)<>"DELAY" THEN
                    IF arrloop(z)=0 THEN
                      l=0
                    ELSE
                      l=1
                    ENDIF
                    IF arrtri(z)=0 OR arrtri(z)=2 THEN
                      saa%=arrstrt(z)+meml
                      sba%=arrend(z)+meml
                      adder=0
                      IF arrtri(z)=2 THEN
                        l=l+2
                      ENDIF
                    ENDIF
                    IF arrtri(z)=1 THEN
                      sba%=arrstrt(z)+meml
                      saa%=arrend(z)+meml
                      IF arrpath$(z)="MEMORY" THEN
                        adder=-8
                      ENDIF
                    ENDIF
                    raus=TRUE
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      ~GRAF_MKSTATE(v,v2,v3,v4)
      IF y=TRUE AND v3<>2 THEN
        yy=INP(2)
      ENDIF
    UNTIL y=TRUE OR raus=TRUE OR v3=2
    IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
      IF arrpath$(z)="MEMORY" THEN
        vhz=arrsrate(z)
        @swtosrate(vhz)
        @maschruf2c
      ENDIF
      IF arrpath$(z)<>"MEMORY" AND arrpath$(z)<>"" AND arrpath$(z)<>"DELAY" THEN
        pa$=arrpath$(z)+CHR$(0)
        sectors=arrend(z)-arrstrt(z)
        handle=GEMDOS(61,L:VARPTR(pa$),0)
        IF arrtri(z)=0 OR arrtri(z)=2 THEN
          playpos=arrstrt(z)*flen
          vhz=arrsrate(z)
          @swtosrate(vhz)
          over=0
          l=arrloop(z)+4
          IF arrtri(z)=2 THEN
            l=l+2
          ENDIF
          @maschruf5c
        ENDIF
        IF arrtri(z)=1 THEN
          playpos=arrend(z)*flen
          vhz=arrsrate(z)
          @swtosrate(vhz)
          l=arrloop(z)+4
          over=-8
          @maschruf5c
        ENDIF
        ~GEMDOS(62,handle)
      ENDIF
    ENDIF
    ~GRAF_MKSTATE(v,v2,v3,v4)
  UNTIL v3=2 OR y=TRUE OR INP?(2)<>0
  @maschinit2d
RETURN
'
> PROCEDURE maschruf18c
  .| Glob. Var.: midiwort#,ch#,note#,sda%,raus#,x#,y#,v#,v2#,v3#,v4#,xx#,xx2#
  .|     xx3#,yy#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpplay-2,
  ' MIDI-WAIT
  '
  @busy_mouse
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  midiwort=(ch-1)*256+note
  sda%=midiwort
  raus=FALSE
  REPEAT
    x=INP?(3)
    y=INP?(2)
    ~GRAF_MKSTATE(v,v2,v3,v4)
    IF x=TRUE AND v3<>2 THEN
      xx=INP(3)
      IF xx=&H90+(ch-1) THEN
        REPEAT
          x=INP?(3)
          y=INP?(2)
          ~GRAF_MKSTATE(v,v2,v3,v4)
        UNTIL x=TRUE OR y=TRUE OR v3=2
        IF y=FALSE AND x=TRUE AND v3<>2 THEN
          xx2=INP(3)
          IF xx2=note AND v3<>2 THEN
            REPEAT
              x=INP?(3)
              y=INP?(2)
              ~GRAF_MKSTATE(v,v2,v3,v4)
            UNTIL x=TRUE OR y=TRUE OR v3=2
            IF y=FALSE AND x=TRUE AND v3<>2 THEN
              xx3=INP(3)
              IF xx=&H90+(ch-1) AND xx2=note AND xx3<>0 THEN
                raus=TRUE
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    IF y=TRUE AND v3<>2 THEN
      yy=INP(2)
    ENDIF
    ~GRAF_MKSTATE(v,v2,v3,v4)
  UNTIL y=TRUE OR raus=TRUE OR v3=2 OR INP?(2)=TRUE
RETURN
'
> PROCEDURE maschinit28
  .| Glob. Var.: mdat2%
  .| Aufruf in : smpsave-2,ldhlp-1,
  LOCAL a,g
  ' LOAD INTEL-DATA
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 7000                           moveq.l   #0,d0
  ' 3010                 anf2:     move.w    (a0),d0
  ' 10C0                           move.b    d0,(a0)+
  ' E040                           asr.w     #8,d0
  ' 10C0                           move.b    d0,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DF4                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  '
anfabmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H7000
  DATA &H3010
  DATA &H10C0
  DATA &HE040
  DATA &H10C0
  DATA &HB1C9
  DATA &H6DF4
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfabmasch
  FOR g=0 TO 30 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf28(start,datalen)
  .| Glob. Var.: sad%,sbd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpsave-2,ldhlp-1,
  ' LOAD-INTEL-DATA
  '
  @busy_mouse
  sad%=start
  sbd%=start+datalen
  ~C:mdat2%(L:sad%,L:sbd%)
RETURN
'
> PROCEDURE maschinit29
  .| Glob. Var.: mdat2%
  .| Aufruf in : make-2,
  LOCAL a,g
  ' COPYBACK
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; dest
  ' 2449                           move.l    a1,a2
  ' 598A                 anf2:     subq.l    #4,a2
  ' 22D2                           move.l    (a2),(a1)+
  ' B5C8                           cmp.l     a0,a2
  ' 6EF8                           bgt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  '
anfacmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H2449
  DATA &H598A
  DATA &H22D2
  DATA &HB5C8
  DATA &H6EF8
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfacmasch
  FOR g=0 TO 26 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf29(start,dest)
  .| Glob. Var.: sad%,sbd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : make-2,
  ' COPYBACK
  '
  @busy_mouse
  sad%=start
  sbd%=dest
  ~C:mdat2%(L:sad%,L:sbd%)
RETURN
'
> PROCEDURE maschinit30
  .| Glob. Var.: mdat2%
  .| Aufruf in : fade_it-3,
  LOCAL a,g
  ' FADE IN&OUT
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; data
  ' 202F0044                       move.l    68(sp),d0 ; werte
  ' 226F0048                       movea.l   72(sp),a1 ; anfang
  ' 246F004C                       movea.l   76(sp),a2 ; ende
  ' 260A                           move.l    a2,d3
  ' 2409                           move.l    a1,d2
  ' 9682                           sub.l     d2,d3
  ' E483                           asr.l     #2,d3
  ' 02833FFFFFFF                   andi.l    #$3FFFFFFF,d3
  ' 86C0                           divu.w    d0,d3
  ' 0243FFFF                       andi.w    #$ffff,d3
  ' B67C0000                       cmp.w     #0,d3
  ' 6604                           bne.s     anf2a
  ' 363C0001                       move.w    #1,d3
  ' 04400001             anf2a:    sub.w     #1,d0
  ' 3410                 anf2:     move.w    (a0),d2
  ' 3C280002                       move.w    2(a0),d6
  ' 9C42                           sub.w     d2,d6
  ' 02860000FFFF                   andi.l    #$ffff,d6
  ' 0806000F                       btst      #15,d6
  ' 6712                           beq.s     positiv
  ' 4446                 negativ:  neg.w     d6
  ' B67C0000                       cmp.w     #0,d3
  ' 6706                           beq.s     neg2
  ' 8CC3                           divu.w    d3,d6
  ' 0246FFFF                       andi.w    #$ffff,d6
  ' 4446                 neg2:     neg.w     d6
  ' 6008                           bra.s     anf2b
  ' B67C0000             positiv:  cmp.w     #0,d3
  ' 6702                           beq.s     anf2b
  ' 8CC3                           divu.w    d3,d6
  ' 0246FFFF             anf2b:    andi.w    #$ffff,d6
  ' 61000068                       bsr       max
  ' 3803                           move.w    d3,d4
  ' 04440001                       sub.w     #1,d4
  ' 3211                 anf3:     move.w    (a1),d1
  ' 61000038                       bsr       fade
  ' B3CA                           cmpa.l    a2,a1
  ' 6C2C                           bge.s     weg
  ' 3211                           move.w    (a1),d1
  ' 6100002E                       bsr       fade
  ' B3CA                           cmpa.l    a2,a1
  ' 6C22                           bge.s     weg
  ' D446                           add.w     d6,d2
  ' 0242FFFF                       andi.w    #$FFFF,d2
  ' B3CA                           cmpa.l    a2,a1
  ' 6C18                           bge.s     weg
  ' 51CCFFE0                       dbra      d4,anf3
  ' 5488                           addq.l    #2,a0
  ' 51C8FF9E                       dbra      d0,anf2
  ' B3CA                           cmpa.l    a2,a1
  ' 6C0A                           bge.s     weg
  ' 3211                 anf4:     move.w    (a1),d1
  ' 6100000C                       bsr       fade
  ' B3CA                           cmpa.l    a2,a1
  ' 6DF6                           blt.s     anf4
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 02810000FFFF         fade:     andi.l    #$FFFF,d1
  ' BA7C0000                       cmp.w     #0,d5
  ' 6714                           beq.s     weiter
  ' 0801000F                       btst      #15,d1
  ' 670A                           beq.s     noneg
  ' 4641                           not.w     d1
  ' C2C2                           mulu.w    d2,d1
  ' 82C5                           divu.w    d5,d1
  ' 4641                           not.w     d1
  ' 6004                           bra.s     weiter
  ' C2C2                 noneg:    mulu.w    d2,d1
  ' 82C5                           divu.w    d5,d1
  ' 32C1                 weiter:   move.w    d1,(a1)+
  ' 4E75                           rts
  ' 3803                 max:      move.w    d3,d4
  ' D844                           add.w     d4,d4
  ' 04440002                       sub.w     #2,d4
  ' 3A3C0000                       move.w    #0,d5
  ' 2649                           movea.l   a1,a3
  ' 3219                 max2:     move.w    (a1)+,d1
  ' 0801000F                       btst      #15,d1
  ' 6702                           beq.s     noneg2
  ' 4641                           not.w     d1
  ' B245                 noneg2:   cmp.w     d5,d1
  ' 6F02                           ble.s     weiter2
  ' 3A01                           move.w    d1,d5
  ' 51CCFFEE             weiter2:  dbra      d4,max2
  ' 224B                           movea.l   a3,a1
  ' 4E75                           rts
  '
anfadmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H202F,&H0044
  DATA &H226F,&H0048
  DATA &H246F,&H004C
  DATA &H260A
  DATA &H2409
  DATA &H9682
  DATA &HE483
  DATA &H0283,&H3FFF,&HFFFF
  DATA &H86C0
  DATA &H0243,&HFFFF
  DATA &HB67C,&H0000
  DATA &H6604
  DATA &H363C,&H0001
  DATA &H0440,&H0001
  DATA &H3410
  DATA &H3C28,&H0002
  DATA &H9C42
  DATA &H0286,&H0000,&HFFFF
  DATA &H0806,&H000F
  DATA &H6712
  DATA &H4446
  DATA &HB67C,&H0000
  DATA &H6706
  DATA &H8CC3
  DATA &H0246,&HFFFF
  DATA &H4446
  DATA &H6008
  DATA &HB67C,&H0000
  DATA &H6702
  DATA &H8CC3
  DATA &H0246,&HFFFF
  DATA &H6100,&H0068
  DATA &H3803
  DATA &H0444,&H0001
  DATA &H3211
  DATA &H6100,&H0038
  DATA &HB3CA
  DATA &H6C2C
  DATA &H3211
  DATA &H6100,&H002E
  DATA &HB3CA
  DATA &H6C22
  DATA &HD446
  DATA &H0242,&HFFFF
  DATA &HB3CA
  DATA &H6C18
  DATA &H51CC,&HFFE0
  DATA &H5488
  DATA &H51C8,&HFF9E
  DATA &HB3CA
  DATA &H6C0A
  DATA &H3211
  DATA &H6100,&H000C
  DATA &HB3CA
  DATA &H6DF6
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H0281,&H0000,&HFFFF
  DATA &HBA7C,&H0000
  DATA &H6714
  DATA &H0801,&H000F
  DATA &H670A
  DATA &H4641
  DATA &HC2C2
  DATA &H82C5
  DATA &H4641
  DATA &H6004
  DATA &HC2C2
  DATA &H82C5
  DATA &H32C1
  DATA &H4E75
  DATA &H3803
  DATA &HD844
  DATA &H0444,&H0002
  DATA &H3A3C,&H0000
  DATA &H2649
  DATA &H3219
  DATA &H0801,&H000F
  DATA &H6702
  DATA &H4641
  DATA &HB245
  DATA &H6F02
  DATA &H3A01
  DATA &H51CC,&HFFEE
  DATA &H224B
  DATA &H4E75
  '
  RESTORE anfadmasch
  FOR g=0 TO 246 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf30(daten,werte,von,bis)
  .| Glob. Var.: sad%,sbd%,scd%,meml#,sdd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : fade_it-3,
  ' FADE IN&OUT
  '
  @busy_mouse
  sad%=daten
  sbd%=werte
  scd%=INT((meml+von)/4)*4
  sdd%=INT((meml+bis)/4)*4
  ~C:mdat2%(L:sad%,L:sbd%,L:scd%,L:sdd%)
RETURN
'
> PROCEDURE maschinit31
  .| Glob. Var.: mdat2%
  .| Aufruf in : fade_it-2,curve-1,hardproof2-1,
  LOCAL a,g
  ' Hîchstwert berechnen fÅr CURVE
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 7200                           moveq.l   #0,d1     ; zaehler pos
  ' 7800                           moveq.l   #0,d4     ; zaehler neg
  ' 7600                           moveq.l   #0,d3
  ' 3610                 anf2:     move.w    (a0),d3
  ' D1FC00000004                   adda.l    #4,a0
  ' 0803000F                       btst      #15,d3
  ' 670A                           beq.s     positiv
  ' 4443                 negativ:  neg.w     d3
  ' B644                           cmp.w     d4,d3
  ' 6F0A                           ble.s     weiter
  ' 3803                           move.w    d3,d4
  ' 6006                           bra.s     weiter
  ' B641                 positiv:  cmp.w     d1,d3
  ' 6F02                           ble.s     weiter
  ' 3203                           move.w    d3,d1
  ' B1C9                 weiter:   cmp.l     a1,a0
  ' 6DDE                           blt.s     anf2
  ' 02840000FFFF                   andi.l    #$ffff,d4
  ' 02810000FFFF         posgo:    andi.l    #$ffff,d1
  ' 45FA000E             ready:    lea.l     wert(pc),a2
  ' 3481                           move.w    d1,(a2)
  ' 35440002                       move.w    d4,2(a2)
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 00000000             wert:     dc.l 0
anfaemasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H7200
  DATA &H7800
  DATA &H7600
  DATA &H3610
  DATA &HD1FC,&H0000,&H0004
  DATA &H0803,&H000F
  DATA &H670A
  DATA &H4443
  DATA &HB644
  DATA &H6F0A
  DATA &H3803
  DATA &H6006
  DATA &HB641
  DATA &H6F02
  DATA &H3203
  DATA &HB1C9
  DATA &H6DDE
  DATA &H0284,&H0000,&HFFFF
  DATA &H0281,&H0000,&HFFFF
  DATA &H45FA,&H000E
  DATA &H3481
  DATA &H3544,&H0002
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H0000,&H0000
  '
  RESTORE anfaemasch
  FOR g=0 TO 82 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf31
  .| Glob. Var.: virtual#,sac%,i#,sbc%,stp#,vcs#,mdat2%,a#,am#
  .| Aufruf in : curve-2,hardproof2-2,
  ' MITTEL2/Hîchstwert berechnen
  '
  IF virtual=FALSE THEN
    sac%=i
    sbc%=i+stp
  ELSE
    sac%=i-vcs
    sbc%=(i+stp)-vcs
  ENDIF
  ~C:mdat2%(L:sac%,L:sbc%)
  a=DPEEK(mdat2%+80)
  am=DPEEK(mdat2%+82)
RETURN
'
> PROCEDURE maschruf31b(r1,r2,VAR d)
  .| Glob. Var.: sac%,meml#,sbc%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : fade_it-2,
  ' MITTEL2/Hîchstwert berechnen
  '
  @busy_mouse
  LOCAL cp,cm
  sac%=INT((meml+r1)/4)*4
  sbc%=INT((meml+r2)/4)*4
  ~C:mdat2%(L:sac%,L:sbc%)
  cp=DPEEK(mdat2%+80)
  cm=DPEEK(mdat2%+82)
  IF cp>cm THEN
    d=cp
  ELSE
    d=cm
  ENDIF
RETURN
'
> PROCEDURE maschinit32
  .| Glob. Var.: mdat2%
  .| Aufruf in : fade_it-4,springart-4,
  LOCAL a,g
  ' ZERONO
  ' Wert suchen,der nicht Null ist
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 202F0048                       move.l    72(sp),d0 ; Richtung
  ' 246F004C                       movea.l   76(sp),a2 ; RÅckgabewert
  ' B07C0000                       cmp.w     #0,d0
  ' 6618                           bne.s     back
  ' 2218                 vor:      move.l    (a0)+,d1
  ' 0C8100000000                   cmpi.l    #0,d1
  ' 6606                           bne.s     vorweg
  ' B1C9                           cmpa.l    a1,a0
  ' 6DF2                           blt.s     vor
  ' 601C                           bra.s     weg
  ' 2008                 vorweg:   move.l    a0,d0
  ' 5980                           subq.l    #4,d0
  ' 2480                           move.l    d0,(a2)
  ' 6014                           bra.s     weg
  ' 2221                 back:     move.l    -(a1),d1
  ' 0C8100000000                   cmpi.l    #0,d1
  ' 6606                           bne.s     backweg
  ' B3C8                           cmpa.l    a0,a1
  ' 6EF2                           bgt.s     back
  ' 6004                           bra.s     weg
  ' 2009                 backweg:  move.l    a1,d0
  ' 2480                           move.l    d0,(a2)
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfafmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H202F,&H0048
  DATA &H246F,&H004C
  DATA &HB07C,&H0000
  DATA &H6618
  DATA &H2218
  DATA &H0C81,&H0000,&H0000
  DATA &H6606
  DATA &HB1C9
  DATA &H6DF2
  DATA &H601C
  DATA &H2008
  DATA &H5980
  DATA &H2480
  DATA &H6014
  DATA &H2221
  DATA &H0C81,&H0000,&H0000
  DATA &H6606
  DATA &HB3C8
  DATA &H6EF2
  DATA &H6004
  DATA &H2009
  DATA &H2480
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfafmasch
  FOR g=0 TO 74 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf32(ca,cb,cc)
  .| Glob. Var.: cfa%,meml#,cfb%,cfc%,back%,wback%,cfd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : fade_it-4,springart-4,
  ' ZERONO
  '
  @busy_mouse
  cfa%=INT((meml+ca)/4)*4
  cfb%=INT((meml+cb)/4)*4
  cfc%=cc
  back%=-1
  LPOKE wback%,-1
  cfd%=wback%
  ~C:mdat2%(L:cfa%,L:cfb%,L:cfc%,L:cfd%)
  back%=LPEEK(wback%)
  IF back%<>-1 THEN
    back%=INT((back%-meml)/4)*4
  ENDIF
  IF back%<0 AND back%<>-1 THEN
    back%=-1
  ENDIF
RETURN
'
> PROCEDURE maschinit33
  .| Glob. Var.: mdat2%
  .| Aufruf in : springart-4,
  LOCAL a,g
  ' ZERO
  ' Wert suchen,der Null ist
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 202F0048                       move.l    72(sp),d0 ; Richtung
  ' 246F004C                       movea.l   76(sp),a2 ; RÅckgabewert
  ' B07C0000                       cmp.w     #0,d0
  ' 6616                           bne.s     back
  ' 2018                 vor:      move.l    (a0)+,d0
  ' B0BC00000000                   cmp.l     #0,d0
  ' 6706                           beq.s     vorweg
  ' B1C9                           cmp.l     a1,a0
  ' 6DF2                           blt.s     vor
  ' 6018                           bra.s     weg
  ' 5988                 vorweg:   subq.l    #4,a0
  ' 2488                           move.l    a0,(a2)
  ' 6012                           bra.s     weg
  ' 2021                 back:     move.l    -(a1),d0
  ' B0BC00000000                   cmp.l     #0,d0
  ' 6706                           beq.s     backweg
  ' B3C8                           cmp.l     a0,a1
  ' 6EF2                           bgt.s     back
  ' 6002                           bra.s     weg
  ' 2489                 backweg:  move.l    a1,(a2)
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfagmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H202F,&H0048
  DATA &H246F,&H004C
  DATA &HB07C,&H0000
  DATA &H6616
  DATA &H2018
  DATA &HB0BC,&H0000,&H0000
  DATA &H6706
  DATA &HB1C9
  DATA &H6DF2
  DATA &H6018
  DATA &H5988
  DATA &H2488
  DATA &H6012
  DATA &H2021
  DATA &HB0BC,&H0000,&H0000
  DATA &H6706
  DATA &HB3C8
  DATA &H6EF2
  DATA &H6002
  DATA &H2489
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfagmasch
  FOR g=0 TO 70 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf33(ca,cb,cc)
  .| Glob. Var.: cfa%,meml#,cfb%,cfc%,back%,wback%,cfd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : springart-4,
  ' ZERO
  '
  @busy_mouse
  cfa%=INT((meml+ca)/4)*4
  cfb%=INT((meml+cb)/4)*4
  cfc%=cc
  back%=-1
  LPOKE wback%,-1
  cfd%=wback%
  ~C:mdat2%(L:cfa%,L:cfb%,L:cfc%,L:cfd%)
  back%=LPEEK(wback%)
  IF back%<>-1 THEN
    back%=INT((back%-meml)/4)*4
  ENDIF
  IF back%<0 AND back%<>-1 THEN
    back%=-1
  ENDIF
RETURN
'
> PROCEDURE maschinit34
  .| Glob. Var.: mdat2%
  .| Aufruf in : negate-1,
  LOCAL a,g
  ' NEGATE
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 4458                 anf2:     neg.w     (a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DFA                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfahmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H4458
  DATA &HB1C9
  DATA &H6DFA
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfahmasch
  FOR g=0 TO 22 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf34(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : negate-3,
  ' NEGATE
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~C:mdat2%(L:saa%,L:sba%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit35
  .| Glob. Var.: mdat2%
  .| Aufruf in : lrchange-1,
  LOCAL a,g
  ' Left/Right-Change LRCHANGE
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 2010                 anf2:     move.l    (a0),d0
  ' 4840                           swap.w    d0
  ' 20C0                           move.l    d0,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DF6                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfaimasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H2010
  DATA &H4840
  DATA &H20C0
  DATA &HB1C9
  DATA &H6DF6
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfaimasch
  FOR g=0 TO 26 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf35(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : lrchange-3,
  ' Left/Right-Change LRCHANGE
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~C:mdat2%(L:saa%,L:sba%)
  cached=FALSE
RETURN
'
> PROCEDURE maschinit36
  .| Glob. Var.: mdat2%
  .| Aufruf in : sdsave-2,
  LOCAL a,g
  ' Save Mono  SDMONO
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; meml
  ' 226F0044                       movea.l   68(sp),a1 ; memh
  ' 246F0048                       movea.l   72(sp),a2 ; mdat%
  ' 266F004C                       movea.l   76(sp),a3 ; mdat%+len
  ' 2E2F0050                       move.l    80(sp),d7 ; handle
  ' 286F0054                       movea.l   84(sp),a4 ; Returnwert
  ' 2A4A                           move.l    a2,a5
  ' 3AD0                 anf:      move.w    (a0),(a5)+
  ' 5888                           addq.l    #4,a0
  ' B7CD                           cmpa.l    a5,a3
  ' 6608                           bne.s     weiter
  ' 61000022                       bsr       write
  ' 4A80                           tst.l     d0
  ' 6B14                           bmi.s     fehler
  ' B1C9                 weiter:   cmpa.l    a1,a0
  ' 6DEC                           blt.s     anf
  ' 61000016                       bsr       write
  ' 4A80                           tst.l     d0
  ' 6B08                           bmi.s     fehler
  ' 2888                 ende:     move.l    a0,(a4)
  ' 4CDF7FFF             ende2:    movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 28BC00000000         fehler:   move.l    #0,(a4)
  ' 60F2                           bra.s     ende2
  ' 48E701FC             write:    movem.l   d7/a0-a5,-(sp)
  ' 2F0A                           move.l    a2,-(sp)  ; Fwrite
  ' 200D                           move.l    a5,d0
  ' 908A                           sub.l     a2,d0
  ' 2F00                           move.l    d0,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C0040                       move.w    #64,-(sp)
  ' B0BC00000000                   cmp.l     #0,d0
  ' 6702                           beq.s     nowrite
  ' 4E41                           trap      #1
  ' 4FEF000C             nowrite:  lea.l     $c(sp),sp
  ' 4CDF3F80                       movem.l   (sp)+,d7/a0-a5
  ' 2A4A                           move.l    a2,a5
  ' 4E75                           rts
anfajmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H266F,&H004C
  DATA &H2E2F,&H0050
  DATA &H286F,&H0054
  DATA &H2A4A
  DATA &H3AD0
  DATA &H5888
  DATA &HB7CD
  DATA &H6608
  DATA &H6100,&H0022
  DATA &H4A80
  DATA &H6B14
  DATA &HB1C9
  DATA &H6DEC
  DATA &H6100,&H0016
  DATA &H4A80
  DATA &H6B08
  DATA &H2888
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H28BC,&H0000,&H0000
  DATA &H60F2
  DATA &H48E7,&H01FC
  DATA &H2F0A
  DATA &H200D
  DATA &H908A
  DATA &H2F00
  DATA &H3F07
  DATA &H3F3C,&H0040
  DATA &HB0BC,&H0000,&H0000
  DATA &H6702
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H3F80
  DATA &H2A4A
  DATA &H4E75
  '
  RESTORE anfajmasch
  FOR g=0 TO 112 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf36(l,h,l2,h2,hdl,VAR ret)
  .| Glob. Var.: saa%,sba%,sca%,sda%,sea%,mdat2%,mdat3%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : sdsave-2,
  ' Save Mono  SDMONO
  '
  @busy_mouse
  saa%=l
  sba%=h
  sca%=l2
  sda%=h2
  sea%=hdl
  ~C:mdat2%(L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:mdat3%)
  ret=LPEEK(mdat3%)
RETURN
'
> PROCEDURE maschinit37
  .| Glob. Var.: mdat2%
  .| Aufruf in : sdload-1,
  LOCAL a,g
  ' Load 2xMono  SDSTEREO
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; meml
  ' 226F0044                       movea.l   68(sp),a1 ; memh
  ' 246F0048                       movea.l   72(sp),a2 ; mdat%
  ' 266F004C                       movea.l   76(sp),a3 ; mdat%+len
  ' 2E2F0050                       move.l    80(sp),d7 ; handle
  ' 286F0054                       movea.l   84(sp),a4 ; Returnwert
  ' 6100002A                       bsr       read
  ' 4A80                           tst.l     d0
  ' 6B1C                           bmi.s     fehler
  ' 309D                 anf:      move.w    (a5)+,(a0)
  ' 5888                           addq.l    #4,a0
  ' BDCD                           cmpa.l    a5,a6
  ' 6608                           bne.s     weiter
  ' 6100001A                       bsr       read
  ' 4A80                           tst.l     d0
  ' 6B0C                           bmi.s     fehler
  ' B1C9                 weiter:   cmpa.l    a1,a0
  ' 6DEC                           blt.s     anf
  ' 2888                 ende:     move.l    a0,(a4)
  ' 4CDF7FFF             ende2:    movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 28BC00000000         fehler:   move.l    #0,(a4)
  ' 60F2                           bra.s     ende2
  ' 2009                 read:     move.l    a1,d0
  ' 9088                           sub.l     a0,d0
  ' 220B                           move.l    a3,d1
  ' 928A                           sub.l     a2,d1
  ' B081                           cmp.l     d1,d0
  ' 6D02                           blt.s     read2
  ' 2001                           move.l    d1,d0
  ' 2C40                 read2:    move.l    d0,a6
  ' DDCA                           add.l     a2,a6
  ' 48E701FE                       movem.l   d7/a0-a6,-(sp)
  ' 2F0A                           move.l    a2,-(sp)  ; Fread
  ' 2F00                           move.l    d0,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' B0BC00000000                   cmp.l     #0,d0
  ' 6702                           beq.s     noread
  ' 4E41                           trap      #1
  ' 4FEF000C             noread:   lea.l     $c(sp),sp
  ' 4CDF7F80                       movem.l   (sp)+,d7/a0-a6
  ' 2A4A                           move.l    a2,a5
  ' 4E75                           rts
anfakmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H246F,&H0048
  DATA &H266F,&H004C
  DATA &H2E2F,&H0050
  DATA &H286F,&H0054
  DATA &H6100,&H002A
  DATA &H4A80
  DATA &H6B1C
  DATA &H309D
  DATA &H5888
  DATA &HBDCD
  DATA &H6608
  DATA &H6100,&H001A
  DATA &H4A80
  DATA &H6B0C
  DATA &HB1C9
  DATA &H6DEC
  DATA &H2888
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H28BC,&H0000,&H0000
  DATA &H60F2
  DATA &H2009
  DATA &H9088
  DATA &H220B
  DATA &H928A
  DATA &HB081
  DATA &H6D02
  DATA &H2001
  DATA &H2C40
  DATA &HDDCA
  DATA &H48E7,&H01FE
  DATA &H2F0A
  DATA &H2F00
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &HB0BC,&H0000,&H0000
  DATA &H6702
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H7F80
  DATA &H2A4A
  DATA &H4E75
  '
  RESTORE anfakmasch
  FOR g=0 TO 124 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf37(l,h,l2,h2,hdl,VAR ret)
  .| Glob. Var.: saa%,sba%,sca%,sda%,sea%,mdat2%,mdat3%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : sdload-2,
  ' Load 2xMono  SDSTEREO
  '
  @busy_mouse
  saa%=l
  sba%=h
  sca%=l2
  sda%=h2
  sea%=hdl
  ~C:mdat2%(L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:mdat3%)
  ret=LPEEK(mdat3%)
RETURN
'
> PROCEDURE maschinit38
  .| Glob. Var.: mdat2%
  .| Aufruf in : sdsave-2,ldhlp-1,
  LOCAL a,g
  ' WAVALON
  '
  ' 48E7FFFE             anf:      movem.l   d0-d7/a0-a6,-(sp)
  ' 206F0040                       movea.l   64(sp),a0 ; anf
  ' 226F0044                       movea.l   68(sp),a1 ; ende
  ' 3010                 anf2:     move.w    (a0),d0
  ' 04408000                       sub.w     #$8000,d0
  ' 30C0                           move.w    d0,(a0)+
  ' B1C9                           cmp.l     a1,a0
  ' 6DF4                           blt.s     anf2
  ' 4CDF7FFF             weg:      movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
anfalmasch:
  DATA &H48E7,&HFFFE
  DATA &H206F,&H0040
  DATA &H226F,&H0044
  DATA &H3010
  DATA &H0440,&H8000
  DATA &H30C0
  DATA &HB1C9
  DATA &H6DF4
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  '
  RESTORE anfalmasch
  FOR g=0 TO 28 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschruf38(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : sdsave-2,ldhlp-1,
  ' WAVALON
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~C:mdat2%(L:saa%,L:sba%)
  cached=FALSE
RETURN
' ------------------------------------------------------------------------------
' ------------------------FLYDIALS--------------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE key
  .| Glob. Var.: key&,edit_obj&,cont&,rsc_adr%,next_obj&,idx&,obj&,mrkhandle2#
  .|     v1#,v2#,v3#,ascii|,scan|,a#,shift&,title&,shcut#,nob#,nr#,keytab%,a&
  .|     a$,tree&,evnt&,mb&,mx&,my&
  .| Felder    : rsc_adr%()
  .| Ruft auf  : form_keybd,rsc_shortcut
  .| Aufruf in : rsc_do-1,
  LOCAL bs
  ' Mîchten Sie erweiterte Tastaturkommandos? Dann entREMen Sie
  ' diese Zeile und ersetzen die Prozedur durch:
  '  IF key& AND edit_obj&<>0     ! vorher so....
  IF (key& AND edit_obj&<>0) OR (key& AND 255)=13    ! jetzt so....
    cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  ENDIF
  '  cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  '
  obj&=0
  ~WIND_GET(MENU(4),10,mrkhandle2,v1,v2,v3)
  '  ~WIND_GET(mrkhandle,10,mrkhandle2,v1,v2,v3)
  '
  ascii|=BYTE(key&)                                  ! ASCII-Code
  scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
  a=@rsc_shortcut(27,scan|,shift&,title&)
  shcut=FALSE
  IF a<>0 THEN
    nob=a
    obj&=a
    shcut=TRUE
  ENDIF
  '
  rsc_adr%=rsc_adr%(nr)
  IF ascii|=0                                        ! Kein ASCII-Code...
    '
    IF scan|=97 OR scan|=98                          ! UNDO/HELP...
      ascii|=ADD(SUB(scan|,97),14)
      obj&=0
      '
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
      '
      IF BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE IF scan|>=59 AND scan|<=68                  ! F-Tasten...
      ascii|=SUB(scan|,58)
      obj&=0
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
      IF SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE                                             ! ALT+Buchstabe...
      '
      IF scan|>=120 AND scan|<=129                   ! Zahlen...
        SUB scan|,118
        keytab%={XBIOS(16,L:-1,L:-1,L:-1)}           ! ...ohne Shift
      ELSE                                           ! Alles andere...
        keytab%={ADD(XBIOS(16,L:-1,L:-1,L:-1),4)}    ! ...mit Shift
      ENDIF
      '
      ascii|=BYTE{ADD(keytab%,scan|)}                ! ASCII-Code holen
      IF ascii|<>0                                      ! Tastaturbedienbar...
        CLR a&,obj&
        '
        DO WHILE NOT BTST(OB_FLAGS(rsc_adr%,obj&),5) ! Nicht LASTOBJ
          INC obj&
          '
          scan|=BYTE(SHR(OB_TYPE(rsc_adr%,obj&),8))
          IF scan|=26 OR scan|=28                    ! Ein Button/String...
            a$=@rsc_text$(tree&,obj&)                ! ...Text
            '
            a&=INSTR(a$,"[")
            IF a&                                    ! Tastaturbedienbar...
              a&=ASC(MID$(a$,SUCC(a&),1))
              a&=(BCLR(a&,5)=ascii|) OR (a&>=48 AND a&<=57 AND a&=ascii|)
            ENDIF
            '                                        ! '[' vor Zeichen
          ENDIF
          '
        LOOP UNTIL a&                                ! ...gefunden
        '
        IF a&                                        ! Objekt gefunden...
          key&=0                                     ! ...keine Eingabe mehr
          '                                          ! +SHIFT Circle-Butt?
          IF BTST(shift&,1) AND BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5) AND SHR(OB_TYPE(rsc_adr%,obj&+2),8)=27
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simulieren
            ~OBJC_OFFSET(rsc_adr%,obj&+2,mx&,my&)
            '                                        ! Ist es ein Popup...
          ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5)
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simul.
            ~OBJC_OFFSET(rsc_adr%,obj&,mx&,my&)
          ELSE                                       ! ...Button bedienen
            cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
          ENDIF
        ENDIF
        '
      ENDIF
    ENDIF
    '
  ENDIF
  '
  IF next_obj&<>0 AND edit_obj&<>next_obj&
    ~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,3,idx&)  ! ...Eingabe
  ENDIF
  '  obj=obj&
  '
RETURN
> PROCEDURE message
  .| Glob. Var.: handle&,a&,rsc_trees&,accwindopen#,tree&,rsc_window&
  .|     next_obj&,edit_obj&,idx&,nr#,peak&,peakint#,mx#,my#,mz#,rsc_adr%,n#
  .|     butdirect#,butnr#,donr#,h#,a#,smpedit&,mnr#,cs#,ce#
  .| Felder    : rsc_handle%(),rsc_adr%()
  .| Ruft auf  : markhlp,rsc_message,mouse,button,rsc_redraw_obj,curve
  .|     markprod3
  .| Aufruf in : rsc_do-1,helptxt-2,
  @markhlp
  '  PRINT MENU(1);",";MENU(5);",";MENU(6);",";MENU(7);",";MENU(8)
  handle&=MENU(4)                                    ! ...Fenster-Handle
  '
  FOR a&=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
    EXIT IF handle&=rsc_handle%(a&)
  NEXT a&
  '
  IF MENU(1)=&H4724 THEN
    accwindopen=TRUE
  ENDIF
  IF MENU(1)=41 OR (MENU(1)=22 AND tree&=a&)         ! AC_CLOSE/Closer...
    MUL rsc_window&,-(MENU(1)=22)
    '
    next_obj&=9999                                   ! ...Exit-Code
    '
    GOTO rsc_dox_ende                                ! ...rsc_do verlassen
    '
  ELSE IF a&>-1 AND NOT (MENU(1)=21 AND a&<>tree&)   ! Ein RSC-Fenster....
    rsc_message(a&,MENU(1),MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    '
  ELSE IF MENU(1)=40 OR MENU(1)=21                   ! AC_OPEN/Anderes Fenster toppen...
    '
    IF a&<>-1 THEN
      IF handle&=rsc_handle%(a&) THEN
        tree&=a&
        IF nr=peak& THEN
          @write_int(0)
        ENDIF
        nr=tree&
        IF nr=peak& THEN
          peakint=FALSE
        ENDIF
        @mouse(mx,my,mz)
        rsc_adr%=rsc_adr%(tree&)
        n=OBJC_FIND(rsc_adr%,0,100,mx,my)
        IF n<>0 AND n<>-1 THEN
          @button
          butdirect=TRUE
          butnr=donr
        ENDIF
        @rsc_redraw_obj(nr,0)
      ENDIF
    ENDIF
    rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    '
  ELSE IF MENU(1)<>21 AND MENU(1)<>22                ! nicht toppen/schlieûen...
  ELSE                                               ! Nichts zu machen...
    ~BIOS(3,2,7)
  ENDIF
  IF MENU(1)=20 THEN
    h=MENU(4)                                    ! ...Fenster-Handle
    FOR a=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
      EXIT IF h=rsc_handle%(a)
    NEXT a
    IF a<>-1 THEN
      '      @rsc_message(a,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
      '      @rsc_message(a,20,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
      IF a=peak& THEN
        peakint=FALSE
      ENDIF
      IF a=smpedit& AND a=nr THEN
        mnr=nr
        nr=a
        @curve(cs,ce)
        @markprod3
        nr=mnr
      ELSE
      ENDIF
      '      @rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    ENDIF
  ENDIF
  IF MENU(1)=21 THEN
    IF nr=smpedit& THEN
      @curve(cs,ce)
      @markprod3
    ENDIF
    IF nr=smp16& THEN
      @makehz
      @sethertz
    ENDIF
  ENDIF
rsc_dox_ende:
RETURN
> PROCEDURE button
  .| Glob. Var.: mrkhandle2#,mx&,my&,rsc_adr%,nr#,next_obj&,fsel&,fssldbut&
  .|     fsslide&,fsmax#,fsz#,slflg#,arranger&,arrslbut&,arrslide&,slmax#,pbz#
  .|     trakker&,trakxbut&,trakslid&,tmax#,trakkz#,trakybut&,trkvslid&,tymax#
  .|     trakkyz#,virtual&,vslbut&,vslider&,hbg#,hbz#,vhbldstrt#,smplen#,zu%
  .|     edit_obj&,idx&,vblkstrt&,a$,slr#,hbgm#,mt#,vslc#,lslide#,smpedit&
  .|     zoombutt&,mrz#,zoomp#,mrcs#,cs#,mrce#,ce#,zomslide&,zmax#,mrzoom#
  .|     scrlslde&,scrolbut&,scmax#,scrollp#,mrscroll#,scteil#,scrolm#,vmem#
  .|     cached#,scstep#,peak&,cont&,tree&,evnt&,obj&,ob_tail&,rsc_popup&,b$
  .|     popup&,rate&,digana#,mover&,input&,source&,dsp&,rate2&,smp16&
  .|     makerate&,arrmake&,make&,mb&,editfade&,peakmute&,arrm1&,arrm2&,arrm3&
  .|     arrm4&,arrclip&,leave#,v#,v2#,v3#,v4#
  .| Felder    : rsc_adr%(),rscx&(),rscy&(),rscw&(),rsch&()
  .| Ruft auf  : sliding,fsnrset,setbutton,slideupdate,arrnrset,timeline
  .|     blkart,slidelr,textbutt,zoomcalc,scrollinit,setslide,restaura
  .|     rsc_movedial,rsc_text,rsc_popup,rsc_set_cursor,edhandler2
  .| Aufruf in : message-1,rsc_do-2,
  LOCAL popok,dif
  mrkhandle2=WIND_FIND(mx&,my&)
  '  IF mrkhandle=mrkhandle2 THEN
  '  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
  '  IF v<>0 AND kenn=mrkhandle2 THEN
  rsc_adr%=rsc_adr%(nr)
  next_obj&=OBJC_FIND(rsc_adr%,0,100,mx&,my&)
  '
  '                                                  ! String vor Popup...
  IF next_obj&>0
    IF BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND SHR(OB_TYPE(rsc_adr%,next_obj&),8)=28 AND BTST(OB_STATE(rsc_adr%,SUCC(next_obj&)),5)
      ' (TOUCHEXIT, STRING, SUCC: SHADOWED)
      INC next_obj&
    ENDIF
  ENDIF
  '
  IF next_obj&=-1                                    ! Neben die Box...
    SOUND 1,15,10,4,10
    SOUND 0,0,0,0,0
    next_obj&=0
  ELSE
    '
    IF nr=fsel& AND next_obj&=fssldbut& THEN
      @sliding(fsslide&,fssldbut&,fsmax,5,fsz,slflg)
      IF slflg=TRUE THEN
        @fsnrset
      ENDIF
      @setbutton(next_obj&,0)
      next_obj&=0
    ENDIF
    '
    '
    IF nr=fsel& AND next_obj&=fsslide& THEN
      @slideupdate(fsslide&,fssldbut&,fsmax,mx&,my&,1,5,fsz,slflg)
      IF slflg=TRUE THEN
        @fsnrset
      ENDIF
      next_obj&=0
    ENDIF
    '
    IF nr=arranger& AND next_obj&=arrslbut& THEN
      @sliding(arrslide&,arrslbut&,slmax,5,pbz,slflg)
      IF slflg=TRUE THEN
        @arrnrset
      ENDIF
      @setbutton(next_obj&,0)
      next_obj&=0
    ENDIF
    '
    '
    IF nr=arranger& AND next_obj&=arrslide& THEN
      @slideupdate(arrslide&,arrslbut&,slmax,mx&,my&,1,5,pbz,slflg)
      IF slflg=TRUE THEN
        @arrnrset
      ENDIF
      next_obj&=0
    ENDIF
    '
    '
    IF nr=trakker& AND next_obj&=trakxbut& THEN
      @sliding(trakslid&,trakxbut&,tmax,5,trakkz,slflg)
      IF slflg=TRUE THEN
        @timeline
      ENDIF
      @setbutton(next_obj&,0)
      next_obj&=0
    ENDIF
    '
    '
    IF nr=trakker& AND next_obj&=trakslid& THEN
      @slideupdate(trakslid&,trakxbut&,tmax,mx&,my&,1,5,trakkz,slflg)
      IF slflg=TRUE THEN
        @timeline
      ENDIF
      next_obj&=0
    ENDIF
    '
    '
    IF nr=trakker& AND next_obj&=trakybut& THEN
      @sliding(trkvslid&,trakybut&,tymax,5,trakkyz,slflg)
      IF slflg=TRUE THEN
        @timeline
      ENDIF
      @setbutton(next_obj&,0)
      next_obj&=0
    ENDIF
    '
    '
    IF nr=trakker& AND next_obj&=trkvslid& THEN
      @slideupdate(trkvslid&,trakybut&,tymax,mx&,my&,1,5,trakkyz,slflg)
      IF slflg=TRUE THEN
        @timeline
      ENDIF
      next_obj&=0
    ENDIF
    '
    '
    IF nr=virtual& AND next_obj&=vslbut& THEN
      @sliding2(vslider&,vslbut&,lslide,hbreit,hbz,slflg)
      @setbutton(vslbut&,0)
      IF slflg=TRUE THEN
        vhbldstrt=INT((smplen/lslide*hbz)/4)*4
        ~OBJC_EDIT(zu%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
        edit_obj&=vblkstrt&
        @blkart
      ENDIF
      idx&=LEN(a$)
      @setbutton(next_obj&,0)
      next_obj&=0
    ENDIF
    '
    '
    IF nr=virtual& AND next_obj&=vslider& THEN
      hbgm=(smplen/mt)       ! Einteilungsanzahl
      @slideupdate2(vslider&,vslbut&,lslide,mx&,my&,hbreit,hbz,slflg)
      IF slflg=TRUE THEN
        vhbldstrt=INT((smplen/lslide*hbz)/4)*4
        ~OBJC_EDIT(zu%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
        edit_obj&=vblkstrt&
        @blkart
      ENDIF
      idx&=LEN(a$)
      next_obj&=0
    ENDIF
    '
    '
    IF nr=smpedit& AND next_obj&=zoombutt& THEN
      mrz=zoomp
      mrcs=cs
      mrce=ce
      @sliding(zomslide&,zoombutt&,zmax,16,zoomp,slflg)
      IF slflg=TRUE THEN
        IF mrz<>zoomp THEN
          a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
          @textbutt(zomslide&,zoombutt&,a$,1)
          @zoomcalc
          mrzoom=zoomp
          IF mrcs<>cs OR mrce<>ce THEN
            @scrollinit
            @setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
            mrscroll=scrollp
          ENDIF
        ENDIF
      ENDIF
      @setbutton(next_obj&,0)
      next_obj&=0
    ENDIF
    '
    '
    IF nr=smpedit& AND next_obj&=zomslide& THEN
      mrcs=cs
      mrce=ce
      mrz=zoomp
      @slideupdate(zomslide&,zoombutt&,zmax,mx&,my&,1,16,zoomp,slflg)
      IF slflg=TRUE THEN
        IF mrz<>zoomp THEN
          a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
          @textbutt(zomslide&,zoombutt&,a$,1)
          @zoomcalc
          mrzoom=zoomp
          IF mrcs<>cs OR mrce<>ce THEN
            @scrollinit
            @setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
            mrscroll=scrollp
          ENDIF
        ENDIF
      ENDIF
      next_obj&=0
    ENDIF
    '
    '
    IF nr=smpedit& AND next_obj&=scrolbut& THEN
      mrcs=cs
      mrce=ce
      mrz=scrollp
      @sliding2(scrlslde&,scrolbut&,scmax,scstep,scrollp,slflg)
      IF slflg=TRUE THEN
        IF scrollp<>mrz THEN
          dif=ce-cs
          cs=scrollp*scteil
          ce=dif+scrollp*scteil
          IF ce>vmem THEN
            cs=vmem-dif
            ce=vmem
          ENDIF
          cs=INT(cs/4)*4
          ce=INT(ce/4)*4
          cached=FALSE
          IF mrcs<>cs OR mrce<>ce THEN
            @setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
            mrscroll=scrollp
          ENDIF
          @restaura
        ENDIF
      ENDIF
      @setbutton(next_obj&,0)
      next_obj&=0
    ENDIF
    '
    '
    IF nr=smpedit& AND next_obj&=scrlslde& THEN
      mrcs=cs
      mrce=ce
      mrz=scrollp
      @slideupdate2(scrlslde&,scrolbut&,scmax,mx&,my&,scstep,scrollp,slflg)
      IF slflg=TRUE THEN
        dif=ce-cs
        cs=scrollp*scteil
        ce=dif+scrollp*scteil
        IF ce>vmem THEN
          cs=vmem-dif
          ce=vmem
        ENDIF
        cs=INT(cs/4)*4
        ce=INT(ce/4)*4
        cached=FALSE
        @setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
        mrscroll=scrollp
        @restaura
      ENDIF
      next_obj&=0
    ENDIF
    '
    '
    IF nr<>peak& THEN
      cont&=FORM_BUTTON(rsc_adr%,next_obj&,1,next_obj&)
    ENDIF
    ' ------------------------------------------------ Flydial-Ecke
    IF BTST(OB_STATE(rsc_adr%,next_obj&),1)          ! (CROSSED)
      rsc_movedial(tree&,edit_obj&,idx&)             ! ...Dialog verschieben
      '
      next_obj&=0                                    ! Damit der Cursor..
      cont&=1                                        ! ..bleibt wo er ist
      ' ---------------------------------------------- Circle-Button...
    ELSE IF SHR(OB_TYPE(rsc_adr%,next_obj&),8)=27 AND BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),5) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),3))
      ' (G_BOXCHAR, PRED: SHADOWED /NOT DISABLED)
      next_obj&=PRED(next_obj&)                      ! Objektnr. Button
      a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
      evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
      '
      obj&=1
      FOR ob_tail&=1 TO PRED(evnt&)
        obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
      NEXT ob_tail&
      '
      evnt&=SUCC(obj&)
      b$=@rsc_text$(rsc_popup&,evnt&)
      DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
        INC evnt&                                    ! Defaulteintrag
      LOOP
      '
      REPEAT
        INC evnt&                                    ! NÑchster Eintrag...
        IF evnt&>OB_TAIL(rsc_adr%(rsc_popup&),obj&)  ! ...gibt es nicht
          evnt&=SUCC(obj&)                           ! ...dann wieder 1.
        ENDIF
        '                                            ! bis nicht DISABLED
      UNTIL NOT BTST(OB_STATE(rsc_adr%(rsc_popup&),evnt&),3)
      '                                              ! Button Ñndern...
      rsc_text(tree&,next_obj&,@rsc_text$(rsc_popup&,evnt&))
      ~OBJC_DRAW(rsc_adr%,next_obj&,1,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
      popup&=SUB(evnt&,obj&)
      '          REPEAT
      '          ~GRAF_MKSTATE(v,v2,v3,v4)
      '        UNTIL v3=0
      ' ---------------------------------------------- Popup-Menue...
    ELSE IF BTST(OB_STATE(rsc_adr%,next_obj&),5) AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND (NOT BTST(OB_STATE(rsc_adr%,next_obj&),3))
      popok=FALSE
      IF (((next_obj&=rate& AND digana=TRUE) OR next_obj&=mover&) AND nr=smpedit&) THEN
        popok=TRUE
      ENDIF
      IF ((next_obj&=protect& OR next_obj&=mode& OR next_obj&=emphasis& OR next_obj&=input& OR next_obj&=source& OR next_obj&=dsp& OR (next_obj&=rate2& AND digana=TRUE)) AND nr=smp16&) THEN
        popok=TRUE
      ENDIF
      IF next_obj&=makerate& AND nr=arrmake& THEN
        popok=TRUE
      ENDIF
      IF next_obj&=setform& AND nr=setup& THEN
        popok=TRUE
      ENDIF
      IF popok=TRUE THEN
        ' (SHADOWED, TOUCHEXIT, NOT DISABLED)
        evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
        obj&=1
        FOR ob_tail&=1 TO PRED(evnt&)
          obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
        NEXT ob_tail&
        ob_tail&=OB_TAIL(rsc_adr%(rsc_popup&),obj&)
        a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
        evnt&=SUCC(obj&)
        DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
          INC evnt&                                    ! Ausrichtung ermitteln
        LOOP UNTIL evnt&>ob_tail&
        '
        IF evnt&<=ob_tail&                             ! Defaulteintrag...
          popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,SUB(evnt&,SUCC(obj&)))
        ELSE                                           ! Sonst ohne...
          IF tree&=smpedit& OR tree&=make& THEN
            popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,1)
          ENDIF
        ENDIF
        IF popup&=0                                    ! Abbruch...
          cont&=1                                      ! ...weiter geht's
          next_obj&=0                                  ! ...Cursor 'festhalten'
        ENDIF
      ENDIF
      ' ---------------------------------------------- Cursor positionieren
      ' Mîchten Sie den Cursor mit der Maus zeichengenau positionieren?
      ' Dann entREMen Sie diese Zeilen und laden diese Prozedur nach:
    ELSE IF BTST(OB_FLAGS(rsc_adr%,next_obj&),3)
      @rsc_set_cursor(rsc_adr%,mx&,my&,edit_obj&,next_obj&,idx&)
    ENDIF
    '
  ENDIF
  IF cont&=0 OR (next_obj&<>0 AND next_obj&<>edit_obj&)
    ~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
  ENDIF
  ' ENDIF
  ' ENDIF
  IF nr=smpedit& AND mb&<>0 THEN
    @edhandler2
  ENDIF
  IF nr=editfade& OR (nr=peak& AND next_obj&<>peakmute&) OR ((next_obj&=arrm1& OR next_obj&=arrm2& OR next_obj&=arrm3& OR next_obj&=arrm4& OR next_obj&=arrclip&) AND nr=arranger&) THEN
    leave=TRUE
  ELSE
    leave=FALSE
  ENDIF
  REPEAT
    ~GRAF_MKSTATE(v,v2,v3,v4)        ! NEU !!!
  UNTIL v3=0 OR leave=TRUE
  IF next_obj&=0 AND nr<>editfade& THEN
    next_obj&=-1
  ENDIF
RETURN
> PROCEDURE rsc_init
  .| Glob. Var.: ap_id&,rsc_aes&,rsc_mtsk!,rsc_alert&,wchar&,hchar&,rsc_vh&
  .|     planes&,deskx&,desky&,deskw&,deskh&,rsc_flyd%,rsc_bitblt%,rsc_obspec%
  .|     rsc_cookie%
  .| Felder    : rsc_adr%()
  .| Aufruf in : HAUPTPROGRAMM-1,
  LOCAL a&
  '
  ' Initialisiert die von den RSC-Routinen benîtigten Variablen...
  '
  ap_id&=APPL_INIT()                         ! Applikations-ID
  '
  rsc_aes&=INT{{ADD(GB,4)}}                  ! AES-Version
  rsc_mtsk!=INT{ADD({ADD(GB,4)},2)}<>1       ! Multitasking?
  rsc_alert&=-1                              ! Noch keine fliegenden Alerts
  '
  CONTRL(6)=GRAF_HANDLE(wchar&,hchar&,a&,a&) ! AES-Handle, Zeichenbreite/Hîhe
  rsc_vh&=V_OPNVWK(1)                        ! Virt.Workst. fÅr Flydials îffnen
  IF rsc_vh&=0
    rsc_vh&=V~H                              ! ...Fehler, dann eben die alte
  ENDIF
  CONTRL(6)=V~H
  '
  INTIN(0)=1
  VDISYS 102,1,0
  planes&=INTOUT(4)                          ! Bitplanes
  '
  ~WIND_GET(0,7,deskx&,desky&,deskw&,deskh&) ! Hintergrundfenster
  ' ------------------------------------------------------ Inline vorbereiten
  INLINE rsc_flyd%,2834
  '
  rsc_bitblt%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,16)})      ! BITBLT-Routine
  rsc_obspec%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,18)})      ! OB_SPEC-Routine...
  rsc_cookie%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,20)})      ! COOKIE-Routine...
  '
  {ADD(rsc_flyd%,22)}=ADD(GB,24)                         ! VDI-Parameterblock
  INT{ADD(rsc_flyd%,26)}=rsc_vh&                         ! Virt. Workstation
  INT{ADD(rsc_flyd%,28)}=wchar&                          ! Zeichenzellenbreite
  INT{ADD(rsc_flyd%,30)}=hchar&                          ! Zeichenzellenhîhe
  ' ------------------------------------------------------
  ' Berechnet den Speicherbedarf einer Bitmap-Grafik...
  DEFFN getsize(w&,h&)=SHL(SHR(ADD(MUL(MUL(SHR(ADD(w&,15),3),h&),planes&),255),8),8)
  '
  ' GegenstÅck zur Prozedur rsc_text: Universelles Objekt-Text auslesen...
  DEFFN rsc_text$(tree&,obj&)=CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}
  '
RETURN
> PROCEDURE rsc_exit
  .| Glob. Var.: rsc_vh&,popup_back%,rsc_userblk%
  .| Aufruf in : goodbye-1,
  '
  CONTRL(6)=rsc_vh&
  VDISYS 38,0,0                              ! vqt_attributes
  IF ABS(INTOUT(0))<>1                       ! Anderer AES-Zeichensatz (MTOS)...
    ~VST_UNLOAD_FONTS(0)                     ! ...freigeben
  ENDIF
  '
  IF rsc_vh&<>V~H                            ! Flydial-Workstation freigeben...
    ~V_CLSVWK()
  ENDIF
  '
  ' Die folgenden Zeilen sind nur im Interpreter relevant und kînnen im
  ' Compilat wegfallen. Tip: Mit dem ERGO!pro-PrÑprozessor ausblenden.
  '
  ~RSRC_FREE()                               ! Resource entfernen
  '
  IF popup_back%
    ~MFREE(popup_back%)                      ! Popup-Hintergrund freigeben
  ENDIF
  '
  IF rsc_userblk%
    ~MFREE(rsc_userblk%)                     ! Userblks freigeben
  ENDIF
  '
RETURN
> FUNCTION rsc_laden(file$,trees&,popup&,menu&,alert&)
$F%
.| Glob. Var.: popup_back%,rsc_trees&,rsc_popup&,rsc_menu&,rsc_alert&
.|     rsc_aes&,rsc_vh&,dreidim#,rsc_flyd%
.| Felder    : rsc_adr%(),rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&()
.| Ruft auf  : xrsrc_load,xrsrc_gaddr,rsc_walk_tree
.| Aufruf in : HAUPTPROGRAMM-2,
LOCAL tree&,obj&,font_h&,font_id&,color3d&,a%
popup_back%=0
'
' LÑdt die Resource und initialisiert einige globale Variablen...
' ------------------------------------------------------ RSC laden
' Wollen Sie das RSC-File direkt im Programmcode 'aufbewahren'?
' Dann entREMen Sie diese Zeilen und laden Sie die Funktion
' 'rsc_conv' aus EXTENDED.LST hinzu...
' INLINE rsc%,3160
' IF @rsrc_conv(rsc%)=0
IF @xrsrc_load(file$)=0
  ~FORM_ALERT(1,"[3][ | Fehler beim Laden | der RSC-Datei! | ][Abbruch]")
  RETURN FALSE
ENDIF
' ------------------------------------------------------
DIM rsc_adr%(trees&),rsc_handle%(trees&)
DIM rscx&(trees&),rscy&(trees&),rscw&(trees&),rsch&(trees&)
'
rsc_trees&=trees&                                      ! Anzahl ObjektbÑume-1
rsc_popup&=popup&                                      ! Popup-Baum
rsc_menu&=menu&                                        ! Dropdown-Baum
rsc_alert&=alert&                                      ! Alert-Baum
' ------------------------------------------------------
' Die folgenden Zeilen sind nur nîtig, wenn das Resource-File ALERT-
' oder FREE-BÑume enthÑlt. NÑheres in der Doku.
' alerts&=trees&-SUCC(rsc_alert&)                        ! Alerts & Free Strings...
' FOR tree&=0 TO alerts&
' ~RSRC_GADDR(5,tree&,a%)
' rsc_adr%(rsc_alert&+SUCC(tree&))=a%
' NEXT tree&
' trees&=rsc_alert&
' ------------------------------------------------------ Adressen ermitteln
FOR tree&=0 TO trees&
  '
  ~@xrsrc_gaddr(0,tree&,a%)  ! Kompatibel zu den XRSRC-Routinen
  rsc_adr%(tree&)=a%
  IF tree&<>menu&
    ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
  ENDIF
  '
NEXT tree&
' ------------------------------------------------------ Grîûtes Popup
IF popup&>-1
  obj&=1
  WHILE obj&>0
    popup_back%=MAX(popup_back%,@getsize(ADD(OB_W(rsc_adr%(popup&),obj&),21),OB_H(rsc_adr%(popup&),obj&)))
    obj&=OB_NEXT(rsc_adr%(popup&),obj&)
  WEND
  popup_back%=MALLOC(popup_back%)                      ! Hintergrundpuffer...
  IF popup_back%=0
    RETURN FALSE                                       ! ...nicht geklappt
  ENDIF
ENDIF
' ------------------------------------------------------ Anderer Zeichensatz
IF rsc_aes&>=&H400 OR APPL_FIND("?API")=0              ! Hat APPL_GETINFO()...
  '
  GCONTRL(0)=130
  GCONTRL(1)=1
  GCONTRL(2)=5
  GCONTRL(3)=0
  GCONTRL(4)=0
  GINTIN(0)=0
  '
  GEMSYS                                               ! APPL_GETINFO()
  '
  IF GINTOUT(0)=1                                      ! Hat geklappt...
    font_h&=GINTOUT(1)                                 ! AES-Font Hîhe
    font_id&=GINTOUT(2)                                ! AES-Font ID
    '
    IF ABS(font_id&)<>1 AND GDOS?<>0                   ! Anderer AES-Font...
      V~H=rsc_vh&
      ~VST_LOAD_FONTS(0)                               ! ...Fonts laden
      DEFTEXT ,,,,font_id&
      DEFTEXT ,,,font_h&                               ! ...und einstellen
      V~H=-1
    ENDIF
  ENDIF
ENDIF
' ------------------------------------------------------ 3D-Darstellung
IF rsc_aes&>=&H340                                     ! Ab AES 3.40...
  GCONTRL(0)=48
  GCONTRL(1)=4
  GCONTRL(2)=3
  GCONTRL(3)=0
  GCONTRL(4)=0
  '
  GINTIN(0)=0                                          ! Inquire
  GINTIN(1)=5                                          ! Background
  '
  GEMSYS                                               ! OBJC_SYSVAR()
  '
  IF GINTOUT(0)>0                                      ! Hat geklappt...
    color3d&=GINTOUT(1)                                ! ...3D-Farbe
  ENDIF
  IF dreidim=0 THEN
    color3d&=0
  ENDIF
ENDIF
' ------------------------------------------------------
INT{ADD(rsc_flyd%,32)}=color3d&>0                      ! 3D-Darstellung an/aus
INT{ADD(rsc_flyd%,34)}=color3d&                        ! 3D-Farbe
' ------------------------------------------------------
IF @rsc_walk_tree(trees&)
  RETURN TRUE                                          ! alles ok
ENDIF
'
RETURN FALSE                                           ! Error!
ENDFUNC
> FUNCTION rsc_walk_tree(trees&)
$F%
.| Glob. Var.: rsc_userblk%,hchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_instal_userdef
.| Aufruf in : rsc_laden-1,
LOCAL a&,b&,userblk&,tree&,obj&,a%
'
' RSC-Baum durchgehen und userdefs installieren...
'
' ------------------------------------------------------ Userdefs ermitteln
FOR tree&=0 TO trees&
'
obj&=-1
'
REPEAT
  '
  INC obj&
  '
  a&=SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)           ! Es ist ein userdef...
  ADD userblk&,-AND(a&>=17,a&<=22)
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! ...bis LAST_OBJ
'
NEXT tree&
'
rsc_userblk%=MALLOC(SHL(SUCC(userblk&),3))             ! Userblks(+1) anfordern (*8)
IF rsc_userblk%=0                                      ! Zu wenig Speicher...
RETURN FALSE                                         ! ...Error!
ENDIF
a%=rsc_userblk%                                        ! Merken
' ------------------------------------------------------ ObjektbÑume modifiz.
FOR tree&=0 TO trees&
'
obj&=-1
REPEAT
  '
  INC obj&
  '
  SELECT SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)       ! OB_TYPE
    ' ------------------------------------------------ Flydial-Ecke...
  CASE 17
    rsc_instal_userdef(tree&,obj&,5)
    ' ------------------------------------------------ Button/String...
  CASE 18
    '
    a&=OB_FLAGS(rsc_adr%(tree&),obj&)                ! OB_FLAGS
    b&=BYTE(OB_TYPE(rsc_adr%(tree&),obj&))           ! Alter OB_TYPE
    '
    IF BTST(a&,4)                                    ! Radiobutton...
      rsc_instal_userdef(tree&,obj&,1)
      '                                              ! BUTTON, nicht EXIT
    ELSE IF b&=26 AND (NOT BTST(a&,2))               ! Checkbutton...
      rsc_instal_userdef(tree&,obj&,2)
      '
    ELSE                                             ! Normale EXIT-Buttons...
      '
      IF b&<>28                                      ! Kein STRING...
        a&=SUCC(-BTST(a&,1)-BTST(a&,2)-BTST(a&,6))
        IF a&>1 !EXIT       DEFAULT    TOUCHEXIT
          OB_X(rsc_adr%(tree&),obj&)=SUB(OB_X(rsc_adr%(tree&),obj&),a&)
          OB_Y(rsc_adr%(tree&),obj&)=SUB(OB_Y(rsc_adr%(tree&),obj&),a&)
          OB_W(rsc_adr%(tree&),obj&)=ADD(OB_W(rsc_adr%(tree&),obj&),ADD(a&,a&))
          OB_H(rsc_adr%(tree&),obj&)=SUCC(ADD(OB_H(rsc_adr%(tree&),obj&),ADD(a&,a&)))
        ENDIF                                        ! ...fÅr Redraw grîûer
      ENDIF
      '
      rsc_instal_userdef(tree&,obj&,6)
      '
    ENDIF
    ' ------------------------------------------------ Unterstr. Text...
  CASE 19
    rsc_instal_userdef(tree&,obj&,4)
    OB_FLAGS(rsc_adr%(tree&),obj&)=BSET(OB_FLAGS(rsc_adr%(tree&),obj&),13)
    ' ...OB_FLAG 13 setzen, wird in 'rsc_draw' benîtigt
    ' ------------------------------------------------ Rahmen...
  CASE 20
    rsc_instal_userdef(tree&,obj&,3)
    ' ------------------------------------------------ Niceline...
  CASE 21
    rsc_instal_userdef(tree&,obj&,8)
    ' ------------------------------------------------ Circlebutton...
  CASE 22
    IF hchar&=8 OR hchar&=16                         ! ...nur wenn mîglich
      rsc_instal_userdef(tree&,obj&,7)               ! ...als Bitmap
    ELSE
      OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(27,8),BYTE(OB_TYPE(rsc_adr%(tree&),obj&)))
    ENDIF                                            ! ...sonst Pfeil lassen
    '
  ENDSELECT
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! Bis LAST_OB gesetzt
'
NEXT tree&
'
{rsc_userblk%}=0                                       ! FÅr Nullstrings
rsc_userblk%=a%                                        ! FÅr MFREE() am Ende
'
RETURN TRUE                                            ! Alles OK
ENDFUNC
> PROCEDURE rsc_instal_userdef(tree&,obj&,nr&)
.| Glob. Var.: rsc_userblk%,rsc_flyd%
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_walk_tree-8,
'
' Userdef-Objekt installieren...
'
' nr& bezeichnet eine der folgenden Ausgaberoutinen:
' 1  Radiobutton, rund
' 2  Check-Button
' 3  Rahmen
' 4  Unterstr. Text
' 5  Flydial
' 6  Button
' 7  Circlebutton
' 8  Niceline
'
{rsc_userblk%}=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,SHL(PRED(nr&),1))})
{ADD(rsc_userblk%,4)}=OB_SPEC(rsc_adr%(tree&),obj&)
'
OB_SPEC(rsc_adr%(tree&),obj&)=rsc_userblk%             ! userdef und alter Typ
OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(BYTE(OB_TYPE(rsc_adr%(tree&),obj&)),8),24)
'                                                      ! im oberen Byte
ADD rsc_userblk%,8
'
RETURN
> PROCEDURE rsc_draw(tree&,flag%)
.| Glob. Var.: hchar&,deskx&,desky&,deskw&,deskh&,rsc_window&,rsc_obspec%
.|     rsc_userblk%,mrkhandle#,rsc_list$
.| Felder    : rsc_adr%(),rscx&(),rscy&(),rscw&(),rsch&(),rsc_handle%()
.| Ruft auf  : rsc_menu_ienable,rsc_message,rsc_bitblt
.| Aufruf in : rsc_alert-1,main-1,normalize-1,fade-1,smptime-1,movefrag-1
.|     smpsave-1,blklfrag-1,newfsel-4,sampleinf-2,resample-1,arranger-1
.|     trakker-1,arrsmpr-1,arrdelay-1,arrmname-1,virtual-1,abackup-1
.|     makeaback-1,smpedit-1,blkfunc-1,time_edit-1,make-2,info-1,setupdat-1
.|     conspace-1,memtovirt2-1,midi-1,loopwahl-1,dspwahl-1,peak-1,
LOCAL fly&,title&,obj&,x&,y&,w&,h&,rx&,ry&,rb&,rh&,handle&,a%,rsc_adr%
'
' Stellt einen Dialog auf dem Bildschirm dar...
'
' tree&   : Index des Dialogbaumes
' flag%   : Bitbelegung
'           Bit 0 -> Fensterdialog
'           Bit 1 -> Schlieûfeld
'           Bit 2 -> Bei Fensterdialogen: Sofort zeichnen
'
rsc_adr%=rsc_adr%(tree&)
' --------------------------------------------------- Titel & Flugecke suchen
DO WHILE NOT (fly&>0 AND title&>0)
INC obj&
IF BTST(OB_STATE(rsc_adr%,obj&),1)                ! Flugecke...
  fly&=obj&
ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),13)          ! Dialogtitel...
  title&=obj&
ENDIF
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
' --------------------------------------------------- Als Fenster-Dialog
IF BTST(flag%,0)
x&=SUCC(rscx&(tree&))
y&=ADD(ADD(rscy&(tree&),SHL(hchar&,1)),5)
w&=SUB(rscw&(tree&),2)
h&=SUB(SUB(rsch&(tree&),SHL(hchar&,1)),5)
'
IF fly&                                           ! Flugecke hidden...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                 ! Rahmen: 1 Pixel auûen...
OB_SPEC(rsc_adr%,0)=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
'
rx&=OR(&X1001,SHL(-BTST(flag%,1),1))              ! Ggf. Schlieûfeld
handle&=WIND_CREATE(rx&,deskx&,desky&,deskw&,deskh&)
'    ~WIND_SET(handle&,10,handle&,0,0,0)  ! Fenstertitel setzen
IF handle&>0                                      ! Fenster vorhanden...
  '
  ~WIND_UPDATE(1)                                 ! BEG_UPDATE
  '
  INC rsc_window&                                 ! Anz. offene Fenster+1
  rsc_menu_ienable(FALSE)                         ! MenÅtitel disablen
  '
  IF title&                                       ! Dialogtitel existiert...
    a%=C:rsc_obspec%(L:rsc_adr%,title&)           ! ...Adresse des Titels
  ELSE
    a%=rsc_userblk%                               ! ...sonst Nullstring
  ENDIF
  ~WIND_SET(handle&,2,INT(SWAP(a%)),INT(a%),0,0)  ! Fenstertitel setzen
  mrkhandle=handle&
  '
  ~WIND_CALC(0,&X1001,x&,y&,w&,h&,rx&,ry&,rb&,rh&)! WC_BORDER
  ~WIND_OPEN(handle&,rx&,ry&,rb&,rh&)
  '
  rsc_handle%(tree&)=handle&
  '
  IF BTST(flag%,2)                                ! Sofort zeichnen...
    rsc_message(tree&,20,x&,y&,w&,h&,0,0)         ! ...redrawen
    REPEAT
      obj&=EVNT_MULTI(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1000)
      IF BTST(obj&,4) AND (MENU(4)<>rsc_handle%(tree&))
        '           message_auswerten(MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
      ENDIF
    UNTIL BTST(obj&,5)                            ! ...bis Timer-Event
  ENDIF
  '
  ~WIND_UPDATE(0)                                 ! END_UPDATE
  '
ENDIF
ENDIF
' --------------------------------------------------- Als normaler Dialog
IF rsc_handle%(tree&)=0
a%=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
OB_SPEC(rsc_adr%,0)=OR(a%,SHL(2,16))              ! Rahmen: 2 Pixel innen
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'                                                 ! Auûerhalb des Screens...
IF rscy&(tree&)<desky& OR ADD(rscx&(tree&),PRED(w&))>ADD(deskx&,PRED(deskw&)) OR ADD(rscy&(tree&),PRED(h&))>ADD(desky&,PRED(deskh&))
  ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                             ! ...wieder in die Mitte
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
'
rsc_list$=rsc_list$+MKI$(tree&)                   ! Dialog in die Liste aufnehmen
'
rsc_handle%(tree&)=MALLOC(@getsize(w&,h&))
IF rsc_handle%(tree&)                             ! Hintergrund retten...
  rsc_bitblt(0,0,0,rsc_handle%(tree&),w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
  '
ENDIF
'
IF fly&>0 AND rsc_handle%(tree&)>0               ! Flugecke sichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BCLR(OB_FLAGS(rsc_adr%,fly&),7)
ELSE IF fly&                                     ! unsichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                ! Zeichnen...
~OBJC_DRAW(rsc_adr%,0,7,rscx&(tree&),rscy&(tree&),w&,h&)
ENDIF
'  mrkhandle=WIND_FIND(x&,y&)
RETURN
> PROCEDURE rsc_menu_ienable(stat!)
.| Glob. Var.: rsc_menu&,rsc_window&,rsc_aes&,rsc_mtsk!,ap_id&
.| Felder    : rsc_adr%(),rscw&()
.| Aufruf in : rsc_draw-1,rsc_back-1,main-1,windows-1,fade-1,arranger-1
.|     trakker-1,abackup-1,makeaback-1,smpedit-3,blkfunc-1,info-1
.|     loopwahl-1,dspwahl-1,
LOCAL obj&,title&,rsc_adr%
'
' Disabled/enabled alle MenÅ-Titel und den 'About...'-MenÅ-Eintrag...
'                                ! Gibt es ein MenÅ..
IF rsc_menu&>-1 AND rsc_window&=1! und ist es das 1. Fenster?
'
rsc_adr%=rsc_adr%(rsc_menu&)
'                              ! Objektbreite verÑndern...
IF stat!                       ! Enablen...
  OB_W(rsc_adr%,2)=rscw&(rsc_menu&)
ELSE                           ! Disablen...
  rscw&(rsc_menu&)=OB_W(rsc_adr%,2)
  OB_W(rsc_adr%,2)=OB_W(rsc_adr%,3)
ENDIF
'
obj&=3                         ! Ersten MenÅtitel Åberspringen
'
REPEAT
  INC obj&
  '                            ! G_TITEL...
  IF BYTE(OB_TYPE(rsc_adr%,obj&))=32
    '
    ~MENU_IENABLE(rsc_adr%,obj&,stat!)
    '
    title&=obj&                ! Wird fÅr 'About...' gebraucht
  ENDIF
  '
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
'                              ! 'About...' dis/enablen
~MENU_IENABLE(rsc_adr%,ADD(title&,3),stat!)
'                              ! Unter MultiTOS...
IF (rsc_aes&>=&H400) AND rsc_mtsk!
  IF ap_id&=MENU_BAR(rsc_adr%,-1)
    ~MENU_BAR(rsc_adr%,1)      ! ...Menu nur neu anzeigen, wenn erlaubt
  ENDIF
ELSE                           ! Unter SingleTOS...
  ~MENU_BAR(rsc_adr%,1)        ! ...Menu immer neu anzeigen
ENDIF
'
ENDIF
'
RETURN
> FUNCTION rsc_do(tree&,next_obj&,VAR popup&)
$F%
.| Glob. Var.: obj#,donr#,nr#,edit_obj&,idx&,tim&,mx&,my&,mb&,shift&,c#
.|     shcut#,winh#,smp16&,peak&,editfade&,smpedit&,digana#,xd#,xm#,ce#,cs#
.|     stay1#,stay2#,show#,showdat#,tedart#,hz#,showbdat#,shw$,showxy&
.|     butdirect#,othernr#
.| Felder    : rsc_handle%(),rsc_adr%()
.| Ruft auf  : message,drop,button,key,drop2,edhandler,peakread,fadehandler
.|     maketime,edhandler3,textfeld
.| Aufruf in : rsc_alert-1,windows-1,normalize-1,fade-1,smptime-1
.|     movefrag-1,smpsave-1,blklfrag-1,newfsel-1,sampleinf-1,resample-1
.|     arrsmpr-1,arrdelay-1,arrmname-1,virtual-1,abackup-1,time_edit-1
.|     make-1,setupdat-1,conspace-1,midi-1,
LOCAL a&,handle&,a$
LOCAL cont&,ob_tail&,obj&,flags&,rsc_adr%,keytab%
LOCAL ascii|,scan|,evnt&,mc&,key&
'
' Dialog auswerten...
'
obj=0
donr=nr
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(1)                                      ! ...BEG_UPDATE
~WIND_UPDATE(3)                                      ! ...BEG_MCTRL
flags&=&X11                                          ! ...BUTTON/KEYBD-Events
'
ELSE                                                   ! Fenster-Dialog...
flags&=&X110011                                      ! ...zus. MESSAGE-Events
ENDIF
'  IF nr=arranger& AND intplay=TRUE THEN
'  flags&=&X10011                                          ! keine Timer-Events wegen Interrupts
' ENDIF
'
rsc_adr%=rsc_adr%(tree&)
cont&=TRUE
' ------------------------------------------------------ Editierbares Objekt
DO WHILE (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3)) OR BTST(OB_STATE(rsc_adr%,next_obj&),3)
INC next_obj&
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,next_obj&),5)
IF BTST(OB_FLAGS(rsc_adr%,next_obj&),5) AND (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3))
next_obj&=0
ENDIF
' ------------------------------------------------------
'
IF cont&<>0 AND (next_obj&<>0 AND edit_obj&<>next_obj&)             ! Ggf. Cursor setzen...
edit_obj&=next_obj&                                ! ...Exit-Code zurÅck
next_obj&=0                                        ! ...'rsc_do' verlassen
~OBJC_EDIT(rsc_adr%,edit_obj&,27,idx&,1,idx&)       ! ...Cursor ein
ENDIF
'
next_obj&=0
tim&=20   ! EVENT-TIMER in msec
REPEAT
evnt&=EVNT_MULTI(flags&,2,1,1,0,0,0,0,0,0,0,0,0,0,0,tim&,mx&,my&,mb&,shift&,key&,c)
IF donr=nr THEN
IF BTST(evnt&,4) THEN
  @message
  @drop
ENDIF
IF BTST(evnt&,1) THEN
  @button
ENDIF
IF BTST(evnt&,0) THEN
  @key
  IF obj&<>0 AND mb&=1 THEN
    @button
  ENDIF
  IF obj&<>0 AND shcut=TRUE AND mb&=0 THEN
    @drop2
  ENDIF
ENDIF
IF BTST(evnt&,5) AND BTST(winh,smp16&)=TRUE AND nr=smp16& THEN
  @edhandler
ENDIF
IF BTST(winh,arranger&)=TRUE AND nr=arranger& AND intplay=TRUE THEN
  @edhandler4
ENDIF
IF BTST(evnt&,5) AND nr=peak& THEN
  @peakread
ENDIF
IF BTST(evnt&,5) AND BTST(evnt&,4)=FALSE AND nr=editfade& THEN
  @fadehandler
ENDIF
@maketime
IF BTST(evnt&,5) AND nr=smpedit& THEN
  IF digana=FALSE THEN
    @edhandler3
  ENDIF
  IF mx&>=xd AND mx&<=(xm+xd) AND xm>0 AND ce>cs AND my&>=stay1 AND my&<=stay2 AND show=TRUE THEN
    showdat=(INT((INT((ce-cs)/4))/xm*(mx&-xd)))+INT(cs/4)
    IF virtual=FALSE THEN
      showert=meml+showdat*4
      show$=HEX$(DPEEK(showert))+" "+HEX$(DPEEK(showert+2))+CHR$(0)
    ENDIF
    IF tedart=0 THEN
      showdat=showdat/hz
    ENDIF
    IF showbdat<>showdat THEN
      showbdat=showdat
      shw$=STR$(showdat)+CHR$(0)
      IF LEN(shw$)>9 THEN
        shw$=LEFT$(shw$,9)
      ENDIF
      @textfeld(freemem&,show$,1)
      @textfeld(showxy&,shw$,1)
    ENDIF
  ENDIF
ENDIF
ENDIF
IF mc&=2 AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6)      ! Doppelklick auf
next_obj&=WORD(BSET(next_obj&,15))                   ! TOUCHEXIT...
ENDIF
UNTIL (next_obj&>0 OR donr<>nr)
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(0)                                      ! END_UPDATE
~WIND_UPDATE(2)                                      ! END_MCTRL
ENDIF
IF donr<>nr AND butdirect=FALSE THEN
next_obj&=0
ENDIF
othernr=FALSE
rsc_do_ende:
RETURN next_obj&
ENDFUNC
> FUNCTION rsc_popup(a!,tree&,button&,popup&,def&)
$F%
.| Glob. Var.: rsc_popup&,hchar&,popup_back%,rsc_vh&,wchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_text
.| Aufruf in : button-2,
LOCAL x&,y&,b&,h&,m!
LOCAL evnt&,mx&,my&,mb&,shift&,key&,mc&,ascii|,scan|
LOCAL obj&,old_obj&,first&,anz&
LOCAL rsc&,rsc_adr%
'
' Popup-MenÅ darstellen und auswerten...
'
' a!       : TRUE: Button verÑndern, FALSE: Nur Popup
' tree&    : Index des Dialogbaumes
' button&  : Objektnr. des betÑtigten Buttons
' popup&   : Index des Popups
' def&     : Default-Eintrag (1-x)
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~WIND_UPDATE(3)                                   ! BEG_MCTRL
'
rsc_adr%=rsc_adr%(rsc_popup&)
'
first&=OB_HEAD(rsc_adr%,popup&)                   ! erster Eintrag
anz&=SUB(OB_TAIL(rsc_adr%,popup&),first&)         ! Anzahl EintrÑge-1
' ------------------------------------------------- Popup positionieren
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)
OB_X(rsc_adr%,0)=SUB(x&,OB_X(rsc_adr%,popup&))
OB_Y(rsc_adr%,0)=MAX(ADD(hchar&,4),MIN(SUB(WORK_OUT(1),4)-OB_H(rsc_adr%,popup&),SUB(y&,MUL(def&,hchar&))))-OB_Y(rsc_adr%,popup&)
'
x&=ADD(OB_X(rsc_adr%,0),PRED(OB_X(rsc_adr%,popup&)))
y&=ADD(OB_Y(rsc_adr%,0),PRED(OB_Y(rsc_adr%,popup&)))
b&=ADD(OB_W(rsc_adr%,popup&),4)
h&=ADD(OB_H(rsc_adr%,popup&),4)
' -------------------------------------------------
'
rsc_bitblt(0,0,0,popup_back%,b&,h&,x&,y&,b&,h&,0,0)
'
~OBJC_DRAW(rsc_adr%,0,7,x&,y&,b&,h&)              ! Popup zeichnen
'
IF a!                                             ! Button verÑndern...
'
~GRAF_MOUSE(256,0)                              ! Hidem
V~H=rsc_vh&                                     ! ...Default-Eintrag mit...
GRAPHMODE 2
'
INTIN(0)=8                                      ! ...HÑkchen versehen
PTSIN(0)=ADD(x&,DIV(wchar&,2))
PTSIN(1)=y&-DIV(hchar&,6)+MUL(SUCC(def&),hchar&)
VDISYS 8,1,1                                    ! ...v_gtext()
'
GRAPHMODE 1
V~H=-1
~GRAF_MOUSE(257,0)                              ! Showm
'
ENDIF
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)      ! Objekt unter der Maus...
'
IF obj&<=0                                        ! Daneben...
obj&=ADD(first&,def&)                           ! ...Default-Eintrag nehmen
ENDIF
'
old_obj&=obj&
IF (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))   ! Nicht disabled...
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
ENDIF                                             ! ...selektieren
'
~EVNT_TIMER(200)
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
IF mb&=1
m!=TRUE
evnt&=4
ENDIF
'
' --------------------------------------------------
DO
'
IF NOT m!
evnt&=EVNT_MULTI(&X111,1,1,1,1,mx&,my&,1,1,0,0,0,0,0,0,0,mx&,my&,mb&,shift&,key&,mc&)
ELSE
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
ENDIF
'
IF BTST(evnt&,0)                                 ! Tastaturereignis...
ascii|=BYTE(key&)
scan|=BYTE(SHR(key&,8))
'                                              ! Noch kein sel. Eintrag...
IF NOT (obj&>=first& AND obj&<=ADD(first&,anz&))
obj&=first&
'
ELSE IF scan|=80                               ! ...Cursor runter
INC obj&
IF obj&>ADD(first&,anz&)
  obj&=first&
ENDIF
'
ELSE IF scan|=72                               ! ...Cursor runter
DEC obj&
IF obj&<first&
  obj&=ADD(first&,anz&)
ENDIF
'
ENDIF
'
ENDIF
'
IF BTST(evnt&,2)                                 ! Mausereignis...
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)
ENDIF
'                                                ! Alten Eintrag deselekt...
IF obj&<>old_obj&
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),1)
ENDIF
'                                                ! Im MenÅ und nicht disabled...
IF (obj&>=first& AND obj&<=ADD(first&,anz&)) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
'                                              ! ...neuen selektieren
old_obj&=obj&
rsc&=SUB(obj&,first&)                          ! RÅckgabe
ENDIF
'
LOOP UNTIL BTST(evnt&,1) OR (mb&<>1 AND m!) OR ascii|=13 OR ascii|=27 OR scan|=97
' --------------------------------------------------
rsc_bitblt(popup_back%,b&,h&,0,0,0,0,0,b&,h&,x&,y&)! Hintergrund restaurieren
'
IF rsc&=SUB(obj&,first&) AND scan|<>97 AND ascii|<>27 ! Eintrag ausgewÑhlt...
'
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,obj&),0),0)
'
IF a!                                            ! Button verÑndern...
'                                              ! Neuen Text eintragen:
rsc_text(tree&,button&,@rsc_text$(rsc_popup&,obj&))
'
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)    ! Button zeichnen
~OBJC_DRAW(rsc_adr%(tree&),button&,1,x&,y&,OB_W(rsc_adr%(tree&),button&),OB_H(rsc_adr%(tree&),button&))
'
ENDIF
'
ELSE                                               ! Daneben => Abbruch...
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),0)
'
rsc&=-1                                          ! ...Abbruch markieren
'
ENDIF
'
REPEAT
~GRAF_MKSTATE(mx&,my&,mb&,shift&)                ! Mausknopf 'entprellen'
UNTIL mb&=0
'
~WIND_UPDATE(2)                                    ! END_MCTRL
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN SUCC(rsc&)
ENDFUNC
> PROCEDURE rsc_message(tree&,message&,x&,y&,w&,h&,edit_obj&,idx&)
.| Glob. Var.: wchar&,hchar&
.| Felder    : rsc_handle%(),rsc_adr%(),rscx&(),rscy&()
.| Ruft auf  : rsc_cursor
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,message-2,rsc_draw-1
.|     rsc_back-1,rsc_redraw_obj-1,main-1,fade-1,arranger-1,trakker-1
.|     blkfunc-1,info-1,loopwahl-1,peak-1,
LOCAL a|,ax&,ay&,ab&,ah&,handle&,obj&,rsc_adr%,a%,a$
'
' Wertet ein innerhalb des 'rsc_do' eingetroffenes Message-Ereignis aus...
'
IF nr<>smpinf& AND nr<>fsel& THEN
handle&=rsc_handle%(tree&)                         ! Fensterhandle des Dialogs
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
SELECT message&
' --------------------------------------------------------------------------
CASE 20,21                                         ! WM_REDRAW/WM_TOPPED
IF message&=20                                   ! WM_REDRAW...
~GRAF_MOUSE(256,0)                           ! Hidem
~WIND_GET(handle&,11,ax&,ay&,ab&,ah&)          ! 1. Rechteck
'
REPEAT
  '
  IF RC_INTERSECT(x&,y&,w&,h&,ax&,ay&,ab&,ah&) ! ...redrawen
    ~OBJC_DRAW(rsc_adr%(tree&),0,7,ax&,ay&,ab&,ah&)
  ENDIF
  '
  ~WIND_GET(handle&,12,ax&,ay&,ab&,ah&)        ! NÑchstes Rechteck...
UNTIL ab&=0 AND ah&=0                          ! ...kein Redraw mehr nîtig
'
~GRAF_MOUSE(257,0)                           ! Showm
'
ELSE                                             ! WM_TOPPED...
~WIND_SET(handle&,10,0,0,0,0)                  ! ...toppen
ENDIF
'
~WIND_GET(0,10,ax&,ay&,ay&,ay&)                  ! Oberstes Fenster...
IF ax&=handle& AND edit_obj&>0                   ! Ist das unsrige...
' ---------------------------------------------- Cursor-Setz-Orgie...
rsc_adr%=rsc_adr%(tree&)
'
obj&=edit_obj&                                 ! Parent ermitteln...
'
REPEAT
  obj&=OB_NEXT(rsc_adr%,obj&)
UNTIL obj&<edit_obj&
'
~OBJC_OFFSET(rsc_adr%,edit_obj&,ax&,ay&)       ! Koordinaten des Objekts
'
a$=CHAR{{ADD(OB_SPEC(rsc_adr%,edit_obj&),4)}}  ! Maske: "Eingabe:______"
ah&=1
WHILE MID$(a$,ah&,1)<>"_"                      ! LÑnge des Vortextes...
  INC ah&
WEND                                           ! ...ermitteln
'
ADD ax&,MUL(wchar&,ADD(PRED(ah&),idx&))        ! Cursor-Position im Pixeln
ah&=ADD(OB_H(rsc_adr%,edit_obj&),6)            ! Cursor ist grîûer hchar&
'                                              ! Cursor lîschen...
~OBJC_DRAW(rsc_adr%,obj&,7,ax&,SUB(ay&,3),wchar&,ah&)
rsc_cursor(rsc_adr%,edit_obj&,idx&)            ! ...und setzen
'
ENDIF
' --------------------------------------------------------------------------
CASE 28                                            ! WM_MOVED
~WIND_CALC(1,&X1001,x&,y&,w&,h&,ax&,ay&,ab&,ah&)
'
rscx&(tree&)=PRED(ax&)
rscy&(tree&)=SUB(SUB(ay&,5),MUL(hchar&,2))
OB_X(rsc_adr%(tree&),0)=ADD(rscx&(tree&),3)
OB_Y(rsc_adr%(tree&),0)=ADD(rscy&(tree&),3)
'
~WIND_SET(handle&,5,x&,y&,w&,h&)
'
ENDSELECT
'
~WIND_UPDATE(0)                                    ! END_UPDATE
'
ENDIF
RETURN
> PROCEDURE rsc_back(tree&)
.| Glob. Var.: rsc_window&,nr#,smp16&,blkfunc&,peak&,loop&,editfade&
.|     arranger&,info&,trakker&,smpedit&,edit_obj&,idx&,rsc_list$
.| Felder    : rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&(),rsc_adr%()
.| Ruft auf  : rsc_menu_ienable,rsc_message,rsc_bitblt
.| Aufruf in : rsc_alert-1,goodbye-1,normalize-1,blklfrag-1,newfsel-4
.|     restaura2-1,restaura2b-1,sampleinf-1,resample-1,make-1,conspace-1
.|     memtovirt2-1,
'
' Entfernt den Dialog vom Bildschirm...
'
' ---------------------------------------------------- Als Fenster-Dialog
IF rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
rsc_menu_ienable(TRUE)                             ! ...MenÅ wieder wÑhlbar
'
IF rsc_window&                                     ! Fenster existiert...
'
~WIND_CLOSE(rsc_handle%(tree&))
~WIND_DELETE(rsc_handle%(tree&))                 ! ...schlieûen & abmelden
'
DEC rsc_window&                                  ! Anz. offene Fenster-1
'
ELSE                                               ! Sonst Redraw auslîsen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF
' -------------------------------------------------- Als normaler Dialog
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
IF rsc_window&>0 THEN
IF nr=smp16& OR nr=blkfunc& OR nr=peak& OR nr=loop& OR nr=editfade& OR nr=arranger& OR nr=info& OR nr=trakker& THEN
nr=smpedit&
tree&=smpedit&
rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
ENDIF
ELSE
rsc_list$=LEFT$(rsc_list$,SUB(LEN(rsc_list$),2))   ! Dialog aus der Liste entf.
'
IF rsc_handle%(tree&)                              ! Hintergrund gerettet...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~MFREE(rsc_handle%(tree&))
'
ELSE                                               ! Desktop redrawen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
IF rsc_list$<>""                                 ! Noch ein Dialog drunter...
~OBJC_DRAW(rsc_adr%(CVI(RIGHT$(rsc_list$,2))),0,7,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                            ! ...diesen auch redrawen
ENDIF
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
ENDIF
RETURN
> PROCEDURE rsc_text(tree&,obj&,a$)
.| Aufruf in : button-1,rsc_popup-1,rsc_alert-2,
'
' Universelle Objekt-Text Belegung...
'
'  CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}=a$
RETURN
> PROCEDURE rsc_bitblt(a%,w&,h&,b%,rb&,rh&,ax&,ay&,ab&,ah&,gx&,gy&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : rsc_draw-1,rsc_popup-2,rsc_back-1,rsc_movedial-3
.|     rsc_flipping-23,
'
' Universeller Raster-Kopierer (benutzt vro_cpyfm oder vrt_cpyfm)...
'
IF ab&>0 AND ah&>0                 ! Breite und Hîhe vorhanden...
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:a%,w&,h&,0,planes&,L:b%,rb&,rh&,0,planes&,ax&,ay&,ab&,ah&,gx&,gy&,1)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_cursor(rsc_adr%,edit_obj&,idx&)
.| Aufruf in : rsc_message-1,rsc_movedial-1,
LOCAL a|,a%
'
' Zeichengenaue Positionierung des Cursors...
'
a%=ADD({OB_SPEC(rsc_adr%,edit_obj&)},idx&)
'
a|=BYTE{a%}                                        ! Zeichen merken
BYTE{a%}=0                                         ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)       ! Cursor setzen
BYTE{a%}=a|                                        ! ...Zeichen restaurieren
'
RETURN
> PROCEDURE busy_mouse
.| Glob. Var.: m_adr%,m_busy%
.| Aufruf in : HAUPTPROGRAMM-1,maschruf-1,maschruf2-1,maschinit2b-1
.|     maschruf3-1,maschruf3b-1,maschruf5-1,maschinit5b-1,maschruf5c-1
.|     maschruf6-1,maschruf8-1,maschruf8b-1,maschruf9-1,maschruf10-1
.|     maschruf11-1,maschruf12-1,maschruf13-1,maschruf16-1,maschruf17-1
.|     maschruf18b-1,maschruf18c-1,maschruf28-1,maschruf29-1,maschruf30-1
.|     maschruf31b-1,maschruf32-1,maschruf33-1,maschruf34-1,maschruf35-1
.|     maschruf36-1,maschruf37-1,maschruf38-1,fade_it-7,smpkhlp-1,smpihlp-5
.|     smpcut-3,virtmove-7,virtcopy-2,virtins-4,putpix-3,edhandler2-7
.|     smpsave-2,ldhlp-1,sampleinf-1,trakload-1,arrinsert-1,arrdelete-1
.|     hardfs-1,hardproof2-2,rettmem-1,arrload-1,arrsave-1,make-3,trash-2
.|     setload-1,setsave-1,fseldef-1,conspace-1,coninsert-4,mono-3,negate-3
.|     lrchange-3,springart-1,
' Eine Busy-Maus in der Form eines kleines Balles...
'
IF m_adr%=ADD(m_busy%,518)
m_adr%=m_busy%
'
ELSE
ADD m_adr%,74
ENDIF
'
~GRAF_MOUSE(255,m_adr%)
'
RETURN
> FUNCTION rsc_get(x&,y&,w&,h&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : fseldef-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%
'
a%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
a%=MALLOC(a%)                      ! Speicher anfordern
'
IF a%                              ! Hat geklappt...
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
'                                ! Kopieren...
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION rsc_get2(x&,y&,w&,h&,md%)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-3,dragging2-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%
a%=md%                           ! Speicher anfordern
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> PROCEDURE rsc_put(a%,x&,y&,m&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&
'
IF a%                              ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,0,0,w&,h&,x&,y&,m&)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
' ------------------------------------------------------------------------------
' ------------------------INTERFACE-FARBICONS-----------------------------------
' ------------------------------------------------------------------------------
> FUNCTION xrsrc_init      ! MagicMac-Patch
.| Glob. Var.: xrsrc%,relo%,f.base%,f.init%,f.scalc%,r%
.| Aufruf in : HAUPTPROGRAMM-1,
LOCAL a%,tl%,dl%,bl%,p$
'
' Initialisierungsroutine fÅr die Xrsrc-Routinen
' XRSRC-Routinen Copyright (c)1992 Olaf Meisiek
'
' -----------------------------------------------------------
INLINE xrsrc%,9423
INLINE relo%,94
'
f.base%=GEMDOS(75,5,L:0,L:0,L:0)     ! CREATE BASEPAGE
'
IF f.base%<=0
RETURN FALSE                       ! ERROR!
ENDIF
'
tl%={xrsrc%+2}                       ! LÑnge TEXT
dl%={xrsrc%+6}                       ! LÑnge DATA
bl%={xrsrc%+10}                      ! LÑnge BSS
'
{f.base%+8}=f.base%+256              ! Adresse TEXT
{f.base%+16}={f.base%+8}+{xrsrc%+2}  ! Adresse DATA
{f.base%+24}={f.base%+16}+{xrsrc%+6} ! Adresse BSS
'
{f.base%+12}=tl%                     ! LÑnge TEXT
{f.base%+20}=dl%                     ! LÑnge DATA
{f.base%+28}=bl%                     ! LÑnge BSS
'
' {f.base%+32}=dta%                  ! Addresse DTA
'
BMOVE xrsrc%+28,f.base%+256,9423-28  ! Relozieren...
~C:relo%(L:f.base%+256,L:tl%,L:dl%,L:INT{xrsrc%+14})
'
'  ~MSHRINK(f.base%,256+tl%+dl%+bl%)
' --> ausgeklammert damit es auch auf Magic-MAc lÑuft !!!
' -----------------------------------------------------------
f.init%={f.base%+8}
'
p$=STRING$(100,0)
{f.init%+4}=V:p$
'
$C+
a%=C:f.init%(L:f.base%)              ! Initialisierung
$C-
'
IF a%=0                              ! Hat geklappt...
f.scalc%={f.init%+42}
'
WORD{f.init%+4+36}=128             ! Nummer der Function
$C+
r%=C:f.scalc%()
$C-
'
RETURN TRUE
ENDIF
'
RETURN FALSE                         ! ERROR!
ENDFUNC
> PROCEDURE xrsrc_exit
.| Glob. Var.: f.init%,r%,f.scalc%,f.base%
.| Aufruf in : HAUPTPROGRAMM-1,goodbye-1,
'
WORD{f.init%+4+36}=129          ! Nummer der Funktion
$C+
r%=C:f.scalc%()
$C-
'
~MFREE(f.base%)
'
RETURN
> FUNCTION xrsrc_load(file$)
.| Glob. Var.: f.init%,f.scalc%
.| Aufruf in : rsc_laden-1,
LOCAL r%
'
file$=file$+CHR$(0)
'
WORD{f.init%+4+36}=1          ! Nummer der Funktion
'
{f.init%+4+16}=V:file$
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_gaddr(re_gtype&,re_gindex&,VAR re_gaddr%)
.| Glob. Var.: f.init%,f.scalc%
.| Aufruf in : rsc_laden-1,textfeld-1,textbutt-1,setbutton-1,setbutton2-1
.|     hidetree-1,readbutton-1,readpos-1,colorbox-1,editread-1,editfeld-1
.|     do_main-1,normalize-2,fade-2,smptime-2,movefrag-2,smpsave-3
.|     blklfrag-3,newfsel-3,sampleinf-2,resample-1,slideinit-1,slidelen-1
.|     setslide-1,slideupdate-1,slidelr-1,sliding-1,timeline-3,trakload-1
.|     trkbutcalc1-1,trkbutcalc2-1,arrsmpr-4,dragging1-1,dragging2-1
.|     arrdelay-2,arrmname-2,virtual-2,abackup-2,do_smpedit-2,time_edit-2
.|     make-2,do_info-1,setupdat-2,conspace-1,midi-2,peak-1,do_peak-2,
LOCAL r%
'
WORD{f.init%+4+36}=3          ! Nummer der Funktion
'
WORD{f.init%+4+0}=re_gtype&
WORD{f.init%+4+2}=re_gindex&
'
{f.init%+4+16}=V:re_gaddr%
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_obfix(re_gaddr%,re_obj&)
.| Glob. Var.: f.init%,f.scalc%
.| Aufruf in :  - (tot)
LOCAL r%
'
WORD{f.init%+4+36}=5          ! Nummer der Funktion
'
WORD{f.init%+4+0}=re_obj&
'
{f.init%+4+16}=re_gaddr%
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
' ------------------------------------------------------------------------------
' ------------------------ENHANCED-FLYDIALS-------------------------------------
' ------------------------------------------------------------------------------
DEFFN rsc_flags(tree&,obj&,bit&)=BTST(OB_FLAGS(rsc_adr%(tree&),obj&),bit&)
DEFFN rsc_state(tree&,obj&,bit&)=BTST(OB_STATE(rsc_adr%(tree&),obj&),bit&)
> FUNCTION form_keybd(rsc_adr%,edit_obj&,key&,a&,VAR next_obj&,key_back&,idx&)
.| Ruft auf  : form_search_flag
.| Aufruf in : key-1,
' ZusÑtzliche Tastaturkommandos...
' Einfach FORM_KEYBD in 'rsc_do' durch @form_keybd ersetzen.
$F%
LOCAL scan|,cont&
'
' Ersetzt FORM_KEYBD()...
'
key_back&=0
cont&=1
'
SELECT key&
'
' ------------------------------------------------- SHIFT right
CASE &H4D36
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
' ------------------------------------------------- SHIFT left
CASE &H4B34
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
'
a&=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=0
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=a&
'
' ------------------------------------------------- Cursor runter
CASE &H5000
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
' ------------------------------------------------- Cursor rauf
CASE &H4800
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,-1)
' ------------------------------------------------- SHIFT runter/HOME
CASE &H5032,&H4737                                  ! =>letztes Feld
REPEAT
next_obj&=edit_obj&
edit_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
UNTIL edit_obj&=0
' ------------------------------------------------- SHIFT rauf, HOME
CASE &H4838,&H4700                                  ! =>erstes Feld
next_obj&=@form_search_flag(rsc_adr%,0,3,1)
' ------------------------------------------------- HELP/UNDO
CASE &H6200,&H6100
key_back&=key&
' ------------------------------------------------- Alles andere
DEFAULT
scan|=BYTE(SHR(key&,8))                           ! SCAN-Code
'
IF BYTE(key&)>0 OR scan|=75 OR scan|=77           ! Cursor rauf/runter
cont&=FORM_KEYBD(rsc_adr%,edit_obj&,key&,0,next_obj&,key&)
'                                               ! Kein Ende&TAB u. EDITABLE
IF cont&>0 AND BYTE(key&)<>9 AND BTST(OB_FLAGS(rsc_adr%,edit_obj&),3)
'
scan|=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)+8}+idx&}! Maske 'A' oder 'N'...
IF scan|=65 OR (scan|=78 AND (BYTE(key&)<48 OR BYTE(key&)>57))
key&=BCLR(key&,5)                             ! ...Groûschrift setzen
ENDIF
'
~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,2,idx&) ! ...Eingabe
ENDIF
'
ELSE
key_back&=key&
ENDIF
'
ENDSELECT
'
RETURN cont&
ENDFUNC
> FUNCTION form_search_flag(rsc_adr%,obj&,flag&,step&)
$F%
.| Aufruf in : form_keybd-4,
'
' Unterroutine fÅr form_keybd. Sucht das nÑchste/vorhergehende Objekt mit
' dem gesetzten Bit 'flag&' in OB_FLAGS...
'
' Sonderfall: Letztes Objekt ist edierbar, Cursor runter:
IF NOT (BTST(OB_FLAGS(rsc_adr%,obj&),5)=TRUE AND step&>0)
'
REPEAT
ADD obj&,step&
'
IF BTST(OB_FLAGS(rsc_adr%,obj&),flag&) AND (NOT BTST(OB_STATE(rsc_adr%,obj&),3))
RETURN obj&
ENDIF
UNTIL (obj&<=0) OR BTST(OB_FLAGS(rsc_adr%,obj&),5)
'
ENDIF
'
RETURN 0
ENDFUNC
> PROCEDURE rsc_movedial(tree&,edit_obj&,idx&)
.| Glob. Var.: deskx&,deskw&,desky&,deskh&
.| Felder    : rscw&(),rsch&(),rscx&(),rscy&(),rsc_handle%(),rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_flipping,rsc_cursor
.| Aufruf in : button-1,
' SOLID Flydials...
' Einfach die Prozedur 'rsc_movedial' ersetzen.
LOCAL x&,y&,w&,h&,fx&,fy&,mx&,my&,mb&,shift&,rsc%
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'
~GRAF_MKSTATE(mx&,my&,x&,y&)
' Nicht zusÑtzl. rechte Maustaste oder SHIFT/CONTROL/ALT...
IF NOT (x&=3 OR AND(y&,&X1111)>0)
rsc%=MALLOC(@getsize(w&,h&))                    ! Dialog retten
ENDIF
IF rsc%                                           ! Hat geklappt...
rsc_bitblt(0,0,0,rsc%,w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
ENDIF
'
~GRAF_MOUSE(4,0)                                  ! FLAT_HAND
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
fx&=SUB(mx&,SUCC(rscx&(tree&)))                   ! Relativer Mausfaktor
fy&=SUB(my&,SUCC(rscy&(tree&)))
'
mx&=rscx&(tree&)
my&=rscy&(tree&)
' ------------------------------------------------- Bewegen
IF rsc%                                           ! SOLID...
REPEAT
'
~GRAF_MKSTATE(x&,y&,mb&,shift&)
'
x&=SUB(PRED(x&),fx&)
y&=SUB(PRED(y&),fy&)                          ! Clipping...
x&=MIN(MAX(x&,deskx&),SUB(ADD(deskx&,deskw&),w&))
y&=MIN(MAX(y&,desky&),SUB(ADD(desky&,deskh&),h&))
'
IF mx&<>x& OR my&<>y&
rsc_flipping(rsc_handle%(tree&),rsc%,mx&,my&,w&,h&,x&,y&)
mx&=x&
my&=y&
'
ENDIF
'
UNTIL mb&=0
'
~MFREE(rsc%)
'
ELSE                                              ! Nicht SOLID...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~GRAF_DRAGBOX(rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),deskx&,desky&,deskw&,deskh&,x&,y&)
ENDIF
' ------------------------------------------------- Hinsetzen
rscx&(tree&)=x&
rscy&(tree&)=y&
OB_X(rsc_adr%(tree&),0)=ADD(x&,3)
OB_Y(rsc_adr%(tree&),0)=ADD(y&,3)
'
IF rsc%=0                                         ! Nicht SOLID...
rsc_bitblt(0,0,0,rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
~OBJC_DRAW(rsc_adr%(tree&),0,10,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
'
IF edit_obj&
rsc_cursor(rsc_adr%(tree&),edit_obj&,idx&)    ! ...Cursor ein
ENDIF
ENDIF
'
~GRAF_MOUSE(0,0)
'
RETURN
> PROCEDURE rsc_flipping(rsc_back%,rsc%,ax&,ay&,w&,h&,x&,y&)
.| Ruft auf  : rsc_bitblt
.| Aufruf in : rsc_movedial-1,
LOCAL rb&,rh&,gw&,gh&
'
gw&=ABS(SUB(x&,ax&))         ! Verschiebbreite
gh&=ABS(SUB(y&,ay&))         ! Verschiebhîhe
rb&=SUB(w&,gw&)              ! Restbreite
rh&=SUB(h&,gh&)              ! Resthîhe
'
IF rb&<0 OR rh&<0            ! rsc% auûerhalb von rsc_back%
'
' Gesamten Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,h&,ax&,ay&)
'
' Gesamten Dialog aktualisieren -----
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,h&,0,0)
'
ELSE IF x&>ax&               ! nach rechts...
'
IF y&>ay&                  ! nach rechts-unten veschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,gh&,gw&,rh&,ax&,ADD(ay&,gh&))
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,gh&,ax&,ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,gh&,rb&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),rb&,gh&,0,rh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ELSE                      ! nach rechts-oben / rechts verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,gw&,rh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,0,rb&,rh&,0,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,rb&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ENDIF
'                         ! nach links / oben / unten...
ELSE IF y&>ay&              ! nach links-unten / unten verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,rb&,gh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,h&,ADD(ax&,rb&),ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,gh&,rb&,rh&,gw&,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,gw&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),w&,gh&,0,rh&)
'
ELSE                        ! nach links-oben / links / oben verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,rh&,ADD(ax&,rb&),ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,0,rb&,rh&,gw&,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,gh&),gw&,rh&,0,gh&)
'
ENDIF
'
rsc_bitblt(rsc%,w&,h&,0,0,0,0,0,w&,h&,x&,y&)
'
RETURN
> PROCEDURE rsc_set_cursor(rsc_adr%,mx&,my&,VAR edit_obj&,next_obj&,idx&)
.| Glob. Var.: wchar&
.| Aufruf in : button-1,
' Zeichengenaues Cursor-Positionieren mit der Maus...
' Nur die entsprechenden 2 Zeilen in 'rsc_do' (ziemlich am Ende) entREMen.
LOCAL x&,a&,i&,ob_spec%,a$
'
ob_spec%=OB_SPEC(rsc_adr%,next_obj&)
'
~OBJC_OFFSET(rsc_adr%,next_obj&,x&,a&)          ! Absolute X-Position
'
x&=DIV(SUB(mx&+SHR(wchar&,2),x&),wchar&)        ! Spaltenposition
'
a$=CHAR{{ADD(ob_spec%,4)}}                      ! Maske lesen
'
FOR a&=1 TO x&                                  ! Pos. im Eingabefeld...
IF MID$(a$,a&,1)="_"
INC i&                                      ! ...nur relevante
ENDIF
NEXT a&
SUB x&,(x&-i&)
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)    ! Cursor aus
'
ob_spec%=ADD({ob_spec%},x&)
'
a&=BYTE{ob_spec%}                               ! Zeichen merken
BYTE{ob_spec%}=0                                ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,next_obj&,0,idx&,1,idx&)    ! Cursor setzen
BYTE{ob_spec%}=a&                               ! ...und Zeichen restaurieren
'
edit_obj&=next_obj&
'
RETURN
> FUNCTION rsc_shortcut(tree&,scan|,shift&,VAR title&)
.| Felder    : rsc_adr%()
.| Aufruf in : key-1,
' MenÅshortcut ermitteln...
$F%
LOCAL a&,obj&,rsc_adr%,s$,t$
'
' tree&      : Index des MenÅbaumes
' scan|      : SCAN-Code der gedrÅckten Taste
' shift&     : Status der tastaturumschalttasten
' VAR title& : Bei Erfolg Objektnummer des MenÅtitels
'
SELECT scan|
CASE 2 TO 10                                   ! 1-2...
s$=CHR$(ADD(47,scan|))
CASE 15                                        ! TAB...
s$="I"
shift&=BSET(shift&,2)                        ! ...entspricht "^I"
'
CASE 59 TO 68,84 TO 93                         ! Ftasten...
IF scan|<84
s$="F"+STR$(SUB(scan|,58))                 ! ...normal
ELSE
s$="F"+STR$(SUB(scan|,83))                 ! ...mit Shift
ENDIF
CASE 71                                        ! ClrHome...
s$="CLR"
CASE 83                                        ! DELETE...
s$="DEL"
CASE 97                                        ! UNDO...
s$="UNDO"
CASE 98                                        ! HELP...
s$="HELP"
DEFAULT                                        ! Alles andere...
rsc_adr%={XBIOS(16,L:-1,L:-1,L:-1)}
s$=CHR$(BCLR(BYTE{ADD(rsc_adr%,scan|)},5))
ENDSELECT
'
IF BTST(shift&,3)                              ! Alternate...
s$=CHR$(7)+s$
ENDIF
IF BTST(shift&,2)                              ! Control...
s$="^"+s$
ENDIF
IF BTST(shift&,0) OR BTST(shift&,1)            ! Shift...
s$=CHR$(1)+s$
ENDIF
'
title&=2                                       ! Position des Titels
obj&=5                                         ! Beginn der eigentl. MenÅs
rsc_adr%=rsc_adr%(tree&)                       ! öbersichtlicher
'
REPEAT                                         ! alle Objekte d. MenÅbaums
INC obj&
'
IF BYTE(OB_TYPE(rsc_adr%,obj&))=28           ! G_STRING...
IF NOT BTST(OB_STATE(rsc_adr%,obj&),3)     ! disabled ?
'
t$=TRIM$(CHAR{OB_SPEC(rsc_adr%,obj&)})   ! MenÅpunkt-Text
'
a&=RINSTR(t$," ")
IF a&                                    ! Shortcut vorhanden ?
'
IF MID$(t$,SUCC(a&))=s$                ! hier der vermutete Shortcut
RETURN obj&                          ! gefunden
ENDIF
'
ENDIF
ENDIF
'
ELSE IF BYTE(OB_TYPE(rsc_adr%,obj&))=20      ! G_STRING ?
INC title&
ENDIF
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)          ! LAST_OB ?
'
title&=0
RETURN 0                                       ! nicht gef. oder disabled
ENDFUNC
> FUNCTION rsc_alert(icon&,text$,button$,def&)
.| Glob. Var.: rsc_alert&,wchar&,hchar&
.| Felder    : rsc_adr%(),rscw&(),rsch&(),rscx&(),rscy&()
.| Ruft auf  : rsc_text,rsc_draw,rsc_do,rsc_back
.| Aufruf in : copytoarr-1,
' Fliegende ALERT-Box...
$F%
LOCAL a&,b&,h&,i&,l&,len&,w&,x&,y&,z&,ab&,ah&,rsc&,rsc_adr%,a$
'
' Alert-Box darstellen...
'
IF rsc_alert&>-1                                       ! Wenn's den Baum gibt:
rsc_adr%=rsc_adr%(rsc_alert&)                        ! rsc_alert=GLOBAL
'
text$=text$+"|"
button$=button$+"|"
' ---------------------------------------------------- Icon bestimmen
OB_FLAGS(rsc_adr%,2)=BSET(OB_FLAGS(rsc_adr%,2),7)    ! Hidden...
OB_FLAGS(rsc_adr%,3)=BSET(OB_FLAGS(rsc_adr%,3),7)
OB_FLAGS(rsc_adr%,4)=BSET(OB_FLAGS(rsc_adr%,4),7)
'
OB_FLAGS(rsc_adr%,SUCC(icon&))=BCLR(OB_FLAGS(rsc_adr%,SUCC(icon&)),7)
' ---------------------------------------------------- Buttons
OB_FLAGS(rsc_adr%,10)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,10)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,11)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,11)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,12)=OR(&X100101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,12))) ! LAST_OB+EXIT+SELECT.
'                                                    ! Default-Button...
OB_FLAGS(rsc_adr%,9+def&)=BSET(OB_FLAGS(rsc_adr%,9+def&),1)
' ---------------------------------------------------- Textzeilen setzen
FOR i&=1 TO 5
a&=INSTR(text$,"|")
a$=LEFT$(text$,MIN(30,MAX(0,PRED(a&))))
text$=MID$(text$,SUCC(a&))
'
z&=MAX(z&,-i&*(a$<>""))                            ! Hîchste belegte Zeile
l&=MAX(l&,LEN(a$))                                 ! LÑngste Zeile
'
rsc_text(rsc_alert&,ADD(4,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Button-Texte setzen
FOR i&=1 TO 3
a&=INSTR(button$,"|")
a$=LEFT$(button$,MIN(10,MAX(0,PRED(a&))))
button$=MID$(button$,SUCC(a&))
'
ADD b&,-(a$<>"")                                   ! Anzahl Buttons
len&=MAX(len&,LEN(a$))                             ! LÑngster Button
'
rsc_text(rsc_alert&,ADD(9,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Dialog-Breite Ñndern
l&=MAX(l&,MUL(10,b&))                                ! Minimal-Breite
'
w&=OB_W(rsc_adr%,3)+MUL(wchar&,ADD(l&,5))
OB_W(rsc_adr%,0)=w&                                  ! Neue Breite
'
OB_X(rsc_adr%,1)=w&-PRED(OB_W(rsc_adr%,1))           ! Flydial verschieben
rscw&(rsc_alert&)=ADD(w&,6)
' ---------------------------------------------------- Dialog-Hîhe Ñndern
h&=OB_H(rsc_adr%,10)+MUL(hchar&,ADD(z&,2))
OB_H(rsc_adr%,0)=h&                                  ! Neue Hîhe
rsch&(rsc_alert&)=ADD(h&,6)
' ---------------------------------------------------- Buttons plazieren
len&=MUL(wchar&,MAX(8,SUCC(len&)))
OB_W(rsc_adr%,10)=len&                               ! Breite anpassen..
OB_W(rsc_adr%,11)=len&
OB_W(rsc_adr%,12)=len&
'
SELECT b&                                            ! Anzahl Buttons...
CASE 1
OB_FLAGS(rsc_adr%,11)=BSET(OB_FLAGS(rsc_adr%,11),7)! ...hidden
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
' OB_X(rsc_adr%,10)=SHR(SUB(w&,OB_W(rsc_adr%,10)),1)
OB_X(rsc_adr%,10)=SUB(w&,OB_W(rsc_adr%,10))-2*wchar&
'
CASE 2
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
x&=w&-OB_W(rsc_adr%,11)-2*wchar&
OB_X(rsc_adr%,11)=x&
OB_X(rsc_adr%,10)=x&-OB_W(rsc_adr%,10)-wchar&
'
CASE 3
x&=w&-OB_W(rsc_adr%,12)-SHL(wchar&,1)              ! ...Mitte
OB_X(rsc_adr%,12)=x&
OB_X(rsc_adr%,11)=x&-OB_W(rsc_adr%,10)-wchar&
OB_X(rsc_adr%,10)=OB_X(rsc_adr%,11)-OB_W(rsc_adr%,10)-wchar&
'
ENDSELECT
'
y&=h&-OB_H(rsc_adr%,10)-SHR(hchar&,1)
OB_Y(rsc_adr%,10)=y&
OB_Y(rsc_adr%,11)=y&
OB_Y(rsc_adr%,12)=y&
' ---------------------------------------------------- Anzeigen
~FORM_CENTER(rsc_adr%(rsc_alert&),rscx&(rsc_alert&),rscy&(rsc_alert&),rscw&(rsc_alert&),rsch&(rsc_alert&))
'
rsc_draw(rsc_alert&,FALSE)
'
rsc&=@rsc_do(rsc_alert&,0,a&)
'
rsc_back(rsc_alert&)
' ----------------------------------------------------
OB_STATE(rsc_adr%,rsc&)=BCLR(OB_STATE(rsc_adr%,rsc&),0)! SELECTED lîschen
'
RETURN SUB(rsc&,9)                                   ! Nummer des Buttons 1-3
ENDIF
'                                                      ! Normaler Alert...
WHILE INSTR(button$,"[")>0
button$=LEFT$(button$,PRED(INSTR(button$,"[")))+MID$(button$,SUCC(INSTR(button$,"[")))
WEND                                                   ! ...'[' rausfiltern
'
RETURN FORM_ALERT(def&,"["+STR$(icon&)+"]["+text$+"]["+button$+"]")
ENDFUNC
> PROCEDURE rsc_state(tree&,obj&,bit&,stat!)
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_tristate-4,rsc_tristate2-4,
' Setzen und Abfragen einzelner Bits in OB_STATE und OB_FLAGS...
'
' tree& : Index des Objektbaumes
' obj&  : Objektnummer
' bit&  : Zu setzendes Bit
' stat! : TRUE =Bit setzen, FALSE =Bit lîschen
'
IF stat!
OB_STATE(rsc_adr%(tree&),obj&)=BSET(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ELSE
OB_STATE(rsc_adr%(tree&),obj&)=BCLR(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ENDIF
'
RETURN
> PROCEDURE rsc_tristate(tree&,obj&)
.| Glob. Var.: tri#
.| Ruft auf  : rsc_state,rsc_draw_obj
.| Aufruf in : arrtristate-1,
' Behandlung eines Tristate-Buttons...
'
INC tri
IF tri=3 THEN
tri=0
ENDIF
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
RETURN
> PROCEDURE rsc_tristate2(tree&,obj&)
.| Glob. Var.: tri#
.| Ruft auf  : rsc_state,rsc_draw_obj
.| Aufruf in : arrnrset-4,arranger-4,arrdel-4,
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
RETURN
> PROCEDURE rsc_draw_obj(tree&,obj&)
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_tristate-1,rsc_tristate2-1,
' Zeichnen eines einzelnen Objektes...
LOCAL x&,y&
'
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
~OBJC_DRAW(rsc_adr%(tree&),obj&,8,x&,y&,OB_W(rsc_adr%(tree&),obj&),OB_H(rsc_adr%(tree&),obj&))
'
RETURN
> PROCEDURE rsc_redraw_obj(tree&,obj&)
.| Glob. Var.: edit_obj&,idx&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_message
.| Aufruf in : message-1,fadehandler-1,clsfade-1,fadedel-1,restaura3-1
.|     trakload-1,trakforw-1,trkbackw-1,hardfs-1,mforw-1,mbackw-1
.|     time_edit-1,coninsert-1,record2-1,record3-1,
' Sauberer Redraw eines Objektes, nur fÅr Fensterdialoge!...
LOCAL x&,y&,w&,h&
'
' Sendet einen Redraw-Event fÅr ein Objekt
' --------------------------------------------------
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
w&=OB_W(rsc_adr%(tree&),obj&)
h&=OB_H(rsc_adr%(tree&),obj&)
'
'  appl_write(ap_id&,20,rsc_handle%(tree&),x&-3,y&-3,w&+6,h&+6,"")   ! WM_REDRAW
rsc_message(tree&,20,x&-3,y&-3,w&+6,h&+6,edit_obj&,idx&)   ! WM_REDRAW
'
RETURN
> PROCEDURE appl_write(id&,msg&,handle&,x&,y&,w&,h&,a$)
.| Glob. Var.: msg%,ap_id&
.| Aufruf in : helptxt-2,
' LOCAL b$
'
' Sendet eine Message an ein Programm. Dabei kann es sich auch um
' das eigene Programm handeln (id&=ap_id&), siehe 'rsc_redraw_obj'
' --------------------------------------------------
INLINE msg%,256
'
INT{msg%}=msg&                                     ! 0 Message-ID
INT{msg%+2}=ap_id&                                 ! 1 Unsere ID
INT{msg%+4}=0                                      ! 2 Keine öberlÑnge
INT{msg%+6}=handle&                                ! 3
INT{msg%+8}=x&                                     ! 4 MenÅpunkt
INT{msg%+10}=y&                                    ! 5
INT{msg%+12}=w&                                    ! 6
INT{msg%+14}=h&                                    ! 7
'
IF x&=0                                            ! String (z.B. fÅr VA_START)...
CHAR{msg%+16}=LEFT$(a$,240)
{msg%+6}=msg%+16
ENDIF
'
~APPL_WRITE(id&,16,msg%)                           ! Weg damit
'
RETURN
' ------------------------------------------------------------------------------
' ------------------------RCS-Zugriffs-Routinen---------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE textfeld(txtname,txt$,versatz)
LOCAL a
.| Glob. Var.: nr#,zu%,string#,it#,xwidth#,ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : opto-1,coax-1,analog-1,digital-1,fliphz-22,maschruf2-2
.|     maschruf3-6,maschruf3b-6,maschruf5-2,maschruf5c-2,maschruf8b-6
.|     rsc_do-1,do_main-4,fnamwrite-3,smpfree-1,smplen-1,smpsec-1
.|     selblkstxt-6,selblketxt-6,markhlp3-2,smptime-3,markprod3-1,smpsave-1
.|     clearfsel-30,getsel2-30,getsel4-1,smpload-3,ldhztest-3,writehzm-2
.|     sampleinf-82,clsed-25,writeyproz-18,resmptxt-3,resample-1
.|     arrnrset-48,arranger-2,timeline-3,trakload-4,trakforw-2,trkbackw-2
.|     trkstop-1,trkstrt-1,trkend-1,trkanf-2,trkfull-2,trkplay-10,opentrk-6
.|     arrsmpr-1,arrstrt-2,arrend-2,arrtowork-2,copytoarr-1,arrmidi-8
.|     arrdel-24,arrmname-4,arrplay-10,hardstrt-4,hardend-4,hardfs-18
.|     virtual-2,arrload-1,mstop-1,mforw-2,mbackw-2,maketime-1,makepnt-1
.|     abackup-1,abackr-1,abackl-1,sethertz-6,smpedit-3,do_smpedit-2
.|     do_blkf-2,make-6,rebuild-3,setupdat-2,setdat-4,fseldef-1,secbutt-1
.|     flipptest-1,recbutt-1,tresbutt-1,markdel-1,smpstx-2,smpsts-2,smpex-2
.|     smpes-2,smph3-2,conspace-3,midi-1,channelup-1,channeldown-1
.|     makenote-1,normtest-1,norml-1,normr-1,resl-1,resr-1,resoth32-1
.|     resoth44-1,resoth48-1,peak-1,do_peak-1,markhandler-1,deladbutt-3
.|     smpplay-7,smppmhlp-2,record-1,record3-3,
'  IF mrkhandle=mrkhandle2 THEN
'  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
'  IF v<>0 AND kenn=mrkhandle2 THEN
~@xrsrc_gaddr(0,nr,zu%)
string=LPEEK(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,txtname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~FRE(0)
' ENDIF
' ENDIF
RETURN
'
> PROCEDURE textbutt(parent,txtname,txt$,versatz)
.| Glob. Var.: nr#,zu%,string#,it#,xwidth#,ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : button-2,zslidecalc-1,smpedit-1,do_smpedit-2,
'  IF mrkhandle=mrkhandle2 THEN
'  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
'  IF v<>0 AND kenn=mrkhandle2 THEN
~@xrsrc_gaddr(0,nr,zu%)
string=(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
POKE string+it-1+(versatz-1),ASC(MID$(txt$,it,1))
NEXT it
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,parent,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
' ENDIF
' ENDIF
RETURN
'
> PROCEDURE setbutton(buttnr,buttflag)
.| Glob. Var.: nr#,zu%,buttadr#,xwidth#,ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : button-7,winbuttset-8,main-1,do_main-3,smplen-1,smpsec-1
.|     selblksbut-6,selblkebut-6,helptxt-2,normalize-5,fade-7,infade-2
.|     ausfade-2,smptime-1,smpanf-1,smpend-1,smpmid-1,smpcut-1,movefrag-1
.|     smpsave-2,blklfrag-1,clearfsel-15,getsel3-3,newfsel-64,restaura4-4
.|     smpload-1,ldhztest-1,ldhlp-7,smpinfbutt-1,sampleinf-1,clsed-15
.|     resample-5,arrnrset-48,arranger-7,do_arrange-8,trakker-1
.|     do_trakker-10,trakknr-2,trakload-3,trkpause-1,trkstop-1,trkstrt-1
.|     trkend-1,trkanf-1,trkfull-1,trkplay-1,trktowork-1,arrsmpr-4
.|     arrstrt-1,arrend-1,dragging1-5,dragging2-8,copytoarr-1,arrmidplay-1
.|     arrdel-17,arrinsert-1,arrdelete-1,arrdelay-2,delayr-1,delayl-1
.|     arrmname-1,arrplay-1,hardstrt-1,hardend-1,hardfs-1,virtual-16
.|     arrload-1,arrsave-1,recplay-1,mpause-1,mstop-1,abackup-7,abackr-1
.|     abackl-1,smpedit-5,do_smpedit-11,blkfunc-1,do_blkf-2,time_edit-10
.|     make-2,info-1,do_info-2,rebuild-6,trash-2,setupdat-2,setload-1
.|     setdat-52,setsave-1,vertline-1,linkdot-1,spacefill-1,fseldef-1
.|     secbutt-1,recbutt-1,tresbutt-1,conmix-1,conspace-2,coninsert-2
.|     memtovirt-2,memtovirt2-2,monitor-1,mono-2,negate-2,lrchange-2,midi-3
.|     loopwahl-4,do_loop-2,dspwahl-1,do_dsp-8,resoth32-1,resoth44-1
.|     resoth48-1,peak-1,do_peak-4,smpplay-2,smppmhlp-1,smpauto-4,smpstart-4,
'  IF mrkhandle=mrkhandle2 THEN
'  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
'  IF v<>0 AND kenn=mrkhandle2 THEN
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
' ENDIF
' ENDIF
RETURN
'
> PROCEDURE setbutton2(buttnr,buttflag,n)
.| Glob. Var.: xwidth#,ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : main-1,fade-1,arranger-1,trakker-1,blkfunc-1,info-1
.|     loopwahl-1,peak-1,edhandler-29,
LOCAL buttadr,zu%
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,n,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE setbild(buttnr,buttflag)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
RETURN
'
> PROCEDURE hidetree(buttnr,buttflag)
.| Glob. Var.: nr#,zu%,buttadr#,xwidth#,ywidth#,trakbox2&
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : timeline-2,trakload-1,
LOCAL bf
'  IF mrkhandle=mrkhandle2 THEN
'  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
'  IF v<>0 AND kenn=mrkhandle2 THEN
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,trakbox2&,99,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
' ENDIF
' ENDIF
RETURN
'
> PROCEDURE hidetree2(buttnr,buttflag)
.| Glob. Var.: buttadr#,zu%
.| Aufruf in : timeline-1,
LOCAL bf
buttadr=zu%+24*buttnr
DPOKE buttadr+10,0    ! setbutton lîschen
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
ENDIF
RETURN
'
> PROCEDURE readbutton(buttnr)
.| Glob. Var.: nr#,zu%,buttadr#,buttflag#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : helptxt-2,newfsel-1,dragging1-2,dragging2-1,
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+10)
RETURN
'
> PROCEDURE readpos(buttnr)
.| Glob. Var.: nr#,zu%,buttadr#,bx#,by#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : dragging1-1,dragging2-1,
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
bx=DPEEK(buttadr+16)
by=DPEEK(buttadr+18)
RETURN
'
> PROCEDURE colorbox(nrr,buttnr,col,fill)
.| Glob. Var.: zu%,buttadr#,colflag#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : HAUPTPROGRAMM-68,
~@xrsrc_gaddr(0,nrr,zu%)
buttadr=zu%+24*buttnr
colflag=DPEEK(buttadr+14)
colflag=(colflag AND &HFFF0)+col
colflag=(colflag AND &HFF8F)+fill*16
DPOKE buttadr+14,colflag
RETURN
'
> PROCEDURE textcolor(nrr,buttnr,col,rahmen,fill)
~@xrsrc_gaddr(0,nrr,zu%)
buttadr=LPEEK(zu%+24*buttnr+12)
colflag=DPEEK(buttadr+18)
colflag=(colflag AND &HF0)+col*256+rahmen*4096+fill
DPOKE buttadr+18,colflag
RETURN
'
> PROCEDURE editread(edread)
.| Glob. Var.: nr#,zu%,editadr#,erd#,a$,bv$
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-2,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkproof-1,tedproof-1,setupdat-1,setsave-1,
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edread+12
erd=LPEEK(LPEEK(editadr))
a$=""
WHILE PEEK(erd)<>0
bv$=CHR$(PEEK(erd))
a$=a$+bv$
erd=erd+1
WEND
RETURN
'
> PROCEDURE editfeld(edname,ed$)
.| Glob. Var.: edit_obj&,nr#,zu%,editadr#,edanf#,edz#,ef#,ap#,xwidth#
.|     ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-8,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkart-1,tedart-2,setdat-1,
edit_obj&=0
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edname+12
edanf=LPEEK(LPEEK(editadr))
edz=LEN(ed$)
FOR ef=1 TO edz
ap=ASC(MID$(ed$,ef,1))
POKE edanf+ef-1,ap
NEXT ef
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,edname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~FRE(0)
RETURN
'
> PROCEDURE mouse(VAR mx,my,mk)
.| Aufruf in : message-1,normalize-1,fadehandler-2,markhandl4-1,arrsmpr-1
.|     dragging1-2,dragging2-2,arrmname-1,virtual-1,setupdat-1,midi-1
.|     do_peak-1,markhandler-1,
LOCAL void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx,my,mk,void&)
~WIND_UPDATE(2)
'
SUB mx,WORD{WINDTAB+64}
SUB my,WORD{WINDTAB+66}
RETURN
'
> FUNCTION mousek
$F%
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf4b-1
.|     maschruf5-1,maschruf5c-1,maschruf8b-1,fadehandler-1,fade-1,smptime-1
.|     movefrag-1,drawpix-2,edhandler2-3,smpsave-1,blklfrag-1,newfsel-1
.|     sampleinf-1,trkplay-1,dragging2-1,arrtristate-1,arrdelay-1,arrplay-1
.|     abackup-1,time_edit-1,make-1,smpsts-1,smpes-1,do_peak-1,peakwert-1
.|     markhandler-1,
LOCAL mk&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(void&,void&,mk&,void&)
~WIND_UPDATE(2)
'
RETURN mk&
'
ENDFUNC
'
> FUNCTION mousex
$F%
.| Aufruf in : markhandl4-1,do_peak-1,
LOCAL mx&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx&,void&,void&,void&)
~WIND_UPDATE(2)
SUB mx&,WORD{WINDTAB+64}
'
RETURN mx&
'
ENDFUNC
'
> FUNCTION mousey
$F%
.| Aufruf in : markhandl4-1,do_peak-1,
LOCAL my&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(void&,my&,void&,void&)
~WIND_UPDATE(2)
SUB my&,WORD{WINDTAB+66}
'
RETURN my&
'
ENDFUNC
'
' ------------------------------------------------------------------------------
'          HardwareunabhÑngiger Teil - GEM
' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------
' ------------------------HAUPTPROGRAMM-----------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE treiberload
IF demo=FALSE THEN
IF EXIST(s$+"SOUND.PRG"+CHR$(0))=TRUE THEN
a=EXEC(0,s$+"SOUND.PRG"+CHR$(0),CHR$(0),CHR$(0))
IF a<>0 THEN
ALERT 3,"Soundkarten-Treiber konnte|nicht geladen werden !",1,"EXIT",g
END
ENDIF
ELSE
ALERT 3,"Soundkarten-Treiber fehlt !",1,"EXIT",g
END
ENDIF
ENDIF
RETURN
'
> PROCEDURE rec_headinit(r$)
fil$=LEFT$(r$,INSTR(r$,CHR$(0))-1)
danf=mdat%
@headart
IF sfileart=0 THEN
inf=FALSE
ALERT 3,"Falscher File-Extender !",1,"EXIT",g
ENDIF
RETURN
'
> PROCEDURE rec_header
IF sfileart<>0 THEN
fileart=sfileart
OPEN "I",#1,fil$+CHR$(0)
vmlen=mlen
mlen=LOF(#1)-head
CLOSE #1
vblks=blks
vsret=sret
vsblock=sblock
blks=0
sret=0
sblock=0
@headmake
mlen=vmlen
blks=vblks
sret=vsret
sblock=vsblock
h%=GEMDOS(61,L:filadr,2)
IF h%>0 THEN
ok%=GEMDOS(66,L:0,h%,0)
ok%=GEMDOS(64,h%,L:head,L:danf)
ok%=GEMDOS(62,h%)
ENDIF
ENDIF
RETURN
'
> FUNCTION mxalloc(giveme,art)
a=GEMDOS(68,L:giveme,art)
RETURN a
ENDFUNC
'
> PROCEDURE intzeiger1(bx)
.| Glob. Var.: cs#,ce#,cx#,xm#,c1#,sret#,c2#,sblock#,xd#,stay1#,stay2#,cx2#
.| Ruft auf  : blocklook
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf5-1,maschruf5c-1,
LOCAL j
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 7
@blocklook
IF ((bx=c1 AND (sret=0 OR sret=2)) OR (bx=c2-8 AND sret=1)) AND sblock=1 THEN
GRAPHMODE 3
ELSE
GRAPHMODE 1
ENDIF
LINE cx+xd,stay1,cx+xd,stay2
cx2=cx
COLOR 0
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE intzeiger2(bx)
.| Glob. Var.: cs#,ce#,cx#,xm#,cx2#,xd#,stay1#,stay2#
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf5-1,maschruf5c-1,
LOCAL j
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 7
GRAPHMODE 3
LINE cx2+xd,stay1,cx2+xd,stay2
LINE cx+xd,stay1,cx+xd,stay2
cx2=cx
COLOR 0
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE intzeiger3
.| Glob. Var.: bx#,cs#,ce#,cx2#,xd#,stay1#,stay2#
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf5-1,maschruf5c-1,
LOCAL j
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 7
GRAPHMODE 3
LINE cx2+xd,stay1,cx2+xd,stay2
COLOR 0
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE drop
.| Glob. Var.: nob#
.| Ruft auf  : drop2
.| Aufruf in : rsc_do-1,
IF MENU(1)=10 THEN
nob=MENU(5)
@drop2
ENDIF
RETURN
'
> PROCEDURE drop2
.| Glob. Var.: nr#,rsc_adr%,rsc_menu&,nob#,ddinfo&,smpedit&,obj#,infoicon&
.|     ddblock&,blocfunc&,ddsmp16&,edsmp16&,ddpeak&,peaksw2&,ddarr&,arrange&
.|     ddtrakk&,trak&,ddloop&,loopart&,ddload&,smpload&,ddsave&,smpsave&
.|     ddfader&,edfade&,ddsetup&,setuper&,ddmon&,monitor&,dddsp&,swdsp&
.|     ddauto&,smpauto2&,ddmanu&,smpstrt2&,ddplay&,smpplay&,ddexit&,g#
.|     ddmidi&,edmidi&,obj&
.| Felder    : rsc_handle%(),rsc_adr%()
.| Ruft auf  : info,blkfunc,main,peak,arranger,trakker,loopwahl,smpload
.|     smpsave,fade,setupdat,monitor,dspwahl,smpauto,smpstart,smpplay
.|     goodbye,midi
.| Aufruf in : rsc_do-1,drop-1,
IF rsc_handle%(nr)>0 AND rsc_handle%(nr)<1000 THEN
rsc_adr%=rsc_adr%(rsc_menu&)
~MENU_TNORMAL(rsc_adr%,MENU(4),1)
IF nob=ddinfo& THEN
IF nr=smpedit& THEN
obj=infoicon&
ELSE
obj=0
ENDIF
@info
ENDIF
IF nob=ddblock& THEN
IF nr=smpedit& THEN
obj=blocfunc&
ELSE
obj=0
ENDIF
@blkfunc
ENDIF
IF nob=ddsmp16& THEN
IF nr=smpedit& THEN
obj=edsmp16&
ELSE
obj=0
ENDIF
@main
ENDIF
IF nob=ddpeak& THEN
IF nr=smpedit& THEN
obj=peaksw2&
ELSE
obj=0
ENDIF
@peak
ENDIF
IF nob=ddarr& THEN
IF nr=smpedit& THEN
obj=arrange&
ELSE
obj=0
ENDIF
@arranger
ENDIF
IF nob=ddtrakk& THEN
IF nr=smpedit& THEN
obj=trak&
ELSE
obj=0
ENDIF
@trakker
ENDIF
IF nob=ddloop& THEN
IF nr=smpedit& THEN
obj=loopart&
ELSE
obj=0
ENDIF
@loopwahl
ENDIF
IF nob=ddload& THEN
IF nr=smpedit& THEN
obj=smpload&
ELSE
obj=0
ENDIF
neufsel=FALSE
@smpload
ENDIF
IF nob=ddbank& THEN
IF nr=smpedit& THEN
obj=smpdbank&
ELSE
obj=0
ENDIF
neufsel=TRUE
@smpload
ENDIF
IF nob=ddsave& THEN
IF nr=smpedit& THEN
obj=smpsave&
ELSE
obj=0
ENDIF
@smpsave
ENDIF
IF nob=ddfader& THEN
IF nr=smpedit& THEN
obj=edfade&
ELSE
obj=0
ENDIF
@fade
ENDIF
IF nob=ddsetup& THEN
IF nr=smpedit& THEN
obj=setuper&
ELSE
obj=0
ENDIF
@setupdat
ENDIF
IF nob=ddmon& THEN
IF nr=smpedit& THEN
obj=monitor&
ELSE
obj=0
ENDIF
@monitor
ENDIF
IF nob=dddsp& THEN
IF nr=smpedit& THEN
obj=swdsp&
ELSE
obj=0
ENDIF
@dspwahl
ENDIF
IF nob=ddauto& THEN
IF nr=smpedit& THEN
obj=smpauto2&
ELSE
obj=0
ENDIF
@smpauto
ENDIF
IF nob=ddmanu& THEN
IF nr=smpedit& THEN
obj=smpstrt2&
ELSE
obj=0
ENDIF
@smpstart
ENDIF
IF nob=ddplay& THEN
IF nr=smpedit& THEN
obj=smpplay&
ELSE
obj=0
ENDIF
@smpplay
ENDIF
IF nob=ddexit& THEN
ALERT 2,"Programm beenden",1,"JA|NEIN",g
IF g=1 THEN
@goodbye
ENDIF
ENDIF
IF nob=ddmidi& THEN
IF nr=smpedit& THEN
obj=edmidi&
ELSE
obj=0
ENDIF
@midi
ENDIF
obj=0
obj&=0
ENDIF
nob=0
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE winbuttset
.| Glob. Var.: nr#,smpedit&,winh#,info&,infoicon&,peak&,peaksw2&,blkfunc&
.|     blocfunc&,loop&,loopart&,smp16&,edsmp16&,editfade&,edfade&,arranger&
.|     arrange&,trakker&,trak&
.| Ruft auf  : setbutton
.| Aufruf in : smpedit-1,
IF nr=smpedit& THEN
IF BTST(winh,info&)=TRUE THEN
@setbutton(infoicon&,1)
ENDIF
IF BTST(winh,peak&)=TRUE THEN
@setbutton(peaksw2&,1)
ENDIF
IF BTST(winh,blkfunc&)=TRUE THEN
@setbutton(blocfunc&,1)
ENDIF
IF BTST(winh,loop&)=TRUE THEN
@setbutton(loopart&,1)
ENDIF
IF BTST(winh,smp16&)=TRUE THEN
@setbutton(edsmp16&,1)
ENDIF
IF BTST(winh,editfade&)=TRUE THEN
@setbutton(edfade&,1)
ENDIF
IF BTST(winh,arranger&)=TRUE THEN
@setbutton(arrange&,1)
ENDIF
IF BTST(winh,trakker&)=TRUE THEN
@setbutton(trak&,1)
ENDIF
IF BTST(winh,dspedit&)=TRUE THEN
@setbutton(swdsp&,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE main
.| Glob. Var.: winh#,smp16&,rsc_window&,vornr#,nr#,menuda#,edsmp16&,g#
.|     smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,setbutton,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,smp16&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=smp16&
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@makehz
@sethertz
@fliphz2
@sourcein
ELSE
@setbutton(edsmp16&,0)
ALERT 1,"Alle Fenster belegt|Bitte ein Fenster schlieûen !",1,"EXIT",g
ENDIF
ELSE
vornr=nr
nr=smp16&
IF vornr=smpedit& THEN
@setbutton2(edsmp16&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_main
.| Glob. Var.: smp16&,zu%,zuadr#,buttadr#,obj#,but#,dsp&,a$,popups&
.|     dsppopup&,popup&,rate2&,digana#,smppop2&,input&,inpop&,source&
.|     srcpop&,protect&,swdsp&,helporig&,exit&,winh#,nr#,smpedit&,edsmp16&
.|     nob#
.| Ruft auf  : xrsrc_gaddr,textfeld,dspoff,dspin,dspout,adlow,admid,adhigh
.|     ext32l,ext44l,ext48l,ext32h,ext44h,ext48h,ext256,ext384,analog
.|     digital,opto,coax,prot,setbutton,dspwahl,helptxt,restaura2b
.| Aufruf in : windows-1,
~@xrsrc_gaddr(0,smp16&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
IF but=22 THEN
IF obj=dsp& THEN
a$=@rsc_text$(popups&,dsppopup&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@dspoff
ENDIF
IF popup&=2 THEN
@dspin
ENDIF
IF popup&=3 THEN
@dspout
ENDIF
ENDIF
IF obj=rate2& AND digana=TRUE THEN
a$=@rsc_text$(popups&,smppop2&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@adlow
ENDIF
IF popup&=2 THEN
@admid
ENDIF
IF popup&=3 THEN
@adhigh
ENDIF
IF popup&=4 THEN
@ad8
ENDIF
IF popup&=5 THEN
@ad11
ENDIF
IF popup&=6 THEN
@ad12
ENDIF
IF popup&=7 THEN
@ad16
ENDIF
IF popup&=8 THEN
@ad17
ENDIF
IF popup&=9 THEN
@ad22
ENDIF
IF popup&=10 THEN
@ad24
ENDIF
IF popup&=11 THEN
@ad33
ENDIF
IF popup&=12 THEN
@adexth2
ENDIF
IF popup&=13 THEN
@adextl2
ENDIF
IF popup&=14 THEN
@adexth1
ENDIF
IF popup&=15 THEN
@adextl1
ENDIF
ENDIF
IF obj=input& THEN
a$=@rsc_text$(popups&,inpop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@analog
ENDIF
IF popup&=2 THEN
@digital
ENDIF
ENDIF
IF obj=source& THEN
a$=@rsc_text$(popups&,srcpop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@opto
ENDIF
IF popup&=2 THEN
@coax
ENDIF
IF popup&=3 THEN
@aesebu
ENDIF
ENDIF
IF obj=emphasis& THEN
a$=@rsc_text$(popups&,emphpop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@emphoff
ENDIF
IF popup&=2 THEN
@emphon
ENDIF
ENDIF
IF obj=mode& THEN
a$=@rsc_text$(popups&,modepop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@consumer
ENDIF
IF popup&=2 THEN
@profess
ENDIF
ENDIF
IF obj=protect& THEN
a$=@rsc_text$(popups&,popscms&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@scmsno
ENDIF
IF popup&=2 THEN
@scmsone
ENDIF
IF popup&=3 THEN
@scmsfree
ENDIF
ENDIF
ENDIF
IF obj=bridge& THEN
@digibridge
ENDIF
IF obj=helporig& THEN
@helptxt("HAUPTSEITE")
ENDIF
IF obj=exit& OR obj=9999 THEN
winh=BCLR(winh,smp16&)
@setbutton(exit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(edsmp16&,0)
ENDIF
@sethertz
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
nob=0
RETURN
'
> PROCEDURE windows
.| Glob. Var.: menuda#,obj#,nr#,popup&,info&,dspedit&,arranger&,trakker&
.|     loop&,peak&,blkfunc&,smp16&,smpedit&,smpexit&,g#
.| Ruft auf  : rsc_menu_ienable,rsc_do,do_info,do_dsp,do_arrange,do_trakker
.|     do_loop,do_peak,do_blkf,do_main,maketime,do_smpedit,goodbye
.| Aufruf in : smpedit-1,
REPEAT
REPEAT
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
obj=@rsc_do(nr,0,popup&)
IF obj<>0 AND nr=peak& THEN
@do_peak
ENDIF
IF peakmrk=peak& AND nr<>peak& THEN
@write_int(0)
ENDIF
IF obj<>0 AND nr=info& THEN
@do_info
ENDIF
IF obj<>0 AND nr=dspedit& THEN
@do_dsp
ENDIF
IF obj<>0 AND nr=arranger& THEN
@do_arrange
ENDIF
IF obj<>0 AND nr=trakker& THEN
@do_trakker
ENDIF
IF obj<>0 AND nr=loop& THEN
@do_loop
ENDIF
IF obj<>0 AND nr=blkfunc& THEN
@do_blkf
ENDIF
IF obj<>0 AND nr=smp16& THEN
@do_main
ENDIF
IF obj<>0 AND nr=smpedit& THEN
@maketime
@do_smpedit
IF obj<>9999 AND obj<>smpexit& THEN
obj=0
ENDIF
ENDIF
~FRE(0)
UNTIL nr=smpedit& AND (obj=smpexit& OR obj=9999)
ALERT 2,"Programm beenden",1,"JA|NEIN",g
IF g=1 THEN
@write_int(0)
@goodbye
ENDIF
obj=0
UNTIL g=1
RETURN
'
> PROCEDURE goodbye
.| Glob. Var.: demo#,peakint#,i#,winh#
.| Ruft auf  : rsc_back,rsc_exit,xrsrc_exit,exit
.| Aufruf in : drop2-1,windows-1,fehler-1,
IF demo=FALSE THEN
IF XBIOS(500)=&H71273800 THEN
peakint=FALSE
@write_int(0)
ENDIF
ENDIF
FOR i=31 TO 0 STEP -1
IF BTST(winh,i)=TRUE THEN
@rsc_back(i)
ENDIF
NEXT i
GEMSYS 109                                        ! Nur ab GEM 1.04!
@rsc_exit
@xrsrc_exit
@exit
END
RETURN
'
> PROCEDURE memfeld(memolen,grenz)
.| Glob. Var.: mem$,nr#,smp16&,smpedit&
.| Aufruf in : fnamwrite-1,smplen-1,smpplay-1,record3-1,
LOCAL a,b
b=memolen
a=LEN(STR$(b))
IF a>6 THEN
b=INT(b/1024)
ENDIF
mem$=STR$(b)
IF nr=smp16& THEN
IF a>6 THEN
mem$=mem$+" KB used"+CHR$(0)
ELSE
mem$=mem$+" Bytes used"+CHR$(0)
ENDIF
ENDIF
IF nr=smpedit& THEN
IF a>6 THEN
mem$="LEN "+mem$+" KB"+CHR$(0)
ELSE
mem$="LEN "+mem$+" BYTES"+CHR$(0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE secfeld(seclen,grenz)
.| Glob. Var.: sec$,nr#,smpedit&
.| Aufruf in : fnamwrite-1,smpsec-1,do_blkf-1,smpplay-1,record3-1,
IF nr=smpedit& THEN
hsec=seclen*100
@htimeset
sec$="= "+a$+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE fnamwrite
.| Glob. Var.: nr#,smpedit&,smpfile&,smpnam$,smplen#,smplen&,mem$,sec#,hz#
.|     smpsec&,sec$
.| Ruft auf  : textfeld,memfeld,secfeld,smpfree
.| Aufruf in : smplen-1,smpsec-1,smpsave-1,smpload-1,ldhlp-1,smpedit-1
.|     do_smpedit-11,rebuild-1,markdel-1,setup2-1,memtovirt-1,memtovirt2-1
.|     smpplay-1,record2-1,record4-1,
IF nr=smpedit& THEN
@textfeld(smpfile&,smpnam$+CHR$(0),1)
@memfeld(smplen,8)
@textfeld(smplen&,mem$,1)
sec=INT(smplen/(hz*4))+1
@secfeld(sec,8)
@textfeld(smpsec&,sec$,1)
@smpfree
ENDIF
RETURN
'
> PROCEDURE smpfree
.| Glob. Var.: lfw$,op$,smpname&
.| Ruft auf  : textfeld
.| Aufruf in : fnamwrite-1,setupdat-1,
LOCAL a$,a
a=ASC(LEFT$(lfw$,1))-64
a=INT(DFREE(a)/1024)
a$=LEFT$(lfw$,2)+STR$(a)+"K  "
a=ASC(LEFT$(op$,1))-64
a=INT(DFREE(a)/1024)
a$=a$+LEFT$(op$,2)+STR$(a)+"K"
IF LEN(a$)>20 THEN
a$=LEFT$(a$,20)
ENDIF
a$=a$+CHR$(0)
@textfeld(smpname&,a$,1)
RETURN
'
> PROCEDURE smplen
.| Glob. Var.: mlen#,mem$,smplen&
.| Ruft auf  : memfeld,textfeld,fnamwrite,setbutton
.| Aufruf in : do_smpedit-1,
@memfeld(mlen,8)
mem$="MAX"+RIGHT$(mem$,LEN(mem$)-3)
@textfeld(smplen&,mem$,1)
PAUSE 100
@fnamwrite
@setbutton(smplen&,0)
RETURN
'
> PROCEDURE smpsec
.| Glob. Var.: mlen#,hz#,sec$,smpsec&
.| Ruft auf  : secfeld,textfeld,fnamwrite,setbutton
.| Aufruf in : do_smpedit-1,
LOCAL s
s=INT(mlen/(hz*4))+1
hsec=s*100
@htimeset
sec$="MAX "+a$+CHR$(0)
@textfeld(smpsec&,sec$,1)
PAUSE 100
@fnamwrite
@setbutton(smpsec&,0)
RETURN
'
> PROCEDURE selblkstxt(i,a$)        ! Text in Start-Looptaste schreiben
.| Glob. Var.: smptsa&,smptsb&,smptsc&,smptsd&,smptse&,smptsava&
.| Ruft auf  : textfeld
.| Aufruf in : markhlp3-1,markhlp8-1,movingmark-1,
SELECT i
CASE 1
@textfeld(smptsa&,a$,1)
CASE 2
@textfeld(smptsb&,a$,1)
CASE 3
@textfeld(smptsc&,a$,1)
CASE 4
@textfeld(smptsd&,a$,1)
CASE 5
@textfeld(smptse&,a$,1)
CASE 6
@textfeld(smptsava&,a$,1)
ENDSELECT
RETURN
'
> PROCEDURE selblketxt(i,a$)        ! Text in End-Looptaste schreiben
.| Glob. Var.: smptea&,smpteb&,smptec&,smpted&,smptee&,smptsavb&
.| Ruft auf  : textfeld
.| Aufruf in : markhlp3-1,markhlp8-1,movingmark-1,
SELECT i
CASE 1
@textfeld(smptea&,a$,1)
CASE 2
@textfeld(smpteb&,a$,1)
CASE 3
@textfeld(smptec&,a$,1)
CASE 4
@textfeld(smpted&,a$,1)
CASE 5
@textfeld(smptee&,a$,1)
CASE 6
@textfeld(smptsavb&,a$,1)
ENDSELECT
RETURN
'
> PROCEDURE selblksbut(i,a)         ! Start-Loopbutton setzen/lîschen
.| Glob. Var.: smpsta&,smpstb&,smpstc&,smpstd&,smpste&,smpsavl&
.| Ruft auf  : setbutton
.| Aufruf in : markset-1,ldready-1,rebuild-1,smpsts-1,smph3-4,
SELECT i
CASE 1
@setbutton(smpsta&,a)
CASE 2
@setbutton(smpstb&,a)
CASE 3
@setbutton(smpstc&,a)
CASE 4
@setbutton(smpstd&,a)
CASE 5
@setbutton(smpste&,a)
CASE 6
@setbutton(smpsavl&,a)
ENDSELECT
RETURN
'
> PROCEDURE selblkebut(i,a)         ! End-Loopbutton setzen/lîschen
.| Glob. Var.: smpea&,smpeb&,smpec&,smped&,smpee&,smpsavr&
.| Ruft auf  : setbutton
.| Aufruf in : markset-1,ldready-1,rebuild-1,smpes-1,smph3-4,
SELECT i
CASE 1
@setbutton(smpea&,a)
CASE 2
@setbutton(smpeb&,a)
CASE 3
@setbutton(smpec&,a)
CASE 4
@setbutton(smped&,a)
CASE 5
@setbutton(smpee&,a)
CASE 6
@setbutton(smpsavr&,a)
ENDSELECT
RETURN
'
> PROCEDURE selblkshak(i,VAR a)     ! Start-LoophÑckchen finden
.| Glob. Var.: hacksa&,hacksb&,hacksc&,hacksd&,hackse&,hackss&
.| Aufruf in : markprod3-1,smpstx-1,smpsts-1,smph3-1,
SELECT i
CASE 1
a=hacksa&
CASE 2
a=hacksb&
CASE 3
a=hacksc&
CASE 4
a=hacksd&
CASE 5
a=hackse&
CASE 6
a=hackss&
ENDSELECT
RETURN
'
> PROCEDURE selblkehak(i,VAR a)     ! End-LoophÑckchen finden
.| Glob. Var.: hackea&,hackeb&,hackec&,hacked&,hackee&,hackes&
.| Aufruf in : markprod3-1,smpex-1,smpes-1,smph3-1,
SELECT i
CASE 1
a=hackea&
CASE 2
a=hackeb&
CASE 3
a=hackec&
CASE 4
a=hacked&
CASE 5
a=hackee&
CASE 6
a=hackes&
ENDSELECT
RETURN
'
> PROCEDURE helptxt(search$)        ! Hilfstexte von 1st Guide aktivieren
.| Glob. Var.: obj#,buttflag#,accwindopen#
.| Ruft auf  : readbutton,setbutton,appl_write,message
.| Aufruf in : do_main-1,normalize-1,fade-1,smptime-1,movefrag-1,smpsave-1
.|     blklfrag-1,newfsel-1,sampleinf-1,resample-1,do_arrange-1
.|     do_trakker-1,arrsmpr-1,arrdelay-1,arrmname-1,virtual-1,abackup-1
.|     do_smpedit-1,do_blkf-1,time_edit-1,make-1,do_info-1,setupdat-1
.|     conspace-1,midi-1,do_loop-1,do_dsp-1,
LOCAL g,hlpfound
msg_id=APPL_FIND("1STGUIDE")
IF msg_id<>-1 THEN
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=op$+"1STGUIDE.IDX"
ENDIF
IF EXIST(hpath$)=FALSE THEN
hlpfound=FALSE
'    ~GRAF_MOUSE(256,0)                              ! Hidem
'    ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
'   ~GRAF_MOUSE(257,0)                              ! Showm
@fileselect(op$+"*.IDX","1STGUIDE.IDX","Search 1STGUIDE.IDX:")
'   @rsc_put(ab,rscx&(nr),rscy&(nr),1)
IF ordner$<>"" AND pret<>0 AND pbutt=1 THEN
hpath$=ordner$+"1STGUIDE.IDX"
IF EXIST(hpath$)=TRUE THEN
hlpfound=TRUE
ENDIF
ENDIF
ELSE
hlpfound=TRUE
ENDIF
IF hlpfound=TRUE THEN
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
@appl_write(msg_id,&H4711,0,0,0,0,0,hpath$)    ! VA_START
accwindopen=FALSE
ON MENU MESSAGE GOSUB message
REPEAT
ON MENU
UNTIL accwindopen=TRUE
@appl_write(msg_id,1025,0,0,0,0,0,search$)                           ! AC_HELP
accwindopen=FALSE
ON MENU MESSAGE GOSUB message
REPEAT
ON MENU
UNTIL accwindopen=TRUE
ENDIF
ELSE
ALERT 1,"1stGuide ist nicht installiert|daher keine Hilfe,sorry !!!",1,"OK",g
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
ENDIF
RETURN
'
> PROCEDURE markhlp
.| Glob. Var.: nr#,handle&,ax&,ay&,ab&,ah&,xd#,yd#,xm#,ym#,sline#,stay1#
.|     ym1#,ym2#,stay2#,dazu#
.| Felder    : rsc_handle%()
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,message-1,normalize-1
.|     fadehandler-1,fade-1,fadelinear-1,fadesquare-1,fadexp-1,fadesqrt-1
.|     fadelog-1,infade-1,ausfade-1,smptime-2,smpkhlp-1,smpmhlp-1,smpihlp-1
.|     zoomhelp-1,smpl-1,smpr-2,smpcut-1,movefrag-1,edhandler2-1,blkstest-1
.|     smpsave-5,blklfrag-2,newfsel-1,blkltest-1,ldhlp-6,sampleinf-1
.|     curve-1,resample-1,slideupdate-1,slidelr-1,dragging1-1,dragging2-1
.|     arrdelay-1,arrmname-1,write-1,smpedit-1,blkfunc-1,time_edit-1,make-1
.|     info-1,trash-2,setupdat-1,smpstx-1,smpsts-1,smpex-1,smpes-1
.|     markhlp6-1,setup-1,conspace-2,midi-1,loopwahl-1,dspwahl-1,peak-1
.|     do_peak-2,peakread2-1,
IF rsc_handle%(nr)<1001                             ! Normaler Dialog...
handle&=rsc_handle%(nr)                         ! Fensterhandle des Dialogs
~WIND_GET(handle&,4,ax&,ay&,ab&,ah&)          ! 1. Rechteck
xd=ax&+24           ! X-Locator
yd=ay&+14           ! Y-Locator
xm=602              ! Breite der Box
ym=76               ! Hîhe der Box
sline=88   ! Abstand zur zweiten Mittellinie
stay1=yd+24         ! Anfang der Markline
ym1=yd+27           ! Y-Locator erste Box
ym2=yd+115          ! Y-Locator zweite Box
stay2=yd+195        ! Ende der Markline
dazu=yd+222         ! Y-Locator fÅr Fade
ENDIF
RETURN
'
> PROCEDURE markhlp2
.| Glob. Var.: cs#,xd#,stay1#,stay2#,t$
.| Aufruf in : smpstx-1,smpsts-1,smpex-1,smpes-1,
IF cs=0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
LINE xd,stay1,xd,stay2
GRAPHMODE 1
TEXT xd-3,stay1-1,t$
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE markhlp3(i,stxnr)
.| Glob. Var.: tedart#,hz#,loopz#,cstxt&,cetxt&
.| Ruft auf  : selblkstxt,selblketxt,textfeld
.| Aufruf in : markprod2-4,markprod3-4,smph2-4,edhandler2-4,markset-2
.|     findblock-2,curve-4,smpedit-2,timecorr-2,smpstx-1,smpsts-1,smpex-1
.|     smpes-1,
LOCAL sc,sc$
IF tedart=0 THEN
sc=stxnr/(hz*4)
ELSE
sc=INT(stxnr/4)
ENDIF
sc$=STR$(sc)
sc$=LEFT$(sc$+SPACE$(9),9)+CHR$(0)
IF i>0 AND i<=loopz THEN
@selblkstxt(i,sc$)
ENDIF
IF i>loopz AND i<=loopz*2 THEN
@selblketxt(i-loopz,sc$)
ENDIF
IF i=9998 THEN
@textfeld(cstxt&,sc$,1)
ENDIF
IF i=9999 THEN
@textfeld(cetxt&,sc$,1)
ENDIF
RETURN
'
> PROCEDURE markhlp8(i,bx)
.| Glob. Var.: cs#,ce#,cx#,xm#,xd#,stay1#,stay2#,loopz#
.| Ruft auf  : selblkstxt,selblketxt
.| Aufruf in : smph3-2,
LOCAL j
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
LINE cx+xd,stay1,cx+xd,stay2
COLOR 0
GRAPHMODE 1
FOR j=xd+cx-5 TO xd+cx+5
LINE j,stay1,j,stay1-5
NEXT j
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
IF i>0 AND i<=loopz THEN
@selblkstxt(i,CHR$(0))
ENDIF
IF i>loopz AND i<=loopz*2 THEN
@selblketxt(i-loopz,CHR$(0))
ENDIF
RETURN
'
> PROCEDURE normalize
.| Glob. Var.: makecurve#,vorvornr#,vornr#,nr#,normaliz&,normadj&,normauto&
.|     norma#,obj#,popup&,zu%,zuadr#,x#,y#,v#,buttadr#,but#,norml1&,norml2&
.|     norml3&,normr1&,normr2&,normr3&,objadr#,objflag#,helpnorm&,normok&
.|     normexit&,norm&
.| Ruft auf  : rsc_draw,markhlp,setbutton,normtest,rsc_do,xrsrc_gaddr,mouse
.|     norml,normr,helptxt,normauto,normadj,rsc_back,blkrestaura
.| Aufruf in : do_blkf-1,
makecurve=0
vorvornr=vornr
vornr=nr
nr=normaliz&
@rsc_draw(nr,0)
@markhlp
IF norma=0 THEN
@setbutton(normauto&,0)
@setbutton(normadj&,1)
db$=STR$(db)+CHR$(0)
ELSE
@setbutton(normadj&,0)
@setbutton(normauto&,1)
db$=STR$(0)+CHR$(0)
ENDIF
@textfeld(normdb&,db$,1)
@normtest
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
IF obj=norml1& OR obj=norml2& OR obj=norml3& OR obj=normr1& OR obj=normr2& OR obj=normr3& THEN
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=norml1& OR obj=norml2& OR obj=norml3& THEN
@norml
ENDIF
IF obj=normr1& OR obj=normr2& OR obj=normr3& THEN
@normr
ENDIF
IF obj=normauto& THEN
norma=1
db$=STR$(0)+CHR$(0)
@textfeld(normdb&,db$,1)
ENDIF
IF obj=normadj& THEN
norma=0
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
ENDIF
IF obj=helpnorm& THEN
@helptxt("NORMALIZE")
ENDIF
UNTIL obj=normok& OR obj=normexit&
IF obj=normok& THEN
IF norma=1 THEN
@normauto
ENDIF
IF norma=0 THEN
@normadj
ENDIF
ENDIF
@setbutton(obj,0)
@rsc_back(nr)
nr=vornr
@blkrestaura
@setbutton(norm&,0)
vornr=vorvornr
obj=0
RETURN
'
> PROCEDURE fadehandler
.| Glob. Var.: x#,y#,k#,yd#,yma#,dazu#,xd#,fxl#,xm#,ym#,fadericht#,fadnr#,i#
.|     v3#,nr#,buttadr#,zuadr#,obj#,but#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : markhlp,mouse,mousek,rsc_redraw_obj
.| Aufruf in : rsc_do-1,
@markhlp
@mouse(x,y,k)
IF y>yd AND k=1 THEN
yma=dazu
IF x<xd+fxl THEN
x=xd+fxl
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
LINE x,y,x,y
~GRAF_MOUSE(257,0)                              ! Showm
xm=x
ym=y
IF fadericht=1 THEN
IF xm>xd+10 THEN
xm=xd+10
ENDIF
ENDIF
REPEAT
@mouse(x,y,k)
IF fadericht=0 THEN
IF x>=xm AND x>xd+fxl-1 AND x<xd+fxl+fadnr-1 THEN
IF y>ym THEN
y=ym
ENDIF
IF y<yd THEN
y=yd
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
LINE xm,ym,x,y
FOR i=xm TO x
LINE i,yma,i,y
fadeni(i-xd-fxl)=fadnr-(y-yd)
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
xm=x
ym=y
ENDIF
ELSE
IF x>=xm AND x>xd+fxl-1 AND x<xd+fxl+fadnr-1 THEN
IF ym>y THEN
y=ym
ENDIF
IF y>dazu THEN
y=dazu
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
LINE xm,ym,x,y
FOR i=xm TO x
LINE i,yma,i,y
fadeno(i-xd-fxl)=fadnr-(y-yd)
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
xm=x
ym=y
ENDIF
ENDIF
v3=@mousek
UNTIL v3=0
IF x<xd+fxl+fadnr-1 THEN
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
RETURN
'
> PROCEDURE fade
.| Glob. Var.: winh#,editfade&,rsc_window&,vornr#,nr#,menuda#,fxl#,zu%
.|     boxadr#,fadericht#,infade&,ausfade&,yma#,dazu#,i#,fadnr#,a#,yd#,y#
.|     xd#,zuadr#,obj#,popup&,helpfade&,fadelin&,fadexp&,fadesqrt&,fadedel&
.|     fdsquare&,fadelog&,fadload&,fadsave&,fadexit&,fadok&,aw#,fadeok&
.|     edfade&,g#,smpedit&,tree&,edit_obj&,idx&
.| Felder    : bfadeni#(),fadeni#(),bfadeno#(),fadeno#()
.| Ruft auf  : rsc_draw,rsc_menu_ienable,xrsrc_gaddr,markhlp,setbutton
.|     rsc_do,helptxt,infade,ausfade,fadelinear,fadexp,fadesqrt,fadedel
.|     fadesquare,fadelog,fadeload,fadesave,mousek,restaura2b,setbutton2
.|     rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,editfade&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=editfade&
@rsc_draw(nr,5)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
'  fyl=51   ! Oberkante-Y Fadefenster
fxl=-6   ! Linke Kante-X Fadefenster
GRAPHMODE 1
~@xrsrc_gaddr(0,nr,zu%)
boxadr=zu%
@markhlp
'  tree&=nr
IF fadericht=0 THEN
@setbutton(infade&,33)
ELSE
@setbutton(ausfade&,33)
ENDIF
yma=dazu
FOR i=1 TO fadnr
bfadeni(i)=fadeni(i)
bfadeno(i)=fadeno(i)
NEXT i
FOR i=1 TO fadnr
IF fadericht=0 THEN
a=fadeni(i)/fadnr*(dazu-yd)
y=dazu-a
ELSE
a=fadeno(i)/fadnr*(dazu-yd)
y=dazu-a
ENDIF
IF a<>0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
LINE i+xd+fxl,yma,i+xd+fxl,y
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
NEXT i
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0
IF obj=helpfade& THEN
@helptxt("FADE-EDITOR")
ENDIF
IF obj=infade& THEN
@infade
ENDIF
IF obj=ausfade& THEN
@ausfade
ENDIF
IF obj=fadelin& THEN
@fadelinear
ENDIF
IF obj=fadexp& THEN
@fadexp
ENDIF
IF obj=fadesqrt& THEN
@fadesqrt
ENDIF
IF obj=fadedel& THEN
@fadedel
ENDIF
IF obj=fdsquare& THEN
@fadesquare
ENDIF
IF obj=fadelog& THEN
@fadelog
ENDIF
IF obj=fadload& THEN
@fadeload
ENDIF
IF obj=fadsave& THEN
@fadesave
ENDIF
IF obj=fadexit& OR obj=fadok& OR obj=infade& OR obj=ausfade& THEN
aw=FORM_BUTTON(boxadr,obj,1,a)
REPEAT
UNTIL @mousek=0
ELSE
@setbutton(obj,1)
PAUSE 1
@setbutton(obj,0)
ENDIF
PAUSE 1
UNTIL obj=fadeok& OR obj=fadexit&
@setbutton(obj,0)
winh=BCLR(winh,nr)
IF obj=fadexit& THEN
FOR i=1 TO fadnr
fadeni(i)=bfadeni(i)
fadeno(i)=bfadeno(i)
NEXT i
ENDIF
@restaura2b
obj=0
@setbutton(edfade&,0)
GRAPHMODE 3
ELSE
@setbutton(edfade&,0)
ALERT 1,"Alle Fenster belegt|Bitte ein Fenster schlieûen !",1,"EXIT",g
ENDIF
ELSE
vornr=nr
nr=editfade&
IF vornr=smpedit& THEN
@setbutton2(edfade&,1,vornr)
ENDIF
tree&=nr
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE clsfade
.| Glob. Var.: nr#
.| Ruft auf  : rsc_redraw_obj
.| Aufruf in : fadelinear-1,fadesquare-1,fadexp-1,fadesqrt-1,fadelog-1
.|     infade-1,ausfade-1,
IF nr=editfade& THEN
'  @markhlp
'  COLOR 0
'  GRAPHMODE 1
'  PBOX xd+fxl,dazu-fadnr+24,xd+fxl+fadnr,dazu
'  COLOR 1
@rsc_redraw_obj(nr,0)
ENDIF
RETURN
'
> PROCEDURE fadelinear
.| Glob. Var.: fadericht#,ym#,dazu#,y#,i#,fadnr#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL i
@clsfade
GRAPHMODE 1
@markhlp
IF fadericht=0 THEN
fadewin=0
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
FOR i=1 TO fadnr
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
fadeni(i)=y
y=y+1
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=0
ym=dazu
y=fadnr-1
~GRAF_MOUSE(256,0)                              ! Hidem
FOR i=1 TO fadnr
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
fadeno(i)=y
y=y-1
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE fadesquare
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
c=SQR(fadnr)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
IF fadericht=0 THEN
fadewin=1
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=teil
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=b
fadeni(i)=y
a=a+teil
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=1
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=b
fadeno(i)=y
a=a-teil
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE fadexp
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
d=8
c=LOG(fadnr*d)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
IF fadericht=0 THEN
fadewin=2
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=0
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=b
fadeni(i)=y
a=a+teil
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=2
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=b
fadeno(i)=y
a=a-teil
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE fadesqrt
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
c=SQR(fadnr)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
IF fadericht=0 THEN
fadewin=3
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=fadnr-b
fadeni(i)=y
a=a-teil
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=3
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=0
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=fadnr-b
fadeno(i)=y
a=a+teil
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE fadelog
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
d=8
c=LOG(fadnr*d)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
IF fadericht=0 THEN
fadewin=4
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=fadnr-b
fadeni(i)=y
a=a-teil
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=4
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=0
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=fadnr-b
fadeno(i)=y
a=a+teil
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE setlinear
.| Glob. Var.: y#,i#,fadnr#
.| Felder    : fadeni#(),fadeno#()
.| Aufruf in : fadeset-1,
y=0
FOR i=1 TO fadnr
fadeni(i)=y
y=y+1
NEXT i
y=fadnr
FOR i=1 TO fadnr
fadeno(i)=y
y=y-1
NEXT i
RETURN
'
> PROCEDURE infade
.| Glob. Var.: fadericht#,ausfade&,infade&,yma#,dazu#,i#,fadnr#,a#,yd#,y#
.|     xd#,fxl#
.| Felder    : fadeni#()
.| Ruft auf  : markhlp,clsfade,setbutton
.| Aufruf in : fade-1,fadesave-1,fadeload-1,
LOCAL i
@markhlp
fadericht=0
IF nr=editfade& THEN
GRAPHMODE 1
@clsfade
@setbutton(ausfade&,0)
@setbutton(infade&,1)
ENDIF
yma=dazu
IF nr=editfade& THEN
~GRAF_MOUSE(256,0)                              ! Hidem
ENDIF
FOR i=1 TO fadnr
a=fadeni(i)/fadnr*(dazu-yd)
y=dazu-a
IF a<>0 AND nr=editfade& THEN
LINE i+xd+fxl,yma,i+xd+fxl,y
ENDIF
NEXT i
IF nr=editfade& THEN
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE ausfade
.| Glob. Var.: fadericht#,infade&,ausfade&,yma#,dazu#,i#,fadnr#,a#,yd#,y#
.|     xd#,fxl#
.| Felder    : fadeno#()
.| Ruft auf  : markhlp,clsfade,setbutton
.| Aufruf in : fade-1,fadesave-1,fadeload-1,
LOCAL i
@markhlp
fadericht=1
IF nr=editfade& THEN
GRAPHMODE 1
@clsfade
@setbutton(infade&,0)
@setbutton(ausfade&,1)
ENDIF
yma=dazu
IF nr=editfade& THEN
~GRAF_MOUSE(256,0)                              ! Hidem
ENDIF
FOR i=1 TO fadnr
a=fadeno(i)/fadnr*(dazu-yd)
y=dazu-a
IF a<>0 AND nr=editfade& THEN
LINE i+xd+fxl,yma,i+xd+fxl,y
ENDIF
NEXT i
IF nr=editfade& THEN
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE fadedel
.| Glob. Var.: i#,fadnr#,fadericht#,nr#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : rsc_redraw_obj
.| Aufruf in : fade-1,
FOR i=1 TO fadnr
IF fadericht=0 THEN
fadeni(i)=0
ELSE
fadeno(i)=0
ENDIF
NEXT i
@rsc_redraw_obj(nr,0)
RETURN
'
> PROCEDURE fade_it
.| Glob. Var.: sblock#,b1#,c1#,b2#,c2#,mlen#,sms#,sme#,fadericht#,a1#,a2#
.|     vmem#,virtual#,okay#,virtwfile#,virtpath$,a#,virtln#,virtp$,virtfile$
.|     vln#,bytes#,e#,meml#,e2#,i#,fadnr#,mdat3%,c#,back%,g#,cached#,path$
.|     smpnam$,noblkdel#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : blocklook,busy_mouse,maschinit31,maschruf31b,maschinit32
.|     maschruf32,maschinit30,maschruf30,restaura,hardproof3,memtovirt2
.|     nomem
.| Aufruf in : smpl-1,smpr-1,
LOCAL teil
teil=1024
IF sblock=1 THEN
@blocklook
b1=INT(c1/4)*4
b2=INT(c2/4)*4
ELSE
b1=0
b2=INT(mlen/4)*4
ENDIF
IF sblock=0 OR (sblock=1 AND c1<c2 AND c1>=0 AND c2>0 AND sms<>0 AND sme<>0) THEN
IF fadericht=1 THEN
a1=b1
a2=b1+teil
IF a2>vmem THEN
a1=b1-teil
a2=b1
ENDIF
IF a1<0 THEN
a1=0
IF (a2-a1)<teil THEN
a2=teil
ENDIF
ENDIF
ENDIF
IF fadericht=0 THEN
a1=b2-teil
a2=b2
IF a1<0 THEN
a1=b2
a2=b2+teil
ENDIF
IF a2>vmem THEN
a2=vmem
IF (a2-a1)<teil THEN
a1=vmem-teil
ENDIF
ENDIF
ENDIF
IF virtual=FALSE OR (virtual=TRUE AND c2-c1<=mlen) THEN
IF virtual=TRUE THEN
okay=FALSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
SEEK #1,a1
vln=a2-a1
bytes=INT(mlen/4)*4
e=0
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschinit31
@maschruf31b(0,bytes,e2)
IF e2>e THEN
e=e2
ENDIF
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ELSE
@maschinit31
@maschruf31b(a1,a2,e)
ENDIF
IF e=0 AND sblock=1 THEN
e=16384
ENDIF
IF e<>0 AND sblock=1 THEN
FOR i=1 TO fadnr
IF fadericht=0 THEN
DPOKE mdat3%+i*2-2,INT(e/fadnr*fadeni(i))
ELSE
DPOKE mdat3%+i*2-2,INT(e/fadnr*fadeno(i))
ENDIF
NEXT i
IF virtual=FALSE THEN
IF fadericht=0 THEN
@maschinit32
c=0
@maschruf32(b1,b2,c)
IF back%<>-1 THEN
b1=back%
ENDIF
ENDIF
IF fadericht=1 THEN
@maschinit32
c=1
@maschruf32(b1,b2,c)
IF back%<>-1 THEN
b2=back%
ENDIF
ENDIF
@maschinit30
@maschruf30(mdat3%,fadnr,b1,b2)
ELSE
IF okay=TRUE THEN
SEEK #1,b1
vln=b2-b1
bytes=INT(mlen/4)*4
IF vln<=bytes THEN
@busy_mouse
bytes=INT(vln/4)*4
IF bytes>3 THEN
BGET #1,meml,bytes
IF fadericht=0 THEN
@maschinit32
c=0
@maschruf32(0,bytes,c)
IF back%<>-1 THEN
b1=b1+back%
ENDIF
ENDIF
IF fadericht=1 THEN
@maschinit32
c=1
@maschruf32(0,bytes,c)
IF back%<>-1 THEN
b2=b2-((b2-b1)-back%)
ENDIF
ENDIF
ENDIF
ENDIF
IF virtwfile=FALSE THEN
SEEK #1,b1
IF (b2-b1)<=mlen THEN
@busy_mouse
BGET #1,meml,b2-b1
@maschinit30
@maschruf30(mdat3%,fadnr,0,b2-b1)
SEEK #1,b1
BPUT #1,meml,b2-b1
CLOSE #1
ELSE
ALERT 1,"Zu wenig Speicher frei !",1,"EXIT",g
ENDIF
ELSE
SEEK #1,0
IF (b2-b1)<=mlen THEN
vln=b1
bytes=INT(mlen/4)*4
IF vln>0 THEN
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
@busy_mouse
vln=b2-b1
bytes=INT(vln/4)*4
BGET #1,meml,bytes
@maschinit30
@maschruf30(mdat3%,fadnr,0,b2-b1)
BPUT #2,meml,bytes
vln=INT((virtln-b2)/4)*4
bytes=INT(mlen/4)*4
IF vln>0 THEN
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ELSE
ALERT 1,"Zu wenig Speicher frei !",1,"EXIT",g
ENDIF
ENDIF
ENDIF
ENDIF
IF virtual=FALSE OR (virtual=TRUE AND okay=TRUE AND (b2-b1)<=mlen AND virtwfile=TRUE) THEN
cached=FALSE
@restaura
ENDIF
ELSE
ALERT 1,"Bereichsfehler !|Block definiert ?",1,"OK",g
ENDIF
IF okay=TRUE THEN
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
@busy_mouse
path$=virtpath$
a=RINSTR(virtpath$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
cached=FALSE
@restaura
ENDIF
ENDIF
ELSE
IF (c2-c1)>mlen THEN
ALERT 1,"Zu wenig Speicher frei !",1,"EXIT",g
ELSE
@nomem
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
ALERT 1,"Bereichsfehler !|Block definiert ?",1,"OK",g
ENDIF
RETURN
'
> PROCEDURE fadesave
.| Glob. Var.: fade$,lfw$,fil$,pret#,pbutt#,a#,sector#,i#,fadnr#,fadericht#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : fileselect,nomem,infade,ausfade
.| Aufruf in : fade-1,
LOCAL p$,g,g2
g=RINSTR(fade$,"\")
@fileselect(lfw$+"*."+RIGHT$(fade$,3),RIGHT$(fade$,LEN(fade$)-g),"FADER-SAVE:")
g2=INSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+RIGHT$(fade$,4)
ELSE
IF RIGHT$(fil$,4)<>RIGHT$(fil$,4) THEN
fil$=LEFT$(fil$,g2)+RIGHT$(fade$,3)
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=sector THEN
OPEN "O",#1,fil$
FOR i=1 TO fadnr
PRINT #1,fadeni(i)
PRINT #1,fadeno(i)
NEXT i
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
IF fadericht=0 THEN
@infade
ELSE
ausfade
ENDIF
RETURN
'
> PROCEDURE fadeload
.| Glob. Var.: fade$,lfw$,fil$,pret#,pbutt#,i#,fadnr#,fadericht#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : fileselect,infade,ausfade
.| Aufruf in : fade-1,
LOCAL p$,g
g=RINSTR(fade$,"\")
@fileselect(lfw$+"*."+RIGHT$(fade$,3),RIGHT$(fade$,LEN(fade$)-g),"FADER-LOAD:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
IF EXIST(fil$) THEN
OPEN "I",#1,fil$
FOR i=1 TO fadnr
INPUT #1,fadeni(i)
INPUT #1,fadeno(i)
NEXT i
CLOSE #1
ENDIF
ENDIF
IF fadericht=0 THEN
@infade
ELSE
ausfade
ENDIF
RETURN
'
> PROCEDURE fadeset
.| Glob. Var.: fadnr#,fade$,i#
.| Felder    : fadeni#(),fadeno#(),bfadeni#(),bfadeno#()
.| Ruft auf  : setlinear
.| Aufruf in : setload-1,
IF fadnr<>246 THEN
fadnr=246          ! Breite des Fadefensters in Pixeln
DIM fadeni(fadnr)
DIM fadeno(fadnr)
DIM bfadeni(fadnr)
DIM bfadeno(fadnr)
IF EXIST(fade$) THEN
OPEN "I",#1,fade$
FOR i=1 TO fadnr
INPUT #1,fadeni(i)
INPUT #1,fadeno(i)
NEXT i
CLOSE #1
ELSE
@setlinear
ENDIF
ENDIF
RETURN
'
> PROCEDURE blocklook
.| Glob. Var.: master#,loopz#,sms#,msms#,sme#,msme#,c1#,c2#,xm#,ce#,mce#
.|     meml#,mcs#
.| Felder    : loops#(),loope#()
.| Aufruf in : intzeiger1-1,fade_it-1,smpkhlp-1,movingmark-1,smpmhlp-1
.|     smpihlp-1,smpl-1,smpr-1,smpcut-1,sampleinf-1,resample-1,copytoarr-1
.|     trash-1,mono-2,negate-2,lrchange-2,makenorm-1,normtest-1,makeresmp-1
.|     smpplay-2,smpauto-1,record-1,
IF master=loopz OR master=loopz*2 THEN
sms=msms
sme=msme
ENDIF
IF sms>0 AND sms<loopz THEN
c1=loops(sms)
ENDIF
IF sme>0 AND sme<loopz THEN
c2=loope(sme)
ENDIF
IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 THEN
mce=c2+meml
mce=INT(mce/4)*4
mcs=c1+meml
mcs=INT(mcs/4)*4
ENDIF
RETURN
'
> PROCEDURE smptime
LOCAL a,a2
.| Glob. Var.: hrd#,vornr#,nr#,record&,min$,min#,timetxt&,oldmin#,obj#
.|     popup&,zu%,zuadr#,buttadr#,but#,objadr#,objflag#,rechelp&,recexit&
.|     recok&,recl1&,recl2&,recr1&,recr2&
.| Ruft auf  : markhlp,rsc_draw,textfeld,rsc_do,xrsrc_gaddr,mousek,helptxt
.|     setbutton,restaura2
.| Aufruf in : smpauto-1,smpstart-1,
a=ASC(LEFT$(fil$,1))-64
a2=DFREE(a)
IF a2=0 THEN
nofile=0
@nomem
ELSE
vornr=nr
nr=record&
@rsc_draw(nr,0)
@markhlp
hsec=INT(a2/hz/4*100)
mmax=INT(a2/hz/4)
@htimeset
a$="FREETIME: "+a$
@textfeld(recfree&,a$,1)
hsec=rtime*100
@htimeset2
@editfeld(timetxt&,ab$)
oldrtime=rtime
REPEAT
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=rechelp& THEN
@helptxt("RECORD-TIME")
ENDIF
UNTIL obj=recexit& OR obj=recok& OR obj=recl1& OR obj=recl2& OR obj=recr1& OR obj=recr2& OR obj=recl0& OR obj=recr0&
IF obj=recexit& OR obj=recok& OR obj=recl1& OR obj=recl2& OR obj=recr1& OR obj=recr2& OR obj=recl0& OR obj=recr0& THEN
@setbutton(obj,0)
ENDIF
@editread(timetxt&)
IF LEN(a$)=6 THEN
rtime=VAL(LEFT$(a$,2))*3600+VAL(MID$(a$,3,2))*60+VAL(MID$(a$,5,2))
ENDIF
UNTIL obj=recexit& OR ((obj=recok& OR obj=recl0& OR obj=recr0& OR obj=recl1& OR obj=recl2& OR obj=recr1& OR obj=recr2&) AND LEN(a$)=6 AND rtime<(24*60*60))
IF obj=recr0& OR obj=recr1& OR obj=recr2& THEN
IF obj=recr0& AND rtime<mmax THEN
rtime=rtime+1
ENDIF
IF obj=recr1& AND rtime<=(mmax-60) THEN
rtime=rtime+60
ENDIF
IF obj=recr2& AND rtime<=(mmax-3600) THEN
rtime=rtime+3600
ENDIF
hsec=rtime*100
@htimeset2
@editfeld(timetxt&,ab$)
ENDIF
IF obj=recl0& OR obj=recl1& OR obj=recl2& THEN
IF obj=recl0& AND rtime>0 THEN
rtime=rtime-1
ENDIF
IF obj=recl1& AND rtime>=60 THEN
rtime=rtime-60
ENDIF
IF obj=recl2& AND rtime>=3600 THEN
rtime=rtime-3600
ENDIF
hsec=rtime*100
@htimeset2
@editfeld(timetxt&,ab$)
ENDIF
UNTIL obj=recexit& OR obj=recok&
@restaura2
IF obj=recok& THEN
@minwrite
ELSE
rtime=oldrtime
ENDIF
ENDIF
edit_obj&=0
RETURN
'
> PROCEDURE minwrite
IF nr=smpedit& THEN
hsec=rtime*100
@htimeset
a$=LEFT$(a$,8)+CHR$(0)
@textfeld(mintext&,a$,1)
ENDIF
RETURN
'
> PROCEDURE smpkhlp
.| Glob. Var.: mrkp$,mp$,g#,sms#,sme#,loopz#,xm#,ce#,c2#,c1#,c#,xmp#
.|     virtual#,mcs#,meml#,mce#,memh#,vmem#,mcd#,noms#,xmo#,ncs#,nce#,a#
.|     lfw$,mlen#,workfile$,sblock#,b#,v#,seek#,bytes#,path$,smpnam$
.|     noblkdel#,makevirt3#,workf$,virtwfile#,mm#,virtln#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp,blocklook,maschinit10,maschruf10,maschinit11
.|     maschruf11,busy_mouse,rettmem,memtovirt2,nomem,virtcopy,restaura
.| Aufruf in : smpanf-1,smpend-1,smpl-1,smpr-1,edhandler2-1,
LOCAL makev
makev=FALSE
mrkp$=mp$
ALERT 2,"Kopieren ?",1,"JA|NEIN",g
IF g=1 THEN
IF sms<>0 AND sme<>0 AND sms<loopz AND sme<loopz THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 AND ((c<>0 AND xmp=-1) OR (c=0 AND xmp=0)) THEN
IF virtual=FALSE THEN
@maschinit10
IF mcs>=meml AND mce+4<memh AND c=1 THEN     !vorwÑrts key
sms=1
sme=1
loops(1)=c2
loope(1)=c2+(c2-c1)
IF loope(1)>vmem THEN
makev=TRUE
ENDIF
IF makev=FALSE THEN
@maschruf10(mcs,mce,mce+4,memh)
ENDIF
ENDIF
IF mcs>=meml AND mce+4<memh AND c=2 THEN   ! ans Ende
sms=1
sme=1
loops(1)=vmem
loope(1)=vmem+(c2-c1)
makev=TRUE
ENDIF
IF mcs>meml AND c=-1 THEN
mcd=mcs-(mce-mcs)
IF mcd<meml THEN
mcd=meml
mcs=mce-(mcs-meml)
ENDIF
@maschruf10(mcs,mce,mcd,mcs)
sms=1
sme=1
loope(1)=c1
loops(1)=c1-(c2-c1)
IF loops(1)<0 THEN
loops(1)=c1
loope(1)=c2
ENDIF
ENDIF
IF mcs>meml AND c=-2 THEN
noms=0
mcd=mcs-(mce-mcs)
IF mcd<meml THEN
noms=1
mcd=meml
mcs=mce-(mcs-meml)
ELSE
mcd=meml
ENDIF
@maschruf10(mcs,mce,mcd,mcs)
sms=1
sme=1
loope(1)=c2-c1
loops(1)=0
IF noms=1 THEN
loops(1)=c1
loope(1)=c2
ENDIF
ENDIF
IF xmp=0 AND c=0 THEN
loops(1)=INT((c1+xmo)/4)*4
loope(1)=INT((c2+xmo)/4)*4
sms=1
sme=1
IF loops(1)<0 THEN
loops(1)=0
loope(1)=c2-c1
ENDIF
IF loope(1)>vmem THEN         ! vor per Maus
makev=TRUE
ENDIF
IF makev=FALSE THEN
ncs=loops(1)+meml
ncs=INT(ncs/4)*4
nce=loope(1)+meml
nce=INT(nce/4)*4
IF ncs>=mce THEN
@maschruf10(mcs,mce,ncs,memh)
ENDIF
IF ncs<mcs THEN
@maschruf10(mcs,mce,ncs,mce)
ENDIF
IF ncs<mce AND ncs>mcs THEN
@maschinit11
@maschruf11(mce,mcs,nce)
ENDIF
ENDIF
ENDIF
IF makev=TRUE THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF loops(loopz)>=0 AND loope(loopz)<=mlen AND sblock=1 THEN
a=loops(loopz)
b=loope(loopz)
ELSE
a=0
b=mlen
ENDIF
b=INT(b/4)*4
a=INT(a/4)*4
v=b-a
v=INT(v/4)*4
IF a>=0 AND b<=mlen THEN
@busy_mouse
BPUT #1,meml+a,v
ENDIF
IF loops(1)>b THEN
seek=v
ELSE
seek=loops(1)
ENDIF
SEEK #1,seek
c=INT((c2-c1)/4)*4
BPUT #1,meml+c1,c
bytes=LOF(#1)
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
@rettmem
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
IF c=1 THEN
IF virtwfile=FALSE THEN
loops(1)=c2
loope(1)=c2+(c2-c1)
ENDIF
@virtcopy(c1,c2,c2-c1)
ENDIF
IF c=-1 THEN
mm=c1-(c2-c1)
IF mm<0 THEN
mm=0
ENDIF
IF virtwfile=FALSE THEN
loope(1)=c1
loops(1)=c1-(c2-c1)
IF loops(1)<0 THEN
loops(1)=c1
loope(1)=c2
ENDIF
ENDIF
@virtcopy(c1,mm,c2-c1)
ENDIF
IF c=-2 THEN
IF virtwfile=FALSE THEN
loope(1)=c2-c1
loops(1)=0
ENDIF
@virtcopy(c1,0,c2-c1)
ENDIF
IF c=2 THEN
IF virtwfile=FALSE THEN
loops(1)=vmem-(c2-c1)
loope(1)=vmem
ENDIF
@virtcopy(c1,virtln-(c2-c1),c2-c1)
ENDIF
IF xmp=0 AND c=0 THEN
xmo=INT(xmo/4)*4
c1=INT(c1/4)*4
c2=INT(c2/4)*4
@virtcopy(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
@restaura
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE movingmark
.| Glob. Var.: cm1#,c1#,xmo#,i#,loopz#,cm2#,sms#,sme#
.| Felder    : loops#(),loope#()
.| Ruft auf  : blocklook,selblkstxt,selblketxt
.| Aufruf in : smpmhlp-1,
@blocklook
IF cm1<=c1 THEN
xmo=c1-cm1
ELSE
xmo=cm1-c1
xmo=-xmo
ENDIF
FOR i=1 TO loopz
IF loops(i)>=cm1 AND loops(i)<=cm2 AND sms<>i THEN
loops(i)=loops(i)+xmo
@selblkstxt(i,CHR$(0))
ENDIF
NEXT i
FOR i=1 TO loopz
IF loope(i)>=cm1 AND loope(i)<=cm2 AND sme<>i THEN
loope(i)=loope(i)+xmo
@selblketxt(i,CHR$(0))
ENDIF
NEXT i
RETURN
'
> PROCEDURE smpmhlp
.| Glob. Var.: moveart#,sms#,sme#,loopz#,cm1#,c1#,cm2#,c2#,sblock#,xm#,ce#
.|     virtual#,a#,lfw$,mlen#,workfile$,xmp#,mcs#,meml#,mce#,memh#,bytes#
.|     virtfile$,m#,mrkstax#,mrkeax#,xmo#,vmem#,ncs#,path$,smpnam$,noblkdel#
.|     makevirt3#,workf$,virt$,n#,g#,virtwfile#,virtln#,cached#
.| Felder    : loops#(),loope#()
.| Ruft auf  : movefrag,markhlp,blocklook,rettmem,maschinit9,maschruf9,nomem
.|     memtovirt2,virtmove,movingmark,restaura
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,edhandler2-1,
@movefrag
IF moveart>0 THEN
IF sms<>0 AND sme<>0 AND sms<loopz AND sme<loopz THEN
@markhlp
@blocklook
cm1=c1
cm2=c2
IF sblock=1 THEN
IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 THEN
IF virtual=FALSE THEN
sms=1
sme=1
IF moveart=3 THEN                       ! CLEAR/INS
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF xmp=1 AND mcs>meml THEN          ! zum Anfang
BPUT #1,mcs,mce-mcs
@rettmem
@maschinit9
@maschruf9(mcs,mce)
BPUT #1,meml,memh-meml
loops(1)=0
loope(1)=c2-c1
bytes=LOF(#1)
ENDIF
IF xmp=3 THEN                       ! ans Ende
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#2,lfw$+virtfile$
BPUT #2,mcs,mce-mcs
CLOSE #2
@rettmem
@maschinit9
@maschruf9(mcs,mce)
BPUT #1,meml,memh-meml
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
bytes=LOF(#1)
loops(1)=mlen
loope(1)=bytes
CLOSE #2
KILL lfw$+virtfile$
ELSE
@nomem
ENDIF
ENDIF
IF xmp=2 THEN                        ! zur Mitte
m=((memh-meml)/2)+meml-((mce-mcs)/2)
m=INT(m/4)*4
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#2,lfw$+virtfile$
BPUT #2,mcs,mce-mcs
CLOSE #2
@rettmem
@maschinit9
@maschruf9(mcs,mce)
BPUT #1,meml,m-meml
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
BPUT #1,m,memh-m
CLOSE #2
KILL lfw$+virtfile$
bytes=LOF(#1)
loops(1)=m-meml
loope(1)=(m-meml)+(c2-c1)
ELSE
@nomem
ENDIF
ENDIF
IF xmp=0 THEN                     ! Maus-move
mrkstax=loops(1)
mrkeax=loope(1)
loops(1)=INT((c1+xmo)/4)*4
loope(1)=INT((c2+xmo)/4)*4
IF loops(1)<0 THEN
loops(1)=0
loope(1)=c2-c1
ENDIF
IF loope(1)>vmem THEN
loope(1)=INT(vmem/4)*4
loops(1)=loope(1)-(c2-c1)
ENDIF
ncs=loops(1)+meml
ncs=INT(ncs/4)*4
IF DFREE(a)>(c2-c1) THEN
@rettmem
OPEN "O",#2,lfw$+virtfile$
BPUT #2,mcs,mce-mcs
CLOSE #2
@maschinit9
@maschruf9(mcs,mce)
BPUT #1,meml,ncs-meml
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
BPUT #1,ncs,memh-ncs
CLOSE #2
KILL lfw$+virtfile$
bytes=LOF(#1)
ELSE
@nomem
ENDIF
ENDIF
loops(1)=INT(loops(1)/4)*4
loope(1)=INT(loope(1)/4)*4
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 OR moveart=1 OR moveart=2 THEN
IF xmp=1 AND mcs>meml THEN          ! zum Anfang
@maschinit9
IF moveart=4 THEN
BMOVE mcs,meml,mce-mcs
IF mcs>meml+(mce-mcs) THEN
@maschruf9(mcs,mce)
ELSE
@maschruf9(meml+(mce-mcs),mce)
ENDIF
ENDIF
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
IF moveart=2 THEN                            ! CUT/INS
BMOVE meml,meml+(mce-mcs),mlen-(mce-mcs)
ENDIF
OPEN "I",#1,virt$
BGET #1,meml,mce-mcs
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ENDIF
loops(1)=0
loope(1)=c2-c1
ENDIF
IF xmp=3 THEN                        ! ans Ende
@maschinit9
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,lfw$+virtfile$
BPUT #1,mcs,mce-mcs
CLOSE #1
IF moveart=1 THEN                ! CUT/COPY
BMOVE mce,mcs,memh-mce
OPEN "I",#1,lfw$+virtfile$
BGET #1,memh-(mce-mcs),mce-mcs
CLOSE #1
KILL lfw$+virtfile$
loope(1)=(INT(vmem/4)*4)
loops(1)=loope(1)-(c2-c1)
ENDIF
IF moveart=2 THEN                ! CUT/INS
@rettmem
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
BPUT #1,meml,mlen
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
CLOSE #2
KILL lfw$+virtfile$
bytes=LOF(#1)
loops(1)=mlen
loope(1)=bytes
loops(1)=INT(loops(1)/4)*4
loope(1)=INT(loope(1)/4)*4
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 THEN            ! CLEAR/COPY
IF mce<memh-(mce-mcs) THEN
BMOVE mcs,memh-(mce-mcs),mce-mcs
@maschruf9(mcs,mce)
loope(1)=(INT(vmem/4)*4)
loops(1)=loope(1)-(c2-c1)
ELSE
BMOVE mcs,memh-(mce-mcs),mce-mcs
@maschruf9(mcs,memh-(mce-mcs))
loope(1)=INT(vmem/4)*4
loops(1)=loope(1)-(c2-c1)
ENDIF
ENDIF
ENDIF
IF xmp=2 THEN                        ! zur Mitte
m=((memh-meml)/2)+meml-((mce-mcs)/2)
m=INT(m/4)*4
@maschinit9
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
IF moveart=2 THEN                            ! CUT/INS
BMOVE m,m+(mce-mcs),memh-m-(mce-mcs)
ENDIF
OPEN "I",#1,virt$
BGET #1,m,mce-mcs
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 THEN
IF mcs>=m+(mce-mcs) OR mce<m THEN
BMOVE mcs,m,mce-mcs
@maschruf9(mcs,mce)
ENDIF
IF mcs<m+(mce-mcs) AND mcs>=m AND mce>m+(mce-mcs) THEN
BMOVE mcs,m,mce-mcs
@maschruf9(m+(mce-mcs),mce)
ENDIF
IF mcs<m AND mce>=m AND mce<m+(mce-mcs) THEN
BMOVE mcs,m,mce-mcs
@maschruf9(mcs,m-1)
ENDIF
ENDIF
n=INT((c2-c1)/2)
loops(1)=INT((vmem/2-n)/4)*4
loope(1)=loops(1)+(c2-c1)
ENDIF
IF xmp=0 THEN                     ! Maus-move
mrkstax=loops(1)
mrkeax=loope(1)
loops(1)=INT((c1+xmo)/4)*4
loope(1)=INT((c2+xmo)/4)*4
IF loops(1)<0 THEN
loops(1)=0
loope(1)=c2-c1
ENDIF
IF loope(1)>vmem THEN
loope(1)=INT(vmem/4)*4
loops(1)=loope(1)-(c2-c1)
ENDIF
ncs=loops(1)+meml
ncs=INT(ncs/4)*4
@maschinit9
IF moveart=1 OR moveart=2 THEN
IF ncs<mcs OR ncs>mce THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
OPEN "I",#1,virt$
IF mce<=ncs THEN
IF moveart=2 THEN                            ! CUT/INS
BMOVE ncs-(mce-mcs),ncs,memh-ncs
ENDIF
BGET #1,ncs-(mce-mcs),mce-mcs
loops(1)=loops(1)-(mce-mcs)
loops(1)=INT(loops(1)/4)*4
loope(1)=loope(1)-(mce-mcs)
loope(1)=INT(loope(1)/4)*4
ELSE
IF moveart=2 THEN                            ! CUT/INS
BMOVE ncs,ncs+(mce-mcs),memh-ncs-(mce-mcs)
ENDIF
BGET #1,ncs,mce-mcs
ENDIF
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ELSE
loops(1)=mrkstax
loope(1)=mrkeax
ALERT 1,"Sorry, aber das macht|keinen Sinn !",1,"EXIT",g
ENDIF
ENDIF
IF moveart=4 THEN
BMOVE mcs,ncs,mce-mcs
IF mcs>=ncs+(mce-mcs) OR mce<ncs THEN
@maschruf9(mcs,mce)
ENDIF
IF mcs<ncs+(mce-mcs) AND mcs>=ncs AND mce>ncs+(mce-mcs) THEN
@maschruf9(ncs+(mce-mcs),mce)
ENDIF
IF mcs<ncs AND mce>=ncs AND mce<ncs+(mce-mcs) THEN
@maschruf9(mcs,ncs-1)
ENDIF
ENDIF
ENDIF
ENDIF
ELSE
IF moveart>0 THEN
IF xmp=1 AND mcs>meml THEN        ! an Anfang
IF virtwfile=FALSE THEN
loope(1)=c2-c1
loops(1)=0
ENDIF
@virtmove(c1,0,c2-c1)
ENDIF
IF xmp=2 THEN                     ! zur Mitte
n=INT((c2-c1)/2)
n=INT((vmem/2-n)/4)*4
IF virtwfile=FALSE THEN
loops(1)=n
loope(1)=loops(1)+(c2-c1)
ENDIF
@virtmove(c1,n,c2-c1)
ENDIF
IF xmp=3 THEN                     ! ans Ende
IF virtwfile=FALSE THEN
IF moveart=4 OR moveart=1 THEN
loops(1)=vmem-(c2-c1)
loope(1)=vmem
ELSE
loops(1)=vmem
loope(1)=vmem+(c2-c1)
ENDIF
ENDIF
IF moveart=4 OR moveart=1 THEN
@virtmove(c1,virtln-(c2-c1),c2-c1)
ELSE
@virtmove(c1,virtln,c2-c1)
ENDIF
ENDIF
IF xmp=0 THEN             ! Maus-move
xmo=INT(xmo/4)*4
c1=INT(c1/4)*4
c2=INT(c2/4)*4
@virtmove(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
ENDIF
cached=FALSE
@movingmark
@restaura
ENDIF
ELSE
ALERT 1,"Block undefiniert !",1,"EXIT",g
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE smpihlp                     ! Routine fÅr mem fehlt noch
.| Glob. Var.: mrkp$,mp$,g#,sms#,sme#,loopz#,xm#,ce#,c2#,c1#,virtual#
.|     sblock#,xmp#,xmo#,mlen#,m#,vmem#,ncs#,meml#,a#,lfw$,workfile$,cached#
.|     b#,bytes#,path$,smpnam$,noblkdel#,makevirt3#,workf$,virtwfile#
.|     virtln#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp,blocklook,busy_mouse,nomem,rettmem,memtovirt2,virtins
.|     restaura
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,edhandler2-1,
LOCAL makev
mrkp$=mp$
makev=FALSE
ALERT 2,"EinfÅgen ?",1,"JA|NEIN",g
IF g=1 THEN
IF sms<>0 AND sme<>0 AND sms<loopz AND sme<loopz THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 THEN
IF virtual=FALSE THEN
IF sblock=1 THEN
IF xmp=1 THEN
xmo=-c1
ENDIF
IF xmp=3 THEN
xmo=mlen-c2
ENDIF
IF xmp=2 THEN
m=mlen/2
m=INT(m/4)*4
xmo=m-c1
ENDIF
IF loops(loopz)>=0 AND loope(loopz)<=mlen THEN
sms=1
sme=1
IF mlen>=(c2+xmo) AND (c1+xmo)>=0 THEN
xmo=INT(xmo/4)*4
IF ((c1+xmo)<=loope(loopz) AND (loope(loopz)+(c2-c1))<=mlen) OR ((c1+xmo)>loope(loopz) AND (c1+xmo+(c2-c1))<=mlen) THEN
loops(1)=INT((c1+xmo)/4)*4
loope(1)=INT((c2+xmo)/4)*4
IF loops(1)<0 THEN
loops(1)=0
loope(1)=c2-c1
ENDIF
IF loope(1)>vmem THEN
loope(1)=INT(vmem/4)*4
loops(1)=loope(1)-(c2-c1)
ENDIF
ncs=loops(1)+meml
ncs=INT(ncs/4)*4
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>=(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
@busy_mouse
BPUT #1,c1+meml,c2-c1
CLOSE #1
IF ((c1+xmo)<=loope(loopz) AND (loope(loopz)+(c2-c1))<=mlen) THEN
BMOVE ncs,ncs+(c2-c1),loope(loopz)-loops(1)
loope(loopz)=loope(loopz)+(c2-c1)
ENDIF
OPEN "I",#1,lfw$+workfile$
@busy_mouse
BGET #1,ncs,c2-c1
CLOSE #1
KILL lfw$+workfile$
cached=FALSE
ELSE
@nomem
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
ALERT 1,"Block undefiniert !",1,"EXIT",g
ENDIF
IF makev=TRUE THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF loops(loopz)>=0 AND loope(loopz)<=mlen AND sblock=1 THEN
a=loops(loopz)
b=loope(loopz)
ELSE
a=0
b=mlen
ENDIF
IF a>=0 AND b<=mlen THEN
IF (c1+xmo)<a THEN
@busy_mouse
BPUT #1,meml+c1,c2-c1
BPUT #1,meml+a,b-a
ENDIF
IF (c1+xmo)>=a AND (c1+xmo)<=b THEN
@busy_mouse
BPUT #1,meml+a,(c1+xmo)-a
BPUT #1,meml+c1,c2-c1
IF (c1+xmo)<b THEN
BPUT #1,meml+c1+xmo,b-(c1+xmo)
ENDIF
ENDIF
IF (c1+xmo)>b THEN
@busy_mouse
BPUT #1,meml,b-a
BPUT #1,meml+c1,c2-c1
ENDIF
ENDIF
bytes=LOF(#1)
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
@rettmem
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
IF xmp=1 THEN
IF virtwfile=FALSE THEN
loops(1)=0
loope(1)=c2-c1
ENDIF
@virtins(c1,0,c2-c1)
ENDIF
IF xmp=2 THEN
m=(virtln/2)
m=INT(m/4)*4
IF virtwfile=FALSE THEN
loops(1)=m
loope(1)=m+(c2-c1)
ENDIF
@virtins(c1,m,c2-c1)
ENDIF
IF xmp=3 THEN
IF virtwfile=FALSE THEN
loops(1)=virtln
loope(1)=virtln+(c2-c1)
ENDIF
@virtins(c1,virtln,c2-c1)
ENDIF
IF xmp=0 THEN
xmo=INT(xmo/4)*4
c1=INT(c1/4)*4
c2=INT(c2/4)*4
@virtins(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
@restaura
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE markprod2
.| Glob. Var.: i#,loopz#,t$,a#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhandler,markhlp3
.| Aufruf in : edhandler2-1,
FOR i=1 TO loopz-1
IF loops(i)<>-1 THEN
t$=CHR$(ASC("a")-1+i)
a=loops(i)
@markhandler(a)
loops(i)=a
@markhlp3(i,loops(i))
ENDIF
NEXT i
IF loops(loopz)<>-1 THEN
t$="s"
a=loops(loopz)
@markhandler(a)
loops(loopz)=a
@markhlp3(loopz,loops(loopz))
ENDIF
FOR i=1 TO loopz-1
IF loope(i)<>-1 THEN
t$=CHR$(ASC("A")-1+i)
a=loope(i)
@markhandler(a)
loope(i)=a
@markhlp3(i+loopz,loope(i))
ENDIF
NEXT i
IF loope(loopz)<>-1 THEN
t$="S"
a=loope(loopz)
@markhandler(a)
loope(loopz)=a
@markhlp3(loopz*2,loope(loopz))
ENDIF
RETURN
'
> PROCEDURE markprod3
.| Glob. Var.: nr#,smpedit&,i#,loopz#,t$,master#,sms#,sme#,a#,masthlp#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp3,markhlp6,selblkshak,selblkehak,textfeld
.| Aufruf in : message-2,restaura4-1,smpedit-1,time_edit-1,record2-1,
IF nr=smpedit& THEN
@makehz
@sethertz
FOR i=1 TO loopz-1
IF loops(i)<>-1 THEN
t$=CHR$(ASC("a")-1+i)
@markhlp3(i,loops(i))
@markhlp6(loops(i))
ENDIF
NEXT i
IF loops(loopz)<>-1 THEN
t$="s"
@markhlp3(loopz,loops(loopz))
@markhlp6(loops(loopz))
ENDIF
FOR i=1 TO loopz-1
IF loope(i)<>-1 THEN
t$=CHR$(ASC("A")-1+i)
@markhlp3(i+loopz,loope(i))
@markhlp6(loope(i))
ENDIF
NEXT i
IF loope(loopz)<>-1 THEN
t$="S"
@markhlp3(loopz*2,loope(loopz))
@markhlp6(loope(loopz))
ENDIF
FOR i=1 TO loopz-1
IF master=0 AND sms=i THEN
master=i
ENDIF
NEXT i
FOR i=1 TO loopz-1
IF master=0 AND sme=i THEN
master=i+loopz
ENDIF
NEXT i
IF master>0 AND master<loopz THEN
@selblkshak(master,a)
masthlp=a
ENDIF
IF master>loopz AND master<loopz*2 THEN
@selblkehak(master-loopz,a)
masthlp=a
ENDIF
IF master<>0 AND master<>loopz AND master<>loopz*2 THEN
@textfeld(masthlp,""+CHR$(0),1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE smph2
.| Glob. Var.: master#,loopz#,t$,a#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhandl2,markhlp3
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,
IF master>0 AND master<loopz THEN
t$=CHR$(ASC("a")-1+master)
a=loops(master)
@markhandl2(a)
loops(master)=a
@markhlp3(master,loops(master))
ENDIF
IF master>loopz AND master<loopz*2 THEN
t$=CHR$(ASC("A")-1+master-loopz)
a=loope(master-loopz)
@markhandl2(a)
loope(master-loopz)=a
@markhlp3(master,loope(master-loopz))
ENDIF
IF master=loopz THEN
t$="s"
a=loops(loopz)
@markhandl2(a)
loops(loopz)=a
@markhlp3(loopz,loops(loopz))
ENDIF
IF master=loopz*2 THEN
t$="S"
a=loope(loopz)
@markhandl2(a)
loope(loopz)=a
@markhlp3(master,loope(loopz))
ENDIF
RETURN
'
> PROCEDURE smpanf
.| Glob. Var.: smark#,xmo#,xmp#,c#,x#,lzhold#,lz#,smpanf&
.| Ruft auf  : smpmhlp,smpihlp,smpkhlp,smph1,smph2,zoomhelp,setbutton
.|     flipptest
.| Aufruf in : do_smpedit-1,
IF smark=6 THEN
xmo=0
xmp=1
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=0
xmp=1
@smpihlp
ENDIF
IF smark=5 THEN
c=-2
@smpkhlp
ENDIF
IF smark=3 THEN
@smph1
x=0
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=1
@zoomhelp
ENDIF
@setbutton(smpanf&,0)
@flipptest
RETURN
'
> PROCEDURE smpend
.| Glob. Var.: smark#,xmp#,xmo#,xm#,c#,x#,vmem#,lzhold#,lz#,lzmrk#,smpend&
.| Ruft auf  : smpmhlp,smpihlp,smpkhlp,smph1,smph2,zoomhelp,setbutton
.|     flipptest
.| Aufruf in : do_smpedit-1,
IF smark=6 THEN
xmp=3
xmo=xm
@smpmhlp
ENDIF
IF smark=4 THEN
xmp=3
xmo=xm
@smpihlp
ENDIF
IF smark=5 THEN
c=2
@smpkhlp
ENDIF
IF smark=3 THEN
@smph1
x=vmem
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=lzmrk
@zoomhelp
ENDIF
@setbutton(smpend&,0)
@flipptest
RETURN
'
> PROCEDURE smpmid
.| Glob. Var.: smark#,xmo#,xm#,xmp#,x#,vmem#,lzhold#,lz#,lzmrk#,smpmid&
.| Ruft auf  : smpmhlp,smpihlp,smph1,smph2,zoomhelp,setbutton,flipptest
.| Aufruf in : do_smpedit-1,
IF smark=6 THEN
xmo=xm/2
xmp=2
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=xm/2
xmp=2
@smpihlp
ENDIF
IF smark=3 THEN
@smph1
x=INT(vmem/2)
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=INT(lzmrk/2)
IF lz=0 THEN
lz=1
ENDIF
@zoomhelp
ENDIF
@setbutton(smpmid&,0)
@flipptest
RETURN
'
> PROCEDURE zoomhelp
.| Glob. Var.: lz#,cs#,ce#,zoomstop#,lzhold#,xm#,cached#
.| Felder    : lce#(),lcs#()
.| Ruft auf  : curvetest,markhlp,zslidecalc,restaura
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,
IF lce(lz)>0 THEN
cs=lcs(lz)
ce=lce(lz)
ENDIF
@curvetest(cs,ce)
IF zoomstop=FALSE THEN
@markhlp
ELSE
lz=lzhold
ENDIF
IF xm>0 AND ce>cs THEN
@zslidecalc
cached=FALSE
@restaura
ENDIF
RETURN
'
> PROCEDURE smpl
.| Glob. Var.: c#,smark#,xmp#,obj#,smpl1&,smpl2&,smpl3&,xmo#,c2#,c1#,ce#,cs#
.|     xm#,x#,lz#,xs#,v#,v2#,v3#,v4#,lzhold#,memh#,cached#,u#,fadericht#
.| Ruft auf  : markhlp,blocklook,smpmhlp,smpihlp,smpkhlp,smph1,smph2
.|     zoomhelp,zslidecalc,restaura,fade_it,flipptest
.| Aufruf in : do_smpedit-1,
LOCAL mf
@markhlp
c=0
IF smark=6 OR smark=4 THEN
xmp=0
@blocklook
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
IF obj=smpl1& THEN
xmo=INT((c2-c1)/16)*4
xmo=-xmo
ENDIF
IF obj=smpl2& THEN
xmo=INT((c2-c1)/8)*4
xmo=-xmo
ENDIF
IF obj=smpl3& THEN
xmo=INT((c2-c1)/4)*4
xmo=-xmo
ENDIF
IF smark=6 THEN
@smpmhlp
ELSE
@smpihlp
ENDIF
ENDIF
ENDIF
IF smark=5 THEN
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
c=-1
@smpkhlp
ENDIF
ENDIF
IF smark=3 THEN
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
@smph1
mf=INT((ce-cs)/xm/4)*4
IF obj=smpl1& THEN
IF ((ce-cs)/4)>xm THEN
x=x-1*mf
ELSE
x=x-4
ENDIF
ENDIF
IF obj=smpl2& THEN
IF ((ce-cs)/4)>xm THEN
x=x-3*mf
ELSE
x=x-3*4
ENDIF
ENDIF
IF obj=smpl3& THEN
IF ((ce-cs)/4)>xm THEN
x=x-10*mf
ELSE
x=x-10*4
ENDIF
ENDIF
@smph2
ENDIF
ENDIF
IF smark=2 THEN
IF lz>1 THEN
@smph1
IF obj=smpl1& THEN
xs=1
ENDIF
IF obj=smpl2& THEN
xs=2
ENDIF
IF obj=smpl3& THEN
xs=3
ENDIF
IF lz>xs AND (obj=smpl1& OR obj=smpl2& OR obj=smpl3&) THEN
~WIND_UPDATE(3)
~GRAF_MKSTATE(v,v2,v3,v4)
~WIND_UPDATE(2)
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& AND v4=0 THEN
lzhold=lz
lz=lz-xs
@zoomhelp
ENDIF
IF obj=smpl1& AND v4<>0 THEN
ce=((ce-cs)*1.5)+cs
IF ce>memh THEN
ce=memh
ENDIF
ce=INT(ce/4)*4
IF xm>0 AND ce>cs THEN
@zslidecalc
cached=FALSE
@restaura
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF smark=1 THEN
IF obj=smpl1& THEN
xs=(ce-cs)/4
ENDIF
IF obj=smpl2& THEN
xs=(ce-cs)/2
ENDIF
IF obj=smpl3& THEN
xs=ce-cs
ENDIF
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
IF cs-xs>0 THEN
cs=cs-xs
cs=INT(cs/4)*4
ce=ce-xs
ce=INT(ce/4)*4
ELSE
u=cs
cs=0
ce=ce-u
ce=INT(ce/4)*4
ENDIF
cached=FALSE
@restaura
ENDIF
ENDIF
IF smark=8 THEN
fadericht=0
@fade_it
ENDIF
@flipptest
RETURN
'
> PROCEDURE smpr
.| Glob. Var.: c#,smark#,xmp#,obj#,smpr1&,smpr2&,smpr3&,xmo#,c2#,c1#,ce#,cs#
.|     xm#,x#,lz#,lmax#,xs#,xmul#,zoomstop#,i#,loopz#,sms#,dcs#,sme#,dce#
.|     lzmrk#,cached#,g#,vmem#,u#,fadericht#
.| Felder    : lcs#(),lce#(),loops#(),loope#()
.| Ruft auf  : markhlp,blocklook,smpmhlp,smpihlp,smpkhlp,smph1,smph2
.|     curvetest,zslidecalc,restaura,fade_it,flipptest
.| Aufruf in : do_smpedit-1,
LOCAL mf
@markhlp
c=0
IF smark=6 OR smark=4 THEN
xmp=0
@blocklook
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
IF obj=smpr1& THEN
xmo=INT((c2-c1)/16)*4
ENDIF
IF obj=smpr2& THEN
xmo=INT((c2-c1)/8)*4
ENDIF
IF obj=smpr3& THEN
xmo=INT((c2-c1)/4)*4
ENDIF
IF smark=6 THEN
@smpmhlp
ELSE
@smpihlp
ENDIF
ENDIF
ENDIF
IF smark=5 THEN
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
c=1
@smpkhlp
ENDIF
ENDIF
IF smark=3 THEN
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@smph1
mf=INT((ce-cs)/xm/4)*4
IF obj=smpr1& THEN
IF ((ce-cs)/4)>xm THEN
x=x+1*mf
ELSE
x=x+4
ENDIF
ENDIF
IF obj=smpr2& THEN
IF ((ce-cs)/4)>xm THEN
x=x+3*mf
ELSE
x=x+3*4
ENDIF
ENDIF
IF obj=smpr3& THEN
IF ((ce-cs)/4)>xm THEN
x=x+10*mf
ELSE
x=x+10*4
ENDIF
ENDIF
@smph2
ENDIF
ENDIF
IF smark=2 THEN
IF lz<lmax THEN
@smph1
IF obj=smpr1& THEN
xs=1
xmul=1.5
ENDIF
IF obj=smpr2& THEN
xs=1
xmul=2
ENDIF
IF obj=smpr3& THEN
xs=1
xmul=3
ENDIF
IF (lz+xs)<lmax AND (obj=smpr1& OR obj=smpr2& OR obj=smpr3&) THEN
@curvetest(cs,ce)
IF zoomstop=FALSE THEN
lcs(lz)=cs
lce(lz)=ce
@markhlp
FOR i=1 TO loopz-1
IF sms=i THEN
dcs=loops(i)
ENDIF
NEXT i
FOR i=1 TO loopz-1
IF sme=i THEN
dce=loope(i)
ENDIF
NEXT i
IF sms=0 THEN
dcs=0
ENDIF
IF sme=0 THEN
dce=INT(ce-cs)
ENDIF
lz=lz+xs
lzmrk=lz
cs=dcs
IF dce>=ce THEN
ce=INT(((ce-cs)/xmul)+cs)
ELSE
ce=dce
ENDIF
ce=INT(ce/4)*4
lcs(lz)=cs
lce(lz)=ce
IF xm>0 AND ce>cs THEN
@zslidecalc
cached=FALSE
@restaura
ENDIF
ELSE
ALERT 1,"Sample-Auflîsungsgrenze|erreicht !",1,"OK",g
ENDIF
ENDIF
ENDIF
ENDIF
IF smark=1 THEN
IF obj=smpr1& THEN
xs=(ce-cs)/4
ENDIF
IF obj=smpr2& THEN
xs=(ce-cs)/2
ENDIF
IF obj=smpr3& THEN
xs=ce-cs
ENDIF
IF ce+xs<vmem THEN
cs=cs+xs
cs=INT(cs/4)*4
ce=ce+xs
ce=INT(ce/4)*4
ELSE
u=vmem-ce
cs=cs+u
cs=INT(cs/4)*4
ce=ce+u
ce=INT(ce/4)*4
ENDIF
cached=FALSE
@restaura
ENDIF
IF smark=8 THEN
fadericht=1
@fade_it
ENDIF
@flipptest
RETURN
'
> PROCEDURE movemark(strtmark,mdif)
.| Glob. Var.: i#,loopz#
.| Felder    : loops#(),loope#()
.| Aufruf in : smpcut-1,
FOR i=1 TO loopz
IF (loops(i)>(strtmark-mdif) AND mdif<0) OR (loops(i)<strtmark AND mdif>0) THEN
loops(i)=loops(i)+mdif
ENDIF
NEXT i
FOR i=1 TO loopz
IF (loope(i)>(strtmark-mdif) AND mdif<0) OR (loope(i)<strtmark AND mdif>0) THEN
loope(i)=loope(i)+mdif
ENDIF
NEXT i
RETURN
'
> PROCEDURE smpcut
.| Glob. Var.: vobj#,obj#,sms#,sme#,loopz#,cutexit&,xm#,ce#,c2#,c1#,virtual#
.|     cutout&,mcs#,meml#,memh#,mce#,cutin&,cutdel&,virtln2#,virtln#
.|     virtwfile#,virtpath$,a#,virtp$,virtfile$,seekz#,mlen#,bytes#,path$
.|     smpnam$,vmem#,noblkdel#
.| Ruft auf  : markhlp,blocklook,maschinit9,maschruf9,movemark,busy_mouse
.|     hardproof3,memtovirt2,nomem,setbutton,blkrestaura
.| Aufruf in : do_blkf-1,
LOCAL okay,vln,ml,delrange
vobj=obj
@setbutton(vobj,1)
IF sms<>0 AND sme<>0 AND sms<loopz AND sme<loopz AND obj<>cutexit& THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND sme<>0 AND c2>c1 THEN
@maschinit9
IF virtual=FALSE THEN
IF obj=cutout& THEN
IF mcs>meml THEN
@maschruf9(meml,mcs)
ENDIF
IF memh>mce THEN
@maschruf9(mce,memh)
ENDIF
ENDIF
IF obj=cutin& THEN
@maschruf9(mcs,mce)
ENDIF
IF obj=cutdel& THEN
IF mce>mcs AND mcs>=meml THEN
mce=INT(mce/4)*4
@maschinit9
@maschruf9(mcs,mce)
IF mce<memh THEN
delrange=(memh-(mce+4))
BMOVE mce+4,mcs,delrange
@maschruf9(memh-(mce-mcs),memh)
@movemark(c1,c1-c2)
ENDIF
ENDIF
ENDIF
ELSE
virtln2=virtln
c1=INT(c1/4)*4
c2=INT(c2/4)*4
virtln2=INT(virtln2/4)*4
okay=FALSE
IF virtwfile=FALSE AND obj<>cutdel& THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
seekz=0
ml=INT(mlen/4)*4
IF c1>0 THEN
IF okay=TRUE THEN
vln=c1
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=ml
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutout& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln=0
ENDIF
ENDIF
virtln2=virtln2-seekz
IF c2>c1 AND c2<=virtln THEN
IF okay=TRUE THEN
vln=c2-c1
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutin& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
IF obj<>cutdel& THEN
BPUT #2,meml,bytes
ENDIF
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln=0
virtln2=virtln2-(c2-c1)
ENDIF
ENDIF
IF c2<virtln THEN
IF okay=TRUE THEN
vln=virtln2
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutout& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
ENDIF
ENDIF
IF okay=TRUE THEN
CLOSE #1
IF virtwfile=TRUE OR obj=cutdel& THEN
CLOSE #2
ENDIF
IF virtwfile=FALSE AND obj=cutdel& THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
@memtovirt2
ENDIF
IF virtwfile=FALSE AND (obj=cutin& OR obj=cutout&) THEN
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
ENDIF
ENDIF
ENDIF
PAUSE 3
@setbutton(vobj,0)
@blkrestaura
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
RETURN
'
> PROCEDURE movefrag
.| Glob. Var.: vornr#,nr#,moving&,obj#,popup&,zu%,zuadr#,buttadr#,but#
.|     objadr#,objflag#,movhlp&,mvcutcpy&,mvcutins&,mvclrins&,mvclrcpy&
.|     movexit&,moveart#
.| Ruft auf  : rsc_draw,markhlp,rsc_do,xrsrc_gaddr,mousek,helptxt,setbutton
.|     restaura2
.| Aufruf in : smpmhlp-1,
vornr=nr
nr=moving&
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=movhlp& THEN
@helptxt("MOVE")
ENDIF
UNTIL obj=mvcutcpy& OR obj=mvcutins& OR obj=mvclrins& OR obj=mvclrcpy& OR obj=movexit&
@setbutton(obj,0)
moveart=0
IF obj=mvcutcpy& THEN
moveart=1
ENDIF
IF obj=mvcutins& THEN
moveart=2
ENDIF
IF obj=mvclrins& THEN
moveart=3
ENDIF
IF obj=mvclrcpy& THEN
moveart=4
ENDIF
@restaura2
obj=0
RETURN
'
> PROCEDURE virtmove(ks,kd,kl)
.| Glob. Var.: sms#,sme#,virtln#,a#,virtpath$,vln#,moveart#,virtwfile#
.|     virtp$,virtfile$,bytes#,mlen#,meml#,seek#,memh#,path$,smpnam$,vmem#
.|     g#
.| Ruft auf  : busy_mouse,maschinit9,maschruf9,hardproof3,memtovirt2,nomem
.| Aufruf in : smpmhlp-5,
IF ks<>kd THEN
sms=1
sme=1
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=vln+kl THEN
IF moveart=4 OR ((moveart=1 OR moveart=3 OR moveart=2) AND (kd>ks+kl OR kd<ks))
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 OR moveart=3 OR moveart=2 THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
IF moveart=4 THEN               ! CLR/COPY
vln=virtln
ENDIF
IF moveart=1 OR (moveart=2 AND kd>ks+kl) THEN               ! CUT/COPY
vln=ks
ENDIF
IF moveart=3 OR (moveart=2 AND kd<ks) THEN               ! CLR/INS
vln=kd
ENDIF
bytes=INT(mlen/4)*4
IF vln>0 THEN
REPEAT                          ! Source in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
IF moveart=3 OR (moveart=2 AND kd<ks) THEN
seek=0
vln=kl
bytes=INT(mlen/4)*4
REPEAT                          ! Sourceblock in Destblock kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
SEEK #1,ks+seek
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
IF moveart=1 OR moveart=3 OR (moveart=2 AND (kd>ks+kl OR kd<ks)) THEN    ! bei CUT/COPY den Sourceteil weglassen, den Rest kopieren
IF moveart=1 THEN
SEEK #1,ks+kl
vln=virtln-(ks+kl)
ENDIF
IF moveart=3 THEN
SEEK #1,kd
vln=virtln-kd
ENDIF
IF moveart=2 AND kd>ks+kl THEN    ! StÅck zwischen Sourceende und Destanfang kopieren
SEEK #1,ks+kl
vln=kd-(ks+kl)
ENDIF
IF moveart=2 AND kd<ks THEN   ! StÅck zwischen Destende und Sourceanfang kopieren
SEEK #1,kd
vln=ks-kd
ENDIF
vln=INT(vln/4)*4
bytes=INT(mlen/4)*4
IF vln>0 THEN
REPEAT                          ! Source in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ENDIF
IF moveart=2 AND (kd>ks+kl OR kd<ks) THEN
IF kd>ks+kl THEN
SEEK #1,ks
vln=kl
vln=INT(vln/4)*4
bytes=INT(mlen/4)*4
REPEAT                          ! Sourceblock in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
IF kd>ks+kl THEN
SEEK #1,kd
vln=virtln-kd
ENDIF
IF kd<ks THEN
SEEK #1,ks+kl
vln=virtln-(ks+kl)
ENDIF
vln=INT(vln/4)*4
bytes=INT(mlen/4)*4
IF vln>0 THEN
REPEAT                          ! Von Dest bis Ende in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ENDIF
CLOSE #2
OPEN "U",#2,virtp$
IF moveart<>2 THEN
IF kd<ks OR moveart=4 THEN
SEEK #2,kd
ELSE
SEEK #2,kd-kl
ENDIF
ENDIF
ELSE
OPEN "U",#1,virtpath$
ENDIF
IF moveart=1 OR moveart=4 THEN
vln=INT(kl/4)*4
bytes=INT(mlen/4)*4
seek=0
REPEAT                                ! Sourceblock nach Destblock kopieren
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
IF moveart=4 OR moveart=3 THEN                   ! nur fÅr CLR/COPY und CLR/INS
vln=INT(kl/4)*4
IF moveart=3 AND kd<ks AND kd+kl>ks THEN
vln=ks-kd
vln=INT(vln/4)*4
ENDIF
bytes=INT(mlen/4)*4
@maschinit9
IF vln>=bytes THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+vln)
ENDIF
seek=0
IF moveart=3 AND kd<ks
seek=kl
ENDIF
IF moveart=3 AND kd<ks AND kd+kl>ks THEN
seek=kl*2-vln
ENDIF
IF kd>ks AND kd<(ks+kl) AND moveart=4 THEN
vln=kd-ks
vln=INT(vln/4)*4
ENDIF
IF kd<ks AND kd+kl>ks AND moveart=4 THEN
vln=ks-kd
vln=INT(vln/4)*4
seek=kd+kl-ks
seek=INT(seek/4)*4
ENDIF
IF vln>0 THEN
REPEAT                             ! Source mit Zero Åberschreiben
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=3 THEN
SEEK #2,ks+seek
BPUT #2,meml,bytes
ELSE
SEEK #1,ks+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
ENDIF
CLOSE #1
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 OR moveart=3 OR moveart=2 THEN ! Source del,Dest-Source rename
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
ENDIF
IF virtwfile=FALSE THEN                                ! Display erneuern
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF (moveart=2 OR moveart=3 OR moveart=1) AND kd<=ks+kl AND kd>ks
ALERT 1,"Sorry, aber das macht|keinen Sinn !",1,"EXIT",g
ENDIF
ELSE
@nomem
ENDIF
ENDIF
RETURN
'
> PROCEDURE virtcopy(ks,kd,kl)
.| Glob. Var.: virtln#,a#,virtpath$,vln#,virtwfile#,virtp$,virtfile$,bytes#
.|     mlen#,meml#,seek#,path$,smpnam$,vmem#
.| Ruft auf  : busy_mouse,hardproof3,memtovirt2,nomem
.| Aufruf in : smpkhlp-5,
IF ks<>kd THEN
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=vln+kl THEN
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
vln=virtln
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #2
OPEN "U",#2,virtp$
SEEK #2,kd
ELSE
OPEN "U",#1,virtpath$
ENDIF
vln=INT(kl/4)*4
bytes=INT(mlen/4)*4
seek=0
REPEAT
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
CLOSE #1
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
ENDIF
IF virtwfile=FALSE THEN
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
ENDIF
RETURN
'
> PROCEDURE virtins(ks,kd,kl)
.| Glob. Var.: virtln#,a#,virtpath$,vln#,virtwfile#,virtp$,virtfile$,bytes#
.|     mlen#,meml#,seek#,path$,smpnam$,vmem#
.| Ruft auf  : busy_mouse,hardproof3,memtovirt2,nomem
.| Aufruf in : smpihlp-4,
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=vln+kl THEN
IF virtwfile=TRUE OR kd<virtln THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
vln=INT(kd/4)*4
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
'
vln=INT(kl/4)*4
bytes=INT(mlen/4)*4
SEEK #1,ks
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
'
vln=INT((virtln-kd)/4)*4
bytes=INT(mlen/4)*4
SEEK #1,kd
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
CLOSE #1
CLOSE #2
ELSE
OPEN "U",#1,virtpath$
vln=INT(kl/4)*4
bytes=INT(mlen/4)*4
seek=0
REPEAT
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
CLOSE #1
ENDIF
IF virtwfile=FALSE AND kd<virtln THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
IF virtwfile=FALSE THEN
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE markhandl4
.| Glob. Var.: y#,stay1#,stay2#,smark#,xmp#,c#,tx#,x#,vc1#,tx2#,vc2#,tm#
.|     tm2#,d1#,d2#,ag#,xd#,mdat%,ag2#,mdat2%,k#,xm#,x2#,t$,t2$
.| Ruft auf  : mousey,rsc_get2,rsc_put,mouse
.| Aufruf in : edhandler2-1,
y=@mousey
IF y>=stay1 AND y<=stay2 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
IF smark=6 OR smark=5 OR smark=4 THEN
xmp=0
c=0
ENDIF
tx=x-(x-vc1)
tx2=x+(vc2-x)
tm=tx
tm2=tx2
COLOR 0
GRAPHMODE 3
COLOR 1
d1=x-vc1
d2=vc2-x
GRAPHMODE 3
ag=@rsc_get2(tx+xd,stay1,tx2-tx+1,stay2-stay1+1,mdat%)
ag2=@rsc_get2(tx+xd,stay1,tx2-tx+1,stay2-stay1+1,mdat2%)
@rsc_put(ag,tx+xd,stay1,1)
REPEAT
@mouse(x,y,k)
IF x-d1>=0 AND x+d2<=xm AND y>=stay1 AND y<=stay2 AND x<>x2 THEN
@rsc_put(ag2,tx+xd,stay1,1)
tx=x-d1
tx2=x+d2
x2=x
ag2=@rsc_get2(tx+xd,stay1,tx2-tx+1,stay2-stay1+1,mdat2%)
@rsc_put(ag,tx+xd,stay1,1)
ENDIF
UNTIL k=0
GRAPHMODE 3
TEXT tx+xd-3,stay1,t$
TEXT tx2+xd-3,stay1,t2$
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE putpix
.| Glob. Var.: edff#,virtual#,v4#,meml#,cs#,a#,wd#,g2#,mdat%,virtwfile#
.|     virtpath$,dsk#,virtln#,f#,virtp$,virtfile$,vln#,bytes#,mlen#
.| Ruft auf  : busy_mouse,nomem
.| Aufruf in : drawpix-2,
edff=TRUE
IF virtual=FALSE OR (virtual=TRUE AND (v4=1 OR v4=2)) THEN
IF virtual=FALSE THEN
DPOKE meml+cs+((a-1)*4)+wd,g2
ELSE
DPOKE mdat%+((a-1)*4)+wd,g2
ENDIF
ELSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
@busy_mouse
PAUSE 1
SEEK #1,cs+((a-1)*4)+wd
@busy_mouse
PAUSE 1
DPOKE meml,g2
BPUT #1,meml,2
CLOSE #1
ELSE
dsk=ASC(LEFT$(virtpath$,1))-64
IF DFREE(dsk)>virtln THEN
f=RINSTR(virtpath$,"\")
IF f>0 THEN
virtp$=LEFT$(virtpath$,f)+virtfile$
OPEN "O",#2,virtp$
OPEN "I",#1,virtpath$
vln=virtln
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
CLOSE #1
SEEK #2,cs+((a-1)*4)+wd
DPOKE meml,g2
BPUT #2,meml,2
CLOSE #2
ENDIF
ELSE
@nomem
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
RETURN
'
> PROCEDURE drawpix
.| Glob. Var.: edff#,z#,x#,xd#,xm#,a#,b#,w#,d#,w2#,yd#,dist#,ym#,i#,m#,wd#
.| Felder    : cachep1#(),cachem1#(),cachep2#(),cachem2#()
.| Ruft auf  : mousek,putpix
.| Aufruf in : edhandler2-6,
LOCAL f,dsk,v,v2,v3,v4,g,g2,h1,h2
edff=TRUE
~GRAF_MOUSE(256,0)                              ! Hidem
REPEAT
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL @mousek=0 OR (v2<>z AND v4=0) OR v4=1 OR v4=2
IF v4=1 OR v4=2 THEN
IF v>x THEN
x=v
ENDIF
IF x>xd+xm THEN
x=xd+xm
ENDIF
a=INT(b/xm*(x-xd))+1
w=xd-1+((a-1)*d)
w2=xd-1+(a*d)
IF w>xd+xm THEN
w=xd+xm
ENDIF
IF w2>xd+xm THEN
w2=xd+xm
ENDIF
ENDIF
h1=yd+65+dist
h2=ym/2
IF v2>=h1-h2 AND v2<=h1+h2 THEN
COLOR 1
IF v4=0 THEN
GRAPHMODE 3
ENDIF
IF v4=1 OR v4=2 THEN
GRAPHMODE 1
ENDIF
IF z>=h1-h2 AND z<h1 THEN
FOR i=w TO w2
LINE i,h1-1,i,z
NEXT i
ENDIF
IF z>h1 AND z<=h1+h2 THEN
FOR i=w TO w2
LINE i,h1+1,i,z
NEXT i
ENDIF
IF v2>=h1-h2 AND v2<h1 THEN
FOR i=w TO w2
LINE i,h1-1,i,v2
NEXT i
ENDIF
IF v2>h1 AND v2<=h1+h2 THEN
FOR i=w TO w2
LINE i,h1+1,i,v2
NEXT i
ENDIF
z=v2
ENDIF
UNTIL @mousek=0 OR v4=1 OR v4=2
g=z-h1
g=INT(g/ym*2*m)
~GRAF_MOUSE(257,0)                              ! Showm
IF g<=0 THEN
g2=ABS(g)
ELSE
g2=65536-g
ENDIF
IF dist=0 THEN
wd=0
@putpix
cachep1(a)=0
cachem1(a)=0
IF g<=0 THEN
cachep1(a)=ABS(g)
ENDIF
IF g>=0 THEN
cachem1(a)=g
ENDIF
ELSE
wd=2
@putpix
cachep2(a)=0
cachem2(a)=0
IF g<=0 THEN
cachep2(a)=ABS(g)
ELSE
cachem2(a)=g
ENDIF
ENDIF
GRAPHMODE 3
RETURN
'
> PROCEDURE edhandler
.| Glob. Var.: rwert#,merkc#,merkfreq#,smp16&,smp32&,digana#,hz#,smp44&
.|     smp48&,merkerr#,errdel#,noval&,confid&,slipped&,crc&,parity&,biphase&
.|     nolock&,zi#,merk3#,merk4#,prot&,emph&,use&,audio&
.| Ruft auf  : smprate,setbutton2,sethertz,read_statlow,read_statmid
.|     subframe,emphasis
.| Aufruf in : rsc_do-1,
LOCAL merk1,merk2,a,b,c
@smprate
c=rwert
IF c<>merkc THEN
merkc=c
IF c=3 THEN
IF merkfreq<>0 THEN
@setbutton2(merkfreq,0,smp16&)
ENDIF
@setbutton2(smp32&,1,smp16&)
merkfreq=smp32&
IF digana=FALSE THEN
hz=32000
@sethertz
ENDIF
ENDIF
IF c=0 THEN
IF merkfreq<>0 THEN
@setbutton2(merkfreq,0,smp16&)
ENDIF
@setbutton2(smp44&,1,smp16&)
merkfreq=smp44&
IF digana=FALSE THEN
hz=44100
@sethertz
ENDIF
ENDIF
IF c=2 THEN
IF merkfreq<>0 THEN
@setbutton2(merkfreq,0,smp16&)
ENDIF
@setbutton2(smp48&,1,smp16&)
merkfreq=smp48&
IF digana=FALSE THEN
hz=48000
@sethertz
ENDIF
ENDIF
ENDIF
zsf2=TIMER-zsf
IF zsf2>=50 THEN
@subframe(FALSE)
zsf=TIMER
@read_statmid
b=(rwert AND 7)           ! Status Mid
IF b=0 THEN
IF merkerr<>0 THEN
@setbutton2(merkerr,0,smp16&)
merkerr=0
errdel=1
ENDIF
ENDIF
IF b=1 THEN
IF merkerr<>0 AND merkerr<>noval& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(noval&,1,smp16&)
merkerr=noval&
errdel=1
ENDIF
IF b=2 THEN
IF merkerr<>0 AND merkerr<>confid& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(confid&,1,smp16&)
merkerr=confid&
errdel=1
ENDIF
IF b=3 THEN
IF merkerr<>0 AND merkerr<>slipped& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
merkerr=0
errdel=1
ENDIF
IF b=4 THEN
IF merkerr<>0 AND merkerr<>crc& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
merkerr=0
errdel=1
ENDIF
IF b=5 THEN
IF merkerr<>0 AND merkerr<>parity& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(parity&,1,smp16&)
merkerr=parity&
errdel=1
ENDIF
IF b=6 THEN
IF merkerr<>0 AND merkerr<>biphase& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(biphase&,1,smp16&)
merkerr=biphase&
errdel=1
ENDIF
IF b=7 THEN
IF merkerr<>0 AND merkerr<>nolock& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(nolock&,1,smp16&)
merkerr=nolock&
errdel=1
ENDIF
errdel=0
@subframe(TRUE)
@emphasis
a=rwert
@read_statmid
b=rwert      ! Status Mid
@subframe(FALSE)
IF merk3<>a OR merk4<>b THEN
merk3=a
merk4=b
IF (b AND 4)=4 THEN
@setbutton2(prot&,1,smp16&)
ELSE
@setbutton2(prot&,0,smp16&)
ENDIF
IF a=0 THEN
@setbutton2(emph&,1,smp16&)
ELSE
@setbutton2(emph&,0,smp16&)
ENDIF
IF (b AND 1)=1 THEN
'    "CONSUMER"
@setbutton2(use&,0,smp16&)
ELSE
'    "PROFI"
@setbutton2(use&,1,smp16&)
ENDIF
IF (b AND 2)=2 THEN
'    "DIGITAL"
@setbutton2(audio&,1,smp16&)
ELSE
'    "DATA"
@setbutton2(audio&,0,smp16&)
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler2
.| Glob. Var.: edff#,xmp#,k#,mb&,x#,mx&,y#,my&,xd#,xm#,ce#,cs#,stay1#,stay2#
.|     max#,yzoom#,wyzoom#,rubmax#,v#,v2#,v3#,v4#,ym1#,yd#,z#,dist#,ym2#
.|     sline#,virtual#,virtpath$,mdat%,cached#,virtwfile#,dsk#,virtln#,f#
.|     virtp$,virtfile$,vln#,bytes#,mlen#,meml#,master#,masta#,xx#,zsnap#
.|     back%,loopz#,t$,smark#,sms#,c1#,sme#,c2#,t2$,vc1#,vc2#,xmo#,tx#,tm#
.|     ymd#
.| Felder    : cachep1#(),cachem1#(),cachep2#(),cachem2#(),loops#(),loope#()
.| Ruft auf  : markhlp,drawpix,busy_mouse,mousek,restaura,nomem,smph1
.|     springart,markhlp3,markhlp6,markhandl4,smpkhlp,smpmhlp,smpihlp
.|     flipptest,rubbermax,markprod2
.| Aufruf in : button-1,
LOCAL xw,ym,a1,a2,a,b,c,d,i,w,w2,m
edff=FALSE
xmp=-1
c=0
k=mb&
IF k<>0 THEN
@markhlp
x=mx&
y=my&
IF k<>0 AND x>=xd AND x<=(xm+xd) AND xm>0 AND ce>cs AND y>=stay1 AND y<=stay2 AND (ce-cs)<=xm THEN
IF max=0 OR yzoom=FALSE THEN
m=32767
ELSE
m=max
ENDIF
IF wyzoom=TRUE THEN
m=rubmax
ENDIF
b=(ce-cs)/4
b=INT(b)
d=xm/b
a=INT(b/xm*(x-xd))+1
w=xd-1+((a-1)*d)
w2=xd-1+(a*d)
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4=0 THEN
IF y>=ym AND y<=ym1+ym THEN
a1=cachep1(a)
a2=cachem1(a)
IF a1>a2 THEN
c=INT(a1/m*ym/2)
IF y>=yd+65-c AND y<yd+65-c+4 THEN
z=yd+65-c
dist=0
@drawpix
ENDIF
ELSE
c=INT(a2/m*ym/2)
IF y<=yd+65+c AND y>yd+65+c-4 THEN
z=yd+65+c
dist=0
@drawpix
ENDIF
ENDIF
ENDIF
IF y>=ym2 AND y<=ym2+ym THEN
a1=cachep2(a)
a2=cachem2(a)
IF a1>a2 THEN
c=INT(a1/m*ym/2)
IF y>=yd+65+sline-c AND y<yd+65+sline-c+4 THEN
z=yd+65+sline-c
dist=sline
@drawpix
ENDIF
ELSE
c=INT(a2/m*ym/2)
IF y<=yd+65+sline+c AND y>yd+65+sline+c-4 THEN
z=yd+65+sline+c
dist=sline
@drawpix
ENDIF
ENDIF
ENDIF
ENDIF
IF v4=1 OR v4=2 THEN
IF virtual=TRUE THEN
OPEN "I",#1,virtpath$
@busy_mouse
SEEK #1,cs
BGET #1,mdat%,ce-cs
@busy_mouse
PAUSE 1
CLOSE #1
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF y>=ym AND y<=ym1+ym THEN
z=ym1+ym/2
dist=0
REPEAT
@drawpix
UNTIL @mousek=0
ENDIF
IF y>=ym2 AND y<=ym2+ym THEN
z=ym2+ym/2
dist=sline
REPEAT
@drawpix
UNTIL @mousek=0
ENDIF
IF edff=TRUE THEN
cached=FALSE
@restaura
ENDIF
IF virtual=TRUE AND edff=TRUE THEN
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
@busy_mouse
SEEK #1,cs
BPUT #1,mdat%,ce-cs
@busy_mouse
PAUSE 1
CLOSE #1
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
dsk=ASC(LEFT$(virtpath$,1))-64
IF DFREE(dsk)>virtln THEN
f=RINSTR(virtpath$,"\")
IF f>0 THEN
virtp$=LEFT$(virtpath$,f)+virtfile$
OPEN "O",#2,virtp$
OPEN "I",#1,virtpath$
vln=virtln
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
CLOSE #1
SEEK #2,cs
@busy_mouse
BPUT #2,mdat%,ce-cs
@busy_mouse
CLOSE #2
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ELSE
@nomem
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF k=1 AND y>=stay1 AND y<=stay2 THEN
IF master<7 THEN
masta=loops(master)
ELSE
masta=loope(master-6)
ENDIF
IF masta<cs OR masta>ce AND master<>0 THEN
xw=x
IF k=1 AND xw>=xd AND xw<=(xm+xd) AND xm>0 AND ce>cs THEN
IF xw>=xd AND xw<=(xm+xd) AND xm>0 AND ce>cs THEN
@smph1
IF master>0 AND x>ce OR x<cs THEN
edff=TRUE
xx=INT(((ce-cs)/xm*(xw-xd)+cs)/4)*4
IF zsnap=TRUE THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4<>0 THEN
@springart(xx)
IF back%>=cs AND back%<=ce THEN
xx=back%
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
IF master>0 AND master<loopz THEN
loops(master)=xx
t$=CHR$(ASC("a")-1+master)
@markhlp3(master,loops(master))
ENDIF
IF master>loopz AND master<loopz*2 THEN
loope(master-loopz)=xx
t$=CHR$(ASC("A")-1+master-loopz)
@markhlp3(master,loope(master-loopz))
ENDIF
IF master=loopz THEN
loops(loopz)=xx
t$="s"
@markhlp3(master,loops(loopz))
ENDIF
IF master=loopz*2 THEN
loope(loopz)=xx
t$="S"
@markhlp3(master,loope(loopz))
ENDIF
@markhlp6(xx)
REPEAT
k=@mousek
UNTIL k=0
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF k=1 AND y>=stay1 AND y<=stay2 AND x>=xd AND x<=(xm+xd) AND xm>0 THEN
IF smark=6 OR smark=5 OR smark=4 THEN
IF sms>0 THEN
c1=loops(sms)
t$=CHR$(ASC("a")-1+sms)
ENDIF
IF sme>0 THEN
c2=loope(sme)
t2$=CHR$(ASC("A")-1+sms)
ENDIF
IF (ce-cs)>0 AND c1>=cs AND c2<=ce AND c2>c1 THEN
vc1=INT(xm/(ce-cs)*(c1-cs))
vc2=INT(xm/(ce-cs)*(c2-cs))
IF x>=vc1+xd AND x<=vc2+xd THEN
edff=TRUE
@markhandl4
IF sms>0 THEN
loops(sms)=c1
ENDIF
IF sme>0 THEN
loope(sme)=c2
ENDIF
IF smark=5 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpkhlp
ENDIF
IF smark=6 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpihlp
ENDIF
@flipptest
ENDIF
ENDIF
ENDIF
IF edff=FALSE AND k=1 AND x>=xd AND x<=(xm+xd) AND xm>0 AND ce>cs AND y>=stay1 AND y<=stay2 THEN
IF y>=ym AND y<=ym1+ym THEN
ymd=ym1
@rubbermax
ENDIF
IF y>=ym2 AND y<=ym2+ym THEN
ymd=ym2
@rubbermax
ENDIF
ENDIF
IF smark=1 OR smark=2 OR smark=3 THEN
@markprod2
@flipptest
xmp=0
c=0
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler3
.| Glob. Var.: digana#,c#,rwert#,merkc#,merkfreq#,smp32&,hz#,smp44&,smp48&
.| Ruft auf  : smprate,sethertz
.| Aufruf in : rsc_do-1,smpplay-1,
IF digana=FALSE THEN
@smprate
c=rwert
IF c<>merkc THEN
merkc=c
IF c=3 THEN
merkfreq=smp32&
IF digana=FALSE THEN
hz=32000
@sethertz
ENDIF
ENDIF
IF c=0 THEN
merkfreq=smp44&
IF digana=FALSE THEN
hz=44100
@sethertz
ENDIF
ENDIF
IF c=2 THEN
merkfreq=smp48&
IF digana=FALSE THEN
hz=48000
@sethertz
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler4
IF nr=arranger& AND intplay=TRUE THEN
IF XBIOS(500)=&H71273800 THEN
back%=LPEEK(a+4)      ! Patch
bc=back%/2
IF over>=0 THEN
hsec=INT((sectpos+bc)*flen/vhz/4*100)
ELSE
hsec=INT((sectpos-bc)*flen/vhz/4*100)
ENDIF
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler5
IF nr=trakker& THEN
IF XBIOS(500)=&H71273800 THEN
back%=LPEEK(a+4)      ! Patch
bc=back%/2
hsec=INT((bc*flen+playpos)/vhz/4*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE rubbermax
.| Glob. Var.: v#,v2#,v3#,v4#,ce#,cs#,xm#,x#,y#,x2#,y2#,a1#,ymd#,a2#,ym#,a#
.|     max#,m#,wyzoom#,rubmax#,qspacefill#,spacefill#,g#,xd#,scrlslde&
.|     scrolbut&,scmax#,scrollp#,mrscroll#,cached#
.| Ruft auf  : scrollinit,setslide,zslidecalc,writeyproz,restaura
.| Aufruf in : edhandler2-2,
LOCAL x1
~GRAF_MKSTATE(v,v2,v3,v4)
IF ((v4=1 OR v4=2) AND (ce-cs)>=xm) OR v4=8 THEN
~GRAF_RUBBERBOX(x,y,10,10,x2,y2)
a1=y-ymd
a2=ymd+ym-(y2+y)
IF a2>ymd+ym THEN
a2=ymd+ym
ENDIF
IF a1<0 THEN
a1=0
ENDIF
IF a2<0 THEN
a2=0
ENDIF
IF a1<a2 THEN
a=a1
ELSE
a=a2
ENDIF
a=ABS(a)
a=((ym/2)-a)*2
IF max=0 THEN
m=32767
ELSE
m=max
ENDIF
IF wyzoom=TRUE THEN
m=rubmax
ENDIF
a=m/ym*a
IF wyzoom=FALSE THEN
qspacefill=spacefill
ENDIF
wyzoom=TRUE
spacefill=TRUE
IF v4=1 OR v4=2 THEN
rubmax=INT(a)
IF (100/32767*rubmax)<6 THEN
rubmax=INT(32767/100*6)
ALERT 1,"Auflîsungsgrenze erreicht !",1,"OK",g
ENDIF
x1=x-xd
x1=cs+((ce-cs)/xm*x1)
cs=INT(x1/4)*4
x2=x2+x-xd
x2=cs+((ce-cs)/xm*x2)
ce=INT(x2/4)*4
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
mrscroll=scrollp
cached=FALSE
@zslidecalc
ENDIF
IF v4=8 THEN
rubmax=rubmax*1.5
IF rubmax>32767 THEN
rubmax=32767
wyzoom=FALSE
spacefill=qspacefill
ENDIF
ENDIF
@writeyproz
@restaura
ENDIF
RETURN
'
> PROCEDURE blkstest
.| Glob. Var.: master#,shlp#,blksa#,meml#,blkse#,smrk#,c1#,loopz#,c2#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp
.| Aufruf in : smpsave-1,
IF master=0 AND shlp=1 THEN
blksa=meml
blkse=smrk
ELSE
@markhlp
c1=loops(loopz)
c2=loope(loopz)
blkse=c2+meml
blkse=INT(blkse/4)*4
blksa=c1+meml
blksa=INT(blksa/4)*4
ENDIF
RETURN
'
> PROCEDURE markhlp7
.| Glob. Var.: i#,loopz#,sms#,lmin#,sme#,lma#,blks#,blksa#,meml#
.| Felder    : loops#(),loope#()
.| Aufruf in : smpsave-2,sampleinf-1,
FOR i=1 TO loopz-1
IF sms=i THEN
lmin=loops(i)
ENDIF
NEXT i
FOR i=1 TO loopz-1
IF sme=i THEN
lma=loope(i)
ENDIF
NEXT i
IF blks=0 THEN
lmin=INT(lmin/4)*4
lma=INT(lma/4)*4
ELSE
lmin=lmin-(blksa-meml)
lmin=INT(lmin/4)*4
lma=lma-(blksa-meml)
lma=INT(lma/4)*4
ENDIF
RETURN
'
> PROCEDURE makesmphead
.| Glob. Var.: danf#,hz#,len#,blks#,m2#,meml#,blksa#,blkse#,j#,nam$
.| Felder    : loops#(),loope#()
.| Aufruf in : sdsave-2,
LOCAL a$,i,a,m
FOR i=0 TO 295
POKE danf+i,0
NEXT i
DPOKE (danf+76),16     ! Bits
LPOKE (danf+72),hz     ! Sample-Rate
a=INT(len/4)
LPOKE (danf+92),a      ! datasize
LPOKE (danf+140),a     ! datasize2
LPOKE (danf),0         ! Sample-start
LPOKE (danf+4),a       ! Sample-end
IF blks=0 THEN
m=0
m2=meml
ELSE
m=blksa-meml
m2=blkse-meml
ENDIF
FOR j=1 TO 5
a=INT((loops(j)-m)/4)
IF a<0 OR a>m2 THEN
a=0
ENDIF
LPOKE (danf+4+j*4),a       ! Start L1-L5
a=INT((loope(j)-m)/4)
IF a<0 OR a>m2 THEN
a=0
ENDIF
LPOKE (danf+36+j*4),a      ! End L1-L5
NEXT j
LPOKE (danf+28),0      ! Start L6
LPOKE (danf+60),0      ! End L6
LPOKE (danf+28),0      ! Start L7
LPOKE (danf+60),0      ! End L7
a$=nam$
POKE danf+77,&H10
a=RINSTR(a$,".")
IF a>0 THEN
a=a-1
ENDIF
FOR i=1 TO a
POKE danf+77+i,ASC(MID$(a$,i,1))
NEXT i
LPOKE danf+96,&HFFFFFFFF   ! ??
LPOKE danf+100,&HFFFFFFFF  ! ??
DPOKE danf+144,1           ! ??
LPOKE danf+104,0       ! Marker 1
LPOKE danf+108,0       ! Marker 2
LPOKE danf+112,0       ! Marker 3
LPOKE danf+116,0       ! Marker 4
LPOKE danf+120,0       ! Marker 5
LPOKE danf+124,0       ! Marker 6
LPOKE danf+128,0       ! Marker 7
LPOKE danf+132,0       ! Marker 8
RETURN
'
> PROCEDURE sdsave
.| Glob. Var.: a#,fil$,b#,a$,danf#,head#,fileart#,datx#,len#,hdl#,mdat%
.|     hbuf#,ret#,i#
.| Ruft auf  : maschinit38,maschruf38,maschinit36,maschruf36,makesmphead
.|     nomem
.| Aufruf in : smpsave-1,
a=INSTR(fil$,".")
b=RINSTR(fil$,"\")
IF (a-b)>8 THEN
a$=LEFT$(fil$,a-2)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ELSE
a$=LEFT$(fil$,a-1)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ENDIF
OPEN "O",#1,a$
BPUT #1,danf,head
CLOSE #1
IF fileart=6 THEN
@maschinit38
@maschruf38(datx,datx+len)
ENDIF
hdl=GEMDOS(61,L:VARPTR(a$),2)
~GEMDOS(66,L:head,hdl,0)
@maschinit36
@maschruf36(datx,datx+len,mdat%+2048,mdat%+hbuf-4,hdl,ret)
a=GEMDOS(62,hdl)
IF fileart=6 THEN
@makesmphead
OPEN "U",#1,a$
SEEK #1,LOF(#1)
BPUT #1,danf,296   ! Header
CLOSE #1
ENDIF
IF ret=(datx+len) THEN
a=INSTR(fil$,".")
b=RINSTR(fil$,"\")
IF (a-b)>8 THEN
a$=LEFT$(fil$,a-2)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ELSE
a$=LEFT$(fil$,a-1)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ENDIF
IF fileart=6 THEN
LPOKE danf,&HF07E0001                    ! Kennung
FOR i=danf+4 TO danf+19
POKE i,0
NEXT i
ENDIF
OPEN "O",#1,a$
BPUT #1,danf,head
CLOSE #1
hdl=GEMDOS(61,L:VARPTR(a$),2)
~GEMDOS(66,L:head,hdl,0)
@maschinit36
@maschruf36(datx+2,datx+len+2,mdat%+2048,mdat%+hbuf-4,hdl,ret)
~GEMDOS(62,hdl)
IF fileart=6 THEN
@makesmphead
OPEN "U",#1,a$
SEEK #1,LOF(#1)
BPUT #1,danf,296   ! Header
CLOSE #1
ENDIF
IF ret<>datx+len+2 THEN
@nomem
ENDIF
ELSE
@nomem
ENDIF
IF fileart=6 THEN
@maschinit38
@maschruf38(datx,datx+len)
ENDIF
RETURN
'
> PROCEDURE headart
head=0
IF INSTR(fil$,".")=0 THEN
fil$=fil$+"."+vext$
ENDIF
sfileart=0
IF RIGHT$(fil$,4)=".S16" THEN
sfileart=1
head=20
ENDIF
IF RIGHT$(fil$,4)=".AVR" THEN
sfileart=2
head=128
ENDIF
IF RIGHT$(fil$,4)=".WAV" THEN
sfileart=3
head=44
ENDIF
IF RIGHT$(fil$,3)=".AU" OR RIGHT$(fil$,4)=".SND" THEN
sfileart=4
head=28
ENDIF
IF RIGHT$(fil$,3)=".SD" THEN
sfileart=5
head=1336
ENDIF
IF RIGHT$(fil$,4)=".SMP" THEN
sfileart=6
head=20+296
ENDIF
IF head>0 THEN
FOR i=0 TO head-1
POKE danf+i,0
NEXT i
ENDIF
RETURN
'
> PROCEDURE headmake
IF fileart=1 THEN                          ! S16-File
DPOKE danf,&HF07E                        ! SDS-Startkennung
POKE danf+2,1                            ! MIDI-Kanalnummer
POKE danf+3,1
DPOKE danf+4,&H100                       ! Sample-Nr.
POKE danf+6,16                           ! Bits
per=10^9/hz
x=INT(per/65536)
y=per-x*65536
POKE danf+7,x                            ! Periodendauer eines Samples
DPOKE danf+8,y                           ! Periodendauer eines Samples
IF blks=0 THEN
mlh=INT(mlen/2)
ELSE
mlh=INT((blkse-blksa)/2)
ENDIF
x2=INT(mlh/256)
y2=mlh-x2*256
DPOKE danf+10,x2                          ! Sample Len in Worten
POKE danf+12,y2                           ! Sample Len in Worten
@markhlp
@markhlp7
x3=INT(lmin/65536)
y3=lmin-x3*65536
POKE danf+13,x3                           ! Sustain Loop-Start
DPOKE danf+14,y3                          ! Sustain Loop-Start
x4=INT(lma/256)
y4=lma-x4*256
DPOKE danf+16,x4                          ! Sustain Loop-End
POKE danf+18,y4                           ! Sustain Loop-End
IF sret=0 THEN
la=0
ELSE
la=1
ENDIF
IF sblock=0 THEN
la=&H7F
ENDIF
POKE danf+19,la                           ! Loop-Art
'      POKE danf+20,&HF7                  ! SDS-Endkennung
ENDIF
'
IF fileart=2 THEN                          ! AVR-File
LPOKE danf,&H32424954                    ! AVR-Kennung
i=INSTR(nam$,".")
a$=LEFT$(nam$,i-1)
FOR i=1 TO LEN(a$)
POKE danf+3+i,ASC(MID$(a$,i,1))        ! Name des Samples
NEXT i
DPOKE danf+12,&HFFFF                     ! mode
DPOKE danf+14,16                         ! resolution
DPOKE danf+16,&HFFFF                     ! sign
la=0
IF sblock=1 THEN
la=&HFFFF
ENDIF
DPOKE danf+18,la                         ! loop
DPOKE danf+20,&HFFFF                     ! note
LPOKE danf+22,hz                         ! speed
IF blks=0 THEN
mlh=INT(mlen/2)
ELSE
mlh=INT((blkse-blksa)/2)
ENDIF
LPOKE danf+26,mlh                        ! len
@markhlp
IF sblock=1 THEN
@markhlp7
LPOKE danf+30,INT(lmin/2)              ! beg_loop
LPOKE danf+34,INT(lma/2)               ! end_loop
ELSE
LPOKE danf+30,0
LPOKE danf+34,mlh
ENDIF
ENDIF
'
IF fileart=3 THEN                          ! WAV-File
LPOKE danf,&H52494646                    ! "RIFF"
IF blks=0 THEN
len=mlen
ELSE
len=blkse-blksa
ENDIF
len2=len+head-4
a=INT(len2/&H1000000)
len2=len2-a*&H1000000
a2=INT(len2/65536)
len2=len2-a*65536
a3=INT(len2/256)
a4=len2-a*256
POKE danf+4,a4
POKE danf+5,a3
POKE danf+6,a2
POKE danf+7,a1
LPOKE danf+8,&H57415645                  ! "WAVE"
LPOKE danf+12,&H666D7420                 ! "fmt "
POKE danf+16,16                          ! LÑnge des fmt-Chunks
POKE danf+17,0
POKE danf+18,0
POKE danf+19,0
POKE danf+20,1                           ! format PCM
POKE danf+21,0
POKE danf+22,2                           ! channels
POKE danf+23,0
len2=hz
a=INT(len2/&H1000000)
len2=len2-a*&H1000000
a2=INT(len2/65536)
len2=len2-a*65536
a3=INT(len2/256)
a4=len2-a*256
POKE danf+24,a4                           ! frequency
POKE danf+25,a3
POKE danf+26,a2
POKE danf+27,a1
len2=hz*4                                 ! average
a=INT(len2/&H1000000)
len2=len2-a*&H1000000
a2=INT(len2/65536)
len2=len2-a*65536
a3=INT(len2/256)
a4=len2-a*256
POKE danf+28,a4                           ! average
POKE danf+29,a3
POKE danf+30,a2
POKE danf+31,a1
POKE danf+32,4                            ! align
POKE danf+33,0
POKE danf+34,16                           ! bps
POKE danf+35,0
LPOKE danf+36,&H64617461                  ! "data"
len2=len
a=INT(len2/&H1000000)
len2=len2-a*&H1000000
a2=INT(len2/65536)
len2=len2-a*65536
a3=INT(len2/256)
a4=len2-a*256
POKE danf+40,a4                           ! LÑnge des data-chunks
POKE danf+41,a3
POKE danf+42,a2
POKE danf+43,a1
ENDIF
'
IF fileart=4 THEN                          ! AU-File
LPOKE danf,&H2E736E64                    ! AVR-Kennung
LPOKE danf+4,28                          ! datalocation
LPOKE danf+12,3                          ! dataformat
LPOKE danf+20,2                          ! channelcount
LPOKE danf+24,0                          ! info
LPOKE danf+16,hz                         ! samplingrate
IF blks=0 THEN
mlh=mlen
ELSE
mlh=blkse-blksa
ENDIF
LPOKE danf+8,mlh                         ! datasize
@markhlp
ENDIF
'
IF fileart=5 THEN                          ! SD-File
'   0-3    05 38 00 0C          -> Kennung'
'  58-61   FF FF FF 80'
'  64-67   01 47 04 00'
'  69-74   25 53 63 61 6C 65     %Scale'
' 109-114  20 20 6D 73 65 63       msec'
' 148-151  00 04 CC 66          -> LÑnge des Samples in Bytes'
' 184-187  00 04 CC 66          -> LÑnge des Samples in Bytes'
' 1020-1023 AC 44               -> Samplerate'
' 1031-1036 4C 69 6E 65 61 72     Linear'
' 1336-xxxx Daten'
LPOKE danf,&H538000C                     ! SD-Kennung
LPOKE danf+58,&HFFFFFF80                 ! ?
LPOKE danf+64,&H1470400                  ! ?
POKE danf+69,&H25                        ! "%"
LPOKE danf+70,&H5363616C                 ! "Scal"
POKE danf+74,&H65                        ! "e"
POKE danf+109,&H20                       ! " "
LPOKE danf+110,&H206D7365                ! " mse"
POKE danf+114,&H63                       ! "c"
IF blks=0 THEN
mlh=INT(mlen/2)
ELSE
mlh=INT((blkse-blksa)/2)
ENDIF
LPOKE danf+148,mlh                       ! len
LPOKE danf+184,mlh                       ! len
LPOKE danf+1020,hz                       ! speed
POKE danf+1031,&H4C                      ! "L"
LPOKE danf+1032,&H696E6561               ! "inea"
POKE danf+1036,&H72                      ! "r"
IF blks=0 THEN
len=mlen
ELSE
len=blkse-blksa
ENDIF
ENDIF
'
IF fileart=6 THEN                          ! Avalon SMP-File
LPOKE danf,&HF07E0001                    ! Kennung
FOR i=danf+4 TO danf+19
POKE i,0
NEXT i
head=20
IF blks=0 THEN
len=mlen
ELSE
len=blkse-blksa
ENDIF
ENDIF
RETURN
'
> PROCEDURE smpsave
.| Glob. Var.: inf#,nomem#,vornr#,nr#,savebloc&,zu%,versatz#,a$,string#
.|     savetxt&,it#,obj#,popup&,zuadr#,buttadr#,but#,objadr#,objflag#
.|     savehelp&,savexit&,savall&,savblock&,blks#,sms#,loopz#,msms#,sme#
.|     msme#,big#,anfloadx#,mlen#,blkse#,blksa#,meml#,datx#,danf#,mdat%
.|     virtual#,g#,virtpath$,op$,virtwfile#,mp$,ext2$,fil$,pret#,pbutt#,a#
.|     l#,vext$,nam$,sfileart#,head#,fileart#,i#,isave#,bnam$,smplen#,b#,hz#
.|     per#,x#,y#,mlh#,x2#,y2#,x3#,lmin#,y3#,x4#,lma#,y4#,sret#,la#,sblock#
.|     len#,len2#,a2#,a3#,a4#,a1#,oeffne#,path$,smpnam$,vln#,virtln#,stt#
.|     c2#,c1#,vp$,virtfile$,seekz#,bytes#,smpedit&,smpfile&,smpsave&
.| Ruft auf  : infhol,markhlp,xrsrc_gaddr,rsc_draw,rsc_do,mousek,helptxt
.|     setbutton,restaura2,blkstest,makehz,maschinit,busy_mouse,fileselect
.|     sampleinf,maschruf,markhlp7,nomem,maschinit28,maschruf28,sdsave
.|     makedatum,fnamwrite,infsave,textfeld,restaura4
.| Aufruf in : drop2-1,do_smpedit-1,
inf=FALSE
nomem=FALSE
@infhol
@markhlp
vornr=nr
nr=savebloc&
~@xrsrc_gaddr(0,nr,zu%)
versatz=1
a$="SAVE"
string=LPEEK(LPEEK(zu%+24*savetxt&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=savehelp& THEN
@helptxt("SAVE")
ENDIF
UNTIL obj=savexit& OR obj=savall& OR obj=savblock&
IF obj=savall& THEN
blks=0
ENDIF
IF obj=savblock& THEN
blks=1
ENDIF
@setbutton(obj,0)
@restaura2
IF obj<>savexit& THEN
@blkstest
@makehz
IF sms=loopz THEN
sms=msms
ENDIF
IF sme=loopz THEN
sme=msme
ENDIF
@maschinit
IF big=0 THEN
IF blks=0 THEN
anfloadx=MALLOC(mlen+&H200)
ELSE
anfloadx=MALLOC((blkse-blksa)+&H200)
ENDIF
ELSE
IF blks=0 THEN
anfloadx=meml
ELSE
anfloadx=blksa
ENDIF
ENDIF
IF anfloadx<>0 AND anfloadx<>-1 THEN
IF big=0 THEN
datx=((INT(anfloadx/4))*4)+4
ELSE
datx=anfloadx
ENDIF
danf=mdat%
@busy_mouse
IF virtual=TRUE THEN
g=RINSTR(virtpath$,"\")
IF g>0 THEN
op$=LEFT$(virtpath$,g)
ENDIF
IF virtwfile=TRUE THEN
mp$=""
ENDIF
ENDIF
@fileselect(op$+"*."+ext2$,mp$,"SAVE:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 THEN
IF blks=0 THEN
a=meml
l=mlen
ELSE
a=blksa
l=blkse-blksa
ENDIF
vext$=ext2$
IF vext$="*" THEN
vext$="S16"
ENDIF
IF INSTR(nam$,".")=0 THEN
nam$=nam$+"."+vext$
ENDIF
@headart
IF sfileart=0 THEN
inf=FALSE
ALERT 3,"Falscher File-Extender !",1,"EXIT",g
ELSE
fileart=sfileart
isave=TRUE
bnam$=nam$
smplen=l
@sampleinf
isave=FALSE
ENDIF
IF inf=TRUE THEN
b=datx
IF big=0 THEN
@maschruf
ENDIF
hz=INT(hz/100)*100
@headmake
'
'
'
'
a=ASC(LEFT$(fil$,1))-64
oeffne=FALSE
IF DFREE(a)>(head+(blkse-blksa)) THEN
oeffne=TRUE
ELSE
IF virtual=FALSE THEN
@nomem
ENDIF
ENDIF
IF oeffne=TRUE THEN
IF blks=0 THEN
len=mlen
ELSE
len=blkse-blksa
ENDIF
IF fileart=3 THEN
@maschinit28
@maschruf28(datx,len)
ENDIF
IF virtual=FALSE THEN
IF len>0 THEN
a=ASC(LEFT$(fil$,1))-64
IF fileart=5 OR fileart=6 THEN
IF DFREE(a)>=(head+len*2) THEN
@sdsave
ELSE
@nomem
ENDIF
ELSE
IF DFREE(a)>=(head+len) THEN
OPEN "O",#1,fil$
BPUT #1,danf,head
BPUT #1,datx,len
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
path$=fil$
smpnam$=nam$
smplen=len
@makedatum
@fnamwrite
IF nomem=FALSE THEN
@infsave
ENDIF
ELSE
ALERT 1,"Kein Block markiert !",1,"OK",g
ENDIF
ELSE
IF blks=0 THEN
vln=virtln
stt=0
ELSE
vln=c2-c1
stt=c1
ENDIF
IF vln>0 THEN
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=vln THEN
IF virtwfile=TRUE THEN
a=RINSTR(virtpath$,"\")
IF a>0 THEN
vp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
ELSE
vp$=virtpath$
ENDIF
IF EXIST(vp$)=FALSE THEN
vp$=virtpath$
ENDIF
OPEN "I",#1,vp$
OPEN "O",#2,fil$
vln=INT(vln/4)*4
seekz=INT(stt/4)*4
bytes=INT(mlen/4)*4
IF seekz>0 THEN
SEEK #1,seekz
ENDIF
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #1
CLOSE #2
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
ELSE
ALERT 1,"Kein Block markiert !",1,"OK",g
ENDIF
ENDIF
IF fileart=3 THEN
@maschinit28
@maschruf28(datx,len)
ENDIF
ENDIF
IF nr=smpedit& THEN
@textfeld(smpfile&,nam$+CHR$(0),1)
ENDIF
ENDIF
ENDIF
ENDIF
IF big=0 AND anfloadx<>0 THEN
~MFREE(anfloadx)
ENDIF
@restaura4
ENDIF
IF nr=smpedit& THEN
@setbutton(smpsave&,0)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE blklfrag
.| Glob. Var.: vornr#,nr#,savebloc&,zu%,versatz#,a$,string#,savetxt&,it#
.|     obj#,popup&,zuadr#,buttadr#,but#,objadr#,objflag#,savehelp&,savexit&
.|     savall&,savblock&,blks#
.| Ruft auf  : markhlp,xrsrc_gaddr,rsc_draw,rsc_do,mousek,helptxt,setbutton
.|     rsc_back
.| Aufruf in : ldhlp-1,
@markhlp
vornr=nr
nr=savebloc&
~@xrsrc_gaddr(0,nr,zu%)
versatz=1
a$="LOAD"
string=LPEEK(LPEEK(zu%+24*savetxt&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=savehelp& THEN
@helptxt("LOAD")
ENDIF
UNTIL obj=savexit& OR obj=savall& OR obj=savblock&
IF obj=savall& THEN
blks=0
ENDIF
IF obj=savblock& THEN
blks=1
ENDIF
@setbutton(obj,0)
@rsc_back(nr)
nr=vornr
'  @restaura2
RETURN
'
> PROCEDURE clearfsel
.| Glob. Var.: fsbut1&,fsbut2&,fsbut3&,fsbut4&,fsbut5&,fsbut6&,fsbut7&
.|     fsbut8&,fsbut9&,fsbut10&,fsbut11&,fsbut12&,fsbut13&,fsbut14&,fsbut15&
.|     fstxt1&,fstxt2&,fstxt3&,fstxt4&,fstxt5&,fstxt6&,fstxt7&,fstxt8&
.|     fstxt9&,fstxt10&,fstxt11&,fstxt12&,fstxt13&,fstxt14&,fstxt15&
.| Ruft auf  : setbutton,textfeld
.| Aufruf in : getsel5-1,fsnrset-1,newfsel-5,
@setbutton(fsbut1&,0)
@setbutton(fsbut2&,0)
@setbutton(fsbut3&,0)
@setbutton(fsbut4&,0)
@setbutton(fsbut5&,0)
@setbutton(fsbut6&,0)
@setbutton(fsbut7&,0)
@setbutton(fsbut8&,0)
@setbutton(fsbut9&,0)
@setbutton(fsbut10&,0)
@setbutton(fsbut11&,0)
@setbutton(fsbut12&,0)
@setbutton(fsbut13&,0)
@setbutton(fsbut14&,0)
@setbutton(fsbut15&,0)
@textfeld(fsbut1&,CHR$(0),1)
@textfeld(fsbut2&,CHR$(0),1)
@textfeld(fsbut3&,CHR$(0),1)
@textfeld(fsbut4&,CHR$(0),1)
@textfeld(fsbut5&,CHR$(0),1)
@textfeld(fsbut6&,CHR$(0),1)
@textfeld(fsbut7&,CHR$(0),1)
@textfeld(fsbut8&,CHR$(0),1)
@textfeld(fsbut9&,CHR$(0),1)
@textfeld(fsbut10&,CHR$(0),1)
@textfeld(fsbut11&,CHR$(0),1)
@textfeld(fsbut12&,CHR$(0),1)
@textfeld(fsbut13&,CHR$(0),1)
@textfeld(fsbut14&,CHR$(0),1)
@textfeld(fsbut15&,CHR$(0),1)
@textfeld(fstxt1&,CHR$(0),1)
@textfeld(fstxt2&,CHR$(0),1)
@textfeld(fstxt3&,CHR$(0),1)
@textfeld(fstxt4&,CHR$(0),1)
@textfeld(fstxt5&,CHR$(0),1)
@textfeld(fstxt6&,CHR$(0),1)
@textfeld(fstxt7&,CHR$(0),1)
@textfeld(fstxt8&,CHR$(0),1)
@textfeld(fstxt9&,CHR$(0),1)
@textfeld(fstxt10&,CHR$(0),1)
@textfeld(fstxt11&,CHR$(0),1)
@textfeld(fstxt12&,CHR$(0),1)
@textfeld(fstxt13&,CHR$(0),1)
@textfeld(fstxt14&,CHR$(0),1)
@textfeld(fstxt15&,CHR$(0),1)
RETURN
'
> PROCEDURE clearfsel2
.| Glob. Var.: i#,flist#,wurl#
.| Felder    : dbank$(),dbank2$(),wurlnr#()
.| Aufruf in : getsel5-1,
FOR i=1 TO flist
dbank$(i)=""
dbank2$(i)=""
NEXT i
IF wurl>0 THEN
FOR i=1 TO wurl
wurlnr(i)=0
NEXT i
ENDIF
RETURN
'
> PROCEDURE getsel
.| Glob. Var.: b$,flist#,op$
.| Felder    : dbank$(),dbank2$()
.| Aufruf in : getsel5-4,
LOCAL g,a$
g=FALSE
a$=RIGHT$(b$,5)
a$=LEFT$(a$,LEN(a$)-1)
IF a$=".S16" THEN
g=TRUE
ENDIF
IF a$=".WAV" THEN
g=TRUE
ENDIF
IF a$=".AU" THEN
g=TRUE
ENDIF
IF a$=".SND" THEN
g=TRUE
ENDIF
IF a$=".SMP" THEN
g=TRUE
ENDIF
IF a$=".AVR" THEN
g=TRUE
ENDIF
IF a$=".SD" THEN
g=TRUE
ENDIF
IF g=TRUE THEN
INC flist
dbank$(flist)=b$
dbank2$(flist)=op$+b$
ENDIF
RETURN
'
> PROCEDURE getsel2
.| Glob. Var.: flist#,j#,fsz#,lmax4#,i3#,wurl#,i#,fsmplay#,b$,fsbut1&
.|     fsbut2&,fsbut3&,fsbut4&,fsbut5&,fsbut6&,fsbut7&,fsbut8&,fsbut9&
.|     fsbut10&,fsbut11&,fsbut12&,fsbut13&,fsbut14&,fsbut15&,i2#,bloopz#,a#
.|     c$,src$,a$,fstxt1&,fstxt2&,fstxt3&,fstxt4&,fstxt5&,fstxt6&,fstxt7&
.|     fstxt8&,fstxt9&,fstxt10&,fstxt11&,fstxt12&,fstxt13&,fstxt14&,fstxt15&
.| Felder    : wurlnr#(),dbank$(),dbank2$()
.| Ruft auf  : textfeld
.| Aufruf in : getsel5-2,fsnrset-1,newfsel-5,
IF flist>0 THEN
j=fsz+1
IF j+14>lmax4 THEN
j=lmax4-14
ENDIF
i3=fsz
IF wurlnr(i3+1)=0 THEN
REPEAT
IF i3+1<lmax4 THEN
INC i3
ENDIF
UNTIL wurlnr(i3+1)<>0 OR i3+1>=wurl
ENDIF
FOR i=j TO j+14
IF i<=flist THEN
IF fsmplay=FALSE THEN
b$=dbank$(i)
ELSE
REPEAT
IF i3<lmax4 THEN
INC i3
ENDIF
UNTIL wurlnr(i3)<>0 OR i3>=wurl
IF wurlnr(i3)<>0 AND i3<=wurl THEN
b$=dbank$(wurlnr(i3))
ELSE
b$=""
ENDIF
ENDIF
IF fsmplay=FALSE OR (fsmplay=TRUE AND wurlnr(i3)<>0 AND b$<>"") THEN
IF i=j THEN
@textfeld(fsbut1&,b$,1)
ENDIF
IF i=j+1 THEN
@textfeld(fsbut2&,b$,1)
ENDIF
IF i=j+2 THEN
@textfeld(fsbut3&,b$,1)
ENDIF
IF i=j+3 THEN
@textfeld(fsbut4&,b$,1)
ENDIF
IF i=j+4 THEN
@textfeld(fsbut5&,b$,1)
ENDIF
IF i=j+5 THEN
@textfeld(fsbut6&,b$,1)
ENDIF
IF i=j+6 THEN
@textfeld(fsbut7&,b$,1)
ENDIF
IF i=j+7 THEN
@textfeld(fsbut8&,b$,1)
ENDIF
IF i=j+8 THEN
@textfeld(fsbut9&,b$,1)
ENDIF
IF i=j+9 THEN
@textfeld(fsbut10&,b$,1)
ENDIF
IF i=j+10 THEN
@textfeld(fsbut11&,b$,1)
ENDIF
IF i=j+11 THEN
@textfeld(fsbut12&,b$,1)
ENDIF
IF i=j+12 THEN
@textfeld(fsbut13&,b$,1)
ENDIF
IF i=j+13 THEN
@textfeld(fsbut14&,b$,1)
ENDIF
IF i=j+14 THEN
@textfeld(fsbut15&,b$,1)
ENDIF
'
IF fsmplay=FALSE THEN
b$=dbank2$(i)
ELSE
IF wurlnr(i3)<>0 AND i3<=wurl THEN
b$=dbank2$(wurlnr(i3))
ELSE
b$=""
ENDIF
ENDIF
IF b$<>"" THEN
b$=LEFT$(b$,INSTR(b$,"."))+"INF"+CHR$(0)
IF EXIST(b$)=TRUE THEN
OPEN "I",#2,b$
FOR i2=1 TO bloopz
INPUT #2,a
INPUT #2,a
NEXT i2
c$=""
src$=""
REPEAT
INPUT #2,a$
c$=c$+a$
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
c$=c$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
REPEAT
INPUT #2,a$
src$=src$+a$
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
src$=src$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
CLOSE #2
a$=""
IF c$<>"" AND c$<>CHR$(0) THEN
IF RIGHT$(c$,1)=CHR$(0) THEN
c$=LEFT$(c$,LEN(c$)-1)
ENDIF
a$=c$
ENDIF
IF src$<>"" AND src$<>CHR$(0) THEN
IF RIGHT$(src$,1)=CHR$(0) THEN
src$=LEFT$(src$,LEN(src$)-1)
ENDIF
IF LEN(a$)>0 THEN
a$=a$+","
ENDIF
a$=a$+src$
ENDIF
IF a$<>"" THEN
IF LEN(a$)>60 THEN
a$=LEFT$(a$,60)
ENDIF
a$=a$+CHR$(0)
IF i=fsz+1 THEN
@textfeld(fstxt1&,a$,1)
ENDIF
IF i=fsz+2 THEN
@textfeld(fstxt2&,a$,1)
ENDIF
IF i=fsz+3 THEN
@textfeld(fstxt3&,a$,1)
ENDIF
IF i=fsz+4 THEN
@textfeld(fstxt4&,a$,1)
ENDIF
IF i=fsz+5 THEN
@textfeld(fstxt5&,a$,1)
ENDIF
IF i=fsz+6 THEN
@textfeld(fstxt6&,a$,1)
ENDIF
IF i=fsz+7 THEN
@textfeld(fstxt7&,a$,1)
ENDIF
IF i=fsz+8 THEN
@textfeld(fstxt8&,a$,1)
ENDIF
IF i=fsz+9 THEN
@textfeld(fstxt9&,a$,1)
ENDIF
IF i=fsz+10 THEN
@textfeld(fstxt10&,a$,1)
ENDIF
IF i=fsz+11 THEN
@textfeld(fstxt11&,a$,1)
ENDIF
IF i=fsz+12 THEN
@textfeld(fstxt12&,a$,1)
ENDIF
IF i=fsz+13 THEN
@textfeld(fstxt13&,a$,1)
ENDIF
IF i=fsz+14 THEN
@textfeld(fstxt14&,a$,1)
ENDIF
IF i=fsz+15 THEN
@textfeld(fstxt15&,a$,1)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE getsel3
.| Glob. Var.: fsmplay#,obj#,k#,k2#,vfil$,op$
.| Felder    : dbank$()
.| Ruft auf  : setbutton
.| Aufruf in : newfsel-16,
IF fsmplay=TRUE THEN
@setbutton(obj,0)
ENDIF
IF k<>0 AND k2<>0 AND obj<>k2 THEN
@setbutton(k2,0)
ENDIF
IF obj=k2 AND k<>0 AND dbank$(k)<>"" AND fsmplay=FALSE THEN
@setbutton(obj,1)
ENDIF
k2=obj
IF dbank$(k)<>"" AND k<>0 THEN
vfil$=op$+dbank$(k)
ELSE
vfil$=""
ENDIF
RETURN
'
> PROCEDURE getsel4
.| Glob. Var.: fsel$,a$,op$,fsotxt&
.| Ruft auf  : textfeld
.| Aufruf in : getsel5-1,
IF EXIST(fsel$)=TRUE THEN
a$="FILESELECT-DATEI -->"+fsel$
ELSE
a$=op$
ENDIF
IF LEN(a$)>50 THEN
a$="..."+RIGHT$(a$,47)
ENDIF
a$=a$+CHR$(0)
@textfeld(fsotxt&,a$,1)
RETURN
'
> PROCEDURE getsel5
.| Glob. Var.: flist#,fsel$,a$,nf$,op$,a#,dta#,pdta#,b$,k#
.| Ruft auf  : clearfsel,clearfsel2,getsel4,getsel,getsel2
.| Aufruf in : newfsel-6,
LOCAL g
@clearfsel
@clearfsel2
@getsel4
flist=0
g=FALSE
IF EXIST(fsel$)=TRUE THEN
g=TRUE
OPEN "I",#1,fsel$
IF LOF(#1)>0 THEN
g=TRUE
WHILE EOF(#1)=FALSE
INPUT #1,a$
nf$=a$+CHR$(0)
op$=LEFT$(a$,LEN(a$)-3)
a=GEMDOS(78,L:VARPTR(nf$),0)
IF a=0 THEN
dta=GEMDOS(47)
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WHILE GEMDOS(79)=0
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WEND
ENDIF
WEND
ENDIF
CLOSE #1
@getsel2
ENDIF
IF g=FALSE THEN
nf$=op$+"*.*"+CHR$(0)
a=GEMDOS(78,L:VARPTR(nf$),0)
IF a=0 THEN
dta=GEMDOS(47)
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WHILE GEMDOS(79)=0
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WEND
@getsel2
ENDIF
ENDIF
k=0
RETURN
'
> PROCEDURE fsnrset
.| Ruft auf  : clearfsel,getsel2
.| Aufruf in : button-2,newfsel-2,
@clearfsel
@getsel2
RETURN
'
> PROCEDURE newfsel
.| Glob. Var.: vornr#,nr#,fsel&,wurload#,zu%,fsmax#,lmax4#,fsslide&
.|     fssldbut&,fsz#,fsload&,fssave&,k#,wurl#,vop$,op$,vnam$,nam$,vfil$
.|     fil$,fsmplay#,fsmatic&,obj#,popup&,zuadr#,buttadr#,but#,objadr#
.|     objflag#,fshelp&,fsins&,buttflag#,fsdel&,a#,i#,fsordner&,fsadd&
.|     fsnew&,fsclf&,lfw$,mbox$,pret#,pbutt#,g#,dfil$,dfil2$,fsplay&,handle#
.|     playpos#,l#,sectors#,flen#,anspiel#,over#,fil2$,jz#,iz#,fsbut1&
.|     fsbut2&,fsbut3&,fsbut4&,fsbut5&,fsbut6&,fsbut7&,fsbut8&,fsbut9&
.|     fsbut10&,fsbut11&,fsbut12&,fsbut13&,fsbut14&,fsel$,ordner$,ext$
.|     fssldup&,slflg#,fsslddwn&,fsbut15&,fsexit&,fsok&,k2#
.| Felder    : wurlnr#(),dbank$(),dbank2$()
.| Ruft auf  : xrsrc_gaddr,slideinit,rsc_draw,setslide,setbutton,markhlp
.|     getsel5,rsc_do,mousek,readbutton,helptxt,clearfsel,getsel2,fileselect
.|     rsc_back,maschinit5,digout,maschruf5,slideup,fsnrset,slidedwn,getsel3
.| Aufruf in : ldhlp-1,
LOCAL j
vornr=nr
nr=fsel&
wurload=FALSE
~@xrsrc_gaddr(0,nr,zu%)
fsmax=lmax4
@slideinit(fsslide&,fssldbut&,fsmax,5,fsz)
@rsc_draw(nr,0)
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@setbutton(fsload&,8)
@setbutton(fssave&,8)
@markhlp
k=0
wurl=0
vop$=op$
vnam$=nam$
vfil$=fil$
fsmplay=FALSE
@setbutton(fsmatic&,0)
@getsel5
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
@readbutton(obj)
IF obj=fshelp& THEN
@helptxt("FSEL")
ENDIF
IF obj=fsins& AND buttflag<>8 THEN
INC wurl
wurlnr(wurl)=fsz+k
PAUSE 3
@setbutton(fsins&,0)
ENDIF
IF obj=fsdel& THEN
IF fsmplay=FALSE THEN
a=0
IF wurl>0 AND k<>0 THEN
FOR i=wurl TO 1 STEP -1
EXIT IF wurlnr(i)=fsz+k
NEXT i
IF wurlnr(i)=fsz+k THEN
wurlnr(i)=0
ENDIF
ENDIF
ELSE
FOR i=1 TO wurl
wurlnr(i)=0
NEXT i
fsz=0
wurl=0
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@clearfsel
@getsel2
ENDIF
PAUSE 3
@setbutton(fsdel&,0)
ENDIF
IF obj=fsmatic& THEN
IF fsmplay=FALSE THEN
fsmplay=TRUE
fsz=0
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@setbutton(fsins&,8)
@setbutton(fsordner&,8)
@setbutton(fsadd&,8)
@setbutton(fsnew&,8)
@setbutton(fsclf&,8)
@setbutton(fsload&,0)
@setbutton(fssave&,0)
ELSE
fsmplay=FALSE
fsz=0
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@setbutton(fsins&,0)
@setbutton(fsdel&,0)
@setbutton(fsordner&,0)
@setbutton(fsadd&,0)
@setbutton(fsnew&,0)
@setbutton(fsclf&,0)
@setbutton(fsload&,8)
@setbutton(fssave&,8)
IF wurload=TRUE THEN
@getsel5
wurload=FALSE
ENDIF
ENDIF
@clearfsel
@getsel2
k=0
ENDIF
IF obj=fsload& AND buttflag<>8 THEN
@fileselect(lfw$+"*."+mbox$,"SMP16."+mbox$,"LOAD MUSICBOX:")
IF pret<>0 AND pbutt=1 THEN
IF EXIST(fil$) THEN
OPEN "I",#1,fil$
wurl=0
WHILE EOF(#1)=FALSE
INC wurl
wurlnr(wurl)=wurl
INPUT #1,dbank$(wurlnr(wurl))
INPUT #1,dbank2$(wurlnr(wurl))
WEND
CLOSE #1
@clearfsel
@getsel2
wurload=TRUE
ENDIF
ENDIF
PAUSE 3
@setbutton(fsload&,0)
ENDIF
IF obj=fssave& AND buttflag<>8 THEN
IF wurl>0 THEN
@fileselect(lfw$+"*."+mbox$,"SMP16."+mbox$,"SAVE MUSICBOX:")
IF pret<>0 AND pbutt=1 THEN
OPEN "O",#1,fil$
FOR i=1 TO wurl
PRINT #1,dbank$(wurlnr(i))
PRINT #1,dbank2$(wurlnr(i))
NEXT i
CLOSE #1
ENDIF
ENDIF
PAUSE 3
@setbutton(fssave&,0)
ENDIF
IF obj=fsclf& AND buttflag<>8 THEN
ALERT 2,"Wirklich lîschen ?",1,"JA|NEIN",g
IF g=1 THEN
IF dbank$(fsz+k)<>"" AND k<>0 THEN
dfil$=dbank2$(fsz+k)
IF EXIST(dfil$) AND dfil$<>"" THEN
KILL dfil$
ENDIF
dfil2$=LEFT$(dfil$,INSTR(dfil$,"."))+"INF"
IF EXIST(dfil2$) AND dfil$<>"" THEN
KILL dfil2$
ENDIF
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@getsel5
ENDIF
ENDIF
PAUSE 3
@setbutton(fsclf&,0)
ENDIF
IF obj=fsplay& THEN
IF fsmplay=FALSE THEN
IF dbank$(fsz+k)<>"" AND k<>0 THEN
vfil$=dbank2$(fsz+k)
ELSE
vfil$=""
ENDIF
IF EXIST(vfil$) AND vfil$<>"" THEN
@maschinit5
handle=GEMDOS(61,L:VARPTR(vfil$),0)
IF handle>0 THEN
playpos=0
OPEN "I",#1,vfil$
l=LOF(#1)
CLOSE #1
sectors=INT(l/flen)
IF sectors>anspiel THEN
'              sectors=anspiel
ENDIF
over=0
@digout(TRUE)
l=0
fil2$=fil$
fil$=vfil$
@maschruf5
fil$=fil2$
@digout(FALSE)
~GEMDOS(62,handle)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
ENDIF
IF fsmplay=TRUE THEN
jz=0
FOR iz=1 TO wurl
IF wurlnr(iz)<>0 AND dbank$(wurlnr(iz))<>"" THEN
vfil$=dbank2$(wurlnr(iz))
ELSE
vfil$=""
ENDIF
IF EXIST(vfil$) AND vfil$<>"" THEN
INC jz
IF jz=1 THEN
@setbutton(fsbut1&,1)
ENDIF
IF jz=2 THEN
@setbutton(fsbut1&,0)
@setbutton(fsbut2&,1)
ENDIF
IF jz=3 THEN
@setbutton(fsbut2&,0)
@setbutton(fsbut3&,1)
ENDIF
IF jz=4 THEN
@setbutton(fsbut3&,0)
@setbutton(fsbut4&,1)
ENDIF
IF jz=5 THEN
@setbutton(fsbut4&,0)
@setbutton(fsbut5&,1)
ENDIF
IF jz=6 THEN
@setbutton(fsbut5&,0)
@setbutton(fsbut6&,1)
ENDIF
IF jz=7 THEN
@setbutton(fsbut6&,0)
@setbutton(fsbut7&,1)
ENDIF
IF jz=8 THEN
@setbutton(fsbut7&,0)
@setbutton(fsbut8&,1)
ENDIF
IF jz=9 THEN
@setbutton(fsbut8&,0)
@setbutton(fsbut9&,1)
ENDIF
IF jz=10 THEN
@setbutton(fsbut9&,0)
@setbutton(fsbut10&,1)
ENDIF
IF jz=11 THEN
@setbutton(fsbut10&,0)
@setbutton(fsbut11&,1)
ENDIF
IF jz=12 THEN
@setbutton(fsbut11&,0)
@setbutton(fsbut12&,1)
ENDIF
IF jz=13 THEN
@setbutton(fsbut12&,0)
@setbutton(fsbut13&,1)
ENDIF
IF jz=14 THEN
@setbutton(fsbut13&,0)
@setbutton(fsbut14&,1)
ENDIF
IF jz>14 AND fsz<lmax4 THEN
INC fsz
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@clearfsel
@getsel2
@setbutton(fsbut14&,1)
ENDIF
@maschinit5
handle=GEMDOS(61,L:VARPTR(vfil$),0)
IF handle>0 THEN
playpos=0
OPEN "I",#1,vfil$
l=LOF(#1)
CLOSE #1
sectors=INT(l/flen)
over=0
@digout(TRUE)
l=0
fil2$=fil$
fil$=vfil$
@maschruf5
fil$=fil2$
@digout(FALSE)
~GEMDOS(62,handle)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
NEXT iz
fsz=0
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@clearfsel
@getsel2
ENDIF
@setbutton(obj,0)
ENDIF
IF obj=fsnew& AND buttflag<>8 THEN
OPEN "O",#1,fsel$
CLOSE #1
@setbutton(fsnew&,0)
fsmplay=FALSE
@setbutton(fsmatic&,0)
@getsel5
ENDIF
IF obj=fsadd& AND buttflag<>8 THEN
IF EXIST(fsel$)=FALSE THEN
OPEN "O",#1,fsel$
CLOSE #1
ENDIF
OPEN "U",#1,fsel$
a=LOF(#1)
SEEK #1,a
PRINT #1,ordner$+"*.*"
CLOSE #1
@setbutton(fsadd&,0)
fsmplay=FALSE
@setbutton(fsmatic&,0)
@getsel5
ENDIF
IF obj=fsordner& AND buttflag<>8 THEN
fsmplay=FALSE
@setbutton(fsmatic&,0)
@fileselect(op$+"*."+ext$,"","PATH:")
@setbutton(obj,0)
IF pret<>0 AND pbutt=1 THEN
op$=ordner$
@getsel5
ENDIF
ENDIF
IF obj=fssldup& THEN
@slideup(fsslide&,fssldbut&,fsmax,1,5,fsz,slflg)
IF slflg=TRUE THEN
@fsnrset
ENDIF
@setbutton(fssldup&,0)
ENDIF
IF obj=fsslddwn& THEN
@slidedwn(fsslide&,fssldbut&,fsmax,1,5,fsz,slflg)
IF slflg=TRUE THEN
@fsnrset
ENDIF
@setbutton(fsslddwn&,0)
ENDIF
IF obj=fsbut1& AND buttflag<>8 THEN
@getsel3
k=1
ENDIF
IF obj=fsbut2& THEN
@getsel3
k=2
ENDIF
IF obj=fsbut3& THEN
@getsel3
k=3
ENDIF
IF obj=fsbut4& THEN
@getsel3
k=4
ENDIF
IF obj=fsbut5& THEN
@getsel3
k=5
ENDIF
IF obj=fsbut6& THEN
@getsel3
k=6
ENDIF
IF obj=fsbut7& THEN
@getsel3
k=7
ENDIF
IF obj=fsbut8& THEN
@getsel3
k=8
ENDIF
IF obj=fsbut9& THEN
@getsel3
k=9
ENDIF
IF obj=fsbut10& THEN
@getsel3
k=10
ENDIF
IF obj=fsbut11& THEN
@getsel3
k=11
ENDIF
IF obj=fsbut12& THEN
@getsel3
k=12
ENDIF
IF obj=fsbut13& THEN
@getsel3
k=13
ENDIF
IF obj=fsbut14& THEN
@getsel3
k=14
ENDIF
IF obj=fsbut15& THEN
@getsel3
k=15
ENDIF
UNTIL obj=fsexit& OR obj=fsok& OR k<>0
IF k<>0 THEN
IF dbank$(k)="" THEN
@setbutton(obj,0)
@getsel3
k=0
ENDIF
ENDIF
IF k=0 AND obj=fsok& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=fsexit& OR (k<>0 AND obj=fsok& AND dbank$(k)<>"")
IF obj<>0 THEN
@setbutton(obj,0)
ENDIF
IF k2<>0 THEN
@setbutton(k2,0)
ENDIF
IF obj=fsok& AND dbank$(k)<>"" AND k<>0 THEN
fil$=dbank2$(fsz+k)
nam$=dbank$(fsz+k)
a=INSTR(fil$,nam$)
ordner$=LEFT$(fil$,a-1)
pret=1
pbutt=1
ELSE
pret=0
pbutt=0
ENDIF
@rsc_back(nr)
nr=vornr
obj=0
'  op$=vop$
'  nam$=vnam$
'  fil$=vfil$
RETURN
'
> PROCEDURE restaura
.| Ruft auf  : restaura3,restaura4
.| Aufruf in : button-2,fade_it-2,smpkhlp-2,smpmhlp-2,smpihlp-2,zoomhelp-1
.|     smpl-2,smpr-2,edhandler2-1,rubbermax-1,zoomcalc-1,do_smpedit-3
.|     trash-1,negate-1,lrchange-1,smpplay-1,record3-2,
'  @rsc_back(nr)
@restaura3
@restaura4
RETURN
'
> PROCEDURE blkrestaura
.| Glob. Var.: nr#,smpedit&,winh#
.| Ruft auf  : restaura3,restaura4
.| Aufruf in : normalize-1,smpcut-1,resample-1,conmix-1,mono-1,negate-1
.|     lrchange-1,
LOCAL bnr
bnr=nr
nr=smpedit&
IF BTST(winh,smpedit&)=TRUE THEN
@restaura3
@restaura4
ENDIF
nr=bnr
@restaura3
@restaura4
RETURN
'
> PROCEDURE restaura2
.| Glob. Var.: nr#,vornr#,winh#
.| Ruft auf  : rsc_back
.| Aufruf in : smptime-1,movefrag-1,smpsave-1,sampleinf-1,arrsmpr-1
.|     arrdelay-1,arrmname-1,virtual-1,abackup-1,makeaback-1,time_edit-1
.|     make-1,setupdat-1,midi-1,do_dsp-1,
@rsc_back(nr)
nr=vornr
IF BTST(winh,nr)=TRUE THEN
'    @restaura3
'    @restaura4
ENDIF
RETURN
'
> PROCEDURE restaura2b
.| Glob. Var.: nr#
.| Ruft auf  : rsc_back
.| Aufruf in : do_main-1,fade-1,do_arrange-1,do_trakker-1,do_blkf-1
.|     do_info-1,do_loop-1,do_peak-1,
@rsc_back(nr)
RETURN
'
> PROCEDURE restaura3
.| Glob. Var.: nr#,smp16&,i#
.| Ruft auf  : rsc_redraw_obj
.| Aufruf in : restaura-1,blkrestaura-2,sampleinf-1,
IF nr=smp16& THEN
i=7
ELSE
i=5
ENDIF
@rsc_redraw_obj(nr,0)
RETURN
'
> PROCEDURE restaura4
.| Glob. Var.: nr#,smpedit&,cs#,ce#,sblock#,smppmark&,sloop#,smploop&
.| Ruft auf  : curve,markprod3,setbutton
.| Aufruf in : smpsave-1,restaura-1,blkrestaura-2,smpload-1,
IF nr=smpedit& THEN
@curve(cs,ce)
@markprod3
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF sloop=0 THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE smpload
.| Glob. Var.: mrkobj#,memlmrk#,meml#,secmrk#,sec#,anfloadx#,smplen#,abz#
.|     vmem#,lready#,savexit&,smpnam$,pathda#,nr#,smpedit&,cs#,ce#,extclock#
.|     hz#,a$,popups&,rate32&,rate&,rate44&,rate48&,smpload&
.| Ruft auf  : ldhlp,fnamwrite,curve,restaura4,textfeld,adlow,admid,adhigh
.|     setbutton
.| Aufruf in : drop2-1,do_smpedit-1,
mrkobj=0
memlmrk=meml
secmrk=sec
@ldhlp
IF anfloadx<>0 AND anfloadx<>-1 AND (smplen-abz)<=vmem AND lready=1 AND mrkobj<>savexit& THEN
IF smpnam$<>"" AND pathda=TRUE THEN
@fnamwrite
IF nr=smpedit& THEN
@curve(cs,ce)
@restaura4
ENDIF
@fliphz
@fliphz2
ENDIF
ELSE
IF pathda=FALSE THEN
IF nr=smpedit& THEN
@curve(cs,ce)
ENDIF
'      @restaura4
ENDIF
ENDIF
IF nr=smpedit& THEN
IF neufsel=FALSE THEN
@setbutton(smpload&,0)
ELSE
@setbutton(smpdbank&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE marksearch
.| Glob. Var.: markfull#,loopz#,markfre#
.| Felder    : loops#(),loope#()
.| Aufruf in : findblock-1,sampleinf-2,
LOCAL ex,i
markfull=FALSE
ex=FALSE
FOR i=1 TO loopz-1
IF ((loops(i)=0 AND loope(i)=0) OR (loops(i)=-1 AND loope(i)=-1)) AND ex=FALSE THEN
markfre=i
ex=TRUE
ENDIF
NEXT i
IF ex=FALSE THEN
markfre=1
markfull=TRUE
ENDIF
RETURN
'
> PROCEDURE blkltest
.| Glob. Var.: bpos#,master#,bstart#,loopz#,dist#,ce#,cs#,blks#,conc#,meml#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp
.| Aufruf in : ldhlp-1,conspace-1,coninsert-1,
@markhlp
bpos=0
IF master=0 THEN
bstart=0
ENDIF
IF master>0 AND master<loopz THEN
bstart=loops(master)
ENDIF
IF master>loopz AND master<loopz*2 THEN
bstart=loope(master-loopz)
ENDIF
dist=ce-cs
IF blks=1 THEN
bpos=bstart
ENDIF
conc=bstart
bstart=bstart+meml
bstart=INT(bstart/4)*4
RETURN
'
> PROCEDURE fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
.| Glob. Var.: pret#,pbutt#
.| Ruft auf  : ain
.| Aufruf in : fileselect-1,
LPOKE ADDRIN,fs_iinpath%
LPOKE ADDRIN+4,fs_iinsel%
LPOKE ADDRIN+8,fs_iinlabel%
@ain(91,0,2,3,0)
pret=GINTOUT(0)
pbutt=GINTOUT(1)
RETURN
'
> PROCEDURE ain(g0%,g2%,g4%,g6%,g8%)
.| Aufruf in : fsel_exinput-1,
DPOKE GCONTRL,g0%
DPOKE GCONTRL+2,g2%
DPOKE GCONTRL+4,g4%
DPOKE GCONTRL+6,g6%
DPOKE GCONTRL+8,g8%
GEMSYS
RETURN
'
> PROCEDURE fileselect(a$,b$,c$)
.| Glob. Var.: fs_iinpath%,fs_iinsel%,fs_iinlabel%,a#,ordner$,nam$,fil$
.| Ruft auf  : fsel_exinput
.| Aufruf in : fadesave-1,fadeload-1,smpsave-1,newfsel-3,ldhlp-1,trakload-1
.|     hardfs-1,arrload-1,arrsave-1,make-1,fseldef-1,coninsert-1,smpplay-1
.|     record3-1,
~GRAF_MOUSE(256,0)                              ! Hidem
'  ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
a$=a$+CHR$(0)+SPACE$(100)
fs_iinpath%=VARPTR(a$)
b$=b$+CHR$(0)+SPACE$(100)
fs_iinsel%=VARPTR(b$)
c$=c$+CHR$(0)+SPACE$(100)
fs_iinlabel%=VARPTR(c$)
@fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
a=INSTR(a$,CHR$(0))
a$=LEFT$(a$,a-1)
a=INSTR(b$,CHR$(0))
b$=LEFT$(b$,a-1)
a=RINSTR(a$,"\")
IF LEN(a$)=0 THEN
ordner$=""
ELSE
ordner$=LEFT$(a$,a)
ENDIF
IF LEN(b$)=0 THEN
nam$=""
fil$=""
ELSE
nam$=b$
fil$=ordner$+b$
ENDIF
IF nr=fsel& THEN
@rsc_back(nr)
@rsc_draw(nr,0)
ENDIF
'  @rsc_put(ab,rscx&(nr),rscy&(nr),1)
'  @rsc_redraw_obj(nr,0)
RETURN
'
> PROCEDURE markset
.| Glob. Var.: markfre#,sms#,sme#,ah#,ah2#,nr#,smpedit&,t$,loopz#
.| Felder    : loope#(),loops#()
.| Ruft auf  : selblksbut,selblkebut,markhlp6,markhlp3
.| Aufruf in : sampleinf-1,
LOCAL i
FOR i=1 TO 5
IF markfre=i THEN
sms=i
sme=i
loope(i)=ah
loops(i)=ah2
IF nr=smpedit& THEN
@selblksbut(i,1)
@selblkebut(i,1)
t$=CHR$(ASC("a")-1+i)
@markhlp6(loops(i))
t$=CHR$(ASC("A")-1+i)
@markhlp6(loope(i))
@markhlp3(i,loops(i))
@markhlp3(i+loopz,loope(i))
ENDIF
ENDIF
NEXT i
RETURN
'
> PROCEDURE ldhztest
.| Glob. Var.: extclock#,per#,hz#,nr#,smp16&,a$,popups&,ad32&,rate2&,ad44&
.|     ad48&,retime#,hzm#,sblock#,sret#,smpedit&,fileart#,smppmark&
.| Ruft auf  : textfeld,adlow,admid,adhigh,setbutton
.| Aufruf in : ldhlp-6,ldhead-1,
hz=per
@fliphz
@fliphz2
IF per<>8000 AND per<>11000 AND per<>12000 AND per<>16000 AND per<>17000 AND per<>22000 AND per<>24000 AND per<>33000 AND per<>66000 AND per<>128 AND per<>192 AND per<>256 AND per<>384 AND per<>32000 AND per<>44100 AND per<>48000 THEN
retime=1
per=INT(per/100)*100
hz=per
hzm=hz
ENDIF
sblock=0
sret=0
IF nr=smpedit& AND (fileart=5 OR fileart=4) THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE writehzm
.| Glob. Var.: retime#,hz#,hzm#,p$,nr#,smpedit&,smprate&,smp16&
.| Ruft auf  : textfeld,deladbutt
.| Aufruf in : ldready-1,
IF retime=1 THEN
hz=hzm
p$=STR$(hzm/1000)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
IF nr=smp16& THEN
@fliphz
ENDIF
ELSE
p$="    "+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE sdload
.| Glob. Var.: loded#,ea#,eb#,ret#,hdl#,al$,head#,datx#,samlen#,mdat%,hbuf#
.|     a#,ar$,g#,ec#,fil$
.| Ruft auf  : maschinit37,maschruf37
.| Aufruf in : ldhlp-2,
loded=FALSE
IF ea=TRUE AND eb=TRUE THEN
ret=0
hdl=GEMDOS(61,L:VARPTR(al$),0)
~GEMDOS(66,L:head,hdl,0)
@maschinit37
@maschruf37(datx,datx+samlen,mdat%+2048,mdat%+hbuf-4,hdl,ret)
a=GEMDOS(62,hdl)
IF ret=(datx+samlen) THEN
ret=0
hdl=GEMDOS(61,L:VARPTR(ar$),0)
~GEMDOS(66,L:head,hdl,0)
@maschruf37(datx+2,datx+samlen+2,mdat%+2048,mdat%+hbuf-4,hdl,ret)
~GEMDOS(62,hdl)
IF ret<>datx+samlen+2 THEN
ALERT 1,"Ladefehler !",1,"EXIT",g
loded=FALSE
ELSE
loded=TRUE
IF ec=FALSE THEN
a=INSTR(fil$,".")
fil$=LEFT$(fil$,a-2)+RIGHT$(fil$,LEN(fil$)-a+1)
ENDIF
ENDIF
ELSE
loded=FALSE
ALERT 1,"Ladefehler !",1,"EXIT",g
ENDIF
ELSE
ALERT 1,"File not found !",1,"EXIT",g
loded=FALSE
ENDIF
RETURN
'
> PROCEDURE findblock
.| Glob. Var.: sa#,se#,ah2#,bpos#,ah#,vmem#,sret#,a#,sblock#,markfre#
.|     markfull#,sms#,sme#,nr#,smpedit&,loopz#
.| Felder    : loope#(),loops#()
.| Ruft auf  : marksearch,markhlp3
.| Aufruf in : ldhlp-1,sampleinf-1,
IF sa<>se AND se<>0 AND sa<>&HFFFFFFFF AND sa<>-1 AND se<>&HFFFFFFFF AND se<>-1 THEN
ah2=sa+bpos
ah=se+bpos
IF ah>vmem THEN
ah=vmem
ENDIF
IF ah2>vmem THEN
ah2=vmem
ENDIF
IF ah=vmem AND ah2=vmem THEN
ah2=-1
ah=-1
ENDIF
IF ah<ah2 THEN
sret=1                ! RÅckwÑrts-Loop
a=ah2
ah2=ah
ah=a
ENDIF
IF ah<>-1 AND ah2<>-1 THEN
sblock=1
@marksearch
IF markfre>0 AND markfull=FALSE THEN
sms=markfre
sme=markfre
loope(markfre)=ah
loops(markfre)=ah2
IF nr=smpedit& THEN
@markhlp3(markfre,loops(markfre))
@markhlp3(markfre+loopz,loope(markfre))
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE ldready
.| Glob. Var.: sms#,loopz#,sme#,cached#,loded#,lz#,path$,fil$,smpnam$,bnam$
.| Ruft auf  : selblksbut,selblkebut,writehzm
.| Aufruf in : ldhlp-7,
IF sms>0 AND sms<loopz THEN
@selblksbut(sms,1)
ENDIF
IF sme>0 AND sme<loopz THEN
@selblkebut(sme,1)
ENDIF
cached=FALSE
loded=TRUE
lz=1
path$=fil$
smpnam$=bnam$
@writehzm
RETURN
'
> PROCEDURE fileart
head=0
fileart=0
abz=DPEEK(datx)
abz2=LPEEK(datx)
IF abz=&HF07E THEN
head=20   ! HeaderlÑnge fÅr S16-Files
fileart=1
ENDIF
IF abz2=&H32424954 THEN
head=128   ! HeaderlÑnge fÅr AVR-Files
fileart=2
ENDIF
IF abz2=&H52494646 THEN
head=44   ! HeaderlÑnge fÅr WAV-Files
fileart=3
ENDIF
IF abz2=&H2E736E64 THEN
head=28   ! HeaderlÑnge fÅr AU und SND-Files
fileart=4
ENDIF
abz=head
IF abz2=&H538000C THEN
head=1336 ! HeaderlÑnge fÅr SD-Files
fileart=5
IF virtld=FALSE THEN
ln=ln*2
ENDIF
abz=head*2+8
ENDIF
IF abz2=&HF07E0001 THEN
head=296 ! HeaderlÑnge fÅr Avalon SMP-Files
fileart=6
IF virtld=FALSE THEN
ln=ln*2
ENDIF
abz=head*2+8
ENDIF
RETURN
'
> PROCEDURE fileart2
IF fileart=6 THEN
SEEK #1,LOF(#1)-head
ENDIF
BGET #1,datx,head
IF fileart=6 THEN
SEEK #1,20
ENDIF
RETURN
'
> PROCEDURE ldhlp
.| Glob. Var.: loded#,inf#,virtual#,rett#,virt$,virt2$,virtld#,blockld#
.|     mrkobj#,obj#,savexit&,retime#,shlp#,lready#,cs#,ce#,vmem#,head#,x#,y#
.|     w#,h#,neufsel#,op$,ext$,pathda#,fil$,pret#,pbutt#,datx#,mdat%,ln#
.|     mlen#,blks#,anfloadx#,meml#,mt#,bstart#,memh#,fileart#,abz#,abz2#
.|     ln2#,lded#,danf#,vfileart#,vhead#,vhbldstrt#,hbldlen#,a#,tst1#,per#
.|     samlen#,ec#,al$,ar$,ea#,eb#,bnam$,nam$,smplen#,sblock#,j#,sa#,se#,nr#
.|     smpedit&,smppmark&,okmark#,sms#,sme#,vlmin#,lmin#,vlma#,lma#,tst2#
.|     dazu#,tst3#,tst4#,tst5#,tst6#,dmagic#,ov#,la#,sret#,ah#,bpos#,ah2#
.|     x2#,y2#,ldlen#,perm#,x3#,y3#,x4#,y4#,hz#,hzm#,b#,l#,smrk#,big#
.|     virtcurve#,maxcwert#,profln#,profhz#,vtst#,mbs#,vorln#,lz#,hard&
.|     vmeml#,vmemh#,hrd#,vce#,vcs#,virtex#,g#,lmax3#,vmbs#,zoomp#
.| Felder    : bloops#(),bloope#(),mblocks#(),mblocke#(),mblockp$()
.| Ruft auf  : infhol,blklfrag,maschinit,newfsel,fileselect,busy_mouse
.|     blkltest,markdel,clsed,markhlp,ldhztest,sampleinf,findblock,setbutton
.|     sdload,maschinit38,maschruf38,ldready,maschinit28,maschruf28,makehz
.|     maschruf,ldhead,virtual,ldhlp,hardproof,infrett,fnamwrite,zslidecalc
.| Aufruf in : smpload-1,ldhlp-2,
loded=FALSE
inf=FALSE
@infhol
IF virtual=FALSE AND rett=TRUE THEN
IF EXIST(virt$)=TRUE AND EXIST(virt2$)=TRUE THEN
KILL virt$
KILL virt2$
ENDIF
rett=FALSE
ENDIF
IF (virtld=TRUE AND (blockld=TRUE OR virtual=TRUE)) OR (virtld=FALSE AND blockld=FALSE AND virtual=FALSE) THEN
IF virtld=FALSE THEN
IF neufsel=FALSE THEN
@blklfrag
mrkobj=obj
ELSE
blks=0
ENDIF
ENDIF
IF obj<>savexit& THEN
retime=0
shlp=0
lready=0
cs=0
ce=vmem
head=20   ! HeaderlÑnge fÅr S16-Files
@maschinit
x=100
y=100
w=400
h=400
IF virtld=FALSE THEN
IF neufsel=TRUE THEN
@newfsel
ELSE
@fileselect(op$+"*."+ext$,"","LOAD:")
ENDIF
ENDIF
@busy_mouse
pathda=EXIST(fil$)
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pathda=TRUE AND pret<>0 AND pbutt=1 THEN
datx=mdat%
OPEN "I",#1,fil$
IF virtld=FALSE THEN
ln=LOF(#1)
ENDIF
BGET #1,datx,4
CLOSE #1
@blkltest
IF (virtld=FALSE AND (ln-head)<=mlen) OR blockld=TRUE THEN
IF blks=0 THEN
anfloadx=meml
mt=INT(mlen/4)*4
ELSE
anfloadx=bstart
mt=memh-bstart
ENDIF
ELSE
IF blks=0 OR virtual=TRUE THEN
anfloadx=meml
mt=INT(mlen/4)*4
ELSE
anfloadx=bstart
mt=memh-bstart
ENDIF
ENDIF
@fileart
IF anfloadx<>0 AND anfloadx<>-1 AND (ln-abz)<=mt THEN
lready=1
ln2=ln
IF blks=0 THEN
@markdel
ENDIF
ln=ln2
datx=((INT(anfloadx/4))*4)+4
OPEN "I",#1,fil$
@fileart2
lded=1
@clsed
danf=datx
IF blockld=TRUE AND virtld=TRUE THEN
fileart=vfileart
head=vhead
SEEK #1,vhbldstrt+head
ln=hbldlen
ENDIF
'
IF fileart=6 THEN          ! Avalon SMP-Format
@markhlp
a=datx
tst1=DPEEK(danf+76)    ! Bits
IF tst1=16 THEN
per=LPEEK(danf+72)     ! Sample-Rate
@ldhztest
samlen=LPEEK(danf+92)*4 ! datasize
ln=samlen
bloops(7)=LPEEK(danf+32)
bloope(7)=LPEEK(danf+64)
bloops(6)=LPEEK(danf+28)
bloope(6)=LPEEK(danf+60)
bloops(5)=LPEEK(danf+24)
bloope(5)=LPEEK(danf+56)
bloops(4)=LPEEK(danf+20)
bloope(4)=LPEEK(danf+52)
bloops(3)=LPEEK(danf+16)
bloope(3)=LPEEK(danf+48)
bloops(2)=LPEEK(danf+12)
bloope(2)=LPEEK(danf+44)
bloops(1)=LPEEK(danf+8)
bloope(1)=LPEEK(danf+40)
ec=FALSE
a=RINSTR(fil$,".")
al$=LEFT$(fil$,a-2)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
a=RINSTR(fil$,".")
ar$=LEFT$(fil$,a-2)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ea=EXIST(al$)
eb=EXIST(ar$)
IF ea=FALSE OR eb=FALSE THEN
IF EXIST(fil$)=TRUE THEN
al$=fil$
ar$=fil$
ea=TRUE
eb=TRUE
ec=TRUE
ENDIF
ENDIF
bnam$=nam$
smplen=ln
IF ec=FALSE THEN
a=RINSTR(nam$,".")
bnam$=LEFT$(nam$,a-2)+RIGHT$(nam$,LEN(nam$)-a+1)
ENDIF
head=20
@sampleinf
IF inf=TRUE THEN
sblock=0
FOR j=1 TO 7
sa=bloops(j)*4
se=bloope(j)*4
@findblock
NEXT j
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
IF sblock=0 THEN
okmark=0
sms=0
sme=0
ENDIF
vlmin=lmin
vlma=lma
CLOSE #1
@sdload
@maschinit38
@maschruf38(datx,datx+samlen)
@ldready
ELSE
CLOSE #1
ENDIF
ENDIF
ENDIF
'
IF fileart=5 THEN          ! SD-Format
@markhlp
a=datx
per=LPEEK(danf+1020)     ! Sample-Rate
@ldhztest
samlen=LPEEK(danf+148)*2 ! datasize
okmark=0
sms=0
sme=0
ln=samlen
ec=FALSE
a=INSTR(fil$,".")
al$=LEFT$(fil$,a-2)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
a=INSTR(fil$,".")
ar$=LEFT$(fil$,a-2)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ea=EXIST(al$)
eb=EXIST(ar$)
IF ea=FALSE OR eb=FALSE THEN
IF EXIST(fil$)=TRUE THEN
al$=fil$
ar$=fil$
ea=TRUE
eb=TRUE
ec=TRUE
ENDIF
ENDIF
bnam$=nam$
IF ec=FALSE THEN
a=INSTR(nam$,".")
bnam$=LEFT$(nam$,a-2)+RIGHT$(nam$,LEN(nam$)-a+1)
ENDIF
smplen=ln
@sampleinf
IF inf=TRUE THEN
vlmin=lmin
vlma=lma
CLOSE #1
@sdload
@ldready
ELSE
CLOSE #1
ENDIF
ENDIF
'
IF fileart=4 THEN        ! AU-Format
@markhlp
a=datx
tst1=LPEEK(danf+12)    ! dataformat
tst2=LPEEK(danf+20)    ! channelcount
IF tst1=3 AND tst2=2 THEN
per=LPEEK(danf+16)    ! Sample-Rate
@ldhztest
samlen=LPEEK(danf+8)        ! datasize
okmark=0
sms=0
sme=0
dazu=LPEEK(danf+4)-28       !datalocation
IF dazu>0 THEN
BGET #1,datx,dazu
ENDIF
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
vlmin=0
vlma=0
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=3 THEN        ! WAV-Format
@markhlp
a=datx
tst1=LPEEK(danf+8)     ! "WAVE"
tst2=LPEEK(danf+12)    ! "fmt "
tst3=PEEK(danf+20)     ! format
tst4=PEEK(danf+22)     ! channels
tst5=PEEK(danf+32)     ! align
tst6=PEEK(danf+34)     ! bps
IF tst1=&H57415645 AND tst2=&H666D7420 AND tst3=1 AND tst4=2 AND tst5=4 AND tst6=16 THEN
per=PEEK(danf+24)+256*PEEK(danf+25)    ! Sample-Rate
@ldhztest
dmagic=&H64617461
IF LPEEK(danf+36)=dmagic THEN
samlen=PEEK(danf+40)+256*PEEK(danf+41)+65536*PEEK(danf+42)+&H1000000*PEEK(danf+43)
ov=danf+36
ELSE
ov=40
REPEAT
dazu=PEEK(danf+ov)+256*PEEK(danf+ov+1)+65536*PEEK(danf+ov+2)+&H1000000*PEEK(danf+ov+3)
head=head+dazu+8
ov=4
IF ln>=head THEN
BGET #1,datx,dazu+8
IF LPEEK(danf+dazu)=dmagic THEN
samlen=PEEK(danf+dazu+4)+256*PEEK(danf+dazu+5)+65536*PEEK(danf+dazu+6)+&H1000000*PEEK(danf+dazu+7)
ENDIF
ENDIF
UNTIL LPEEK(danf+dazu)=dmagic OR ln<head
ov=danf+dazu
ENDIF
okmark=0
sms=0
sme=0
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
IF LPEEK(ov)=dmagic THEN
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
vlmin=0
vlma=0
BGET #1,datx,samlen
@maschinit28
@maschruf28(datx,samlen)
@ldready
ENDIF
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=2 THEN        ! AVR-Format
@markhlp
a=datx
tst1=DPEEK(danf+12)    ! mode
tst2=DPEEK(danf+14)    ! resolution
tst3=DPEEK(danf+16)    ! sign
IF tst1=&HFFFF AND tst2=16 AND tst3=&HFFFF THEN
per=DPEEK(danf+24)    ! Sample-Rate
@ldhztest
la=DPEEK(danf+18)                           ! Loop ?
sblock=0
sret=0
IF la=&HFFFF THEN
sblock=1
ENDIF
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
samlen=LPEEK(danf+26)*2
IF sblock=1 THEN
lmin=LPEEK(danf+30)*2                          ! Sustain Loop-Start
lma=LPEEK(danf+34)*2                           ! Sustain Loop-End
IF lma<lmin THEN
sret=1                ! RÅckwÑrts-Loop
a=lmin
lmin=lma
lma=a
ENDIF
ah=lma+bpos
ah=INT(ah)
ah2=lmin+bpos
ah2=INT(ah2)
IF ah>vmem THEN
ah=vmem
ENDIF
IF ah2>vmem THEN
ah2=vmem
ENDIF
ELSE
okmark=0
sms=0
sme=0
ENDIF
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
vlmin=lmin
vlma=lma
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=1 THEN                   ! S16-Format
@markhlp
a=datx
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
x2=DPEEK(danf+10)                          ! Sample Len in Worten
y2=PEEK(danf+12)                           ! Sample Len in Worten
ldlen=(x2*256+y2)*2
per=INT(10^9/(x*65536+y))
perm=INT(per/100)*100
per=INT(perm)
@ldhztest
la=PEEK(danf+19)                           ! Loop-Art
sblock=1
IF la=0 THEN
sret=0
ENDIF
IF la=1 THEN
sret=1
ENDIF
IF la=&H7F THEN
sblock=0
ENDIF
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
IF sblock=1 THEN
x3=PEEK(danf+13)                           ! Sustain Loop-Start
y3=DPEEK(danf+14)                          ! Sustain Loop-Start
lmin=x3*65536+y3
x4=DPEEK(danf+16)                          ! Sustain Loop-End
y4=PEEK(danf+18)                           ! Sustain Loop-End
lma=x4*256+y4
ah=lma+bpos
ah=INT(ah)
ah2=lmin+bpos
ah2=INT(ah2)
IF ah>vmem THEN
ah=vmem
ENDIF
IF ah2>vmem THEN
ah2=vmem
ENDIF
ELSE
okmark=0
sms=0
sme=0
ENDIF
samlen=ln-head
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
vlmin=lmin
vlma=lma
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ENDIF
'
IF fileart=0 THEN              ! Rohdaten-Format
samlen=ln-head
bnam$=nam$
smplen=samlen
@makehz
per=hz
@sampleinf
IF inf=TRUE THEN
vlmin=0
vlma=0
BGET #1,datx+head,samlen
@ldready
a=datx
okmark=0
sms=0
sme=0
hzm=hz
ENDIF
CLOSE #1
ENDIF
IF inf=TRUE THEN
a=datx
IF blks=0 THEN
b=meml
l=memh-meml
shlp=1
smrk=meml+(ln-head)
smrk=INT(smrk/4)*4
ELSE
shlp=0
b=bstart
l=memh-bstart
ENDIF
IF big=0 THEN
@maschruf
ENDIF
IF vmem<=mlen AND (virtual=TRUE OR blockld=TRUE) THEN
virtual=FALSE
blockld=FALSE
virtld=FALSE
virtcurve=FALSE
maxcwert=0
ce=mlen
cs=0
vmem=INT(mlen/4)*4
ENDIF
IF virtual=FALSE AND blockld=FALSE THEN
profln=ln
profhz=hz
ENDIF
ENDIF
ELSE
vhead=head
vfileart=fileart
vtst=TRUE
bnam$=nam$
smplen=ln
per=0
@ldhead
IF per=0 THEN
@makehz
per=hz
ENDIF
@sampleinf
vtst=FALSE
IF inf=TRUE THEN
@virtual
IF blockld=TRUE THEN
IF blks=0 THEN
mbs=0
ENDIF
ln=mt-4
obj=mrkobj
virtld=TRUE
@ldhlp
virtld=FALSE
vorln=ln
lz=1
vmem=INT(mlen/4)*4
ENDIF
IF virtual=TRUE THEN
mbs=0
IF nr=smpedit& THEN
@setbutton(hard&,1)
ENDIF
vmem=ln-head
vmeml=0
vmemh=mt
hrd=1
@hardproof
ln=mt
obj=mrkobj
blks=0
virtld=TRUE
@ldhlp
virtld=FALSE
@markdel
@clsed
ln=vmem
vce=0
vcs=0
lz=1
ENDIF
IF virtex=TRUE THEN
@infrett
ENDIF
ENDIF
ENDIF
IF inf=FALSE THEN
@infrett
ENDIF
@fnamwrite
ENDIF
ENDIF
ELSE
ALERT 1,"Sample in virt. Bearbeitung !|Sample mit Trash lîschen.",1,"OK",g
ENDIF
obj=0
blockld=FALSE
IF loded=TRUE AND virtual=FALSE THEN
INC mbs
IF blks=1 THEN
mblocks(mbs)=bstart-meml
mblocke(mbs)=bstart+samlen-meml
ELSE
mbs=1
mblocks(mbs)=0
mblocke(mbs)=samlen
ENDIF
mblockp$(mbs)=fil$
IF mbs>lmax3 THEN
mbs=1
ENDIF
vmbs=mbs
ENDIF
IF loded=TRUE THEN
zoomp=0
@zslidecalc
ENDIF
IF inf=FALSE THEN
@infrett
ENDIF
RETURN
'
> PROCEDURE infrett
.| Glob. Var.: per#,vper#,path$,vpath$,smpnam$,vsmpnam$,smplen#,vsmplen#
.|     mrkdatum$,vmrkdatum$,retime#,vretime#,ordner$,vordner$,cs#,vorcs#,ce#
.|     vorce#,i#,loopz#,bloopz#,sblock#,vsblock#,lz#,vlz#,mbs#,vmbs#,sms#
.|     vsms#,sme#,vsme#,master#,vmaster#,zoomp#,vzoomp#,srollp#,vscrollp#
.|     sloop#,vsloop#,mamidi#,vmamidi#,loded#
.| Felder    : loops#(),vloops#(),loope#(),vloope#(),bloops#(),vbloops#()
.|     bloope#(),vbloope#()
.| Ruft auf  : makehz
.| Aufruf in : ldhlp-3,sampleinf-1,
per=vper
path$=vpath$
smpnam$=vsmpnam$
smplen=vsmplen
mrkdatum$=vmrkdatum$
retime=vretime
ordner$=vordner$
IF retime=1 THEN
@makehz
ENDIF
cs=vorcs
ce=vorce
FOR i=1 TO loopz
loops(i)=vloops(i)
loope(i)=vloope(i)
NEXT i
FOR i=1 TO bloopz
bloops(i)=vbloops(i)
bloope(i)=vbloope(i)
NEXT i
sblock=vsblock
lz=vlz
mbs=vmbs
sms=vsms
sme=vsme
master=vmaster
zoomp=vzoomp
srollp=vscrollp
sloop=vsloop
mamidi=vmamidi
loded=FALSE
RETURN
'
> PROCEDURE infhol
.| Glob. Var.: vper#,per#,vpath$,path$,vsmpnam$,smpnam$,vsmplen#,smplen#
.|     vordner$,ordner$,vmrkdatum$,mrkdatum$,vretime#,retime#,vorcs#,cs#
.|     vorce#,ce#,i#,loopz#,bloopz#,vsblock#,sblock#,vsloop#,sloop#,vmamidi#
.|     mamidi#,vlz#,lz#,vmbs#,mbs#,vsms#,sms#,vsme#,sme#,vmaster#,master#
.|     vzoomp#,zoomp#,vsrollp#,scrollp#
.| Felder    : vloops#(),loops#(),vloope#(),loope#(),vbloops#(),bloops#()
.|     vbloope#(),bloope#()
.| Aufruf in : smpsave-1,ldhlp-1,record4-1,
vper=per
vpath$=path$
vsmpnam$=smpnam$
vsmplen=smplen
vordner$=ordner$
vmrkdatum$=mrkdatum$
vretime=retime
vorcs=cs
vorce=ce
FOR i=1 TO loopz
vloops(i)=loops(i)
vloope(i)=loope(i)
NEXT i
FOR i=1 TO bloopz
vbloops(i)=bloops(i)
vbloope(i)=bloope(i)
NEXT i
vsblock=sblock
vsloop=sloop
vmamidi=mamidi
vlz=lz
vmbs=mbs
vsms=sms
vsme=sme
vmaster=master
vzoomp=zoomp
vsrollp=scrollp
RETURN
'
> PROCEDURE makedatum
.| Glob. Var.: mrkdatum$
.| Aufruf in : smpsave-1,smpinfbutt-1,record4-1,
LOCAL d$
d$=DATE$
mrkdatum$=LEFT$(d$,LEN(d$)-4)+RIGHT$(d$,2)+"  "+LEFT$(TIME$,5)+CHR$(0)
RETURN
'
> PROCEDURE smpinfbutt
.| Glob. Var.: obj#,bnam$,smpnam$,fil$,path$,mbs#,virtual#,smplen#,vmem#
.|     per#,hz#,infbutt#
.| Ruft auf  : setbutton,makedatum,makehz,sampleinf
.| Aufruf in : do_smpedit-1,
LOCAL d$
@setbutton(obj,0)
bnam$=smpnam$
fil$=path$
IF mbs=0 AND virtual=FALSE THEN
smplen=vmem
@makedatum
@makehz
per=hz
ENDIF
infbutt=TRUE
@sampleinf
infbutt=FALSE
RETURN
'
> PROCEDURE sampleinf
.| Glob. Var.: virtld#,vornr#,nr#,smpinf&,infbutt#,sinfcomm&,sinfsrc&,isave#
.|     sinfname&,bnam$,smplen#,per#,sinflen&,sinfrate&,fil$,mdat2%,mrkdatum$
.|     sinfdate&,fileart#,i#,bloopz#,lma#,vtst#,sblock#,lmin#,c$,src$,b$
.|     ordner$,inf$,j#,markfull#,sa#,se#,scr$,sinfsus1&,sinfsus2&,sinfrel1&
.|     sinfrel2&,sinfl1&,sinfl2&,sinfl3&,sinfl4&,sinfl5&,sinfl6&,sinfl7&
.|     sinfl8&,sinfl9&,sinfl10&,sinfl11&,sinfl12&,l#,hz#,xlmin#,xlma#,obj#
.|     popup&,zu%,zuadr#,edit_obj&,buttadr#,but#,objadr#,objflag#,sinhelp&
.|     sinfexit&,sinfok&,inf#,head#,mlen#,blockld#,blks#,meml#,memh#
.|     commtxt$,srctxt$,infname$
.| Felder    : bloops#(),bloope#(),loops#(),loope#()
.| Ruft auf  : rsc_draw,editfeld,markhlp,textfeld,marksearch,findblock
.|     markset,blocklook,markhlp7,rsc_do,xrsrc_gaddr,mousek,helptxt
.|     busy_mouse,maschinit9,maschruf9,infrett,editread,setbutton,restaura2
.|     rsc_back,restaura3
.| Aufruf in : smpsave-1,ldhlp-8,smpinfbutt-1,record4-1,
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
LOCAL a,b,t,d,m,day,a$,f$,vcs,vce,vln,t$,d$,exi
IF virtld=FALSE THEN
vornr=nr
nr=smpinf&
IF infbutt=TRUE THEN
@rsc_draw(nr,0)    ! sollte 5 sein
ELSE
@rsc_draw(nr,0)
ENDIF
@editfeld(sinfcomm&,CHR$(0))
@editfeld(sinfsrc&,CHR$(0))
@markhlp
IF isave=FALSE THEN
@textfeld(sinfname&,bnam$+CHR$(0),1)
a$=STR$(INT(smplen/4))+" samples = "+STR$(INT(smplen/per/4*1000)/1000)+" sec"+CHR$(0)
IF LEN(a$)>35 THEN
a$=STR$(INT(smplen/4))+"/"+STR$(INT(smplen/per/4*1000)/1000)+CHR$(0)
ENDIF
IF LEN(a$)>35 THEN
a$=STR$(INT(smplen/4))+" samples"+CHR$(0)
ENDIF
@textfeld(sinflen&,a$,1)
a$=STR$(INT(per/100)/10)+" KHz"+CHR$(0)
@textfeld(sinfrate&,a$,1)
IF infbutt=FALSE THEN
f$=fil$+CHR$(0)
a=GEMDOS(61,L:VARPTR(f$),0)
IF a>=0 THEN
~GEMDOS(87,L:mdat2%,a,0)
b=GEMDOS(62,a)
t=DPEEK(mdat2%)
d=DPEEK(mdat2%+2)
day=(d AND 31)
d=(d AND (65535-31))
d=SHR(d,5)
m=(d AND 15)
d=80+SHR(d,4)
IF d>99 THEN
d=d-100
ENDIF
d$=RIGHT$("0"+STR$(d),2)
a$=STR$(day)+"."+STR$(m)+"."+d$
t=SHR(t,5)
d=(t AND 63)
d$=RIGHT$("0"+STR$(d),2)
t=SHR(t,6)
t$=RIGHT$("0"+STR$(t),2)
a$=a$+"  "+t$+":"+d$+CHR$(0)
mrkdatum$=a$
@textfeld(sinfdate&,a$,1)
ELSE
a$=CHR$(0)
@textfeld(sinfdate&,a$,1)
ENDIF
ELSE
@textfeld(sinfdate&,mrkdatum$,1)
ENDIF
IF infbutt=FALSE THEN
IF fileart<>6 THEN
FOR i=1 TO bloopz
bloops(i)=-1
bloope(i)=-1
NEXT i
IF lma>0 AND vtst=FALSE AND sblock=1 THEN
bloops(1)=INT(lmin/4)
bloope(1)=INT(lma/4)
ENDIF
ENDIF
c$=""
src$=""
a=RINSTR(bnam$,".")
b$=ordner$+LEFT$(bnam$,a)+inf$
exi=FALSE
IF EXIST(b$)=TRUE THEN
exi=TRUE
OPEN "I",#2,b$
FOR i=1 TO bloopz
INPUT #2,bloops(i)
INPUT #2,bloope(i)
NEXT i
IF fileart<>6 THEN
FOR j=1 TO bloopz
@marksearch
IF markfull=FALSE THEN
sa=bloops(j)*4
se=bloope(j)*4
ENDIF
@findblock
NEXT j
ENDIF
REPEAT
INPUT #2,a$
IF a$<>CHR$(0) THEN
c$=c$+a$
ENDIF
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
c$=c$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
REPEAT
INPUT #2,a$
IF a$<>CHR$(0) THEN
src$=src$+a$
ENDIF
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
scr$=scr$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
CLOSE #2
ELSE
IF fileart=1 OR fileart=2 THEN
@marksearch
@markset
ENDIF
ENDIF
ENDIF
IF bloops(1)<>-1 THEN
@textfeld(sinfsus1&,STR$(bloops(1))+CHR$(0),1)
ELSE
@textfeld(sinfsus1&,CHR$(0),1)
ENDIF
IF bloope(1)<>-1 THEN
@textfeld(sinfsus2&,STR$(bloope(1))+CHR$(0),1)
ELSE
@textfeld(sinfsus2&,CHR$(0),1)
ENDIF
IF fileart=6 OR exi=TRUE OR infbutt=TRUE THEN
IF exi=TRUE OR (infbutt=TRUE AND EXIST(b$)=TRUE) THEN
@editfeld(sinfcomm&,c$+CHR$(0))
@editfeld(sinfsrc&,src$+CHR$(0))
ELSE
@editfeld(sinfcomm&,CHR$(0))
@editfeld(sinfsrc&,CHR$(0))
ENDIF
IF bloops(2)<>-1 THEN
@textfeld(sinfrel1&,STR$(bloops(2))+CHR$(0),1)
ELSE
@textfeld(sinfrel1&,CHR$(0),1)
ENDIF
IF bloope(2)<>-1 THEN
@textfeld(sinfrel2&,STR$(bloope(2))+CHR$(0),1)
ELSE
@textfeld(sinfrel2&,CHR$(0),1)
ENDIF
IF bloops(3)<>-1 THEN
@textfeld(sinfl1&,STR$(bloops(3))+CHR$(0),1)
ELSE
@textfeld(sinfl1&,CHR$(0),1)
ENDIF
IF bloope(3)<>-1 THEN
@textfeld(sinfl2&,STR$(bloope(3))+CHR$(0),1)
ELSE
@textfeld(sinfl2&,CHR$(0),1)
ENDIF
IF bloops(4)<>-1 THEN
@textfeld(sinfl3&,STR$(bloops(4))+CHR$(0),1)
ELSE
@textfeld(sinfl3&,CHR$(0),1)
ENDIF
IF bloope(4)<>-1 THEN
@textfeld(sinfl4&,STR$(bloope(4))+CHR$(0),1)
ELSE
@textfeld(sinfl4&,CHR$(0),1)
ENDIF
IF bloops(5)<>-1 THEN
@textfeld(sinfl5&,STR$(bloops(5))+CHR$(0),1)
ELSE
@textfeld(sinfl5&,CHR$(0),1)
ENDIF
IF bloope(5)<>-1 THEN
@textfeld(sinfl6&,STR$(bloope(5))+CHR$(0),1)
ELSE
@textfeld(sinfl6&,CHR$(0),1)
ENDIF
IF bloops(6)<>-1 THEN
@textfeld(sinfl7&,STR$(bloops(6))+CHR$(0),1)
ELSE
@textfeld(sinfl7&,CHR$(0),1)
ENDIF
IF bloope(6)<>-1 THEN
@textfeld(sinfl8&,STR$(bloope(6))+CHR$(0),1)
ELSE
@textfeld(sinfl8&,CHR$(0),1)
ENDIF
IF bloops(7)<>-1 THEN
@textfeld(sinfl9&,STR$(bloops(7))+CHR$(0),1)
ELSE
@textfeld(sinfl9&,CHR$(0),1)
ENDIF
IF bloope(7)<>-1 THEN
@textfeld(sinfl10&,STR$(bloope(7))+CHR$(0),1)
ELSE
@textfeld(sinfl10&,CHR$(0),1)
ENDIF
IF bloops(8)<>-1 THEN
@textfeld(sinfl11&,STR$(bloops(8))+CHR$(0),1)
ELSE
@textfeld(sinfl11&,CHR$(0),1)
ENDIF
IF bloope(8)<>-1 THEN
@textfeld(sinfl12&,STR$(bloope(8))+CHR$(0),1)
ELSE
@textfeld(sinfl12&,CHR$(0),1)
ENDIF
ELSE
@editfeld(sinfcomm&,CHR$(0))
@editfeld(sinfsrc&,CHR$(0))
@textfeld(sinfrel1&,CHR$(0),1)
@textfeld(sinfrel2&,CHR$(0),1)
@textfeld(sinfl1&,CHR$(0),1)
@textfeld(sinfl2&,CHR$(0),1)
@textfeld(sinfl3&,CHR$(0),1)
@textfeld(sinfl4&,CHR$(0),1)
@textfeld(sinfl5&,CHR$(0),1)
@textfeld(sinfl6&,CHR$(0),1)
@textfeld(sinfl7&,CHR$(0),1)
@textfeld(sinfl8&,CHR$(0),1)
@textfeld(sinfl9&,CHR$(0),1)
@textfeld(sinfl10&,CHR$(0),1)
@textfeld(sinfl11&,CHR$(0),1)
@textfeld(sinfl12&,CHR$(0),1)
ENDIF
ELSE
@blocklook
d$=DATE$
d$=LEFT$(d$,LEN(d$)-4)+RIGHT$(d$,2)
@textfeld(sinfname&,bnam$+CHR$(0),1)
a$=STR$(INT(l/4))+" samples = "+STR$(INT(l/hz/4*1000)/1000)+" sec"+CHR$(0)
IF LEN(a$)>35 THEN
a$=STR$(INT(l/4))+"/"+STR$(INT(l/hz/4*1000)/1000)+CHR$(0)
ENDIF
IF LEN(a$)>35 THEN
a$=STR$(INT(l/4))+" samples"+CHR$(0)
ENDIF
@textfeld(sinflen&,a$+CHR$(0),1)
@textfeld(sinfrate&,STR$(INT(hz/100)/10)+" kHz"+CHR$(0),1)
@textfeld(sinfdate&,d$+"  "+LEFT$(TIME$,5)+CHR$(0),1)
IF sblock=1 THEN
xlmin=lmin
xlma=lma
@markhlp7
bloops(1)=INT(lmin/4)
bloope(1)=INT(lma/4)
@textfeld(sinfsus1&,STR$(bloops(1))+CHR$(0),1)
@textfeld(sinfsus2&,STR$(bloope(1))+CHR$(0),1)
lmin=xlmin
lma=xlma
ELSE
FOR i=1 TO bloopz
bloops(i)=-1
bloope(i)=-1
NEXT i
@textfeld(sinfsus1&,CHR$(0),1)
@textfeld(sinfsus2&,CHR$(0),1)
ENDIF
a=RINSTR(fil$,".")
b$=LEFT$(fil$,a)+inf$
@textfeld(sinfrel1&,CHR$(0),1)
@textfeld(sinfrel2&,CHR$(0),1)
IF loops(2)<>-1 THEN
@textfeld(sinfl1&,STR$(INT(loops(2)/4))+CHR$(0),1)
ELSE
@textfeld(sinfl1&,CHR$(0),1)
ENDIF
IF loope(2)<>-1 THEN
@textfeld(sinfl2&,STR$(INT(loope(2)/4))+CHR$(0),1)
ELSE
@textfeld(sinfl2&,CHR$(0),1)
ENDIF
IF loops(3)<>-1 THEN
@textfeld(sinfl3&,STR$(INT(loops(3)/4))+CHR$(0),1)
ELSE
@textfeld(sinfl3&,CHR$(0),1)
ENDIF
IF loope(3)<>-1 THEN
@textfeld(sinfl4&,STR$(INT(loope(3)/4))+CHR$(0),1)
ELSE
@textfeld(sinfl4&,CHR$(0),1)
ENDIF
IF loops(4)<>-1 THEN
@textfeld(sinfl5&,STR$(INT(loops(4)/4))+CHR$(0),1)
ELSE
@textfeld(sinfl5&,CHR$(0),1)
ENDIF
IF loope(4)<>-1 THEN
@textfeld(sinfl6&,STR$(INT(loope(4)/4))+CHR$(0),1)
ELSE
@textfeld(sinfl6&,CHR$(0),1)
ENDIF
IF loops(5)<>-1 THEN
@textfeld(sinfl7&,STR$(INT(loops(5)/4))+CHR$(0),1)
ELSE
@textfeld(sinfl7&,CHR$(0),1)
ENDIF
IF loope(5)<>-1 THEN
@textfeld(sinfl8&,STR$(INT(loope(5)/4))+CHR$(0),1)
ELSE
@textfeld(sinfl8&,CHR$(0),1)
ENDIF
@textfeld(sinfl9&,CHR$(0),1)
@textfeld(sinfl10&,CHR$(0),1)
@textfeld(sinfl11&,CHR$(0),1)
@textfeld(sinfl12&,CHR$(0),1)
ENDIF
REPEAT
REPEAT
obj=@rsc_do(nr,obj,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>sinfcomm& AND obj<>sinfsrc&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=sinhelp& THEN
@helptxt("SAMPLE-INFO")
ENDIF
UNTIL obj=sinfexit& OR obj=sinfok&
IF obj=sinfok& THEN
inf=TRUE
IF infbutt=FALSE THEN
@busy_mouse
ENDIF
IF ((virtld=FALSE AND (smplen-head)<=mlen) OR blockld=TRUE) AND blks=0 AND infbutt=FALSE AND isave=FALSE THEN
@maschinit9
@maschruf9(meml,memh)
ENDIF
ELSE
inf=FALSE
IF infbutt=FALSE THEN
@infrett
ENDIF
ENDIF
ELSE
inf=TRUE
ENDIF
IF isave=TRUE AND inf=TRUE THEN
@editread(sinfcomm&)
commtxt$=a$+CHR$(0)
@editread(sinfsrc&)
srctxt$=a$+CHR$(0)
infname$=b$
ENDIF
@setbutton(obj,0)
IF infbutt=TRUE THEN
@restaura2
ELSE
IF virtld=FALSE THEN
@rsc_back(nr)
nr=vornr
@restaura3
ENDIF
ENDIF
obj=0
RETURN
'
> PROCEDURE infsave
.| Glob. Var.: blks#,meml#,blksa#,blkse#,infname$,sector#,loopz#,bloopz#
.|     commtxt$,srctxt$
.| Felder    : loops#(),loope#()
.| Ruft auf  : nomem
.| Aufruf in : smpsave-1,record4-1,
LOCAL m,m2,a,b,i
IF blks=0 THEN
m=0
m2=meml
ELSE
m=blksa-meml
m2=blkse-meml
ENDIF
a=ASC(LEFT$(infname$,1))-64
IF DFREE(a)>sector THEN
OPEN "O",#2,infname$
a=loopz-1
IF a>bloopz THEN
a=bloopz
ENDIF
FOR i=1 TO a
b=INT((loops(i)-m)/4)
IF b<0 OR b>m2 THEN
b=-1
ENDIF
PRINT #2,b
b=INT((loope(i)-m)/4)
IF b<0 OR b>m2 THEN
b=-1
ENDIF
PRINT #2,b
NEXT i
IF a<bloopz THEN
FOR i=a+1 TO bloopz
PRINT #2,-1
PRINT #2,-1
NEXT i
ENDIF
PRINT #2,commtxt$
PRINT #2,srctxt$
CLOSE #2
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE ldhead
.| Glob. Var.: datx#,mdat%,fil$,f#,abz#,abz2#,head#,fileart#,danf#,tst1#
.|     per#,vhz#,tst2#,tst3#,tst4#,tst5#,tst6#,x#,y#,hz#
.| Ruft auf  : makehz,ldhztest
.| Aufruf in : ldhlp-1,trakload-1,hardfs-1,
datx=mdat%
OPEN "I",#1,fil$
f=LOF(#1)
BGET #1,datx,4
abz=DPEEK(datx)
abz2=LPEEK(datx)
IF abz=&HF07E THEN
head=20   ! HeaderlÑnge fÅr S16-Files
fileart=1
ENDIF
IF abz2=&H32424954 THEN
head=128   ! HeaderlÑnge fÅr AVR-Files
fileart=2
ENDIF
IF abz2=&H52494646 THEN
head=44   ! HeaderlÑnge fÅr WAV-Files
fileart=3
ENDIF
IF abz2=&H2E736E64 THEN
head=28   ! HeaderlÑnge fÅr AU und SND-Files
fileart=4
ENDIF
IF abz2=&H538000C THEN
head=1336 ! HeaderlÑnge fÅr SD-Files
fileart=5
ENDIF
IF abz2=&HF07E0001 THEN
head=296 ! HeaderlÑnge fÅr Avalon SMP-Files
fileart=6
ENDIF
IF head>4 THEN
IF fileart<>6 THEN
BGET #1,datx+4,head-4
ELSE
SEEK #1,LOF(#1)-head
BGET #1,datx,head
ENDIF
ENDIF
CLOSE #1
danf=datx
IF fileart=6 THEN        ! Avalon SMP-Format
tst1=DPEEK(danf+76)    ! Bits
IF tst1=16 THEN
per=LPEEK(danf+72)     ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=5 THEN        ! SD-Format
per=LPEEK(danf+1020)   ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
IF fileart=4 THEN        ! AU-Format
tst1=LPEEK(danf+12)    ! dataformat
tst2=LPEEK(danf+20)    ! channelcount
IF tst1=3 AND tst2=2 THEN
per=LPEEK(danf+16)    ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=3 THEN        ! WAV-Format
tst1=LPEEK(danf+8)     ! "WAVE"
tst2=LPEEK(danf+12)    ! "fmt "
tst3=PEEK(danf+20)     ! format
tst4=PEEK(danf+22)     ! channels
tst5=PEEK(danf+32)     ! align
tst6=PEEK(danf+34)     ! bps
IF tst1=&H57415645 AND tst2=&H666D7420 AND tst3=1 AND tst4=2 AND tst5=4 AND tst6=16 THEN
per=PEEK(danf+24)+256*PEEK(danf+25)    ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=2 THEN        ! AVR-Format
tst1=DPEEK(danf+12)    ! mode
tst2=DPEEK(danf+14)    ! resolution
tst3=DPEEK(danf+16)    ! sign
IF tst1=&HFFFF AND tst2=16 AND tst3=&HFFFF THEN
per=DPEEK(danf+24)    ! Sample-Rate
ENDIF
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
IF fileart=1 THEN                   ! S16-Format
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
IF x=0 AND y=0 THEN
@makehz
per=hz
ELSE
per=INT(10^9/(x*65536+y))
ENDIF
per=INT(per)
IF per<>32000 AND per<>44100 AND per<>48000 THEN
@ldhztest
ENDIF
vhz=per
ENDIF
IF fileart=0 THEN
vhz=INT(hz/100)*100
ENDIF
RETURN
'
> PROCEDURE clsed
.| Glob. Var.: nr#,smpedit&,smptsa&,smptsb&,smptsc&,smptsd&,smptse&
.|     smptsava&,smptea&,smpteb&,smptec&,smpted&,smptee&,smptsavb&,hacksa&
.|     hacksb&,hacksc&,hacksd&,hackse&,hackss&,hackea&,hackeb&,hackec&
.|     hacked&,hackee&,hackes&,smpsta&,smpstb&,smpstc&,smpstd&,smpste&
.|     smpsavl&,smpea&,smpeb&,smpec&,smped&,smpee&,smpsavr&,sms#,sme#
.|     master#,sblock#,smppmark&,sloop#,smploop&,a$,popups&,smpmark&,mover&
.|     smark#
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : ldhlp-2,smpedit-2,trash-2,memtovirt-1,memtovirt2-1,record2-1,
LOCAL hac$,mem$
mem$="     "+CHR$(0)
hac$=" "+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smptsa&,mem$,1)
@textfeld(smptsb&,mem$,1)
@textfeld(smptsc&,mem$,1)
@textfeld(smptsd&,mem$,1)
@textfeld(smptse&,mem$,1)
@textfeld(smptsava&,mem$,1)
@textfeld(smptea&,mem$,1)
@textfeld(smpteb&,mem$,1)
@textfeld(smptec&,mem$,1)
@textfeld(smpted&,mem$,1)
@textfeld(smptee&,mem$,1)
@textfeld(smptsavb&,mem$,1)
@textfeld(hacksa&,hac$,1)
@textfeld(hacksb&,hac$,1)
@textfeld(hacksc&,hac$,1)
@textfeld(hacksd&,hac$,1)
@textfeld(hackse&,hac$,1)
@textfeld(hackss&,hac$,1)
@textfeld(hackea&,hac$,1)
@textfeld(hackeb&,hac$,1)
@textfeld(hackec&,hac$,1)
@textfeld(hacked&,hac$,1)
@textfeld(hackee&,hac$,1)
@textfeld(hackes&,hac$,1)
@setbutton(smpsta&,0)
@setbutton(smpstb&,0)
@setbutton(smpstc&,0)
@setbutton(smpstd&,0)
@setbutton(smpste&,0)
@setbutton(smpsavl&,0)
@setbutton(smpea&,0)
@setbutton(smpeb&,0)
@setbutton(smpec&,0)
@setbutton(smped&,0)
@setbutton(smpee&,0)
@setbutton(smpsavr&,0)
ENDIF
sms=0
sme=0
master=0
sblock=0
IF nr=smpedit& THEN
@setbutton(smppmark&,0)
IF sloop=1 THEN
@setbutton(smploop&,1)
ELSE
@setbutton(smploop&,0)
ENDIF
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
ENDIF
smark=3
RETURN
'
> PROCEDURE curvetest(cs,ce)
.| Glob. Var.: zoomstop#
.| Aufruf in : zoomhelp-1,smpr-1,
zoomstop=FALSE
LOCAL xm,len,stp,bs
xm=617
len=ce-cs
stp=(INT(len/xm))
stp=(INT((stp+1)/4)*4)
bs=0
IF stp=0 THEN
stp=4
IF len>xm*4 THEN
bs=len/xm/4
ELSE
bs=xm*4/len
ENDIF
ENDIF
IF bs>7 THEN
zoomstop=TRUE
ENDIF
RETURN
'
> PROCEDURE drawcurve
.| Glob. Var.: spacefill#,u#,l#,bs#,a#,am#,vertline#,linkdot#,xdi#,ydi#,y2#
.| Aufruf in : curve-4,
IF spacefill=TRUE THEN
FOR u=l TO l+bs
LINE u,a,u,am
NEXT u
ENDIF
IF vertline=TRUE AND spacefill=FALSE THEN
LINE l,a,l,am
ENDIF
IF linkdot=TRUE AND spacefill=FALSE THEN
IF l>xdi-2 THEN
IF a<>ydi THEN
LINE l-bs,y2,l,a
y2=a
ELSE
LINE l-bs,y2,l,am
y2=am
ENDIF
ELSE
IF a<>ydi THEN
LINE l,y2,l,a
y2=a
ELSE
LINE l,y2,l,am
y2=am
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE writeyproz
.| Glob. Var.: max#,yzoom#,wyzoom#,rubmax#,rp0&,lp0&,lp20&,lm20&,rp20&,rm20&
.|     lp40&,lm40&,rp40&,rm40&,lp60&,lm60&,rp60&,rm60&,lp80&,lm80&,rp80&
.|     rm80&,byzoom#
.| Ruft auf  : textfeld
.| Aufruf in : rubbermax-1,curve-2,smpedit-1,
LOCAL a,m,b$
IF max=0 OR (yzoom=FALSE AND wyzoom=FALSE) THEN
m=32767
ELSE
m=max
ENDIF
IF wyzoom=TRUE THEN
m=rubmax
ENDIF
a=100/32767*m
b$=" 0-"+CHR$(0)
@textfeld(rp0&,b$,1)
@textfeld(lp0&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*2))+"-",3)+CHR$(0)
@textfeld(lp20&,b$,1)
@textfeld(lm20&,b$,1)
@textfeld(rp20&,b$,1)
@textfeld(rm20&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*4))+"-",3)+CHR$(0)
@textfeld(lp40&,b$,1)
@textfeld(lm40&,b$,1)
@textfeld(rp40&,b$,1)
@textfeld(rm40&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*6))+"-",3)+CHR$(0)
@textfeld(lp60&,b$,1)
@textfeld(lm60&,b$,1)
@textfeld(rp60&,b$,1)
@textfeld(rm60&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*8))+"-",3)+CHR$(0)
@textfeld(lp80&,b$,1)
@textfeld(lm80&,b$,1)
@textfeld(rp80&,b$,1)
@textfeld(rm80&,b$,1)
byzoom=yzoom
RETURN
'
> PROCEDURE curve(cs,ce)
.| Glob. Var.: zoomstop#,grids#,maxcol#,xd#,ym1#,xm#,ym#,ym2#,mbs#,col#,ax#
.|     bx#,yline#,virtcurve#,virtual#,maxcwert#,mlen#,vce#,vcs#,cached#,wa#
.|     vmem#,wb#,stp#,j#,m1#,m2#,m3#,m4#,cwertep1#,cwertep2#,cwertem1#
.|     cwertem2#,max#,max2#,ldlen#,mrkp$,virtpath$,meml#,yd#,sline#,bs#,ci#
.|     am#,y2#,yzoom#,aa#,wyzoom#,rubmax#,aam#
.| Felder    : mblocks#(),mblocke#(),cachep1#(),cachep2#(),cachem1#()
.|     cachem2#()
.| Ruft auf  : markhlp,maschinit31,maschruf31,writeyproz,drawcurve,markhlp3
.| Aufruf in : message-2,restaura4-1,smpload-2,smpedit-1,time_edit-1
.|     record2-1,
LOCAL c$,s,e,l,y,len,adr,i,a,z,m,k,d,xdi,ydi
zoomstop=FALSE
GRAPHMODE 1
@markhlp
'
' COLORS: 0=weiss,1=schwarz,2=rot,3=grÅn,4=blau,5=cyan,6=gelb,7=magenta,8=hellgrau
'         9=dunkelgrau,10=dunkelrot,11=dunkelgrÅn,12=dunkelblau,13=dunkelcyan,14=dunkelgelb,15=dunkelmagenta
'
IF grids=1 THEN
IF maxcol<=2 THEN
DEFFILL 0,1,8
ELSE
DEFFILL 8,1,8
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX xd+1,ym1,xd+xm,ym1+ym
PBOX xd+1,ym2,xd+xm,ym2+ym
IF mbs>0 THEN
col=1
FOR i=1 TO mbs
INC col
ax=mblocks(i)
bx=mblocke(i)
IF (ce-cs)>0 AND (bx-ax)>0 THEN
IF ax<cs AND bx>cs THEN
ax=cs
ENDIF
IF bx>ce AND ax>=cs AND ax<=ce THEN
bx=ce
ENDIF
IF ax>=cs AND ax<=ce AND bx>=cs AND bx<=ce AND (ce-cs)>0 AND (bx-ax)>0 THEN
ax=ax-cs
ax=ax/(ce-cs)*xm
bx=bx-cs
bx=bx/(ce-cs)*xm
IF maxcol<=2 THEN
DEFFILL 1,3,col
IF col=13 THEN
col=1
ENDIF
ELSE
IF col=8 THEN
col=10
ENDIF
IF col=16 THEN
col=2
ENDIF
DEFFILL col,1,8
ENDIF
PBOX xd+ax+1,ym1,xd+bx,ym1+ym
PBOX xd+ax+1,ym2,xd+bx,ym2+ym
ENDIF
ENDIF
NEXT i
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
IF yline=TRUE THEN
~GRAF_MOUSE(256,0)                              ! Hidem
DEFLINE 2
GRAPHMODE 3
LINE xd+1,ym1+6,xd+xm+1,ym1+6
LINE xd+1,ym1+6+8,xd+xm+1,ym1+6+8
LINE xd+1,ym1+6+8*2,xd+xm+1,ym1+6+8*2
LINE xd+1,ym1+6+8*3,xd+xm+1,ym1+6+8*3
LINE xd+1,ym1+6+8*5,xd+xm+1,ym1+6+8*5
LINE xd+1,ym1+6+8*6,xd+xm+1,ym1+6+8*6
LINE xd+1,ym1+6+8*7,xd+xm+1,ym1+6+8*7
LINE xd+1,ym1+6+8*8,xd+xm+1,ym1+6+8*8
LINE xd+1,ym2+6,xd+xm+1,ym2+6
LINE xd+1,ym2+6+8,xd+xm+1,ym2+6+8
LINE xd+1,ym2+6+8*2,xd+xm+1,ym2+6+8*2
LINE xd+1,ym2+6+8*3,xd+xm+1,ym2+6+8*3
LINE xd+1,ym2+6+8*5,xd+xm+1,ym2+6+8*5
LINE xd+1,ym2+6+8*6,xd+xm+1,ym2+6+8*6
LINE xd+1,ym2+6+8*7,xd+xm+1,ym2+6+8*7
LINE xd+1,ym2+6+8*8,xd+xm+1,ym2+6+8*8
GRAPHMODE 1
DEFLINE 1
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
virtcurve=FALSE
IF virtual=TRUE AND maxcwert>0 THEN
IF ce-cs>mlen THEN
vce=0
vcs=0
virtcurve=TRUE
cached=TRUE
IF cs>0 THEN
wa=vmem/cs
wa=(maxcwert/wa)
ELSE
wa=0
ENDIF
IF ce>0 THEN
wb=vmem/ce
wb=(maxcwert/wb)
ELSE
wb=0
ENDIF
wa=INT(wa)
wb=INT(wb)
stp=(wb-wa)/xm
j=0
m1=0
m2=0
m3=0
m4=0
i=wa+1
REPEAT
INC j
IF j<=xm THEN
a=LPEEK(cwertep1+INT(i)*4)
IF m1<a AND a>0 THEN
m1=a
ENDIF
IF m2>a AND a<0 THEN
m2=a
ENDIF
cachep1(j)=a
a=LPEEK(cwertep2+INT(i)*4)
IF m3<a AND a>0 THEN
m3=a
ENDIF
IF m4>a AND a<0 THEN
m4=a
ENDIF
cachep2(j)=a
a=LPEEK(cwertem1+INT(i)*4)
IF m2<a AND a>0 THEN
m2=a
ENDIF
cachem1(j)=a
a=LPEEK(cwertem2+INT(i)*4)
IF m4<a AND a>0 THEN
m4=a
ENDIF
cachem2(j)=a
ENDIF
i=i+stp
UNTIL i>=wb
m2=ABS(m2)
IF m1>m2 THEN
max=m1
ELSE
max=m2
ENDIF
m4=ABS(m4)
IF m3>m4 THEN
max2=m3
ELSE
max2=m4
ENDIF
IF max2>max THEN
max=max2
ENDIF
ELSE
IF cs<vcs OR ce>vce OR vce=0 THEN
IF cs<vcs THEN
IF mlen>ce-cs AND ce-mlen>=0 THEN
ldlen=mlen
ELSE
ldlen=ce-cs
ENDIF
virtcurve=FALSE
cached=FALSE
vce=ce
vcs=ce-ldlen
IF vcs=0 THEN
ldlen=mlen
vce=mlen
ENDIF
OPEN "I",#1,mrkp$
SEEK #1,vcs
ELSE
IF mlen>ce-cs AND vmem-cs>=mlen THEN
ldlen=mlen
ELSE
ldlen=ce-cs
ENDIF
IF cs+ldlen>vmem THEN
ldlen=vmem-cs
ENDIF
virtcurve=FALSE
cached=FALSE
vcs=cs
vce=cs+ldlen
OPEN "I",#1,virtpath$
SEEK #1,cs
ENDIF
BGET #1,meml,ldlen
CLOSE #1
ENDIF
ENDIF
ENDIF
'  IF mrkhandle=mrkhandle2 THEN
'  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
'  IF v<>0 AND kenn=mrkhandle2 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
@maschinit31
xdi=xd+1   ! X-Locator fÅr Mittellinien
ydi=yd+65  ! Mittellinie erste Box
sline=88   ! Abstand zur zweiten Mittellinie
len=ce-cs
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~WIND_UPDATE(3)                                    ! BEG_UPDATE
LINE xdi,ydi,xdi+xm,ydi
LINE xdi,ydi+sline,xdi+xm,ydi+sline
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~WIND_UPDATE(2)                                    ! BEG_UPDATE
stp=(INT(len/xm))
stp=(INT((stp+1)/4)*4)
COLOR 0
l=xdi-2
y=ydi
IF virtcurve=FALSE THEN
bs=1
IF stp=0 THEN
stp=4
IF len>xm*4 THEN
bs=len/xm/4
ELSE
bs=xm*4/len
ENDIF
ELSE
IF (len/stp)<xm THEN
bs=xm/(len/stp)
ENDIF
ENDIF
adr=meml
ELSE
bs=1
adr=0
ENDIF
COLOR 1
IF cached=FALSE THEN
ci=0
m1=0
m2=0
FOR i=adr+cs TO adr+ce-stp STEP stp
@maschruf31
IF a>32767 THEN
a=a-65536
ENDIF
IF m1<a AND a>0 THEN
m1=a
ENDIF
IF m2>a AND a<0 THEN
m2=a
ENDIF
IF m2<am AND am>0 THEN
m2=am
ENDIF
INC ci
IF l<=(xm+xdi) THEN
cachep1(ci)=a
ENDIF
IF l<=(xm+xdi) THEN
cachem1(ci)=am
ENDIF
l=l+bs
NEXT i
m2=ABS(m2)
IF m1>m2 THEN
max=m1
ELSE
max=m2
ENDIF
ci=0
m1=0
m2=0
l=xdi-2
FOR i=adr+cs+2 TO adr+ce-stp STEP stp
@maschruf31
IF a>32767 THEN
a=a-65536
ENDIF
IF m1<a AND a>0 THEN
m1=a
ENDIF
IF m2>a AND a<0 THEN
m2=a
ENDIF
IF m2<am AND am>0 THEN
m2=am
ENDIF
INC ci
IF l<=(xm+xdi) THEN
cachep2(ci)=a
ENDIF
IF l<=(xm+xdi) THEN
cachem2(ci)=am
ENDIF
l=l+bs
NEXT i
m2=ABS(m2)
IF m1>m2 THEN
max2=m1
ELSE
max2=m2
ENDIF
IF max2>max THEN
max=max2
ENDIF
ci=0
l=xdi-2
y2=y
@writeyproz
FOR i=adr+cs TO adr+ce-stp STEP stp
INC ci
IF l<=(xm+xdi) THEN
a=cachep1(ci)
IF max>0 THEN
IF yzoom=TRUE THEN
aa=INT(a/max*ym/2)
ELSE
aa=INT(a/32767*ym/2)
ENDIF
IF wyzoom=TRUE THEN
aa=INT(a/rubmax*ym/2)
IF aa>ym/2 THEN
aa=ym/2
ENDIF
ENDIF
ELSE
aa=0
ENDIF
a=ydi-aa
am=cachem1(ci)
IF max>0 THEN
IF yzoom=TRUE THEN
aam=INT(am/max*ym/2)
ELSE
aam=INT(am/32767*ym/2)
ENDIF
IF wyzoom=TRUE THEN
aam=INT(am/rubmax*ym/2)
IF aam>ym/2 THEN
aam=ym/2
ENDIF
ENDIF
ELSE
aam=0
ENDIF
am=aam+ydi
IF INT((ce-cs)/4)<=xm THEN
@drawcurve
ELSE
LINE l,a,l,am
ENDIF
ENDIF
l=l+bs
NEXT i
y=ydi+sline
ci=0
l=xdi-2
ydi=ydi+sline
y2=y
FOR i=adr+cs+2 TO adr+ce-stp STEP stp
INC ci
IF l<=(xm+xdi) THEN
a=cachep2(ci)
IF max>0 THEN
IF yzoom=TRUE THEN
aa=INT(a/max*ym/2)
ELSE
aa=INT(a/32767*ym/2)
ENDIF
IF wyzoom=TRUE THEN
aa=INT(a/rubmax*ym/2)
IF aa>ym/2 THEN
aa=ym/2
ENDIF
ENDIF
ELSE
aa=0
ENDIF
a=ydi-aa
am=cachem2(ci)
IF max>0 THEN
IF yzoom=TRUE THEN
aam=INT(am/max*ym/2)
ELSE
aam=INT(am/32767*ym/2)
ENDIF
IF wyzoom=TRUE THEN
aam=INT(am/rubmax*ym/2)
IF aam>ym/2 THEN
aam=ym/2
ENDIF
ENDIF
ELSE
aam=0
ENDIF
am=aam+ydi
IF INT((ce-cs)/4)<=xm THEN
@drawcurve
ELSE
LINE l,a,l,am
ENDIF
ENDIF
l=l+bs
NEXT i
@markhlp3(9998,cs)
@markhlp3(9999,ce)
cached=TRUE
ELSE
'        IF yzoom<>byzoom THEN
@writeyproz
'      ENDIF
l=xdi-2
ci=0
y2=y
FOR i=adr+cs TO adr+ce-stp STEP stp
INC ci
IF l<=(xm+xdi) THEN
a=cachep1(ci)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aa=INT(a/max*ym/2)
ELSE
aa=INT(a/32767*ym/2)
ENDIF
IF wyzoom=TRUE THEN
aa=INT(a/rubmax*ym/2)
IF aa>ym/2 THEN
aa=ym/2
ENDIF
ENDIF
ELSE
aa=0
ENDIF
a=ydi-aa
am=cachem1(ci)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aam=INT(am/max*ym/2)
ELSE
aam=INT(am/32767*ym/2)
ENDIF
IF wyzoom=TRUE THEN
aam=INT(am/rubmax*ym/2)
IF aam>ym/2 THEN
aam=ym/2
ENDIF
ENDIF
ELSE
aam=0
ENDIF
am=aam+ydi
IF INT((ce-cs)/4)<=xm THEN
@drawcurve
ELSE
LINE l,a,l,am
ENDIF
ENDIF
l=l+bs
NEXT i
ydi=ydi+sline
l=xdi-2
y=ydi
ci=0
y2=y
FOR i=adr+cs+2 TO adr+ce-stp STEP stp
INC ci
IF l<=(xm+xdi) THEN
a=cachep2(ci)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aa=INT(a/max*ym/2)
ELSE
aa=INT(a/32767*ym/2)
ENDIF
IF wyzoom=TRUE THEN
aa=INT(a/rubmax*ym/2)
IF aa>ym/2 THEN
aa=ym/2
ENDIF
ENDIF
ELSE
aa=0
ENDIF
a=ydi-aa
am=cachem2(ci)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aam=INT(am/max*ym/2)
ELSE
aam=INT(am/32767*ym/2)
ENDIF
IF wyzoom=TRUE THEN
aam=INT(am/rubmax*ym/2)
IF aam>ym/2 THEN
aam=ym/2
ENDIF
ENDIF
ELSE
aam=0
ENDIF
am=aam+ydi
IF INT((ce-cs)/4)<=xm THEN
@drawcurve
ELSE
LINE l,a,l,am
ENDIF
ENDIF
l=l+bs
NEXT i
@markhlp3(9998,cs)
@markhlp3(9999,ce)
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
' ENDIF
'  ENDIF
RETURN
'
> PROCEDURE adjustresmp
.| Glob. Var.: adjrsmp#,adjresmp#
.| Aufruf in : resample-1,
IF adjrsmp=FALSE THEN
adjresmp=TRUE
ELSE
adjresmp=FALSE
ENDIF
RETURN
'
> PROCEDURE resmptxt
.| Glob. Var.: sblock#,len#,mlen#,resorig#,resoth#,c2#,c1#,a$,resmplen&,hz#
.|     resmpsec&,resmpfac&
.| Ruft auf  : textfeld
.| Aufruf in : resample-6,
IF sblock=0 THEN
len=INT(mlen/resorig*resoth/4)
ELSE
len=INT((c2-c1)/resorig*resoth/4)
ENDIF
a$=STR$(len)+" samples"+CHR$(0)
@textfeld(resmplen&,a$,1)
len=INT(len/hz*1000)/1000
hsec=INT(len*100)
@htimeset
a$="TIME "+a$
'  a$=STR$(len)+" sec"+CHR$(0)
@textfeld(resmpsec&,a$,1)
len=((resoth/resorig)*100)
len=INT(len+1.0E-07)/100
a$="Factor "+STR$(len)+CHR$(0)
@textfeld(resmpfac&,a$,1)
RETURN
'
> PROCEDURE resample
.| Glob. Var.: makecurve#,vorvornr#,vornr#,nr#,resample&,resorig#,hz#,db$
.|     restxt&,resoth#,resother&,sblock#,c2#,c1#,sms#,sme#,adjresmp#
.|     adjresmp&,obj#,popup&,zu%,zuadr#,edit_obj&,resl1&,resl2&,resl3&
.|     resr1&,resr2&,resr3&,res32&,res44&,res48&,helprsmp&,resok&,resexit&
.|     noresok#,a$,i#,a#,g#,resmp&
.| Ruft auf  : makehz,rsc_draw,markhlp,editfeld,textfeld,blocklook,resmptxt
.|     setbutton,rsc_do,xrsrc_gaddr,resl,resr,adjustresmp,resoth32,resoth44
.|     resoth48,helptxt,editread,makeresmp,rsc_back,blkrestaura
.| Aufruf in : do_blkf-1,
makecurve=0
vorvornr=vornr
vornr=nr
nr=resample&
@makehz
@rsc_draw(nr,0)
@markhlp
resorig=hz/1000
db$=STR$(resorig)+CHR$(0)
@editfeld(restxt&,db$)
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
IF adjresmp=TRUE THEN
@setbutton(adjresmp&,1)
ELSE
@setbutton(adjresmp&,0)
ENDIF
@blocklook
IF sblock=0 OR (sblock=1 AND c2>c1 AND sms<>0 AND sme<>0 AND c2>0) THEN
@resmptxt
IF adjresmp=TRUE THEN
@setbutton(adjresmp&,1)
ELSE
@setbutton(adjresmp&,0)
ENDIF
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>restxt&
edit_obj&=0
IF obj=resl1& OR obj=resl2& OR obj=resl3& OR obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@setbutton(obj,0)
ENDIF
IF obj=resl1& OR obj=resl2& OR obj=resl3& THEN
@resl
@resmptxt
ENDIF
IF obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@resr
@resmptxt
ENDIF
IF obj=adjresmp& THEN
@adjustresmp
ENDIF
IF obj=res32& THEN
@resoth32
@resmptxt
ENDIF
IF obj=res44& THEN
@resoth44
@resmptxt
ENDIF
IF obj=res48& THEN
@resoth48
@resmptxt
ENDIF
IF obj=helprsmp& THEN
@helptxt("RESAMPLING")
ENDIF
UNTIL obj=resok& OR obj=resexit&
IF obj=resok& THEN
@editread(restxt&)
noresok=FALSE
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF (a<48 OR a>57) AND a<>46 THEN
noresok=TRUE
ENDIF
IF (i=1 OR i=4) AND a=46 THEN
noresok=TRUE
ENDIF
NEXT i
ELSE
noresok=TRUE
ENDIF
ENDIF
@setbutton(obj,0)
UNTIL (obj=resok& AND noresok=FALSE) OR obj=resexit&
IF obj=resok& AND noresok=FALSE THEN
resorig=VAL(a$)
@makeresmp
ENDIF
ELSE
ALERT 3,"Fehlerhafte Blockmarkierung !",1,"EXIT",g
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@rsc_back(nr)
nr=vornr
@blkrestaura
@setbutton(resmp&,0)
vornr=vorvornr
obj=0
RETURN
'
> PROCEDURE arrnrset
.| Glob. Var.: mrkch#,ch#,mrknote#,note#,arrnr1&,pbz#,arrnr2&,arrnr3&
.|     arrnr4&,arrherr#,arrm1&,arrm2&,arrm3&,arrm4&,realtime#,vhz#,flen#
.|     arrloop1&,arrch1&,arrnote1&,arrtri1&,arrsmpr1&,arrloop2&,arrch2&
.|     arrnote2&,arrtri2&,arrsmpr2&,arrloop3&,arrch3&,arrnote3&,arrtri3&
.|     arrsmpr3&,arrloop4&,arrch4&,arrnote4&,arrtri4&,arrsmpr4&,hsec#,a1$,a$
.|     a3$,a2$,sectpos#,pat$,midiwort#,ch$,m$,tri#,l#,a4#,a4$,hardst1&
.|     harde1&,spur1&,hardlen1&,db$,nr#,arrmem1&,hardst2&,harde2&,spur2&
.|     hardlen2&,arrmem2&,hardst3&,harde3&,spur3&,hardlen3&,arrmem3&
.|     hardst4&,harde4&,spur4&,hardlen4&,arrmem4&
.| Felder    : arrsrate#(),arrpath$(),arrend#(),arrstrt#(),arrtri#()
.|     arrlen#(),arrfn$(),arrmidi#(),arrloop#()
.| Ruft auf  : textfeld,setbutton,htimeset,midinote,rsc_tristate2
.| Aufruf in : button-2,arranger-1,do_arrange-2,arrsmpr-1,realtime-2
.|     dragging2-1,arrtristate-1,arrdel-1,arrinsert-1,arrdelete-1
.|     arrdelay-1,hardstrt-1,hardend-1,hardfs-1,arrload-1,
'
' akkuberechnung muû geÑndert werden wegen unterschiedlichen Sampleraten !!!
'
LOCAL p$,i,akku,z,ap$
mrkch=ch
mrknote=note
@textfeld(arrnr1&,RIGHT$("  "+STR$(pbz*4+1),3)+CHR$(0),1)
@textfeld(arrnr2&,RIGHT$("  "+STR$(pbz*4+2),3)+CHR$(0),1)
@textfeld(arrnr3&,RIGHT$("  "+STR$(pbz*4+3),3)+CHR$(0),1)
@textfeld(arrnr4&,RIGHT$("  "+STR$(pbz*4+4),3)+CHR$(0),1)
IF arrherr=pbz*4+1 THEN
@setbutton(arrm1&,1)
ELSE
@setbutton(arrm1&,0)
ENDIF
IF arrherr=pbz*4+2 THEN
@setbutton(arrm2&,1)
ELSE
@setbutton(arrm2&,0)
ENDIF
IF arrherr=pbz*4+3 THEN
@setbutton(arrm3&,1)
ELSE
@setbutton(arrm3&,0)
ENDIF
IF arrherr=pbz*4+4 THEN
@setbutton(arrm4&,1)
ELSE
@setbutton(arrm4&,0)
ENDIF
akku=0
IF realtime=TRUE THEN
IF pbz>0 THEN
FOR i=1 TO pbz*4
vhz=arrsrate(i)
IF arrpath$(i)="DELAY" THEN
akku=akku+arrend(i)*vhz*4/100
ENDIF
IF arrpath$(i)="MEMORY" THEN
IF arrend(i)-arrstrt(i)>=0 THEN
akku=akku+(arrend(i)-arrstrt(i))
IF arrtri(i)=2 AND arrpath$(i)="MEMORY" THEN
akku=akku+(arrend(i)-arrstrt(i))
ENDIF
ENDIF
ENDIF
IF arrpath$(i)<>"" AND arrpath$(i)<>"MEMORY" AND arrpath$(i)<>"DELAY" THEN
IF arrend(i)-arrstrt(i)>=0 THEN
akku=akku+(arrend(i)-arrstrt(i))*flen
IF arrtri(i)=2 THEN
akku=akku+(arrend(i)-arrstrt(i))*flen
ENDIF
ENDIF
ENDIF
NEXT i
ENDIF
ENDIF
FOR z=1 TO 4
ap$=arrpath$(pbz*4+z)
IF ap$="MEMORY" OR ap$="DELAY" THEN
IF ap$="DELAY" THEN
IF z=1 THEN
@setbutton(arrloop1&,8)
@setbutton(arrch1&,8)
@setbutton(arrnote1&,8)
@setbutton(arrtri1&,8)
@textfeld(arrch1&,SPACE$(2)+CHR$(0),1)
@textfeld(arrnote1&,SPACE$(4)+CHR$(0),1)
@textfeld(arrsmpr1&,SPACE$(4)+CHR$(0),1)
@setbutton(arrsmpr1&,8)
ENDIF
IF z=2 THEN
@setbutton(arrloop2&,8)
@setbutton(arrch2&,8)
@setbutton(arrnote2&,8)
@setbutton(arrtri2&,8)
@textfeld(arrch2&,SPACE$(2)+CHR$(0),1)
@textfeld(arrnote2&,SPACE$(4)+CHR$(0),1)
@textfeld(arrsmpr2&,SPACE$(4)+CHR$(0),1)
@setbutton(arrsmpr2&,8)
ENDIF
IF z=3 THEN
@setbutton(arrloop3&,8)
@setbutton(arrch3&,8)
@setbutton(arrnote3&,8)
@setbutton(arrtri3&,8)
@textfeld(arrch3&,SPACE$(2)+CHR$(0),1)
@textfeld(arrnote3&,SPACE$(4)+CHR$(0),1)
@textfeld(arrsmpr3&,SPACE$(4)+CHR$(0),1)
@setbutton(arrsmpr3&,8)
ENDIF
IF z=4 THEN
@setbutton(arrloop4&,8)
@setbutton(arrch4&,8)
@setbutton(arrnote4&,8)
@setbutton(arrtri4&,8)
@textfeld(arrch4&,SPACE$(2)+CHR$(0),1)
@textfeld(arrnote4&,SPACE$(4)+CHR$(0),1)
@textfeld(arrsmpr4&,SPACE$(4)+CHR$(0),1)
@setbutton(arrsmpr4&,8)
ENDIF
IF realtime=FALSE THEN
hsec=arrstrt(pbz*4+z)
ELSE
vhz=arrsrate(pbz*4+z)
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
a1$=a$
hsec=arrend(pbz*4+z)
@htimeset
a3$=a$
IF realtime=FALSE THEN
a2$=a3$
ELSE
sectpos=INT(arrend(pbz*4+z)*vhz*4/100)+akku
hsec=INT(sectpos/vhz/4*100)
@htimeset
a2$=a$
akku=sectpos
ENDIF
ENDIF
IF ap$="MEMORY" THEN
sectpos=arrstrt(pbz*4+z)
IF realtime=TRUE THEN
sectpos=akku
ENDIF
vhz=arrsrate(pbz*4+z)
IF vhz=0 THEN
vhz=44100
ENDIF
hsec=INT(sectpos/vhz/4*100)
@htimeset
a1$=a$
sectpos=arrend(pbz*4+z)
IF realtime=TRUE THEN
IF arrend(pbz*4+z)-arrstrt(pbz*4+z)>=0 THEN
IF arrtri(pbz*4+z)=2 THEN
sectpos=(arrend(pbz*4+z)-arrstrt(pbz*4+z))*2+akku
ELSE
sectpos=(arrend(pbz*4+z)-arrstrt(pbz*4+z))+akku
ENDIF
ELSE
sectpos=akku
ENDIF
ENDIF
hsec=INT(sectpos/vhz/4*100)
@htimeset
a2$=a$
sectpos=arrlen(pbz*4+z)
hsec=INT(sectpos/vhz/4*100)
@htimeset
a3$=a$
IF arrend(pbz*4+z)-arrstrt(pbz*4+z)>=0 THEN
IF arrtri(pbz*4+z)=2 THEN
akku=akku+(arrend(pbz*4+z)-arrstrt(pbz*4+z))*2
ELSE
akku=akku+(arrend(pbz*4+z)-arrstrt(pbz*4+z))
ENDIF
ENDIF
ENDIF
ELSE
sectpos=arrstrt(pbz*4+z)
vhz=arrsrate(pbz*4+z)
IF vhz=0 THEN
vhz=44100
ENDIF
IF realtime=FALSE THEN
hsec=INT(sectpos*flen/vhz/4*100)
ELSE
sectpos=akku
hsec=INT(sectpos/vhz/4*100)
ENDIF
@htimeset
a1$=a$
sectpos=arrend(pbz*4+z)
IF realtime=FALSE THEN
hsec=INT(sectpos*flen/vhz/4*100)
ELSE
IF arrend(pbz*4+z)-arrstrt(pbz*4+z)>=0 THEN
IF arrtri(pbz*4+z)=2 THEN
sectpos=(sectpos-arrstrt(pbz*4+z))*2*flen+akku
ELSE
sectpos=(sectpos-arrstrt(pbz*4+z))*flen+akku
ENDIF
ELSE
sectpos=akku
ENDIF
hsec=INT(sectpos/vhz/4*100)
ENDIF
@htimeset
a2$=a$
sectpos=arrlen(pbz*4+z)
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
a3$=a$
IF arrend(pbz*4+z)-arrstrt(pbz*4+z)>=0 THEN
IF arrtri(pbz*4+z)=2 THEN
akku=akku+(arrend(pbz*4+z)-arrstrt(pbz*4+z))*2*flen
ELSE
akku=akku+(arrend(pbz*4+z)-arrstrt(pbz*4+z))*flen
ENDIF
ENDIF
ENDIF
pat$=LEFT$(arrfn$(pbz*4+z)+SPACE$(12),12)
midiwort=arrmidi(pbz*4+z)
note=(midiwort AND 255)
ch=INT(midiwort/256)+1
ch$=RIGHT$(" "+STR$(ch),2)+CHR$(0)
@midinote
p$=arrpath$(pbz*4+z)
IF pat$="            " THEN
m$=" "+CHR$(0)
ENDIF
IF p$="DELAY" THEN
m$="D"+CHR$(0)
ENDIF
IF p$="MEMORY" THEN
m$="M"+CHR$(0)
ENDIF
IF p$<>"MEMORY" AND p$<>"DELAY" AND pat$<>"            " THEN
m$="H"+CHR$(0)
ENDIF
tri=arrtri(pbz*4+z)
l=arrloop(pbz*4+z)
a4=INT(arrsrate(pbz*4+z)/100)/10
IF a4>0 THEN
a4$=LEFT$(STR$(a4)+SPACE$(4),4)+CHR$(0)
ELSE
a4$=SPACE$(4)+CHR$(0)
ENDIF
IF z=1 THEN
@textfeld(hardst1&,a1$,1)
@textfeld(harde1&,a2$,1)
@textfeld(spur1&,pat$,1)
@textfeld(hardlen1&,a3$,1)
IF p$<>"DELAY" THEN
@textfeld(arrch1&,ch$,1)
@textfeld(arrnote1&,db$,1)
@setbutton(arrch1&,0)
@setbutton(arrnote1&,0)
@setbutton(arrloop1&,l)
@setbutton(arrtri1&,0)
@setbutton(arrsmpr1&,0)
@textfeld(arrsmpr1&,a4$,1)
@rsc_tristate2(nr,arrtri1&)
ENDIF
@textfeld(arrmem1&,m$,1)
ENDIF
IF z=2 THEN
@textfeld(hardst2&,a1$,1)
@textfeld(harde2&,a2$,1)
@textfeld(spur2&,pat$,1)
@textfeld(hardlen2&,a3$,1)
IF p$<>"DELAY" THEN
@textfeld(arrch2&,ch$,1)
@textfeld(arrnote2&,db$,1)
@setbutton(arrch2&,0)
@setbutton(arrnote2&,0)
@setbutton(arrloop2&,l)
@setbutton(arrtri2&,0)
@setbutton(arrsmpr2&,0)
@textfeld(arrsmpr2&,a4$,1)
@rsc_tristate2(nr,arrtri2&)
ENDIF
@textfeld(arrmem2&,m$,1)
ENDIF
IF z=3 THEN
@textfeld(hardst3&,a1$,1)
@textfeld(harde3&,a2$,1)
@textfeld(spur3&,pat$,1)
@textfeld(hardlen3&,a3$,1)
IF p$<>"DELAY" THEN
@textfeld(arrch3&,ch$,1)
@textfeld(arrnote3&,db$,1)
@setbutton(arrch3&,0)
@setbutton(arrnote3&,0)
@setbutton(arrloop3&,l)
@setbutton(arrtri3&,0)
@setbutton(arrsmpr3&,0)
@textfeld(arrsmpr3&,a4$,1)
@rsc_tristate2(nr,arrtri3&)
ENDIF
@textfeld(arrmem3&,m$,1)
ENDIF
IF z=4 THEN
@textfeld(hardst4&,a1$,1)
@textfeld(harde4&,a2$,1)
@textfeld(spur4&,pat$,1)
@textfeld(hardlen4&,a3$,1)
IF p$<>"DELAY" THEN
@textfeld(arrch4&,ch$,1)
@textfeld(arrnote4&,db$,1)
@setbutton(arrch4&,0)
@setbutton(arrnote4&,0)
@setbutton(arrloop4&,l)
@setbutton(arrtri4&,0)
@setbutton(arrsmpr4&,0)
@textfeld(arrsmpr4&,a4$,1)
@rsc_tristate2(nr,arrtri4&)
ENDIF
@textfeld(arrmem4&,m$,1)
ENDIF
NEXT z
ch=mrkch
note=mrknote
RETURN
'
'
'
> PROCEDURE scrollinit
LOCAL a,steps,len
scstep=1
steps=4
scslc=1   ! Schrittweite
IF ((INT(vmem/4)*4)-INT((ce-cs)/4)*4)>0 THEN
scmax=(vmem-(ce-cs))/((ce-cs)/steps)
IF scmax>INT(scmax) THEN
scmax=scmax+1
scmax=INT(scmax)
IF scmax=1 THEN
scmax=2
ENDIF
scteil=(vmem-(ce-cs))/(scmax-1)
ENDIF
@slidelen2(scrlslde&,scrolbut&,tolen)
scstep=(tolen/scmax)
IF scstep<10 THEN
scstep=10
ENDIF
scmax=tolen+1
scteil=(vmem-(ce-cs))/(scmax-1-scstep)
ELSE
scmax=1
scteil=0
@slidelen2(scrlslde&,scrolbut&,scstep)
ENDIF
IF scmax=2 AND cs>0 AND (INT(ce/4)*4)<(INT(vmem/4)*4) THEN
scmax=3
scteil=(vmem-(ce-cs))/(scmax-1-scstep)
ENDIF
@slideinit2(scrlslde&,scrolbut&,scstep)
IF scteil>0 THEN
scrollp=INT(cs/scteil)
IF scrollp=0 AND cs>0 THEN
scrollp=1
ENDIF
ELSE
scrollp=0
ENDIF
RETURN
'
> PROCEDURE slideinit2(slidename&,slbutname&,step)    ! variable Buttonbreite
LOCAL b,h,scst
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h THEN
DPOKE (zu%+24*slbutname&+20),step   ! Breite des Schiebers anpassen
ELSE
DPOKE (zu%+24*slbutname&+22),step   ! Hîhe des Schiebers anpassen
ENDIF
pos=0                                       ! Position des Schiebers
RETURN
'
> PROCEDURE setslide2(slidename&,slbutname&,max,pos,step)
LOCAL b,h,poswert
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF max>1 THEN
poswert=1000/(max-1)*pos
ELSE
poswert=0
ENDIF
IF b>h THEN
sx=(poswert*b/1000)
IF sx+step>max THEN
sx=max-step
ENDIF
DPOKE zu%+24*slbutname&+16,sx              ! X-Position einstellen
ELSE
sy=(poswert*h/1000)
IF sy+step>max THEN
sy=max-step
ENDIF
DPOKE zu%+24*slbutname&+18,sy              ! Y-Position einstellen
ENDIF
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,slidename&,1,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE slideupdate2(slidename&,slbutname&,max,mx,my,slc,VAR pos,flg)
LOCAL b,h,pbb,pbla,pbl,a
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
a=FALSE
IF b>h THEN
pbb=DPEEK(zu%+24*slidename&+16)+ax&+12       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF mx>(pbb+pbla+pbl/2) THEN
@slidedwn2(slidename&,slbutname&,max,slc,slc,pos,a)
ENDIF
IF mx<(pbb+pbla-pbl/2) THEN
@slideup2(slidename&,slbutname&,max,slc,pos,a)
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+ay&-33    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF my>(pbb+pbla+pbl/2) THEN
@slidedwn2(slidename&,slbutname&,max,slc,slc,pos,a)
ENDIF
IF my<(pbb+pbla-pbl/2) THEN
@slideup2(slidename&,slbutname&,max,slc,pos,a)
ENDIF
ENDIF
flg=a
RETURN
'
> PROCEDURE slideup2(slidename&,slbutname&,max,slc,VAR pos,flg)
LOCAL p,a,sl
p=pos
sl=slc
IF p-sl<0 AND sl>1 THEN
sl=p
ENDIF
IF p-sl>=0 THEN
p=p-sl
@setslide2(slidename&,slbutname&,max,p,slc)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slidedwn2(slidename&,slbutname&,max,step,slc,VAR pos,flg)
LOCAL p,a,sl,st2
p=pos
sl=slc
IF p>=max-sl AND sl>1 THEN
sl=max-p-1
ENDIF
IF p<(max-step) THEN
p=p+sl
@setslide2(slidename&,slbutname&,max,p,slc)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE sliding2(slidename&,slbutname&,max,step,VAR pos,flg)
LOCAL b,h,slwert,p,a
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h THEN
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,0)
ELSE
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,1)
ENDIF
p=INT((max-step-1)/1000*slwert)
IF p<>pos THEN
@setslide2(slidename&,slbutname&,max,p,step)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slidelen2(slidename&,slbutname&,VAR len)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : virtual-1,scrollinit-1,
LOCAL b,h
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h THEN
len=b
ELSE
len=h
ENDIF
RETURN
'
'
'
> PROCEDURE slideinit(slidename&,slbutname&,max,bg,VAR pos)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : newfsel-1,arranger-1,trakker-2,virtual-1,scrollinit-1
.|     setup2-1,
LOCAL b,h,pbl
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h THEN
pbl=INT(b/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+20),pbl         ! Breite des Schiebers anpassen
ELSE
pbl=INT(h/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+22),pbl         ! Hîhe des Schiebers anpassen
ENDIF
pos=0                                       ! Position des Schiebers
RETURN
'
> PROCEDURE slidelen(slidename&,slbutname&,VAR len,leno)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : virtual-1,scrollinit-1,
LOCAL b,h
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h THEN
leno=b
len=b-DPEEK(zu%+24*slbutname&+20)   ! Breite des Schiebers in Pixeln
ELSE
leno=h
len=h-DPEEK(zu%+24*slbutname&+22)   ! Hîhe des Schiebers in Pixeln
ENDIF
RETURN
'
> PROCEDURE setslide(slidename&,slbutname&,max,bg,pos)
.| Glob. Var.: nr#,zu%,xwidth#,ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : button-4,rubbermax-1,newfsel-7,slideup-1,slidedwn-1
.|     sliding-1,arranger-1,trakker-2,virtual-1,getmem-2,zslidecalc-1
.|     smpedit-2,do_smpedit-6,time_edit-1,
LOCAL b,h,pbl,poswert
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF max>1 THEN
poswert=1000/(max-1)*pos
ELSE
poswert=0
ENDIF
IF b>h THEN
pbl=INT(b/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
SUB b,pbl
DPOKE zu%+24*slbutname&+16,poswert*b/1000              ! X-Position einstellen
ELSE
pbl=INT(h/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
SUB h,pbl
DPOKE zu%+24*slbutname&+18,poswert*h/1000              ! Y-Position einstellen
ENDIF
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,slidename&,1,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE slideup(slidename&,slbutname&,max,slc,bg,VAR pos,flg)
.| Ruft auf  : setslide
.| Aufruf in : newfsel-1,slideupdate-2,do_arrange-1,do_trakker-2,virtual-1
.|     do_smpedit-2,
LOCAL p,a,sl
p=pos
sl=slc
IF p-sl<0 AND sl>1 THEN
sl=p
ENDIF
IF p-sl>=0 THEN
p=p-sl
@setslide(slidename&,slbutname&,max,bg,p)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slidedwn(slidename&,slbutname&,max,slc,bg,VAR pos,flg)
.| Ruft auf  : setslide
.| Aufruf in : newfsel-1,slideupdate-2,do_arrange-1,do_trakker-2,virtual-1
.|     do_smpedit-2,
LOCAL p,a,sl
p=pos
sl=slc
IF p>=max-sl AND sl>1 THEN
sl=max-p-1
ENDIF
IF p<(max-sl) THEN
p=p+sl
@setslide(slidename&,slbutname&,max,bg,p)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slideupdate(slidename&,slbutname&,max,mx,my,slc,bg,VAR pos,flg)
.| Glob. Var.: nr#,zu%,ax&,ay&
.| Ruft auf  : markhlp,xrsrc_gaddr,slidedwn,slideup
.| Aufruf in : button-7,
LOCAL b,h,pbb,pbla,pbl,a
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
a=FALSE
IF b>h THEN
pbb=DPEEK(zu%+24*slidename&+16)+ax&+12       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF mx>(pbb+pbla+pbl/2) THEN
@slidedwn(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
IF mx<(pbb+pbla-pbl/2) THEN
@slideup(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+ay&-33    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF my>(pbb+pbla+pbl/2) THEN
@slidedwn(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
IF my<(pbb+pbla-pbl/2) THEN
@slideup(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
ENDIF
flg=a
RETURN
'
> PROCEDURE slidelr(slidename&,slbutname&,max,mx,my,pos,VAR slidr)
.| Glob. Var.: nr#,zu%,ax&,ay&
.| Ruft auf  : markhlp,xrsrc_gaddr
.| Aufruf in : button-1,
LOCAL b,h,pbb,pbla,pbl
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h THEN
pbb=DPEEK(zu%+24*slidename&+16)+ax&+24       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF pos<(max-1) AND mx>(pbb+pbla+pbl/2) THEN
slidr=TRUE
ENDIF
IF pos>0 AND mx<(pbb+pbla-pbl/2) THEN
slidr=FALSE
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+ay&-33    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF pos<(max-1) AND my>(pbb+pbla+pbl/2) THEN
slidr=TRUE
ENDIF
IF pos>0 AND my<(pbb+pbla-pbl/2) THEN
slidr=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE sliding(slidename&,slbutname&,max,bg,VAR pos,flg)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr,setslide
.| Aufruf in : button-7,
LOCAL b,h,slwert,p,a
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h THEN
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,0)
ELSE
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,1)
ENDIF
p=INT((max-1)/1000*slwert)
IF p<>pos THEN
@setslide(slidename&,slbutname&,max,bg,p)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE arranger
.| Glob. Var.: obj#,winh#,arranger&,rsc_window&,vornr#,nr#,vormidiwort#
.|     midiwort#,vorch#,ch#,vornote#,note#,hz#,arrz#,merkclip#,spring#,drag#
.|     arrherr#,hardopen#,playstop#,slmax#,lmax2#,arrslide&,arrslbut&,pbz#
.|     menuda#,realtime#,arreal&,a$,playlen&,tri#,l#,arrloop1&,arrtri1&
.|     arrloop2&,arrtri2&,arrloop3&,arrtri3&,arrloop4&,arrtri4&,playname&
.|     arrange&,g#,smpedit&,edit_obj&,idx&
.| Felder    : arrtri#(),arrloop#()
.| Ruft auf  : makehz,slideinit,rsc_draw,rsc_menu_ienable,setbutton,textfeld
.|     rsc_tristate2,setslide,arrnrset,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
LOCAL vy
obj=0
IF BTST(winh,arranger&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=arranger&
winh=BSET(winh,nr)
vormidiwort=midiwort
vorch=ch
vornote=note
merkhz=hz
@makehz
arrz=0
merkclip=0
spring=FALSE
drag=FALSE
arrherr=0
hardopen=FALSE
playstop=0
slmax=lmax2/4
@slideinit(arrslide&,arrslbut&,slmax,5,pbz)
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
IF realtime=FALSE THEN
@setbutton(arreal&,0)
ELSE
@setbutton(arreal&,1)
ENDIF
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
tri=arrtri(1)
l=arrloop(1)
@setbutton(arrloop1&,l)
@rsc_tristate2(nr,arrtri1&)
tri=arrtri(2)
l=arrloop(2)
@setbutton(arrloop2&,l)
@rsc_tristate2(nr,arrtri2&)
tri=arrtri(3)
l=arrloop(3)
@setbutton(arrloop3&,l)
@rsc_tristate2(nr,arrtri3&)
tri=arrtri(4)
l=arrloop(4)
@setbutton(arrloop4&,l)
@rsc_tristate2(nr,arrtri4&)
@setslide(arrslide&,arrslbut&,slmax,5,pbz)
@arrnrset
@textfeld(playname&,"            "+CHR$(0),1)
ELSE
@setbutton(arrange&,0)
ALERT 1,"Alle Fenster belegt|Bitte ein Fenster schlieûen !",1,"EXIT",g
ENDIF
ELSE
vornr=nr
nr=arranger&
IF vornr=smpedit& THEN
@setbutton2(arrange&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE arrsethz
.| Glob. Var.: vhz#,pbz#,arrz#
.| Felder    : arrsrate#()
.| Ruft auf  : swtosrate,analog,digout
.| Aufruf in : mforw-1,mbackw-1,
vhz=arrsrate(pbz*4+arrz)
IF vhz=0 THEN
vhz=44100
ENDIF
@swtosrate(vhz)
@analog
@digout(TRUE)
RETURN
'
> PROCEDURE do_arrange
.| Glob. Var.: obj#,smpplay2&,over#,arrclip&,pause&,stop&,forward&,rewind&
.|     smprplay&,smpauto3&,hrdmrk#,hrd#,smpstrt3&,recplay&,hardmerg&
.|     arrload&,arrsave&,hardfs1&,hardfs2&,hardfs3&,hardfs4&,arrch1&,arrch2&
.|     arrch3&,arrch4&,arrnote1&,arrnote2&,arrnote3&,arrnote4&,arrsmpr1&
.|     arrsmpr2&,arrsmpr3&,arrsmpr4&,hardstrt&,hardend&,arrplay&,slideup&
.|     arrslide&,arrslbut&,slmax#,pbz#,slflg#,slidedwn&,arrmidi&,arrtri1&
.|     arrtri2&,arrtri3&,arrtri4&,arrdel1&,arrdel2&,arrdel3&,arrdel4&
.|     arrloop1&,arrloop2&,arrloop3&,arrloop4&,arrm1&,arrm2&,arrm3&,arrm4&
.|     arrstrt&,arrend&,arrhelp&,arreal&,arrins&,arrdel&,arrdelay&,arrexit&
.|     winh#,arranger&,vornr#,smpedit&,arrange&,hz#,merkhz#,midiwort#
.|     vormidiwort#,ch#,vorch#,note#,vornote#
.| Ruft auf  : mforw,setbutton,dragging2,mpause,mstop,mbackw,smpauto
.|     smpstart,recplay,make,arrload,arrsave,hardfs,arrmidi,arrsmpr,hardstrt
.|     hardend,arrplay,slideup,arrnrset,slidedwn,arrmidplay,arrtristate
.|     arrdel,arrloop,arrtowork,arrstrt,arrend,helptxt,realtime,arrinsert
.|     arrdelete,arrdelay,restaura2b,swtosrate
.| Aufruf in : windows-1,
IF obj=smpplay2& THEN
over=0
@mforw
@setbutton(smpplay2&,0)
ENDIF
IF obj=arrclip& THEN
@dragging2
ENDIF
IF obj=pause& THEN
@mpause
ENDIF
IF obj=stop& THEN
@mstop
ENDIF
IF obj=forward& THEN
IF XBIOS(500)=&H71273800 AND oldplay=FALSE THEN
over=8
ELSE
over=12
ENDIF
@mforw
@setbutton(forward&,0)
ENDIF
IF obj=rewind& THEN
IF XBIOS(500)=&H71273800 AND oldplay=FALSE THEN
over=-8
ELSE
over=-20
ENDIF
@mbackw
@setbutton(rewind&,0)
ENDIF
IF obj=smprplay& THEN
over=-8
@mbackw
@setbutton(smprplay&,0)
ENDIF
IF obj=smpauto3& THEN
hrdmrk=hrd
hrd=1
@smpauto
hrd=hrdmrk
ENDIF
IF obj=smpstrt3& THEN
hrdmrk=hrd
hrd=1
@smpstart
hrd=hrdmrk
ENDIF
IF obj=recplay& THEN
@recplay
ENDIF
IF obj=hardmerg& THEN
@make
ENDIF
IF obj=arrload& THEN
@arrload
ENDIF
IF obj=arrsave& THEN
@arrsave
ENDIF
IF obj=hardfs1& OR obj=hardfs2& OR obj=hardfs3& OR obj=hardfs4& THEN
@hardfs
ENDIF
IF obj=arrch1& OR obj=arrch2& OR obj=arrch3& OR obj=arrch4& OR obj=arrnote1& OR obj=arrnote2& OR obj=arrnote3& OR obj=arrnote4& THEN
amidibut=obj
@arrmidi
@setbutton(amidibut,0)
ENDIF
IF obj=arrsmpr1& OR obj=arrsmpr2& OR obj=arrsmpr3& OR obj=arrsmpr4& THEN
@arrsmpr
ENDIF
IF obj=hardstrt& THEN
@hardstrt
ENDIF
IF obj=hardend& THEN
@hardend
ENDIF
IF obj=arrplay& THEN
@arrplay
ENDIF
IF obj=slideup& THEN
@slideup(arrslide&,arrslbut&,slmax,1,5,pbz,slflg)
IF slflg=TRUE THEN
@arrnrset
ENDIF
@setbutton(slideup&,0)
ENDIF
IF obj=slidedwn& THEN
@slidedwn(arrslide&,arrslbut&,slmax,1,5,pbz,slflg)
IF slflg=TRUE THEN
@arrnrset
ENDIF
@setbutton(slidedwn&,0)
ENDIF
IF obj=arrmidi& THEN
@arrmidplay
ENDIF
IF obj=arrtri1& OR obj=arrtri2& OR obj=arrtri3& OR obj=arrtri4& THEN
@arrtristate
ENDIF
IF obj=arrdel1& OR obj=arrdel2& OR obj=arrdel3& OR obj=arrdel4& THEN
@arrdel
ENDIF
IF obj=arrloop1& OR obj=arrloop2& OR obj=arrloop3& OR obj=arrloop4& THEN
@arrloop
ENDIF
IF obj=arrm1& OR obj=arrm2& OR obj=arrm3& OR obj=arrm4& THEN
@arrtowork
ENDIF
IF obj=arrstrt& THEN
@arrstrt
ENDIF
IF obj=arrend& THEN
@arrend
ENDIF
IF obj=arrhelp& THEN
@helptxt("ARRANGER")
ENDIF
IF obj=arreal& THEN
@realtime
ENDIF
IF obj=arrins& THEN
@arrinsert
ENDIF
IF obj=arrdel& THEN
@arrdelete
ENDIF
IF obj=arrdelay& THEN
@arrdelay
ENDIF
IF obj=arrexit& OR obj=9999 THEN
@setbutton(arrexit&,0)
winh=BCLR(winh,arranger&)
vornr=smpedit&
@restaura2b
obj=0
@setbutton(arrange&,0)
GRAPHMODE 3
IF hz<>merkhz THEN
hz=merkhz
@swtosrate(hz)
ENDIF
midiwort=vormidiwort
ch=vorch
note=vornote
obj=0
ENDIF
obj=0
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE trakker
.| Glob. Var.: winh#,trakker&,rsc_window&,vornr#,nr#,hz#,arrz#,merkclip#
.|     spring#,drag#,arrherr#,hardopen#,playstop#,tmax#,lmax2#,tymax#
.|     trakslid&,trakxbut&,trakkz#,trkvslid&,trakybut&,trakkyz#,menuda#,a$
.|     tri#,l#,px#,zu%,traknam1&,a#,trak&,g#,smpedit&,edit_obj&,idx&
.| Felder    : arrtri#(),arrloop#()
.| Ruft auf  : makehz,slideinit,rsc_draw,rsc_menu_ienable,setslide,timeline
.|     setbutton,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
LOCAL vy
oldplay=TRUE
IF BTST(winh,trakker&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=trakker&
winh=BSET(winh,nr)
'
'
'
'  LET trakk1&=2 ! BOXTEXT in Baum TRAKKER
'  LET trakk8&=9 ! BOXTEXT in Baum TRAKKER
'  LET traknam1&=10 ! BOXTEXT in Baum TRAKKER
'
'  LET trakprt&=45 ! USERDEF in Baum TRAKKER
'  LET hlpedit3&=68 ! USERDEF in Baum TRAKKER
'  LET traklen&=80 ! TEXT in Baum TRAKKER
'  LET trakinfo&=84 ! BOXTEXT in Baum TRAKKER
'
'  DIM trkfn$(lmax3)
'  DIM trkpath$(lmax3)
'                                DIM trktime(lmax3)
'  DIM trkvor(lmax3)
'  DIM trknext(lmax3)
'  DIM trkstrt(lmax3)
'  DIM trkend(lmax3)
'  DIM trklen(lmax3)
'  DIM trkloop(lmax3)
'  DIM trktri(lmax3)
'  DIM trksrate(lmax3)
'  DIM trkch(lmax3)
'
merkhz=hz
@makehz
arrz=0
merkclip=0
spring=FALSE
drag=FALSE
arrherr=0
hardopen=FALSE
playstop=0
tmax=lmax2/4
tymax=12
@slideinit(trakslid&,trakxbut&,tmax,5,trakkz)
@slideinit(trkvslid&,trakybut&,tymax,5,trakkyz)
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
a$="XX:XX:XX XX"+CHR$(0)
tri=arrtri(1)
l=arrloop(1)
trakkz=0
@setslide(trakslid&,trakxbut&,tmax,5,trakkz)
trakkyz=6
@setslide(trkvslid&,trakybut&,tymax,5,trakkyz)
px=DPEEK(zu%+24*traknam1&+16)         ! X-Position des Objekts in Pixeln
'  py=DPEEK(zu%+24*traknam1&+18)         ! Y-Position des Objekts in Pixeln
'  DPOKE (zu%+24*traknam1&+16),px+32     ! X-Position des Objekts verÑndern
'  DPOKE (zu%+24*traknam1&+18),12        ! Y-Position des Objekts verÑndern
'  ~WIND_UPDATE(1)                                    ! BEG_UPDATE
'  ~OBJC_DRAW(zu%,trakbox2&,99,0,0,xwidth,ywidth)      ! neu zeichnen
'  ~WIND_UPDATE(0)                                    ! BEG_UPDATE
'  PAUSE 50
'
'  wx=DPEEK(zu%+24*traknam1&+20)         ! Breite des Objekts in Pixeln
'  wy=DPEEK(zu%+24*traknam1&+22)         ! Hîhe des Objekts in Pixeln
'  DPOKE (zu%+24*traknam1&+20),50        ! Breite des Objekts verÑndern
'  DPOKE (zu%+24*traknam1&+22),32        ! Hîhe des Objekts verÑndern
'  ~WIND_UPDATE(1)                                    ! BEG_UPDATE
'  ~OBJC_DRAW(zu%,trakbox2&,99,0,0,xwidth,ywidth)      ! neu zeichnen
'  ~WIND_UPDATE(0)                                    ! BEG_UPDATE
a=0
@timeline
ELSE
@setbutton(trak&,0)
ALERT 1,"Alle Fenster belegt|Bitte ein Fenster schlieûen !",1,"EXIT",g
ENDIF
ELSE
vornr=nr
nr=trakker&
IF vornr=smpedit& THEN
@setbutton2(trak&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_trakker
.| Glob. Var.: obj#,smpplay3&,over#,trakclip&,pause2&,stop2&,forward2&
.|     rewind2&,smprpla2&,trakstrt&,trakend&,trakload&,trakanf&,trakfull&
.|     trakhelp&,trakplay&,traknam1&,trakk1&,trakk2&,trakk3&,trakk4&,trakk5&
.|     trakk6&,trakk7&,trakk8&,smpauto4&,hrdmrk#,hrd#,smpstrt4&,recplay2&
.|     hrdmerg2&,traksave&,trakxl&,trakslid&,trakxbut&,tmax#,trakkz#,slflg#
.|     trakxr&,trkslido&,trkvslid&,trakybut&,tymax#,trakkyz#,trkslidu&
.|     traktri&,trakdel&,trakloop&,trakins&,arrdel&,trakexit&,winh#,trakker&
.|     vornr#,smpedit&,trak&,hz#,merkhz#
.| Ruft auf  : trakforw,setbutton,trkpause,trkstop,trkbackw,trkstrt,trkend
.|     trakload,trkanf,trkfull,helptxt,trkplay,trktowork,trakknr,slideup
.|     timeline,slidedwn,restaura2b,swtosrate
.| Aufruf in : windows-1,
IF obj=smpplay3& THEN
over=0
@trakforw
@setbutton(smpplay3&,0)
ENDIF
IF obj=trakclip& THEN
ENDIF
IF obj=pause2& THEN
@trkpause
ENDIF
IF obj=stop2& THEN
@trkstop
ENDIF
IF obj=forward2& THEN
over=12
@trakforw
@setbutton(forward2&,0)
ENDIF
IF obj=rewind2& THEN
over=-20
@trkbackw
@setbutton(rewind2&,0)
ENDIF
IF obj=smprpla2& THEN
over=-8
@trkbackw
@setbutton(smprpla2&,0)
ENDIF
IF obj=trakstrt& THEN
@trkstrt
ENDIF
IF obj=trakend& THEN
@trkend
ENDIF
IF obj=trksmpte& THEN
@trksmpte_edit
ENDIF
IF obj=trakload& THEN
@trakload
ENDIF
IF obj=trakanf& THEN
@trkanf
ENDIF
IF obj=trakfull& THEN
@trkfull
ENDIF
IF obj=trakhelp& THEN
@helptxt("TRAKKER")
ENDIF
IF obj=trakplay& THEN
@trkplay
ENDIF
IF obj>=traknam1& AND obj<traknam1&+8*7 THEN
@trktowork
a=BIOS(11,-1)   ! Shift ?
IF a=1 OR a=2 THEN
@trakdrag
ENDIF
ENDIF
IF obj=trakk1& OR obj=trakk2& OR obj=trakk3& OR obj=trakk4& OR obj=trakk5& OR obj=trakk6& OR obj=trakk7& OR obj=trakk8& THEN
@trakknr
ENDIF
IF obj=smpauto4& THEN
hrdmrk=hrd
hrd=1
'      @smpauto
hrd=hrdmrk
ENDIF
IF obj=smpstrt4& THEN
hrdmrk=hrd
hrd=1
'      @smpstart
hrd=hrdmrk
ENDIF
IF obj=recplay2& THEN
'      @recplay
ENDIF
IF obj=hrdmerg2& THEN
'      @make
ENDIF
IF obj=traksave& THEN
'     @arrsave
ENDIF
IF obj=trakxl& THEN
@slideup(trakslid&,trakxbut&,tmax,1,5,trakkz,slflg)
IF slflg=TRUE THEN
@timeline
ENDIF
@setbutton(trakxl&,0)
ENDIF
IF obj=trakxr& THEN
@slidedwn(trakslid&,trakxbut&,tmax,1,5,trakkz,slflg)
IF slflg=TRUE THEN
@timeline
ENDIF
@setbutton(trakxr&,0)
ENDIF
IF obj=trkslido& THEN
@slideup(trkvslid&,trakybut&,tymax,1,5,trakkyz,slflg)
IF slflg=TRUE THEN
@timeline
ENDIF
@setbutton(trkslido&,0)
ENDIF
IF obj=trkslidu& THEN
@slidedwn(trkvslid&,trakybut&,tymax,1,5,trakkyz,slflg)
IF slflg=TRUE THEN
@timeline
ENDIF
@setbutton(trkslidu&,0)
ENDIF
IF obj=traktri& THEN
'      @arrtristate
ENDIF
IF obj=trakdel& THEN
@trakdel
ENDIF
IF obj=trakloop& THEN
'      @arrloop
ENDIF
IF obj=trakins& THEN
'      @arrinsert
ENDIF
IF obj=arrdel& THEN
'      @arrdelete
ENDIF
IF obj=trakexit& OR obj=9999 THEN
oldplay=FALSE
@setbutton(trakexit&,0)
winh=BCLR(winh,trakker&)
vornr=smpedit&
@restaura2b
obj=0
@setbutton(trak&,0)
GRAPHMODE 3
IF hz<>merkhz THEN
hz=merkhz
@swtosrate(hz)
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
RETURN
'
> PROCEDURE trakdrag
LOCAL a,x,v,v2,b
@markhlp
REPEAT
a=BIOS(11,-1)
@mouse(x,v,v2)
IF x>=xd+20 AND x<=xd+20+616-px THEN
b=x-xd-20
c=INT(toffs2+(tv/42*b))    ! Start-Position in msec
c2=trktime(atrkp)
IF c2<>c THEN
trktime(atrkp)=c
hsec=INT(trktime(atrkp)/10)
@htimeset
@textfeld(trksmpte&,a$,1)
ENDIF
ENDIF
UNTIL a=0
@timeline
RETURN
'
> PROCEDURE trksmpte_edit
vornr=nr
nr=delay&
@rsc_draw(nr,0)
@markhlp
dt=INT(trktime(atrkp)/10)
IF dt=0 THEN
a$="00000000"+CHR$(0)
ELSE
@delaytxt
ENDIF
@editfeld(delaytim&,a$)
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>delaytim&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=delayhlp& THEN
@helptxt("SMPTE-EDIT")
ENDIF
IF obj=delayr& THEN
@delayr
ENDIF
IF obj=delayl& THEN
@delayl
ENDIF
UNTIL obj=delayex& OR obj=delayok&
@setbutton(obj,0)
IF obj=delayok& THEN
@editread(delaytim&)  ! RÅckgabewert in a$
@txtdelay
IF wandel=TRUE THEN
trktime(atrkp)=dt*10
ENDIF
ENDIF
@restaura2
IF obj=delayok& THEN
hsec=INT(trktime(atrkp)/10)
@htimeset
@textfeld(trksmpte&,a$,1)
@timeline
ENDIF
@setbutton(trksmpte&,0)
RETURN
'
> PROCEDURE timeline
.| Glob. Var.: nr#,zu%,traknam1&,trakbox2&,xwidth#,ywidth#,trakkyz#,dt#,tv#
.|     b$,toffs#,trakkz#,toffs2#,a$,timeline&,vtrkp#,trkp#,trkz#,notrk#,t#
.|     trkc#,dv#,dv2#,trkbut#,d#,flen#
.| Felder    : trkch#(),trktime#(),trkend#(),trkstrt#(),trkfn$(),trksrate#()
.|     trkpnt#(),trknext#()
.| Ruft auf  : xrsrc_gaddr,hidetree2,textfeld,trkbutcalc2,trkbutcalc1
.|     hidetree
.| Aufruf in : button-4,trakker-1,do_trakker-4,
LOCAL i,j
~@xrsrc_gaddr(0,nr,zu%)
FOR j=0 TO 6
FOR i=0 TO 7
@hidetree2(traknam1&+i+j*8,TRUE)
NEXT i
NEXT j
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,trakbox2&,99,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
IF trakkyz=0 THEN
dt=1
tv=1
b$="ms"
ENDIF
IF trakkyz=1 THEN
dt=5
tv=5
b$="ms"
ENDIF
IF trakkyz=2 THEN
dt=10
tv=10
b$="ms"
ENDIF
IF trakkyz=3 THEN
dt=50
tv=50
b$="ms"
ENDIF
IF trakkyz=4 THEN
dt=100
tv=100
b$="ms"
ENDIF
IF trakkyz=5 THEN
dt=500
tv=500
b$="ms"
ENDIF
IF trakkyz=6 THEN
dt=1
tv=1000
b$="s"
ENDIF
IF trakkyz=7 THEN
dt=5
tv=5000
b$="s"
ENDIF
IF trakkyz=8 THEN
dt=10
tv=10000
b$="s"
ENDIF
IF trakkyz=9 THEN
dt=1
tv=1000*60
b$="m"
ENDIF
IF trakkyz=10 THEN
dt=5
tv=1000*60*5
b$="m"
ENDIF
IF trakkyz=11 THEN
dt=10
tv=1000*60*10
b$="m"
ENDIF
IF trakkyz=12 THEN
dt=1
tv=1000*60*60
b$="h"
ENDIF
toffs=dt*14*trakkz
toffs2=trakkz*tv*14
a$=LEFT$(STR$(toffs)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*2)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*3)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*4)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*5)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*6)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*7)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*8)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*9)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*10)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*11)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*12)+b$+SPACE$(5),7)
a$=a$+LEFT$(STR$(toffs+dt*13)+b$+SPACE$(5),7)
a$=a$+CHR$(0)
@textfeld(timeline&,a$,1)
vtrkp=trkp
IF trkz>0 THEN
FOR i=1 TO 8  !vorher 8
notrk=FALSE
t=0
trkc=-1
REPEAT
INC t
IF trkch(t)=i THEN
INC trkc
ENDIF
UNTIL t=trkz OR trkch(t)=i
IF trkch(t)=i THEN
dv=trktime(t)
dv2=trkend(t)-trkstrt(t)
trkbut=traknam1&+i-1+trkc*8
~@xrsrc_gaddr(0,nr,zu%)
DPOKE (zu%+24*trkbut+18),i*24-16           ! Y-Position des Objekts verÑndern
d=(dv2*flen/trksrate(t)/4*1000)                    ! Auflîsung in ms
trkp=t
REPEAT
extrk=FALSE
@trkbutcalc2
@trkbutcalc1
IF extrk=TRUE OR notrk=TRUE THEN
trkp=trknext(trkp)
ENDIF
UNTIL trkp=0 OR notrk=FALSE OR trkz=trkp
IF notrk=FALSE THEN
IF trkc=1 THEN
trkpnt(i)=t
ENDIF
@hidetree(traknam1&+i-1+trkc*8,FALSE)
IF atrkp=trkp THEN
@setbutton(traknam1&+i-1+trkc*8,1)
ENDIF
ELSE
trkc=0
ENDIF
a$=trkfn$(trkp)+CHR$(0)
@textfeld(trkbut,a$,1)
notrk=FALSE
IF trknext(t)<>0 THEN
REPEAT
t=trknext(t)
INC trkc
dv=trktime(t)
dv2=trkend(t)-trkstrt(t)
trkbut=traknam1&+i-1+trkc*8
~@xrsrc_gaddr(0,nr,zu%)
DPOKE (zu%+24*trkbut+18),i*24-16           ! Y-Position des Objekts verÑndern
d=(dv2*flen/trksrate(t)/4*1000)                    ! Auflîsung in ms
trkp=t
REPEAT
extrk=FALSE
@trkbutcalc2
@trkbutcalc1
IF extrk=TRUE OR notrk=TRUE THEN
trkp=trknext(trkp)
ENDIF
UNTIL trkp=0 OR notrk=FALSE OR trkz=trkp
IF notrk=FALSE THEN
IF trkc=1 THEN
trkpnt(i)=t
ENDIF
@hidetree(traknam1&+i-1+trkc*8,FALSE)
IF atrkp=trkp THEN
@setbutton(traknam1&+i-1+trkc*8,1)
ENDIF
ELSE
trkc=0
ENDIF
a$=trkfn$(trkp)+CHR$(0)
@textfeld(trkbut,a$,1)
notrk=FALSE
UNTIL trknext(t)=0 OR trktime(t)>=(trakkz+1)*tv*14
ENDIF
ENDIF
NEXT i
@trkbutdraw
ENDIF
trkp=vtrkp
RETURN
'
> PROCEDURE trakknr
.| Glob. Var.: trakact#,trakk1&,trakk2&,trakk3&,trakk4&,trakk5&,trakk6&
.|     trakk7&,trakk8&,obj#
.| Ruft auf  : setbutton
.| Aufruf in : do_trakker-1,
LOCAL t
IF trakact<>0 THEN
IF trakact=1 THEN
t=trakk1&
ENDIF
IF trakact=2 THEN
t=trakk2&
ENDIF
IF trakact=3 THEN
t=trakk3&
ENDIF
IF trakact=4 THEN
t=trakk4&
ENDIF
IF trakact=5 THEN
t=trakk5&
ENDIF
IF trakact=6 THEN
t=trakk6&
ENDIF
IF trakact=7 THEN
t=trakk7&
ENDIF
IF trakact=8 THEN
t=trakk8&
ENDIF
@setbutton(t,0)
ENDIF
@setbutton(obj,4)
IF obj=trakk1& THEN
trakact=1
ENDIF
IF obj=trakk2& THEN
trakact=2
ENDIF
IF obj=trakk3& THEN
trakact=3
ENDIF
IF obj=trakk4& THEN
trakact=4
ENDIF
IF obj=trakk5& THEN
trakact=5
ENDIF
IF obj=trakk6& THEN
trakact=6
ENDIF
IF obj=trakk7& THEN
trakact=7
ENDIF
IF obj=trakk8& THEN
trakact=8
ENDIF
RETURN
'
> PROCEDURE trakload
.| Glob. Var.: notrk#,trakact#,trkz#,a$,traktime&,hardopen#,handle#
.|     playstop#,op$,ext$,fil$,nr#,sectors#,f#,flen#,sectall#,sectpos#,hsec#
.|     vhz#,traklen&,a4$,nam$,lmax3#,trkp#,dv#,dv2#,t#,trkc#,t2#,trkbut#
.|     traknam1&,trakname&,zu%,tl#,d#,vorwork#,j#,a#,g#,obj#
.| Felder    : trkpath$(),trkch#(),trktime#(),trkend#(),trkstrt#()
.|     trknext#(),trkvor#(),trksrate#(),trkfn$(),trklen#()
.| Ruft auf  : textfeld,fileselect,rsc_redraw_obj,busy_mouse,ldhead,htimeset
.|     xrsrc_gaddr,trkbutcalc2,hidetree,setbutton,opentrk,arrmname
.| Aufruf in : do_trakker-1,
notrk=FALSE
IF trakact<>0 THEN
IF trkpath$(trkz+1)="" THEN
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(traktime&,a$,1)
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
@fileselect(op$+"*."+ext$,"","TRACK-FILE:")
IF EXIST(fil$) THEN
@busy_mouse
@ldhead
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
sectors=INT(f/flen)
sectall=sectors
sectpos=0
hardopen=TRUE
hsec=INT(sectall*flen/vhz/4*100)
@htimeset
@textfeld(traklen&,a$+CHR$(0),1)
a4$=LEFT$(STR$(INT(vhz/100)/10)+SPACE$(4),4)+CHR$(0)
a$=nam$+CHR$(0)
IF trkz<lmax3 THEN
INC trkz
trkp=trkz
atrkp=trkp   ! aktuelles File
dv=0
dv2=0
IF trkz>1 THEN
t=0
trkc=0
REPEAT
INC t
IF trkch(t)=trakact THEN
INC trkc
ENDIF
UNTIL t=trkz OR trkch(t)=trakact
IF trkch(t)=trakact THEN
dv=trktime(t)
dv2=trkend(t)-trkstrt(t)
t2=t
REPEAT
t2=trknext(t2)
IF t2<>0 THEN
t=t2
INC trkc
ENDIF
dv=trktime(t)
dv2=trkend(t)-trkstrt(t)
UNTIL (trkch(t)=trakact AND trknext(t)=0)
ENDIF
IF trkch(t)=trakact AND trknext(t)=0 THEN
trknext(t)=trkz
trkvor(trkz)=t
ENDIF
ENDIF
trkbut=traknam1&+trakact-1+trkc*8
butnam$=a$
a$="*"+CHR$(0)  ! Startobj
@textfeld(trkbut,a$,1)
@textfeld(trakname&,nam$+CHR$(0),1)
~@xrsrc_gaddr(0,nr,zu%)
DPOKE (zu%+24*trkbut+18),trakact*24-16        ! Y-Position des Objekts verÑndern
tl=72
d=(dv2*flen/vhz/4*1000)                    ! Auflîsung in ms
trktime(trkz)=dv+d
trksrate(trkz)=vhz
@trkbutcalc2
@trkbutcalc1
@trkbutdraw
IF notrk=FALSE THEN
@hidetree(traknam1&+trakact-1+trkc*8,FALSE)
ENDIF
trkpath$(trkz)=fil$+CHR$(0)
trkfn$(trkz)=nam$
trklen(trkz)=sectall
trkch(trkz)=trakact
IF vorwork<>0 THEN
@setbutton(vorwork,0)
ENDIF
vorwork=traknam1&+trakact-1+trkc*8
@setbutton(vorwork,1)
j=trkc
a=trakact
@opentrk
ELSE
ALERT 1,"Alle PlÑtze belegt !",1,"EXIT",g
ENDIF
ENDIF
ELSE
@arrmname
ENDIF
ELSE
ALERT 1,"Zuerst Spur auswÑhlen !",1,"EXIT",g
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE traksethz
.| Glob. Var.: vhz#,trkp#
.| Felder    : trksrate#()
.| Ruft auf  : swtosrate,analog,digout
.| Aufruf in : trakforw-1,trkbackw-1,
vhz=trksrate(trkp)
IF vhz=0 THEN
vhz=44100
ENDIF
@swtosrate(vhz)
@analog
@digout(TRUE)
RETURN
'
> PROCEDURE trakforw
.| Glob. Var.: trkp#,pa$,vhz#,playstop#,hardopen#,handle#,sectall#,sectpos#
.|     sectors#,l#,playpos#,flen#,back%,hsec#,traktime&,a$,nr#
.| Felder    : trkpath$(),trksrate#()
.| Ruft auf  : traksethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_trakker-2,
IF trkpath$(trkp)<>"" AND pa$<>"" THEN
@traksethz
vhz=trksrate(trkp)
@maschinit5
IF playstop=2 AND hardopen=TRUE THEN
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
IF sectall>sectpos THEN
sectors=sectall-sectpos
l=0
playpos=sectpos*flen
@maschruf5
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
ENDIF
@digout(FALSE)
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(traktime&,a$,1)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
playpos=sectpos*flen
sectors=sectall-sectpos
l=0
playpos=sectpos*flen
@maschruf5
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
@digout(FALSE)
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
IF vhz>0 THEN
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE trkbackw
.| Glob. Var.: trkp#,pa$,vhz#,playstop#,hardopen#,sectpos#,sectors#,l#
.|     playpos#,flen#,back%,handle#,sectall#,hsec#,traktime&,a$,nr#
.| Felder    : trkpath$(),trksrate#()
.| Ruft auf  : traksethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_trakker-2,
IF trkpath$(trkp)<>"" AND pa$<>"" THEN
@traksethz
vhz=trksrate(trkp)
@maschinit5
IF playstop=2 AND hardopen=TRUE THEN
@digout(TRUE)
@swtosrate(vhz)
IF sectpos>0 THEN
sectors=sectpos
l=0
playpos=sectpos*flen
@maschruf5
IF sectpos>0 THEN
sectpos=sectpos-back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
ENDIF
@digout(FALSE)
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF sectpos=0 THEN
sectpos=sectall
ENDIF
playpos=sectpos*flen
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(traktime&,a$,1)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
sectors=sectpos
l=0
playpos=sectpos*flen
@maschruf5
IF sectpos>0 THEN
sectpos=sectpos-back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
@digout(FALSE)
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
RETURN
'
> PROCEDURE trkpause
.| Glob. Var.: pause2&
.| Ruft auf  : setbutton
.| Aufruf in : do_trakker-1,
@setbutton(pause2&,0)
RETURN
'
> PROCEDURE trkstop
.| Glob. Var.: handle#,playstop#,hardopen#,a$,trakname&,stop2&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : do_trakker-1,
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
a$=SPACE$(12)
@textfeld(trakname&,a$,1)
@setbutton(stop2&,0)
RETURN
'
> PROCEDURE trkstrt
.| Glob. Var.: trkp#,sectpos#,hsec#,flen#,vhz#,trakstrt&,a$
.| Felder    : trkstrt#()
.| Ruft auf  : htimeset,textfeld,setbutton,trkbutcalc1
.| Aufruf in : do_trakker-1,
trkstrt(trkp)=sectpos
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(trakstrt&,a$,1)
@setbutton(trakstrt&,0)
@trkbutcalc1
@trkbutdraw
RETURN
'
> PROCEDURE trakdel
LOCAL i,j
'  DIM trkpnt(8)
IF atrkp<>0 THEN
i=atrkp
IF trknext(i)=0 THEN
trkfn$(atrkp)=""
trkpath$(atrkp)=""
trkstrt(atrkp)=0
trkend(atrkp)=0
trksrate(atrkp)=0
trktri(atrkp)=0
trkloop(atrkp)=0
trklen(atrkp)=0
trktime(atrkp)=0
trknext(atrkp)=0
IF trkvor(atrkp)<>0 AND atrkp=trkz THEN
trknext(trkvor(atrkp))=0
ENDIF
trkvor(atrkp)=0
trkch(atrkp)=0
IF atrkp=trkz THEN
DEC trkz
ENDIF
ELSE
REPEAT
j=trknext(i)
IF j<>0 THEN
trkfn$(i)=trkfn$(j)
trkpath$(i)=trkpath$(j)
trkstrt(i)=trkstrt(j)
trkend(i)=trkend(j)
trksrate(i)=trksrate(j)
trktri(i)=trktri(j)
trkloop(i)=trkloop(j)
trklen(i)=trklen(j)
trknext(i)=trknext(j)
trkch(i)=trkch(j)
trktime(i)=trktime(j)
i=j
ENDIF
UNTIL j=0
ENDIF
atrkp=0
@timeline
ENDIF
@setbutton(trakdel&,0)
RETURN
'
> PROCEDURE trkbutcalc1    ! Breite
.| Glob. Var.: a#,trkp#,b#,c#,flen#,tv#,d#,toffs2#,px#,nr#,zu%,trkbut#
.|     trakbox2&,xwidth#,ywidth#,notrk#
.| Felder    : trkstrt#(),trkend#(),trksrate#(),trktime#(),trknext#()
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : timeline-2,trkstrt-1,trkend-1,
a=trkstrt(trkp)
b=trkend(trkp)
c=b-a
IF c<1 THEN
c=1
ENDIF
c=INT((c*flen/trksrate(trkp)/4*1000))
d=trktime(trkp)
IF toffs2>0 THEN
d=d-toffs2
ENDIF
IF d<0 THEN
IF d+c>=0 THEN
c=c+d
d=0
ENDIF
ENDIF
c=INT((c*42/tv))
IF c<6 THEN   ! vorher 72
c=6
ENDIF
IF d>=0 THEN
d=INT((d/tv*42))+px+1
ENDIF
IF c<=0 THEN
extrk=TRUE
ENDIF
IF d<=610 AND d>=px+1 AND c>0 AND trkp<>0 AND extrk=FALSE THEN
~@xrsrc_gaddr(0,nr,zu%)
IF c+d>616 THEN
c=616-d
ENDIF
DPOKE (zu%+24*trkbut+20),c                         ! Breite des Objekts verÑndern
'    ~WIND_UPDATE(1)                                    ! BEG_UPDATE
'    ~OBJC_DRAW(zu%,trakbox2&,99,0,0,xwidth,ywidth)     ! neu zeichnen
'    ~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
notrk=TRUE
ENDIF
RETURN
'
> PROCEDURE trkbutcalc2    ! X-Position
.| Glob. Var.: d#,trkp#,toffs2#,a#,b#,c#,flen#,tv#,px#,nr#,zu%,tl#,trkbut#
.|     trakbox2&,xwidth#,ywidth#,notrk#
.| Felder    : trktime#(),trkstrt#(),trkend#(),trksrate#(),trknext#()
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : timeline-2,trakload-1,
d=trktime(trkp)
IF toffs2>0 THEN
d=d-toffs2
ENDIF
a=trkstrt(trkp)
b=trkend(trkp)
c=b-a
c=INT((c*flen/trksrate(trkp)/4*1000))
IF d<0 THEN
IF d+c>=0 THEN
d=0
ENDIF
ENDIF
c=INT((c*42/tv))
IF c<6 THEN   ! vorher 72
c=6
ENDIF
d=INT(d/tv*42)
IF d>=0 THEN
d=d+px+1
ELSE
extrk=TRUE
ENDIF
IF d<=610 AND d>=px+1 AND c>0 AND trkp<>0 AND extrk=FALSE THEN
~@xrsrc_gaddr(0,nr,zu%)
IF c+d+tl>616 THEN
c=616-d
'      DPOKE (zu%+24*trkbut+20),c                       ! Breite des Objekts verÑndern
ENDIF
DPOKE (zu%+24*(trkbut)+16),d                       ! X-Position des Objekts verÑndern
'    ~WIND_UPDATE(1)                                    ! BEG_UPDATE
'    ~OBJC_DRAW(zu%,trakbox2&,99,0,0,xwidth,ywidth)     ! neu zeichnen
'    ~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
notrk=TRUE
ENDIF
RETURN
'
> PROCEDURE trkbutdraw
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,trakbox2&,99,0,0,xwidth,ywidth)     ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE trkend
.| Glob. Var.: trkp#,sectpos#,hsec#,flen#,vhz#,trakend&,a$
.| Felder    : trkend#()
.| Ruft auf  : htimeset,textfeld,setbutton,trkbutcalc1
.| Aufruf in : do_trakker-1,
trkend(trkp)=sectpos
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(trakend&,a$,1)
@setbutton(trakend&,0)
@trkbutcalc1
@textfeld(trkbut,butnam$,1)
@trkbutdraw
RETURN
'
> PROCEDURE trkanf
.| Glob. Var.: handle#,pa$,sectpos#,hsec#,flen#,vhz#,traktime&,a$,playpos#
.|     g#,trakanf&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_trakker-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=0
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(traktime&,a$,1)
playpos=sectpos
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=0
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
IF handle<0 THEN
ALERT 1,"Zuerst Sample laden !",1,"OK",g
handle=0
ENDIF
@setbutton(trakanf&,0)
RETURN
'
> PROCEDURE trkfull
.| Glob. Var.: handle#,pa$,sectpos#,sectall#,hsec#,flen#,vhz#,traktime&,a$
.|     playpos#,g#,trakfull&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_trakker-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=sectall
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(traktime&,a$,1)
playpos=sectpos*flen
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=sectall
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
IF handle<0 THEN
ALERT 1,"Zuerst Sample laden !",1,"OK",g
handle=0
ENDIF
@setbutton(trakfull&,0)
RETURN
'
> PROCEDURE trkplay
.| Glob. Var.: virtual#,g#,vad#,ad#,over#,i#,rpat$,vvhz#,hz#,pat$,vhz#
.|     realtime#,hsec#,traktime&,a$,trakname&,t#,aready#,tim#,v3#,a#,back%
.|     l#,meml#,b#,adder#,saa%,sba%,loop#,flen#,pa$,sectors#,sectpos#
.|     handle#,playpos#,lmax3#,b$,trakplay&
.| Felder    : trkpath$(),trksrate#(),trkstrt#(),trkend#(),trkfn$()
.|     trktri#(),trkloop#()
.| Ruft auf  : analog,wait,makehz,digout,maschinit2b,maschinit5b,htimeset
.|     textfeld,mousek,swtosrate,maschruf2c,maschruf5c,maschinit2d,digital
.|     setbutton
.| Aufruf in : do_trakker-1,
LOCAL r,akku,j,rr
voldplay=oldplay
oldplay=FALSE
IF virtual=TRUE THEN
ALERT 1,"Kein PLAY von Memory-Daten !|Wegen virt. Bearbeitung|gesperrt.",1,"OK",g
ENDIF
vad=ad
IF vad=0 THEN
@analog
ENDIF
@wait
over=0
@makehz
@digout(TRUE)
@maschinit2b
@maschinit5b
i=0
j=0
rr=0
akku=0
rpat$=""
vvhz=hz
REPEAT
INC i
pat$=trkpath$(i)
vhz=trksrate(i)
IF vhz=0 THEN
vhz=44100
ENDIF
IF pat$="DELAY" THEN
IF realtime=FALSE THEN
hsec=trkstrt(i)
ELSE
hsec=INT(akku/vhz/4*100)
akku=akku+trkend(i)*vhz*4/100
ENDIF
@htimeset
@textfeld(traktime&,a$,1)
a$=LEFT$(trkfn$(i)+SPACE$(12),12)
@textfeld(trakname&,a$,1)
t=trkend(i)*2
aready=FALSE
tim=TIMER
REPEAT
v3=@mousek
a=TIMER
IF (a-tim)<0 THEN
tim=0
ENDIF
IF (a-tim)>=t THEN
aready=TRUE
ENDIF
UNTIL aready=TRUE OR v3<>0
IF aready=TRUE THEN
back%=0
ELSE
back%=1
ENDIF
ENDIF
IF trkend(i)<>0 AND pat$<>"" AND pat$<>"DELAY" THEN
IF pat$="MEMORY" THEN
r=trktri(i)
IF realtime=FALSE THEN
IF r=0 OR r=2 THEN
hsec=INT(trkstrt(i)/vhz/4*100)
ENDIF
IF r=1 THEN
hsec=INT(trkend(i)/vhz/4*100)
ENDIF
ELSE
hsec=INT(akku/vhz/4*100)
IF r=2 THEN
akku=akku+(trkend(i)-trkstrt(i))*2
ELSE
akku=akku+trkend(i)-trkstrt(i)
ENDIF
ENDIF
@htimeset
@textfeld(traktime&,a$,1)
a$=LEFT$(trkfn$(i)+SPACE$(12),12)
@textfeld(trakname&,a$,1)
IF r=0 OR r=2 THEN
l=trkloop(i)+r
a=trkstrt(i)+meml
b=trkend(i)+meml
adder=0
ENDIF
IF r=1 THEN
l=trkloop(i)
b=trkstrt(i)+meml
a=trkend(i)+meml
adder=-8
ENDIF
IF virtual=FALSE THEN
@swtosrate(vhz)
@digout(TRUE)
saa%=a
sba%=b
@maschruf2c
ELSE
back%=0
ENDIF
ELSE
IF EXIST(pat$) THEN
loop=trkloop(i)
r=trktri(i)
IF r=0 OR r=2 THEN
IF realtime=FALSE THEN
hsec=INT(trkstrt(i)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
akku=akku+(trkend(i)-trkstrt(i))*flen
IF r=2 THEN
akku=akku+(trkend(i)-trkstrt(i))*flen
ENDIF
ENDIF
@htimeset
@textfeld(traktime&,a$,1)
pa$=pat$+CHR$(0)
a$=LEFT$(trkfn$(i)+SPACE$(12),12)
@textfeld(trakname&,a$,1)
sectors=trkend(i)-trkstrt(i)
sectpos=trkstrt(i)
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
playpos=trkstrt(i)*flen
@swtosrate(vhz)
over=0
l=r+loop
@maschruf5c
~GEMDOS(62,handle)
ENDIF
ENDIF
IF r=1 THEN
IF realtime=FALSE THEN
hsec=INT(trkend(i)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
akku=akku+(trkend(i)-trkstrt(i))*flen
ENDIF
@htimeset
@textfeld(traktime&,a$,1)
pa$=pat$+CHR$(0)
a$=LEFT$(trkfn$(i)+SPACE$(12),12)
@textfeld(trakname&,a$,1)
sectors=trkend(i)-trkstrt(i)
sectpos=trkend(i)
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
playpos=trkend(i)*flen
l=loop
over=-8
@swtosrate(vhz)
@maschruf5c
~GEMDOS(62,handle)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF pat$<>"" THEN
j=i
rr=r
rpat$=pat$
vvhz=vhz
ENDIF
IF XBIOS(500)=&H71273800 THEN
back%=INT(back%/2)
ENDIF
UNTIL i=lmax3 OR (back%<>sectors AND pat$<>"MEMORY" AND pat$<>"" AND pat$<>"DELAY") OR (back%<>0 AND pat$="DELAY") OR (pat$="MEMORY" AND ((back%<>sba% AND (r=1 OR r=0)) OR (back%<>saa%+4 AND r=2)))
@maschinit2d
vhz=vvhz
@textfeld(trakname&,"            "+CHR$(0),1)
IF rpat$="DELAY" AND back%=0 THEN
IF realtime=FALSE THEN
hsec=trkend(j)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF pat$="DELAY" AND back%<>0 THEN
a$="   BREAK   "+CHR$(0)
ENDIF
IF pat$="MEMORY" AND ((r=0 OR r=1) AND back%<>sba%) OR (r=2 AND back%<>saa%+4) THEN
a$="   BREAK   "+CHR$(0)
ENDIF
IF pat$<>"MEMORY" AND pat$<>"DELAY" AND pat$<>"" AND back%<>sectors THEN
IF r=0 THEN
IF realtime=FALSE THEN
hsec=INT((trkstrt(i)+back%)*flen/vhz/4*100)
ELSE
hsec=INT(((akku-((trkend(i)-trkstrt(i))*flen)+(back%*flen)))/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF r=1 THEN
IF realtime=FALSE THEN
hsec=INT((trkend(i)-back%)*flen/vhz/4*100)
ELSE
hsec=INT(((akku-((trkend(i)-trkstrt(i))*flen)+(back%*flen)))/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF r=2 AND back%<>sectors THEN
a$="   BREAK   "+CHR$(0)
ENDIF
ENDIF
IF rpat$<>"" AND rpat$<>"MEMORY" AND rpat$<>"DELAY" THEN
IF rr=0 AND back%=sectors THEN
IF realtime=FALSE THEN
hsec=INT(trkend(j)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=1 AND back%=sectors THEN
IF realtime=FALSE THEN
hsec=INT(trkstrt(j)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=2 AND back%=sectors THEN
IF realtime=FALSE THEN
hsec=INT(trkstrt(j)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
ENDIF
IF rpat$="MEMORY" THEN
IF rr=0 AND back%=sba% THEN
IF realtime=FALSE THEN
hsec=INT(trkend(j)/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=1 AND back%=sba% THEN
IF realtime=FALSE THEN
hsec=INT(trkstrt(j)/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=2 AND back%=saa%+4 THEN
IF b$<>a$ THEN
IF realtime=FALSE THEN
hsec=INT(trkstrt(j)/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
ENDIF
ENDIF
@textfeld(traktime&,a$,1)
@digout(FALSE)
IF vad=0 THEN
@digital
ENDIF
@setbutton(trakplay&,0)
oldplay=voldplay
RETURN
'
> PROCEDURE trktowork
.| Glob. Var.: spring#,trkbut#,obj#,i#,traknam1&,a#,j#,vorwork#
.| Ruft auf  : setbutton,opentrk
.| Aufruf in : do_trakker-1,
IF spring=FALSE THEN
'    @dragging1
ENDIF
trkbut=obj
FOR i=0 TO 6
IF obj=traknam1&+i*8 THEN
a=1
j=i
ENDIF
IF obj=traknam1&+1+i*8 THEN
a=2
j=i
ENDIF
IF obj=traknam1&+2+i*8 THEN
a=3
j=i
ENDIF
IF obj=traknam1&+3+i*8 THEN
a=4
j=i
ENDIF
IF obj=traknam1&+4+i*8 THEN
a=5
j=i
ENDIF
IF obj=traknam1&+5+i*8 THEN
a=6
j=i
ENDIF
IF obj=traknam1&+6+i*8 THEN
a=7
j=i
ENDIF
IF obj=traknam1&+7+i*8 THEN
a=8
j=i
ENDIF
NEXT i
IF vorwork<>0 THEN
IF vorwork=obj THEN
@setbutton(vorwork,1)
ELSE
@setbutton(vorwork,0)
ENDIF
ENDIF
@opentrk
vorwork=obj
RETURN
'
> PROCEDURE opentrk
.| Glob. Var.: t#,lmax3#,a#,toffs2#,j#,b#,trkp#,hardopen#,handle#,playstop#
.|     pat$,vhz#,pa$,f#,sectors#,flen#,sectall#,sectpos#,hsec#,trakstrt&,a$
.|     s#,trakend&,traklen&,trksmpte&,g#,g2#,traktime&,trakname&
.| Felder    : trkch#(),trkpnt#(),trknext#(),trkpath$(),trksrate#()
.|     trkstrt#(),trkend#(),trklen#(),trktime#(),trkfn$()
.| Ruft auf  : htimeset,textfeld
.| Aufruf in : trakload-1,trktowork-1,
t=0
REPEAT
INC t
UNTIL t=lmax3 OR trkch(t)=a
'
IF toffs2>0 THEN
t=trkpnt(a)
j=j-1
ENDIF
'
IF j>0 THEN
b=0
REPEAT
INC b
t=trknext(t)
UNTIL b=j
ENDIF
trkp=t
atrkp=trkp   ! aktuelles File
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF trkpath$(trkp)<>"MEMORY" AND trkpath$(trkp)<>"DELAY" AND trkpath$(trkp)<>"" THEN
pat$=trkpath$(trkp)
vhz=trksrate(trkp)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pa$=pat$+CHR$(0)
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
sectors=INT(f/flen)
sectall=sectors
sectpos=trkstrt(trkp)
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(trakstrt&,a$,1)
s=trkend(trkp)
hsec=INT(s*flen/vhz/4*100)
@htimeset
@textfeld(trakend&,a$,1)
s=trklen(trkp)
hsec=INT(s*flen/vhz/4*100)
@htimeset
@textfeld(traklen&,a$,1)
hsec=INT(trktime(trkp)/10)
@htimeset
@textfeld(trksmpte&,a$,1)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=LEFT$(pat$+SPACE$(12),12)+CHR$(0)
hardopen=TRUE
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(traktime&,a$,1)
a$=LEFT$(trkfn$(trkp)+SPACE$(12),12)
@textfeld(trakname&,a$,1)
ENDIF
RETURN
'
> PROCEDURE arrsmpr
.| Glob. Var.: obj#,arrsmpr1&,arrsmpr2&,arrsmpr3&,arrsmpr4&,pbz#,mrkobj#
.|     vorvornr#,vornr#,nr#,resample&,zu%,versatz#,a$,string#,rsmptxt1&,it#
.|     rsmptxt2&,resorig#,db$,restxt&,resoth#,resother&,popup&,zuadr#,x#,y#
.|     v3#,buttadr#,but#,resl1&,resl2&,resl3&,resr1&,resr2&,resr3&,objadr#
.|     objflag#,res32&,res44&,res48&,helprsmp&,resok&,resexit&,noresok#,a#
.|     edit_obj&
.| Felder    : arrpath$(),arrsrate#()
.| Ruft auf  : xrsrc_gaddr,rsc_draw,editfeld,textfeld,rsc_do,mouse,setbutton
.|     resl,resr,resoth32,resoth44,resoth48,helptxt,editread,restaura2
.|     arrnrset
.| Aufruf in : do_arrange-1,
LOCAL i,j
IF obj=arrsmpr1& THEN
i=1
ENDIF
IF obj=arrsmpr2& THEN
i=2
ENDIF
IF obj=arrsmpr3& THEN
i=3
ENDIF
IF obj=arrsmpr4& THEN
i=4
ENDIF
IF arrpath$(pbz*4+i)<>"" THEN
mrkobj=obj
vorvornr=vornr
vornr=nr
'    @rsc_back(nr)
nr=resample&
~@xrsrc_gaddr(0,resample&,zu%)
zuadr=zu%
versatz=1
a$="SAMPLERATE"
string=LPEEK(LPEEK(zu%+24*rsmptxt1&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
a$="  NEW  "
string=LPEEK(LPEEK(zu%+24*rsmptxt2&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
@rsc_draw(nr,0)
resorig=INT(arrsrate(pbz*4+i)/100)/10
db$=STR$(resorig)+CHR$(0)
@editfeld(restxt&,db$)
resoth=44.1
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1
IF obj=resl1& OR obj=resl2& OR obj=resl3& OR obj=resr1& OR obj=resr2& OR obj=resr3& THEN
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=resl1& OR obj=resl2& OR obj=resl3& THEN
@resl
ENDIF
IF obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@resr
ENDIF
IF obj=res32& THEN
@resoth32
ENDIF
IF obj=res44& THEN
@resoth44
ENDIF
IF obj=res48& THEN
@resoth48
ENDIF
IF obj=helprsmp& THEN
@helptxt("ARR-SAMPLERATE")
ENDIF
UNTIL obj=resok& OR obj=resexit&
IF obj=resok& THEN
@editread(resother&)
noresok=FALSE
IF LEN(a$)>0 THEN
FOR j=1 TO LEN(a$)
a=ASC(MID$(a$,j,1))
IF (a<48 OR a>57) AND a<>46 THEN
noresok=TRUE
ENDIF
IF (j=1 OR j=4) AND a=46 THEN
noresok=TRUE
ENDIF
NEXT j
ELSE
noresok=TRUE
ENDIF
ENDIF
@setbutton(obj,0)
UNTIL (obj=resok& AND noresok=FALSE) OR obj=resexit&
IF obj=resok& AND noresok=FALSE THEN
resoth=VAL(a$)*1000
arrsrate(pbz*4+i)=resoth
ENDIF
@restaura2
~@xrsrc_gaddr(0,resample&,zu%)
a$="RESAMPLING"
string=LPEEK(LPEEK(zu%+24*rsmptxt1&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
a$="CONVERT"
string=LPEEK(LPEEK(zu%+24*rsmptxt2&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
vornr=vorvornr
@setbutton(mrkobj,0)
@arrnrset
ELSE
@setbutton(obj,0)
ENDIF
obj=0
edit_obj&=0
RETURN
'
> PROCEDURE realtime
.| Glob. Var.: realtime#
.| Ruft auf  : arrnrset
.| Aufruf in : do_arrange-1,
IF realtime=FALSE THEN
realtime=TRUE
@arrnrset
ELSE
realtime=FALSE
@arrnrset
ENDIF
RETURN
'
> PROCEDURE arrstrt
.| Glob. Var.: handle#,pa$,sectpos#,hsec#,flen#,vhz#,playlen&,a$,playpos#,g#
.|     arrstrt&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_arrange-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=0
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
playpos=sectpos
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=0
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
IF handle<0 THEN
ALERT 1,"Zuerst Sample laden !",1,"OK",g
handle=0
ENDIF
@setbutton(arrstrt&,0)
RETURN
'
> PROCEDURE arrend
.| Glob. Var.: handle#,pa$,sectpos#,sectall#,hsec#,flen#,vhz#,playlen&,a$
.|     playpos#,g#,arrend&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_arrange-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=sectall
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
playpos=sectpos*flen
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=sectall
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
IF handle<0 THEN
ALERT 1,"Zuerst Sample laden !",1,"OK",g
handle=0
ENDIF
@setbutton(arrend&,0)
RETURN
'
> PROCEDURE dragging1
.| Glob. Var.: obj#,arrm1&,arrm2&,arrm3&,arrm4&,arrherr#,pbz#,dragm#,mobj2#
.|     nr#,zu%,vmp#,vmp2#,v3#,vm#,vm2#,ag#,xd#,bx#,yd#,by#,mdat%,ag2#,mdat2%
.|     v#,v2#,k#,fobj#,arrclip&,hardtype#,buttflag#,merkclip#,drag#,i#
.| Felder    : arrpath$()
.| Ruft auf  : markhlp,xrsrc_gaddr,readpos,mouse,rsc_get2,rsc_put,readbutton
.|     setbutton
.| Aufruf in : arrtowork-1,
LOCAL z
IF obj=arrm1& THEN
z=1
ENDIF
IF obj=arrm2& THEN
z=2
ENDIF
IF obj=arrm3& THEN
z=3
ENDIF
IF obj=arrm4& THEN
z=4
ENDIF
IF arrherr=pbz*4+z THEN
IF arrpath$(arrherr)<>"" THEN
dragm=FALSE
mobj2=obj
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
@readpos(obj)
GRAPHMODE 3
@mouse(vmp,vmp2,v3)
vm=vmp
vm2=vmp2
~GRAF_MOUSE(256,0)                              ! Hidem
ag=@rsc_get2(xd+bx-13,yd+by+129,29,17,mdat%)
ag2=@rsc_get2(xd+bx-13,yd+by+129,29,17,mdat2%)
@rsc_put(ag2,xd+bx-13,yd+by+129,1)
REPEAT
@mouse(v,v2,k)
IF k=1 AND (v<>vm OR v2<>vm2) THEN
@rsc_put(ag2,xd+bx-13+(vm-vmp),yd+by+129+(vm2-vmp2),1)
ag2=@rsc_get2(xd+bx-13+(v-vmp),yd+by+129+(v2-vmp2),29,17,mdat2%)
@rsc_put(ag,xd+bx-13+(v-vmp),yd+by+129+(v2-vmp2),1)
vm=v
vm2=v2
ENDIF
fobj=OBJC_FIND(zu%,0,10,v,v2)
IF fobj=arrclip& THEN
@readbutton(arrclip&)
IF hardtype<>0 AND arrherr=pbz*4+z THEN
IF buttflag=0 AND arrpath$(pbz*4+z)<>"" THEN
@setbutton(arrclip&,1)
dragm=TRUE
merkclip=pbz*4+z
ENDIF
ENDIF
ENDIF
IF fobj<>arrclip& AND dragm=TRUE THEN
@readbutton(arrclip&)
IF buttflag<>0 THEN
@setbutton(arrclip&,0)
ENDIF
ENDIF
UNTIL k=0
@rsc_put(ag2,xd+bx-13+(vm-vmp),yd+by+129+(vm2-vmp2),1)
~GRAF_MOUSE(257,0)                              ! Showm
IF fobj=arrclip& AND drag=TRUE THEN
@setbutton(arrclip&,0)
FOR i=0 TO 2
PAUSE 2
@setbutton(arrclip&,1)
PAUSE 2
@setbutton(arrclip&,0)
NEXT i
merkclip=pbz*4+z
ENDIF
GRAPHMODE 3
IF dragm=TRUE THEN
drag=TRUE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE dragging2
.| Glob. Var.: drag#,drag2#,nr#,zu%,obj#,vmp#,vmp2#,v3#,vm#,vm2#,ag#,xd#,bx#
.|     yd#,by#,v#,v2#,k#,ag2#,mdat2%,arrm1&,arrm2&,arrm3&,arrm4&,pbz#
.|     buttflag#,mobj#,mobj2#,i#,merkclip#,arrclip&,spring#
.| Felder    : arrpath$(),arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrloop#()
.|     arrtri#(),arrsrate#()
.| Ruft auf  : markhlp,xrsrc_gaddr,readpos,mouse,rsc_put,rsc_get2,readbutton
.|     setbutton,arrtowork,arrnrset,mousek
.| Aufruf in : do_arrange-1,
LOCAL z
IF drag=TRUE THEN
@markhlp
drag2=FALSE
~@xrsrc_gaddr(0,nr,zu%)
@readpos(obj)
GRAPHMODE 3
@mouse(vmp,vmp2,v3)
vm=vmp
vm2=vmp2
~GRAF_MOUSE(256,0)                              ! Hidem
@rsc_put(ag,xd+bx-20,yd+by-40,1)
REPEAT
@mouse(v,v2,k)
IF k=1 AND (v<>vm OR v2<>vm2) THEN
@rsc_put(ag2,xd+bx-20+(vm-vmp),yd+by-40+(vm2-vmp2),1)
ag2=@rsc_get2(xd+bx-20+(v-vmp),yd+by-40+(v2-vmp2),29,17,mdat2%)
@rsc_put(ag,xd+bx-20+(v-vmp),yd+by-40+(v2-vmp2),1)
vm=v
vm2=v2
ENDIF
obj=OBJC_FIND(zu%,0,10,v,v2)
IF obj=arrm1& OR obj=arrm2& OR obj=arrm3& OR obj=arrm4& THEN
z=0
IF obj=arrm1& THEN
z=1
ENDIF
IF obj=arrm2& THEN
z=2
ENDIF
IF obj=arrm3& THEN
z=3
ENDIF
IF obj=arrm4& THEN
z=4
ENDIF
IF z=>0 THEN
IF arrpath$(pbz*4+z)="" THEN
@readbutton(obj)
IF buttflag=0 THEN
@setbutton(obj,1)
drag2=TRUE
mobj=obj
ENDIF
ENDIF
ENDIF
ENDIF
IF obj<>arrm1& AND obj<>arrm2& AND obj<>arrm3& AND obj<>arrm4& AND drag2=TRUE THEN
@setbutton(mobj,0)
drag2=FALSE
ENDIF
UNTIL k=0
@rsc_put(ag2,xd+bx-20+(vm-vmp),yd+by-40+(vm2-vmp2),1)
~GRAF_MOUSE(257,0)                              ! Showm
IF drag2=TRUE THEN
@setbutton(mobj2,0)
@setbutton(mobj,1)
FOR i=0 TO 2
PAUSE 2
@setbutton(mobj,0)
PAUSE 2
@setbutton(mobj,1)
NEXT i
arrfn$(pbz*4+z)=arrfn$(merkclip)
arrpath$(pbz*4+z)=arrpath$(merkclip)
arrstrt(pbz*4+z)=arrstrt(merkclip)
arrend(pbz*4+z)=arrend(merkclip)
arrlen(pbz*4+z)=arrlen(merkclip)
'      arrmidi(pbz*4+z)=arrmidi(merkclip)
arrloop(pbz*4+z)=arrloop(merkclip)
arrtri(pbz*4+z)=arrtri(merkclip)
arrsrate(pbz*4+z)=arrsrate(merkclip)
obj=mobj
@setbutton(arrclip&,0)
spring=TRUE
@arrtowork
spring=FALSE
@arrnrset
ENDIF
GRAPHMODE 3
ELSE
REPEAT
UNTIL @mousek=0
ENDIF
@setbutton(arrclip&,0)
RETURN
'
> PROCEDURE arrtowork
.| Glob. Var.: spring#,obj#,arrm1&,hardtype#,arrherr#,pbz#,arrm2&,arrm3&
.|     arrm4&,hardopen#,handle#,playstop#,pat$,vhz#,arrz#,pa$,f#,sectors#
.|     flen#,sectall#,sectpos#,g#,g2#,hsec#,playlen&,a$,playname&
.| Felder    : arrpath$(),arrsrate#(),arrstrt#(),arrfn$()
.| Ruft auf  : dragging1,htimeset,textfeld
.| Aufruf in : do_arrange-1,dragging2-1,
IF spring=FALSE THEN
@dragging1
ENDIF
IF obj=arrm1& THEN
hardtype=1
arrherr=pbz*4+1
ENDIF
IF obj=arrm2& THEN
hardtype=2
arrherr=pbz*4+2
ENDIF
IF obj=arrm3& THEN
hardtype=3
arrherr=pbz*4+3
ENDIF
IF obj=arrm4& THEN
hardtype=4
arrherr=pbz*4+4
ENDIF
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF arrpath$(pbz*4+hardtype)<>"MEMORY" AND arrpath$(pbz*4+hardtype)<>"DELAY" AND arrpath$(pbz*4+hardtype)<>"" THEN
pat$=arrpath$(pbz*4+hardtype)
vhz=arrsrate(pbz*4+hardtype)
arrz=hardtype
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pa$=pat$+CHR$(0)
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
sectors=INT(f/flen)
sectall=sectors
sectpos=arrstrt(pbz*4+hardtype)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=LEFT$(pat$+SPACE$(12),12)+CHR$(0)
hardopen=TRUE
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
a$=LEFT$(arrfn$(pbz*4+hardtype)+SPACE$(12),12)
@textfeld(playname&,a$,1)
ENDIF
RETURN
'
> PROCEDURE copytoarr
.| Glob. Var.: lmax2#,sms#,sme#,virtual#,c1#,c2#,flen#,vmem#,path$,hz#
.|     sloop#,sret#,smpnam$,i$,coptotxt&,g#,coptoarr&
.| Felder    : arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrpath$()
.|     arrsrate#(),arrloop#(),arrtri#()
.| Ruft auf  : blocklook,textfeld,rsc_alert,setbutton
.| Aufruf in : do_smpedit-1,
LOCAL i
i=0
REPEAT
INC i
UNTIL i=lmax2 OR arrfn$(i)=""
IF arrfn$(i)="" THEN
@blocklook
IF sms<>0 AND sme<>0 THEN
IF virtual=FALSE THEN
arrstrt(i)=c1
arrend(i)=c2
arrlen(i)=c2-c1
arrpath$(i)="MEMORY"
ELSE
arrstrt(i)=INT(c1/flen)
arrend(i)=INT(c2/flen)
arrlen(i)=INT(vmem/flen)
arrpath$(i)=path$
ENDIF
arrsrate(i)=hz
arrloop(i)=sloop
arrtri(i)=sret
IF smpnam$<>"" THEN
arrfn$(i)=smpnam$
ELSE
arrfn$(i)="MEMORY"
ENDIF
i$=RIGHT$("  "+STR$(i),3)+CHR$(0)
@textfeld(coptotxt&,i$,1)
ELSE
g=@rsc_alert(1,"Blockmarkierung fehlt !","OK",1)
ENDIF
ELSE
ALERT 1,"Alle EintrÑge belegt !",1,"OK",g
ENDIF
@setbutton(coptoarr&,0)
RETURN
'
> PROCEDURE arrtristate
.| Glob. Var.: obj#,arrtri1&,z#,arrtri2&,arrtri3&,arrtri4&,tri#,pbz#,nr#
.|     realtime#
.| Felder    : arrtri#()
.| Ruft auf  : rsc_tristate,mousek,arrnrset
.| Aufruf in : do_arrange-1,
IF obj=arrtri1& THEN
z=1
ENDIF
IF obj=arrtri2& THEN
z=2
ENDIF
IF obj=arrtri3& THEN
z=3
ENDIF
IF obj=arrtri4& THEN
z=4
ENDIF
tri=arrtri(pbz*4+z)
@rsc_tristate(nr,obj)
REPEAT
UNTIL @mousek=0
arrtri(pbz*4+z)=tri
IF realtime=TRUE THEN
@arrnrset
ENDIF
RETURN
'
> PROCEDURE arrmidi
.| Glob. Var.: mrkch#,ch#,mrknote#,note#,obj#,arrnote1&,arrch1&,arrmz#
.|     arrnote2&,arrch2&,arrnote3&,arrch3&,arrnote4&,arrch4&,z#,pbz#,ch$
.|     midiwort#,db$
.| Felder    : arrmidi#()
.| Ruft auf  : midi,textfeld
.| Aufruf in : do_arrange-1,
mrkch=ch
mrknote=note
IF obj=arrnote1& OR obj=arrch1& THEN
arrmz=1
ENDIF
IF obj=arrnote2& OR obj=arrch2& THEN
arrmz=2
ENDIF
IF obj=arrnote3& OR obj=arrch3& THEN
arrmz=3
ENDIF
IF obj=arrnote4& OR obj=arrch4& THEN
arrmz=4
ENDIF
z=arrmidi(pbz*4+arrmz)
note=(z AND 255)
ch=INT(z/256)+1
@midi
ch$=RIGHT$(" "+STR$(ch),2)+CHR$(0)
arrmidi(pbz*4+arrmz)=midiwort
IF arrmz=1 THEN
@textfeld(arrch1&,ch$,1)
@textfeld(arrnote1&,db$,1)
ENDIF
IF arrmz=2 THEN
@textfeld(arrch2&,ch$,1)
@textfeld(arrnote2&,db$,1)
ENDIF
IF arrmz=3 THEN
@textfeld(arrch3&,ch$,1)
@textfeld(arrnote3&,db$,1)
ENDIF
IF arrmz=4 THEN
@textfeld(arrch4&,ch$,1)
@textfeld(arrnote4&,db$,1)
ENDIF
ch=mrkch
note=mrknote
RETURN
'
> PROCEDURE arrmidplay
.| Glob. Var.: a#,meml#,b#,memh#,sret#,c#,adm#,ad#,arrmidi&
.| Ruft auf  : wait,analog,maschruf18b,digin,digital,setbutton
.| Aufruf in : do_arrange-1,
@wait
a=meml
b=memh
IF sret=1 THEN
c=a
a=b-4
b=c
ENDIF
adm=ad
IF adm=0 THEN
@analog
ENDIF
IF (sret=0 OR sret=2) AND a<b THEN
@maschruf18b
@digin
ENDIF
IF sret=1 AND a>b THEN
@maschruf18b
@digin
ENDIF
IF adm=0 THEN
@digital
ENDIF
@setbutton(arrmidi&,0)
RETURN
'
> PROCEDURE arrdel
.| Glob. Var.: obj#,arrdel1&,arrdel2&,arrdel3&,arrdel4&,pbz#,a$,a2$,a3$,a4$
.|     tri#,arrsmpr1&,arrch1&,arrnote1&,arrtri1&,arrmem1&,spur1&,hardst1&
.|     harde1&,hardlen1&,arrloop1&,nr#,arrsmpr2&,arrch2&,arrnote2&,arrtri2&
.|     arrmem2&,spur2&,hardst2&,harde2&,hardlen2&,arrloop2&,arrsmpr3&
.|     arrch3&,arrnote3&,arrtri3&,arrmem3&,spur3&,hardst3&,harde3&,hardlen3&
.|     arrloop3&,arrsmpr4&,arrch4&,arrnote4&,arrtri4&,arrmem4&,spur4&
.|     hardst4&,harde4&,hardlen4&,arrloop4&,realtime#
.| Felder    : arrfn$(),arrpath$(),arrstrt#(),arrend#(),arrlen#(),arrloop#()
.|     arrtri#(),arrsrate#()
.| Ruft auf  : textfeld,setbutton,rsc_tristate2,arrnrset
.| Aufruf in : do_arrange-1,
LOCAL z
IF obj=arrdel1& THEN
z=1
ENDIF
IF obj=arrdel2& THEN
z=2
ENDIF
IF obj=arrdel3& THEN
z=3
ENDIF
IF obj=arrdel4& THEN
z=4
ENDIF
arrfn$(pbz*4+z)=""
arrpath$(pbz*4+z)=""
arrstrt(pbz*4+z)=0
arrend(pbz*4+z)=0
arrlen(pbz*4+z)=0
arrloop(pbz*4+z)=0
arrtri(pbz*4+z)=0
arrsrate(pbz*4+z)=0
a$="            "+CHR$(0)
a2$="00:00:00 00"+CHR$(0)
a3$=" "+CHR$(0)
a4$=SPACE$(4)+CHR$(0)
tri=0
IF z=1 THEN
@textfeld(arrsmpr1&,a4$,1)
@setbutton(arrch1&,0)
@setbutton(arrnote1&,0)
@setbutton(arrtri1&,0)
@textfeld(arrmem1&,a3$,1)
@textfeld(spur1&,a$,1)
@textfeld(hardst1&,a2$,1)
@textfeld(harde1&,a2$,1)
@textfeld(hardlen1&,a2$,1)
@setbutton(arrloop1&,0)
@rsc_tristate2(nr,arrtri1&)
ENDIF
IF z=2 THEN
@textfeld(arrsmpr2&,a4$,1)
@setbutton(arrch2&,0)
@setbutton(arrnote2&,0)
@setbutton(arrtri2&,0)
@textfeld(arrmem2&,a3$,1)
@textfeld(spur2&,a$,1)
@textfeld(hardst2&,a2$,1)
@textfeld(harde2&,a2$,1)
@textfeld(hardlen2&,a2$,1)
@setbutton(arrloop2&,0)
@rsc_tristate2(nr,arrtri2&)
ENDIF
IF z=3 THEN
@textfeld(arrsmpr3&,a4$,1)
@setbutton(arrch3&,0)
@setbutton(arrnote3&,0)
@setbutton(arrtri3&,0)
@textfeld(arrmem3&,a3$,1)
@textfeld(spur3&,a$,1)
@textfeld(hardst3&,a2$,1)
@textfeld(harde3&,a2$,1)
@textfeld(hardlen3&,a2$,1)
@setbutton(arrloop3&,0)
@rsc_tristate2(nr,arrtri3&)
ENDIF
IF z=4 THEN
@textfeld(arrsmpr4&,a4$,1)
@setbutton(arrch4&,0)
@setbutton(arrnote4&,0)
@setbutton(arrtri4&,0)
@textfeld(arrmem4&,a3$,1)
@textfeld(spur4&,a$,1)
@textfeld(hardst4&,a2$,1)
@textfeld(harde4&,a2$,1)
@textfeld(hardlen4&,a2$,1)
@setbutton(arrloop4&,0)
@rsc_tristate2(nr,arrtri4&)
ENDIF
IF realtime=TRUE THEN
@arrnrset
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE arrinsert
.| Glob. Var.: arrherr#,lmax2#,arrins&
.| Felder    : arrpath$(),arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#()
.| Ruft auf  : busy_mouse,arrnrset,hardwahl,setbutton
.| Aufruf in : do_arrange-1,
LOCAL s,i,a1,a2,g
IF arrherr<>0 THEN
s=arrherr
a1=0
a2=0
IF s<lmax2 THEN
i=lmax2+1
@busy_mouse
REPEAT
DEC i
UNTIL arrpath$(i)<>"" OR i=s
IF arrpath$(i)<>"" THEN
a2=i
ENDIF
IF a2=0 THEN
ALERT 1,"Ist doch genug Platz !",1,"OK",g
ENDIF
IF a2=lmax2 THEN
ALERT 1,"Der letzte Platz ist belegt,|daher kein INSERT mîglich!",1,"OK",g
ENDIF
IF a2<>0 AND a2<>lmax2 THEN
i=s-1
REPEAT
INC i
UNTIL arrpath$(i)<>"" OR i=lmax2
IF arrpath$(i)<>"" THEN
a1=i
ENDIF
FOR i=a2 TO a1 STEP -1
arrpath$(i+1)=arrpath$(i)
arrfn$(i+1)=arrfn$(i)
arrstrt(i+1)=arrstrt(i)
arrend(i+1)=arrend(i)
arrlen(i+1)=arrlen(i)
arrmidi(i+1)=arrmidi(i)
arrloop(i+1)=arrloop(i)
arrtri(i+1)=arrtri(i)
arrsrate(i+1)=arrsrate(i)
NEXT i
arrpath$(a1)=""
arrfn$(a1)=""
arrstrt(a1)=0
arrend(a1)=0
arrlen(a1)=0
arrmidi(a1)=0
arrloop(a1)=0
arrtri(a1)=0
arrsrate(a1)=0
@arrnrset
ENDIF
ENDIF
ELSE
@hardwahl
ENDIF
@setbutton(arrins&,0)
RETURN
'
> PROCEDURE arrdelete
.| Glob. Var.: arrherr#,lmax2#,arrdel&
.| Felder    : arrpath$(),arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#()
.| Ruft auf  : busy_mouse,arrnrset,hardwahl,setbutton
.| Aufruf in : do_arrange-1,
LOCAL s,i,a1,a2
IF arrherr<>0 THEN
s=arrherr
a1=0
a2=0
arrpath$(s)=""
arrfn$(s)=""
arrstrt(s)=0
arrend(s)=0
arrlen(s)=0
arrmidi(s)=0
arrloop(s)=0
arrtri(s)=0
arrsrate(s)=0
IF s<lmax2 THEN
i=s
@busy_mouse
REPEAT
INC i
UNTIL arrpath$(i)<>"" OR i=lmax2
IF arrpath$(i)<>"" THEN
a1=i
ENDIF
IF a1<>0 THEN
i=lmax2+1
REPEAT
DEC i
UNTIL arrpath$(i)<>"" OR i=1
IF arrpath$(i)<>"" THEN
a2=i
ENDIF
FOR i=a1 TO a2
arrpath$(i-1)=arrpath$(i)
arrfn$(i-1)=arrfn$(i)
arrstrt(i-1)=arrstrt(i)
arrend(i-1)=arrend(i)
arrlen(i-1)=arrlen(i)
arrmidi(i-1)=arrmidi(i)
arrloop(i-1)=arrloop(i)
arrtri(i-1)=arrtri(i)
arrsrate(i-1)=arrsrate(i)
NEXT i
arrpath$(a2)=""
arrfn$(a2)=""
arrstrt(a2)=0
arrend(a2)=0
arrlen(a2)=0
arrmidi(a2)=0
arrloop(a2)=0
arrtri(a2)=0
arrsrate(a2)=0
ENDIF
ENDIF
@arrnrset
ELSE
@hardwahl
ENDIF
@setbutton(arrdel&,0)
RETURN
'
> PROCEDURE delaytxt
.| Glob. Var.: dt#,a$
.| Aufruf in : arrdelay-1,delayr-1,delayl-1,
LOCAL b$,a,dtt
dtt=dt
a$=""
b$=""
IF dtt>=360000 THEN
a=INT(dtt/360000)
dtt=dtt-a*360000
a$=STR$(a)
ENDIF
IF LEN(a$)=0 THEN
a$="00"
ENDIF
IF LEN(a$)=1 THEN
a$="0"+a$
ENDIF
IF dtt>=6000 THEN
a=INT(dtt/6000)
dtt=dtt-a*6000
b$=STR$(a)
ENDIF
IF LEN(b$)=0 THEN
b$="00"
ENDIF
IF LEN(b$)=1 THEN
b$="0"+b$
ENDIF
a$=a$+b$
b$=""
IF dtt>=100 THEN
a=INT(dtt/100)
dtt=dtt-a*100
b$=STR$(a)
ENDIF
IF LEN(b$)=0 THEN
b$="00"
ENDIF
IF LEN(b$)=1 THEN
b$="0"+b$
ENDIF
a$=a$+b$
a=INT(dtt)
b$=STR$(a)
IF LEN(b$)=0 THEN
b$="00"
ENDIF
IF LEN(b$)=1 THEN
b$="0"+b$
ENDIF
a$=a$+b$+CHR$(0)
RETURN
'
> PROCEDURE txtdelay
.| Glob. Var.: wandel#,a$,dt#
.| Aufruf in : arrdelay-1,delayr-1,delayl-1,
LOCAL g
wandel=TRUE
IF VAL(MID$(a$,5,2))>59 THEN
wandel=FALSE
ENDIF
IF VAL(MID$(a$,3,2))>59 THEN
wandel=FALSE
ENDIF
IF (VAL(RIGHT$(a$,1)) AND 1)=1 THEN
wandel=FALSE
ENDIF
IF LEN(a$)<>8 THEN
wandel=FALSE
ENDIF
IF wandel=FALSE THEN
ALERT 1,"unkorrekte Eingabe !",1,"OK",g
ELSE
dt=0
dt=VAL(RIGHT$(a$,2))
dt=dt+VAL(MID$(a$,5,2))*100
dt=dt+VAL(MID$(a$,3,2))*6000
dt=dt+VAL(LEFT$(a$,2))*360000
ENDIF
RETURN
'
> PROCEDURE arrdelay
.| Glob. Var.: arrherr#,vornr#,nr#,delay&,deltime#,dt#,a$,delaytim&,obj#
.|     popup&,zu%,zuadr#,edit_obj&,buttadr#,but#,objadr#,objflag#,delayhlp&
.|     delayr&,delayl&,delayex&,delayok&,wandel#,hz#,g#,arrdelay&
.| Felder    : arrpath$(),arrend#(),arrstrt#(),arrlen#(),arrsrate#()
.|     arrfn$()
.| Ruft auf  : rsc_draw,markhlp,delaytxt,editfeld,rsc_do,xrsrc_gaddr,mousek
.|     helptxt,delayr,delayl,setbutton,editread,txtdelay,restaura2,arrnrset
.|     hardwahl
.| Aufruf in : do_arrange-1,
IF arrherr<>0 THEN
IF arrpath$(arrherr)="" OR arrpath$(arrherr)="DELAY" THEN
vornr=nr
nr=delay&
@rsc_draw(nr,0)
@markhlp
IF arrend(arrherr)<>0 THEN
deltime=arrend(arrherr)
ENDIF
dt=deltime
IF deltime=0 THEN
a$="00000000"+CHR$(0)
ELSE
@delaytxt
ENDIF
@editfeld(delaytim&,a$)
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>delaytim&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=delayhlp& THEN
@helptxt("DELAY")
ENDIF
IF obj=delayr& THEN
@delayr
ENDIF
IF obj=delayl& THEN
@delayl
ENDIF
UNTIL obj=delayex& OR obj=delayok&
@setbutton(obj,0)
IF obj=delayok& THEN
@editread(delaytim&)  ! RÅckgabewert in a$
@txtdelay
IF wandel=TRUE THEN
deltime=dt
arrpath$(arrherr)="DELAY"
arrstrt(arrherr)=0
arrend(arrherr)=deltime
arrlen(arrherr)=deltime
arrsrate(arrherr)=hz
IF arrfn$(arrherr)="" THEN
arrfn$(arrherr)="DELAY"
ENDIF
ENDIF
ENDIF
@restaura2
IF obj=delayok& THEN
@arrnrset
ENDIF
obj=0
ELSE
ALERT 1,"Platz ist besetzt !",1,"OK",g
ENDIF
ELSE
@hardwahl
ENDIF
@setbutton(arrdelay&,0)
RETURN
'
> PROCEDURE hardwahl
.| Aufruf in : arrinsert-1,arrdelete-1,arrdelay-1,
LOCAL g
ALERT 1,"Zuerst Platz auswÑhlen !",1,"OK",g
RETURN
'
> PROCEDURE delayr
.| Glob. Var.: delaytim&,wandel#,dt#,a$,delayr&
.| Ruft auf  : editread,txtdelay,delaytxt,editfeld,setbutton
.| Aufruf in : arrdelay-1,
@editread(delaytim&)  ! RÅckgabewert in a$
@txtdelay
IF wandel=TRUE THEN
IF dt<35999999 THEN
dt=dt+2
@delaytxt
@editfeld(delaytim&,a$)
ENDIF
ENDIF
@setbutton(delayr&,0)
RETURN
'
> PROCEDURE delayl
.| Glob. Var.: delaytim&,wandel#,dt#,a$,delayl&
.| Ruft auf  : editread,txtdelay,delaytxt,editfeld,setbutton
.| Aufruf in : arrdelay-1,
@editread(delaytim&)  ! RÅckgabewert in a$
@txtdelay
IF wandel=TRUE THEN
IF dt>0 THEN
dt=dt-2
@delaytxt
@editfeld(delaytim&,a$)
ENDIF
ENDIF
@setbutton(delayl&,0)
RETURN
'
> PROCEDURE arrmname
.| Glob. Var.: mrkobj#,obj#,vorvornr#,vornr#,nr#,arrmname&,pbz#,hardtype#,a$
.|     mp$,a#,memname&,popup&,zu%,zuadr#,x#,y#,v3#,edit_obj&,buttadr#,but#
.|     objadr#,objflag#,amhelp&,amexit&,amok&,spur1&,spur2&,spur3&,spur4&
.| Felder    : arrfn$()
.| Ruft auf  : rsc_draw,markhlp,editfeld,rsc_do,xrsrc_gaddr,mouse,helptxt
.|     editread,setbutton,restaura2,textfeld
.| Aufruf in : trakload-1,hardfs-1,
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=arrmname&
@rsc_draw(nr,0)
@markhlp
IF arrfn$(pbz*4+hardtype)="MEMORY" THEN
a$=mp$+CHR$(0)
a=INSTR(a$,".")
IF a>1 THEN
a$=LEFT$(a$,a-1)+CHR$(0)
ENDIF
ELSE
a$=arrfn$(pbz*4+hardtype)+CHR$(0)
ENDIF
IF LEN(a$)>12 THEN
a$=LEFT$(a$,12)
ENDIF
@editfeld(memname&,a$)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1 AND obj<>memname&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=amhelp& THEN
@helptxt("ARRANGE-NAME Ñndern")
ENDIF
UNTIL obj=amexit& OR obj=amok&
IF obj=amok& THEN
editread(memname&)
arrfn$(pbz*4+hardtype)=a$
ENDIF
@setbutton(obj,0)
@restaura2
IF obj=amok& THEN
a$=LEFT$(arrfn$(pbz*4+hardtype)+"            ",12)+CHR$(0)
IF hardtype=1 THEN
@textfeld(spur1&,a$,1)
ENDIF
IF hardtype=2 THEN
@textfeld(spur2&,a$,1)
ENDIF
IF hardtype=3 THEN
@textfeld(spur3&,a$,1)
ENDIF
IF hardtype=4 THEN
@textfeld(spur4&,a$,1)
ENDIF
ENDIF
obj=mrkobj
vornr=vorvornr
RETURN
'
> PROCEDURE arrloop
.| Glob. Var.: obj#,arrloop1&,z#,arrloop2&,arrloop3&,arrloop4&,pbz#
.| Felder    : arrloop#()
.| Aufruf in : do_arrange-1,
IF obj=arrloop1& THEN
z=1
ENDIF
IF obj=arrloop2& THEN
z=2
ENDIF
IF obj=arrloop3& THEN
z=3
ENDIF
IF obj=arrloop4& THEN
z=4
ENDIF
IF arrloop(pbz*4+z)=0 THEN
arrloop(pbz*4+z)=1
ELSE
arrloop(pbz*4+z)=0
ENDIF
RETURN
'
> PROCEDURE wait
.| Aufruf in : trkplay-1,arrmidplay-1,arrplay-1,smpplay-1,smpauto-2
.|     smpstart-1,
LOCAL v,v2,v3,v4
REPEAT
~WIND_UPDATE(3)
~GRAF_MKSTATE(v,v2,v3,v4)
~WIND_UPDATE(2)
REPEAT
IF INP?(2)=TRUE THEN
~INP(2)
ENDIF
IF INP?(3)=TRUE THEN
~INP(3)
ENDIF
IF INP?(1)=TRUE THEN
~INP(1)
ENDIF
UNTIL INP?(2)=FALSE AND INP?(1)=FALSE AND INP?(3)=FALSE
UNTIL v3=0 AND v4=0
RETURN
'
> PROCEDURE arrplay
.| Glob. Var.: virtual#,g#,vad#,ad#,over#,i#,rpat$,vvhz#,hz#,pat$,vhz#
.|     realtime#,hsec#,playlen&,a$,playname&,t#,aready#,tim#,v3#,a#,back%,l#
.|     meml#,b#,adder#,saa%,sba%,loop#,flen#,pa$,sectors#,sectpos#,handle#
.|     playpos#,lmax2#,b$,arrplay&
.| Felder    : arrpath$(),arrsrate#(),arrstrt#(),arrend#(),arrfn$()
.|     arrtri#(),arrloop#()
.| Ruft auf  : analog,wait,makehz,digout,maschinit2b,maschinit5b,htimeset
.|     textfeld,mousek,swtosrate,maschruf2c,maschruf5c,maschinit2d,digital
.|     setbutton
.| Aufruf in : do_arrange-1,
LOCAL r,akku,j,rr
IF virtual=TRUE THEN
ALERT 1,"Kein PLAY von Memory-Daten !|Wegen virt. Bearbeitung|gesperrt.",1,"OK",g
ENDIF
vad=ad
IF vad=0 THEN
@analog
ENDIF
@wait
over=0
@makehz
@digout(TRUE)
@maschinit2b
@maschinit5b
i=0
j=0
rr=0
akku=0
rpat$=""
vvhz=hz
REPEAT
INC i
pat$=arrpath$(i)
vhz=arrsrate(i)
IF vhz=0 THEN
vhz=44100
ENDIF
IF pat$="DELAY" THEN
IF realtime=FALSE THEN
hsec=arrstrt(i)
ELSE
hsec=INT(akku/vhz/4*100)
akku=akku+arrend(i)*vhz*4/100
ENDIF
@htimeset
@textfeld(playlen&,a$,1)
a$=LEFT$(arrfn$(i)+SPACE$(12),12)
@textfeld(playname&,a$,1)
t=arrend(i)*2
aready=FALSE
tim=TIMER
REPEAT
v3=@mousek
a=TIMER
IF (a-tim)<0 THEN
tim=0
ENDIF
IF (a-tim)>=t THEN
aready=TRUE
ENDIF
UNTIL aready=TRUE OR v3<>0
IF aready=TRUE THEN
back%=0
ELSE
back%=1
ENDIF
ENDIF
IF arrend(i)<>0 AND pat$<>"" AND pat$<>"DELAY" THEN
IF pat$="MEMORY" THEN
r=arrtri(i)
IF realtime=FALSE THEN
IF r=0 OR r=2 THEN
hsec=INT(arrstrt(i)/vhz/4*100)
ENDIF
IF r=1 THEN
hsec=INT(arrend(i)/vhz/4*100)
ENDIF
ELSE
hsec=INT(akku/vhz/4*100)
IF r=2 THEN
akku=akku+(arrend(i)-arrstrt(i))*2
ELSE
akku=akku+arrend(i)-arrstrt(i)
ENDIF
ENDIF
@htimeset
@textfeld(playlen&,a$,1)
a$=LEFT$(arrfn$(i)+SPACE$(12),12)
@textfeld(playname&,a$,1)
IF r=0 OR r=2 THEN
l=arrloop(i)+r
a=arrstrt(i)+meml
b=arrend(i)+meml
adder=0
ENDIF
IF r=1 THEN
l=arrloop(i)
b=arrstrt(i)+meml
a=arrend(i)+meml
adder=-8
ENDIF
IF virtual=FALSE THEN
@swtosrate(vhz)
@digout(TRUE)
saa%=a
sba%=b
@maschruf2c
ELSE
back%=0
ENDIF
ELSE
IF EXIST(pat$) THEN
loop=arrloop(i)
r=arrtri(i)
IF r=0 OR r=2 THEN
IF realtime=FALSE THEN
hsec=INT(arrstrt(i)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
akku=akku+(arrend(i)-arrstrt(i))*flen
IF r=2 THEN
akku=akku+(arrend(i)-arrstrt(i))*flen
ENDIF
ENDIF
@htimeset
@textfeld(playlen&,a$,1)
pa$=pat$+CHR$(0)
a$=LEFT$(arrfn$(i)+SPACE$(12),12)
@textfeld(playname&,a$,1)
sectors=arrend(i)-arrstrt(i)
sectpos=arrstrt(i)
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
playpos=arrstrt(i)*flen
@swtosrate(vhz)
over=0
l=r+loop
@maschruf5c
~GEMDOS(62,handle)
ENDIF
ENDIF
IF r=1 THEN
IF realtime=FALSE THEN
hsec=INT(arrend(i)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
akku=akku+(arrend(i)-arrstrt(i))*flen
ENDIF
@htimeset
@textfeld(playlen&,a$,1)
pa$=pat$+CHR$(0)
a$=LEFT$(arrfn$(i)+SPACE$(12),12)
@textfeld(playname&,a$,1)
sectors=arrend(i)-arrstrt(i)
sectpos=arrend(i)
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
playpos=arrend(i)*flen
l=loop
over=-8
@swtosrate(vhz)
@maschruf5c
~GEMDOS(62,handle)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF pat$<>"" THEN
j=i
rr=r
rpat$=pat$
vvhz=vhz
ENDIF
UNTIL i=lmax2 OR (back%<>sectors AND pat$<>"MEMORY" AND pat$<>"" AND pat$<>"DELAY") OR (back%<>0 AND pat$="DELAY") OR (pat$="MEMORY" AND ((back%<>sba% AND (r=1 OR r=0)) OR (back%<>saa%+4 AND r=2)))
@maschinit2d
vhz=vvhz
@textfeld(playname&,"            "+CHR$(0),1)
IF rpat$="DELAY" AND back%=0 THEN
IF realtime=FALSE THEN
hsec=arrend(j)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF pat$="DELAY" AND back%<>0 THEN
a$="   BREAK   "+CHR$(0)
ENDIF
IF pat$="MEMORY" AND ((r=0 OR r=1) AND back%<>sba%) OR (r=2 AND back%<>saa%+4) THEN
a$="   BREAK   "+CHR$(0)
ENDIF
IF pat$<>"MEMORY" AND pat$<>"DELAY" AND pat$<>"" AND back%<>sectors THEN
IF r=0 THEN
IF realtime=FALSE THEN
hsec=INT((arrstrt(i)+back%)*flen/vhz/4*100)
ELSE
hsec=INT(((akku-((arrend(i)-arrstrt(i))*flen)+(back%*flen)))/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF r=1 THEN
IF realtime=FALSE THEN
hsec=INT((arrend(i)-back%)*flen/vhz/4*100)
ELSE
hsec=INT(((akku-((arrend(i)-arrstrt(i))*flen)+(back%*flen)))/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF r=2 AND back%<>sectors THEN
a$="   BREAK   "+CHR$(0)
ENDIF
ENDIF
IF rpat$<>"" AND rpat$<>"MEMORY" AND rpat$<>"DELAY" THEN
IF rr=0 AND back%=sectors THEN
IF realtime=FALSE THEN
hsec=INT(arrend(j)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=1 AND back%=sectors THEN
IF realtime=FALSE THEN
hsec=INT(arrstrt(j)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=2 AND back%=sectors THEN
IF realtime=FALSE THEN
hsec=INT(arrstrt(j)*flen/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
ENDIF
IF rpat$="MEMORY" THEN
IF rr=0 AND back%=sba% THEN
IF realtime=FALSE THEN
hsec=INT(arrend(j)/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=1 AND back%=sba% THEN
IF realtime=FALSE THEN
hsec=INT(arrstrt(j)/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
IF rr=2 AND back%=saa%+4 THEN
IF b$<>a$ THEN
IF realtime=FALSE THEN
hsec=INT(arrstrt(j)/vhz/4*100)
ELSE
hsec=INT(akku/vhz/4*100)
ENDIF
@htimeset
ENDIF
ENDIF
ENDIF
@textfeld(playlen&,a$,1)
@digout(FALSE)
IF vad=0 THEN
@digital
ENDIF
@setbutton(arrplay&,0)
RETURN
'
> PROCEDURE swtosrate(swhz)
.| Glob. Var.: extclock#
.| Ruft auf  : adlow,admid,adhigh
.| Aufruf in : maschruf18b-3,arrsethz-1,do_arrange-1,do_trakker-1
.|     traksethz-1,trakforw-2,trkbackw-2,trkplay-3,arrplay-3,mforw-2
.|     mbackw-2,make-1,
LOCAL holdhz
holdhz=hz
hz=swhz
@fliphz
@fliphz2
hz=holdhz
RETURN
'
> PROCEDURE hardstrt
.| Glob. Var.: pbz#,arrz#,sectpos#,realtime#,hsec#,flen#,vhz#,hardtype#
.|     hardopen#,hardst1&,a$,hardst2&,hardst3&,hardst4&,hardstrt&
.| Felder    : arrstrt#()
.| Ruft auf  : htimeset,textfeld,arrnrset,setbutton
.| Aufruf in : do_arrange-1,
arrstrt(pbz*4+arrz)=sectpos
IF realtime=FALSE THEN
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
IF hardtype=1 AND hardopen=TRUE THEN
@textfeld(hardst1&,a$,1)
ENDIF
IF hardtype=2 AND hardopen=TRUE THEN
@textfeld(hardst2&,a$,1)
ENDIF
IF hardtype=3 AND hardopen=TRUE THEN
@textfeld(hardst3&,a$,1)
ENDIF
IF hardtype=4 AND hardopen=TRUE THEN
@textfeld(hardst4&,a$,1)
ENDIF
ELSE
@arrnrset
ENDIF
@setbutton(hardstrt&,0)
RETURN
'
> PROCEDURE hardend
.| Glob. Var.: pbz#,arrz#,sectpos#,realtime#,hsec#,flen#,vhz#,hardtype#
.|     hardopen#,harde1&,a$,harde2&,harde3&,harde4&,hardend&
.| Felder    : arrend#()
.| Ruft auf  : htimeset,textfeld,arrnrset,setbutton
.| Aufruf in : do_arrange-1,
arrend(pbz*4+arrz)=sectpos
IF realtime=FALSE THEN
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
IF hardtype=1 AND hardopen=TRUE THEN
@textfeld(harde1&,a$,1)
ENDIF
IF hardtype=2 AND hardopen=TRUE THEN
@textfeld(harde2&,a$,1)
ENDIF
IF hardtype=3 AND hardopen=TRUE THEN
@textfeld(harde3&,a$,1)
ENDIF
IF hardtype=4 AND hardopen=TRUE THEN
@textfeld(harde4&,a$,1)
ENDIF
ELSE
@arrnrset
ENDIF
@setbutton(hardend&,0)
RETURN
'
> PROCEDURE hardfs
.| Glob. Var.: obj#,hardfs1&,hardtype#,hardfs2&,hardfs3&,hardfs4&,pbz#,a$
.|     playlen&,arrherr#,hardopen#,handle#,playstop#,op$,ext$,fil$,nr#
.|     sectors#,f#,flen#,sectall#,sectpos#,hsec#,vhz#,mz$,a4$,spur1&,nam$
.|     hardlen1&,arrmem1&,arrsmpr1&,spur2&,hardlen2&,arrmem2&,arrsmpr2&
.|     spur3&,hardlen3&,arrmem3&,arrsmpr3&,spur4&,hardlen4&,arrmem4&
.|     arrsmpr4&,arrz#,pat$,pa$,playname&
.| Felder    : arrpath$(),arrfn$(),arrlen#(),arrsrate#()
.| Ruft auf  : textfeld,fileselect,rsc_redraw_obj,busy_mouse,ldhead,htimeset
.|     arrnrset,arrmname,setbutton
.| Aufruf in : do_arrange-1,
IF obj=hardfs1& THEN
hardtype=1
ENDIF
IF obj=hardfs2& THEN
hardtype=2
ENDIF
IF obj=hardfs3& THEN
hardtype=3
ENDIF
IF obj=hardfs4& THEN
hardtype=4
ENDIF
IF arrpath$(pbz*4+hardtype)="" THEN
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
IF obj=hardfs1& THEN
arrherr=pbz*4+1
ENDIF
IF obj=hardfs2& THEN
arrherr=pbz*4+2
ENDIF
IF obj=hardfs3& THEN
arrherr=pbz*4+3
ENDIF
IF obj=hardfs4& THEN
arrherr=pbz*4+4
ENDIF
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
@fileselect(op$+"*."+ext$,"","ARRANGE-FILE:")
IF EXIST(fil$) THEN
@busy_mouse
@ldhead
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
sectors=INT(f/flen)
sectall=sectors
sectpos=0
hardopen=TRUE
hsec=INT(sectall*flen/vhz/4*100)
@htimeset
mz$="H"+CHR$(0)
a4$=LEFT$(STR$(INT(vhz/100)/10)+SPACE$(4),4)+CHR$(0)
IF obj=hardfs1& THEN
@textfeld(spur1&,nam$+CHR$(0),1)
@textfeld(hardlen1&,a$,1)
@textfeld(arrmem1&,mz$,1)
@textfeld(arrsmpr1&,a4$,1)
ENDIF
IF obj=hardfs2& THEN
@textfeld(spur2&,nam$+CHR$(0),1)
@textfeld(hardlen2&,a$,1)
@textfeld(arrmem2&,mz$,1)
@textfeld(arrsmpr2&,a4$,1)
ENDIF
IF obj=hardfs3& THEN
@textfeld(spur3&,nam$+CHR$(0),1)
@textfeld(hardlen3&,a$,1)
@textfeld(arrmem3&,mz$,1)
@textfeld(arrsmpr3&,a4$,1)
ENDIF
IF obj=hardfs4& THEN
@textfeld(spur4&,nam$+CHR$(0),1)
@textfeld(hardlen4&,a$,1)
@textfeld(arrmem4&,mz$,1)
@textfeld(arrsmpr4&,a4$,1)
ENDIF
arrz=hardtype
pat$=fil$
pa$=pat$+CHR$(0)
arrpath$(pbz*4+arrz)=fil$+CHR$(0)
arrfn$(pbz*4+arrz)=nam$
arrlen(pbz*4+arrz)=sectall
arrsrate(pbz*4+arrz)=vhz
a$=LEFT$(nam$+SPACE$(12),12)
@textfeld(playname&,a$,1)
@arrnrset
ENDIF
ELSE
@arrmname
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE virtual
.| Glob. Var.: vornr#,nr#,virtual&,vslider&,vslbut&,lslide#,lslideo#,hbg#
.|     hbz#,a$,mt#,vblkmlen&,smplen#,vblkvlen&,vhbldstrt#,tedart#,vseconds&
.|     vsamples&,virtwfile#,virtwork&,virtdir&,obj#,popup&,zu%,zuadr#
.|     vblkstrt&,edit_obj&,next_obj&,buttadr#,but#,objadr#,objflag#,x#,y#
.|     v3#,virthelp&,vlslide&,slflg#,vrslide&,vtedart#,notedok#,virtplay&
.|     handle#,fil$,playpos#,sectors#,hbldlen#,flen#,over#,l#,virtbloc&
.|     virtno&,virtok&,virtex#,blockld#,virtual#
.| Ruft auf  : slidelen,slideinit,rsc_draw,setslide,blockcalc,textfeld
.|     blkart,setbutton,rsc_do,xrsrc_gaddr,mouse,helptxt,slideup,slidedwn
.|     blkproof,maschinit5,digout,maschruf5,restaura2
.| Aufruf in : ldhlp-1,
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
vornr=nr
nr=virtual&
@slidelen2(vslider&,vslbut&,lslide)
hbreit=(lslide/smplen*mt)            ! Einteilungsanzahl
@slideinit2(vslider&,vslbut&,hbreit)
@rsc_draw(nr,7)
@setslide2(vslider&,vslbut&,lslide,hbz,hbreit)
@blockcalc
a$=LEFT$("MEM "+STR$(INT(mt/4))+SPACE$(10),14)
@textfeld(vblkmlen&,a$,1)
a$=LEFT$("LEN "+STR$(INT(smplen/4))+SPACE$(10),14)
@textfeld(vblkvlen&,a$,1)
vhbldstrt=0
tedart=1
@blkart
IF tedart=0 THEN
@setbutton(vseconds&,1)
@setbutton(vsamples&,0)
ELSE
@setbutton(vsamples&,1)
@setbutton(vseconds&,0)
ENDIF
IF virtwfile=TRUE THEN
@setbutton(virtwork&,1)
@setbutton(virtdir&,0)
ELSE
@setbutton(virtwork&,0)
@setbutton(virtdir&,1)
ENDIF
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>vblkstrt&
edit_obj&=0
next_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
@mouse(x,y,v3)
IF obj=virthelp& THEN
@helptxt("VIRTUAL")
ENDIF
IF obj=virtwork& THEN
virtwfile=TRUE
ENDIF
IF obj=virtdir& THEN
virtwfile=FALSE
ENDIF
IF obj=vlslide& THEN
@slideup2(vslider&,vslbut&,lslide,1,hbz,slflg)
IF slflg=TRUE THEN
vhbldstrt=INT((smplen/lslide*hbz)/4)*4
@blkart
ENDIF
@setbutton(vlslide&,0)
ENDIF
IF obj=vrslide& THEN
@slidedwn2(vslider&,vslbut&,lslide,hbreit,1,hbz,slflg)
IF slflg=TRUE THEN
vhbldstrt=INT((smplen/lslide*hbz)/4)*4
@blkart
ENDIF
@setbutton(vrslide&,0)
ENDIF
IF obj=vsamples& THEN
vtedart=1
IF vtedart<>tedart THEN
@blkproof
IF notedok=FALSE THEN
tedart=vtedart
@blkart
ELSE
@setbutton(vseconds&,1)
@setbutton(vsamples&,0)
ENDIF
ENDIF
ENDIF
IF obj=vseconds& THEN
vtedart=0
IF vtedart<>tedart THEN
@blkproof
IF notedok=FALSE THEN
tedart=vtedart
@blkart
ELSE
@setbutton(vseconds&,0)
@setbutton(vsamples&,1)
ENDIF
ENDIF
ENDIF
IF obj=virtplay& THEN
@blkproof
@blockcalc
@maschinit5
handle=GEMDOS(61,L:VARPTR(fil$),0)
IF handle>0 THEN
playpos=vhbldstrt
sectors=INT(hbldlen/flen)
over=0
@digout(TRUE)
l=0
@maschruf5
@digout(FALSE)
~GEMDOS(62,handle)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
@setbutton(virtplay&,0)
ENDIF
UNTIL obj=virtbloc& OR obj=virtno& OR obj=virtok&
virtex=FALSE
IF obj=virtbloc& THEN
blockld=FALSE
@blkproof
@blockcalc
mt=hbldlen
ELSE
blockld=FALSE
ENDIF
IF obj=virtok& THEN
virtual=TRUE
ELSE
virtual=FALSE
ENDIF
IF obj=virtno& THEN
virtex=TRUE
ENDIF
PAUSE 3
@setbutton(obj,0)
@restaura2
obj=0
RETURN
'
> PROCEDURE blkart
.| Glob. Var.: tedart#,u#,vhbldstrt#,hz#,a$,vblkstrt&
.| Ruft auf  : editfeld
.| Aufruf in : button-2,virtual-5,
IF tedart=0 THEN
u=vhbldstrt/(hz*4)
a$=STR$(u)
ELSE
u=INT(vhbldstrt/4)
a$=STR$(u)
ENDIF
IF LEN(a$)>8 THEN
a$=LEFT$(a$,8)
ENDIF
a$=a$+CHR$(0)
@editfeld(vblkstrt&,a$)
RETURN
'
> PROCEDURE blkproof
.| Glob. Var.: vblkstrt&,notedok#,a$,i#,a#,vhbldstrt#,tedart#,hz#,smplen#,g#
.|     blockld#
.| Ruft auf  : editread
.| Aufruf in : virtual-4,
@editread(vblkstrt&)
notedok=FALSE
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF (a<48 OR a>57) AND a<>46 THEN
notedok=TRUE
ENDIF
IF (i=1 OR i=8) AND a=46 THEN
notedok=TRUE
ENDIF
NEXT i
ELSE
notedok=TRUE
ENDIF
IF notedok=FALSE THEN
vhbldstrt=VAL(a$)
IF tedart=0 THEN
vhbldstrt=vhbldstrt*hz*4
ELSE
vhbldstrt=vhbldstrt*4
ENDIF
vhbldstrt=INT(vhbldstrt/4)*4
IF vhbldstrt<0 OR vhbldstrt>smplen THEN
notedok=TRUE
ALERT 3,"Der Wert ist auûerhalb des|gÅltigen Bereichs !",1,"EXIT",g
ENDIF
ENDIF
IF notedok=FALSE THEN
blockld=TRUE
ENDIF
RETURN
'
> PROCEDURE blockcalc
.| Glob. Var.: hbldlen#,mt#,vhbldstrt#,smplen#,hbg#,hbz#
.| Aufruf in : virtual-3,
hbldlen=INT(mt/4)*4
IF vhbldstrt=0 THEN
vhbldstrt=INT((smplen/lslide*hbz)/4)*4
ENDIF
IF vhbldstrt+hbldlen>smplen THEN
hbldlen=smplen-vhbldstrt
ENDIF
RETURN
'
> PROCEDURE hardproof
.| Glob. Var.: fil$
.| Ruft auf  : rettmem,hardproof2
.| Aufruf in : ldhlp-1,
IF EXIST(fil$)=TRUE THEN
@rettmem
@hardproof2
ENDIF
RETURN
'
> PROCEDURE hardproof2
.| Glob. Var.: fil$,virtpath$,virtln#,stp#,mlen#,xm#,cwerte1#,cwert#
.|     cwertep1#,cwertep2#,cwertem1#,cwertem2#,i#,meml#,werte#,a#,am#
.|     maxcwert#,g#,virtual#,virtcurve#
.| Ruft auf  : busy_mouse,maschinit31,maschruf31,trash
.| Aufruf in : hardproof-1,memtovirt-1,memtovirt2-1,
LOCAL j,z,hl,glen,dh
IF EXIST(fil$)=TRUE THEN
@busy_mouse
virtpath$=fil$
OPEN "I",#1,fil$
virtln=LOF(#1)
hl=virtln-2
@maschinit31
stp=(INT(mlen/xm))
stp=(INT((stp+1)/4)*4)
z=INT(hl/stp+stp)
IF cwerte1>0 THEN
~MFREE(cwert)
ENDIF
cwerte1=MALLOC((z+xm)*16)
IF cwerte1>0 THEN
cwert=cwerte1
cwertep1=INT((cwerte1+2)/2)*2
cwertep2=cwerte1+((z+xm)*4)
cwertem1=cwerte1+((z+xm)*8)
cwertem2=cwerte1+((z+xm)*12)
z=0
REPEAT
i=meml
IF hl<=mlen
glen=hl
ELSE
glen=mlen
ENDIF
werte=INT(glen/stp)
IF werte>0 THEN
glen=werte*stp
hl=hl-glen
BGET #1,meml,glen
FOR j=1 TO werte
@maschruf31
@busy_mouse
INC z
IF a>32767 THEN
a=a-65536
ENDIF
LPOKE (cwertep1+z*4),a
LPOKE (cwertem1+z*4),am
i=i+2
@maschruf31
IF a>32767 THEN
a=a-65536
ENDIF
LPOKE (cwertep2+z*4),a
LPOKE (cwertem2+z*4),am
i=i-2
i=i+stp
NEXT j
ENDIF
UNTIL hl<stp
CLOSE #1
maxcwert=z
ELSE
ALERT 3,"Zu wenig Speicher frei !",1,"EXIT",g
virtual=FALSE
virtcurve=FALSE
@trash
ENDIF
ENDIF
RETURN
'
> PROCEDURE hardproof3
.| Glob. Var.: fil$,virtln#
.| Aufruf in : fade_it-1,smpcut-2,virtmove-1,virtcopy-1,virtins-1,mono-1
.|     negate-1,lrchange-1,makenorm-1,makeresmp-1,
OPEN "I",#1,fil$
virtln=LOF(#1)
CLOSE #1
RETURN
'
> PROCEDURE rettmem
.| Glob. Var.: profhz#,hz#,smpnam$,path$,lfw$,a#,virt2$,sector#,vsmpnam$
.|     vpath$,vsmplen#,vhz#,vsblock#,vsloop#,vmamidi#,vsms#,vsme#,vmaster#
.|     vper#,vmrkdatum$,vretime#,vordner$,vorcs#,vorce#,vlz#,vzoomp#
.|     vscrollp#,i#,loopz#,bloopz#,vlmin#,vlma#,vmbs#,virt$,mlen#,meml#
.| Felder    : vloops#(),vloope#(),vbloops#(),vbloope#(),mblocks#()
.|     mblocke#(),mblockp$()
.| Ruft auf  : busy_mouse,nomem
.| Aufruf in : smpkhlp-1,smpmhlp-5,smpihlp-1,hardproof-1,arrload-1
.|     coninsert-1,
@busy_mouse
IF profhz=0 AND hz<>0 THEN
profhz=hz
ENDIF
IF profhz=0 THEN
profhz=44100
ENDIF
IF smpnam$="" THEN
smpnam$="MEMORY.S16"
ENDIF
IF path$="" THEN
path$=lfw$+smpnam$
ENDIF
a=ASC(LEFT$(virt2$,1))-64
IF DFREE(a)>sector THEN
OPEN "O",#4,virt2$
PRINT #4,vsmpnam$
PRINT #4,vpath$
PRINT #4,vsmplen
PRINT #4,vhz
PRINT #4,vsblock
PRINT #4,vsloop
PRINT #4,vmamidi
PRINT #4,vsms
PRINT #4,vsme
PRINT #4,vmaster
PRINT #4,vper
PRINT #4,vmrkdatum$
PRINT #4,vretime
PRINT #4,vordner$
PRINT #4,vorcs
PRINT #4,vorce
PRINT #4,vlz
PRINT #4,vzoomp
PRINT #4,vscrollp
FOR i=1 TO loopz
PRINT #4,vloops(i)
NEXT i
FOR i=1 TO loopz
PRINT #4,vloope(i)
NEXT i
FOR i=1 TO bloopz
PRINT #4,vbloops(i)
PRINT #4,vbloope(i)
NEXT i
PRINT #4,vlmin
PRINT #4,vlma
PRINT #4,vmbs
IF vmbs>0 THEN
FOR i=1 TO vmbs
PRINT #4,mblocks(i)
PRINT #4,mblocke(i)
PRINT #4,mblockp$(i)
NEXT i
ENDIF
CLOSE #4
a=ASC(LEFT$(virt$,1))-64
IF DFREE(a)>=mlen THEN
BSAVE virt$,meml,mlen
ELSE
@nomem
ENDIF
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE getmem
.| Glob. Var.: virt2$,smpnam$,path$,smplen#,hz#,sblock#,sloop#,mamidi#,sms#
.|     sme#,master#,per#,mrkdatum$,retime#,ordner$,cs#,ce#,lz#,zoomp#
.|     scrollp#,i#,loopz#,bloopz#,vlmin#,vlma#,mbs#,zomslide&,zoombutt&
.|     zmax#,scrlslde&,scrolbut&,scmax#,virt$,meml#,cached#
.| Felder    : loops#(),loope#(),bloops#(),bloope#(),mblocks#(),mblocke#()
.|     mblockp$()
.| Ruft auf  : zslidecalc,scrollinit,setslide
.| Aufruf in : trash-2,
LOCAL a
IF EXIST(virt2$)=TRUE THEN
OPEN "I",#1,virt2$
INPUT #1,smpnam$
INPUT #1,path$
INPUT #1,smplen
INPUT #1,hz
INPUT #1,sblock
INPUT #1,sloop
INPUT #1,mamidi
INPUT #1,sms
INPUT #1,sme
INPUT #1,master
INPUT #1,per
INPUT #1,mrkdatum$
INPUT #1,retime
INPUT #1,ordner$
INPUT #1,cs
INPUT #1,ce
@zslidecalc
@scrollinit
INPUT #1,lz
INPUT #1,zoomp
INPUT #1,scrollp
FOR i=1 TO loopz
INPUT #1,loops(i)
NEXT i
FOR i=1 TO loopz
INPUT #1,loope(i)
NEXT i
FOR i=1 TO bloopz
INPUT #1,bloops(i)
INPUT #1,bloope(i)
NEXT i
INPUT #1,vlmin
INPUT #1,vlma
INPUT #1,mbs
IF mbs>0 THEN
FOR i=1 TO mbs
INPUT #1,mblocks(i)
INPUT #1,mblocke(i)
INPUT #1,mblockp$(i)
NEXT i
ENDIF
CLOSE #1
KILL virt2$
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
ENDIF
IF EXIST(virt$)=TRUE THEN
OPEN "I",#1,virt$
a=LOF(#1)
BGET #1,meml,a
CLOSE #1
KILL virt$
cached=FALSE
ENDIF
RETURN
'
> PROCEDURE arrload
.| Glob. Var.: arrup$,lfw$,fil$,pret#,pbutt#,rett#,lmax2#,smpnam$,path$
.|     smplen#,hz#,sblock#,sloop#,sms#,sme#,master#,loopz#,mbs#,mlen#,meml#
.|     cached#,pbz#,arrz#,a$,playlen&,arrload&,obj#
.| Felder    : arrfn$(),arrpath$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#(),loops#(),loope#(),mblocks#()
.|     mblocke#(),mblockp$()
.| Ruft auf  : fileselect,rettmem,busy_mouse,textfeld,arrnrset,setbutton
.| Aufruf in : do_arrange-1,
LOCAL i,a,b,p$,g
g=RINSTR(arrup$,"\")
@fileselect(lfw$+"*."+RIGHT$(arrup$,3),RIGHT$(arrup$,LEN(arrup$)-g),"ARRANGE-LOAD:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
IF EXIST(fil$) THEN
@rettmem
rett=TRUE
@busy_mouse
OPEN "I",#5,fil$
FOR i=1 TO lmax2
INPUT #5,arrfn$(i)
INPUT #5,arrpath$(i)
INPUT #5,arrstrt(i)
INPUT #5,arrend(i)
INPUT #5,arrlen(i)
INPUT #5,arrmidi(i)
INPUT #5,arrloop(i)
INPUT #5,arrtri(i)
INPUT #5,arrsrate(i)
NEXT i
INPUT #5,smpnam$
INPUT #5,path$
INPUT #5,smplen
INPUT #5,hz
INPUT #5,sblock
INPUT #5,sloop
INPUT #5,sms
INPUT #5,sme
INPUT #5,master
FOR i=1 TO loopz
INPUT #5,loops(i)
NEXT i
FOR i=1 TO loopz
INPUT #5,loope(i)
NEXT i
INPUT #5,mbs
IF mbs>0 THEN
FOR i=1 TO mbs
INPUT #5,mblocks(i)
INPUT #5,mblocke(i)
INPUT #5,mblockp$(i)
NEXT i
ENDIF
CLOSE #5
IF mbs>0 THEN
FOR i=1 TO mbs
IF EXIST(mblockp$(i))=TRUE THEN
IF mblocke(i)<=mlen THEN
OPEN "I",#5,mblockp$(i)
a=mblocke(i)-mblocks(i)
b=LOF(#5)
IF a>b THEN
a=b
ENDIF
BGET #5,meml+mblocks(i),a
CLOSE #5
ENDIF
ENDIF
NEXT i
cached=FALSE
ENDIF
pbz=0
arrz=0
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
@arrnrset
ENDIF
ENDIF
@setbutton(arrload&,0)
obj=0
RETURN
'
> PROCEDURE arrsteil
.| Glob. Var.: i#,lmax2#,smpnam$,path$,smplen#,profhz#,sblock#,sloop#,sms#
.|     sme#,master#,loopz#,mbs#
.| Felder    : arrfn$(),arrpath$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#(),loops#(),loope#(),mblocks#()
.|     mblocke#(),mblockp$()
.| Aufruf in : arrsave-1,makeaback-1,
FOR i=1 TO lmax2
PRINT #5,arrfn$(i)
PRINT #5,arrpath$(i)
PRINT #5,arrstrt(i)
PRINT #5,arrend(i)
PRINT #5,arrlen(i)
PRINT #5,arrmidi(i)
PRINT #5,arrloop(i)
PRINT #5,arrtri(i)
PRINT #5,arrsrate(i)
NEXT i
PRINT #5,smpnam$
PRINT #5,path$
PRINT #5,smplen
PRINT #5,profhz
PRINT #5,sblock
PRINT #5,sloop
PRINT #5,sms
PRINT #5,sme
PRINT #5,master
FOR i=1 TO loopz
PRINT #5,loops(i)
NEXT i
FOR i=1 TO loopz
PRINT #5,loope(i)
NEXT i
PRINT #5,mbs
IF mbs>0 THEN
FOR i=1 TO mbs
PRINT #5,mblocks(i)
PRINT #5,mblocke(i)
PRINT #5,mblockp$(i)
NEXT i
ENDIF
RETURN
'
> PROCEDURE arrsave
.| Glob. Var.: virtual#,mbs#,arrup$,lfw$,fil$,pret#,pbutt#,a#,sector#
.|     arrsave&
.| Ruft auf  : busy_mouse,fileselect,arrsteil,nomem,setbutton
.| Aufruf in : do_arrange-1,
LOCAL p$,g,g2
@busy_mouse
IF virtual=TRUE THEN
mbs=0
ENDIF
g=RINSTR(arrup$,"\")
@fileselect(lfw$+"*."+RIGHT$(arrup$,3),RIGHT$(arrup$,LEN(arrup$)-g),"ARRANGE-SAVE:")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+RIGHT$(arrup$,4)
ELSE
IF RIGHT$(fil$,4)<>RIGHT$(arrup$,4) THEN
fil$=LEFT$(fil$,g2)+RIGHT$(arrup$,3)
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=sector THEN
OPEN "O",#5,fil$
@arrsteil
CLOSE #5
ELSE
@nomem
ENDIF
ENDIF
@setbutton(arrsave&,0)
RETURN
'
> PROCEDURE recplay
.| Glob. Var.: recplay&
.| Ruft auf  : setbutton
.| Aufruf in : do_arrange-1,
@setbutton(recplay&,0)
RETURN
'
> PROCEDURE mpause
.| Glob. Var.: pause&
.| Ruft auf  : setbutton
.| Aufruf in : do_arrange-1,
IF XBIOS(500)=&H71273800 AND intplay=TRUE THEN
IF mpause=FALSE THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
mpause=TRUE
ELSE
IF demo=FALSE THEN
@write_int(1)
ENDIF
mpause=FALSE
ENDIF
ELSE
@setbutton(pause&,0)
ENDIF
RETURN
'
> PROCEDURE mstop
.| Glob. Var.: handle#,playstop#,hardopen#,a$,playname&,stop&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : do_arrange-1,
~GEMDOS(62,handle)
IF XBIOS(500)<>&H71273800 OR oldplay=TRUE THEN
playstop=1
@mstop2
ELSE
INC mstop
IF mstop>1 THEN
playstop=1
@mstop2
ELSE
'      playstop=2
IF XBIOS(500)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
intplay=FALSE
ENDIF
ENDIF
ENDIF
@setbutton(stop&,0)
RETURN
'
> PROCEDURE mstop2
handle=0
hardopen=FALSE
a$=SPACE$(12)
@textfeld(playname&,a$,1)
IF XBIOS(500)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
@digout(FALSE)
intplay=FALSE
ENDIF
RETURN
'
> PROCEDURE mforw
.| Glob. Var.: pbz#,arrz#,pa$,playstop#,hardopen#,handle#,vhz#,sectall#
.|     sectpos#,sectors#,l#,playpos#,flen#,back%,hsec#,playlen&,a$,nr#
.| Felder    : arrpath$()
.| Ruft auf  : arrsethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_arrange-2,
mstop=0
IF arrpath$(pbz*4+arrz)<>"" AND pa$<>"" THEN
@arrsethz
@maschinit5
IF playstop=2 AND hardopen=TRUE THEN
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
IF sectall>sectpos THEN
sectors=sectall-sectpos
l=0
playpos=sectpos*flen
IF over<>0 THEN
oldplay=TRUE
ENDIF
@maschruf5
IF over<>0 THEN
oldplay=FALSE
ENDIF
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
ENDIF
IF XBIOS(500)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
playpos=sectpos*flen
sectors=sectall-sectpos
l=0
playpos=sectpos*flen
IF over<>0 THEN
oldplay=TRUE
ENDIF
@maschruf5
IF over<>0 THEN
oldplay=FALSE
ENDIF
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
IF XBIOS(500)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
IF vhz>0 THEN
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE mbackw
.| Glob. Var.: pbz#,arrz#,pa$,playstop#,hardopen#,vhz#,sectpos#,sectors#,l#
.|     playpos#,flen#,back%,handle#,sectall#,hsec#,playlen&,a$,nr#
.| Felder    : arrpath$()
.| Ruft auf  : arrsethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_arrange-2,
mstop=0
'  IF over<>-8 THEN
oldplay=TRUE
' ENDIF
IF arrpath$(pbz*4+arrz)<>"" AND pa$<>"" THEN
@arrsethz
@maschinit5
IF playstop=2 AND hardopen=TRUE THEN
@digout(TRUE)
@swtosrate(vhz)
IF sectpos>0 THEN
sectors=sectpos
l=0
playpos=sectpos*flen
@maschruf5
IF sectpos>0 THEN
sectpos=sectpos-back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
ENDIF
IF XBIOS(500)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF sectpos=0 THEN
sectpos=sectall
ENDIF
playpos=sectpos*flen
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
sectors=sectpos
l=0
playpos=sectpos*flen
@maschruf5
IF sectpos>0 THEN
sectpos=sectpos-back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
IF XBIOS(500)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
hsec=INT(sectpos*flen/vhz/4*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
IF over<>-8 THEN
oldplay=FALSE
ENDIF
RETURN
'
> PROCEDURE htimeset
LOCAL a,b,h$
hh=INT(hsec/100/60/60)
hrest=hsec-(hh*100*60*60)
hm=INT(hrest/100/60)
hrest=hrest-(hm*100*60)
hs=INT(hrest/100)
hms=hrest-(hs*100)
IF hh<10 THEN
a$=CHR$(16)+CHR$(hh+16)+":"
ELSE
h$=STR$(hh)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=CHR$(a)+CHR$(b)+":"
ENDIF
IF hm<10 THEN
a$=a$+CHR$(16)+CHR$(hm+16)+":"
ELSE
h$=STR$(hm)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=a$+CHR$(a)+CHR$(b)+":"
ENDIF
IF hs<10 THEN
a$=a$+CHR$(16)+CHR$(hs+16)+" "
ELSE
h$=STR$(hs)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=a$+CHR$(a)+CHR$(b)+" "
ENDIF
IF hms<10 THEN
a$=a$+CHR$(16)+CHR$(hms+16)+CHR$(0)
ELSE
h$=STR$(hms)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=a$+CHR$(a)+CHR$(b)+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE htimeset2
.| Glob. Var.: hh#,hsec#,hrest#,hm#,hs#,hms#,a$
.| Aufruf in : maschruf2-1,maschruf3-2,maschruf3b-2,maschruf5-1
.|     maschruf5c-1,maschruf8b-2,arrnrset-9,trakload-1,trakforw-2
.|     trkbackw-2,trkstrt-1,trkend-1,trkanf-2,trkfull-2,trkplay-13
.|     opentrk-5,arrstrt-2,arrend-2,arrtowork-1,arrplay-13,hardstrt-1
.|     hardend-1,hardfs-1,mforw-2,mbackw-2,
hh=INT(hsec/100/60/60)
hrest=hsec-(hh*100*60*60)
hm=INT(hrest/100/60)
hrest=hrest-(hm*100*60)
hs=INT(hrest/100)
hms=hrest-(hs*100)
IF hh<10 THEN
a$="0"+STR$(hh)+":"
ab$="0"+STR$(hh)
ELSE
a$=STR$(hh)+":"
ab$=STR$(hh)
ENDIF
IF hm<10 THEN
a$=a$+"0"+STR$(hm)+":"
ab$=ab$+"0"+STR$(hm)
ELSE
a$=a$+STR$(hm)+":"
ab$=ab$+STR$(hm)
ENDIF
IF hs<10 THEN
a$=a$+"0"+STR$(hs)+" "
ab$=ab$+"0"+STR$(hs)+CHR$(0)
ELSE
a$=a$+STR$(hs)+" "
ab$=ab$+STR$(hs)+CHR$(0)
ENDIF
IF hms<10 THEN
a$=a$+"0"+STR$(hms)+CHR$(0)
ELSE
a$=a$+STR$(hms)+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE zoomcalc
.| Glob. Var.: xm#,vmem#,zmax#,zoomp#,ce#,cs#,nr#,smpedit&,scrolm#,cached#
.| Ruft auf  : makepnt,restaura
.| Aufruf in : button-2,do_smpedit-2,
LOCAL grenz,stufen,dazu
grenz=xm/2
stufen=LOG(vmem-grenz)/zmax
dazu=INT((EXP(stufen*(zmax-zoomp))+grenz)/4)*4
ce=INT((cs+dazu)/4)*4
IF ce>vmem THEN
cs=INT((vmem-dazu)/4)*4
ce=vmem
ENDIF
IF cs<0 THEN
cs=0
ENDIF
IF nr=smpedit& THEN
@makepnt
ENDIF
scrolm=ce-cs
cached=FALSE
@restaura
RETURN
'
> PROCEDURE zslidecalc
.| Glob. Var.: xm#,vmem#,zmax#,ce#,cs#,zoomp#,nr#,smpedit&,zomslide&
.|     zoombutt&,a$
.| Ruft auf  : setslide,textbutt,makepnt
.| Aufruf in : zoomhelp-1,smpl-1,smpr-1,rubbermax-1,ldhlp-1,getmem-1
.|     smpedit-1,do_smpedit-2,trash-1,
LOCAL grenz,stufen
grenz=xm/2
IF vmem-grenz>0 THEN
stufen=LOG(vmem-grenz)/zmax
IF ((ce-cs)-grenz)>0 THEN
zoomp=zmax-ROUND((LOG((ce-cs)-grenz))/stufen)
ELSE
zoomp=zmax-1
ENDIF
ELSE
zoomp=0
ENDIF
IF zoomp>zmax-1 THEN
zoomp=zmax-1
ENDIF
IF nr=smpedit& THEN
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@makepnt
ENDIF
RETURN
'
> PROCEDURE maketime
.| Glob. Var.: uhr#,tim$,nr#,smpedit&,clock&,aback#,btim$,btime#
.| Ruft auf  : textfeld,makeaback
.| Aufruf in : rsc_do-1,windows-1,smpedit-1,markhandler-1,
LOCAL a,b,c,d
IF uhr=TRUE THEN
IF tim$<>TIME$ THEN
tim$=TIME$
IF nr=smpedit& THEN
@textfeld(clock&,TIME$,1)
ENDIF
IF aback=TRUE THEN
a=VAL(MID$(tim$,4,2))
b=VAL(MID$(btim$,4,2))
c=VAL(RIGHT$(tim$,2))
d=VAL(RIGHT$(btim$,2))
IF a<b THEN
a=a+60
ENDIF
IF c<d THEN
c=c+60
b=b+1
ENDIF
b=a-b
c=c-d
IF (b*60+c)>=btime*60 THEN
@makeaback
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE makepnt
.| Glob. Var.: nr#,smpedit&,pnt#,ce#,cs#,xm#,pntc#,a$,pntprsmp&
.| Ruft auf  : textfeld
.| Aufruf in : zoomcalc-1,zslidecalc-1,smpedit-1,do_smpedit-2,
IF nr=smpedit& THEN
pnt=INT((ce-cs)/4)
IF pnt>0 THEN
IF pnt<=xm THEN
pntc=xm/pnt
pntc=INT(pntc*10)/10
a$=STR$(pntc)
IF LEN(a$)>7 THEN
a$=LEFT$(a$,7)
ENDIF
a$=a$+":1"
ELSE
pntc=INT(pnt/xm)
a$="1:"+STR$(pntc)
IF LEN(a$)>9 THEN
a$=LEFT$(a$,9)
ENDIF
ENDIF
a$=a$+CHR$(0)
@textfeld(pntprsmp&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE abackup
.| Glob. Var.: vornr#,nr#,abackup&,winh#,menuda#,a$,btime#,abacktxt&,aback#
.|     aback&,abacknam#,abacknam&,vbtime#,vaback#,vaback2#,vabacknam#,obj#
.|     popup&,zu%,zuadr#,buttadr#,but#,objadr#,objflag#,abackhlp&,abackr1&
.|     abackr2&,abackl1&,abackl2&,abackex&,abackok&,tim$,btim$,clock&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,textfeld,setbutton,rsc_do
.|     xrsrc_gaddr,mousek,helptxt,setaback,abacknam,abackr,abackl,restaura2
.| Aufruf in : do_smpedit-1,
vornr=nr
nr=abackup&
IF BTST(winh,nr)=FALSE THEN
@rsc_draw(nr,0)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
a$=RIGHT$("00"+STR$(btime),2)+CHR$(0)
@textfeld(abacktxt&,a$,1)
IF aback=TRUE THEN
@setbutton(aback&,1)
ELSE
@setbutton(aback&,0)
ENDIF
IF abacknam=TRUE THEN
@setbutton(abacknam&,1)
ELSE
@setbutton(abacknam&,0)
ENDIF
vbtime=btime
vaback=aback
vaback2=aback
vabacknam=abacknam
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=abackhlp& THEN
@helptxt("AUTO-BACKUP")
ENDIF
IF obj=aback& THEN
@setaback
ENDIF
IF obj=abacknam& THEN
@abacknam
ENDIF
IF obj=abackr1& OR obj=abackr2& THEN
@abackr
ENDIF
IF obj=abackl1& OR obj=abackl2& THEN
@abackl
ENDIF
UNTIL obj=abackex& OR obj=abackok&
@setbutton(obj,0)
IF obj=abackex& THEN
btime=vbtime
aback=vaback
abacknam=vabacknam
ELSE
tim$=TIME$
btim$=TIME$
aback=vaback2
ENDIF
winh=BCLR(winh,abackup&)
@restaura2
IF aback=FALSE THEN
@setbutton(clock&,0)
ELSE
@setbutton(clock&,1)
ENDIF
obj=0
RETURN
'
> PROCEDURE setaback
.| Glob. Var.: vaback2#
.| Aufruf in : abackup-1,
IF vaback2=FALSE THEN
vaback2=TRUE
ELSE
vaback2=FALSE
ENDIF
RETURN
'
> PROCEDURE abacknam
.| Glob. Var.: abacknam#
.| Aufruf in : abackup-1,
IF abacknam=FALSE THEN
abacknam=TRUE
ELSE
abacknam=FALSE
ENDIF
RETURN
'
> PROCEDURE abackr
.| Glob. Var.: obj#,abackr1&,x#,btime#,a$,abacktxt&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : abackup-1,
IF obj=abackr1& THEN
x=1
ELSE
x=5
ENDIF
IF btime<(61-x) THEN
btime=btime+x
a$=RIGHT$("00"+STR$(btime),2)+CHR$(0)
@textfeld(abacktxt&,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE abackl
.| Glob. Var.: obj#,abackl1&,x#,btime#,a$,abacktxt&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : abackup-1,
IF obj=abackl1& THEN
x=1
ELSE
x=5
ENDIF
IF btime>x THEN
btime=btime-x
a$=RIGHT$("00"+STR$(btime),2)+CHR$(0)
@textfeld(abacktxt&,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE write(w$,zeile)
.| Glob. Var.: xd#,yd#
.| Ruft auf  : markhlp
.| Aufruf in : makeaback-4,
LOCAL ready,v
ready=FALSE
REPEAT
'    IF mrkhandle=mrkhandle2 THEN
'    v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
'    IF v<>0 AND kenn=mrkhandle2 THEN
@markhlp
~GRAF_MOUSE(256,0)                              ! Hidem
~WIND_UPDATE(1)                                    ! BEG_UPDATE
GRAPHMODE 2
TEXT xd+10,yd+24+zeile*8,w$
GRAPHMODE 1
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~GRAF_MOUSE(257,0)                              ! Showm
ready=TRUE
'  ENDIF
'  ENDIF
UNTIL ready=TRUE
RETURN
'
> PROCEDURE makeaback
.| Glob. Var.: mrkobj#,obj#,vvorvornr#,vorvornr#,vornr#,nr#,inftxt&,winh#
.|     menuda#,btim$,mbs#,path$,ext2$,abacknam#,a$,lfw$,aback$,virtual#,a#
.|     mlen#,meml#,arp$,aback2$,sector#
.| Felder    : mblockp$()
.| Ruft auf  : rsc_draw,rsc_menu_ienable,write,arrsteil,restaura2
.| Aufruf in : maketime-1,
LOCAL b$
mrkobj=obj
vvorvornr=vorvornr
vorvornr=vornr
vornr=nr
nr=inftxt&
IF BTST(winh,nr)=FALSE THEN
@rsc_draw(nr,5)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
btim$=TIME$
IF mbs>0 THEN
b$=mblockp$(mbs)
ELSE
b$=path$
ENDIF
IF b$="" OR INSTR(b$,":")=0 OR INSTR(b$,"\")=0 THEN
b$="MEMORY."+ext2$
ENDIF
IF abacknam=TRUE THEN
a$=b$
IF EXIST(a$)=FALSE THEN
a$=lfw$+aback$
ENDIF
ELSE
a$=lfw$+aback$
ENDIF
IF virtual=FALSE THEN
a=ASC(LEFT$(a$,1))-64
IF DFREE(a)>=mlen THEN
b$=a$
IF LEN(b$)>40 THEN
b$="..."+RIGHT$(b$,40-3)
ENDIF
@write("MEM-Backup:   "+b$,5)
IF abacknam=TRUE AND EXIST(a$)=TRUE THEN
OPEN "U",#5,a$
ELSE
OPEN "O",#5,a$
ENDIF
BPUT #5,meml,mlen
CLOSE #5
ELSE
@write("No MEM-Backup -> no diskspace !!!",5)
PAUSE 50
ENDIF
ENDIF
IF abacknam=TRUE THEN
a$=arp$
IF a$="" THEN
a$=aback2$
ENDIF
IF EXIST(a$)=FALSE THEN
a$=aback2$
ENDIF
ELSE
a$=aback2$
ENDIF
a=ASC(LEFT$(a$,1))-64
IF DFREE(a)>=sector THEN
b$=a$
IF LEN(b$)>40 THEN
b$="..."+RIGHT$(b$,40-3)
ENDIF
@write("ARR-Backup:   "+b$,6)
IF abacknam=TRUE AND EXIST(a$)=TRUE THEN
OPEN "U",#5,a$
ELSE
OPEN "O",#5,a$
ENDIF
@arrsteil
CLOSE #5
ELSE
@write("No ARR-Backup -> no diskspace !!!",6)
PAUSE 50
ENDIF
winh=BCLR(winh,inftxt&)
@restaura2
obj=0
vornr=vorvornr
vorvornr=vvorvornr
RETURN
'
> PROCEDURE sethertz
.| Glob. Var.: extclock#,nr#,smpedit&,hz#,a$,popups&,rate32&,rate&,rate44&
.|     rate48&,smp16&,ad32&,rate2&,ad44&,ad48&
.| Ruft auf  : textfeld,adlow,admid,adhigh,fliphz
.| Aufruf in : edhandler3-3,smpedit-1,setupdat-1,setup2-1,smpauto-1
.|     smpstart-1,edhandler-3,
@fliphz
@fliphz2
RETURN
'
> PROCEDURE smpedit
.| Glob. Var.: nr#,smpedit&,obj#,menuda#,winh#,freez#,i#,info&,blkfunc&
.|     smp16&,peak&,arranger&,trakker&,loop&,editfade&,cs#,ce#,vmem#,lz#
.|     ldlen#,cutp#,blks#,fadericht#,admrk#,ad#,max#,zomslide&,zoombutt&
.|     zmax#,zoomp#,scrlslde&,scrolbut&,scmax#,scrollp#,a$,aback#,clock&
.|     freemem&,popups&,smpmark&,mover&,ch#,note#,midiwort#,min$,min#
.|     mintext&,mamidi#,midi&,sms#,sme#,okmark#,lded#,datx#,sblock#
.|     smppmark&,mrcs#,mrce#,mrzoom#,mrscroll#,away#,gohome#
.| Ruft auf  : rsc_menu_ienable,setup,info,blkfunc,main,peak,arranger
.|     trakker,loopwahl,fade,rsc_draw,setup2,winbuttset,zslidecalc
.|     scrollinit,writeyproz,makepnt,setslide,textbutt,markhlp,setbutton
.|     textfeld,markhlp3,makehz,sethertz,markdel,clsed,fnamwrite,curve
.|     markprod3,maketime,windows
.| Aufruf in : HAUPTPROGRAMM-1,
nr=smpedit&
obj=0
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
@setup
winh=BSET(winh,nr)
'
IF freez=TRUE THEN
FOR i=31 TO 0 STEP -1
obj=0
IF BTST(winh,i)=TRUE AND i<>smpedit& THEN
IF i=info& THEN
winh=BCLR(winh,i)
@info
ENDIF
IF i=blkfunc& THEN
winh=BCLR(winh,i)
@blkfunc
ENDIF
IF i=smp16& THEN
winh=BCLR(winh,i)
@main
ENDIF
IF i=peak& THEN
winh=BCLR(winh,i)
@peak
ENDIF
IF i=arranger& THEN
winh=BCLR(winh,i)
@arranger
ENDIF
IF i=trakker& THEN
winh=BCLR(winh,i)
@trakker
ENDIF
IF i=loop& THEN
winh=BCLR(winh,i)
@loopwahl
ENDIF
IF i=editfade& THEN
winh=BCLR(winh,i)
@fade
ENDIF
ENDIF
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
NEXT i
ENDIF
nr=smpedit&
@rsc_draw(nr,7)
@setup2
@write_int(0)
@winbuttset
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
'
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
'
cs=0
ce=vmem
lz=1
ldlen=0
cutp=0
blks=0
admrk=ad
@zslidecalc
@scrollinit
max=32767
@writeyproz
@makepnt
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@markhlp
IF aback=TRUE THEN
@setbutton(clock&,1)
ENDIF
a$="FRE "+STR$(FRE())+CHR$(0)
@textfeld(freemem&,a$,1)
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
@markhlp3(9998,cs)
@markhlp3(9999,ce)
midiwort=(ch-1)*256+note
@makehz
@sethertz
@minwrite
@sourcein
IF mamidi=0 THEN
@setbutton(midi&,0)
ELSE
@setbutton(midi&,1)
ENDIF
IF sms<>0 AND sme<>0 THEN
okmark=1
ENDIF
IF lded=0 AND okmark=0 THEN
@markdel
@clsed
ELSE
IF DPEEK(datx)=&HF07E OR okmark=1 THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ELSE
@markdel
@clsed
ENDIF
@fnamwrite
ENDIF
@curve(cs,ce)
IF (lded=1 AND DPEEK(datx)=&HF07E) OR okmark=1 THEN
@markprod3
ENDIF
@maketime
mrcs=cs
mrce=ce
mrzoom=zoomp
mrscroll=scrollp
IF away=FALSE THEN
IF gohome=FALSE THEN
@windows
ENDIF
ENDIF
RETURN
'
> PROCEDURE do_smpedit
.| Glob. Var.: smpedit&,zu%,buttadr#,obj#,but#,rate&,digana#,a$,popups&
.|     smppopup&,popup&,mover&,popmark&,smpl1&,smpl2&,smpl3&,smpr1&,smpr2&
.|     smpr3&,objflag#,zuadr#,smpcblk&,pixzoom&,ce#,cs#,xm#,vmem#,zomslide&
.|     zoombutt&,zmax#,zoomp#,scrlslde&,scrolbut&,scmax#,scrollp#,cached#
.|     zooml&,slflg#,zoomr&,lscroll&,scslc#,scteil#,scrolm#,rscroll&,a#
.|     swdsp&,smplen&,smpsec&,blocfunc&,smpfile&,clock&,trak&,smpanf&
.|     smpend&,smpmid&,smpload&,smpsta&,smpstb&,smpstc&,smpstd&,smpste&
.|     smpea&,smpeb&,smpec&,smped&,smpee&,smpsave&,smpplay&,smppmark&
.|     smploop&,peaksw2&,hard&,virtual#,blkstore&,loopart&,loopauto&,edmidi&
.|     edfade&,midi&,smpsavl&,smpsavr&,smpauto2&,smpstrt2&,monitor&,arrange&
.|     setuper&,edsmp16&,infoicon&,trash&,coptoarr&,smptsa&,smptsb&,smptsc&
.|     smptsd&,smptse&,smptsava&,smptea&,smpteb&,smptec&,smpted&,smptee&
.|     smptsavb&,cstxt&,cetxt&,smpedhlp&,smpexit&,mrce#,mrcs#,mrzoom#
.|     mrscroll#
.| Ruft auf  : xrsrc_gaddr,textfeld,adlow,fnamwrite,admid,adhigh,ext32l
.|     ext44l,ext48l,ext32h,ext44h,ext48h,ext256,ext384,smpmark,smpzoom
.|     smpscrol,smpkopie,smpmove,smpinsert,smpmerge,makefade,setbutton,smpl
.|     smpr,smpcblkplay,zslidecalc,setslide,makepnt,scrollinit,restaura
.|     slideup,textbutt,zoomcalc,slidedwn,dspwahl,smplen,smpsec,blkfunc
.|     smpinfbutt,abackup,trakker,smpanf,smpend,smpmid,smpload,smpstx,smpex
.|     smpsave,smpplay,smppmark,smploop,peak,harddisk,blkstore,loopwahl
.|     loopauto,midi,fade,machmidi,smpsts,smpes,smpauto,smpstart,monitor
.|     arranger,setupdat,main,info,trash,copytoarr,time_edit,helptxt
.| Aufruf in : windows-1,
~@xrsrc_gaddr(0,smpedit&,zu%)
buttadr=zu%+24*obj
but=(DPEEK(buttadr+6)) AND 255
IF but=22 THEN
IF obj=rate& AND digana=TRUE THEN
a$=@rsc_text$(popups&,smppopup&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@adlow
@fnamwrite
ENDIF
IF popup&=2 THEN
@admid
@fnamwrite
ENDIF
IF popup&=3 THEN
@adhigh
@fnamwrite
ENDIF
IF popup&=4 THEN
@ad8
@fnamwrite
ENDIF
IF popup&=5 THEN
@ad11
@fnamwrite
ENDIF
IF popup&=6 THEN
@ad12
@fnamwrite
ENDIF
IF popup&=7 THEN
@ad16
@fnamwrite
ENDIF
IF popup&=8 THEN
@ad17
@fnamwrite
ENDIF
IF popup&=9 THEN
@ad22
@fnamwrite
ENDIF
IF popup&=10 THEN
@ad24
@fnamwrite
ENDIF
IF popup&=11 THEN
@ad33
@fnamwrite
ENDIF
IF popup&=12 THEN
@adexth2
@fnamwrite
ENDIF
IF popup&=13 THEN
@adextl2
@fnamwrite
ENDIF
IF popup&=14 THEN
@adexth1
@fnamwrite
ENDIF
IF popup&=15 THEN
@adextl1
@fnamwrite
ENDIF
ENDIF
IF obj=mover& THEN
a$=@rsc_text$(popups&,popmark&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@smpmark
ENDIF
IF popup&=2 THEN
@smpzoom
ENDIF
IF popup&=3 THEN
@smpscrol
ENDIF
IF popup&=4 THEN
@smpkopie
ENDIF
IF popup&=5 THEN
@smpmove
ENDIF
IF popup&=6 THEN
@smpinsert
ENDIF
IF popup&=7 THEN
@smpmerge
ENDIF
IF popup&=8 THEN
@makefade
ENDIF
ENDIF
ENDIF
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& OR obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@setbutton(obj,1)
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
@smpl
ENDIF
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@smpr
ENDIF
IF obj=smpcblk& THEN
@smpcblkplay
@setbutton(smpcblk&,0)
ENDIF
IF obj=pixzoom& THEN
ce=cs+(xm*4)-1
IF ce>vmem THEN
ce=INT(vmem/4)*4
cs=ce-(xm*4)+1
ENDIF
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
@scrollinit
@setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
@setbutton(pixzoom&,0)
cached=FALSE
@restaura
ENDIF
IF obj=zooml& THEN
@slideup(zomslide&,zoombutt&,zmax,1,16,zoomp,slflg)
IF slflg=TRUE THEN
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@zoomcalc
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
ENDIF
@setbutton(zooml&,0)
ENDIF
IF obj=zoomr& THEN
@slidedwn(zomslide&,zoombutt&,zmax,1,16,zoomp,slflg)
IF slflg=TRUE THEN
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@zoomcalc
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
ENDIF
@setbutton(zoomr&,0)
ENDIF
IF obj=lscroll& THEN
@slideup2(scrlslde&,scrolbut&,scmax,1,scrollp,slflg)
IF slflg=TRUE THEN
cs=scrollp*scteil
ce=scrolm+scrollp*scteil
cs=INT(cs/4)*4
ce=INT(ce/4)*4
cached=FALSE
@restaura
ENDIF
@setbutton(lscroll&,0)
ENDIF
IF obj=rscroll& THEN
@slidedwn2(scrlslde&,scrolbut&,scmax,scstep,1,scrollp,slflg)
IF slflg=TRUE THEN
a=scrolm+scrollp*scteil
IF a<=vmem THEN
ce=a
cs=scrollp*scteil
ELSE
cs=vmem-scrolm
ce=vmem
ENDIF
cs=INT(cs/4)*4
ce=INT(ce/4)*4
cached=FALSE
@restaura
ENDIF
@setbutton(rscroll&,0)
ENDIF
IF obj=swdsp& THEN
@dspwahl
ENDIF
IF obj=smplen& THEN
@smplen
ENDIF
IF obj=smpsec& THEN
@smpsec
ENDIF
IF obj=blocfunc& THEN
@blkfunc
ENDIF
IF obj=smpfile& THEN
@smpinfbutt
ENDIF
IF obj=clock& THEN
@abackup
ENDIF
IF obj=trak& THEN
@trakker
ENDIF
IF obj=smpanf& THEN
@smpanf
ENDIF
IF obj=smpend& THEN
@smpend
ENDIF
IF obj=smpmid& THEN
@smpmid
ENDIF
IF obj=smpload& THEN
neufsel=FALSE
@smpload
ENDIF
IF obj=smpdbank& THEN
neufsel=TRUE
@smpload
ENDIF
IF obj=smpsta& THEN
@smpstx(1)
ENDIF
IF obj=smpstb& THEN
@smpstx(2)
ENDIF
IF obj=smpstc& THEN
@smpstx(3)
ENDIF
IF obj=smpstd& THEN
@smpstx(4)
ENDIF
IF obj=smpste& THEN
@smpstx(5)
ENDIF
IF obj=smpea& THEN
@smpex(1)
ENDIF
IF obj=smpeb& THEN
@smpex(2)
ENDIF
IF obj=smpec& THEN
@smpex(3)
ENDIF
IF obj=smped& THEN
@smpex(4)
ENDIF
IF obj=smpee& THEN
@smpex(5)
ENDIF
IF obj=smpsave& THEN
@smpsave
ENDIF
IF obj=smpplay& THEN
@smpplay
ENDIF
IF obj=smppmark& THEN
@smppmark
ENDIF
IF obj=smploop& THEN
@smploop
ENDIF
IF obj=peaksw2& THEN
@peak
ENDIF
IF obj=hard& THEN
IF virtual=FALSE THEN
@harddisk
ELSE
@setbutton(hard&,1)
ENDIF
ENDIF
IF obj=blkstore& THEN
@blkstore
ENDIF
IF obj=loopart& THEN
@loopwahl
ENDIF
IF obj=loopauto& THEN
@loopauto
ENDIF
IF obj=edmidi& THEN
@midi
ENDIF
IF obj=edfade& THEN
@fade
ENDIF
IF obj=midi& THEN
@machmidi
ENDIF
IF obj=smpsavl& THEN
@smpsts
ENDIF
IF obj=smpsavr& THEN
@smpes
ENDIF
IF obj=smpauto2& THEN
@smpauto
ENDIF
IF obj=smpstrt2& THEN
@smpstart
ENDIF
IF obj=monitor& THEN
@monitor
ENDIF
IF obj=recplay3& THEN
@smpstart
ENDIF
IF obj=arrange& THEN
@arranger
ENDIF
IF obj=setuper& THEN
@setupdat
ENDIF
IF obj=edsmp16& THEN
@main
ENDIF
IF obj=infoicon& THEN
@info
ENDIF
IF obj=trash& THEN
@trash
ENDIF
IF obj=coptoarr& THEN
@copytoarr
ENDIF
IF obj=smptsa& OR obj=smptsb& OR obj=smptsc& OR obj=smptsd& OR obj=smptse& OR obj=smptsava& OR obj=smptea& OR obj=smpteb& OR obj=smptec& OR obj=smpted& OR obj=smptee& OR obj=smptsavb& OR obj=cstxt& OR obj=cetxt& THEN
@time_edit
@setbutton(obj,0)
ENDIF
IF obj=smpedhlp& THEN
@helptxt("SAMPLE-EDITOR")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj<>smpexit& THEN
'    obj=0
but=0
popup&=0
ENDIF
IF (ce-cs)<>(mrce-mrcs) AND obj<>smpexit& AND mrzoom=zoomp THEN
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
ENDIF
IF ce<>mrce OR cs<>mrcs AND mrscroll=scrollp THEN
@scrollinit
@setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
mrscroll=scrollp
ENDIF
IF obj=smpexit& THEN
cached=FALSE
@setbutton(smpexit&,0)
ENDIF
RETURN
'
> PROCEDURE blkfunc
.| Glob. Var.: winh#,blkfunc&,rsc_window&,vornr#,nr#,menuda#,makevirt3#
.|     blocfunc&,g#,smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,markhlp,setbutton,setbutton2
.|     rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,blkfunc&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=blkfunc&
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
makevirt3=FALSE
@markhlp
ELSE
@setbutton(blocfunc&,0)
ALERT 1,"Alle Fenster belegt|Bitte ein Fenster schlieûen !",1,"EXIT",g
ENDIF
ELSE
vornr=nr
nr=blkfunc&
IF vornr=smpedit& THEN
@setbutton2(blocfunc&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_blkf
.| Glob. Var.: obj#,blkhelp&,conins&,conmix&,cached#,conspace&,norm&,resmp&
.|     mono&,negate&,lrchange&,cutin&,cutout&,cutdel&,blkexit&,butdirect#
.|     winh#,blkfunc&,smpedit&,makecurve#,p$,hz#,smprate&,sec#,smplen#
.|     smpsec&,sec$,blocfunc&
.| Ruft auf  : helptxt,coninsert,conmix,conspace,normalize,resample,mono
.|     negate,lrchange,smpcut,setbutton,restaura2b,textfeld,secfeld,timecorr
.| Aufruf in : windows-1,
IF obj=blkhelp& THEN
@helptxt("BLOCK-FUNCTIONS")
ENDIF
IF obj=conins& THEN
@coninsert
ENDIF
IF obj=conmix& THEN
@conmix
cached=FALSE
ENDIF
IF obj=conspace& THEN
@conspace
cached=FALSE
ENDIF
IF obj=norm& THEN
@normalize
ENDIF
IF obj=resmp& THEN
@resample
ENDIF
IF obj=mono& THEN
@mono
ENDIF
IF obj=negate& THEN
@negate
ENDIF
IF obj=lrchange& THEN
@lrchange
ENDIF
IF obj=cutin& OR obj=cutout& OR obj=cutdel& THEN
@smpcut
ENDIF
IF obj<>blkexit& AND butdirect=TRUE THEN
butdirect=FALSE
'    nr=butnr
'    @rsc_redraw_obj(nr,0)
ENDIF
IF obj=blkexit& OR obj=9999 THEN
@setbutton(blkexit&,0)
winh=BCLR(winh,blkfunc&)
@restaura2b
IF BTST(winh,smpedit&)=TRUE THEN
IF makecurve=1 THEN
p$=STR$(hz/1000)+CHR$(0)
@textfeld(smprate&,p$,1)
sec=INT(smplen/(hz*4))+1
@secfeld(sec,8)
@textfeld(smpsec&,sec$,1)
@timecorr
ENDIF
@setbutton(blocfunc&,0)
ENDIF
obj=0
ENDIF
RETURN
'
> PROCEDURE time_edit
.| Glob. Var.: mrkobj#,obj#,vorvornr#,vornr#,nr#,timeed&,tedart#,tedsec&
.|     tedsmp&,t#,smptsa&,smptsb&,smptsc&,smptsd&,smptse&,smptsava&,smptea&
.|     smpteb&,smptec&,smpted&,smptee&,smptsavb&,loopz#,s#,cstxt&,cs#,cetxt&
.|     ce#,popup&,tedtxt&,edit_obj&,smpedit&,zu%,zuadr#,buttadr#,but#
.|     objflag#,makefsel&,tedhelp&,vtedart#,tedok&,tedexit&,cached#
.|     scrlslde&,scrolbut&,scmax#,scrollp#,mrscroll#
.| Felder    : loops#(),loope#()
.| Ruft auf  : rsc_draw,markhlp,makehz,setbutton,tedart,mousek,rsc_do
.|     xrsrc_gaddr,helptxt,tedproof,restaura2,rsc_redraw_obj,curve,markprod3
.|     scrollinit,setslide
.| Aufruf in : do_smpedit-1,
LOCAL notedok,robj
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=timeed&
@rsc_draw(nr,0)
@markhlp
@makehz
IF tedart=0 THEN
@setbutton(tedsec&,1)
@setbutton(tedsmp&,0)
ELSE
@setbutton(tedsmp&,1)
@setbutton(tedsec&,0)
ENDIF
t=0
IF obj=smptsa& THEN
t=1
ENDIF
IF obj=smptsb& THEN
t=2
ENDIF
IF obj=smptsc& THEN
t=3
ENDIF
IF obj=smptsd& THEN
t=4
ENDIF
IF obj=smptse& THEN
t=5
ENDIF
IF obj=smptsava& THEN
t=6
ENDIF
IF obj=smptea& THEN
t=7
ENDIF
IF obj=smpteb& THEN
t=8
ENDIF
IF obj=smptec& THEN
t=9
ENDIF
IF obj=smpted& THEN
t=10
ENDIF
IF obj=smptee& THEN
t=11
ENDIF
IF obj=smptsavb& THEN
t=12
ENDIF
IF t>0 AND t<=loopz THEN
s=loops(t)
ENDIF
IF t>loopz AND t<=(loopz*2) THEN
s=loope(t-loopz)
ENDIF
IF obj=cstxt& THEN
s=cs
t=98
ENDIF
IF obj=cetxt& THEN
s=ce
t=99
ENDIF
IF s=-1 THEN
s=0
ENDIF
@tedart
REPEAT
UNTIL @mousek=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1 AND obj<>tedtxt&
edit_obj&=0
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=makefsel& THEN
ENDIF
IF obj=tedhelp& THEN
@helptxt("TIME/SAMPLES-EDITING")
ENDIF
IF obj=tedsmp& THEN
vtedart=1
IF vtedart<>tedart THEN
@tedproof
IF notedok=FALSE THEN
tedart=vtedart
@tedart
ELSE
@setbutton(tedsec&,1)
@setbutton(tedsmp&,0)
ENDIF
ENDIF
ENDIF
IF obj=tedsec& THEN
vtedart=0
IF vtedart<>tedart THEN
@tedproof
IF notedok=FALSE THEN
tedart=vtedart
@tedart
ELSE
@setbutton(tedsec&,0)
@setbutton(tedsmp&,1)
ENDIF
ENDIF
ENDIF
IF obj=tedok& THEN
@tedproof
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=tedexit& OR obj=tedok& OR obj=tedhelp& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=tedexit& OR (obj=tedok& AND notedok=FALSE)
IF obj=tedok& THEN
IF t>0 AND t<=loopz THEN
loops(t)=s
ENDIF
IF t>loopz AND t<=loopz*2 THEN
loope(t-loopz)=s
ENDIF
IF t=98 THEN
cs=s
cached=FALSE
ENDIF
IF t=99 THEN
ce=s
cached=FALSE
ENDIF
ENDIF
@restaura2
IF obj=tedok& THEN
@rsc_redraw_obj(nr,0)
@curve(cs,ce)
@markprod3
ENDIF
obj=mrkobj
IF nr=smpedit& THEN
@setbutton(obj,0)
ENDIF
vornr=vorvornr
IF (t=98 OR t=99) AND nr=smpedit& THEN
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
mrscroll=scrollp
ENDIF
RETURN
'
> PROCEDURE tedart
.| Glob. Var.: tedart#,u#,s#,hz#,a$,tedtxt&
.| Ruft auf  : editfeld
.| Aufruf in : time_edit-3,
IF tedart=0 THEN
u=s/(hz*4)
a$=STR$(u)
ELSE
u=INT(s/4)
a$=STR$(u)
ENDIF
IF LEN(a$)>8 THEN
a$=LEFT$(a$,8)
ENDIF
a$=a$+CHR$(0)
@editfeld(tedtxt&,SPACE$(8)+CHR$(0))
@editfeld(tedtxt&,a$)
RETURN
'
> PROCEDURE tedproof
.| Glob. Var.: tedtxt&,notedok#,a$,i#,a#,s#,tedart#,hz#,vmem#,g#
.| Ruft auf  : editread
.| Aufruf in : time_edit-3,
@editread(tedtxt&)
notedok=FALSE
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF (a<48 OR a>57) AND a<>46 THEN
notedok=TRUE
ENDIF
IF (i=1 OR i=8) AND a=46 THEN
notedok=TRUE
ENDIF
NEXT i
ELSE
notedok=TRUE
ENDIF
IF notedok=FALSE THEN
s=VAL(a$)
IF tedart=0 THEN
s=s*hz*4
ELSE
s=s*4
ENDIF
s=INT(s/4)*4
IF s<0 OR s>vmem THEN
notedok=TRUE
ALERT 3,"Der Wert ist auûerhalb des|gÅltigen Bereichs !",1,"EXIT",g
ENDIF
ENDIF
RETURN
'
> PROCEDURE make
.| Glob. Var.: mrkobj#,obj#,vorvornr#,vornr#,nr#,arrmake&,make$,maketxt&,hz#
.|     a$,popups&,make32&,makerate&,make44&,make48&,popup&,smpedit&,zu%
.|     zuadr#,buttadr#,but#,objflag#,makefsel&,op$,ext$,vext$,fil$,pret#
.|     pbutt#,nam$,makehelp&,makeok&,makexit&,i#,lmax2#,flen#,okay#,a2#
.|     virt$,mlen#,meml#,vln#,anf#,bytes#,len#,start#,virtp$,virtfile$
.| Felder    : arrpath$(),arrend#(),arrstrt#(),arrtri#(),arrsrate#()
.| Ruft auf  : rsc_draw,markhlp,makehz,textfeld,swtosrate,mousek,rsc_do
.|     xrsrc_gaddr,adlow,admid,adhigh,fileselect,rsc_back,helptxt,setbutton
.|     busy_mouse,arr_resmp,maschinit29,maschruf29,maschinit9,maschruf9
.|     nomem,restaura2
.| Aufruf in : do_arrange-1,
LOCAL mhz,nomem,a,b,c,d,e,mrkhz,vm
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=arrmake&
@rsc_draw(nr,0)
@markhlp
@makehz
make$="             "
@textfeld(maketxt&,make$,1)
mhz=2
IF hz=32000 THEN
a$=@rsc_text$(popups&,make32&)
@textfeld(makerate&,a$,1)
mhz=1
ENDIF
IF hz=44100 THEN
a$=@rsc_text$(popups&,make44&)
@textfeld(makerate&,a$,1)
mhz=2
ENDIF
IF hz=48000 THEN
a$=@rsc_text$(popups&,make48&)
@textfeld(makerate&,a$,1)
mhz=3
ENDIF
@swtosrate(hz)
REPEAT
UNTIL @mousek=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
IF obj=makerate& THEN
a$=@rsc_text$(popups&,popmake&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
mhz=1
@adlow
ENDIF
IF popup&=2 THEN
mhz=2
@admid
ENDIF
IF popup&=3 THEN
mhz=3
@adhigh
ENDIF
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=makefsel& THEN
@fileselect(op$+"*."+ext$,"","MAKEFILE:")
vext$=ext$
IF vext$="*" THEN
vext$="S16"
ENDIF
IF RINSTR(fil$,".")=0 THEN
fil$=fil$+"."+vext$
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 THEN
@textfeld(maketxt&,nam$+CHR$(0),1)
ENDIF
ENDIF
IF obj=makehelp& THEN
@helptxt("MAKE")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=makeok& OR obj=makexit& OR obj=makefsel& OR obj=makehelp& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=makexit& OR (obj=makeok& AND fil$<>"" AND nam$<>"")
IF obj=makeok& THEN
IF mhz=1 THEN
mhz=32000
ENDIF
IF mhz=2 THEN
mhz=44100
ENDIF
IF mhz=3 THEN
mhz=48000
ENDIF
b=0
nomem=FALSE
@busy_mouse
FOR i=1 TO lmax2
e=0
IF arrpath$(i)<>"" AND arrpath$(i)<>"MEMORY" AND arrpath$(i)<>"DELAY" THEN
e=(arrend(i)-arrstrt(i))*flen
IF arrtri(i)=2 THEN
e=e+(arrend(i)-arrstrt(i))*flen
ENDIF
nomem=TRUE
ENDIF
IF arrpath$(i)="DELAY" THEN
e=INT(arrend(i)/100*60*mhz)*4
nomem=TRUE
ENDIF
IF arrpath$(i)="MEMORY" THEN
e=(arrend(i)-arrstrt(i))
IF arrtri(i)=2 THEN
e=e+(arrend(i)-arrstrt(i))
ENDIF
ENDIF
IF arrsrate(i)<>mhz AND arrpath$(i)<>"" AND arrpath$(i)<>"DELAY" THEN
nomem=TRUE
mrkhz=arrsrate(i)
e=e/mrkhz*mhz
ENDIF
b=b+e
NEXT i
@busy_mouse
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=b THEN
okay=TRUE
ENDIF
IF nomem=TRUE AND okay=TRUE THEN
a2=ASC(LEFT$(virt$,1))-64
c=mlen
IF a=a2 THEN
c=mlen+b
ENDIF
IF DFREE(a2)>=c THEN
okay=TRUE
ELSE
okay=FALSE
ENDIF
BSAVE virt$,meml,mlen
ENDIF
IF okay=TRUE THEN
OPEN "O",#1,fil$
FOR i=1 TO lmax2
@busy_mouse
a$=arrpath$(i)
'
IF a$<>"" AND a$<>"MEMORY" AND a$<>"DELAY" THEN
OPEN "I",#2,a$
IF arrtri(i)=0 OR arrtri(i)=2 THEN
vln=(arrend(i)-arrstrt(i))*flen
anf=arrstrt(i)*flen
SEEK #2,anf
bytes=INT(mlen/4)*4
IF arrsrate(i)<>mhz THEN
@arr_resmp
ELSE
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #2,meml,bytes
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #2,meml,vln
BPUT #1,meml,vln
ENDIF
ENDIF
ENDIF
IF arrtri(i)=1 OR arrtri(i)=2 THEN
@maschinit29
vln=(arrend(i)-arrstrt(i))
bytes=INT(mlen/8)*4
len=INT(bytes/flen)
start=arrend(i)*flen
IF arrsrate(i)<>mhz THEN
CLOSE #1
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=vln THEN
virtp$=CHR$(a+64)+":\"+virtfile$
OPEN "O",#1,virtp$
ELSE
okay=FALSE
ENDIF
ENDIF
IF okay=TRUE THEN
REPEAT
IF vln<len THEN
len=vln
ENDIF
start=start-len*flen
SEEK #2,start
BGET #2,meml,len*flen
@maschruf29(meml,meml+len*flen)
BPUT #1,meml+len*flen,len*flen
vln=vln-len
UNTIL vln<1
IF arrsrate(i)<>mhz THEN
CLOSE #1
CLOSE #2
OPEN "U",#1,fil$
SEEK #1,LOF(#1)
OPEN "I",#2,virtp$
vln=LOF(#2)
anf=0
bytes=INT(mlen/4)*4
@arr_resmp
ENDIF
ENDIF
ENDIF
CLOSE #2
IF arrsrate(i)<>mhz AND (arrtri(i)=1 OR arrtri(i)=2) AND okay=TRUE THEN
KILL virtp$
ENDIF
ENDIF
'
IF a$="DELAY" THEN
vln=INT(arrend(i)/100*mhz)*4
bytes=INT(mlen/4)*4
@maschinit9
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
@maschruf9(meml,meml+bytes)
bytes=INT(mlen/4)*4
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BPUT #1,meml,vln
ENDIF
ENDIF
'
IF a$="MEMORY" THEN
IF arrtri(i)=0 OR arrtri(i)=2 THEN
a$=virt$
OPEN "I",#2,a$
len=LOF(#2)
vln=(arrend(i)-arrstrt(i))
vln=INT(vln/4)*4
anf=arrstrt(i)
SEEK #2,anf
bytes=INT(mlen/4)*4
IF arrsrate(i)<>mhz THEN
@arr_resmp
ELSE
IF nomem=TRUE THEN
SEEK #2,0
BGET #2,meml,len
ENDIF
BPUT #1,meml+arrstrt(i),vln
ENDIF
CLOSE #2
ENDIF
IF arrtri(i)=1 OR arrtri(i)=2 THEN
OPEN "I",#2,virt$
@maschinit29
vln=(arrend(i)-arrstrt(i))
bytes=INT(mlen/8)*4
start=arrend(i)
'
IF arrsrate(i)<>mhz THEN
CLOSE #1
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=vln THEN
virtp$=CHR$(a+64)+":\"+virtfile$
OPEN "O",#1,virtp$
ELSE
okay=FALSE
ENDIF
ENDIF
IF okay=TRUE THEN
REPEAT
IF vln<bytes THEN
bytes=vln
ENDIF
start=start-bytes
SEEK #2,start
BGET #2,meml,bytes
@maschruf29(meml,meml+bytes)
BPUT #1,meml+bytes,bytes
vln=vln-bytes
UNTIL vln<1
IF arrsrate(i)<>mhz THEN
CLOSE #1
CLOSE #2
OPEN "U",#1,fil$
SEEK #1,LOF(#1)
OPEN "I",#2,virtp$
vln=LOF(#2)
anf=0
bytes=INT(mlen/4)*4
@arr_resmp
ENDIF
ENDIF
CLOSE #2
IF arrsrate(i)<>mhz AND (arrtri(i)=1 OR arrtri(i)=2) AND okay=TRUE THEN
KILL virtp$
ENDIF
ENDIF
ENDIF
'
NEXT i
CLOSE #1
IF nomem=TRUE AND EXIST(virt$)=TRUE THEN
BLOAD virt$,meml
KILL virt$
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF okay=FALSE AND obj<>makexit& THEN
@nomem
ENDIF
ENDIF
@restaura2
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE arr_resmp
.| Glob. Var.: f#,mhz#,e#,i#,bedarf#,okay#,drittel#,memh#,meml#,a#,fil$,vln#
.|     seekz#,anf#,bytes#,mlen#,b#,c#,d#,back%
.| Felder    : arrsrate#()
.| Ruft auf  : maschinit16,maschruf16
.| Aufruf in : make-4,
@maschinit16
f=INT(mhz/100)
e=INT(arrsrate(i)/100)
bedarf=f/e
okay=FALSE
drittel=(memh-meml)/(e+f)*e
drittel=INT(drittel/4)*4
IF drittel>15 THEN
drittel=drittel-8
ENDIF
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=vln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
seekz=anf
REPEAT
IF vln>=bytes THEN
IF bedarf<=1 THEN
bytes=INT(mlen/4)*4
ELSE
bytes=drittel
ENDIF
ELSE
bytes=INT(vln/4)*4
ENDIF
SEEK #2,seekz
IF bytes>3 THEN
BGET #2,meml,bytes
a=meml
b=meml+bytes
IF bedarf<=1 THEN
c=meml
ELSE
c=meml+bytes
ENDIF
d=memh
@maschruf16(a,b,c,d,e,f)
back%=INT(back%/4)*4
BPUT #1,c,back%-c
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
ENDIF
RETURN
'
> PROCEDURE info
.| Glob. Var.: winh#,info&,rsc_window&,vornr#,nr#,menuda#,infoicon&,g#
.|     smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,markhlp,setbutton,setbutton2
.|     rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,info&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=info&
IF infobinv=FALSE THEN
@setbild(infobild&,0)
infobinv=TRUE
ELSE
@setbild(infobild&,1)
infobinv=FALSE
ENDIF
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
ELSE
@setbutton(infoicon&,0)
ALERT 1,"Alle Fenster belegt|Bitte ein Fenster schlieûen !",1,"EXIT",g
ENDIF
ELSE
vornr=nr
nr=info&
IF vornr=smpedit& THEN
@setbutton2(infoicon&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_info
.| Glob. Var.: obj#,zu%,objflag#,helpinfo&,infoexit&,winh#,info&,nr#
.|     smpedit&,infoicon&
.| Ruft auf  : xrsrc_gaddr,helptxt,setbutton,restaura2b
.| Aufruf in : windows-1,
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zu%+8)
IF obj=helpinfo& THEN
@helptxt("INFO")
ENDIF
IF obj=infoexit& OR obj=9999 THEN
winh=BCLR(winh,info&)
@setbutton(infoexit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(infoicon&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE rebuild
.| Glob. Var.: nr#,smpedit&,extclock#,hz#,a$,popups&,rate32&,rate&,rate44&
.|     rate48&,sloop#,smploop&,sblock#,smppmark&,mamidi#,midi&,sms#,sme#
.| Ruft auf  : fnamwrite,textfeld,adlow,admid,adhigh,fliphz,setbutton
.|     selblksbut,selblkebut
.| Aufruf in : trash-2,
@fnamwrite
IF nr=smpedit& THEN
@fliphz
@fliphz2
IF sloop=0 THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF mamidi=0 THEN
@setbutton(midi&,0)
ELSE
@setbutton(midi&,1)
ENDIF
@selblksbut(sms,1)
@selblkebut(sme,1)
ENDIF
RETURN
'
> PROCEDURE trash
.| Glob. Var.: mbs#,zoomp#,v#,v2#,v3#,v4#,virtual#,g#,op$,rop$,virtcurve#
.|     virtld#,blockld#,cached#,maxcwert#,ce#,mlen#,cs#,vmem#,hz#,smplen#
.|     path$,smpnam$,ext2$,lfw$,hrd#,nr#,smpedit&,hard&,rett#,meml#,memh#,i#
.|     lmax2#,lz#,trash&
.| Felder    : arrpath$(),arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrloop#()
.|     arrtri#()
.| Ruft auf  : smph3,markhlp,markdel,clsed,busy_mouse,getmem,makehz
.|     setbutton,rebuild,blocklook,maschinit9,maschruf9,zslidecalc,restaura
.| Aufruf in : hardproof2-1,do_smpedit-1,
mbs=0
zoomp=0
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4=1 OR v4=2 THEN   ! linke oder echte Shift
@smph3
ENDIF
IF v4=0 THEN
IF virtual=TRUE THEN
ALERT 2,"Virtuelles Sample entfernen &|Speicherinhalt zurÅckholen ?",1,"JA|NEIN",g
IF g=1 THEN
op$=rop$
virtual=FALSE
virtcurve=FALSE
virtld=FALSE
blockld=FALSE
cached=FALSE
@markhlp
maxcwert=0
ce=mlen
cs=0
vmem=INT(mlen-1)
@markdel
@clsed
@busy_mouse
@getmem
IF hz=0 THEN
@makehz
ENDIF
IF smplen=0 THEN
smplen=mlen
ENDIF
IF path$="" OR INSTR(path$,":")=0 OR INSTR(path$,"\")=0 THEN
smpnam$="MEMORY."+ext2$
path$=lfw$+smpnam$
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
hrd=0
IF nr=smpedit& THEN
@setbutton(hard&,0)
ENDIF
@rebuild
ENDIF
ELSE
IF rett=TRUE THEN
ALERT 2,"Sample entfernen und|altes Sample zurÅckholen ?",1,"JA|NEIN",g
ELSE
ALERT 2,"Sample entfernen ?",1,"JA|NEIN",g
ENDIF
IF g=1 THEN
cached=FALSE
@markhlp
@blocklook
@maschinit9
@maschruf9(meml,memh)   ! Delete Memory
@markdel
@clsed
FOR i=1 TO lmax2
IF arrpath$(i)="MEMORY" THEN
arrfn$(i)=""
arrpath$(i)=""
arrstrt(i)=0
arrend(i)=0
arrlen(i)=0
arrloop(i)=0
arrtri(i)=0
ENDIF
NEXT i
ENDIF
IF rett=TRUE AND g=1 THEN
rett=FALSE
@busy_mouse
@getmem
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF g=1 THEN
@rebuild
ENDIF
ENDIF
lz=1
zoomp=0
@zslidecalc
@restaura
ENDIF
@setbutton(trash&,0)
RETURN
'
> PROCEDURE sourcein
IF ad=0 THEN
@digital
ELSE
@analog
ENDIF
IF digsource=0 THEN
@opto
ENDIF
IF digsource=1 THEN
@coax
ENDIF
IF digsource=3 THEN
@aesebu
ENDIF
IF empha=FALSE THEN
@emphoff
ENDIF
IF empha=TRUE THEN
@emphon
ENDIF
IF scmsw=0 THEN
@scmsno
ENDIF
IF scmsw=1 THEN
@scmsone
ENDIF
IF scmsw=2 THEN
@scmsfree
ENDIF
IF proffm=FALSE THEN
proffm=TRUE
@consumer
ENDIF
IF proffm=TRUE THEN
proffm=FALSE
@profess
ENDIF
IF bridge=FALSE THEN
bridge=TRUE
ELSE
bridge=FALSE
ENDIF
@digibridge
IF dspw=0 THEN
@dspoff
ENDIF
IF dspw=1 THEN
@dspin
ENDIF
IF dspw=2 THEN
@dspout
ENDIF
bfadericht=fadericht
IF fadewin=0 THEN
@infade
@fadelinear
ENDIF
IF fadewin=1 THEN
@infade
@fadesquare
ENDIF
IF fadewin=2 THEN
@infade
@fadexp
ENDIF
IF fadewin=3 THEN
@infade
@fadesqrt
ENDIF
IF fadewin=4 THEN
@infade
@fadelog
ENDIF
IF fadewout=0 THEN
@ausfade
@fadelinear
ENDIF
IF fadewout=1 THEN
@ausfade
@fadesquare
ENDIF
IF fadewout=2 THEN
@ausfade
@fadexp
ENDIF
IF fadewout=3 THEN
@ausfade
@fadesqrt
ENDIF
IF fadewout=4 THEN
@ausfade
@fadelog
ENDIF
fadericht=bfadericht
IF fadericht=0 THEN
@infade
ELSE
@ausfade
ENDIF
RETURN
'
> PROCEDURE setupdat
.| Glob. Var.: vornr#,nr#,setup&,obj#,popup&,zu%,zuadr#,x#,y#,v3#,lenmall&
.|     edit_obj&,buttadr#,but#,objadr#,objflag#,timeset&,setshow&,posy&
.|     vertline&,frec&,zerosnap&,zoomy&,linkdot&,freeze&,spacefil&,menuset&
.|     sync&,extclock#,fseldef&,secl&,secr&,flip&,dreide&,grid&,sram&
.|     mallmax&,recl&,recr&,tresl&,tresr&,setsave&,setload&,wavset&,avrset&
.|     sndset&,auset&,smpset&,allset&,sdset&,sets16&,sethelp&,setexit&
.|     setok&,a$,memmx#,digana#,vdigana#,op$,vop$,fastrec#,vfastrec#,menuda#
.|     vmenuda#,flen#,vflen#,sramda#,vsramda#,min#,vmin#,mallmax#,vmallmax#
.|     th#,vth#,dreidim#,vdreidim#,grids#,vgrid#,ext$,vext$,flipp#,vflipp#
.|     uhr#,vuhr#,show#,vshow#,yline#,vyline#,vertline#,vvertline#,linkdot#
.|     vlinkdot#,spacefill#,vspacefill#,zsnap#,vzsnap#,yzoom#,vyzoom#,freez#
.|     vfreez#,smpedit&,setuper&,clock&,showxy&,stl#
.| Ruft auf  : rsc_draw,markhlp,setdat,rsc_do,xrsrc_gaddr,mouse,timeset
.|     showset,setyline,vertline,fastrec,zerosnap,yautozoom,linkdot,freeze
.|     spacefill,menuset,sync,fseldef,secbutt,flipp,dreide,grid,sram,mallmax
.|     recbutt,tresbutt,setsave,setload,extender,helptxt,editread,setbutton
.|     restaura2,textfeld,smpfree,write_reglow,makehz,sethertz
.| Aufruf in : drop2-1,do_smpedit-1,
vornr=nr
nr=setup&
@rsc_draw(nr,0)
@markhlp
@setdat
vvol=vol
vvolinbal=volinbal
vbalinmax=balinmax
vad=ad
vhz=hz
vdigsource=digsource
vproffm=proffm
vscmsw=scmsw
vempha=empha
vbridge=bridge
vdspw=dspw
vnote=note
vch=ch
vfadewin=fadewin
vfadewout=fadewout
vfadericht=fadericht
vtedart=tedart
vspc=spc
vnorma=norma
vdb=db
vresoth=resoth
vadjresmp=adjresmp
vrealtime=realtime
vdeltime=deltime
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1 AND obj<>lenmall&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF but=22 THEN
IF obj=setform& AND digana=TRUE THEN
a$=@rsc_text$(popups&,popform&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
vext$="S16"
ENDIF
IF popup&=2 THEN
vext$="WAV"
ENDIF
IF popup&=3 THEN
vext$="AVR"
ENDIF
IF popup&=4 THEN
vext$="SND"
ENDIF
IF popup&=5 THEN
vext$="SD"
ENDIF
IF popup&=6 THEN
vext$="AU"
ENDIF
IF popup&=7 THEN
vext$="SMP"
ENDIF
IF popup&=8 THEN
vext$="*"
ENDIF
ENDIF
ENDIF
IF obj=timeset& THEN
@timeset
ENDIF
IF obj=setshow& THEN
@showset
ENDIF
IF obj=posy& THEN
@setyline
ENDIF
IF obj=vertline& THEN
@vertline
ENDIF
IF obj=frec& THEN
@fastrec
ENDIF
IF obj=zerosnap& THEN
@zerosnap
ENDIF
IF obj=zoomy& THEN
@yautozoom
ENDIF
IF obj=linkdot& THEN
@linkdot
ENDIF
IF obj=freeze& THEN
@freeze
ENDIF
IF obj=spacefil& THEN
@spacefill
ENDIF
IF obj=menuset& THEN
@menuset
ENDIF
IF obj=sync& THEN
IF extclock=FALSE THEN
@sync
ENDIF
ENDIF
IF obj=fseldef& THEN
@fseldef
ENDIF
IF obj=secl& OR obj=secr& THEN
@secbutt
ENDIF
IF obj=flip& THEN
@flipp
ENDIF
IF obj=dreide& THEN
@dreide
ENDIF
IF obj=grid& THEN
@grid
ENDIF
IF obj=sram& THEN
@sram
ENDIF
IF obj=mallmax& THEN
@mallmax
ENDIF
IF obj=recl& OR obj=recr& THEN
@recbutt
ENDIF
IF obj=tresl& OR obj=tresr& THEN
@tresbutt
ENDIF
IF obj=setsave& THEN
@setsave
ENDIF
IF obj=setload& THEN
@setload
@setdat
ENDIF
IF obj=sethelp& THEN
@helptxt("SETUP")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
UNTIL obj=setexit& OR obj=setok&
IF obj=setexit& THEN
vol=vvol
volinbal=vvolinbal
balinmax=vbalinmax
ad=vad
hz=vhz
digsource=vdigsource
proffm=vproffm
scmsw=vscmsw
empha=vempha
bridge=vbridge
dspw=vdspw
note=vnote
ch=vch
fadewin=vfadewin
fadewout=vfadewout
fadericht=vfadericht
tedart=vtedart
spc=vspc
norma=vnorma
db=vdb
resoth=vresoth
adjresmp=vadjresmp
realtime=vrealtime
deltime=vdeltime
@sourcein
ENDIF
IF obj=setok& THEN
@editread(lenmall&)
a$="&H"+a$
memmx=VAL(a$)
digana=vdigana
op$=vop$
fastrec=vfastrec
menuda=vmenuda
flen=vflen
sramda=vsramda
min=vmin
rtime=min*60
mallmax=vmallmax
th=vth
dreidim=vdreidim
grids=vgrid
ext$=vext$
flipp=vflipp
uhr=vuhr
show=vshow
yline=vyline
vertline=vvertline
linkdot=vlinkdot
spacefill=vspacefill
zsnap=vzsnap
yzoom=vyzoom
freez=vfreez
ENDIF
IF extclock=TRUE THEN
digana=TRUE
ENDIF
@setbutton(obj,0)
@restaura2
obj=0
IF nr=smpedit& THEN
@setbutton(setuper&,0)
@textfeld(clock&,SPACE$(8)+CHR$(0),1)
@textfeld(showxy&,SPACE$(9)+CHR$(0),1)
@smpfree
@minwrite
ENDIF
IF digana=FALSE THEN
@write_reglow(stl)
ENDIF
@makehz
@sethertz
RETURN
'
> PROCEDURE setload
.| Glob. Var.: setup$,vol#,memmx#,digana#,op$,flen#,sramda#,min#,mallmax#
.|     th#,dreidim#,grids#,ext$,flipp#,uhr#,show#,aback#,abacknam#,btime#
.|     yline#,vertline#,linkdot#,spacefill#,zsnap#,yzoom#,fastrec#,menuda#
.|     freez#,winh#,ctree#,i#,lfw$,back#,backnam#,rop$,obj#,setload&,nr#
.|     setup&
.| Felder    : rx#(),ry#()
.| Ruft auf  : busy_mouse,fadeset,setbutton
.| Aufruf in : HAUPTPROGRAMM-1,setupdat-1,
IF EXIST(setup$) THEN
@busy_mouse
OPEN "I",#1,setup$
INPUT #1,vol
INPUT #1,volinbal
INPUT #1,balinmax
INPUT #1,ad
INPUT #1,hz
INPUT #1,digsource
INPUT #1,proffm
INPUT #1,scmsw
INPUT #1,empha
INPUT #1,bridge
INPUT #1,dspw
INPUT #1,note
INPUT #1,ch
INPUT #1,fadewin
INPUT #1,fadewout
INPUT #1,fadericht
INPUT #1,tedart
INPUT #1,spc
INPUT #1,norma
INPUT #1,db
INPUT #1,resoth
INPUT #1,adjresmp
INPUT #1,realtime
INPUT #1,deltime
INPUT #1,memmx
INPUT #1,digana
INPUT #1,op$
INPUT #1,flen
INPUT #1,sramda
INPUT #1,min
INPUT #1,mallmax
INPUT #1,th
INPUT #1,dreidim
INPUT #1,grids
INPUT #1,ext$
INPUT #1,flipp
INPUT #1,uhr
INPUT #1,show
INPUT #1,aback
INPUT #1,abacknam
INPUT #1,btime
INPUT #1,yline
INPUT #1,vertline
INPUT #1,linkdot
INPUT #1,spacefill
INPUT #1,zsnap
INPUT #1,yzoom
INPUT #1,fastrec
INPUT #1,menuda
INPUT #1,freez
INPUT #1,winh
INPUT #1,ctree
FOR i=0 TO ctree
INPUT #1,rx(i)
INPUT #1,ry(i)
NEXT i
INPUT #1,hpath$
CLOSE #1
ELSE
digsource=0            ! Digitalanschluû-Art
proffm=0               ! Consumer/Profi-Mode
scmsw=0                ! SCMS-Copymanagement
emphw=0                ! Emphasis
bridge=0               ! Digitalkonvertierung umgehen
dspw=0                 ! DSP none/in/out
note=0                 ! Midi-Note
ch=0                   ! Midi-Kanal
fadewin=0              ! Fader-Art Einblendung
fadewout=0             ! Fader-Art Ausblendung
fadericht=0            ! Fader-Richtung
tedart=0               ! Art der Zeitangabe in Samples oder Sekunden
aback=0                ! Auto-Backup
abacknam=0             ! Original-Filenamen fÅr Auto-Backup
hz=44100               ! Sample-Rate
vol=128+64             ! volume-control
balinmax=24            ! halbe Breite des Balance-Reglers
volinbal=0             ! Stellung des Balance-Reglers
ad=0                   ! Digital-Eingang benutzen
memmx=&H100000         ! Wenn mallmax=FALSE,dann memmx-Speicher anfordern
digana=TRUE            ! wenn TRUE, dann DIGITAL->ANALOG-Umschaltung bei Wiedergabe
op$=lfw$               ! Default-Zugriffspfad
flen=&H4000            ! SektorlÑnge
sramda=FALSE           ! wenn TRUE, dann SRAM vorhanden
min=4                  ! RECORD-Aufnahmezeit in Minuten
rtime=min*60
mallmax=TRUE           ! TRUE, wenn maximalen Speicher anfordern
th=257                 ! Schwelle fÅr AUTO-RECORD
dreidim=1              ! 3D-OberflÑche
grids=1                ! Hintergrundmuster fÅr Wellenfenster
ext$="S16"             ! Fileextender fÅr Soundfiles
flipp=FALSE            ! Einstellung fÅr Copy/move-Auswahlleiste
uhr=FALSE              ! Uhrzeitanzeige
show=FALSE             ! Anzeige der Position in Samples
back=FALSE             ! Auto-Backup
backnam=FALSE          ! Original-Filenamen fÅr Auto-Backup
btime=5                ! Backup-Zeitlimit
yline=FALSE            ! Vertikale Markierung im Wellenfenster
vertline=FALSE         ! Darstellung der Samples als Pegel
linkdot=FALSE          ! Verbindung der Samples durch Linie
spacefill=TRUE         ! FÅllung der Samples
zsnap=FALSE            ! Suchen von Nullpunkten
yzoom=FALSE            ! Autozoom fÅr Samples
fastrec=FALSE          ! Geschwindigkeitsanpassung fÅr langsame /schnelle Systeme
menuda=TRUE            ! MenÅzeile
freez=FALSE            ! Fensterpositionen merken und Fenster automatisch îffnen
spc=3                  ! Space-Time
norma=1                ! Normalize Adjust/Auto
db=-6                  ! Normalize-Wert -6dB
resoth=48              ! Resampling-Wert 48kHz
adjresmp=FALSE         ! Adjust resample-rate
realtime=FALSE         ! Echtzeit fÅr Arranger
deltime=60             ! Zeitverzîgerung fÅr Arranger
winh=0
hpath$=op$+"1STGUIDE.IDX"  ! Pfad des Helpfile-Systems
ENDIF
IF spacefill=FALSE AND vertline=FALSE AND linkdot=FALSE THEN
spacefill=TRUE
ENDIF
@fadeset
rop$=op$
IF obj=setload& AND nr=setup& THEN
@balwrite(vol,volinbal,balinmax)
@setbutton(obj,0)
@sourcein
ENDIF
rtime=min*60
RETURN
'
> PROCEDURE setdat
.| Glob. Var.: extclock#,digana#,vmenuda#,menuda#,vfastrec#,fastrec#
.|     vdigana#,vop$,op$,vflen#,flen#,vsramda#,sramda#,vmin#,min#,vmallmax#
.|     mallmax#,vth#,th#,vdreidim#,dreidim#,vgrid#,grids#,vext$,ext$,vflipp#
.|     flipp#,vuhr#,uhr#,vshow#,show#,vyline#,yline#,vvertline#,vertline#
.|     vlinkdot#,linkdot#,vspacefill#,spacefill#,vzsnap#,zsnap#,vyzoom#
.|     yzoom#,vfreez#,freez#,oop$,a#,fseltxt&,f$,seclen&,recm&,tdb#,aufloes#
.|     tdb$,tresdb&,sdset&,avrset&,sndset&,auset&,smpset&,sets16&,wavset&
.|     allset&,sync&,dreide&,frec&,posy&,menuset&,zoomy&,grid&,freeze&,sram&
.|     flip&,setshow&,zerosnap&,timeset&,linkdot&,vertline&,spacefil&
.|     mallmax&,a$,memmx#,lenmall&
.| Ruft auf  : textfeld,setbutton,editfeld
.| Aufruf in : setupdat-2,
~GRAF_MOUSE(256,0)                              ! Hidem
IF extclock=TRUE THEN
digana=TRUE
ENDIF
vmenuda=menuda
vfastrec=fastrec
vdigana=digana
vop$=op$
vflen=flen
vsramda=sramda
vmin=min
vmallmax=mallmax
vth=th
vdreidim=dreidim
vgrid=grids
vext$=ext$
vflipp=flipp
vuhr=uhr
vshow=show
vyline=yline
vvertline=vertline
vlinkdot=linkdot
vspacefill=spacefill
vzsnap=zsnap
vyzoom=yzoom
vfreez=freez
IF LEN(op$)>57 THEN
oop$=RIGHT$(op$,57)
a=INSTR(oop$,"\")
oop$=RIGHT$(oop$,LEN(oop$)-(a-1))
ELSE
oop$=op$
ENDIF
@textfeld(fseltxt&,oop$+CHR$(0),1)
f$=RIGHT$(SPACE$(5)+STR$(flen),5)+CHR$(0)
@textfeld(seclen&,f$,1)
f$=RIGHT$(SPACE$(5)+STR$(min),5)+CHR$(0)
@textfeld(recm&,f$,1)
tdb=th
tdb=20*LOG10(tdb)
tdb=tdb-aufloes
tdb=INT(tdb*1000)/1000
tdb$=STR$(tdb)+CHR$(0)
@textfeld(tresdb&,tdb$,1)
IF ext$="SD" THEN
a$=@rsc_text$(popups&,setsd&)
ENDIF
IF ext$="AVR" THEN
a$=@rsc_text$(popups&,setavr&)
ENDIF
IF ext$="SND" THEN
a$=@rsc_text$(popups&,setsnd&)
ENDIF
IF ext$="AU" THEN
a$=@rsc_text$(popups&,setau&)
ENDIF
IF ext$="SMP" THEN
a$=@rsc_text$(popups&,setsmp&)
ENDIF
IF ext$="S16" THEN
a$=@rsc_text$(popups&,sets16&)
ENDIF
IF ext$="WAV" THEN
a$=@rsc_text$(popups&,setwav&)
ENDIF
IF ext$="*" THEN
a$=@rsc_text$(popups&,setall&)
ENDIF
@textfeld(setform&,a$,1)
IF digana=FALSE THEN
IF extclock=TRUE THEN
@setbutton(sync&,9)
ELSE
@setbutton(sync&,1)
ENDIF
ELSE
IF extclock=TRUE THEN
@setbutton(sync&,8)
ELSE
@setbutton(sync&,0)
ENDIF
ENDIF
IF dreidim=1 THEN
@setbutton(dreide&,1)
ELSE
@setbutton(dreide&,0)
ENDIF
IF fastrec=FALSE THEN
@setbutton(frec&,0)
ELSE
@setbutton(frec&,1)
ENDIF
IF yline=TRUE THEN
@setbutton(posy&,1)
ELSE
@setbutton(posy&,0)
ENDIF
IF menuda=TRUE THEN
@setbutton(menuset&,1)
ELSE
@setbutton(menuset&,0)
ENDIF
IF yzoom=TRUE THEN
@setbutton(zoomy&,1)
ELSE
@setbutton(zoomy&,0)
ENDIF
IF grids=1 THEN
@setbutton(grid&,1)
ELSE
@setbutton(grid&,0)
ENDIF
IF freez=TRUE THEN
@setbutton(freeze&,1)
ELSE
@setbutton(freeze&,0)
ENDIF
IF sramda=TRUE THEN
@setbutton(sram&,1)
ELSE
@setbutton(sram&,0)
ENDIF
IF flipp=TRUE THEN
@setbutton(flip&,1)
ELSE
@setbutton(flip&,0)
ENDIF
IF show=TRUE THEN
@setbutton(setshow&,1)
ELSE
@setbutton(setshow&,0)
ENDIF
IF zsnap=TRUE THEN
@setbutton(zerosnap&,1)
ELSE
@setbutton(zerosnap&,0)
ENDIF
IF uhr=TRUE THEN
@setbutton(timeset&,1)
ELSE
@setbutton(timeset&,0)
ENDIF
IF linkdot=TRUE THEN
@setbutton(linkdot&,1)
ELSE
@setbutton(linkdot&,0)
ENDIF
IF vertline=TRUE THEN
@setbutton(vertline&,1)
ELSE
@setbutton(vertline&,0)
ENDIF
IF spacefill=TRUE THEN
@setbutton(spacefil&,1)
ELSE
@setbutton(spacefil&,0)
ENDIF
IF mallmax=FALSE THEN
@setbutton(mallmax&,1)
ELSE
@setbutton(mallmax&,0)
ENDIF
a$=HEX$(memmx)+CHR$(0)
@editfeld(lenmall&,a$)
~GRAF_MOUSE(257,0)                              ! Hidem
RETURN
'
> PROCEDURE setsave
.| Glob. Var.: lenmall&,a$,memmx#,a#,setup$,vfreez#,winh#,sector#,vol#
.|     vdigana#,vop$,vflen#,vsramda#,vmin#,vmallmax#,vth#,vdreidim#,vgrid#
.|     vext$,vflipp#,vuhr#,vshow#,aback#,abacknam#,btime#,vyline#,vvertline#
.|     vlinkdot#,vspacefill#,vzsnap#,vyzoom#,vfastrec#,vmenuda#,btree#,i#
.|     obj#
.| Felder    : rscx&(),rscy&()
.| Ruft auf  : busy_mouse,editread,nomem,setbutton
.| Aufruf in : setupdat-1,
@busy_mouse
@editread(lenmall&)
a$="&H"+a$
memmx=VAL(a$)
a=ASC(LEFT$(setup$,1))-64
IF vfreez=FALSE THEN
winh=0
ENDIF
IF DFREE(a)>=sector THEN
OPEN "O",#1,setup$
PRINT #1,vvol
PRINT #1,vvolinbal
PRINT #1,vbalinmax
PRINT #1,vad
PRINT #1,vhz
PRINT #1,vdigsource
PRINT #1,vproffm
PRINT #1,vscmsw
PRINT #1,vempha
PRINT #1,vbridge
PRINT #1,vdspw
PRINT #1,vnote
PRINT #1,vch
PRINT #1,vfadewin
PRINT #1,vfadewout
PRINT #1,vfadericht
PRINT #1,vtedart
PRINT #1,vspc
PRINT #1,vnorma
PRINT #1,vdb
PRINT #1,vresoth
PRINT #1,vadjresmp
PRINT #1,vrealtime
PRINT #1,vdeltime
PRINT #1,memmx
PRINT #1,vdigana
PRINT #1,vop$
PRINT #1,vflen
PRINT #1,vsramda
PRINT #1,vmin
PRINT #1,vmallmax
PRINT #1,vth
PRINT #1,vdreidim
PRINT #1,vgrid
PRINT #1,vext$
PRINT #1,vflipp
PRINT #1,vuhr
PRINT #1,vshow
PRINT #1,aback
PRINT #1,abacknam
PRINT #1,btime
PRINT #1,vyline
PRINT #1,vvertline
PRINT #1,vlinkdot
PRINT #1,vspacefill
PRINT #1,vzsnap
PRINT #1,vyzoom
PRINT #1,vfastrec
PRINT #1,vmenuda
PRINT #1,vfreez
IF vfreez=FALSE THEN
PRINT #1,0
ELSE
PRINT #1,winh
ENDIF
PRINT #1,btree
FOR i=0 TO btree
PRINT #1,rscx&(i)
PRINT #1,rscy&(i)
NEXT i
PRINT #1,hpath$
CLOSE #1
ELSE
@nomem
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE menuset
.| Glob. Var.: vmenuda#
.| Aufruf in : setupdat-1,
IF vmenuda=TRUE THEN
vmenuda=FALSE
ELSE
vmenuda=TRUE
ENDIF
RETURN
'
> PROCEDURE freeze
.| Glob. Var.: vfreez#
.| Aufruf in : setupdat-1,
IF vfreez=TRUE THEN
vfreez=FALSE
ELSE
vfreez=TRUE
ENDIF
RETURN
'
> PROCEDURE fastrec
.| Glob. Var.: vfastrec#
.| Aufruf in : setupdat-1,
IF vfastrec=TRUE THEN
vfastrec=FALSE
ELSE
vfastrec=TRUE
ENDIF
RETURN
'
> PROCEDURE yautozoom
.| Glob. Var.: vyzoom#
.| Aufruf in : setupdat-1,
IF vyzoom=TRUE THEN
vyzoom=FALSE
ELSE
vyzoom=TRUE
ENDIF
RETURN
'
> PROCEDURE setyline
.| Glob. Var.: vyline#
.| Aufruf in : setupdat-1,
IF vyline=TRUE THEN
vyline=FALSE
ELSE
vyline=TRUE
ENDIF
RETURN
'
> PROCEDURE zerosnap
.| Glob. Var.: vzsnap#
.| Aufruf in : setupdat-1,
IF vzsnap=TRUE THEN
vzsnap=FALSE
ELSE
vzsnap=TRUE
ENDIF
RETURN
'
> PROCEDURE vertline
.| Glob. Var.: vvertline#,vspacefill#,vlinkdot#,spacefil&
.| Ruft auf  : setbutton
.| Aufruf in : setupdat-1,
IF vvertline=TRUE THEN
vvertline=FALSE
ELSE
vvertline=TRUE
ENDIF
IF vspacefill=FALSE AND vvertline=FALSE AND vlinkdot=FALSE THEN
vspacefill=TRUE
@setbutton(spacefil&,1)
ENDIF
RETURN
'
> PROCEDURE linkdot
.| Glob. Var.: vlinkdot#,vspacefill#,vvertline#,spacefil&
.| Ruft auf  : setbutton
.| Aufruf in : setupdat-1,
IF vlinkdot=TRUE THEN
vlinkdot=FALSE
ELSE
vlinkdot=TRUE
ENDIF
IF vspacefill=FALSE AND vvertline=FALSE AND vlinkdot=FALSE THEN
vspacefill=TRUE
@setbutton(spacefil&,1)
ENDIF
RETURN
'
> PROCEDURE spacefill
.| Glob. Var.: vspacefill#,vvertline#,vlinkdot#,spacefil&
.| Ruft auf  : setbutton
.| Aufruf in : setupdat-1,
IF vspacefill=TRUE THEN
vspacefill=FALSE
ELSE
vspacefill=TRUE
ENDIF
IF vspacefill=FALSE AND vvertline=FALSE AND vlinkdot=FALSE THEN
vspacefill=TRUE
@setbutton(spacefil&,1)
ENDIF
RETURN
'
> PROCEDURE sync
.| Glob. Var.: vdigana#
.| Aufruf in : setupdat-1,
IF vdigana=TRUE THEN
vdigana=FALSE
ELSE
vdigana=TRUE
ENDIF
RETURN
'
> PROCEDURE dreide
.| Glob. Var.: vdreidim#
.| Aufruf in : setupdat-1,
IF vdreidim=1 THEN
vdreidim=0
ELSE
vdreidim=1
ENDIF
RETURN
'
> PROCEDURE grid
.| Glob. Var.: vgrid#
.| Aufruf in : setupdat-1,
IF vgrid=1 THEN
vgrid=0
ELSE
vgrid=1
ENDIF
RETURN
'
> PROCEDURE fseldef
.| Glob. Var.: ab#,nr#,vop$,ext$,ordner$,pret#,pbutt#,a#,fseltxt&,obj#
.| Felder    : rscx&(),rscy&(),rscw&(),rsch&()
.| Ruft auf  : rsc_get,fileselect,rsc_put,busy_mouse,textfeld,setbutton
.| Aufruf in : setupdat-1,
~GRAF_MOUSE(256,0)                              ! Hidem
ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
@fileselect(vop$+"*."+ext$,"","PATH:")
@rsc_put(ab,rscx&(nr),rscy&(nr),1)
@busy_mouse
IF ordner$<>"" AND pret<>0 AND pbutt=1 THEN
IF LEN(ordner$)>57 THEN
ordner$=RIGHT$(ordner$,57)
a=INSTR(ordner$,"\")
ordner$=RIGHT$(ordner$,LEN(ordner$)-(a-1))
ENDIF
@textfeld(fseltxt&,ordner$+CHR$(0),1)
vop$=ordner$
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE secbutt
.| Glob. Var.: obj#,secl&,vflen#,secr&,f$,seclen&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : setupdat-1,
IF obj=secl& AND vflen>511 THEN
vflen=vflen/2
ENDIF
IF obj=secr& AND vflen<65536 THEN
vflen=vflen*2
ENDIF
f$=RIGHT$(SPACE$(5)+STR$(vflen),5)+CHR$(0)
@textfeld(seclen&,f$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE flipp
.| Glob. Var.: vflipp#
.| Aufruf in : setupdat-1,
IF vflipp=FALSE THEN
vflipp=TRUE
ELSE
vflipp=FALSE
ENDIF
RETURN
'
> PROCEDURE showset
.| Glob. Var.: vshow#
.| Aufruf in : setupdat-1,
IF vshow=FALSE THEN
vshow=TRUE
ELSE
vshow=FALSE
ENDIF
RETURN
'
> PROCEDURE timeset
.| Glob. Var.: vuhr#
.| Aufruf in : setupdat-1,
IF vuhr=FALSE THEN
vuhr=TRUE
ELSE
vuhr=FALSE
ENDIF
RETURN
'
> PROCEDURE flipptest
.| Glob. Var.: flipp#,smark#,nr#,smpedit&,a$,popups&,smpmark&,mover&
.| Ruft auf  : textfeld
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,edhandler2-2,
IF flipp=TRUE AND smark<>3 THEN
smark=3
IF nr=smpedit& THEN
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE sram
.| Glob. Var.: vsramda#
.| Aufruf in : setupdat-1,
IF vsramda=FALSE THEN
vsramda=TRUE
ELSE
vsramda=FALSE
ENDIF
RETURN
'
> PROCEDURE recbutt
.| Glob. Var.: obj#,recl&,vmin#,recr&,f$,recm&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : setupdat-1,
IF obj=recl& AND vmin>1 THEN
DEC vmin
ENDIF
IF obj=recr& AND vmin<100 THEN
INC vmin
ENDIF
f$=RIGHT$(SPACE$(5)+STR$(vmin),5)+CHR$(0)
@textfeld(recm&,f$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE mallmax
.| Glob. Var.: vmallmax#
.| Aufruf in : setupdat-1,
IF vmallmax=TRUE THEN
vmallmax=FALSE
ELSE
vmallmax=TRUE
ENDIF
RETURN
'
> PROCEDURE tresbutt
.| Glob. Var.: obj#,tresl&,vth#,tresr&,tdb#,aufloes#,tdb$,tresdb&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : setupdat-1,
IF obj=tresl& AND vth>199 THEN
vth=vth-100
ENDIF
IF obj=tresr& AND vth<32668 THEN
vth=vth+100
ENDIF
tdb=vth
tdb=20*LOG10(tdb)
tdb=tdb-aufloes
tdb=INT(tdb*1000)/1000
tdb$=STR$(tdb)+CHR$(0)
@textfeld(tresdb&,tdb$,1)
setbutton(obj,0)
RETURN
'
> PROCEDURE timecorr
.| Glob. Var.: i#,loopz#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp3
.| Aufruf in : do_blkf-1,
FOR i=1 TO loopz
IF loops(i)<>-1 THEN
@markhlp3(i,loops(i))
ENDIF
NEXT i
FOR i=1 TO loopz
IF loope(i)<>-1 THEN
@markhlp3(i+loopz,loope(i))
ENDIF
NEXT i
RETURN
'
> PROCEDURE markdel
.| Glob. Var.: smplen#,vmem#,i#,loopz#,smark#,nr#,smpedit&,a$,popups&
.|     smpmark&,mover&,master#
.| Felder    : loops#(),loope#()
.| Ruft auf  : textfeld,fnamwrite
.| Aufruf in : ldhlp-2,smpedit-2,trash-2,memtovirt-1,memtovirt2-1,record2-1,
smplen=vmem
FOR i=1 TO loopz
loops(i)=-1
NEXT i
FOR i=1 TO loopz
loope(i)=-1
NEXT i
smark=3
IF nr=smpedit& THEN
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
ENDIF
master=0
@fnamwrite
RETURN
'
> PROCEDURE smpstx(i)
.| Glob. Var.: sms#,t$,master#,masthlp#,a#
.| Felder    : loops#()
.| Ruft auf  : textfeld,selblkshak,markhlp,markhlp2,markhlp3,markhlp4
.| Aufruf in : do_smpedit-5,smph3-1,
sms=i
t$=CHR$(ASC("a")-1+i)
IF master<>0 AND masthlp<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=i
@selblkshak(i,a)
masthlp=a
@textfeld(a,""+CHR$(0),1)
IF loops(i)=-1 THEN
@markhlp
loops(i)=0
@markhlp2
@markhlp3(i,loops(i))
ELSE
@markhlp4(loops(i))
ENDIF
RETURN
'
> PROCEDURE smpsts
.| Glob. Var.: loopz#,t$,master#,masthlp#,sms#,msms#,a#
.| Felder    : loops#()
.| Ruft auf  : mousek,selblksbut,textfeld,selblkshak,markhlp,markhlp2
.|     markhlp3,markhlp4
.| Aufruf in : do_smpedit-1,smph3-1,
REPEAT
UNTIL @mousek=0
@selblksbut(loopz,0)
t$="s"
IF master<>0 AND masthlp<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
IF sms<loopz THEN
msms=sms
ENDIF
sms=loopz
master=loopz
@selblkshak(loopz,a)
masthlp=a
@textfeld(a,""+CHR$(0),1)
IF loops(loopz)=-1 THEN
@markhlp
loops(loopz)=0
@markhlp2
@markhlp3(loopz,loops(loopz))
ELSE
@markhlp4(loops(loopz))
ENDIF
obj=0
RETURN
'
> PROCEDURE smpex(i)
.| Glob. Var.: sme#,t$,master#,masthlp#,loopz#,a#
.| Felder    : loope#()
.| Ruft auf  : textfeld,selblkehak,markhlp,markhlp2,markhlp3,m11arkhlp4
.| Aufruf in : do_smpedit-5,smph3-1,
sme=i
t$=CHR$(ASC("A")-1+i)
IF master<>0 AND masthlp<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
master=loopz+i
@selblkehak(i,a)
masthlp=a
@textfeld(a,""+CHR$(0),1)
IF loope(i)=-1 THEN
@markhlp
loope(i)=0
@markhlp2
@markhlp3(loopz+i,loope(i))
ELSE
@markhlp4(loope(i))
ENDIF
obj=0
RETURN
'
> PROCEDURE smpes
.| Glob. Var.: loopz#,t$,master#,masthlp#,sme#,msme#,a#
.| Felder    : loope#()
.| Ruft auf  : mousek,selblkebut,textfeld,selblkehak,markhlp,markhlp2
.|     markhlp3,markhlp4
.| Aufruf in : do_smpedit-1,smph3-1,
REPEAT
UNTIL @mousek=0
@selblkebut(loopz,0)
t$="S"
IF master<>0 AND masthlp<>0 THEN
@textfeld(masthlp," "+CHR$(0),1)
ENDIF
IF sme<loopz THEN
msme=sme
ENDIF
sme=loopz
master=loopz*2
@selblkehak(loopz,a)
masthlp=a
@textfeld(a,""+CHR$(0),1)
IF loope(loopz)=-1 THEN
@markhlp
loope(loopz)=0
@markhlp2
@markhlp3(loopz*2,loope(loopz))
ELSE
@markhlp4(loope(loopz))
ENDIF
RETURN
'
> PROCEDURE smph1
.| Glob. Var.: master#,loopz#,x#
.| Felder    : loops#(),loope#()
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-2,smpr-2,edhandler2-1,
IF master>0 AND master<=loopz THEN
x=loops(master)
ENDIF
IF master>loopz AND master<=loopz*2 THEN
x=loope(master-loopz)
ENDIF
RETURN
'
> PROCEDURE smph3
.| Glob. Var.: master#,loopz#,sms#,a#,sme#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp8,selblkshak,textfeld,selblksbut,selblkehak,selblkebut
.|     testsme,testsms,smpstx,smpex,smpsts,smpes
.| Aufruf in : trash-1,
IF master>0 AND master<loopz THEN
@markhlp8(master,loops(master))
loops(master)=-1
sms=0
@selblkshak(master,a)
@textfeld(a," "+CHR$(0),1)
@selblksbut(master,0)
ENDIF
IF master>loopz AND master<loopz*2 THEN
@markhlp8(master,loope(master-loopz))
loope(master-loopz)=-1
sme=0
@selblkehak(master-loopz,a)
@textfeld(a," "+CHR$(0),1)
@selblkebut(master-loopz,0)
ENDIF
IF loope(loopz)<>-1 THEN
master=loopz*2
ENDIF
IF loops(loopz)<>-1 THEN
master=loopz
ENDIF
IF (master>0 AND master<=loopz) THEN
master=0
@testsme
@testsms
ELSE
master=0
@testsms
@testsme
ENDIF
IF master>0 AND master<loopz THEN
@smpstx(master)
@selblksbut(master,1)
ENDIF
IF master>loopz AND master<loopz*2 THEN
@smpex(master-loopz)
@selblkebut(master-loopz,1)
ENDIF
IF master=loopz THEN
@smpsts
@selblksbut(master,1)
PAUSE 2
@selblksbut(master,0)
ENDIF
IF master=loopz*2 THEN
@smpes
@selblkebut(master-loopz,1)
PAUSE 2
@selblkebut(master-loopz,0)
ENDIF
RETURN
'
> PROCEDURE testsme
.| Glob. Var.: i#,loopz#,master#
.| Felder    : loope#()
.| Aufruf in : smph3-2,
FOR i=loopz-1 TO 1 STEP -1
IF loope(i)<>-1 THEN
master=loopz+i
ENDIF
NEXT i
RETURN
'
> PROCEDURE testsms
.| Glob. Var.: i#,loopz#,master#
.| Felder    : loops#()
.| Aufruf in : smph3-2,
FOR i=loopz-1 TO 1 STEP -1
IF loops(i)<>-1 THEN
master=i
ENDIF
NEXT i
RETURN
'
> PROCEDURE markhlp4(bx)
.| Glob. Var.: cs#,ce#,xm#,xd#,stay1#,stay2#,t$
.| Aufruf in : smpstx-1,smpsts-1,smpex-1,smpes-1,
LOCAL cx
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
LINE cx+xd,stay1,cx+xd,stay2
LINE cx+xd,stay1,cx+xd,stay2
GRAPHMODE 1
TEXT cx+xd-3,stay1-1,t$
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE markhlp6(bx)
.| Glob. Var.: cs#,ce#,xm#,xd#,stay1#,stay2#,t$
.| Ruft auf  : markhlp
.| Aufruf in : markprod3-4,edhandler2-1,markset-2,
LOCAL cx
@markhlp
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
LINE cx+xd,stay1,cx+xd,stay2
GRAPHMODE 1
TEXT cx+xd-3,stay1-1,t$
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE setup
.| Glob. Var.: noppause#,peakint#,extclock#,ext#,trkz#,mamidi#,trakact#
.|     butdirect#,isave#,vtst#,infbutt#,rett#,cached#,away#,virtual#
.|     virtwfile#,virtld#,makevirt3#,makevirt2#,makevirt#,blockld#,deltime#
.|     spc#,vcs#,vce#,scmax#,zmax#,buttg#,aufloes#,lmax#,lmax2#,lmax3#
.|     lmax4#,anspiel#,sector#,recfifolen#,playfifolen#,sram#,hbuf#,mdat%
.|     mdat2%,tedart#,tim$,btim$,mdatf#,mdatf2#,mdat3%,mdat4%,wback%,gohome#
.|     adr#,mtst#,mallmax#,memmx#,manf#,merkfrei#,meml#,memh#,mlen#,big#
.|     sramda#,g#,dat#,anfload#,cs#,ce#,vmem#,xm#,loopz#,bloopz#,i#,cwerte1#
.|     mbs#,vmbs#,n#,lz#,smplen#,ext2$,ext$,smpnam$,path$,lfw$,retime#,ad#
.|     xmp#,okmark#,merkerr#,merkfreq#,protnr#,lded#,hrd#,merk1#,merk2#
.|     merk3#,merk4#,merkc#,stl#,clk#,sth#,std#,vol#
.| Felder    : ls#(),le#(),lcs#(),lce#(),arrfn$(),arrpath$(),arrstrt#()
.|     arrend#(),arrlen#(),arrmidi#(),midi#(),arrloop#(),arrtri#()
.|     arrsrate#(),trkfn$(),trkpath$(),trktime#(),trkvor#(),trknext#()
.|     trkstrt#(),trkend#(),trklen#(),trkloop#(),trktri#(),trksrate#()
.|     trkch#(),trkpnt#(),dbank$(),dbank2$(),wurlnr#(),cachep1#(),cachep2#()
.|     cachem1#(),cachem2#(),mblocks#(),mblocke#(),mblockp$(),loops#()
.|     loope#(),vloops#(),vloope#(),bloops#(),bloope#(),vbloops#()
.|     vbloope#()
.| Ruft auf  : markhlp,maschinit9,maschruf9,volwrite
.| Aufruf in : smpedit-1,
LOCAL vnr
DEFTEXT 1,0,0,4
oldplay=FALSE
noppause=FALSE
peakint=FALSE
extclock=FALSE
ext=0
trkz=0
mamidi=0
trakact=0
butdirect=FALSE
isave=FALSE
vtst=FALSE
infbutt=FALSE
infobinv=FALSE
rett=FALSE
proff=FALSE
cached=FALSE
away=FALSE
virtual=FALSE
virtwfile=FALSE
virtld=FALSE
makevirt3=FALSE
makevirt2=FALSE
makevirt=FALSE
blockld=FALSE
vcs=0
vce=0
scmax=50               ! Scroll-Auflîsungsstufen
zmax=30                ! Zoom-Auflîsungsstufen
buttg=16               ! Mindestbreite der Sliderbuttons
aufloes=90.3           ! dB-Aufloesung der Wandler (16Bit)
lmax=100               ! Feldgrîûe fÅr SCROLL
lmax2=100              ! Feldgrîûe fÅr ARRANGER
lmax3=100              ! Feldgrîûe fÅr loaded Blockanfang und Ende
lmax4=100              ! Feldgrîûe fÅr File-Datenbank
anspiel=200            ! anzuspielende Sektoren
sector=&H4000
recfifolen=sector      ! Grîûe des RECORD-FIFO
playfifolen=sector     ! Grîûe des PLAY-FIFO
sram=&HFE900000        ! Anfang des SRAM
hbuf=65536             ! Grîûe des PLAY/REC Buffers
gemvers=GEMDOS(48)     ! GEMDOS-Version >=&H1900 = Fastram-Malloc
IF gemvers>=&H1900 THEN
m=@mxalloc(-1,3)
ELSE
m=MALLOC(-1)
ENDIF
IF m>(hbuf+16384) THEN
IF gemvers>=&H1900 THEN
mdat%=@mxalloc(hbuf,3)     ! Buffer fÅr HARD-REC/PLAY-Buffer und anderes
mdat2%=@mxalloc(16384,3)   ! Buffer fÅr Assembler-Code
ELSE
mdat%=MALLOC(hbuf)     ! Buffer fÅr HARD-REC/PLAY-Buffer und anderes
mdat2%=MALLOC(16384)   ! Buffer fÅr Assembler-Code
ENDIF
tim$=TIME$
btim$=tim$
mdatf=mdat%
mdatf2=mdat2%
IF mdat%=0 OR mdat2%=0 THEN
away=TRUE
ELSE
mdat%=INT(mdat%/2)*2+2
mdat2%=INT(mdat2%/2)*2+2
mdat3%=mdat2%+1000
mdat4%=mdat2%+2000
wback%=INT((mdat2%+2990)/4)*4
gohome=FALSE
IF gemvers>=&H1900 THEN
mtst=@mxalloc(-1,3)
ELSE
mtst=MALLOC(-1)
ENDIF
IF mallmax=FALSE AND mtst>=memmx AND memmx<>0 THEN
mtst=memmx
ENDIF
IF mtst>&H110000 THEN
mtst=INT((mtst-&H70000)/4)*4
IF gemvers>=&H1900 THEN
manf=@mxalloc(mtst,3)
ELSE
manf=MALLOC(mtst)
ENDIF
merkfrei=manf
IF manf>0 THEN
manf=INT(manf/4)*4+4
meml=manf
memh=meml+mtst-4
mlen=mtst-8
big=1
ELSE
IF sramda=TRUE THEN
meml=sram
memh=sram+&H100000-4
mlen=&H100000
big=0
ELSE
IF gemvers>=&H1900 THEN
mtst=@mxalloc(-1,3)
manf=@mxalloc(mtst,3)
ELSE
mtst=MALLOC(-1)
manf=MALLOC(mtst)
ENDIF
merkfrei=manf
IF manf>0 THEN
manf=INT(manf/4)*4+4
meml=manf
memh=meml+mtst-4
mlen=mtst-8
big=1
ELSE
ALERT 3,"Zu wenig freier Speicher !",1,"EXIT",g
gohome=TRUE
ENDIF
ENDIF
ENDIF
ELSE
IF sramda=TRUE THEN
meml=sram
memh=sram+&H100000-4
mlen=&H100000
big=0
ELSE
IF gemvers>=&H1900 THEN
mtst=@mxalloc(-1,3)
ELSE
mtst=MALLOC(-1)
ENDIF
IF mallmax=FALSE AND mtst>=memmx AND memmx<>0 THEN
mtst=memmx
ENDIF
IF gemvers>=&H1900 THEN
manf=@mxalloc(mtst,3)
ELSE
manf=MALLOC(mtst)
ENDIF
merkfrei=manf
IF manf>0 THEN
manf=INT(manf/4)*4+4
meml=manf
memh=meml+mtst-4
mlen=mtst-8
big=1
ELSE
ALERT 3,"Zu wenig freier Speicher !",1,"EXIT",g
gohome=TRUE
ENDIF
ENDIF
ENDIF
IF gohome=FALSE THEN
dat=((INT(anfload/2))*2)+2
cs=0
ce=mlen-1
vmem=INT(mlen/4)*4
DIM ls(lmax)
DIM le(lmax)
DIM lcs(lmax)
DIM lce(lmax)
DIM arrfn$(lmax2)
DIM arrpath$(lmax2)
DIM arrstrt(lmax2)
DIM arrend(lmax2)
DIM arrlen(lmax2)
DIM arrmidi(lmax2)
DIM midi(15,127)
DIM arrloop(lmax2)
DIM arrtri(lmax2)
DIM arrsrate(lmax2)
lmax3=500
DIM trkfn$(lmax3)
DIM trkpath$(lmax3)
DIM trktime(lmax3)
DIM trkvor(lmax3)
DIM trknext(lmax3)
DIM trkstrt(lmax3)
DIM trkend(lmax3)
DIM trklen(lmax3)
DIM trkloop(lmax3)
DIM trktri(lmax3)
DIM trksrate(lmax3)
DIM trkch(lmax3)
DIM trkpnt(8)
@markhlp
DIM dbank$(lmax4)
DIM dbank2$(lmax4)
DIM wurlnr(lmax4)
DIM cachep1(xm+100)
DIM cachep2(xm+100)
DIM cachem1(xm+100)
DIM cachem2(xm+100)
DIM mblocks(lmax3)
DIM mblocke(lmax3)
DIM mblockp$(lmax3)
loopz=6
DIM loops(loopz)
DIM loope(loopz)
DIM vloops(loopz)
DIM vloope(loopz)
bloopz=8
DIM bloops(bloopz)
DIM bloope(bloopz)
DIM vbloops(bloopz)
DIM vbloope(bloopz)
FOR i=1 TO bloopz
bloops(i)=-1
bloope(i)=-1
vbloops(i)=-1
vbloope(i)=-1
NEXT i
cwerte1=0
mbs=0
vmbs=0
n=60
FOR i=1 TO lmax2
arrmidi(i)=n
INC n
IF n>127 THEN
n=0
ENDIF
NEXT i
lz=1
smplen=mlen
ext2$=ext$
IF ext2$="*" THEN
ext2$="S16"
ENDIF
smpnam$="MEMORY."+ext2$
path$=lfw$+smpnam$
@maschinit9
@maschruf9(meml,memh)
retime=0
xmp=0
okmark=0
merkerr=0
merkfreq=0
protnr=0
lded=0
hrd=0
merk1=-1
merk2=-1
merk3=-1
merk4=-1
merkc=-1
prt=-1
plt=-1
prw=FALSE
plw=FALSE
zsf=TIMER
stl=0
sth=0
std=4
staes=0
@balwrite(vol,volinbal,balinmax)                                 ! Auf 0 db stellen
ENDIF
ENDIF
ELSE
ALERT 3,"Zu wenig freier Speicher !",1,"EXIT",g
gohome=TRUE
ENDIF
RETURN
'
> PROCEDURE setup2
.| Glob. Var.: vnr#,nr#,mrkhandle#,mrkhandle2#,v1#,v2#,v3#,stl#,sth#,std#
.|     zomslide&,zoombutt&,zmax#,zoomp#
.| Ruft auf  : makehz,fnamwrite,sethertz,write_reglow,write_reghigh
.|     write_dsp,slideinit,analog
.| Aufruf in : smpedit-1,
vnr=nr
@makehz
~WIND_GET(mrkhandle,10,mrkhandle2,v1,v2,v3)
@fnamwrite
@sethertz
@write_reglow(stl)
@write_reghigh(sth)
@write_dsp(std)
@slideinit(zomslide&,zoombutt&,zmax,16,zoomp)
@sourcein
RETURN
'
> PROCEDURE conmix
.| Glob. Var.: obj#
.| Ruft auf  : blkrestaura,setbutton
.| Aufruf in : do_blkf-1,
@blkrestaura
@setbutton(obj,0)
RETURN
'
> PROCEDURE conspace
.| Glob. Var.: vorvornr#,vornr#,nr#,cvobj#,obj#,space&,spc$,spc#,spacetxt&
.|     oldspc#,popup&,zu%,zuadr#,hlpspace&,exspace&,okspace&,spacel1&
.|     spacel2&,spacer1&,spacer2&,min#,sblock#,virtual#,conc#,virtln#,mlen#
.|     df#,hz#,inspace#,a#,virtpath$,virtwfile#,bytes#,vln#,meml#,memh#
.|     blkfunc&
.| Ruft auf  : markhlp,rsc_draw,textfeld,rsc_do,xrsrc_gaddr,helptxt
.|     setbutton,blkltest,makehz,coninsert,maschinit9,maschruf9,busy_mouse
.|     nomem,rsc_back
.| Aufruf in : do_blkf-1,
@markhlp
vorvornr=vornr
vornr=nr
cvobj=obj
nr=space&
@markhlp
@rsc_draw(nr,0)
spc$="00000"+STR$(spc)
spc$=RIGHT$(spc$,5)+CHR$(0)
@textfeld(spacetxt&,spc$,1)
oldspc=spc
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
IF obj=hlpspace& THEN
@helptxt("SPACE")
ENDIF
UNTIL obj=exspace& OR obj=okspace& OR obj=spacel1& OR obj=spacel2& OR obj=spacer1& OR obj=spacer2&
IF obj=spacer1& OR obj=spacer2& THEN
IF obj=spacer1& AND spc<9999 THEN
spc=spc+1
ENDIF
IF obj=spacer2& AND min<9995 THEN
spc=spc+5
ENDIF
spc$=RIGHT$("00000"+STR$(spc),5)+CHR$(0)
@textfeld(spacetxt&,spc$,1)
ENDIF
IF obj=spacel1& OR obj=spacel2& THEN
IF obj=spacel1& AND spc>1 THEN
spc=spc-1
ENDIF
IF obj=spacel2& AND spc>5 THEN
spc=spc-5
ENDIF
spc$=RIGHT$("00000"+STR$(spc),5)+CHR$(0)
@textfeld(spacetxt&,spc$,1)
ENDIF
@setbutton(obj,0)
UNTIL obj=exspace& OR obj=okspace&
IF obj=okspace& THEN
IF sblock=1 THEN
@blkltest
ELSE
IF virtual=TRUE THEN
conc=virtln
ELSE
conc=mlen
ENDIF
ENDIF
@makehz
df=spc*hz*4
IF virtual=FALSE THEN
inspace=TRUE
@coninsert
inspace=FALSE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF virtwfile=FALSE AND conc=virtln AND df>0 THEN
IF DFREE(a)>=df THEN
OPEN "U",#1,virtpath$
a=RINSTR(virtpath$,"\")
SEEK #1,virtln
bytes=INT(mlen/4)*4
vln=INT(df/4)*4
@maschinit9
IF df>mlen THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+df)
ENDIF
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
IF (virtwfile=TRUE OR (conc<virtln AND virtwfile=FALSE)) AND df>0 THEN
inspace=TRUE
@coninsert
inspace=FALSE
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@rsc_back(nr)
nr=vornr
vornr=vorvornr
IF nr=blkfunc& THEN
@setbutton(cvobj,0)
ENDIF
obj=0
RETURN
'
> PROCEDURE coninsert
.| Glob. Var.: vobj#,obj#,makevirt#,makevirt2#,inspace#,op$,ext$,mp$,nr#
.|     fil$,pbutt#,df#,sblock#,virtual#,conc#,virtln#,mlen#,loopz#,meml#
.|     vln#,cached#,a#,path$,workf$,workfile$,lfw$,dazu#,bytes#,mbytes#
.|     smpnam$,mbs#,smpedit&,hard&,virtpath$,virtwfile#,virtp$,virtfile$
.|     memh#
.| Felder    : loops#(),loope#()
.| Ruft auf  : fileselect,rsc_redraw_obj,blkltest,maschinit9,maschruf9
.|     setbutton,rettmem,nomem,busy_mouse,memtovirt
.| Aufruf in : do_blkf-1,conspace-2,
LOCAL okay,okay2
vobj=obj
makevirt=FALSE
makevirt2=FALSE
okay=FALSE
okay2=FALSE
IF inspace=FALSE THEN
@fileselect(op$+"*."+ext$,mp$,"INSERT:")
IF EXIST(fil$) AND pbutt=1 THEN
OPEN "I",#1,fil$
df=LOF(#1)
CLOSE #1
okay2=TRUE
ELSE
okay2=FALSE
ENDIF
IF sblock=1 THEN
@blkltest
ELSE
IF virtual=TRUE THEN
conc=virtln
ELSE
conc=mlen
ENDIF
ENDIF
ELSE
okay2=TRUE
ENDIF
IF virtual=FALSE AND okay2=TRUE AND df>0 THEN
IF sblock=1 AND conc+df<=mlen AND loops(loopz)>=0 AND loope(loopz)>0 AND (loope(loopz)+df)<=mlen THEN
IF conc<loope(loopz) THEN
BMOVE meml+conc,meml+conc+df,loope(loopz)-conc
ENDIF
vln=INT(df/4)*4
conc=INT(conc/4)*4
IF inspace=FALSE THEN
OPEN "I",#1,fil$
IF vln>3 THEN
BGET #1,meml+conc,vln
ENDIF
CLOSE #1
ELSE
@maschinit9
@maschruf9(meml+conc,meml+conc+vln)
ENDIF
cached=FALSE
ELSE
a=RINSTR(path$,"\")
IF a>0 THEN
workf$=LEFT$(path$,a)+workfile$
ELSE
workf$=lfw$+workfile$
ENDIF
a=ASC(LEFT$(workf$,1))-64
vln=INT(df/4)*4
df=vln
IF loops(loopz)>=0 AND loope(loopz)>loops(loopz) AND sblock=1 THEN
dazu=INT(loops(loopz)/4)*4
ELSE
dazu=0
ENDIF
IF loope(loopz)>0 AND loope(loopz)<=mlen AND sblock=1 THEN
bytes=(INT(loope(loopz)/4)*4)-dazu
ELSE
bytes=mlen-dazu
ENDIF
mbytes=bytes
conc=conc-dazu
IF conc<0 THEN
conc=0
ENDIF
IF conc>bytes THEN
conc=bytes
ENDIF
IF DFREE(a)>=mlen+vln THEN
OPEN "O",#1,workf$
BPUT #1,meml+dazu,bytes
CLOSE #1
virtual=TRUE
path$=workf$
smpnam$=workfile$
mbs=0
IF nr=smpedit& THEN
@setbutton(hard&,1)
ENDIF
makevirt=TRUE
virtln=bytes
conc=INT(conc/4)*4
okay2=TRUE
virtpath$=workf$
@rettmem
ELSE
@nomem
ENDIF
ENDIF
ENDIF
IF virtual=TRUE AND okay2=TRUE THEN
a=ASC(LEFT$(virtpath$,1))-64
IF virtwfile=FALSE AND conc=virtln AND df>0 AND inspace=FALSE THEN
IF DFREE(a)>=df THEN
OPEN "U",#1,virtpath$
a=RINSTR(virtpath$,"\")
OPEN "I",#2,fil$
SEEK #1,virtln
bytes=INT(mlen/4)*4
vln=INT(df/4)*4
makevirt2=TRUE
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #2,meml,bytes
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
CLOSE #1
CLOSE #2
ELSE
@nomem
makevirt2=FALSE
makevirt=FALSE
ENDIF
ELSE
IF DFREE(a)>=(virtln+df) AND df>0 THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
IF inspace=FALSE THEN
OPEN "I",#3,fil$
ENDIF
IF conc>0 AND conc<=virtln THEN
bytes=INT(mlen/4)*4
vln=INT(conc/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
ENDIF
IF inspace=TRUE THEN
@maschinit9
IF df>mlen THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+df)
ENDIF
ENDIF
bytes=INT(mlen/4)*4
vln=INT(df/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF inspace=FALSE THEN
BGET #3,meml,bytes
ENDIF
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
IF conc<virtln THEN
bytes=INT(mlen/4)*4
vln=INT((virtln-conc)/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
ENDIF
CLOSE #1
CLOSE #2
IF inspace=FALSE THEN
CLOSE #3
ENDIF
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
makevirt2=TRUE
ENDIF
ELSE
@nomem
makevirt2=FALSE
makevirt=FALSE
ENDIF
ENDIF
@memtovirt
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(vobj,0)
RETURN
'
> PROCEDURE memtovirt
.| Glob. Var.: makevirt#,makevirt2#,makevirt3#,path$,workf$,a#,smpnam$,vmem#
.|     mbytes#,df#,vmeml#,vmemh#,mlen#,hrd#,cached#,virtcurve#,vvv#,smplen#
.|     meml#,memh#,virtual#,blks#,vce#,vcs#,lz#,nr#,smpedit&,hard&,cs#,ce#
.| Ruft auf  : hardproof2,maschinit9,maschruf9,markdel,clsed,fnamwrite
.|     setbutton
.| Aufruf in : coninsert-1,
IF makevirt=TRUE OR makevirt2=TRUE OR makevirt3=TRUE THEN
IF makevirt=TRUE OR makevirt3=TRUE THEN
path$=workf$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
vmem=mbytes+df
ELSE
vmem=vmem+df
ENDIF
vmeml=0
vmemh=mlen
hrd=1
cached=FALSE
virtcurve=FALSE
IF vmem>mlen THEN
@hardproof2
vvv=TRUE
smplen=vmem
ELSE
IF vmem<mlen THEN
@maschinit9
@maschruf9(meml+vmem,memh)
ENDIF
IF makevirt=TRUE OR makevirt3=TRUE THEN
BLOAD workf$,meml
KILL workf$
ENDIF
vvv=FALSE
virtual=FALSE
cached=FALSE
smplen=vmem
vmem=mlen
ENDIF
blks=0
vce=0
vcs=0
lz=1
IF makevirt3=FALSE THEN
'     @rsc_back(nr)
'      nr=vornr
'    @rsc_draw(nr,5)
ENDIF
@markdel
@clsed
path$=workf$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@fnamwrite
IF nr=smpedit& THEN
IF vvv=TRUE THEN
@setbutton(hard&,1)
hrd=1
ELSE
@setbutton(hard&,0)
hrd=0
ENDIF
ENDIF
cs=0
ce=vmem
ELSE
cached=FALSE
ENDIF
makevirt=FALSE
makevirt2=FALSE
makevirt3=FALSE
RETURN
'
> PROCEDURE memtovirt2
.| Glob. Var.: vmeml#,vmemh#,mlen#,cached#,virtcurve#,vmem#,vvv#,smplen#
.|     meml#,memh#,makevirt#,makevirt3#,workf$,virtual#,blks#,vce#,vcs#,lz#
.|     nr#,vornr#,noblkdel#,smpedit&,hard&,hrd#,cs#,ce#
.| Ruft auf  : hardproof2,maschinit9,maschruf9,rsc_back,rsc_draw,markdel
.|     clsed,fnamwrite,setbutton
.| Aufruf in : fade_it-1,smpkhlp-1,smpmhlp-2,smpihlp-1,smpcut-2,virtmove-1
.|     virtcopy-1,virtins-1,mono-1,negate-1,lrchange-1,makenorm-1
.|     makeresmp-1,
vmeml=0
vmemh=mlen
cached=FALSE
virtcurve=FALSE
IF vmem>mlen THEN
@hardproof2
vvv=TRUE
smplen=vmem
ELSE
IF vmem<mlen THEN
@maschinit9
@maschruf9(meml+vmem,memh)
ENDIF
IF makevirt=TRUE OR makevirt3=TRUE THEN
BLOAD workf$,meml
KILL workf$
ENDIF
vvv=FALSE
virtual=FALSE
cached=FALSE
smplen=vmem
vmem=mlen
ENDIF
blks=0
vce=0
vcs=0
lz=1
IF makevirt3=FALSE THEN
@rsc_back(nr)
nr=vornr
@rsc_draw(nr,5)
ENDIF
IF noblkdel=FALSE THEN
@markdel
@clsed
ENDIF
@fnamwrite
IF nr=smpedit& THEN
IF vvv=TRUE THEN
@setbutton(hard&,1)
hrd=1
ELSE
@setbutton(hard&,0)
hrd=0
ENDIF
ENDIF
cs=0
ce=vmem
makevirt3=FALSE
RETURN
'
> PROCEDURE monitor
.| Glob. Var.: p#,mdat%,nr#,smpedit&,monitor&
.| Ruft auf  : digout,maschinit6,maschruf6,setbutton
.| Aufruf in : drop2-1,do_smpedit-1,do_peak-1,
p=mdat%
POKE p,7
POKE p+1,4
~XBIOS(25,1,L:p)
@digout(TRUE)
@maschinit6
@maschruf6
@digout(FALSE)
PAUSE 20
p=mdat%
POKE p,7
POKE p+1,0
~XBIOS(25,1,L:p)
IF nr=smpedit& THEN
@setbutton(monitor&,0)
ENDIF
RETURN
'
> PROCEDURE mono
.| Glob. Var.: virtual#,sblock#,meml#,memh#,mcs#,mce#,mono&,obj#,bytes#
.|     mlen#,virtwfile#,virtpath$,virtln#,virtp$,virtfile$,c1#,c2#,seekz#
.|     path$,smpnam$,vmem#,noblkdel#
.| Ruft auf  : maschinit17,maschruf17,blocklook,setbutton,busy_mouse
.|     hardproof3,memtovirt2,nomem,blkrestaura
.| Aufruf in : do_blkf-1,
LOCAL okay,a,vln,okay2
okay2=FALSE
@maschinit17
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf17(meml,memh)
ELSE
@blocklook
@maschruf17(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
'    @restaura
okay2=TRUE
@setbutton(mono&,0)
obj=0
ELSE
bytes=INT(mlen/4)*4
okay=FALSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
IF sblock=1 THEN
@blocklook
c1=INT(c1/4)*4
c2=INT(c2/4)*4
seekz=0
vln=c1
IF virtwfile=FALSE THEN
SEEK #1,seekz
ELSE
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
vln=c2-c1
seekz=c1
ELSE
vln=virtln
seekz=0
ENDIF
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschruf17(meml,meml+bytes)
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 AND virtwfile=TRUE THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
IF sblock=1 AND virtwfile=TRUE THEN
seekz=c2
vln=virtln-c2
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
ENDIF
@blkrestaura
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(mono&,0)
obj=0
RETURN
'
> PROCEDURE negate
.| Glob. Var.: virtual#,sblock#,meml#,memh#,mcs#,mce#,negate&,obj#,bytes#
.|     mlen#,virtwfile#,virtpath$,virtln#,virtp$,virtfile$,c1#,c2#,seekz#
.|     path$,smpnam$,vmem#,noblkdel#
.| Ruft auf  : maschinit34,maschruf34,blocklook,restaura,setbutton
.|     busy_mouse,hardproof3,memtovirt2,nomem,blkrestaura
.| Aufruf in : do_blkf-1,
LOCAL okay,a,vln,okay2
okay2=FALSE
@maschinit34
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf34(meml,memh)
ELSE
@blocklook
@maschruf34(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@restaura
okay2=TRUE
@setbutton(negate&,0)
obj=0
ELSE
bytes=INT(mlen/4)*4
okay=FALSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
IF sblock=1 THEN
@blocklook
c1=INT(c1/4)*4
c2=INT(c2/4)*4
seekz=0
vln=c1
IF virtwfile=FALSE THEN
SEEK #1,seekz
ELSE
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
vln=c2-c1
seekz=c1
ELSE
vln=virtln
seekz=0
ENDIF
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschruf34(meml,meml+bytes)
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 AND virtwfile=TRUE THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
IF sblock=1 AND virtwfile=TRUE THEN
seekz=c2
vln=virtln-c2
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
ENDIF
@blkrestaura
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(negate&,0)
obj=0
RETURN
'
> PROCEDURE lrchange
.| Glob. Var.: virtual#,sblock#,meml#,memh#,mcs#,mce#,lrchange&,obj#,bytes#
.|     mlen#,virtwfile#,virtpath$,virtln#,virtp$,virtfile$,c1#,c2#,seekz#
.|     path$,smpnam$,vmem#,noblkdel#
.| Ruft auf  : maschinit35,maschruf35,blocklook,restaura,setbutton
.|     busy_mouse,hardproof3,memtovirt2,nomem,blkrestaura
.| Aufruf in : do_blkf-1,
LOCAL okay,a,vln,okay2
okay2=FALSE
@maschinit35
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf35(meml,memh)
ELSE
@blocklook
@maschruf35(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@restaura
okay2=TRUE
@setbutton(lrchange&,0)
obj=0
ELSE
bytes=INT(mlen/4)*4
okay=FALSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
IF sblock=1 THEN
@blocklook
c1=INT(c1/4)*4
c2=INT(c2/4)*4
seekz=0
vln=c1
IF virtwfile=FALSE THEN
SEEK #1,seekz
ELSE
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
vln=c2-c1
seekz=c1
ELSE
vln=virtln
seekz=0
ENDIF
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschruf35(meml,meml+bytes)
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 AND virtwfile=TRUE THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
IF sblock=1 AND virtwfile=TRUE THEN
seekz=c2
vln=virtln-c2
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
bytes=INT(mlen/4)*4
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
ENDIF
@blkrestaura
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(lrchange&,0)
obj=0
RETURN
'
> PROCEDURE harddisk
.| Glob. Var.: hrd#
.| Aufruf in : do_smpedit-1,
IF hrd=0 THEN
hrd=1
ELSE
hrd=0
ENDIF
RETURN
'
> PROCEDURE midi
.| Glob. Var.: vornr#,nr#,midiedit&,db$,ch#,chtxt&,obj#,popup&,zu%,zuadr#,x#
.|     y#,v3#,but#,midicup&,midicdwn&,midinup&,midindwn&,midioup&,midiodwn&
.|     helpmidi&,midiok&,smpedit&,edmidi&
.| Ruft auf  : rsc_draw,markhlp,textfeld,makenote,rsc_do,xrsrc_gaddr,mouse
.|     channelup,channeldown,noteup,notedown,oktup,oktdown,helptxt,setbutton
.|     restaura2
.| Aufruf in : drop2-1,arrmidi-1,do_smpedit-1,
vornr=nr
nr=midiedit&
@rsc_draw(nr,0)
@markhlp
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(1,obj,zu%)
IF obj=midicup& THEN
@channelup
ENDIF
IF obj=midicdwn& THEN
@channeldown
ENDIF
IF obj=midinup& THEN
@noteup
ENDIF
IF obj=midindwn& THEN
@notedown
ENDIF
IF obj=midioup& THEN
@oktup
ENDIF
IF obj=midiodwn& THEN
@oktdown
ENDIF
IF obj=helpmidi& THEN
@helptxt("MIDI")
ENDIF
IF obj<>0 AND obj<>helpmidi& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=midiok&
@setbutton(obj,0)
@restaura2
obj=0
IF nr=smpedit& THEN
@setbutton(edmidi&,0)
ENDIF
RETURN
'
> PROCEDURE makefade
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=8
RETURN
'
> PROCEDURE channelup
.| Glob. Var.: ch#,db$,chtxt&
.| Ruft auf  : textfeld,makenote
.| Aufruf in : midi-1,
IF ch<16 THEN
ch=ch+1
ENDIF
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
RETURN
'
> PROCEDURE channeldown
.| Glob. Var.: ch#,db$,chtxt&
.| Ruft auf  : textfeld,makenote
.| Aufruf in : midi-1,
IF ch>1 THEN
ch=ch-1
ENDIF
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
RETURN
'
> PROCEDURE makenote
.| Glob. Var.: notetxt&,db$,midiwort#,ch#,note#
.| Ruft auf  : midinote,textfeld
.| Aufruf in : midi-1,channelup-1,channeldown-1,notedown-1,noteup-1
.|     oktdown-1,oktup-1,
@midinote
@textfeld(notetxt&,db$,1)
midiwort=(ch-1)*256+note
RETURN
'
> PROCEDURE midinote
.| Glob. Var.: o#,note#,n#,db$
.| Aufruf in : arrnrset-1,makenote-1,
o=INT(note/12)
n=note-o*12
IF n=0 THEN
IF o<3 THEN
db$="C "
ELSE
db$="c "
ENDIF
ENDIF
IF n=1 THEN
IF o<3 THEN
db$="C#"
ELSE
db$="c#"
ENDIF
ENDIF
IF n=2 THEN
IF o<3 THEN
db$="D "
ELSE
db$="d "
ENDIF
ENDIF
IF n=3 THEN
IF o<3 THEN
db$="D#"
ELSE
db$="d#"
ENDIF
ENDIF
IF n=4 THEN
IF o<3 THEN
db$="E "
ELSE
db$="e "
ENDIF
ENDIF
IF n=5 THEN
IF o<3 THEN
db$="F "
ELSE
db$="f "
ENDIF
ENDIF
IF n=6 THEN
IF o<3 THEN
db$="F#"
ELSE
db$="f#"
ENDIF
ENDIF
IF n=7 THEN
IF o<3 THEN
db$="G "
ELSE
db$="g "
ENDIF
ENDIF
IF n=8 THEN
IF o<3 THEN
db$="G#"
ELSE
db$="g#"
ENDIF
ENDIF
IF n=9 THEN
IF o<3 THEN
db$="A "
ELSE
db$="a "
ENDIF
ENDIF
IF n=10 THEN
IF o<3 THEN
db$="A#"
ELSE
db$="a#"
ENDIF
ENDIF
IF n=11 THEN
IF o<3 THEN
db$="B "
ELSE
db$="b "
ENDIF
ENDIF
IF o=0 THEN
db$=db$+"3"
ENDIF
IF o=1 THEN
db$=db$+"2"
ENDIF
IF o=2 THEN
db$=db$+"1"
ENDIF
IF o=3 THEN
db$=db$+"0"
ENDIF
IF o=4 THEN
db$=db$+"1"
ENDIF
IF o=5 THEN
db$=db$+"2"
ENDIF
IF o=6 THEN
db$=db$+"3"
ENDIF
IF o=7 THEN
db$=db$+"4"
ENDIF
IF o=8 THEN
db$=db$+"5"
ENDIF
IF o=9 THEN
db$=db$+"6"
ENDIF
IF o=10 THEN
db$=db$+"7"
ENDIF
db$=db$+CHR$(0)
RETURN
'
> PROCEDURE notedown
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf in : midi-1,
IF note>0 THEN
note=note-1
ENDIF
@makenote
RETURN
'
> PROCEDURE noteup
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf in : midi-1,
IF note<127 THEN
note=note+1
ENDIF
@makenote
RETURN
'
> PROCEDURE oktdown
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf in : midi-1,
IF (note-12)>=0 THEN
note=note-12
ENDIF
@makenote
RETURN
'
> PROCEDURE oktup
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf in : midi-1,
IF (note+12)<=127 THEN
note=note+12
ENDIF
@makenote
RETURN
'
> PROCEDURE machmidi
.| Glob. Var.: mamidi#
.| Aufruf in : do_smpedit-1,
IF mamidi=0 THEN
mamidi=1
ELSE
mamidi=0
ENDIF
RETURN
'
> PROCEDURE loopwahl
.| Glob. Var.: winh#,loop&,rsc_window&,vornr#,nr#,menuda#,sret#,forw&,backw&
.|     cross&,loopart&,g#,smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,markhlp,setbutton,setbutton2
.|     rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,loop&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=loop&
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
IF sret=0 THEN
@setbutton(forw&,1)
ENDIF
IF sret=1 THEN
@setbutton(backw&,1)
ENDIF
IF sret=2 THEN
@setbutton(cross&,1)
ENDIF
ELSE
@setbutton(loopart&,0)
ALERT 1,"Alle Fenster belegt|Bitte ein Fenster schlieûen !",1,"EXIT",g
ENDIF
ELSE
vornr=nr
nr=loop&
IF vornr=smpedit& THEN
@setbutton2(loopart&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_loop
.| Glob. Var.: obj#,helploop&,forw&,backw&,cross&,loopexit&,winh#,loop&,nr#
.|     smpedit&,loopart&
.| Ruft auf  : helptxt,loopfor,loopret,loopcross,setbutton,restaura2b
.| Aufruf in : windows-1,
IF obj=helploop& THEN
@helptxt("LOOPS")
ENDIF
IF obj=forw& THEN
@loopfor
ENDIF
IF obj=backw& THEN
@loopret
ENDIF
IF obj=cross& THEN
@loopcross
ENDIF
IF obj=loopexit& OR obj=9999 THEN
winh=BCLR(winh,loop&)
@setbutton(loopexit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(loopart&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE dspwahl
.| Glob. Var.: winh#,dspedit&,rsc_window&,vorvornr#,vornr#,nr#,menuda#
.|     swdsp&,g#
.| Ruft auf  : rsc_draw,markhlp,rsc_menu_ienable,setbutton
.| Aufruf in : drop2-1,do_main-1,do_smpedit-1,
IF BTST(winh,dspedit&)=FALSE THEN
IF rsc_window&<7 THEN
vorvornr=vornr
vornr=nr
nr=dspedit&
@rsc_draw(nr,7)
@markhlp
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
ELSE
@setbutton(swdsp&,0)
ALERT 1,"Alle Fenster belegt|Bitte ein Fenster schlieûen !",1,"EXIT",g
ENDIF
ELSE
vornr=nr
nr=dspedit&
IF vornr=smpedit& THEN
@setbutton2(swdsp&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_dsp
.| Glob. Var.: obj#,dspload&,dspsave&,dsphall&,dspecho&,dspret&,dspeq&
.|     helpdsp&,dspexit&,winh#,dspedit&,vornr#,vorvornr#,nr#,smpedit&,swdsp&
.| Ruft auf  : setbutton,helptxt,restaura2
.| Aufruf in : windows-1,
IF obj=dspload& THEN
@dsp_lodload
@setbutton(dspload&,0)
ENDIF
IF obj=dspsave& THEN
PAUSE 2
@setbutton(dspsave&,0)
ENDIF
IF obj=dsphall& THEN
PAUSE 2
@setbutton(dsphall&,0)
ENDIF
IF obj=dspecho& THEN
@dspecho
@setbutton(dspecho&,0)
ENDIF
IF obj=dsppass& THEN
@dsppassthru
@setbutton(dsppass&,0)
ENDIF
IF obj=dspflang& THEN
@dspflanger
@setbutton(dspflang&,0)
ENDIF
IF obj=dspband& THEN
PAUSE 2
@setbutton(dspband&,0)
ENDIF
IF obj=dsphigh& THEN
PAUSE 2
@setbutton(dsphigh&,0)
ENDIF
IF obj=dsplow& THEN
@dsplow
@setbutton(dsplow&,0)
ENDIF
IF obj=dspeq& THEN
PAUSE 2
@setbutton(dspeq&,0)
ENDIF
IF obj=dsppink& THEN
@dsp_pink
@setbutton(dsppink&,0)
ENDIF
IF obj=dspchor& THEN
PAUSE 2
@dspchorus
@setbutton(dspchor&,0)
ENDIF
IF obj=helpdsp& THEN
@helptxt("DSP")
ENDIF
IF obj=dspexit& OR obj=9999 THEN
winh=BCLR(winh,dspedit&)
@setbutton(dspexit&,0)
@restaura2
vornr=vorvornr
obj=0
IF nr=smpedit& THEN
@setbutton(swdsp&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE dspecho
echo:
DATA "_START ECHO3 0000 0000 0000 DSP56000 5.3.2"
DATA "_DATA P 0000"
DATA "0C0040"
DATA "_DATA P 000C"
DATA "0BF080 000074 0BF080 000074 0BF080 00007D 0BF080 00007D"
DATA "_DATA P 0040"
DATA "08F4BD 261009 08F4BE 000000 0003F8 0500BB 0500BA 364000"
DATA "05F426 FFFFFF"
DATA "_DATA P 004A"
DATA "240000 441200 241000 441300 08F4A1 000000 08F4A3 000000"
DATA "08F4AC 004000 08F4AD 00F200 08F4BF 003000 08F4A1 00FFE8"
DATA "00FCB8"
DATA "_DATA P 005B"
DATA "64F400 004000 05F424 003FFF 0AAEA0 00005F 0AAE80 000061"
DATA "0AAEA6 000063 568100 578000 44E422 4EE42A 200040 200058"
DATA "200022 200022 20002A 20002A 566400 5F5C00 561100 571000"
DATA "0C005F"
DATA "_DATA P 0074"
DATA "605E00 300100 0AAEA0 00007A 300000 000000 0858AF 60FE00"
DATA "000004 605E00 301100 0AAEA0 000083 301000 000000 08D8AF"
DATA "60FE00 000004"
DATA "_END 0000"
'
@dsp_boot
RESTORE echo
@load_dsp_prog(23)   ! Anzahl der DATA-Zeilen
RETURN
'
> PROCEDURE dspflanger
flanger:
DATA "_START FLANGE 0000 0000 0000 DSP56000 5.3.2"
DATA "_DATA P 0000"
DATA "0C0040"
DATA "_DATA P 000C"
DATA "0BF080 000078 0BF080 000078 0BF080 000081 0BF080 000081"
DATA "_DATA P 0040"
DATA "08F4BD 261009 08F4BE 000000 0003F8 0500BB 0500BA 364000"
DATA "05F426 FFFFFF"
DATA "_DATA P 004A"
DATA "240000 441200 241000 441300 08F4A1 000000 08F4A3 000000"
DATA "08F4AC 004000 08F4AD 00F200 08F4BF 003000 08F4A1 00FFE8"
DATA "00FCB8"
DATA "_DATA P 005B"
DATA "61F400 002000 05F421 000FFF 71F400 FFFFDF 65F400 000000"
DATA "64F400 000004 0501A5 0501A4 0AAEA0 000067 0AAE80 000069"
DATA "0AAEA6 00006B 568100 578000 565D00 575D00 56DC00 57DC00"
DATA "561100 571000 0BF080 00009A 0C0067"
DATA "_DATA P 0078"
DATA "605E00 300100 0AAEA0 00007E 300000 000000 0858AF 60FE00"
DATA "000004 605E00 301100 0AAEA0 000087 301000 000000 08D8AF"
DATA "60FE00 000004"
DATA "_DATA P 008A"
DATA "520700 540600 580600 420A00 530900 550800 590800 430B00"
DATA "00000C 488600 528700 428A00 498800 538900 438B00 00000C"
DATA "0D008A 253813 27401B 46A400 44F400 59999A 2000D3 2000D3"
DATA "246000 4480DB 21E6CB 5704A3 20CF00 44813E 2000CB 5705A3"
DATA "565900 48A000 42A100 200020 482000 219900 20AF00 5EA000"
DATA "248023 254042 218400 2000A4 21C60B 0AF0A3 0000C2 205100"
DATA "44E900 2F40D0 20595C 21E600 44E900 2000D2 0AF080 0000C8"
DATA "44E900 2F40D0 20595C 21E600 44E900 2051D2 562400 56A300"
DATA "44F400 000001 200044 562300 0AF0A7 0000D4 44A200 48A100"
DATA "442336 482100 0D0093 00000C"
DATA "_DATA X 0020"
DATA "ffffdf"
DATA "_DATA Y 0020"
DATA "000000"
DATA "_DATA X 0021"
DATA "000000"
DATA "_DATA Y 0021"
DATA "005730"
DATA "_DATA X 0022"
DATA "023D70 000000 000000"
DATA "_DATA X 0000"
DATA "000000 000000 000000 000000 000000 000000 000000 000000"
DATA "000000 000000 000000 000000"
DATA "_END 0000"
'
@dsp_boot
RESTORE flanger
@load_dsp_prog(46)   ! Anzahl der DATA-Zeilen
RETURN
'
> PROCEDURE dsplow
lowpass:
DATA "_START TEST 0000 0000 0000 DSP56000 5.3.2 "
DATA "_DATA X 0020"
DATA "00797D 400000 00F2FB 6ABB63 00797D D35EA5 009EFA 400000 "
DATA "013DF4 6EDE0A 009EFA CEA60D "
DATA "_BLOCKDATA Y 0010 0004 000000"
DATA "_BLOCKDATA Y 0014 0004 000000"
DATA "_DATA P 0000"
DATA "0C0040 "
DATA "_DATA P 000C"
DATA "0BF080 000083 0BF080 000083 0BF080 00008C 0BF080 00008C "
DATA "_DATA P 0040"
DATA "08F4BD 261009 08F4BE 000000 0003F8 0500BB 0500BA 364000 "
DATA "05F426 FFFFFF "
DATA "_DATA P 004A"
DATA "240000 441200 241000 441300 08F4A1 000000 08F4A3 000000 "
DATA "08F4AC 004000 08F4AD 00F200 08F4BF 003000 08F4A1 00FFE8 "
DATA "00FCB8 "
DATA "_DATA P 005B"
DATA "0AAEA0 00005B 0AAE80 00005D 0AAEA6 00005F 568100 578000 "
DATA "0BF080 000068 561100 571000 0C005B 301400 0BF080 000073 "
DATA "5E1800 21EE00 301000 0BF080 000073 21CF00 5E9800 00000C "
DATA "05F420 00FFFF 0464A0 0008F8 342022 12D800 45DC22 E49CA3 "
DATA "159CE0 45DCA2 45DCF3 B69CA0 2000F3 B29C71 00F3B8 00000C "
DATA "_DATA P 0083"
DATA "605E00 300100 0AAEA0 000089 300000 000000 0858AF 60FE00 "
DATA "000004 605E00 301100 0AAEA0 000092 301000 000000 08D8AF "
DATA "60FE00 000004 "
DATA "_END 0000"
'
@dsp_boot
RESTORE lowpass
@load_dsp_prog(28)   ! Anzahl der DATA-Zeilen
RETURN
'
> PROCEDURE dsppassthru
passthru:
DATA "_START PASSTHRU 0000 0000 0000 DSP56000 5.3.2"
DATA "_DATA P 0000"
DATA "0c0040"
DATA "_DATA P 000C"
DATA "0BF080 000066 0BF080 000066 0BF080 00006F 0BF080 00006F"
DATA "_DATA P 0040"
DATA "08F4BD 261009 08F4BE 000000 0003F8 0500BB 0500BA 364000"
DATA "05F426 FFFFFF"
DATA "_DATA P 004A"
DATA "240000 441200 241000 441300 08F4A1 000000 08F4A3 000000"
DATA "08F4AC 004000 08F4AD 00F200 08F4BF 003000 08F4A1 00FFE8"
DATA "00fcb8"
DATA "_DATA P 005B"
DATA "0AAEA0 00005B 0AAE80 00005D 0AAEA6 00005F 568100 578000"
DATA "561100 571000 0C005B"
DATA "_DATA P 0066"
DATA "605E00 300100 0AAEA0 00006C 300000 000000 0858AF 60FE00"
DATA "000004 605E00 301100 0AAEA0 000075 301000 000000 08D8AF"
DATA "60FE00 000004"
DATA "_END 0000"
'
@dsp_boot
RESTORE passthru
@load_dsp_prog(20)   ! Anzahl der DATA-Zeilen
RETURN
'
> PROCEDURE dspchorus
chorus:
DATA "_START CHORUS 0000 0000 0000 DSP56000 5.3.2"
DATA "_DATA P 0000"
DATA "0c0040"
DATA "_DATA P 000C"
DATA "0BF080 000080 0BF080 000080 0BF080 00008B 0BF080 00008B"
DATA "_DATA P 0040"
DATA "08F4BD 261009 08F4BE 000000 0003F8 0500BB 0500BA 364000"
DATA "05F426 FFFFFF 61F400 002000 05F421 000FFF 71F400 FFFF7E"
DATA "65F400 000000 64F400 000004 0501A5 0501A4"
DATA "_DATA P 0056"
DATA "44F400 000100 447000 000112 44F400 000110 447000 000113"
DATA "08F4A1 000000 08F4A3 000000 08F4AC 004000 08F4AD 00F200"
DATA "08F4BF 003000 08F4A1 00FFE8 00FCB8"
DATA "_DATA P 006B"
DATA "0AAEA0 00006B 0AAE80 00006D 0AAEA6 00006F 56F000 000101"
DATA "57F000 000100 565D00 575D00 56DC00 57DC00 567000 000111"
DATA "577000 000110 0BF080 0000A6 0C006B"
DATA "_DATA P 0080"
DATA "605E00 60F400 000101 0AAEA0 000088 60F400 000100 000000"
DATA "0858AF 60FE00 000004 605E00 60F400 000111 0AAEA0 000093"
DATA "60F400 000110 000000 08D8AF 60FE00 000004"
DATA "_DATA P 0096"
DATA "520700 540600 580600 420A00 530900 550800 590800 430B00"
DATA "00000C 488600 528700 428A00 498800 538900 438B00 00000C"
DATA "0D0096 253813 27401B 46A400 4480BB 21E6CB 5704A3 20CF00"
DATA "44813E 2000CB 5705A3 565900 48A000 42A100 200020 482000"
DATA "219900 20AF00 5EA000 248023 254042 218400 2000A4 21C60B"
DATA "0AF0A3 0000C9 205100 44E900 2F40D0 20595C 21E600 44E900"
DATA "2000D2 0AF080 0000CF 44E900 2F40D0 20595C 21E600 44E900"
DATA "2051D2 562400 56A300 44F400 000001 200044 562300 0AF0A7"
DATA "0000DB 44A200 48A100 442336 482100 0D009F 00000C"
DATA "_DATA X 0020"
DATA "ffff7e"
DATA "_DATA Y 0020"
DATA "000000"
DATA "_DATA X 0021"
DATA "000000"
DATA "_DATA Y 0021"
DATA "013a93"
DATA "_DATA X 0022"
DATA "027BBE 000000 000000"
DATA "_DATA X 0000"
DATA "000000 000000 000000 000000 000000 000000 000000 000000"
DATA "000000 000000 000000 000000"
DATA "_END 0000"
'
@dsp_boot
RESTORE chorus
@load_dsp_prog(45)   ! Anzahl der DATA-Zeilen
RETURN
'
> PROCEDURE dsp_pink
pink:
DATA "_START PINK 0000 0000 0000 DSP56000 5.3.2"
DATA "_DATA X 0010"
DATA "000001"
DATA "_DATA X 0000"
DATA "000000 000000 000000 000000 000000 000000 000000 000000"
DATA "000000 000000 000000 000000"
DATA "_DATA P 0000"
DATA "0c0040"
DATA "_DATA P 000C"
DATA "0BF080 000098 0BF080 000098 0BF080 0000A1 0BF080 0000A1"
DATA "_DATA P 0040"
DATA "08F4BD 261009 08F4BE 000000 0003F8 0500BB 0500BA 364000"
DATA "05F426 FFFFFF 44F400 FEEDEE 441000 65F400 000000 64F400"
DATA "000004 0501A5 0501A4"
DATA "_DATA P 0053"
DATA "246000 447000 000063 247000 447000 000062 08F4A1 000000"
DATA "08F4A3 000000 08F4AC 004000 08F4AD 00F200 08F4BF 003000"
DATA "08F4A1 00FFE8 00FCB8"
DATA "_DATA P 0066"
DATA "0AAEA0 000066 0AAE80 000068 0AAEA6 00006A 568500 578400"
DATA "567000 000051 577000 000050 0BF080 000085 0C0066 520700"
DATA "540600 580600 420A00 530900 550800 590800 430B00 00000C"
DATA "488600 528700 428A00 498800 538900 438B00 00000C 0D0075"
DATA "0BF080 0000AA 45F400 00A3D7 47F400 7EB852 21C400 4484A1"
DATA "2000C3 560400 0BF080 0000AA 21C400 4485A1 2000C3 560500"
DATA "0D007E 00000C"
DATA "_DATA P 0098"
DATA "605E00 306100 0AAEA0 00009E 306000 000000 0858AF 60FE00"
DATA "000004 605E00 305100 0AAEA0 0000A7 305000 000000 08D8AF"
DATA "60FE00 000004"
DATA "_DATA P 00AA"
DATA "56901B 44F403 000001 02C048 200010 200032 541000 00000C"
DATA "_END 0000"
'
@dsp_boot
RESTORE pink
@load_dsp_prog(33)   ! Anzahl der DATA-Zeilen
RETURN
'
> PROCEDURE load_dsp_prog(len)
LOCAL a$,i,j,a
IF break=FALSE THEN
FOR i=1 TO len
READ a$
FOR j=1 TO LEN(a$)
a=ASC(MID$(a$,j,1))
@lodtohi(a)
EXIT IF break=TRUE
NEXT j
@lodtohi(13)
@lodtohi(10)
EXIT IF break=TRUE
NEXT i
ENDIF
RETURN
'
> PROCEDURE loopauto
.| Aufruf in : do_smpedit-1,
'  @setbutton(loopauto&,0)
RETURN
'
> PROCEDURE loopfor
.| Glob. Var.: sret#
.| Aufruf in : do_loop-1,
sret=0
RETURN
'
> PROCEDURE loopret
.| Glob. Var.: sret#
.| Aufruf in : do_loop-1,
sret=1
RETURN
'
> PROCEDURE loopcross
.| Glob. Var.: sret#
.| Aufruf in : do_loop-1,
sret=2
RETURN
'
> PROCEDURE normadj
.| Glob. Var.: grenz#,db#,aufloes#
.| Ruft auf  : makenorm
.| Aufruf in : normalize-1,
grenz=(db+aufloes)/20
grenz=10^grenz
IF grenz>32767 THEN
grenz=32767
ENDIF
grenz=INT(grenz)
@makenorm
RETURN
'
> PROCEDURE normauto
.| Glob. Var.: db#,grenz#
.| Ruft auf  : makenorm
.| Aufruf in : normalize-1,
db=0
grenz=32767
@makenorm
RETURN
'
> PROCEDURE makenorm
.| Glob. Var.: virtual#,sblock#,meml#,b#,memh#,mcs#,mce#,c2#,c1#,sms#,sme#
.|     ce#,xm#,grenz#,back%,makecurve#,virtln#,bytes#,mlen#,virtwfile#
.|     virtpath$,virtp$,virtfile$,seekz#,path$,smpnam$,vmem#,noblkdel#
.| Ruft auf  : maschinit13,blocklook,maschruf13,hardproof3,memtovirt2,nomem
.| Aufruf in : normadj-1,normauto-1,
LOCAL okay,a,vln
@maschinit13
IF virtual=FALSE THEN
IF sblock=0 THEN
a=meml
b=memh
ELSE
@blocklook
a=mcs
b=mce
ENDIF
IF sblock=0 OR (sblock=1 AND c2>c1 AND mce<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0) THEN
@maschruf13(a,b,grenz,back%)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
makecurve=1
ENDIF
ELSE
a=meml
b=memh
vln=virtln
bytes=INT(mlen/4)*4
okay=FALSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
seekz=0
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
@maschruf13(meml,meml+bytes,grenz,back%)
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
makecurve=1
ELSE
@nomem
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
RETURN
'
> PROCEDURE normtest
.| Glob. Var.: virtual#,sblock#,meml#,memh#,mcs#,mce#,back%,db#,aufloes#
.|     vln#,virtln#,bhold#,bytes#,virtpath$,mlen#,db$,normdb&
.| Ruft auf  : maschinit12,maschruf12,blocklook,textfeld
.| Aufruf in : normalize-1,
@maschinit12
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf12(meml,memh)
ELSE
@blocklook
@maschruf12(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF back%>0 THEN
mdb=back%
mdb=20*LOG10(mdb)
mdb=mdb-aufloes
mdb=INT(mdb*100)/100
ELSE
back%=32767
mdb=0
ENDIF
ELSE
vln=virtln
bhold=0
bytes=0
OPEN "I",#1,virtpath$
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/4)*4
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschruf12(meml,meml+bytes)
ENDIF
vln=vln-bytes
IF back%>bhold THEN
bhold=back%
ENDIF
UNTIL vln<4
CLOSE #1
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF bhold>0 THEN
mdb=bhold
mdb=20*LOG10(mdb)
mdb=mdb-aufloes
mdb=INT(mdb*100)/100
ELSE
bhold=32767
mdb=0
ENDIF
back%=bhold
ENDIF
db$=STR$(mdb)+CHR$(0)
@textfeld(maxdb&,db$,1)
RETURN
'
> PROCEDURE norml
.| Glob. Var.: norma#,auflh#,aufloes#,dbx#,db#,obj#,norml1&,nz#,norml2&
.|     norml3&,db$,normdb&
.| Ruft auf  : textfeld
.| Aufruf in : normalize-1,
IF norma=0 THEN
auflh=INT(0-(aufloes*100))
dbx=INT(db*100)
IF obj=norml1& THEN
nz=2
ENDIF
IF obj=norml2& THEN
nz=20
ENDIF
IF obj=norml3& THEN
nz=400
ENDIF
dbx=dbx-nz
IF dbx>=auflh THEN
db=INT(dbx)/100
ENDIF
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
ENDIF
RETURN
'
> PROCEDURE normr
.| Glob. Var.: norma#,dbx#,db#,obj#,normr1&,nz#,normr2&,normr3&,t#,db$
.|     normdb&
.| Ruft auf  : textfeld
.| Aufruf in : normalize-1,
IF norma=0 THEN
dbx=INT(db*100)
IF obj=normr1& THEN
nz=2
ENDIF
IF obj=normr2& THEN
nz=20
ENDIF
IF obj=normr3& THEN
nz=400
ENDIF
t=1
dbx=dbx+nz
IF t>dbx THEN
db=INT(dbx)/100
ENDIF
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
ENDIF
RETURN
'
> PROCEDURE resl
.| Glob. Var.: obj#,resl1&,nz#,resl2&,resl3&,t#,resoth#,db$,resother&
.| Ruft auf  : textfeld
.| Aufruf in : resample-1,arrsmpr-1,
IF obj=resl1& THEN
nz=0.1
ENDIF
IF obj=resl2& THEN
nz=1
ENDIF
IF obj=resl3& THEN
nz=5
ENDIF
t=5
IF (resoth-nz)>=t THEN
resoth=resoth-nz
ENDIF
resoth=INT(resoth*10)/10
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
RETURN
'
> PROCEDURE resr
.| Glob. Var.: obj#,resr1&,nz#,resr2&,resr3&,t#,resoth#,db$,resother&
.| Ruft auf  : textfeld
.| Aufruf in : resample-1,arrsmpr-1,
IF obj=resr1& THEN
nz=0.1
ENDIF
IF obj=resr2& THEN
nz=1
ENDIF
IF obj=resr3& THEN
nz=5
ENDIF
t=96
IF (resoth+nz)<=t THEN
resoth=resoth+nz
ENDIF
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
RETURN
'
> PROCEDURE resoth32
.| Glob. Var.: resoth#,db$,resother&,res32&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : resample-1,arrsmpr-1,
resoth=32
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
@setbutton(res32&,0)
RETURN
'
> PROCEDURE resoth44
.| Glob. Var.: resoth#,db$,resother&,res44&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : resample-1,arrsmpr-1,
resoth=44.1
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
@setbutton(res44&,0)
RETURN
'
> PROCEDURE resoth48
.| Glob. Var.: resoth#,db$,resother&,res48&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : resample-1,arrsmpr-1,
resoth=48
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
@setbutton(res48&,0)
RETURN
'
> PROCEDURE makeresmp
.| Glob. Var.: e#,resorig#,f#,resoth#,bedarf#,virtual#,sblock#,a#,meml#,b#
.|     memh#,c#,d#,back%,adjresmp#,hz#,hzm#,retime#,makecurve#,drittel#
.|     ldlen#,mcs#,mce#,virtln#,bytes#,mlen#,virtpath$,virtp$,virtfile$
.|     seekz#,seekz2#,virtwfile#,path$,smpnam$,vmem#
.| Ruft auf  : maschinit16,maschruf16,maschinit9,maschruf9,maschinit10
.|     maschruf10,blocklook,hardproof3,memtovirt2,nomem
.| Aufruf in : resample-1,
LOCAL okay,vln
@maschinit16
e=INT(resorig*10)
f=INT(resoth*10)
bedarf=f/e
IF virtual=FALSE THEN
IF sblock=0 THEN
IF bedarf<=1 THEN
a=meml
b=memh
c=meml
d=memh
@maschruf16(a,b,c,d,e,f)
IF back%<memh AND back%>meml THEN
@maschinit9
@maschruf9(back%,memh-4)
ENDIF
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
ELSE
a=meml
drittel=(memh-meml)/(e+f)*e
IF drittel>15 THEN
drittel=drittel-8
ENDIF
IF ldlen=0 OR (ldlen<>0 AND ldlen<=drittel) THEN
drittel=drittel+meml
drittel=INT(drittel/4)*4
b=drittel
c=drittel
d=memh
@maschruf16(a,b,c,d,e,f)
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
@maschinit10
@maschruf10(c,d,meml,memh)
@maschinit9
b=INT((d-c)/4)*4
@maschruf9(meml+b,d)
ELSE
ALERT 3,"Zu wenig Speicher !|Bitte Block verkleinern !",1,"OK",a
ENDIF
ENDIF
ELSE
@blocklook
a=mcs
b=mce
drittel=(memh-meml)/(mce-mcs)
IF bedarf<=1 THEN
c=mcs
d=mce
@maschruf16(a,b,c,d,e,f)
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
IF back%<mce AND back%>mcs THEN
@maschinit9
@maschruf9(back%,mce)
ENDIF
ELSE
IF mce+4<memh AND drittel>=bedarf THEN
c=mce
d=memh-4
@maschruf16(a,b,c,d,e,f)
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
@maschinit10
@maschruf10(c,d,mcs,memh-4)
@maschinit9
b=INT((d-c)/4)*4
@maschruf9(mcs+b,d)
ELSE
ALERT 3,"Zu wenig Speicher !|Bitte Block verkleinern !",1,"OK",a
ENDIF
ENDIF
ENDIF
ELSE                      ! virtual=true
vln=virtln
bytes=INT(mlen/4)*4
okay=FALSE
drittel=(memh-meml)/(e+f)*e
drittel=INT(drittel/4)*4
IF drittel>15 THEN
drittel=drittel-8
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
IF okay=TRUE THEN
seekz=0
seekz2=0
REPEAT
IF vln>=bytes THEN
IF bedarf<=1 THEN
bytes=INT(mlen/4)*4
ELSE
bytes=drittel
ENDIF
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
a=meml
b=meml+bytes
IF bedarf<=1 THEN
c=meml
ELSE
c=meml+bytes
ENDIF
d=memh
@maschruf16(a,b,c,d,e,f)
back%=INT(back%/4)*4
BPUT #2,c,back%-c
ENDIF
vln=vln-bytes
seekz=seekz+bytes
seekz2=seekz2+(back%-c)
UNTIL vln<4
CLOSE #1
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/4)*4
@memtovirt2
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
ELSE
hz=resorig*1000
retime=0
makecurve=0
ENDIF
ELSE
@nomem
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE nomem
.| Glob. Var.: g#,nomem#
.| Aufruf in : fade_it-1,fadesave-1,smpkhlp-1,smpmhlp-9,smpihlp-2,smpcut-1
.|     virtmove-1,virtcopy-1,virtins-1,putpix-1,edhandler2-1,sdsave-2
.|     smpsave-4,infsave-1,rettmem-2,arrsave-1,make-1,setsave-1,conspace-1
.|     coninsert-3,mono-1,negate-1,lrchange-1,makenorm-1,makeresmp-1,
ALERT 1,"Zu wenig Platz|auf dem Speichermedium !",1,"EXIT",g
nomem=TRUE
RETURN
'
> PROCEDURE makevoldb(vdb)
.| Glob. Var.: vol#,a$
.| Aufruf in : peak-1,do_peak-1,
LOCAL v
IF vdb<128+64 THEN
v=32-(vdb/3*2)
ELSE
v=32/127*(255-vdb)
ENDIF
v=(vdb-(128+64))/2
a$=STR$(v)
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
a=v
RETURN
'
> PROCEDURE peak
.| Glob. Var.: winh#,peak&,rsc_window&,vornr#,nr#,distx#,distx2#,disty#,wx#
.|     wy#,wymax#,peakint#,vpl#,pl#,vpr#,pr#,zu%,vol#,peakdb&,a$,pymax#
.|     volbox&,vp#,volume&,xwidth#,ywidth#,mute#,peaksw2&,g#,smpedit&
.|     edit_obj&,idx&
.| Ruft auf  : rsc_draw,markhlp,peakread,xrsrc_gaddr,fifodel,volwrite
.|     makevoldb,textfeld,setbutton,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,peak&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=peak&
@rsc_draw(nr,7)
xbmagic=XBIOS(500)
winh=BSET(winh,nr)
@markhlp
GRAPHMODE 1
DEFLINE 1
prt=-1
plt=-1
prw=FALSE
plw=FALSE
'      @setbutton(peakl&,0)
'     @setbutton(peakr&,0)
distx=10
distx2=distx+72
disty=217
wx=31
wy=1
wymax=187
peakint=FALSE
@peakread
vpl=pl
vpr=pr
~@xrsrc_gaddr(0,nr,zu%)
@fifodel
px=volinbal
@makevoldb(vol)
@textfeld(peakdb&,a$,1)
pxmax=DPEEK(zu%+24*balbox&+20)                    ! Breite der Balancebox in Pixeln
pxmax=INT((pxmax-15)/2)
balinmax=pxmax
pymax=DPEEK(zu%+24*volbox&+22)                    ! Hîhe der Volumebox in Pixeln
pymax=pymax-15
IF vol<128+64 THEN
vp=pymax-(vol/3*2)
ELSE
vp=pymax/127*(255-vol)
ENDIF
DPOKE (zu%+24*volume&+18),vp                      ! Volume-Slider positionieren
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~OBJC_DRAW(zu%,volbox&,1,0,0,xwidth,ywidth)       ! neu zeichnen
~WIND_UPDATE(0)                                   ! BEG_UPDATE
mute=FALSE
@balwrite(vol,px,pxmax)
@makevoldb(lbal)
b=a
@makevoldb(rbal)
a$=STR$(ABS(b-a))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
DPOKE (zu%+24*balance&+16),px+pxmax              ! Horizontalposition des Balance-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,1,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ELSE
@setbutton(peaksw2&,0)
ALERT 1,"Alle Fenster belegt|Bitte ein Fenster schlieûen !",1,"EXIT",g
ENDIF
ELSE
vornr=nr
nr=peak&
IF vornr=smpedit& THEN
@setbutton2(peaksw2&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_peak
.| Glob. Var.: peakint#,peak&,zu%,obj#,smpautop&,smpstrtp&,monitorp&
.|     peakmute&,mute#,vol#,volume&,zu2%,opy#,noppause#,x#,y#,k#,py#,yd#
.|     pymax#,peakdb&,a$,volbox&,xwidth#,ywidth#,peakexit&,winh#,nr#
.|     smpedit&,peaksw2&
.| Ruft auf  : xrsrc_gaddr,markhlp,smpauto,smpstart,monitor,volwrite
.|     setbutton,mousey,peakwert,mouse,makevoldb,textfeld,peakread,mousek
.|     restaura2b
.| Aufruf in : windows-1,
peakint=FALSE
~@xrsrc_gaddr(0,peak&,zu%)
GRAPHMODE 1
DEFLINE 1
peakrd=FALSE
IF obj=smpautop& THEN
@setbutton(obj,1)
'    nr=smpedit&
'    @rsc_redraw_obj(nr,0)
@markhlp
peakrd=TRUE
@smpauto
peakrd=FALSE
peakint=FALSE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF obj=smpstrtp& THEN
@setbutton(obj,1)
'    nr=smpedit&
'    @rsc_redraw_obj(nr,0)
@markhlp
peakrd=TRUE
@smpstart
peakrd=FALSE
peakint=FALSE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF obj=monitorp& THEN
@setbutton(obj,1)
@write_int(0)
@monitor
@write_int(2)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(monitorp&,0)
ENDIF
@peakwork
IF obj=9999 OR obj=peakexit& THEN
IF XBIOS(500)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
peakint=FALSE
ENDIF
@setbutton(peakexit&,0)
winh=BCLR(winh,peak&)
@restaura2b
IF nr=smpedit& THEN
@setbutton(peaksw2&,0)
ENDIF
ENDIF
obj=0
peakmrk=nr
RETURN
'
> PROCEDURE peakwork
IF obj=peakmute& THEN
IF mute=FALSE THEN
mute=TRUE
ELSE
mute=FALSE
ENDIF
IF mute=TRUE THEN
@volwrite(0)
@setbutton(peakmute&,1)
ELSE
@balwrite(vol,px,pxmax)
@setbutton(peakmute&,0)
ENDIF
obj=0
ENDIF
IF obj=balzero& THEN
@setbutton(balzero&,1)
px=0
volinbal=0
DPOKE (zu%+24*balance&+16),px+pxmax              ! Horizontalposition des Balance-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,1,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
@balwrite(vol,px,pxmax)
@makevoldb(lbal)
b=a
@makevoldb(rbal)
a$=STR$(ABS(b-a))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
PAUSE 1
@setbutton(balzero&,0)
REPEAT
UNTIL @mousek=0
obj=0
ENDIF
IF obj=balance& THEN
~@xrsrc_gaddr(1,obj,zu2%)
opx=@mousex
~GRAF_MOUSE(256,0)                              ! Hidem
REPEAT
noppause=TRUE
IF xbmagic<>&H71273800 THEN
@peakwert
ENDIF
@mouse(x,y,k)
IF opx<>x THEN
opx=x
pxv=x-xd-149
IF ABS(pxv)<=pxmax THEN
px=pxv
volinbal=px
@balwrite(vol,px,pxmax)
@makevoldb(lbal)
b=a
@makevoldb(rbal)
a$=STR$(ABS(b-a))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
DPOKE (zu%+24*balance&+16),px+pxmax              ! Horizontalposition des Balance-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,1,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
ENDIF
IF peakrd=FALSE THEN
@peakread
ELSE
@peakrec2
@peaktime
ENDIF
noppause=FALSE
IF demo=FALSE THEN
pkex=LPEEK(peakexit)
ENDIF
UNTIL @mousek<>1 OR (pkex=1 AND peakrd=TRUE)
~GRAF_MOUSE(257,0)                              ! Hidem
obj=0
ENDIF
IF obj=volume& THEN
~@xrsrc_gaddr(1,obj,zu2%)
opy=@mousey
~GRAF_MOUSE(256,0)                              ! Hidem
REPEAT
noppause=TRUE
IF xbmagic<>&H71273800 THEN
@peakwert
ENDIF
@mouse(x,y,k)
IF opy<>y THEN
opy=y
py=y-yd
IF py<=pymax AND py>=0 THEN
IF py>pymax/2 THEN
vol=INT((pymax-py)/pymax*255)/2*3
ELSE
vol=INT(255-(py/pymax*127))
ENDIF
@balwrite(vol,px,pxmax)
@makevoldb(vol)
@textfeld(peakdb&,a$,1)
DPOKE (zu%+24*volume&+18),py                     ! Hîhenposition des Volume-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,volbox&,1,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
ENDIF
IF peakrd=FALSE THEN
@peakread
ELSE
@peakrec2
@peaktime
ENDIF
noppause=FALSE
IF demo=FALSE THEN
pkex=LPEEK(peakexit)
ENDIF
UNTIL @mousek<>1 OR (pkex=1 AND peakrd=TRUE)
~GRAF_MOUSE(257,0)                              ! Hidem
obj=0
ENDIF
RETURN
'
> PROCEDURE peakwert
.| Glob. Var.: demo#,scb%,sth#,sdb%,recfifolen#,seb%,adr#,sfb%,peakint#
.|     peakret#,back3%,pl#,pr#,wymax#,rwert#,pr2#,pl2#,gr1#,gr2#,n#
.| Ruft auf  : mousek,read_smp
.| Aufruf in : maschruf4b-1,do_peak-1,peakread-2,
IF demo=FALSE THEN
IF xbmagic=&H71273800 THEN
scb%=sth
sdb%=recfifolen/8-1
seb%=adr+&H60
sfb%=adr+&H200-1
IF peakint=FALSE THEN
peakint=TRUE
peakret=XBIOS(116,L:scb%,L:sdb%,L:seb%,L:sfb%)
@write_int(2)
ENDIF
REPEAT
back3%=LPEEK(peakret+4)
UNTIL back3%=1 OR @mousek<>0
pl=DPEEK(peakret)
pr=DPEEK(peakret+2)
LPOKE peakret,0
LPOKE peakret+4,0
IF pl>32766 THEN
@setbutton(peakl&,1)
plt=TIMER
plw=TRUE
ENDIF
IF pr>32766 THEN
@setbutton(peakr&,1)
prt=TIMER
prw=TRUE
ENDIF
IF (TIMER-plt)>100 AND plw=TRUE THEN
plw=FALSE
@setbutton(peakl&,0)
ENDIF
IF (TIMER-prt)>100 AND prw=TRUE THEN
prw=FALSE
@setbutton(peakr&,0)
ENDIF
pr=pr/32767*wymax
pl=pl/32767*wymax
ELSE
REPEAT
@read_smp
pr=rwert
UNTIL (pr AND 256)=0
REPEAT
REPEAT
@read_smp
pr=rwert
UNTIL (pr AND 256)=256
@read_smp
pr2=rwert
UNTIL (pr2 AND 256)=256
REPEAT
REPEAT
@read_smp
pl=rwert
UNTIL (pl AND 256)=0
@read_smp
pl2=rwert
UNTIL (pl2 AND 256)=0
pr=(pr AND 255)*256+(pr2 AND 255)
pl=(pl AND 255)*256+(pl2 AND 255)
IF pr>32767 THEN
pr=ABS(pr-65536)
ENDIF
IF pl>32767 THEN
pl=ABS(pl-65536)
ENDIF
pr=pr/32767*wymax
pl=pl/32767*wymax
ENDIF
ELSE
INC pr
INC pl
IF pr>gr1 THEN
pr=0
gr1=INT(RND(1)*wymax)
ENDIF
IF pl>gr2 THEN
pl=0
gr2=INT(RND(1)*wymax)
ENDIF
FOR n=0 TO 300
NEXT n
ENDIF
RETURN
'
> PROCEDURE peakread
.| Glob. Var.: nr#,peak&,pl#,pr#
.| Ruft auf  : peakwert,fifodel,peakread2
.| Aufruf in : rsc_do-1,peak-1,do_peak-1,
LOCAL i,a,b,t,t2,nov,nov2
GRAPHMODE 1
DEFLINE 1
IF nr=peak& THEN
IF xbmagic=&H71273800 THEN
@peakwert
ELSE
a=0
b=0
FOR i=0 TO 19
IF peakrd=FALSE THEN
@fifodel
ENDIF
@peakwert
IF pl>a THEN
a=pl
ENDIF
IF pr>b THEN
b=pr
ENDIF
NEXT i
pl=a
pr=b
ENDIF
ENDIF
@peakread2
RETURN
'
> PROCEDURE peakread2
.| Glob. Var.: nr#,peak&,t#,t2#,vpl#,pl#,nov#,wymax#,vpr#,pr#,nov2#,erlaub#
.|     ax&,distx#,ay&,disty#,wy#,wx#,plm#,maxcol#,noppause#,distx2#,prm#
.| Ruft auf  : markhlp
.| Aufruf in : peakread-1,peakrec-1,
fp=4 ! FÅllfarbe dunkelblau (3=grÅn,2=rot)
IF nr=peak& THEN
t=155
t2=1
IF (vpl-pl)>t2 OR nov=TRUE THEN
IF peakrd=FALSE THEN
pl=vpl/wymax*t
ENDIF
nov=TRUE
ENDIF
IF (vpr-pr)>t2 OR nov2=TRUE THEN
IF peakrd=FALSE THEN
pr=vpr/wymax*t
ENDIF
nov2=TRUE
ENDIF
erlaub=TRUE
IF erlaub=TRUE THEN
@markhlp
IF vpl>pl THEN
DEFFILL 0,1,0
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-wy*pl,ax&+distx+wx,ay&+disty-wy*vpl
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pl<wymax-8 THEN
DEFFILL fp,1,fp
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty,ax&+distx+wx,ay&+disty-wy*pl
~GRAF_MOUSE(257,0)                              ! Hidem
IF xbmagic<>&H71273800 THEN
PAUSE 1
ELSE
PAUSE 1
ENDIF
ELSE
plm=pl-(wymax-8)
DEFFILL fp,1,fp
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty,ax&+distx+wx,ay&+disty-wy*(pl-plm)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,2,4
ELSE
DEFFILL 2,1,2
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-wy*(pl-plm),ax&+distx+wx,ay&+disty-wy*pl
~GRAF_MOUSE(257,0)                              ! Hidem
IF xbmagic<>&H71273800 THEN
IF noppause=FALSE THEN
PAUSE 8
ELSE
PAUSE 1
ENDIF
ELSE
IF noppause=FALSE THEN
PAUSE 7
ELSE
PAUSE 1
ENDIF
ENDIF
ENDIF
IF vpr>pr THEN
DEFFILL 0,1,0
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-wy*pr,ax&+distx2+wx,ay&+disty-wy*vpr
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pr<wymax-8 THEN
DEFFILL fp,1,fp
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty,ax&+distx2+wx,ay&+disty-wy*pr
~GRAF_MOUSE(257,0)                              ! Hidem
IF xbmagic<>&H71273800 THEN
PAUSE 1
ELSE
PAUSE 1
ENDIF
ELSE
prm=pr-(wymax-8)
DEFFILL fp,1,fp
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty,ax&+distx2+wx,ay&+disty-wy*(pr-prm)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,2,4
ELSE
DEFFILL 2,1,2
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-wy*(pr-prm),ax&+distx2+wx,ay&+disty-wy*pr
~GRAF_MOUSE(257,0)                              ! Hidem
IF xbmagic<>&H71273800 THEN
IF noppause=FALSE THEN
PAUSE 8
ELSE
PAUSE 1
ENDIF
ELSE
IF noppause=FALSE THEN
PAUSE 7
ELSE
PAUSE 1
ENDIF
ENDIF
ENDIF
ENDIF
vpl=pl
vpr=pr
IF xbmagic<>&H71273800 THEN
PAUSE 1
ELSE
PAUSE 1
ENDIF
ENDIF
RETURN
'
> PROCEDURE peakrec
.| Glob. Var.: nr#,peak&,pl#,peakret#,pr#,wymax#
.| Ruft auf  : peakread2
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,
LOCAL i,a,b,t,t2,nov,nov2
GRAPHMODE 1
DEFLINE 1
IF nr=peak& THEN
IF XBIOS(500)=&H71273800 THEN
~@xrsrc_gaddr(0,nr,zu%)
@mouse(x,y,k)
IF k=1 THEN
obj=OBJC_FIND(zu%,0,6,x,y)
IF obj<>0 THEN
peakrd=TRUE
@peakwork
REPEAT
IF demo=FALSE THEN
pkex=LPEEK(peakexit)
ENDIF
UNTIL @mousek=0 OR (pkex=1 AND peakrd=TRUE)
peakrd=FALSE
ENDIF
ENDIF
ENDIF
@peakrec2
ENDIF
RETURN
'
> PROCEDURE peakrec2
pl=DPEEK(peakret)
pr=DPEEK(peakret+2)
LPOKE peakret,0
IF pl>32766 THEN
@setbutton(peakl&,1)
plt=TIMER
plw=TRUE
INC peaks2
ENDIF
IF pr>32766 THEN
@setbutton(peakr&,1)
prt=TIMER
prw=TRUE
INC peaks2
ENDIF
IF (TIMER-plt)>100 AND plw=TRUE THEN
plw=FALSE
@setbutton(peakl&,0)
ENDIF
IF (TIMER-prt)>100 AND prw=TRUE THEN
prw=FALSE
@setbutton(peakr&,0)
ENDIF
pr=pr/32767*wymax
pl=pl/32767*wymax
@peakread2
RETURN
'
> PROCEDURE peaktime
LOCAL t
IF demo=FALSE THEN
rfull2=LPEEK(peakfull)
ENDIF
t=peaktime
hsec2=INT((TIMER-t)/2)
IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
hsec=hsec2
@htimeset
IF nr=peak& THEN
@textfeld(peakpos&,a$,1)
IF rfull2<>rfull THEN
rfull=rfull2
b$=STR$(rfull)+CHR$(0)
@textfeld(recerror&,b$,1)
ENDIF
IF peaks2<>peaks THEN
peaks=peaks2
b$=STR$(peaks)+CHR$(0)
@textfeld(recpeaks&,b$,1)
ENDIF
ENDIF
ENDIF
~FRE(0)
RETURN
'
> PROCEDURE smpscrol
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=1
RETURN
'
> PROCEDURE smpzoom
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=2
RETURN
'
> PROCEDURE smpkopie
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=5
RETURN
'
> PROCEDURE smpmove
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=6
RETURN
'
> PROCEDURE smpinsert
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=4
RETURN
'
> PROCEDURE smpmerge
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=7
RETURN
'
> PROCEDURE smpmark
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=3
RETURN
'
> PROCEDURE springart(sa)
.| Glob. Var.: v4#,ce#,cs#,virtual#,back%,virtpath$,mlen#,maxx#,vln#,meml#
.| Ruft auf  : maschinit33,maschruf33,maschinit32,maschruf32,busy_mouse
.| Aufruf in : edhandler2-1,markhandler-1,
LOCAL seek,seek2,bytes
IF v4=1 OR v4=8 THEN
sa=sa+4
IF sa>ce THEN
sa=ce-4
ENDIF
ENDIF
IF v4=2 OR v4=4 THEN
sa=sa-4
IF sa<cs THEN
sa=cs+4
ENDIF
ENDIF
IF virtual=FALSE THEN
IF v4=1 THEN           ! rechte SHIFT
@maschinit33
@maschruf33(sa,ce,0)
ENDIF
IF v4=2 THEN           ! linke SHIFT
@maschinit33
@maschruf33(cs,sa,1)
ENDIF
IF v4=8 THEN           ! Alternate
@maschinit32
@maschruf32(sa,ce,0)
ENDIF
IF v4=4 THEN           ! Control
@maschinit32
@maschruf32(cs,sa,1)
ENDIF
ELSE
back%=-1
IF EXIST(virtpath$)=TRUE AND (v4=1 OR v4=2 OR v4=4 OR v4=8) THEN
OPEN "I",#1,virtpath$
bytes=INT(mlen/4)*4
IF bytes>50000 THEN
maxx=50000
ELSE
maxx=bytes
ENDIF
IF v4=1 OR v4=8 THEN         ! vorwÑrts
seek=sa
vln=ce-sa
ELSE                         ! rÅckwÑrts
seek=sa-maxx
IF seek<cs THEN
seek=cs
ENDIF
vln=sa-cs
ENDIF
vln=INT(vln/4)*4
seek=INT(seek/4)*4
seek2=seek
IF vln>0 THEN
REPEAT
@busy_mouse
SEEK #1,seek
seek2=seek
IF vln>=maxx THEN
bytes=maxx
ELSE
bytes=INT(vln/4)*4
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF v4=1 THEN
@maschinit33
@maschruf33(0,bytes,0)
ENDIF
IF v4=2 THEN
@maschinit33
@maschruf33(0,bytes,1)
ENDIF
IF v4=8 THEN
@maschinit32
@maschruf32(0,bytes,0)
ENDIF
IF v4=4 THEN
@maschinit32
@maschruf32(0,bytes,1)
ENDIF
ENDIF
vln=vln-bytes
IF v4=1 OR v4=8 THEN
seek=seek+bytes
ELSE
seek=seek-bytes
ENDIF
UNTIL vln<4 OR back%<>-1
IF back%<>-1 THEN
back%=seek2+back%
ENDIF
ENDIF
CLOSE #1
ENDIF
ENDIF
RETURN
'
> PROCEDURE markhandler(VAR tx)
.| Glob. Var.: cs#,ce#,xm#,x#,xd#,y#,stay1#,stay2#,k#,f#,x3#,x2#,v2#,show#
.|     showdat#,tedart#,hz#,showbdat#,shw$,showxy&,zsnap#,v#,v3#,v4#,back%
.|     t$,obj#
.| Ruft auf  : mousek,mouse,maketime,textfeld,springart
.| Aufruf in : markprod2-4,
LOCAL ux,i,vtx
vtx=tx
IF vtx>=cs AND vtx<=ce AND (ce-cs)>0 THEN
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
IF x>ux+xd-2 AND x<ux+xd+2 AND y>=stay1 AND y<=stay2 THEN
k=@mousek
~GRAF_MOUSE(256,0)                              ! Hidem
IF k=1 THEN
COLOR 0
GRAPHMODE 1
FOR i=x-5 TO x+5
LINE i,stay1,i,stay1-5
NEXT i
GRAPHMODE 3
f=0
x3=-1
REPEAT
@mouse(x2,v2,k)
'
@maketime
IF x2>=xd AND x2<=(xm+xd) AND xm>0 AND ce>cs AND v2>=stay1 AND v2<=stay2 AND show=TRUE THEN
showdat=(INT((INT((ce-cs)/4))/xm*(x2-xd)))+INT(cs/4)
IF tedart=0 THEN
showdat=showdat/hz
ENDIF
IF showbdat<>showdat THEN
showbdat=showdat
shw$=STR$(showdat)+CHR$(0)
IF LEN(shw$)>9 THEN
shw$=LEFT$(shw$,9)
ENDIF
@textfeld(showxy&,shw$,1)
ENDIF
ENDIF
'
IF x<>x2 THEN
INC f
ENDIF
x=x2
IF x>=xd AND x<=xm+xd AND y>=stay1 AND y<=stay2 AND x<>ux+xd AND x3<>x THEN
GRAPHMODE 3
COLOR 0
LINE ux+xd,stay1+1,ux+xd,stay2
COLOR 1
vtx=INT(((ce-cs)/xm*(x-xd)+cs)/4)*4
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
x3=x
LINE ux+xd,stay1+1,ux+xd,stay2
GRAPHMODE 3
ENDIF
UNTIL k=0
IF zsnap=TRUE THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4<>0 THEN
@springart(vtx)
IF back%>=cs AND back%<=ce THEN
vtx=back%
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
GRAPHMODE 3
COLOR 0
LINE ux+xd,stay1+1,ux+xd,stay2
COLOR 1
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
x3=x
LINE ux+xd,stay1+1,ux+xd,stay2
GRAPHMODE 3
ENDIF
ENDIF
tx=vtx
COLOR 1
TEXT ux+xd-3,stay1-1,t$
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
obj=0
RETURN
'
> PROCEDURE markhandl2(VAR tx)
.| Glob. Var.: x#,vmem#,cs#,ce#,xm#,xd#,stay1#,stay2#,t$
.| Aufruf in : smph2-4,
LOCAL ux,i,vtx
vtx=tx
IF x>=0 AND x<=vmem AND x>=cs AND x<=ce AND (ce-cs)>0 THEN
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
GRAPHMODE 3
COLOR 1
LINE ux+xd,stay1,ux+xd,stay2
COLOR 0
GRAPHMODE 1
FOR i=ux-5 TO ux+5
LINE i+xd,stay1,i+xd,stay1-5
NEXT i
GRAPHMODE 1
COLOR 1
ux=x-cs
ux=INT(ux/(ce-cs)*xm)
GRAPHMODE 3
LINE ux+xd,stay1,ux+xd,stay2
GRAPHMODE 1
TEXT ux+xd-3,stay1-1,t$
GRAPHMODE 3
ENDIF
IF x>=0 AND x<=vmem AND (ce-cs)>0 THEN
tx=x
ENDIF
RETURN
'
> PROCEDURE blkstore
.| Glob. Var.: blks#
.| Aufruf in : do_smpedit-1,
IF blks=0 THEN
blks=1
ELSE
blks=0
ENDIF
RETURN
'
> PROCEDURE smpplay
.| Glob. Var.: digana#,merkc#,hrd#,sblock#,mamidi#,a#,meml#,b#,memh#,sret#
.|     adder#,c#,l#,sloop#,adm#,ad#,nr#,smp16&,a$,popups&,analog&,input&
.|     digital&,smpedit&,smpplay&,virtual#,op$,ext$,pret#,pbutt#,fil$,f#
.|     sectors#,flen#,smpfile&,nam$,smplen&,mem$,s#,hz#,smpsec&,sec$,over#
.|     handle#,playpos#,cblk#,sms#,sme#,c1#,c2#,raus#,y#,v3#,demo#
.| Ruft auf  : edhandler3,wait,maschinit2,analog,textfeld,maschruf2
.|     maschruf18,digin,digital,setbutton,smppmhlp,fileselect,restaura
.|     memfeld,secfeld,digout,maschinit5b,blocklook,maschruf5c,maschruf18c
.|     maschinit5d,fnamwrite
.| Aufruf in : drop2-1,do_smpedit-1,smpcblkplay-1,
IF digana=FALSE THEN
merkc=-1
@edhandler3
ENDIF
@wait
IF hrd=0 THEN
IF sblock=0 THEN
IF mamidi=0 THEN
@maschinit2
ENDIF
a=meml
b=memh
IF sret=1 THEN
adder=-8
c=a
a=b-4
b=c
l=sloop
ELSE
adder=0
l=sret+sloop
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,analog&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF (sret=0 OR sret=2) AND a<b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF sret=1 AND a>b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,digital&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
ELSE
@smppmhlp
ENDIF
ELSE
IF virtual=FALSE THEN
@fileselect(op$+"*."+ext$,"","PLAY:")
@restaura
ENDIF
IF pret<>0 AND pbutt=1 THEN
IF EXIST(fil$) THEN
'
'
'
OPEN "I",#1,fil$
f=LOF(#1)
datx=mdat%
BGET #1,datx,4
@fileart
SEEK #1,0
@fileart2
CLOSE #1
danf=datx
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
per=INT(10^9/(x*65536+y))
perm=INT(per/100)*100
per=INT(perm)
@ldhztest
'
'
'
sectors=INT(f/flen)
IF nr=smpedit& THEN
@textfeld(smpfile&,nam$+CHR$(0),1)
@memfeld(f,8)
@textfeld(smplen&,mem$,1)
s=INT(f/(hz*4))+1
@secfeld(s,8)
@textfeld(smpsec&,sec$,1)
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,analog&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
@digout(TRUE)
@maschinit5b
IF sret=0 OR sret=2 THEN
l=sret+sloop
over=0
REPEAT
handle=GEMDOS(61,L:VARPTR(fil$),0)
IF handle>0 THEN
playpos=0
IF virtual=TRUE AND sblock=1 THEN
IF cblk=FALSE THEN
@blocklook
ENDIF
IF (sms<>0 AND sme<>0 AND c1<>-1 AND c2>0 AND c2>c1) OR cblk=TRUE THEN
sectors=INT((c2-c1)/flen)
playpos=c1
ENDIF
ENDIF
IF mamidi=0 THEN
@maschruf5c
ELSE
@maschruf18c
IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
l=sret+sloop+4
@maschruf5c
ENDIF
ENDIF
~GEMDOS(62,handle)
ENDIF
UNTIL mamidi=0 OR (mamidi=1 AND (v3=2 OR INP?(2)=TRUE))
ENDIF
IF sret=1 THEN
l=sloop
over=-8
REPEAT
handle=GEMDOS(61,L:VARPTR(fil$),0)
IF handle>0 THEN
IF virtual=TRUE AND sblock=1 THEN
IF cblk=FALSE THEN
@blocklook
ENDIF
IF (sms<>0 AND sme<>0 AND c1<>-1 AND c2>0 AND c2>c1) OR cblk=TRUE THEN
sectors=INT((c2-c1)/flen)
playpos=c2
ENDIF
ELSE
playpos=sectors*flen
ENDIF
IF mamidi=0 THEN
@maschruf5c
ELSE
@maschruf18c
IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
l=sloop+4
@maschruf5c
ENDIF
ENDIF
~GEMDOS(62,handle)
ENDIF
UNTIL mamidi=0 OR (mamidi=1 AND (v3=2 OR INP?(2)=TRUE))
ENDIF
@maschinit5d
@fnamwrite
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,digital&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
@digout(FALSE)
RETURN
'
> PROCEDURE smpcblkplay
.| Glob. Var.: cs#,ce#,vmem#,a#,meml#,b#,c1#,c2#,vsblock#,sblock#,vmamidi#
.|     mamidi#,cblk#,ama#,amb#,memh#
.| Ruft auf  : smpplay
.| Aufruf in : do_smpedit-1,
IF cs>=0 AND ce<=vmem AND cs<ce THEN
cs=INT(cs/4)*4
ce=INT(ce/4)*4
a=meml+cs
b=meml+ce
a=INT(a/4)*4
b=INT(b/4)*4
c1=cs
c2=ce
vsblock=sblock
vmamidi=mamidi
sblock=1
mamidi=0
cblk=TRUE
ama=meml
amb=memh
@smpplay
cblk=FALSE
sblock=vsblock
mamidi=vmamidi
ENDIF
RETURN
'
> PROCEDURE smppmhlp
.| Glob. Var.: mamidi#,cblk#,l#,sloop#,lmin#,a#,lma#,b#,sms#,sme#,ama#,amb#
.|     xm#,stxnr#,sret#,adder#,c#,adm#,ad#,nr#,smp16&,a$,popups&,analog&
.|     input&,digital&,smpedit&,smpplay&
.| Ruft auf  : maschinit2,playblksearch,analog,textfeld,maschruf2,maschruf18
.|     digin,digital,setbutton
.| Aufruf in : smpplay-1,
IF mamidi=0 THEN
@maschinit2
ENDIF
IF cblk=FALSE THEN
@playblksearch
ENDIF
l=sloop
lmin=a
lma=b
IF (sms<>0 AND sme<>0 AND a>=ama AND b<=amb AND xm<>0 AND stxnr<>0) OR cblk=TRUE THEN
IF sret=1 THEN
adder=-8
c=a
a=b-4
b=c
ELSE
adder=0
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,analog&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF (sret=0 OR sret=2) AND a<b THEN
l=l+sret
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF sret=1 AND a>b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,digital&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
RETURN
'
> PROCEDURE playblksearch
.| Glob. Var.: a#,meml#,ama#,amb#,memh#,i#,loopz#,sms#,stxnr#,xm#,b#,sme#
.| Felder    : loops#(),loope#()
.| Aufruf in : smppmhlp-1,
a=meml
ama=a
amb=memh
FOR i=1 TO loopz
IF sms=i THEN
stxnr=loops(i)
ENDIF
NEXT i
IF xm>0 AND stxnr>0 THEN
a=a+stxnr
a=INT(a/4)*4
ENDIF
b=meml
FOR i=1 TO loopz
IF sme=i THEN
stxnr=loope(i)
ENDIF
NEXT i
IF xm>0 AND stxnr>0 THEN
b=b+stxnr
b=INT(b/4)*4
b=b-4
ENDIF
RETURN
'
> PROCEDURE smppmark
.| Glob. Var.: sblock#
.| Aufruf in : do_smpedit-1,
IF sblock=0 THEN
sblock=1
ELSE
sblock=0
ENDIF
RETURN
'
> PROCEDURE smploop
.| Glob. Var.: sloop#
.| Aufruf in : do_smpedit-1,
IF sloop=0 THEN
sloop=1
ELSE
sloop=0
ENDIF
RETURN
'
> PROCEDURE smpauto
.| Glob. Var.: autorec#,obj#,recok&,retime#,ldlen#,hrd#,blocks#,a#,meml#,l#
.|     mlen#,mcs#,mce#,sab%,sbb%,frag#,nofile#,ad#,hzc#,rwert#,sblock#,c2#
.|     c1#,sms#,sme#,ce#,xm#,nr#,smpedit&,smpauto2&,arranger&,smpauto3&
.| Ruft auf  : makehz2,sethertz,wait,smptime,maschinit3,blocklook,record3
.|     digout,smprate,maschruf4b,maschruf4,fifodel,maschruf3b,record4
.|     setbutton,record2
.| Aufruf in : drop2-1,do_arrange-1,do_smpedit-1,do_peak-1,
ed_obj=obj
autorec=TRUE
@makehz2
@sethertz
@wait
retime=0
ldlen=0
IF hrd=0 THEN
@maschinit3
IF blocks=0 THEN
a=meml
l=mlen
ELSE
@blocklook
a=mcs
l=mce-mcs
ENDIF
sab%=a
sbb%=a+l
ELSE
@record3
ENDIF
IF hrd=0 OR (hrd=1 AND obj=recok&) THEN
@digout(FALSE)
IF hrd=0 THEN
ALERT 2,"AUFNAHME ?",2,"JA|NEIN",frag
ENDIF
IF (hrd=1 AND nofile=0) THEN
frag=1
ENDIF
IF frag=2 THEN
@setbutton(ed_obj,0)
ENDIF
@wait
IF ad=0 THEN
@smprate
hzc=rwert
ENDIF
IF frag=1 AND ((hrd=0 AND sblock=0) OR (hrd=0 AND sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0)) THEN
IF XBIOS(500)=&H71273800 THEN
@maschruf4b
ELSE
@maschruf4
ENDIF
ELSE
@fifodel
ENDIF
IF frag=1 AND ((hrd=0 AND sblock=0) OR (hrd=0 AND sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0)) THEN
@maschruf3b
ENDIF
IF hrd=1 THEN
@record4
ENDIF
IF nr=smpedit& THEN
@setbutton(smpauto2&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpauto3&,0)
ENDIF
@record2
ELSE
IF nr=smpedit& THEN
@setbutton(smpauto2&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpauto3&,0)
ENDIF
ENDIF
obj=0
edit_obj&=0
RETURN
'
> PROCEDURE smpstart
.| Glob. Var.: autorec#,obj#,recok&,ldlen#,hrd#,nr#,smpedit&,smpstrt2&
.|     arranger&,smpstrt3&
.| Ruft auf  : makehz2,sethertz,wait,smptime,fifodel,record,record3,record4
.|     setbutton,record2
.| Aufruf in : drop2-1,do_arrange-1,do_smpedit-1,do_peak-1,
ed_obj=obj
autorec=FALSE
@makehz2
@sethertz
@wait
ldlen=0
@fifodel
IF hrd=0 THEN
ALERT 2,"AUFNAHME ?",2,"JA|NEIN",frag
IF frag=1 THEN
@record
ELSE
@setbutton(ed_obj,0)
ENDIF
ELSE
@record3
IF obj=recok& THEN
@record4
ENDIF
ENDIF
IF (hrd=0 AND frag=1) OR (hrd=1 AND obj=recok&) THEN
IF nr=smpedit& THEN
@setbutton(ed_obj,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpstrt3&,0)
ENDIF
IF hrd=0 THEN
@record2
ENDIF
ELSE
IF nr=smpedit& THEN
@setbutton(ed_obj,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpstrt3&,0)
ENDIF
ENDIF
obj=0
edit_obj&=0
RETURN
'
> PROCEDURE record
.| Glob. Var.: retime#,ldlen#,nr#,smpedit&,p$,smprate&,sblock#,a#,meml#,l#
.|     mlen#,mcs#,mce#,ad#,hzc#,rwert#,c2#,c1#,sms#,sme#,ce#,xm#
.| Ruft auf  : textfeld,maschinit3,blocklook,smprate,digout,maschruf3
.| Aufruf in : smpstart-1,
retime=0
ldlen=0
IF nr=smpedit& THEN
p$="    "+CHR$(0)
@textfeld(smprate&,p$,1)
ENDIF
@maschinit3
IF sblock=0 THEN
a=meml
l=mlen
ELSE
@blocklook
a=mcs
l=mce-mcs
ENDIF
IF ad=0 THEN
@smprate
hzc=rwert
ENDIF
IF sblock=0 OR (sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND sme<>0 AND ce<>0 AND xm>0) THEN
@digout(FALSE)
IF ed_obj=smpstrt2& OR ed_obj=smpstrtp& THEN
@maschruf3
ENDIF
IF ed_obj=recplay3& THEN
@maschruf7
ENDIF
ENDIF
RETURN
'
> PROCEDURE record2
.| Glob. Var.: nr#,sblock#,smpnam$,ext2$,path$,lfw$,smplen#,vmem#,mbs#,i#
.|     bloopz#,lded#,smpedit&,cs#,ce#
.| Felder    : bloops#(),bloope#()
.| Ruft auf  : rsc_redraw_obj,markdel,clsed,fnamwrite,curve,markprod3
.| Aufruf in : smpauto-1,smpstart-1,
IF sblock=0 THEN
@markdel
@clsed
ENDIF
smpnam$="MEMORY."+ext2$
path$=lfw$+smpnam$
smplen=vmem
mbs=0
FOR i=1 TO bloopz
bloops(i)=-1
bloope(i)=-1
NEXT i
lded=0
@fnamwrite
IF nr=smpedit& THEN
@rsc_redraw_obj(nr,0)
@curve(cs,ce)
@markprod3
ENDIF
RETURN
'
> PROCEDURE record3
.| Glob. Var.: retime#,ldlen#,nofile#,hrd#,op$,ext2$,nr#,fil$,pret#,pbutt#
.|     nam$,f#,min#,hz#,sectors#,flen#,smpedit&,smpfile&,smplen&,mem$,hsec#
.|     smpsec&,sec$,autorec#
.| Ruft auf  : fileselect,rsc_redraw_obj,textfeld,memfeld,secfeld,restaura
.| Aufruf in : smpauto-1,smpstart-1,
retime=0
ldlen=0
nofile=0
IF hrd=1 THEN
@fileselect(op$+"*."+ext2$,"","RECORD:")
IF fil$="" OR pret=0 OR pbutt=0 THEN
nofile=1
ELSE
IF RIGHT$(fil$,1)="\" THEN
nofile=1
ENDIF
ENDIF
IF nofile=0 THEN
@smptime
ENDIF
IF nofile=0 AND obj=recok& THEN
IF INSTR(fil$,".")=0 THEN
fil$=fil$+"."+ext2$
ENDIF
IF INSTR(nam$,".")=0 THEN
nam$=nam$+"."+ext2$
ENDIF
fil$=fil$+CHR$(0)
f=rtime*hz*4
sectors=INT(f/flen)
IF nr=smpedit& THEN
@textfeld(smpfile&,nam$+CHR$(0),1)
@memfeld(f,8)
@textfeld(smplen&,mem$,1)
hsec=INT(f/(hz*4))
@secfeld(hsec,8)
@textfeld(smpsec&,sec$,1)
ENDIF
@restaura
ELSE
@setbutton(ed_obj,0)
IF autorec=FALSE THEN
@restaura
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE record4
.| Glob. Var.: mrkfastrec#,fastrec#,hrd#,nofile#,autorec#,isave#,bnam$,nam$
.|     fil$,l#,smplen#,inf#,path$,smpnam$,g#,mlen#
.| Ruft auf  : maschinit8,maschinit8b,infhol,sampleinf,makedatum,infsave
.|     maschruf8,maschruf8b,fnamwrite
.| Aufruf in : smpauto-1,smpstart-1,
mrkfastrec=fastrec
'  fastrec=FALSE   !   = FALSE wenn nur alte RECORD-Routine, wenn REM-Zeile dann Åber TURBO im Setup alt/neu wÑhlbar
'
IF hrd=1 THEN
IF nofile=0 THEN
IF fastrec=FALSE THEN
@maschinit8
ELSE
@maschinit8b
ENDIF
IF hrd=1 THEN
@infhol
isave=TRUE
bnam$=nam$
IF EXIST(fil$)=TRUE THEN
OPEN "I",#1,fil$
l=LOF(#1)
smplen=INT(l/4)
CLOSE #1
ENDIF
@sampleinf
isave=FALSE
IF inf=TRUE THEN
path$=fil$
smpnam$=nam$
@makedatum
@infsave
ENDIF
ENDIF
IF inf=TRUE THEN
ALERT 0,"Aufnahme-Start",1,"OK",g
IF autorec=TRUE THEN
IF frag=1 AND hrd=1 AND nofile=0 THEN
IF XBIOS(500)=&H71273800 THEN
@maschruf4b
ELSE
@maschruf4
ENDIF
ELSE
@fifodel
ENDIF
ENDIF
IF fastrec=FALSE THEN
@maschruf8
ELSE
@maschruf8b
ENDIF
ELSE
@setbutton(ed_obj,0)
ENDIF
ENDIF
smplen=mlen
@fnamwrite
ENDIF
autorec=FALSE
'
fastrec=mrkfastrec
RETURN
'
> PROCEDURE exit
.| Glob. Var.: cwerte1#,cwert#,merkfrei#,mdatf2#,mdatf#,big#,anfloadx#,virt$
.|     virt2$
.| Aufruf in : goodbye-1,
IF cwerte1>0 THEN
~MFREE(cwert)
ENDIF
IF merkfrei>0 THEN
~MFREE(merkfrei)
ENDIF
IF mdatf2>0 THEN
~MFREE(mdatf2)
ENDIF
IF mdatf>0 THEN
~MFREE(mdatf)
ENDIF
IF big=0 AND anfloadx>0 THEN
~MFREE(anfloadx)
ENDIF
IF EXIST(virt$) THEN
KILL virt$
ENDIF
IF EXIST(virt2$) THEN
KILL virt2$
ENDIF
RETURN
'
> PROCEDURE fehler
.| Glob. Var.: g#
.| Ruft auf  : goodbye
.| Aufruf in : HAUPTPROGRAMM-1,
ALERT 3,"Fehler aufgetaucht !!!|"+STR$(ERR)+"|Weiter ?",1,"JA|NEIN",g
IF g=1 THEN
RESUME NEXT
ELSE
@goodbye
ENDIF
RETURN
'
> PROCEDURE dsp_boot
'
' Bootstrap-Programm
' this is the patched SLOADER  named "SLOADER3.ASM"
'
lodboot:
DATA &H0C01AB
DATA &H08F4BE,&H000000,&H08F4A0,&H000001,&H08F4A2,&H000000,&H0D01D9,&H245F00
DATA &H200045,&H0E21B1,&H0D01D9,&H244400,&H244545,&H0EA1C3,&H200045,&H0E21B1
DATA &H0D01D9,&H242000,&H200045,&H0E21BB,&H0D01E4,&H21B000,&H000000,&H0AE080
DATA &H0D01D9,&H242000,&H200045,&H0E21C3,&H0D01D9,&H218600,&H0D01E4,&H21B000
DATA &H2E5800,&H2E5955,&H0EA1D3,&H200055,&H0EA1D6,&H0D01E7,&H07588D,&H0C01D0
DATA &H0D01E7,&H555800,&H0C01D3,&H0D01E7,&H5D5800,&H0C01D6,&H0AA980,&H0001D9
DATA &H000000,&H000000,&H084E2B,&H000000,&H000000,&H200033,&H200023,&H218E00
DATA &H00000C,&H44F41B,&H000004,&H0C01E9,&H44F41B,&H000006,&H06C400,&H0001FE
DATA &H0D01D9,&H245F00,&H244645,&H0E21F2,&H00008C,&H0444BC,&H0C01B5,&H243045
DATA &H0E71EB,&H200045,&H0E91EB,&H240A44,&H240745,&H0E91FA,&H200044,&H0604A0
DATA &H20003B,&H0610A0,&H200023,&H200018,&H00000C
'
RESTORE lodboot
READ a
@bootwrite(a)
FOR i=1 TO &H1AA
a=0
@bootwrite(a)
EXIT IF break=TRUE
NEXT i
IF break=FALSE THEN
FOR i=&H1AB TO &H1FF
READ a
@bootwrite(a)
EXIT IF break=TRUE
NEXT i
ENDIF
RETURN
'
> PROCEDURE dsp_lodload
'
' Host-LOD-File-Loader to Host by Bootstrap-Loading from DSP56001
' Load a LOD-File in the DSP and Start it at P:0
'
'
@fileselect("D:\SAMPLER\SAMPLE.16\DSP\*.LOD","","LOAD LOD-FILE to DSP:")
IF fil$<>"" THEN
IF EXIST(fil$)=TRUE THEN
'
@dsp_boot
'
' Transfer LOD-File to HI-Interface
'
IF break=FALSE THEN
z=-1
OPEN "I",#1,fil$
REPEAT
a=INP(#1)
IF a=ASC("_") THEN
a$="_"
ENDIF
IF a$="_" AND a=ASC("E") THEN
a$=a$+CHR$(a)
ENDIF
IF a$="_E" AND a=ASC("N") THEN
a$=a$+CHR$(a)
ENDIF
IF a$="_EN" AND a=ASC("D") THEN
a$=a$+CHR$(a)
ENDIF
IF a$="_END" AND a=ASC(" ") THEN
a$=a$+CHR$(a)
z=5
ENDIF
@lodtohi(a)
DEC z
EXIT IF break=TRUE
UNTIL EOF(#1)=TRUE OR z=0
CLOSE #1
ENDIF
ENDIF
IF break=TRUE THEN
'        PRINT "Fehler"
ELSE
'        PRINT "OK"
ENDIF
ENDIF
RETURN
'
> PROCEDURE bootwrite(w)
LOCAL al,am,ah
al=(w AND 255)
w=SHR(w,8)
am=(w AND 255)
w=SHR(w,8)
ah=(w AND 255)
IF break=FALSE AND demo=FALSE THEN
@pause
POKE adr+&H100+2*4,0   ! Dummy
IF break=FALSE THEN
@pause
POKE adr+&H100+2*5,ah
IF break=FALSE THEN
@pause
POKE adr+&H100+2*6,am
IF break=FALSE THEN
@pause
POKE adr+&H100+2*7,al
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE lodtohi(w)
IF break=FALSE THEN
@pause
w=(w AND 127)
IF w>96 AND w<103 THEN
w=w-32
ENDIF
IF demo=FALSE THEN
POKE adr+&H100+2*4,0   ! Dummy
IF break=FALSE THEN
@pause
POKE adr+&H100+2*5,w
IF break=FALSE THEN
@pause
POKE adr+&H100+2*6,0   ! Dummy
IF break=FALSE THEN
@pause
POKE adr+&H100+2*7,0   ! Dummy
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE pause
LOCAL p,t,t2,wait,prf
prf=6
p=200 ! timeout in 1/200 sec
t=TIMER
IF demo=FALSE THEN
REPEAT
t2=TIMER-t
wait=(prf AND (PEEK(adr+&H100+2*2)))
UNTIL wait=prf OR t2>p
IF t2>p AND wait<>prf THEN
break=TRUE
timeout=TRUE
ENDIF
ENDIF
RETURN
