$m900000
$e$
'
DIM buffer&(7)
public=TRUE                ! public or non-public
falconda=FALSE             ! Falcon-Emulation
hardcursor=FALSE
'
' dspuse         ! Host-Port-öbertragung : DSP fÅr trkplay, play & record-Funktionen nutzen
'
' matrixplay     ! Wiedergabe Åber Matrix(TRUE) oder DSP(FALSE)
'
' pch4           ! 4Kanal-PlayMode
' pmo8           ! Play- 8Kanal-Mode nutzen (auch fÅr 16Ch-Mode)
' pch16          ! 16Kanal-PlayMode
'
xload=FALSE
windowda=FALSE
smpwcol=4
smpblkcol=9
xbs=500                   ! my_xbios
ON ERROR GOSUB fehler
'
' ------------------------------------------------------------------------------
' -------STARTRAK.PRG   Sample-Editor & Midi-Player for VME-Atari's-------------
' ----------------------with VME StarTrack Audiocard 16/24Bit Harddisksampler---
' ------------------------First Release 22.8.1994-------------------------------
' ------------------------------------------------------------------------------
' -------------------V 2.00 - Revision 13.06.1998 ------------------------------
' ------------------------------------------------------------------------------
'
'
starversion$="V2.00 / 13.06.1998"
drvtyp$="STARTRACK"
'
'
' ------------------------------------------------------------------------------
' ------------------------STARTRACK-REGISTER------------------------------------
' ------------------------------------------------------------------------------
'
' READ  401h   Status Low                          Bit 0-2,7 -> MAGICVOL,MAGICXLR,MAGICDIGI,MAGICADDA
'
'                                 0  MAGICVOL    - 0=kein zweiter Volume-Controller fÅr Ausgang vorhanden
'                                                  1=zweiter Volume-Controller fÅr Ausgang vorhanden
'                                 1  MAGICXLR    - 0=keine XLR-Erweiterung vorhanden
'                                                  1=XLR-Erweiterung vorhanden
'                                 2  MAGICDIGI   - 0=keine digitalen Schnittstellen vorhanden
'                                                  1=digitale Schnittstellen vorhanden
'                                 6  MAGICHS96   - 0=keine 96KHz-Highsampling,Takt kommt von ICLK-Anschluss
'                                                  1=96KHz-Highsampling mîglich,interne Taktverdopplung des 18.432MHz-Taktes
'                                 7  MAGICADDA   - 0=keine A/D und D/A-Wandler vorhanden
'                                                  1=A/D und D/A-Wandler vorhanden
'
'
'
' WRITE 401h   Register Low  Bytewide              Bit0-7 -> SWAES,SWDIGIN,TAKT0,TAKT1,EXTAKT,EXTEX,EXTTF,EXTTW
'
'                                 0  SWAES       - 0=digitaler Eingang, 1=Analogeingang
'                                 1  SWDIGIN     - 0=optischer Digitaleingang, 1=koaxialer Digitaleingang
'                               2,3  TAKT0,TAKT1 - 0=Takt vom A/D & D/A, 1=32khz, 2=44.1khz, 3=48khz
'                                                  Wird ein externer Takt eingespeist bzw. der MCLK-Takt intern geteilt (EXTAKT=1)
'                                                  wird das Signal TAKT0 miûbraucht, um zwischen 256/384facher Teilung
'                                                  des Mastertaktes umzuschalten. Das Ergebnis sind die Samples/s
'                                                  TAKT0:  0=256facher Takt, 1=384facher Takt
'                                 4  EXTAKT      - 0=Original-MCLK-Takt (durch TAKT0 & TAKT1 bestimmt) nutzen
'                                                - 1=eigenen MCLK-Takt (durch EXTEX,EXTTF & EXTTW bestimmt) nutzen
'
'                                 folgende Register wirken nur in Verbindung mit EXTAKT=1:
'
'                                 5  EXTEX       - 0=internen MCLK-Takt fÅr Taktteiler nutzen (16.9344/24.576 MHz)
'                                                  1=extern Åber EXTMCLK zugefÅhrten MCLK fÅr Taktteiler nutzen
'                                 6  EXTTF       - 0=durch 2(bei EXTEX=0) geteilten Takt fÅr MCLK nutzen. Bei EXTEX=1 keine
'                                                    Teilung, MCLK wird direkt durch EXTCLK (external CLK-Input) erzeugt
'                                                - 1=durch 4(bei EXTEX=0) geteilten Takt fÅr MCLK nutzen. Bei EXTEX=1 Teilung
'                                                    des EXTCLK (external CLK-Input) durch 2 fÅr MCLK-Erzeugung
'                                 7  EXTTW       - 0=16.9344 MHz, 1=12.288MHz fÅr Taktteiler - nur in Verbindung mit EXTEX=0
'                                                    relevant
'
'
'
' READ  421h   Status Mid                          Bit0-2,7 -> ERR0,ERR1,ERR2,EMPH
'
'            wenn  SUBFR=0        0  ERR0        - Fehlercodes vom Digitaleingang
'            wenn  SUBFR=0        1  ERR1        - Fehlercodes vom Digitaleingang
'            wenn  SUBFR=0        2  ERR2        - Fehlercodes vom Digitaleingang
'                                                  Fehlercodes: 0=no error, 1=validity bit high, 2=confidence flag,
'                                                               3=slipped sample
'                                                               4=CRC-error, 5=parity-error, 6=Bi-Phase coding error, 7=no lock
'                                                               (siehe auch CS8412-Manual)
'
'            wenn  SUBFR=1        0  USE         - 0=Profi, 1=Consumer
'            wenn  SUBFR=1        1  AUDIO       - 0=DATA, 1=Audio
'            wenn  SUBFR=1        2  PROT        - 0=no Copy-prohibit - SCMS not active, 1=Copy prohibit - SCMS is active
'            wenn  SUBFR=1        7  EMPH        - 0=no emphasis, 1=emphasis is active
'
'
' READ  441h   Status High                         Bit0-2 -> FIFO-WRempty,FIFO-WRhalf,FIFO-WRfull
'                                                  Die Flags des Play-FIFOs
'                                 0  WRempty     - 0=FIFO leer, muû nachgefÅllt werden sonst Datenverlust
'                                 1  WRhalf      - 0=FIFO mehr als halb gefÅllt, 1=FIFO weniger/bis halb gefÅllt, lîst
'                                                  auch INT aus
'                                 2  WRfull      - 0=FIFO voll, weiterschreiben wird mit Datenverlust bestraft :-)
'
' WRITE 441h   Register High  Bytewide             Bit0-7 -> SWPROT,SWRES-FIFO,SWDIGOUT,SWSUBFR,PREEMPH,GENERA,CATEG0,CATEG1
'
'                                 0  SWPROT(C2)  - 0=SCMS-Copybit aktiv, 1=SCMS-Copybit entfernen - Digitalkopie erlaubt (Bit C2)
'                                                  Wenn SWPROT=1 ist und der Categorycode 11 (DAT) ist,
'                                                  hat das GENERA-Bit keine Bedeutung
'                                                  und der Kopierschutz ist vollstÑndig entfernt.
'                                                  Wenn SWPROT=0 ist und der Categorycode 11 (DAT) ist, und das
'                                                  GENERA-Bit 1 ist, dann kann nach der öberspielung noch einmal kopiert werden.
'                                                  Wenn SWPROT=1 ist und der Categorycode 00 (General) ist, und das
'                                                  GENERA-Bit 0 ist, dann
'                                                  kann nach der öberspielung nicht mehr digital Åberspielt werden (SCMS)
'                                 1  SWRES-FIFO  - 0=REC-FIFO-Reset deaktiviert, 1=REC-FIFO-Reset aktiv - muû manuell
'                                                  rÅckgesetzt werden
'                                 2  SWDIGOUT    - 0=D/A und DigitalausgÑnge geben Daten vom A/D bzw. Digitaleingang wieder
'                                                  1=D/A und DigitalausgÑnge geben Daten vom Play-FIFO wieder
'                                 3  SWSUBFR(SEL)- 0=Error information des Digitaleingangs (siehe Status Mid: ERR0,ERR1,ERR2)
'                                                  1=Channel status information des Digitaleingangs (siehe Status Mid: USE,
'                                                  AUDIO,PROT)
'
'                                                  Die folgenden Bits PREEMPH,CATEG0,CATEG1 & GENERA wirken nur bei
'                                                  Sampler-PLAY auf den
'                                                  Digitalausgang und nicht bei direkten DigitalÅberspielungen als SCMS-Dekoder
'                                 4  PREEMPH(C3) - 0=Preemphasis aus, 1=Preemphasis an, nur wirksam bei Digital-Ausgang (Bit C3)
'                                 5  GENERA(C15) - 0=no indication, einmal kopierbar 1=orginal/nicht kopierbar
'                                                  Das GENERA-Bit hat nur eine Bedeutung, wenn Digitalkopie erlaubt, also SWPROT=1
'                                                  und der Categorycode 00 ist, dann kann 1x kopiert werden
'                                 6  CATEG0(C8)  - Categorycode
'                                 7  CATEG1(C9)  - Categorycode
'                                                  00=General, 01=PCM encoder/decoder, 10=laser optical(CD,MD),
'                                                  11=magnetic tape(DAT,DCC)
'                                 Im Professional-Mode haben einige Leitungen andere Bedeutungen. Alle wichtigen Steuerleitungen
'                                 sind vorhanden um auch den Professional-Mode nutzen zu kînnen. Damit sind auch AES/EBU-
'                                 AnschlÅsse denkbar.'
'
'
' READ  461h   Status xHigh                        Bit0-2 -> FIFO-RDempty,FIFO-RDhalf,FIFO-RDfull
'                                                  Die Flags des Record-FIFOs
'                                 0  RDempty     - 0=FIFO leer, weiterlesen wird mit Zufallsdaten bestraft
'                                 1  RDhalf      - 0=FIFO mehr als halb gefÅllt, 1=FIFO weniger/bis halb gefÅllt,
'                                                  lîst auch INT aus
'                                 2  RDfull      - 0=FIFO voll, muû ausgelesen werden sonst Datenverlust
'
'
' WRITE 481h   DSP-Register  Bytewide              Bit0-7 -> DSPON,DSPIN,VOLCS1,VOLCLK,VOLDATAI(CKS wenn EXTAKT=1),
'                                                            VOLCS2,AESC24,AESC25
'
'                                 0  DSPON       - 0=DSP-Ausgang nicht im Signalweg
'                                                    Bearbeitung der Eingangsdaten Åber DSP-Eingang (digital-in oder A/D)
'                                                    ist mîglich
'                                                  1=DSP-Ausgang im Signalweg, Ausgabe der DSP-Daten im Record oder Play-Zweig
'                                 1  DSPIN       - 0=DSP-Ausgang einschleifen im Record-Zweig
'                                                  1=DSP-Ausgang einschleifen im Play-Zweig
'                                 2  VOLCS1      - /CS-Signal fÅr A/D Volume-Controller
'                                 3  VOLCLK      - Clock-Signal fÅr Volume-Controller um Volume-Daten 8Bit Stereo l/r einzutakten
'                                 4  VOLDATAI    - Dateneingang des Volume-Controllers
'                                 5  VOLCS2      - /CS-Signal fÅr D/A Volume-Controller
'                                 6  AESC24      - Zeigt die Samplerate des Digital-Eingangssignals an (dekodiert dafÅr das
'                                 7  AESC25        Eingangssignal)
'                                                  0=44.1khz, 2=48khz, 3=32khz
'
'
'
' WRITE 4C1h   AES-Register  Bytewide              Bit0,1,7 -> SWPROF,SWCOPY,SPEBU
'
'                                 0  SWPROF      - 0=Consumer-Mode und Transparent-Mode
'                                                  1=Professional-Mode
'                                 1  SWCOPY      - 0=SCMS-Kopierschutz im Kopiermodus vollstÑndig entfernen
'                                                  1=SCMS-Kopierschutz erlaubt im Kopiermodus nur eine Kopie, danach ist
'                                                    SCMS wieder drinn
'                                 2  SWMAL2      - 0=normalen externen Takt benutzen
'                                                  1=externen Takt verdoppeln fÅr HighSampling mit 96KHz
'                                                    (18.432x2 = 36.864 MHz / 384 = 96000KHz)
'                                 7  SPEBU       - 0=SP/DIF-AnschlÅsse nutzen
'                                                  1=AES/EBU-ProfianschlÅsse nutzen
'
'
' RD/WR 501h  DSP-ChipSelect  Bytewide
'
'                               0-7  DSP-DATA    - /CS fÅr den DSP. Der DSP hat 8 Hostregister von 501h-50Fh. Das spiegelt sich im
'                                                  Adreûbereich bis 17Fh. Die HI-Register ICR,CVR,ISR,IVR,RXH,RXM,RXL bzw.
'                                                  ICR,CVR,ISR,IVR,TXH,TXM,TXL sind hierÅber zu erreichen.
'
'
' WRITE 521h  DSPRES            0    DSP-RESET   - 0=/RESET fÅr den DSP, du muût das Register manuell auf 1 zurÅcksetzen
'
'
' RD/WR 541h  SMPTE             0-7  SMPTE-DATA  - Bereich fÅr optionalen SMPTE-Coder/Decoder
'
'
' RD/WR 581h  Interrupt-Freigabe  Bytewide         Bit 0,1 -> PLAY-INT,REC-INT
'
'                                                  Der Startrack-Sampler erzeugt getrennte Vektoren fÅr Aufnahme und Wiedergabe
'                                                  Soll eine Interruptgesteuerte Aufnahme/Wiedergabe gestartet werden muû dafÅr
'                                                  eine Interruptroutine geschrieben/installiert werden. Das ganze wird aber erst
'                                                  gestartet, wenn das zustÑndige INT-Register gesetzt wird.
'                                                  Die Aufnahme/Wiedergabe kann durch RÅcksetzen des zustÑndigen INT-Registers
'                                                  gestoppt werden.
'                                  0  PLAY-INT   - 0=kein Play-Interrupt, 1=PLAY-Interrupt aktiviert bzw. ausgelîst
'                                                  Vector Nr.122
'                                  1  REC-INT    - 0=kein Record-Interrupt, 1=Record-Interrupt aktiviert bzw. ausgelîst
'                                                  Vector Nr.123
'
'
' RD/WR 600h   Sample Read/Write  Wordwide
'
'                               0-8  FIFO        - Hier werden die Samples eingeschrieben oder ausgelesen, und zwar in
'                                                  8Bit-HÑppchen
'                                                  Beim Lesen (REC) mit einer Kennung im Bit8 die anzeigt, ob das Sample zum
'                                                  linken oder rechten Kanal gehîrt.
'                                                  Bit8=0 - Rechter Kanal
'                                                  Bit8=1 - Linker Kanal
'                                                  Beim Schreiben werden auch 8Bit-HÑppchen geschrieben, dabei zeigt Adreûleitung
'                                                  A1 an, ob der rechte oder linke Kanal Åbertragen wird.
'                                                  A1=0 - Rechter Kanal
'                                                  A1=1 - Linker Kanal
'                                                  Zuerst wird das Highbyte des 16Bit-Samples geschrieben/gelesen, und dann
'                                                  das Lowbyte.
'
'
'
'
' Sample-Editor zum STARTRACK-Sampler
'
' Bedienung aller wichtiger Parameter des 16Bit-Stereo-Samplers und Sample-Editor/Arranger
'
CLIP OFF
startup=FALSE
compile=BYTE{ADD(BASEPAGE,256)}<>96
acc=({ADD(BASEPAGE,36)}=0)
INLINE m_busy%,592
m_adr%=m_busy%
xwidth=WORK_OUT(0)+1
ywidth=WORK_OUT(1)+1
bigfoot=FALSE
IF xwidth>=998 AND ywidth>=662 THEN
  bigfoot=TRUE
ENDIF
@busy_mouse
gemvers=GEMDOS(48)     ! GEMDOS-Version >=&H1900 = Fastram-Malloc
m=@malloc(-1,0)
IF m<&H600000 THEN
  smalluse=TRUE       ! wenn weniger als 6 MB RAM frei
  bigfoot=FALSE
ELSE
  smalluse=FALSE
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------RSC-VARIABLEN-----------------------------------------
' ------------------------------------------------------------------------------
IF smalluse=TRUE THEN
  REM Resource Datei Indizes fÅr STARLMON
  '
  LET smp16&=0 ! Formular/Dialog
  LET mainbox&=0 ! BOX in Baum SMP16
  LET exit&=1 ! BUTTON in Baum SMP16
  LET mainbox2&=2 ! BOX in Baum SMP16
  LET emph&=4 ! BUTTON in Baum SMP16
  LET audio&=5 ! BUTTON in Baum SMP16
  LET use&=6 ! BUTTON in Baum SMP16
  LET smp32&=8 ! BUTTON in Baum SMP16
  LET smp44&=9 ! BUTTON in Baum SMP16
  LET smp48&=10 ! BUTTON in Baum SMP16
  LET noval&=12 ! BUTTON in Baum SMP16
  LET confid&=13 ! BUTTON in Baum SMP16
  LET parity&=14 ! BUTTON in Baum SMP16
  LET biphase&=15 ! BUTTON in Baum SMP16
  LET nolock&=16 ! BUTTON in Baum SMP16
  LET prot&=18 ! BUTTON in Baum SMP16
  LET mainbox5&=19 ! BOX in Baum SMP16
  LET ydsp&=20 ! STRING in Baum SMP16
  LET dsp&=21 ! BOXTEXT in Baum SMP16
  LET dspcirc&=22 ! BOXCHAR in Baum SMP16
  LET mainbox6&=23 ! BOX in Baum SMP16
  LET input&=25 ! BOXTEXT in Baum SMP16
  LET incirc&=26 ! BOXCHAR in Baum SMP16
  LET rate2&=28 ! BOXTEXT in Baum SMP16
  LET ratecir2&=29 ! BOXCHAR in Baum SMP16
  LET helporig&=30 ! BOXTEXT in Baum SMP16
  LET mainbox4&=31 ! BOX in Baum SMP16
  LET source&=33 ! BOXTEXT in Baum SMP16
  LET srccirc&=34 ! BOXCHAR in Baum SMP16
  LET protect&=36 ! BOXTEXT in Baum SMP16
  LET protcirc&=37 ! BOXCHAR in Baum SMP16
  LET mode&=39 ! BOXTEXT in Baum SMP16
  LET modecirc&=40 ! BOXCHAR in Baum SMP16
  LET emphasis&=42 ! BOXTEXT in Baum SMP16
  LET emphcirc&=43 ! BOXCHAR in Baum SMP16
  LET bridge&=44 ! BUTTON in Baum SMP16
  '
  LET smpedit&=1 ! Formular/Dialog
  LET editbox7&=0 ! BOX in Baum SMPEDIT
  LET editbox&=2 ! BOX in Baum SMPEDIT
  LET smplen&=3 ! BOXTEXT in Baum SMPEDIT
  LET smpsec&=4 ! BOXTEXT in Baum SMPEDIT
  LET smpexit&=7 ! BUTTON in Baum SMPEDIT
  LET rate&=9 ! BOXTEXT in Baum SMPEDIT
  LET ratecirc&=10 ! BOXCHAR in Baum SMPEDIT
  LET editbox6&=11 ! BOX in Baum SMPEDIT
  LET smppmark&=12 ! ICON in Baum SMPEDIT
  LET midi&=13 ! ICON in Baum SMPEDIT
  LET mintext&=14 ! BOXTEXT in Baum SMPEDIT
  LET smploop&=16 ! ICON in Baum SMPEDIT
  LET smpcblk&=17 ! ICON in Baum SMPEDIT
  LET smpfile&=18 ! BOXTEXT in Baum SMPEDIT
  LET smprate&=19 ! BOXTEXT in Baum SMPEDIT
  LET editbox5&=20 ! BOX in Baum SMPEDIT
  LET mover&=21 ! BOXTEXT in Baum SMPEDIT
  LET movecirc&=22 ! BOXCHAR in Baum SMPEDIT
  LET trash&=23 ! ICON in Baum SMPEDIT
  LET editbox3&=24 ! BOX in Baum SMPEDIT
  LET edmtims&=25 ! BOXTEXT in Baum SMPEDIT
  LET edmtime&=26 ! BOXTEXT in Baum SMPEDIT
  LET edmdown&=27 ! ICON in Baum SMPEDIT
  LET edmslide&=28 ! BOX in Baum SMPEDIT
  LET edmbut&=29 ! BUTTON in Baum SMPEDIT
  LET edmup&=30 ! ICON in Baum SMPEDIT
  LET edmnr&=31 ! BOXTEXT in Baum SMPEDIT
  LET edmtimi&=32 ! BOXTEXT in Baum SMPEDIT
  LET edmtimr&=33 ! BOXTEXT in Baum SMPEDIT
  LET edmtxt&=34 ! BOXTEXT in Baum SMPEDIT
  LET edmbox&=35 ! BOX in Baum SMPEDIT
  LET edmbuts&=36 ! ICON in Baum SMPEDIT
  LET edmbute&=37 ! ICON in Baum SMPEDIT
  LET edmbuti&=38 ! ICON in Baum SMPEDIT
  LET edmbutr&=39 ! ICON in Baum SMPEDIT
  LET smpedhlp&=41 ! BOXTEXT in Baum SMPEDIT
  LET zomslide&=42 ! BOX in Baum SMPEDIT
  LET zoombutt&=43 ! BUTTON in Baum SMPEDIT
  LET cstxt&=46 ! BOXTEXT in Baum SMPEDIT
  LET cetxt&=47 ! BOXTEXT in Baum SMPEDIT
  LET pixzoom&=49 ! ICON in Baum SMPEDIT
  LET showxy&=50 ! BOXTEXT in Baum SMPEDIT
  LET pntprsmp&=51 ! BOXTEXT in Baum SMPEDIT
  LET freemem&=52 ! BOXTEXT in Baum SMPEDIT
  LET clock&=53 ! BOXTEXT in Baum SMPEDIT
  LET smpname&=54 ! BOXTEXT in Baum SMPEDIT
  LET smpundo&=55 ! BOXTEXT in Baum SMPEDIT
  LET flyer&=57 ! USERDEF in Baum SMPEDIT
  LET smpr1&=58 ! ICON in Baum SMPEDIT
  LET smpl1&=59 ! ICON in Baum SMPEDIT
  LET smpl2&=60 ! ICON in Baum SMPEDIT
  LET smpr2&=61 ! ICON in Baum SMPEDIT
  LET smpl3&=62 ! ICON in Baum SMPEDIT
  LET smpanf&=63 ! ICON in Baum SMPEDIT
  LET smpend&=64 ! ICON in Baum SMPEDIT
  LET smpmid&=65 ! ICON in Baum SMPEDIT
  LET smpr3&=66 ! ICON in Baum SMPEDIT
  LET zooml&=67 ! ICON in Baum SMPEDIT
  LET zoomr&=68 ! ICON in Baum SMPEDIT
  LET smpstrt2&=69 ! ICON in Baum SMPEDIT
  LET smpauto2&=70 ! ICON in Baum SMPEDIT
  LET recplay3&=71 ! ICON in Baum SMPEDIT
  LET smpplay&=72 ! ICON in Baum SMPEDIT
  LET smpstop&=73 ! ICON in Baum SMPEDIT
  LET smpwait&=74 ! ICON in Baum SMPEDIT
  LET hard&=75 ! ICON in Baum SMPEDIT
  LET resolu&=78 ! BOXTEXT in Baum SMPEDIT
  LET editbox2&=79 ! BOX in Baum SMPEDIT
  LET setuper&=80 ! ICON in Baum SMPEDIT
  LET edfade&=81 ! ICON in Baum SMPEDIT
  LET peaksw2&=82 ! ICON in Baum SMPEDIT
  LET disk&=83 ! ICON in Baum SMPEDIT
  LET loopart&=84 ! ICON in Baum SMPEDIT
  LET blocfunc&=85 ! ICON in Baum SMPEDIT
  LET arrange&=86 ! ICON in Baum SMPEDIT
  LET smpload&=87 ! ICON in Baum SMPEDIT
  LET smpsave&=88 ! ICON in Baum SMPEDIT
  LET infoicon&=89 ! ICON in Baum SMPEDIT
  LET edmidi&=90 ! ICON in Baum SMPEDIT
  LET trak&=91 ! ICON in Baum SMPEDIT
  LET edsmp16&=92 ! ICON in Baum SMPEDIT
  LET swdsp&=93 ! ICON in Baum SMPEDIT
  LET smpdbank&=94 ! ICON in Baum SMPEDIT
  LET swmark&=95 ! ICON in Baum SMPEDIT
  LET wmodes&=96 ! ICON in Baum SMPEDIT
  LET swyzoom&=97 ! ICON in Baum SMPEDIT
  LET swclick&=98 ! ICON in Baum SMPEDIT
  LET swdraw&=99 ! ICON in Baum SMPEDIT
  LET swblk&=100 ! ICON in Baum SMPEDIT
  LET scrubs&=101 ! ICON in Baum SMPEDIT
  LET swsearch&=102 ! ICON in Baum SMPEDIT
  LET curvbox&=103 ! BOX in Baum SMPEDIT
  LET editbox4&=104 ! BOX in Baum SMPEDIT
  LET editbox8&=105 ! BOX in Baum SMPEDIT
  LET smptxr&=106 ! TEXT in Baum SMPEDIT
  LET smptxl&=107 ! TEXT in Baum SMPEDIT
  LET rm80&=108 ! BOXTEXT in Baum SMPEDIT
  LET rp0&=109 ! BOXTEXT in Baum SMPEDIT
  LET rp80&=110 ! BOXTEXT in Baum SMPEDIT
  LET rp60&=111 ! BOXTEXT in Baum SMPEDIT
  LET rp40&=112 ! BOXTEXT in Baum SMPEDIT
  LET rm60&=113 ! BOXTEXT in Baum SMPEDIT
  LET rm40&=114 ! BOXTEXT in Baum SMPEDIT
  LET lp80&=115 ! BOXTEXT in Baum SMPEDIT
  LET lm80&=116 ! BOXTEXT in Baum SMPEDIT
  LET lp40&=117 ! BOXTEXT in Baum SMPEDIT
  LET lp60&=118 ! BOXTEXT in Baum SMPEDIT
  LET lm60&=119 ! BOXTEXT in Baum SMPEDIT
  LET lm40&=120 ! BOXTEXT in Baum SMPEDIT
  LET lm20&=121 ! BOXTEXT in Baum SMPEDIT
  LET lp0&=122 ! BOXTEXT in Baum SMPEDIT
  LET rp20&=123 ! BOXTEXT in Baum SMPEDIT
  LET rm20&=124 ! BOXTEXT in Baum SMPEDIT
  LET lp20&=125 ! BOXTEXT in Baum SMPEDIT
  LET scrlslde&=126 ! BOX in Baum SMPEDIT
  LET scrolbut&=127 ! BUTTON in Baum SMPEDIT
  LET lscroll&=128 ! ICON in Baum SMPEDIT
  LET rscroll&=129 ! ICON in Baum SMPEDIT
  '
  LET dspedit&=2 ! Formular/Dialog
  LET dspbox&=0 ! BOX in Baum DSPEDIT
  LET dspecho&=3 ! BUTTON in Baum DSPEDIT
  LET dsphall&=4 ! BUTTON in Baum DSPEDIT
  LET dsplow&=5 ! BUTTON in Baum DSPEDIT
  LET dsphigh&=6 ! BUTTON in Baum DSPEDIT
  LET dspband&=7 ! BUTTON in Baum DSPEDIT
  LET dspflang&=8 ! BUTTON in Baum DSPEDIT
  LET dspchor&=9 ! BUTTON in Baum DSPEDIT
  LET dspeq&=10 ! BUTTON in Baum DSPEDIT
  LET dsppink&=11 ! BUTTON in Baum DSPEDIT
  LET dsppass&=12 ! BUTTON in Baum DSPEDIT
  LET dspload&=13 ! BUTTON in Baum DSPEDIT
  LET dspsave&=14 ! BUTTON in Baum DSPEDIT
  LET helpdsp&=15 ! BOXTEXT in Baum DSPEDIT
  LET dspexit&=16 ! BUTTON in Baum DSPEDIT
  '
  LET peak&=3 ! Formular/Dialog
  LET peakbox&=0 ! BOX in Baum PEAK
  LET plmax&=4 ! BUTTON in Baum PEAK
  LET prmax&=5 ! BUTTON in Baum PEAK
  LET peakbox2&=6 ! BOX in Baum PEAK
  LET volbox&=17 ! BOX in Baum PEAK
  LET volume&=19 ! ICON in Baum PEAK
  LET smpautop&=21 ! ICON in Baum PEAK
  LET smpstrtp&=22 ! ICON in Baum PEAK
  LET playpeak&=23 ! ICON in Baum PEAK
  LET peakexit&=24 ! BUTTON in Baum PEAK
  LET peakpos&=25 ! BOXTEXT in Baum PEAK
  LET peakmax&=26 ! BOXTEXT in Baum PEAK
  LET recerror&=29 ! BOXTEXT in Baum PEAK
  LET peakhelp&=31 ! BOXTEXT in Baum PEAK
  LET balbox&=32 ! BOXTEXT in Baum PEAK
  LET balance&=34 ! ICON in Baum PEAK
  LET peakl&=36 ! ICON in Baum PEAK
  LET peakr&=37 ! ICON in Baum PEAK
  LET recpeaks&=38 ! BOXTEXT in Baum PEAK
  LET peakdb&=41 ! BOXTEXT in Baum PEAK
  LET peakmute&=42 ! ICON in Baum PEAK
  LET balzero&=43 ! ICON in Baum PEAK
  LET peakbal&=44 ! BOXTEXT in Baum PEAK
  LET hardpeak&=64 ! ICON in Baum PEAK
  LET playstop&=65 ! ICON in Baum PEAK
  LET peakwait&=66 ! ICON in Baum PEAK
  LET volinout&=69 ! ICON in Baum PEAK
  LET peakch1&=70 ! BOXTEXT in Baum PEAK
  LET peakch4&=71 ! BOXTEXT in Baum PEAK
  LET peakch2&=72 ! BOXTEXT in Baum PEAK
  LET peakch3&=73 ! BOXTEXT in Baum PEAK
  LET peakname&=74 ! BOXTEXT in Baum PEAK
  '
  LET loop&=4 ! Formular/Dialog
  LET loopbox&=0 ! BOX in Baum LOOP
  LET loopexit&=1 ! BUTTON in Baum LOOP
  LET loopbox2&=2 ! BOX in Baum LOOP
  LET forw&=3 ! BUTTON in Baum LOOP
  LET cross&=4 ! BUTTON in Baum LOOP
  LET backw&=5 ! BUTTON in Baum LOOP
  LET helploop&=7 ! BOXTEXT in Baum LOOP
  LET autoloop&=8 ! BUTTON in Baum LOOP
  '
  LET normaliz&=5 ! Formular/Dialog
  LET normbox&=0 ! BOX in Baum NORMALIZ
  LET normok&=2 ! BUTTON in Baum NORMALIZ
  LET normexit&=3 ! BUTTON in Baum NORMALIZ
  LET maxdb&=4 ! BOXTEXT in Baum NORMALIZ
  LET normbox2&=6 ! BOX in Baum NORMALIZ
  LET normauto&=7 ! BUTTON in Baum NORMALIZ
  LET normadj&=8 ! BUTTON in Baum NORMALIZ
  LET normbox3&=9 ! BOX in Baum NORMALIZ
  LET norml1&=10 ! ICON in Baum NORMALIZ
  LET norml2&=11 ! ICON in Baum NORMALIZ
  LET norml3&=12 ! ICON in Baum NORMALIZ
  LET normr1&=13 ! ICON in Baum NORMALIZ
  LET normr2&=14 ! ICON in Baum NORMALIZ
  LET normr3&=15 ! ICON in Baum NORMALIZ
  LET helpnorm&=16 ! BOXTEXT in Baum NORMALIZ
  LET normdb&=18 ! BOXTEXT in Baum NORMALIZ
  '
  LET resample&=6 ! Formular/Dialog
  LET resmpbox&=0 ! BOX in Baum RESAMPLE
  LET adjresmp&=1 ! BUTTON in Baum RESAMPLE
  LET helprsmp&=2 ! BOXTEXT in Baum RESAMPLE
  LET rsmptxt1&=3 ! TEXT in Baum RESAMPLE
  LET resmpbx2&=4 ! BOX in Baum RESAMPLE
  LET restxt&=5 ! FTEXT in Baum RESAMPLE
  LET resmpsec&=6 ! BOXTEXT in Baum RESAMPLE
  LET resmplen&=7 ! BOXTEXT in Baum RESAMPLE
  LET resmpfac&=8 ! BOXTEXT in Baum RESAMPLE
  LET rsmptxt2&=10 ! TEXT in Baum RESAMPLE
  LET resother&=11 ! BOXTEXT in Baum RESAMPLE
  LET resok&=12 ! BUTTON in Baum RESAMPLE
  LET resexit&=13 ! BUTTON in Baum RESAMPLE
  LET res32&=15 ! BUTTON in Baum RESAMPLE
  LET res44&=16 ! BUTTON in Baum RESAMPLE
  LET res48&=17 ! BUTTON in Baum RESAMPLE
  LET resr3&=18 ! ICON in Baum RESAMPLE
  LET resr2&=19 ! ICON in Baum RESAMPLE
  LET resr1&=20 ! ICON in Baum RESAMPLE
  LET resl1&=21 ! ICON in Baum RESAMPLE
  LET resl2&=22 ! ICON in Baum RESAMPLE
  LET resl3&=23 ! ICON in Baum RESAMPLE
  '
  LET midiedit&=7 ! Formular/Dialog
  LET midibox&=0 ! BOX in Baum MIDIEDIT
  LET notetxt&=1 ! BOXTEXT in Baum MIDIEDIT
  LET chtxt&=3 ! BOXTEXT in Baum MIDIEDIT
  LET midiok&=5 ! BUTTON in Baum MIDIEDIT
  LET helpmidi&=7 ! BOXTEXT in Baum MIDIEDIT
  LET midinup&=10 ! ICON in Baum MIDIEDIT
  LET midioup&=11 ! ICON in Baum MIDIEDIT
  LET midindwn&=12 ! ICON in Baum MIDIEDIT
  LET midiodwn&=13 ! ICON in Baum MIDIEDIT
  LET midicup&=14 ! ICON in Baum MIDIEDIT
  LET midicdwn&=15 ! ICON in Baum MIDIEDIT
  '
  LET editfade&=8 ! Formular/Dialog
  LET fadebox&=0 ! BOX in Baum EDITFADE
  LET fadexit&=2 ! BUTTON in Baum EDITFADE
  LET fadelin&=4 ! BUTTON in Baum EDITFADE
  LET edfadbox&=5 ! BOX in Baum EDITFADE
  LET infade&=6 ! BUTTON in Baum EDITFADE
  LET ausfade&=7 ! BUTTON in Baum EDITFADE
  LET helpfade&=8 ! BOXTEXT in Baum EDITFADE
  LET fadexp&=9 ! BUTTON in Baum EDITFADE
  LET fadesqrt&=10 ! BUTTON in Baum EDITFADE
  LET fadeundo&=11 ! BUTTON in Baum EDITFADE
  LET fadedel&=12 ! BUTTON in Baum EDITFADE
  LET fdsquare&=13 ! BUTTON in Baum EDITFADE
  LET fadelog&=14 ! BUTTON in Baum EDITFADE
  LET fadload&=15 ! BUTTON in Baum EDITFADE
  LET fadsave&=16 ! BUTTON in Baum EDITFADE
  '
  LET popups&=9 ! Formular/Dialog
  LET smppopup&=1 ! BOX in Baum POPUPS
  LET rate32&=2 ! STRING in Baum POPUPS
  LET rate44&=3 ! STRING in Baum POPUPS
  LET rate48&=4 ! STRING in Baum POPUPS
  LET rate88&=5 ! STRING in Baum POPUPS
  LET rate96&=6 ! STRING in Baum POPUPS
  LET rate8&=7 ! STRING in Baum POPUPS
  LET rate11&=8 ! STRING in Baum POPUPS
  LET rate12&=9 ! STRING in Baum POPUPS
  LET rate16&=10 ! STRING in Baum POPUPS
  LET rate17&=11 ! STRING in Baum POPUPS
  LET rate22&=12 ! STRING in Baum POPUPS
  LET rate24&=13 ! STRING in Baum POPUPS
  LET rate33&=14 ! STRING in Baum POPUPS
  LET ratexth2&=15 ! STRING in Baum POPUPS
  LET ratextl2&=16 ! STRING in Baum POPUPS
  LET ratexth1&=17 ! STRING in Baum POPUPS
  LET ratextl1&=18 ! STRING in Baum POPUPS
  LET ratediv&=19 ! STRING in Baum POPUPS
  LET dsppopup&=20 ! BOX in Baum POPUPS
  LET dspoff&=21 ! STRING in Baum POPUPS
  LET dspin&=22 ! STRING in Baum POPUPS
  LET dspout&=23 ! STRING in Baum POPUPS
  LET smppop2&=24 ! BOX in Baum POPUPS
  LET ad32&=25 ! STRING in Baum POPUPS
  LET ad44&=26 ! STRING in Baum POPUPS
  LET ad48&=27 ! STRING in Baum POPUPS
  LET ad88&=28 ! STRING in Baum POPUPS
  LET ad96&=29 ! STRING in Baum POPUPS
  LET ad8&=30 ! STRING in Baum POPUPS
  LET ad11&=31 ! STRING in Baum POPUPS
  LET ad12&=32 ! STRING in Baum POPUPS
  LET ad16&=33 ! STRING in Baum POPUPS
  LET ad17&=34 ! STRING in Baum POPUPS
  LET ad22&=35 ! STRING in Baum POPUPS
  LET ad24&=36 ! STRING in Baum POPUPS
  LET ad33&=37 ! STRING in Baum POPUPS
  LET adexth2&=38 ! STRING in Baum POPUPS
  LET adextl2&=39 ! STRING in Baum POPUPS
  LET adexth1&=40 ! STRING in Baum POPUPS
  LET adextl1&=41 ! STRING in Baum POPUPS
  LET addiv&=42 ! STRING in Baum POPUPS
  LET inpop&=43 ! BOX in Baum POPUPS
  LET analog&=44 ! STRING in Baum POPUPS
  LET digital&=45 ! STRING in Baum POPUPS
  LET srcpop&=46 ! BOX in Baum POPUPS
  LET opto&=47 ! STRING in Baum POPUPS
  LET coax&=48 ! STRING in Baum POPUPS
  LET aesebu&=49 ! STRING in Baum POPUPS
  LET popmark&=50 ! BOX in Baum POPUPS
  LET smpmark&=51 ! STRING in Baum POPUPS
  LET smpzoom&=52 ! STRING in Baum POPUPS
  LET smpscrol&=53 ! STRING in Baum POPUPS
  LET kopy&=54 ! STRING in Baum POPUPS
  LET move&=55 ! STRING in Baum POPUPS
  LET insert&=56 ! STRING in Baum POPUPS
  LET merge&=57 ! STRING in Baum POPUPS
  LET fade&=58 ! STRING in Baum POPUPS
  LET popmake&=59 ! BOX in Baum POPUPS
  LET make32&=60 ! STRING in Baum POPUPS
  LET make44&=61 ! STRING in Baum POPUPS
  LET make48&=62 ! STRING in Baum POPUPS
  LET make88&=63 ! STRING in Baum POPUPS
  LET make96&=64 ! STRING in Baum POPUPS
  LET popform&=65 ! BOX in Baum POPUPS
  LET sets16&=66 ! STRING in Baum POPUPS
  LET setwav&=67 ! STRING in Baum POPUPS
  LET setavr&=68 ! STRING in Baum POPUPS
  LET setaif&=69 ! STRING in Baum POPUPS
  LET setsnd&=70 ! STRING in Baum POPUPS
  LET setsd&=71 ! STRING in Baum POPUPS
  LET setau&=72 ! STRING in Baum POPUPS
  LET setsmp&=73 ! STRING in Baum POPUPS
  LET setall&=74 ! STRING in Baum POPUPS
  LET popscms&=75 ! BOX in Baum POPUPS
  LET scmsno&=76 ! STRING in Baum POPUPS
  LET scmsone&=77 ! STRING in Baum POPUPS
  LET scmsfree&=78 ! STRING in Baum POPUPS
  LET modepop&=79 ! BOX in Baum POPUPS
  LET consumer&=80 ! STRING in Baum POPUPS
  LET profess&=81 ! STRING in Baum POPUPS
  LET emphpop&=82 ! BOX in Baum POPUPS
  LET emphoff&=83 ! STRING in Baum POPUPS
  LET emphon&=84 ! STRING in Baum POPUPS
  '
  LET record&=10 ! Formular/Dialog
  LET recbox&=0 ! BOX in Baum RECORD
  LET recfree&=1 ! BOXTEXT in Baum RECORD
  LET recok&=2 ! BUTTON in Baum RECORD
  LET recexit&=3 ! BUTTON in Baum RECORD
  LET timemeld&=4 ! TEXT in Baum RECORD
  LET rechelp&=5 ! BOXTEXT in Baum RECORD
  LET timetxt&=9 ! FTEXT in Baum RECORD
  LET tinpul1&=12 ! ICON in Baum RECORD
  LET tinpul2&=14 ! ICON in Baum RECORD
  LET tinpul3&=15 ! ICON in Baum RECORD
  LET tinpul4&=16 ! ICON in Baum RECORD
  LET tinpuh1&=17 ! ICON in Baum RECORD
  LET tinpuh2&=18 ! ICON in Baum RECORD
  LET tinpuh3&=19 ! ICON in Baum RECORD
  LET tinpuh4&=20 ! ICON in Baum RECORD
  LET tinpdh1&=21 ! ICON in Baum RECORD
  LET tinpdh2&=22 ! ICON in Baum RECORD
  LET tinpdh3&=23 ! ICON in Baum RECORD
  LET tinpdh4&=24 ! ICON in Baum RECORD
  LET tinpdl1&=25 ! ICON in Baum RECORD
  LET tinpdl2&=26 ! ICON in Baum RECORD
  LET tinpdl3&=27 ! ICON in Baum RECORD
  LET tinpdl4&=28 ! ICON in Baum RECORD
  '
  LET blkfunc&=11 ! Formular/Dialog
  LET blkbox&=0 ! BOX in Baum BLKFUNC
  LET cutin&=1 ! ICON in Baum BLKFUNC
  LET cutout&=2 ! ICON in Baum BLKFUNC
  LET blkexit&=3 ! BUTTON in Baum BLKFUNC
  LET blkhelp&=5 ! BOXTEXT in Baum BLKFUNC
  LET cutdel&=6 ! ICON in Baum BLKFUNC
  LET norm&=10 ! ICON in Baum BLKFUNC
  LET resmp&=11 ! ICON in Baum BLKFUNC
  LET mono&=12 ! ICON in Baum BLKFUNC
  LET conmix&=13 ! ICON in Baum BLKFUNC
  LET conins&=14 ! ICON in Baum BLKFUNC
  LET conspace&=15 ! ICON in Baum BLKFUNC
  LET negate&=23 ! ICON in Baum BLKFUNC
  LET lrchange&=25 ! ICON in Baum BLKFUNC
  '
  LET savebloc&=12 ! Formular/Dialog
  LET savebox&=0 ! BOX in Baum SAVEBLOC
  LET savall&=1 ! ICON in Baum SAVEBLOC
  LET savblock&=2 ! ICON in Baum SAVEBLOC
  LET savexit&=3 ! BUTTON in Baum SAVEBLOC
  LET savetxt&=4 ! TEXT in Baum SAVEBLOC
  LET savehelp&=5 ! BOXTEXT in Baum SAVEBLOC
  '
  LET arranger&=13 ! Formular/Dialog
  LET arrbox&=0 ! BOX in Baum ARRANGER
  LET arrbox2&=1 ! BOX in Baum ARRANGER
  LET hlpedit2&=2 ! ICON in Baum ARRANGER
  LET arrload&=3 ! ICON in Baum ARRANGER
  LET arrsave&=4 ! ICON in Baum ARRANGER
  LET arrmidi&=5 ! ICON in Baum ARRANGER
  LET arrins&=6 ! ICON in Baum ARRANGER
  LET arrdel&=7 ! ICON in Baum ARRANGER
  LET smpauto3&=9 ! ICON in Baum ARRANGER
  LET smpstrt3&=10 ! ICON in Baum ARRANGER
  LET pause&=11 ! ICON in Baum ARRANGER
  LET rewind&=12 ! ICON in Baum ARRANGER
  LET recplay&=13 ! ICON in Baum ARRANGER
  LET smpplay2&=14 ! ICON in Baum ARRANGER
  LET smprplay&=15 ! ICON in Baum ARRANGER
  LET forward&=16 ! ICON in Baum ARRANGER
  LET arrstrt&=17 ! ICON in Baum ARRANGER
  LET arrend&=18 ! ICON in Baum ARRANGER
  LET stop&=19 ! ICON in Baum ARRANGER
  LET arrbox4&=20 ! BOX in Baum ARRANGER
  LET playlen&=21 ! BOXTEXT in Baum ARRANGER
  LET arreal&=22 ! ICON in Baum ARRANGER
  LET arrblk&=23 ! ICON in Baum ARRANGER
  LET arrbox3&=24 ! BOX in Baum ARRANGER
  LET arrbox5&=25 ! BOX in Baum ARRANGER
  LET hardfs1&=26 ! BUTTON in Baum ARRANGER
  LET spur1&=27 ! BOXTEXT in Baum ARRANGER
  LET arrbox6&=28 ! BOX in Baum ARRANGER
  LET hardfs2&=29 ! BUTTON in Baum ARRANGER
  LET spur2&=30 ! BOXTEXT in Baum ARRANGER
  LET arrbox7&=31 ! BOX in Baum ARRANGER
  LET hardfs3&=32 ! BUTTON in Baum ARRANGER
  LET spur3&=33 ! BOXTEXT in Baum ARRANGER
  LET arrbox8&=34 ! BOX in Baum ARRANGER
  LET hardfs4&=35 ! BUTTON in Baum ARRANGER
  LET spur4&=36 ! BOXTEXT in Baum ARRANGER
  LET hardst2&=38 ! BOXTEXT in Baum ARRANGER
  LET hardst3&=40 ! BOXTEXT in Baum ARRANGER
  LET hardst4&=42 ! BOXTEXT in Baum ARRANGER
  LET harde2&=44 ! BOXTEXT in Baum ARRANGER
  LET harde3&=46 ! BOXTEXT in Baum ARRANGER
  LET harde4&=48 ! BOXTEXT in Baum ARRANGER
  LET harde1&=50 ! BOXTEXT in Baum ARRANGER
  LET hardlen1&=52 ! BOXTEXT in Baum ARRANGER
  LET hardlen2&=54 ! BOXTEXT in Baum ARRANGER
  LET hardlen3&=56 ! BOXTEXT in Baum ARRANGER
  LET hardlen4&=58 ! BOXTEXT in Baum ARRANGER
  LET arrnr1&=61 ! BOXTEXT in Baum ARRANGER
  LET arrnr2&=63 ! BOXTEXT in Baum ARRANGER
  LET arrnr3&=65 ! BOXTEXT in Baum ARRANGER
  LET arrm1&=66 ! ICON in Baum ARRANGER
  LET arrm2&=67 ! ICON in Baum ARRANGER
  LET arrm3&=68 ! ICON in Baum ARRANGER
  LET arrm4&=69 ! ICON in Baum ARRANGER
  LET hardst1&=71 ! BOXTEXT in Baum ARRANGER
  LET arrnote2&=73 ! BOXTEXT in Baum ARRANGER
  LET arrnote3&=75 ! BOXTEXT in Baum ARRANGER
  LET arrnote4&=77 ! BOXTEXT in Baum ARRANGER
  LET arrnr4&=81 ! BOXTEXT in Baum ARRANGER
  LET arrmem1&=83 ! BOXTEXT in Baum ARRANGER
  LET arrmem2&=85 ! BOXTEXT in Baum ARRANGER
  LET arrmem3&=87 ! BOXTEXT in Baum ARRANGER
  LET arrmem4&=89 ! BOXTEXT in Baum ARRANGER
  LET arrnote1&=91 ! BOXTEXT in Baum ARRANGER
  LET arrch1&=93 ! BOXTEXT in Baum ARRANGER
  LET arrch2&=95 ! BOXTEXT in Baum ARRANGER
  LET arrch3&=97 ! BOXTEXT in Baum ARRANGER
  LET arrch4&=99 ! BOXTEXT in Baum ARRANGER
  LET arrtri1&=101 ! BUTTON in Baum ARRANGER
  LET arrtri2&=102 ! BUTTON in Baum ARRANGER
  LET arrtri3&=103 ! BUTTON in Baum ARRANGER
  LET arrtri4&=104 ! BUTTON in Baum ARRANGER
  LET arrloop1&=107 ! ICON in Baum ARRANGER
  LET arrloop2&=108 ! ICON in Baum ARRANGER
  LET arrloop3&=109 ! ICON in Baum ARRANGER
  LET arrloop4&=110 ! ICON in Baum ARRANGER
  LET arrsmpr1&=114 ! BOXTEXT in Baum ARRANGER
  LET arrsmpr2&=116 ! BOXTEXT in Baum ARRANGER
  LET arrsmpr3&=118 ! BOXTEXT in Baum ARRANGER
  LET arrsmpr4&=120 ! BOXTEXT in Baum ARRANGER
  LET arrdel1&=125 ! ICON in Baum ARRANGER
  LET arrdel2&=126 ! ICON in Baum ARRANGER
  LET arrdel3&=127 ! ICON in Baum ARRANGER
  LET arrdel4&=128 ! ICON in Baum ARRANGER
  LET hardstrt&=129 ! ICON in Baum ARRANGER
  LET hardend&=130 ! ICON in Baum ARRANGER
  LET arrplay1&=133 ! ICON in Baum ARRANGER
  LET arrplay2&=134 ! ICON in Baum ARRANGER
  LET arrplay3&=135 ! ICON in Baum ARRANGER
  LET arrplay4&=136 ! ICON in Baum ARRANGER
  LET arrslide&=137 ! BOX in Baum ARRANGER
  LET arrslbut&=138 ! BUTTON in Baum ARRANGER
  LET arrexit&=139 ! BUTTON in Baum ARRANGER
  LET arrhelp&=140 ! BOXTEXT in Baum ARRANGER
  LET arrclip&=141 ! ICON in Baum ARRANGER
  LET arrprint&=142 ! ICON in Baum ARRANGER
  LET klavier&=143 ! ICON in Baum ARRANGER
  LET slideup&=144 ! ICON in Baum ARRANGER
  LET slidedwn&=145 ! ICON in Baum ARRANGER
  LET playname&=146 ! BOXTEXT in Baum ARRANGER
  LET arrtrash&=147 ! ICON in Baum ARRANGER
  '
  LET setup&=14 ! Formular/Dialog
  LET setupbox&=0 ! BOX in Baum SETUP
  LET sync&=2 ! BUTTON in Baum SETUP
  LET fseldef&=4 ! BUTTON in Baum SETUP
  LET fseltxt&=6 ! BOXTEXT in Baum SETUP
  LET setform&=8 ! BOXTEXT in Baum SETUP
  LET setfbut&=9 ! BOXCHAR in Baum SETUP
  LET seclen&=13 ! BOXTEXT in Baum SETUP
  LET secl&=14 ! BUTTON in Baum SETUP
  LET secr&=15 ! BUTTON in Baum SETUP
  LET nfsbut&=17 ! BUTTON in Baum SETUP
  LET mallmax&=20 ! BUTTON in Baum SETUP
  LET setupbx2&=21 ! BOX in Baum SETUP
  LET lenmall&=22 ! FTEXT in Baum SETUP
  LET sethelp&=23 ! BOXTEXT in Baum SETUP
  LET recm&=26 ! BOXTEXT in Baum SETUP
  LET recl&=27 ! BUTTON in Baum SETUP
  LET recr&=28 ! BUTTON in Baum SETUP
  LET tresdb&=31 ! BOXTEXT in Baum SETUP
  LET tresl&=32 ! BUTTON in Baum SETUP
  LET tresr&=33 ! BUTTON in Baum SETUP
  LET setexit&=34 ! BUTTON in Baum SETUP
  LET setsave&=35 ! BUTTON in Baum SETUP
  LET setload&=36 ! BUTTON in Baum SETUP
  LET setok&=37 ! BUTTON in Baum SETUP
  LET dreide&=38 ! BUTTON in Baum SETUP
  LET flip&=39 ! BUTTON in Baum SETUP
  LET timeset&=40 ! BUTTON in Baum SETUP
  LET setshow&=41 ! BUTTON in Baum SETUP
  LET setupbx3&=43 ! BOX in Baum SETUP
  LET vertline&=44 ! BUTTON in Baum SETUP
  LET linkdot&=45 ! BUTTON in Baum SETUP
  LET spacefil&=46 ! BUTTON in Baum SETUP
  LET zoomy&=47 ! BUTTON in Baum SETUP
  LET grid&=48 ! BUTTON in Baum SETUP
  LET posy&=49 ! BUTTON in Baum SETUP
  LET zerosnap&=50 ! BUTTON in Baum SETUP
  LET frec&=51 ! BUTTON in Baum SETUP
  LET menuset&=52 ! BUTTON in Baum SETUP
  LET freeze&=54 ! BUTTON in Baum SETUP
  LET viewset&=55 ! BUTTON in Baum SETUP
  LET emulset&=56 ! BUTTON in Baum SETUP
  '
  LET info&=15 ! Formular/Dialog
  LET infobox&=0 ! BOX in Baum INFO
  LET infoexit&=1 ! BUTTON in Baum INFO
  LET helpinfo&=2 ! BOXTEXT in Baum INFO
  LET infobild&=3 ! ICON in Baum INFO
  LET cpyright&=12 ! TEXT in Baum INFO
  '
  LET arrmname&=16 ! Formular/Dialog
  LET arrmnbox&=0 ! BOX in Baum ARRMNAME
  LET arrmnbx2&=1 ! BOX in Baum ARRMNAME
  LET memname&=2 ! FTEXT in Baum ARRMNAME
  LET amexit&=4 ! BUTTON in Baum ARRMNAME
  LET amhelp&=5 ! BOXTEXT in Baum ARRMNAME
  LET amok&=6 ! BUTTON in Baum ARRMNAME
  '
  LET virtual&=17 ! Formular/Dialog
  LET virtbox&=0 ! BOX in Baum VIRTUAL
  LET virthelp&=2 ! BOXTEXT in Baum VIRTUAL
  LET virtbloc&=4 ! BUTTON in Baum VIRTUAL
  LET virtok&=5 ! BUTTON in Baum VIRTUAL
  LET virtbox3&=6 ! BOX in Baum VIRTUAL
  LET vblkstrt&=7 ! FTEXT in Baum VIRTUAL
  LET vseconds&=8 ! BUTTON in Baum VIRTUAL
  LET vsamples&=9 ! BUTTON in Baum VIRTUAL
  LET vblkmlen&=10 ! BOXTEXT in Baum VIRTUAL
  LET vblkvlen&=12 ! BOXTEXT in Baum VIRTUAL
  LET vslider&=13 ! BOX in Baum VIRTUAL
  LET vslbut&=14 ! BUTTON in Baum VIRTUAL
  LET virtbox2&=15 ! BOX in Baum VIRTUAL
  LET virtwork&=16 ! BUTTON in Baum VIRTUAL
  LET virtdir&=17 ! BUTTON in Baum VIRTUAL
  LET vrslide&=18 ! ICON in Baum VIRTUAL
  LET vlslide&=19 ! ICON in Baum VIRTUAL
  LET virtno&=20 ! BUTTON in Baum VIRTUAL
  LET virtplay&=21 ! ICON in Baum VIRTUAL
  LET virtstop&=24 ! ICON in Baum VIRTUAL
  '
  LET moving&=18 ! Formular/Dialog
  LET movngbox&=0 ! BOX in Baum MOVING
  LET movhlp&=1 ! BOXTEXT in Baum MOVING
  LET mvcutcpy&=3 ! BUTTON in Baum MOVING
  LET mvcutins&=4 ! BUTTON in Baum MOVING
  LET mvclrins&=5 ! BUTTON in Baum MOVING
  LET mvclrcpy&=6 ! BUTTON in Baum MOVING
  LET movexit&=7 ! BUTTON in Baum MOVING
  '
  LET arrmake&=19 ! Formular/Dialog
  LET makebox&=0 ! BOX in Baum ARRMAKE
  LET maketxt&=4 ! BOXTEXT in Baum ARRMAKE
  LET makefsel&=5 ! BUTTON in Baum ARRMAKE
  LET makerate&=6 ! BOXTEXT in Baum ARRMAKE
  LET makehelp&=9 ! BOXTEXT in Baum ARRMAKE
  LET makeok&=10 ! BUTTON in Baum ARRMAKE
  LET makexit&=11 ! BUTTON in Baum ARRMAKE
  '
  LET timeed&=20 ! Formular/Dialog
  LET timebox&=0 ! BOX in Baum TIMEED
  LET timebox2&=1 ! BOX in Baum TIMEED
  LET tedtxt&=2 ! FTEXT in Baum TIMEED
  LET tedexit&=4 ! BUTTON in Baum TIMEED
  LET tedhelp&=5 ! BOXTEXT in Baum TIMEED
  LET tedok&=6 ! BUTTON in Baum TIMEED
  '
  LET abackup&=21 ! Formular/Dialog
  LET abackbox&=0 ! BOX in Baum ABACKUP
  LET abacktxt&=1 ! BOXTEXT in Baum ABACKUP
  LET abackok&=2 ! BUTTON in Baum ABACKUP
  LET abackex&=3 ! BUTTON in Baum ABACKUP
  LET abackhlp&=5 ! BOXTEXT in Baum ABACKUP
  LET abackr1&=8 ! ICON in Baum ABACKUP
  LET abackr2&=9 ! ICON in Baum ABACKUP
  LET abackl1&=10 ! ICON in Baum ABACKUP
  LET abackl2&=11 ! ICON in Baum ABACKUP
  LET abackbo2&=12 ! BOX in Baum ABACKUP
  LET aback&=13 ! BUTTON in Baum ABACKUP
  LET abacknam&=14 ! BUTTON in Baum ABACKUP
  '
  LET inftxt&=22 ! Formular/Dialog
  LET infbox&=0 ! BOX in Baum INFTXT
  LET infbox2&=1 ! BOX in Baum INFTXT
  LET inftitel&=2 ! BUTTON in Baum INFTXT
  '
  LET smpinf&=23 ! Formular/Dialog
  LET sinfbox&=0 ! BOX in Baum SMPINF
  LET sinfok&=1 ! BUTTON in Baum SMPINF
  LET sinfexit&=2 ! BUTTON in Baum SMPINF
  LET sinfhelp&=3 ! BOXTEXT in Baum SMPINF
  LET sinfname&=6 ! BOXTEXT in Baum SMPINF
  LET sinflen&=8 ! BOXTEXT in Baum SMPINF
  LET sinfrate&=10 ! BOXTEXT in Baum SMPINF
  LET sinfsus2&=15 ! BOXTEXT in Baum SMPINF
  LET sinfrel2&=16 ! BOXTEXT in Baum SMPINF
  LET sinfl5&=18 ! BOXTEXT in Baum SMPINF
  LET sinfl6&=19 ! BOXTEXT in Baum SMPINF
  LET sinfl7&=22 ! BOXTEXT in Baum SMPINF
  LET sinfl8&=23 ! BOXTEXT in Baum SMPINF
  LET sinfl1&=24 ! BOXTEXT in Baum SMPINF
  LET sinfl2&=26 ! BOXTEXT in Baum SMPINF
  LET sinfl3&=28 ! BOXTEXT in Baum SMPINF
  LET sinfl4&=30 ! BOXTEXT in Baum SMPINF
  LET sinfdate&=32 ! BOXTEXT in Baum SMPINF
  LET sinfrel1&=33 ! BOXTEXT in Baum SMPINF
  LET sinfsus1&=34 ! BOXTEXT in Baum SMPINF
  LET sinfbox2&=35 ! BOX in Baum SMPINF
  LET sinfcomm&=36 ! FTEXT in Baum SMPINF
  LET sinfsrc&=37 ! FTEXT in Baum SMPINF
  LET sinfl9&=40 ! BOXTEXT in Baum SMPINF
  LET sinfl10&=41 ! BOXTEXT in Baum SMPINF
  LET sinfl11&=42 ! BOXTEXT in Baum SMPINF
  LET sinfl12&=43 ! BOXTEXT in Baum SMPINF
  '
  LET trakker&=24 ! Formular/Dialog
  LET trakbox&=0 ! BOX in Baum TRAKKER
  LET trakbox2&=1 ! BOX in Baum TRAKKER
  LET trakbox5&=2 ! BOX in Baum TRAKKER
  LET trkbx1&=3 ! BOX in Baum TRAKKER
  LET trklevo1&=4 ! ICON in Baum TRAKKER
  LET trklevt1&=5 ! BOXTEXT in Baum TRAKKER
  LET trklevu1&=6 ! ICON in Baum TRAKKER
  LET trkmute1&=7 ! ICON in Baum TRAKKER
  LET trakk1&=8 ! BOXTEXT in Baum TRAKKER
  LET trksolo1&=9 ! ICON in Baum TRAKKER
  LET trkact1&=10 ! ICON in Baum TRAKKER
  LET trkbx3&=11 ! BOX in Baum TRAKKER
  LET trklevo3&=12 ! ICON in Baum TRAKKER
  LET trklevt3&=13 ! BOXTEXT in Baum TRAKKER
  LET trklevu3&=14 ! ICON in Baum TRAKKER
  LET trkmute3&=15 ! ICON in Baum TRAKKER
  LET trakk3&=16 ! BOXTEXT in Baum TRAKKER
  LET trksolo3&=17 ! ICON in Baum TRAKKER
  LET trkact3&=18 ! ICON in Baum TRAKKER
  LET trktxt3&=19 ! BOXTEXT in Baum TRAKKER
  LET panl3&=20 ! ICON in Baum TRAKKER
  LET pantxt3&=21 ! BOXTEXT in Baum TRAKKER
  LET trkbx4&=22 ! BOX in Baum TRAKKER
  LET trklevo4&=23 ! ICON in Baum TRAKKER
  LET trklevt4&=24 ! BOXTEXT in Baum TRAKKER
  LET trklevu4&=25 ! ICON in Baum TRAKKER
  LET trkmute4&=26 ! ICON in Baum TRAKKER
  LET trakk4&=27 ! BOXTEXT in Baum TRAKKER
  LET trksolo4&=28 ! ICON in Baum TRAKKER
  LET trkact4&=29 ! ICON in Baum TRAKKER
  LET trktxt4&=30 ! BOXTEXT in Baum TRAKKER
  LET panl4&=31 ! ICON in Baum TRAKKER
  LET pantxt4&=32 ! BOXTEXT in Baum TRAKKER
  LET trkbx2&=33 ! BOX in Baum TRAKKER
  LET trklevo2&=34 ! ICON in Baum TRAKKER
  LET trklevt2&=35 ! BOXTEXT in Baum TRAKKER
  LET trklevu2&=36 ! ICON in Baum TRAKKER
  LET trkmute2&=37 ! ICON in Baum TRAKKER
  LET trakk2&=38 ! BOXTEXT in Baum TRAKKER
  LET trksolo2&=39 ! ICON in Baum TRAKKER
  LET trkact2&=40 ! ICON in Baum TRAKKER
  LET trktxt2&=41 ! BOXTEXT in Baum TRAKKER
  LET panl2&=42 ! ICON in Baum TRAKKER
  LET pantxt2&=43 ! BOXTEXT in Baum TRAKKER
  LET trktxt1&=44 ! BOXTEXT in Baum TRAKKER
  LET panr1&=45 ! ICON in Baum TRAKKER
  LET panl1&=46 ! ICON in Baum TRAKKER
  LET pantxt1&=47 ! BOXTEXT in Baum TRAKKER
  LET panr2&=48 ! ICON in Baum TRAKKER
  LET panr3&=49 ! ICON in Baum TRAKKER
  LET panr4&=50 ! ICON in Baum TRAKKER
  LET trakexit&=51 ! BUTTON in Baum TRAKKER
  LET trakhelp&=52 ! BOXTEXT in Baum TRAKKER
  LET trakslid&=53 ! BOX in Baum TRAKKER
  LET trakxbut&=54 ! BUTTON in Baum TRAKKER
  LET trakbox4&=55 ! BOX in Baum TRAKKER
  LET traktime&=56 ! BOXTEXT in Baum TRAKKER
  LET trakname&=57 ! BOXTEXT in Baum TRAKKER
  LET trkerr&=58 ! BOXTEXT in Baum TRAKKER
  LET pause2&=60 ! ICON in Baum TRAKKER
  LET rewind2&=61 ! ICON in Baum TRAKKER
  LET stop2&=62 ! ICON in Baum TRAKKER
  LET recplay2&=63 ! ICON in Baum TRAKKER
  LET smpplay3&=64 ! ICON in Baum TRAKKER
  LET smprpla2&=65 ! ICON in Baum TRAKKER
  LET forward2&=66 ! ICON in Baum TRAKKER
  LET trakanf&=67 ! ICON in Baum TRAKKER
  LET trakfull&=68 ! ICON in Baum TRAKKER
  LET smpstrt4&=69 ! ICON in Baum TRAKKER
  LET smpauto4&=70 ! ICON in Baum TRAKKER
  LET trakbox3&=71 ! BOX in Baum TRAKKER
  LET hlpedit3&=72 ! ICON in Baum TRAKKER
  LET hrdmerg2&=73 ! ICON in Baum TRAKKER
  LET trakload&=74 ! ICON in Baum TRAKKER
  LET trakplay&=75 ! ICON in Baum TRAKKER
  LET trakdel&=76 ! ICON in Baum TRAKKER
  LET traksall&=77 ! ICON in Baum TRAKKER
  LET traklall&=78 ! ICON in Baum TRAKKER
  LET killtrak&=79 ! ICON in Baum TRAKKER
  LET trakclip&=80 ! ICON in Baum TRAKKER
  LET tblksel&=81 ! ICON in Baum TRAKKER
  LET tblkmove&=82 ! ICON in Baum TRAKKER
  LET tblkcopy&=83 ! ICON in Baum TRAKKER
  LET tblkdrag&=84 ! ICON in Baum TRAKKER
  LET tblkedit&=85 ! ICON in Baum TRAKKER
  LET tblksnap&=86 ! ICON in Baum TRAKKER
  LET tblkvol&=87 ! ICON in Baum TRAKKER
  LET tblkcut&=88 ! ICON in Baum TRAKKER
  LET trakinfo&=92 ! BOXTEXT in Baum TRAKKER
  LET trakstrt&=93 ! BOXTEXT in Baum TRAKKER
  LET trakend&=94 ! BOXTEXT in Baum TRAKKER
  LET traklen&=95 ! BOXTEXT in Baum TRAKKER
  LET trksmpte&=96 ! BOXTEXT in Baum TRAKKER
  LET trakxr&=98 ! ICON in Baum TRAKKER
  LET trakxl&=99 ! ICON in Baum TRAKKER
  LET strtl&=100 ! ICON in Baum TRAKKER
  LET strtr&=101 ! ICON in Baum TRAKKER
  LET lend&=102 ! ICON in Baum TRAKKER
  LET ltime&=103 ! ICON in Baum TRAKKER
  LET rend&=104 ! ICON in Baum TRAKKER
  LET rtime&=105 ! ICON in Baum TRAKKER
  LET trkblk&=106 ! ICON in Baum TRAKKER
  LET trkcopy&=107 ! ICON in Baum TRAKKER
  LET trkdel&=108 ! ICON in Baum TRAKKER
  LET tblkplay&=109 ! ICON in Baum TRAKKER
  LET timeline&=110 ! BOXTEXT in Baum TRAKKER
  LET trkslot&=111 ! BOXTEXT in Baum TRAKKER
  LET trk4&=116 ! ICON in Baum TRAKKER
  LET trk8&=117 ! ICON in Baum TRAKKER
  LET trk12&=118 ! ICON in Baum TRAKKER
  LET trk16&=119 ! ICON in Baum TRAKKER
  LET spurslid&=120 ! BOX in Baum TRAKKER
  LET spurybut&=121 ! BUTTON in Baum TRAKKER
  LET spuro&=122 ! ICON in Baum TRAKKER
  LET spuru&=123 ! ICON in Baum TRAKKER
  LET zoomxl&=124 ! ICON in Baum TRAKKER
  LET zoomxr&=125 ! ICON in Baum TRAKKER
  LET zoomslid&=126 ! BOX in Baum TRAKKER
  LET zoomxbut&=127 ! BUTTON in Baum TRAKKER
  LET trakdur&=128 ! BOXTEXT in Baum TRAKKER
  LET tnamcom&=133 ! ICON in Baum TRAKKER
  LET curve&=134 ! ICON in Baum TRAKKER
  LET trksolo&=135 ! ICON in Baum TRAKKER
  LET trkrvol&=137 ! BOX in Baum TRAKKER
  LET trkrmax&=138 ! BOX in Baum TRAKKER
  LET trklvol&=139 ! BOX in Baum TRAKKER
  LET trklmax&=140 ! BOX in Baum TRAKKER
  LET trkvbox&=141 ! BOXTEXT in Baum TRAKKER
  LET trkvol&=143 ! ICON in Baum TRAKKER
  LET tpstrt&=144 ! BOXTEXT in Baum TRAKKER
  LET tpend&=145 ! BOXTEXT in Baum TRAKKER
  LET tpsl&=147 ! ICON in Baum TRAKKER
  LET tpel&=148 ! ICON in Baum TRAKKER
  LET tpsr&=149 ! ICON in Baum TRAKKER
  LET tper&=150 ! ICON in Baum TRAKKER
  LET trkmon&=151 ! BOXTEXT in Baum TRAKKER
  '
  LET dropdown&=25 ! Menuebaum
  LET ddstar&=3 ! TITLE in Baum DROPDOWN
  LET dddat&=4 ! TITLE in Baum DROPDOWN
  LET ddwind&=5 ! TITLE in Baum DROPDOWN
  LET ddfunc&=6 ! TITLE in Baum DROPDOWN
  LET ddplugin&=7 ! TITLE in Baum DROPDOWN
  LET ddinfo&=10 ! STRING in Baum DROPDOWN
  LET ddload&=19 ! STRING in Baum DROPDOWN
  LET ddsave&=20 ! STRING in Baum DROPDOWN
  LET ddexit&=21 ! STRING in Baum DROPDOWN
  LET ddsmp16&=23 ! STRING in Baum DROPDOWN
  LET ddblock&=24 ! STRING in Baum DROPDOWN
  LET ddpeak&=25 ! STRING in Baum DROPDOWN
  LET ddarr&=26 ! STRING in Baum DROPDOWN
  LET ddtrakk&=27 ! STRING in Baum DROPDOWN
  LET ddloop&=28 ! STRING in Baum DROPDOWN
  LET dddsp&=29 ! STRING in Baum DROPDOWN
  LET ddworkm&=30 ! STRING in Baum DROPDOWN
  LET ddsetup&=32 ! STRING in Baum DROPDOWN
  LET ddfader&=33 ! STRING in Baum DROPDOWN
  LET ddmidi&=34 ! STRING in Baum DROPDOWN
  LET ddbank&=35 ! STRING in Baum DROPDOWN
  LET ddmon&=37 ! STRING in Baum DROPDOWN
  LET ddauto&=38 ! STRING in Baum DROPDOWN
  LET ddmanu&=39 ! STRING in Baum DROPDOWN
  LET ddplay&=40 ! STRING in Baum DROPDOWN
  LET ddhost&=42 ! STRING in Baum DROPDOWN
  LET ddmix&=43 ! STRING in Baum DROPDOWN
  LET ddplug1&=45 ! STRING in Baum DROPDOWN
  LET ddplug2&=46 ! STRING in Baum DROPDOWN
  LET ddplug3&=47 ! STRING in Baum DROPDOWN
  LET ddplug4&=48 ! STRING in Baum DROPDOWN
  LET ddplug5&=49 ! STRING in Baum DROPDOWN
  LET ddplug6&=50 ! STRING in Baum DROPDOWN
  LET ddplug7&=51 ! STRING in Baum DROPDOWN
  LET ddplug8&=52 ! STRING in Baum DROPDOWN
  LET ddplug9&=53 ! STRING in Baum DROPDOWN
  LET ddplug10&=54 ! STRING in Baum DROPDOWN
  '
  LET wmode&=26 ! Formular/Dialog
  LET wmbox1&=0 ! BOX in Baum WMODE
  LET wmhelp&=1 ! BOXTEXT in Baum WMODE
  LET wmexit&=2 ! BUTTON in Baum WMODE
  LET wmbox2&=4 ! BOX in Baum WMODE
  LET mixcpu&=5 ! BUTTON in Baum WMODE
  LET mixdma&=6 ! BUTTON in Baum WMODE
  LET mixdsp&=7 ! BUTTON in Baum WMODE
  LET wmbox4&=9 ! BOX in Baum WMODE
  LET mast16&=10 ! BUTTON in Baum WMODE
  LET mast24&=11 ! BUTTON in Baum WMODE
  LET wmbox3&=13 ! BOX in Baum WMODE
  LET recm2&=14 ! BUTTON in Baum WMODE
  LET recm4&=15 ! BUTTON in Baum WMODE
  LET recm8&=16 ! BUTTON in Baum WMODE
  LET wmbox5&=18 ! BOX in Baum WMODE
  LET ramlo&=19 ! BUTTON in Baum WMODE
  LET ramhi&=20 ! BUTTON in Baum WMODE
  LET syncsrte&=23 ! FTEXT in Baum WMODE
  LET wmodebx2&=24 ! BOX in Baum WMODE
  LET synchz&=25 ! FTEXT in Baum WMODE
  LET wmodebx3&=26 ! BOX in Baum WMODE
  LET smpteset&=27 ! FTEXT in Baum WMODE
  LET syncpcg&=28 ! BUTTON in Baum WMODE
  LET syncadat&=29 ! BUTTON in Baum WMODE
  LET syncmtc&=30 ! BUTTON in Baum WMODE
  LET syncxmit&=31 ! BUTTON in Baum WMODE
  LET syncalc&=32 ! BUTTON in Baum WMODE
  LET clkfalc&=33 ! BUTTON in Baum WMODE
  LET wmbox7&=34 ! BOX in Baum WMODE
  LET frame24&=35 ! BUTTON in Baum WMODE
  LET frame25&=36 ! BUTTON in Baum WMODE
  LET frame30&=37 ! BUTTON in Baum WMODE
  '
  LET fsel&=27 ! Formular/Dialog
  LET fselbox&=0 ! BOX in Baum FSEL
  LET fselbox2&=1 ! BOX in Baum FSEL
  LET fsbut1&=2 ! BOXTEXT in Baum FSEL
  LET fsbut2&=3 ! BOXTEXT in Baum FSEL
  LET fsbut3&=4 ! BOXTEXT in Baum FSEL
  LET fsbut4&=5 ! BOXTEXT in Baum FSEL
  LET fsbut5&=6 ! BOXTEXT in Baum FSEL
  LET fsbut6&=7 ! BOXTEXT in Baum FSEL
  LET fsbut7&=8 ! BOXTEXT in Baum FSEL
  LET fsbut8&=9 ! BOXTEXT in Baum FSEL
  LET fsbut9&=10 ! BOXTEXT in Baum FSEL
  LET fsbut10&=11 ! BOXTEXT in Baum FSEL
  LET fsbut11&=12 ! BOXTEXT in Baum FSEL
  LET fsbut12&=13 ! BOXTEXT in Baum FSEL
  LET fsbut13&=14 ! BOXTEXT in Baum FSEL
  LET fsbut14&=15 ! BOXTEXT in Baum FSEL
  LET fsbut15&=16 ! BOXTEXT in Baum FSEL
  LET fstxt1&=17 ! BOXTEXT in Baum FSEL
  LET fstxt2&=18 ! BOXTEXT in Baum FSEL
  LET fstxt3&=19 ! BOXTEXT in Baum FSEL
  LET fstxt4&=20 ! BOXTEXT in Baum FSEL
  LET fstxt5&=21 ! BOXTEXT in Baum FSEL
  LET fstxt6&=22 ! BOXTEXT in Baum FSEL
  LET fstxt7&=23 ! BOXTEXT in Baum FSEL
  LET fstxt8&=24 ! BOXTEXT in Baum FSEL
  LET fstxt9&=25 ! BOXTEXT in Baum FSEL
  LET fstxt10&=26 ! BOXTEXT in Baum FSEL
  LET fstxt11&=27 ! BOXTEXT in Baum FSEL
  LET fstxt12&=28 ! BOXTEXT in Baum FSEL
  LET fstxt13&=29 ! BOXTEXT in Baum FSEL
  LET fstxt14&=30 ! BOXTEXT in Baum FSEL
  LET fstxt15&=31 ! BOXTEXT in Baum FSEL
  LET fsslide&=32 ! BOX in Baum FSEL
  LET fssldbut&=33 ! BUTTON in Baum FSEL
  LET fsok&=34 ! BUTTON in Baum FSEL
  LET fshelp&=35 ! BOXTEXT in Baum FSEL
  LET fsplay&=36 ! ICON in Baum FSEL
  LET fsexit&=37 ! BUTTON in Baum FSEL
  LET fsordner&=39 ! BUTTON in Baum FSEL
  LET fsotxt&=40 ! BOXTEXT in Baum FSEL
  LET fsmatic&=41 ! ICON in Baum FSEL
  LET fsins&=42 ! ICON in Baum FSEL
  LET fsdel&=43 ! ICON in Baum FSEL
  LET fsadd&=44 ! BUTTON in Baum FSEL
  LET fsnew&=45 ! BUTTON in Baum FSEL
  LET fsload&=46 ! ICON in Baum FSEL
  LET fssave&=47 ! ICON in Baum FSEL
  LET fsclf&=48 ! ICON in Baum FSEL
  LET fssldup&=49 ! ICON in Baum FSEL
  LET fsslddwn&=50 ! ICON in Baum FSEL
  LET fsstop&=51 ! ICON in Baum FSEL
  LET fswait&=52 ! ICON in Baum FSEL
  LET fsend&=53 ! ICON in Baum FSEL
  LET fstime&=54 ! BOXTEXT in Baum FSEL
  LET fslplay&=55 ! ICON in Baum FSEL
  LET tfsabc&=56 ! USERDEF in Baum FSEL
  LET tfsearch&=57 ! BUTTON in Baum FSEL
  '
  LET meldung&=28 ! Formular/Dialog
  LET meldbox&=0 ! BOX in Baum MELDUNG
  LET meldtxt&=1 ! BOXTEXT in Baum MELDUNG
  '
  LET trknamin&=29 ! Formular/Dialog
  LET trktxbox&=0 ! BOX in Baum TRKNAMIN
  LET trktxbo2&=1 ! BOX in Baum TRKNAMIN
  LET trktxtin&=2 ! FTEXT in Baum TRKNAMIN
  LET trktxex&=4 ! BUTTON in Baum TRKNAMIN
  LET trktxhlp&=5 ! BOXTEXT in Baum TRKNAMIN
  LET trktxok&=6 ! BUTTON in Baum TRKNAMIN
  '
  LET trkcomin&=30 ! Formular/Dialog
  LET trkcbox&=0 ! BOX in Baum TRKCOMIN
  LET trkcbox2&=1 ! BOX in Baum TRKCOMIN
  LET trkctxin&=2 ! FTEXT in Baum TRKCOMIN
  LET trkcexit&=4 ! BUTTON in Baum TRKCOMIN
  LET trkchlp&=5 ! BOXTEXT in Baum TRKCOMIN
  LET trkcok&=6 ! BUTTON in Baum TRKCOMIN
  '
  LET mrktxtin&=31 ! Formular/Dialog
  LET mtexbox&=0 ! BOX in Baum MRKTXTIN
  LET mtexbox2&=1 ! BOX in Baum MRKTXTIN
  LET mtex&=2 ! FTEXT in Baum MRKTXTIN
  LET mtexex&=4 ! BUTTON in Baum MRKTXTIN
  LET mtexhelp&=5 ! BOXTEXT in Baum MRKTXTIN
  LET mtexok&=6 ! BUTTON in Baum MRKTXTIN
  '
  LET mrkfind&=32 ! Formular/Dialog
  LET mrkfbox&=0 ! BOX in Baum MRKFIND
  LET mrkfex&=2 ! BUTTON in Baum MRKFIND
  LET mrkfhelp&=3 ! BOXTEXT in Baum MRKFIND
  LET mrkfok&=4 ! BUTTON in Baum MRKFIND
  LET mrkfbox2&=6 ! BOX in Baum MRKFIND
  LET mrkftims&=7 ! BOXTEXT in Baum MRKFIND
  LET mrkftime&=8 ! BOXTEXT in Baum MRKFIND
  LET mrkfbuts&=9 ! ICON in Baum MRKFIND
  LET mrkfbute&=10 ! ICON in Baum MRKFIND
  LET mrkfdown&=11 ! ICON in Baum MRKFIND
  LET mrkfslid&=12 ! BOX in Baum MRKFIND
  LET mrkfbut&=13 ! BUTTON in Baum MRKFIND
  LET mrkfup&=14 ! ICON in Baum MRKFIND
  LET mrkfnr&=15 ! BOXTEXT in Baum MRKFIND
  LET mrkfbuti&=16 ! ICON in Baum MRKFIND
  LET mrkfbutr&=17 ! ICON in Baum MRKFIND
  LET mrkftimi&=18 ! BOXTEXT in Baum MRKFIND
  LET mrkftimr&=19 ! BOXTEXT in Baum MRKFIND
  LET mrkftxt&=20 ! BOXTEXT in Baum MRKFIND
  '
  LET disked&=33 ! Formular/Dialog
  LET dskedbox&=0 ! BOX in Baum DISKED
  LET dskedex&=1 ! BUTTON in Baum DISKED
  LET dskedhlp&=2 ! BOXTEXT in Baum DISKED
  LET dskedbx4&=4 ! BOX in Baum DISKED
  LET dskedbx2&=5 ! BOX in Baum DISKED
  LET dskedit&=6 ! FTEXT in Baum DISKED
  LET dskren&=8 ! ICON in Baum DISKED
  LET dskopie&=9 ! ICON in Baum DISKED
  LET dskedbx3&=10 ! BOX in Baum DISKED
  LET dskedtxt&=11 ! BOXTEXT in Baum DISKED
  LET dskill&=13 ! ICON in Baum DISKED
  '
  LET clocks&=34 ! Formular/Dialog
  LET clkbox&=0 ! BOX in Baum CLOCKS
  LET clockex&=2 ! BUTTON in Baum CLOCKS
  LET clockhlp&=3 ! BOXTEXT in Baum CLOCKS
  LET clockok&=4 ! BUTTON in Baum CLOCKS
  LET clkbox2&=6 ! BOX in Baum CLOCKS
  LET clock1&=7 ! BOXTEXT in Baum CLOCKS
  LET clock2&=8 ! BOXTEXT in Baum CLOCKS
  LET clkdown&=9 ! ICON in Baum CLOCKS
  LET clkslid&=10 ! BOX in Baum CLOCKS
  LET clkbut&=11 ! BUTTON in Baum CLOCKS
  LET clkup&=12 ! ICON in Baum CLOCKS
  LET clock3&=13 ! BOXTEXT in Baum CLOCKS
  LET clock4&=14 ! BOXTEXT in Baum CLOCKS
  LET clock5&=15 ! BOXTEXT in Baum CLOCKS
  LET clockm&=16 ! BOXTEXT in Baum CLOCKS
  '
  LET marknumb&=35 ! Formular/Dialog
  LET mnumbox&=0 ! BOX in Baum MARKNUMB
  LET mnumbox2&=1 ! BOX in Baum MARKNUMB
  LET mnumtxt&=2 ! FTEXT in Baum MARKNUMB
  LET mnumexit&=4 ! BUTTON in Baum MARKNUMB
  LET mnumhelp&=5 ! BOXTEXT in Baum MARKNUMB
  LET mnumok&=6 ! BUTTON in Baum MARKNUMB
  '
  LET alertbox&=36 ! Formular/Dialog
  LET alertcol&=0 ! BOX in Baum ALERTBOX
ELSE
  IF bigfoot=FALSE THEN
    REM Resource Datei Indizes fÅr STARLOW
    '
    LET smp16&=0 ! Formular/Dialog
    LET mainbox&=0 ! BOX in Baum SMP16
    LET exit&=1 ! BUTTON in Baum SMP16
    LET mainbox2&=2 ! BOX in Baum SMP16
    LET emph&=4 ! BUTTON in Baum SMP16
    LET audio&=5 ! BUTTON in Baum SMP16
    LET use&=6 ! BUTTON in Baum SMP16
    LET smp32&=8 ! BUTTON in Baum SMP16
    LET smp44&=9 ! BUTTON in Baum SMP16
    LET smp48&=10 ! BUTTON in Baum SMP16
    LET noval&=12 ! BUTTON in Baum SMP16
    LET confid&=13 ! BUTTON in Baum SMP16
    LET parity&=14 ! BUTTON in Baum SMP16
    LET biphase&=15 ! BUTTON in Baum SMP16
    LET nolock&=16 ! BUTTON in Baum SMP16
    LET prot&=18 ! BUTTON in Baum SMP16
    LET mainbox5&=19 ! BOX in Baum SMP16
    LET ydsp&=20 ! STRING in Baum SMP16
    LET dsp&=21 ! BOXTEXT in Baum SMP16
    LET dspcirc&=22 ! BOXCHAR in Baum SMP16
    LET mainbox6&=23 ! BOX in Baum SMP16
    LET input&=25 ! BOXTEXT in Baum SMP16
    LET incirc&=26 ! BOXCHAR in Baum SMP16
    LET rate2&=28 ! BOXTEXT in Baum SMP16
    LET ratecir2&=29 ! BOXCHAR in Baum SMP16
    LET helporig&=30 ! BOXTEXT in Baum SMP16
    LET mainbox4&=31 ! BOX in Baum SMP16
    LET source&=33 ! BOXTEXT in Baum SMP16
    LET srccirc&=34 ! BOXCHAR in Baum SMP16
    LET protect&=36 ! BOXTEXT in Baum SMP16
    LET protcirc&=37 ! BOXCHAR in Baum SMP16
    LET mode&=39 ! BOXTEXT in Baum SMP16
    LET modecirc&=40 ! BOXCHAR in Baum SMP16
    LET emphasis&=42 ! BOXTEXT in Baum SMP16
    LET emphcirc&=43 ! BOXCHAR in Baum SMP16
    LET bridge&=44 ! BUTTON in Baum SMP16
    '
    LET smpedit&=1 ! Formular/Dialog
    LET editbox7&=0 ! BOX in Baum SMPEDIT
    LET editbox&=2 ! BOX in Baum SMPEDIT
    LET smplen&=3 ! BOXTEXT in Baum SMPEDIT
    LET smpsec&=4 ! BOXTEXT in Baum SMPEDIT
    LET smpexit&=7 ! BUTTON in Baum SMPEDIT
    LET rate&=9 ! BOXTEXT in Baum SMPEDIT
    LET ratecirc&=10 ! BOXCHAR in Baum SMPEDIT
    LET editbox6&=11 ! BOX in Baum SMPEDIT
    LET smppmark&=12 ! USERDEF in Baum SMPEDIT
    LET midi&=13 ! USERDEF in Baum SMPEDIT
    LET mintext&=14 ! BOXTEXT in Baum SMPEDIT
    LET smploop&=16 ! USERDEF in Baum SMPEDIT
    LET smpcblk&=17 ! USERDEF in Baum SMPEDIT
    LET smpfile&=18 ! BOXTEXT in Baum SMPEDIT
    LET smprate&=19 ! BOXTEXT in Baum SMPEDIT
    LET editbox5&=20 ! BOX in Baum SMPEDIT
    LET mover&=21 ! BOXTEXT in Baum SMPEDIT
    LET movecirc&=22 ! BOXCHAR in Baum SMPEDIT
    LET trash&=23 ! USERDEF in Baum SMPEDIT
    LET editbox3&=24 ! BOX in Baum SMPEDIT
    LET edmtims&=25 ! BOXTEXT in Baum SMPEDIT
    LET edmtime&=26 ! BOXTEXT in Baum SMPEDIT
    LET edmdown&=27 ! USERDEF in Baum SMPEDIT
    LET edmslide&=28 ! BOX in Baum SMPEDIT
    LET edmbut&=29 ! BUTTON in Baum SMPEDIT
    LET edmup&=30 ! USERDEF in Baum SMPEDIT
    LET edmnr&=31 ! BOXTEXT in Baum SMPEDIT
    LET edmtimi&=32 ! BOXTEXT in Baum SMPEDIT
    LET edmtimr&=33 ! BOXTEXT in Baum SMPEDIT
    LET edmtxt&=34 ! BOXTEXT in Baum SMPEDIT
    LET edmbox&=35 ! BOX in Baum SMPEDIT
    LET edmbuts&=36 ! USERDEF in Baum SMPEDIT
    LET edmbute&=37 ! USERDEF in Baum SMPEDIT
    LET edmbuti&=38 ! USERDEF in Baum SMPEDIT
    LET edmbutr&=39 ! USERDEF in Baum SMPEDIT
    LET smpedhlp&=41 ! BOXTEXT in Baum SMPEDIT
    LET zomslide&=42 ! BOX in Baum SMPEDIT
    LET zoombutt&=43 ! BUTTON in Baum SMPEDIT
    LET cstxt&=46 ! BOXTEXT in Baum SMPEDIT
    LET cetxt&=47 ! BOXTEXT in Baum SMPEDIT
    LET pixzoom&=49 ! USERDEF in Baum SMPEDIT
    LET showxy&=50 ! BOXTEXT in Baum SMPEDIT
    LET pntprsmp&=51 ! BOXTEXT in Baum SMPEDIT
    LET freemem&=52 ! BOXTEXT in Baum SMPEDIT
    LET clock&=53 ! BOXTEXT in Baum SMPEDIT
    LET smpname&=54 ! BOXTEXT in Baum SMPEDIT
    LET smpundo&=55 ! BOXTEXT in Baum SMPEDIT
    LET flyer&=57 ! USERDEF in Baum SMPEDIT
    LET smpr1&=58 ! USERDEF in Baum SMPEDIT
    LET smpl1&=59 ! USERDEF in Baum SMPEDIT
    LET smpl2&=60 ! USERDEF in Baum SMPEDIT
    LET smpr2&=61 ! USERDEF in Baum SMPEDIT
    LET smpl3&=62 ! USERDEF in Baum SMPEDIT
    LET smpanf&=63 ! USERDEF in Baum SMPEDIT
    LET smpend&=64 ! USERDEF in Baum SMPEDIT
    LET smpmid&=65 ! USERDEF in Baum SMPEDIT
    LET smpr3&=66 ! USERDEF in Baum SMPEDIT
    LET zooml&=67 ! USERDEF in Baum SMPEDIT
    LET zoomr&=68 ! USERDEF in Baum SMPEDIT
    LET smpstrt2&=69 ! USERDEF in Baum SMPEDIT
    LET smpauto2&=70 ! USERDEF in Baum SMPEDIT
    LET recplay3&=71 ! USERDEF in Baum SMPEDIT
    LET smpplay&=72 ! USERDEF in Baum SMPEDIT
    LET smpstop&=73 ! USERDEF in Baum SMPEDIT
    LET smpwait&=74 ! USERDEF in Baum SMPEDIT
    LET hard&=75 ! USERDEF in Baum SMPEDIT
    LET resolu&=78 ! BOXTEXT in Baum SMPEDIT
    LET editbox2&=79 ! BOX in Baum SMPEDIT
    LET setuper&=80 ! USERDEF in Baum SMPEDIT
    LET edfade&=81 ! USERDEF in Baum SMPEDIT
    LET peaksw2&=82 ! USERDEF in Baum SMPEDIT
    LET disk&=83 ! USERDEF in Baum SMPEDIT
    LET loopart&=84 ! USERDEF in Baum SMPEDIT
    LET blocfunc&=85 ! USERDEF in Baum SMPEDIT
    LET arrange&=86 ! USERDEF in Baum SMPEDIT
    LET smpload&=87 ! USERDEF in Baum SMPEDIT
    LET smpsave&=88 ! USERDEF in Baum SMPEDIT
    LET infoicon&=89 ! USERDEF in Baum SMPEDIT
    LET edmidi&=90 ! USERDEF in Baum SMPEDIT
    LET trak&=91 ! USERDEF in Baum SMPEDIT
    LET edsmp16&=92 ! USERDEF in Baum SMPEDIT
    LET swdsp&=93 ! USERDEF in Baum SMPEDIT
    LET smpdbank&=94 ! USERDEF in Baum SMPEDIT
    LET swmark&=95 ! USERDEF in Baum SMPEDIT
    LET wmodes&=96 ! USERDEF in Baum SMPEDIT
    LET swyzoom&=97 ! USERDEF in Baum SMPEDIT
    LET swclick&=98 ! USERDEF in Baum SMPEDIT
    LET swdraw&=99 ! USERDEF in Baum SMPEDIT
    LET swblk&=100 ! USERDEF in Baum SMPEDIT
    LET scrubs&=101 ! USERDEF in Baum SMPEDIT
    LET swsearch&=102 ! USERDEF in Baum SMPEDIT
    LET curvbox&=103 ! BOX in Baum SMPEDIT
    LET editbox4&=104 ! BOX in Baum SMPEDIT
    LET editbox8&=105 ! BOX in Baum SMPEDIT
    LET smptxr&=106 ! TEXT in Baum SMPEDIT
    LET smptxl&=107 ! TEXT in Baum SMPEDIT
    LET rm80&=108 ! BOXTEXT in Baum SMPEDIT
    LET rp0&=109 ! BOXTEXT in Baum SMPEDIT
    LET rp80&=110 ! BOXTEXT in Baum SMPEDIT
    LET rp60&=111 ! BOXTEXT in Baum SMPEDIT
    LET rp40&=112 ! BOXTEXT in Baum SMPEDIT
    LET rm60&=113 ! BOXTEXT in Baum SMPEDIT
    LET rm40&=114 ! BOXTEXT in Baum SMPEDIT
    LET lp80&=115 ! BOXTEXT in Baum SMPEDIT
    LET lm80&=116 ! BOXTEXT in Baum SMPEDIT
    LET lp40&=117 ! BOXTEXT in Baum SMPEDIT
    LET lp60&=118 ! BOXTEXT in Baum SMPEDIT
    LET lm60&=119 ! BOXTEXT in Baum SMPEDIT
    LET lm40&=120 ! BOXTEXT in Baum SMPEDIT
    LET lm20&=121 ! BOXTEXT in Baum SMPEDIT
    LET lp0&=122 ! BOXTEXT in Baum SMPEDIT
    LET rp20&=123 ! BOXTEXT in Baum SMPEDIT
    LET rm20&=124 ! BOXTEXT in Baum SMPEDIT
    LET lp20&=125 ! BOXTEXT in Baum SMPEDIT
    LET scrlslde&=126 ! BOX in Baum SMPEDIT
    LET scrolbut&=127 ! BUTTON in Baum SMPEDIT
    LET lscroll&=128 ! USERDEF in Baum SMPEDIT
    LET rscroll&=129 ! USERDEF in Baum SMPEDIT
    '
    LET dspedit&=2 ! Formular/Dialog
    LET dspbox&=0 ! BOX in Baum DSPEDIT
    LET dspecho&=3 ! BUTTON in Baum DSPEDIT
    LET dsphall&=4 ! BUTTON in Baum DSPEDIT
    LET dsplow&=5 ! BUTTON in Baum DSPEDIT
    LET dsphigh&=6 ! BUTTON in Baum DSPEDIT
    LET dspband&=7 ! BUTTON in Baum DSPEDIT
    LET dspflang&=8 ! BUTTON in Baum DSPEDIT
    LET dspchor&=9 ! BUTTON in Baum DSPEDIT
    LET dspeq&=10 ! BUTTON in Baum DSPEDIT
    LET dsppink&=11 ! BUTTON in Baum DSPEDIT
    LET dsppass&=12 ! BUTTON in Baum DSPEDIT
    LET dspload&=13 ! BUTTON in Baum DSPEDIT
    LET dspsave&=14 ! BUTTON in Baum DSPEDIT
    LET helpdsp&=15 ! BOXTEXT in Baum DSPEDIT
    LET dspexit&=16 ! BUTTON in Baum DSPEDIT
    '
    LET peak&=3 ! Formular/Dialog
    LET peakbox&=0 ! BOX in Baum PEAK
    LET plmax&=4 ! BUTTON in Baum PEAK
    LET prmax&=5 ! BUTTON in Baum PEAK
    LET peakbox2&=6 ! BOX in Baum PEAK
    LET volbox&=17 ! BOX in Baum PEAK
    LET volume&=19 ! USERDEF in Baum PEAK
    LET smpautop&=21 ! USERDEF in Baum PEAK
    LET smpstrtp&=22 ! USERDEF in Baum PEAK
    LET playpeak&=23 ! USERDEF in Baum PEAK
    LET peakexit&=24 ! BUTTON in Baum PEAK
    LET peakpos&=25 ! BOXTEXT in Baum PEAK
    LET peakmax&=26 ! BOXTEXT in Baum PEAK
    LET recerror&=29 ! BOXTEXT in Baum PEAK
    LET peakhelp&=31 ! BOXTEXT in Baum PEAK
    LET balbox&=32 ! BOXTEXT in Baum PEAK
    LET balance&=34 ! USERDEF in Baum PEAK
    LET peakl&=36 ! USERDEF in Baum PEAK
    LET peakr&=37 ! USERDEF in Baum PEAK
    LET recpeaks&=38 ! BOXTEXT in Baum PEAK
    LET peakdb&=41 ! BOXTEXT in Baum PEAK
    LET peakmute&=42 ! USERDEF in Baum PEAK
    LET balzero&=43 ! USERDEF in Baum PEAK
    LET peakbal&=44 ! BOXTEXT in Baum PEAK
    LET hardpeak&=64 ! USERDEF in Baum PEAK
    LET playstop&=65 ! USERDEF in Baum PEAK
    LET peakwait&=66 ! USERDEF in Baum PEAK
    LET volinout&=69 ! USERDEF in Baum PEAK
    LET peakch1&=70 ! BOXTEXT in Baum PEAK
    LET peakch4&=71 ! BOXTEXT in Baum PEAK
    LET peakch2&=72 ! BOXTEXT in Baum PEAK
    LET peakch3&=73 ! BOXTEXT in Baum PEAK
    LET peakname&=74 ! BOXTEXT in Baum PEAK
    '
    LET loop&=4 ! Formular/Dialog
    LET loopbox&=0 ! BOX in Baum LOOP
    LET loopexit&=1 ! BUTTON in Baum LOOP
    LET loopbox2&=2 ! BOX in Baum LOOP
    LET forw&=3 ! BUTTON in Baum LOOP
    LET cross&=4 ! BUTTON in Baum LOOP
    LET backw&=5 ! BUTTON in Baum LOOP
    LET helploop&=7 ! BOXTEXT in Baum LOOP
    LET autoloop&=8 ! BUTTON in Baum LOOP
    '
    LET normaliz&=5 ! Formular/Dialog
    LET normbox&=0 ! BOX in Baum NORMALIZ
    LET normok&=2 ! BUTTON in Baum NORMALIZ
    LET normexit&=3 ! BUTTON in Baum NORMALIZ
    LET maxdb&=4 ! BOXTEXT in Baum NORMALIZ
    LET normbox2&=6 ! BOX in Baum NORMALIZ
    LET normauto&=7 ! BUTTON in Baum NORMALIZ
    LET normadj&=8 ! BUTTON in Baum NORMALIZ
    LET normbox3&=9 ! BOX in Baum NORMALIZ
    LET norml1&=10 ! USERDEF in Baum NORMALIZ
    LET norml2&=11 ! USERDEF in Baum NORMALIZ
    LET norml3&=12 ! USERDEF in Baum NORMALIZ
    LET normr1&=13 ! USERDEF in Baum NORMALIZ
    LET normr2&=14 ! USERDEF in Baum NORMALIZ
    LET normr3&=15 ! USERDEF in Baum NORMALIZ
    LET helpnorm&=16 ! BOXTEXT in Baum NORMALIZ
    LET normdb&=18 ! BOXTEXT in Baum NORMALIZ
    '
    LET resample&=6 ! Formular/Dialog
    LET resmpbox&=0 ! BOX in Baum RESAMPLE
    LET adjresmp&=1 ! BUTTON in Baum RESAMPLE
    LET helprsmp&=2 ! BOXTEXT in Baum RESAMPLE
    LET rsmptxt1&=3 ! TEXT in Baum RESAMPLE
    LET resmpbx2&=4 ! BOX in Baum RESAMPLE
    LET restxt&=5 ! FTEXT in Baum RESAMPLE
    LET resmpsec&=6 ! BOXTEXT in Baum RESAMPLE
    LET resmplen&=7 ! BOXTEXT in Baum RESAMPLE
    LET resmpfac&=8 ! BOXTEXT in Baum RESAMPLE
    LET rsmptxt2&=10 ! TEXT in Baum RESAMPLE
    LET resother&=11 ! BOXTEXT in Baum RESAMPLE
    LET resok&=12 ! BUTTON in Baum RESAMPLE
    LET resexit&=13 ! BUTTON in Baum RESAMPLE
    LET res32&=15 ! BUTTON in Baum RESAMPLE
    LET res44&=16 ! BUTTON in Baum RESAMPLE
    LET res48&=17 ! BUTTON in Baum RESAMPLE
    LET resr3&=18 ! USERDEF in Baum RESAMPLE
    LET resr2&=19 ! USERDEF in Baum RESAMPLE
    LET resr1&=20 ! USERDEF in Baum RESAMPLE
    LET resl1&=21 ! USERDEF in Baum RESAMPLE
    LET resl2&=22 ! USERDEF in Baum RESAMPLE
    LET resl3&=23 ! USERDEF in Baum RESAMPLE
    '
    LET midiedit&=7 ! Formular/Dialog
    LET midibox&=0 ! BOX in Baum MIDIEDIT
    LET notetxt&=1 ! BOXTEXT in Baum MIDIEDIT
    LET chtxt&=3 ! BOXTEXT in Baum MIDIEDIT
    LET midiok&=5 ! BUTTON in Baum MIDIEDIT
    LET helpmidi&=7 ! BOXTEXT in Baum MIDIEDIT
    LET midinup&=10 ! USERDEF in Baum MIDIEDIT
    LET midioup&=11 ! USERDEF in Baum MIDIEDIT
    LET midindwn&=12 ! USERDEF in Baum MIDIEDIT
    LET midiodwn&=13 ! USERDEF in Baum MIDIEDIT
    LET midicup&=14 ! USERDEF in Baum MIDIEDIT
    LET midicdwn&=15 ! USERDEF in Baum MIDIEDIT
    '
    LET editfade&=8 ! Formular/Dialog
    LET fadebox&=0 ! BOX in Baum EDITFADE
    LET fadexit&=2 ! BUTTON in Baum EDITFADE
    LET fadelin&=4 ! BUTTON in Baum EDITFADE
    LET edfadbox&=5 ! BOX in Baum EDITFADE
    LET infade&=6 ! BUTTON in Baum EDITFADE
    LET ausfade&=7 ! BUTTON in Baum EDITFADE
    LET helpfade&=8 ! BOXTEXT in Baum EDITFADE
    LET fadexp&=9 ! BUTTON in Baum EDITFADE
    LET fadesqrt&=10 ! BUTTON in Baum EDITFADE
    LET fadeundo&=11 ! BUTTON in Baum EDITFADE
    LET fadedel&=12 ! BUTTON in Baum EDITFADE
    LET fdsquare&=13 ! BUTTON in Baum EDITFADE
    LET fadelog&=14 ! BUTTON in Baum EDITFADE
    LET fadload&=15 ! BUTTON in Baum EDITFADE
    LET fadsave&=16 ! BUTTON in Baum EDITFADE
    '
    LET popups&=9 ! Formular/Dialog
    LET smppopup&=1 ! BOX in Baum POPUPS
    LET rate32&=2 ! STRING in Baum POPUPS
    LET rate44&=3 ! STRING in Baum POPUPS
    LET rate48&=4 ! STRING in Baum POPUPS
    LET rate88&=5 ! STRING in Baum POPUPS
    LET rate96&=6 ! STRING in Baum POPUPS
    LET rate8&=7 ! STRING in Baum POPUPS
    LET rate11&=8 ! STRING in Baum POPUPS
    LET rate12&=9 ! STRING in Baum POPUPS
    LET rate16&=10 ! STRING in Baum POPUPS
    LET rate17&=11 ! STRING in Baum POPUPS
    LET rate22&=12 ! STRING in Baum POPUPS
    LET rate24&=13 ! STRING in Baum POPUPS
    LET rate33&=14 ! STRING in Baum POPUPS
    LET ratexth2&=15 ! STRING in Baum POPUPS
    LET ratextl2&=16 ! STRING in Baum POPUPS
    LET ratexth1&=17 ! STRING in Baum POPUPS
    LET ratextl1&=18 ! STRING in Baum POPUPS
    LET ratediv&=19 ! STRING in Baum POPUPS
    LET dsppopup&=20 ! BOX in Baum POPUPS
    LET dspoff&=21 ! STRING in Baum POPUPS
    LET dspin&=22 ! STRING in Baum POPUPS
    LET dspout&=23 ! STRING in Baum POPUPS
    LET smppop2&=24 ! BOX in Baum POPUPS
    LET ad32&=25 ! STRING in Baum POPUPS
    LET ad44&=26 ! STRING in Baum POPUPS
    LET ad48&=27 ! STRING in Baum POPUPS
    LET ad88&=28 ! STRING in Baum POPUPS
    LET ad96&=29 ! STRING in Baum POPUPS
    LET ad8&=30 ! STRING in Baum POPUPS
    LET ad11&=31 ! STRING in Baum POPUPS
    LET ad12&=32 ! STRING in Baum POPUPS
    LET ad16&=33 ! STRING in Baum POPUPS
    LET ad17&=34 ! STRING in Baum POPUPS
    LET ad22&=35 ! STRING in Baum POPUPS
    LET ad24&=36 ! STRING in Baum POPUPS
    LET ad33&=37 ! STRING in Baum POPUPS
    LET adexth2&=38 ! STRING in Baum POPUPS
    LET adextl2&=39 ! STRING in Baum POPUPS
    LET adexth1&=40 ! STRING in Baum POPUPS
    LET adextl1&=41 ! STRING in Baum POPUPS
    LET addiv&=42 ! STRING in Baum POPUPS
    LET inpop&=43 ! BOX in Baum POPUPS
    LET analog&=44 ! STRING in Baum POPUPS
    LET digital&=45 ! STRING in Baum POPUPS
    LET srcpop&=46 ! BOX in Baum POPUPS
    LET opto&=47 ! STRING in Baum POPUPS
    LET coax&=48 ! STRING in Baum POPUPS
    LET aesebu&=49 ! STRING in Baum POPUPS
    LET popmark&=50 ! BOX in Baum POPUPS
    LET smpmark&=51 ! STRING in Baum POPUPS
    LET smpzoom&=52 ! STRING in Baum POPUPS
    LET smpscrol&=53 ! STRING in Baum POPUPS
    LET kopy&=54 ! STRING in Baum POPUPS
    LET move&=55 ! STRING in Baum POPUPS
    LET insert&=56 ! STRING in Baum POPUPS
    LET merge&=57 ! STRING in Baum POPUPS
    LET fade&=58 ! STRING in Baum POPUPS
    LET popmake&=59 ! BOX in Baum POPUPS
    LET make32&=60 ! STRING in Baum POPUPS
    LET make44&=61 ! STRING in Baum POPUPS
    LET make48&=62 ! STRING in Baum POPUPS
    LET make88&=63 ! STRING in Baum POPUPS
    LET make96&=64 ! STRING in Baum POPUPS
    LET popform&=65 ! BOX in Baum POPUPS
    LET sets16&=66 ! STRING in Baum POPUPS
    LET setwav&=67 ! STRING in Baum POPUPS
    LET setavr&=68 ! STRING in Baum POPUPS
    LET setaif&=69 ! STRING in Baum POPUPS
    LET setsnd&=70 ! STRING in Baum POPUPS
    LET setsd&=71 ! STRING in Baum POPUPS
    LET setau&=72 ! STRING in Baum POPUPS
    LET setsmp&=73 ! STRING in Baum POPUPS
    LET setall&=74 ! STRING in Baum POPUPS
    LET popscms&=75 ! BOX in Baum POPUPS
    LET scmsno&=76 ! STRING in Baum POPUPS
    LET scmsone&=77 ! STRING in Baum POPUPS
    LET scmsfree&=78 ! STRING in Baum POPUPS
    LET modepop&=79 ! BOX in Baum POPUPS
    LET consumer&=80 ! STRING in Baum POPUPS
    LET profess&=81 ! STRING in Baum POPUPS
    LET emphpop&=82 ! BOX in Baum POPUPS
    LET emphoff&=83 ! STRING in Baum POPUPS
    LET emphon&=84 ! STRING in Baum POPUPS
    '
    LET record&=10 ! Formular/Dialog
    LET recbox&=0 ! BOX in Baum RECORD
    LET recfree&=1 ! BOXTEXT in Baum RECORD
    LET recok&=2 ! BUTTON in Baum RECORD
    LET recexit&=3 ! BUTTON in Baum RECORD
    LET timemeld&=4 ! TEXT in Baum RECORD
    LET rechelp&=5 ! BOXTEXT in Baum RECORD
    LET timetxt&=9 ! FTEXT in Baum RECORD
    LET tinpul1&=12 ! USERDEF in Baum RECORD
    LET tinpul2&=14 ! USERDEF in Baum RECORD
    LET tinpul3&=15 ! USERDEF in Baum RECORD
    LET tinpul4&=16 ! USERDEF in Baum RECORD
    LET tinpuh1&=17 ! USERDEF in Baum RECORD
    LET tinpuh2&=18 ! USERDEF in Baum RECORD
    LET tinpuh3&=19 ! USERDEF in Baum RECORD
    LET tinpuh4&=20 ! USERDEF in Baum RECORD
    LET tinpdh1&=21 ! USERDEF in Baum RECORD
    LET tinpdh2&=22 ! USERDEF in Baum RECORD
    LET tinpdh3&=23 ! USERDEF in Baum RECORD
    LET tinpdh4&=24 ! USERDEF in Baum RECORD
    LET tinpdl1&=25 ! USERDEF in Baum RECORD
    LET tinpdl2&=26 ! USERDEF in Baum RECORD
    LET tinpdl3&=27 ! USERDEF in Baum RECORD
    LET tinpdl4&=28 ! USERDEF in Baum RECORD
    '
    LET blkfunc&=11 ! Formular/Dialog
    LET blkbox&=0 ! BOX in Baum BLKFUNC
    LET cutin&=1 ! USERDEF in Baum BLKFUNC
    LET cutout&=2 ! USERDEF in Baum BLKFUNC
    LET blkexit&=3 ! BUTTON in Baum BLKFUNC
    LET blkhelp&=5 ! BOXTEXT in Baum BLKFUNC
    LET cutdel&=6 ! USERDEF in Baum BLKFUNC
    LET norm&=10 ! USERDEF in Baum BLKFUNC
    LET resmp&=11 ! USERDEF in Baum BLKFUNC
    LET mono&=12 ! USERDEF in Baum BLKFUNC
    LET conmix&=13 ! USERDEF in Baum BLKFUNC
    LET conins&=14 ! USERDEF in Baum BLKFUNC
    LET conspace&=15 ! USERDEF in Baum BLKFUNC
    LET negate&=23 ! USERDEF in Baum BLKFUNC
    LET lrchange&=25 ! USERDEF in Baum BLKFUNC
    '
    LET savebloc&=12 ! Formular/Dialog
    LET savebox&=0 ! BOX in Baum SAVEBLOC
    LET savall&=1 ! USERDEF in Baum SAVEBLOC
    LET savblock&=2 ! USERDEF in Baum SAVEBLOC
    LET savexit&=3 ! BUTTON in Baum SAVEBLOC
    LET savetxt&=4 ! TEXT in Baum SAVEBLOC
    LET savehelp&=5 ! BOXTEXT in Baum SAVEBLOC
    '
    LET arranger&=13 ! Formular/Dialog
    LET arrbox&=0 ! BOX in Baum ARRANGER
    LET arrbox2&=1 ! BOX in Baum ARRANGER
    LET hlpedit2&=2 ! USERDEF in Baum ARRANGER
    LET arrload&=3 ! USERDEF in Baum ARRANGER
    LET arrsave&=4 ! USERDEF in Baum ARRANGER
    LET arrmidi&=5 ! USERDEF in Baum ARRANGER
    LET arrins&=6 ! USERDEF in Baum ARRANGER
    LET arrdel&=7 ! USERDEF in Baum ARRANGER
    LET smpauto3&=9 ! USERDEF in Baum ARRANGER
    LET smpstrt3&=10 ! USERDEF in Baum ARRANGER
    LET pause&=11 ! USERDEF in Baum ARRANGER
    LET rewind&=12 ! USERDEF in Baum ARRANGER
    LET recplay&=13 ! USERDEF in Baum ARRANGER
    LET smpplay2&=14 ! USERDEF in Baum ARRANGER
    LET smprplay&=15 ! USERDEF in Baum ARRANGER
    LET forward&=16 ! USERDEF in Baum ARRANGER
    LET arrstrt&=17 ! USERDEF in Baum ARRANGER
    LET arrend&=18 ! USERDEF in Baum ARRANGER
    LET stop&=19 ! USERDEF in Baum ARRANGER
    LET arrbox4&=20 ! BOX in Baum ARRANGER
    LET playlen&=21 ! BOXTEXT in Baum ARRANGER
    LET arreal&=22 ! USERDEF in Baum ARRANGER
    LET arrblk&=23 ! USERDEF in Baum ARRANGER
    LET arrbox3&=24 ! BOX in Baum ARRANGER
    LET arrbox5&=25 ! BOX in Baum ARRANGER
    LET hardfs1&=26 ! BUTTON in Baum ARRANGER
    LET spur1&=27 ! BOXTEXT in Baum ARRANGER
    LET arrbox6&=28 ! BOX in Baum ARRANGER
    LET hardfs2&=29 ! BUTTON in Baum ARRANGER
    LET spur2&=30 ! BOXTEXT in Baum ARRANGER
    LET arrbox7&=31 ! BOX in Baum ARRANGER
    LET hardfs3&=32 ! BUTTON in Baum ARRANGER
    LET spur3&=33 ! BOXTEXT in Baum ARRANGER
    LET arrbox8&=34 ! BOX in Baum ARRANGER
    LET hardfs4&=35 ! BUTTON in Baum ARRANGER
    LET spur4&=36 ! BOXTEXT in Baum ARRANGER
    LET hardst2&=38 ! BOXTEXT in Baum ARRANGER
    LET hardst3&=40 ! BOXTEXT in Baum ARRANGER
    LET hardst4&=42 ! BOXTEXT in Baum ARRANGER
    LET harde2&=44 ! BOXTEXT in Baum ARRANGER
    LET harde3&=46 ! BOXTEXT in Baum ARRANGER
    LET harde4&=48 ! BOXTEXT in Baum ARRANGER
    LET harde1&=50 ! BOXTEXT in Baum ARRANGER
    LET hardlen1&=52 ! BOXTEXT in Baum ARRANGER
    LET hardlen2&=54 ! BOXTEXT in Baum ARRANGER
    LET hardlen3&=56 ! BOXTEXT in Baum ARRANGER
    LET hardlen4&=58 ! BOXTEXT in Baum ARRANGER
    LET arrnr1&=61 ! BOXTEXT in Baum ARRANGER
    LET arrnr2&=63 ! BOXTEXT in Baum ARRANGER
    LET arrnr3&=65 ! BOXTEXT in Baum ARRANGER
    LET arrm1&=66 ! USERDEF in Baum ARRANGER
    LET arrm2&=67 ! USERDEF in Baum ARRANGER
    LET arrm3&=68 ! USERDEF in Baum ARRANGER
    LET arrm4&=69 ! USERDEF in Baum ARRANGER
    LET hardst1&=71 ! BOXTEXT in Baum ARRANGER
    LET arrnote2&=73 ! BOXTEXT in Baum ARRANGER
    LET arrnote3&=75 ! BOXTEXT in Baum ARRANGER
    LET arrnote4&=77 ! BOXTEXT in Baum ARRANGER
    LET arrnr4&=81 ! BOXTEXT in Baum ARRANGER
    LET arrmem1&=83 ! BOXTEXT in Baum ARRANGER
    LET arrmem2&=85 ! BOXTEXT in Baum ARRANGER
    LET arrmem3&=87 ! BOXTEXT in Baum ARRANGER
    LET arrmem4&=89 ! BOXTEXT in Baum ARRANGER
    LET arrnote1&=91 ! BOXTEXT in Baum ARRANGER
    LET arrch1&=93 ! BOXTEXT in Baum ARRANGER
    LET arrch2&=95 ! BOXTEXT in Baum ARRANGER
    LET arrch3&=97 ! BOXTEXT in Baum ARRANGER
    LET arrch4&=99 ! BOXTEXT in Baum ARRANGER
    LET arrtri1&=101 ! BUTTON in Baum ARRANGER
    LET arrtri2&=102 ! BUTTON in Baum ARRANGER
    LET arrtri3&=103 ! BUTTON in Baum ARRANGER
    LET arrtri4&=104 ! BUTTON in Baum ARRANGER
    LET arrloop1&=107 ! USERDEF in Baum ARRANGER
    LET arrloop2&=108 ! USERDEF in Baum ARRANGER
    LET arrloop3&=109 ! USERDEF in Baum ARRANGER
    LET arrloop4&=110 ! USERDEF in Baum ARRANGER
    LET arrsmpr1&=114 ! BOXTEXT in Baum ARRANGER
    LET arrsmpr2&=116 ! BOXTEXT in Baum ARRANGER
    LET arrsmpr3&=118 ! BOXTEXT in Baum ARRANGER
    LET arrsmpr4&=120 ! BOXTEXT in Baum ARRANGER
    LET arrdel1&=125 ! USERDEF in Baum ARRANGER
    LET arrdel2&=126 ! USERDEF in Baum ARRANGER
    LET arrdel3&=127 ! USERDEF in Baum ARRANGER
    LET arrdel4&=128 ! USERDEF in Baum ARRANGER
    LET hardstrt&=129 ! USERDEF in Baum ARRANGER
    LET hardend&=130 ! USERDEF in Baum ARRANGER
    LET arrplay1&=133 ! USERDEF in Baum ARRANGER
    LET arrplay2&=134 ! USERDEF in Baum ARRANGER
    LET arrplay3&=135 ! USERDEF in Baum ARRANGER
    LET arrplay4&=136 ! USERDEF in Baum ARRANGER
    LET arrslide&=137 ! BOX in Baum ARRANGER
    LET arrslbut&=138 ! BUTTON in Baum ARRANGER
    LET arrexit&=139 ! BUTTON in Baum ARRANGER
    LET arrhelp&=140 ! BOXTEXT in Baum ARRANGER
    LET arrclip&=141 ! USERDEF in Baum ARRANGER
    LET arrprint&=142 ! USERDEF in Baum ARRANGER
    LET klavier&=143 ! USERDEF in Baum ARRANGER
    LET slideup&=144 ! USERDEF in Baum ARRANGER
    LET slidedwn&=145 ! USERDEF in Baum ARRANGER
    LET playname&=146 ! BOXTEXT in Baum ARRANGER
    LET arrtrash&=147 ! USERDEF in Baum ARRANGER
    '
    LET setup&=14 ! Formular/Dialog
    LET setupbox&=0 ! BOX in Baum SETUP
    LET sync&=2 ! BUTTON in Baum SETUP
    LET fseldef&=4 ! BUTTON in Baum SETUP
    LET fseltxt&=6 ! BOXTEXT in Baum SETUP
    LET setform&=8 ! BOXTEXT in Baum SETUP
    LET setfbut&=9 ! BOXCHAR in Baum SETUP
    LET seclen&=13 ! BOXTEXT in Baum SETUP
    LET secl&=14 ! BUTTON in Baum SETUP
    LET secr&=15 ! BUTTON in Baum SETUP
    LET nfsbut&=17 ! BUTTON in Baum SETUP
    LET mallmax&=20 ! BUTTON in Baum SETUP
    LET setupbx2&=21 ! BOX in Baum SETUP
    LET lenmall&=22 ! FTEXT in Baum SETUP
    LET sethelp&=23 ! BOXTEXT in Baum SETUP
    LET recm&=26 ! BOXTEXT in Baum SETUP
    LET recl&=27 ! BUTTON in Baum SETUP
    LET recr&=28 ! BUTTON in Baum SETUP
    LET tresdb&=31 ! BOXTEXT in Baum SETUP
    LET tresl&=32 ! BUTTON in Baum SETUP
    LET tresr&=33 ! BUTTON in Baum SETUP
    LET setexit&=34 ! BUTTON in Baum SETUP
    LET setsave&=35 ! BUTTON in Baum SETUP
    LET setload&=36 ! BUTTON in Baum SETUP
    LET setok&=37 ! BUTTON in Baum SETUP
    LET dreide&=38 ! BUTTON in Baum SETUP
    LET flip&=39 ! BUTTON in Baum SETUP
    LET timeset&=40 ! BUTTON in Baum SETUP
    LET setshow&=41 ! BUTTON in Baum SETUP
    LET setupbx3&=43 ! BOX in Baum SETUP
    LET vertline&=44 ! BUTTON in Baum SETUP
    LET linkdot&=45 ! BUTTON in Baum SETUP
    LET spacefil&=46 ! BUTTON in Baum SETUP
    LET zoomy&=47 ! BUTTON in Baum SETUP
    LET grid&=48 ! BUTTON in Baum SETUP
    LET posy&=49 ! BUTTON in Baum SETUP
    LET zerosnap&=50 ! BUTTON in Baum SETUP
    LET frec&=51 ! BUTTON in Baum SETUP
    LET menuset&=52 ! BUTTON in Baum SETUP
    LET freeze&=54 ! BUTTON in Baum SETUP
    LET viewset&=55 ! BUTTON in Baum SETUP
    LET emulset&=56 ! BUTTON in Baum SETUP
    '
    LET info&=15 ! Formular/Dialog
    LET infobox&=0 ! BOX in Baum INFO
    LET infoexit&=1 ! BUTTON in Baum INFO
    LET helpinfo&=2 ! BOXTEXT in Baum INFO
    LET infobild&=3 ! USERDEF in Baum INFO
    LET cpyright&=12 ! TEXT in Baum INFO
    '
    LET arrmname&=16 ! Formular/Dialog
    LET arrmnbox&=0 ! BOX in Baum ARRMNAME
    LET arrmnbx2&=1 ! BOX in Baum ARRMNAME
    LET memname&=2 ! FTEXT in Baum ARRMNAME
    LET amexit&=4 ! BUTTON in Baum ARRMNAME
    LET amhelp&=5 ! BOXTEXT in Baum ARRMNAME
    LET amok&=6 ! BUTTON in Baum ARRMNAME
    '
    LET virtual&=17 ! Formular/Dialog
    LET virtbox&=0 ! BOX in Baum VIRTUAL
    LET virthelp&=2 ! BOXTEXT in Baum VIRTUAL
    LET virtbloc&=4 ! BUTTON in Baum VIRTUAL
    LET virtok&=5 ! BUTTON in Baum VIRTUAL
    LET virtbox3&=6 ! BOX in Baum VIRTUAL
    LET vblkstrt&=7 ! FTEXT in Baum VIRTUAL
    LET vseconds&=8 ! BUTTON in Baum VIRTUAL
    LET vsamples&=9 ! BUTTON in Baum VIRTUAL
    LET vblkmlen&=10 ! BOXTEXT in Baum VIRTUAL
    LET vblkvlen&=12 ! BOXTEXT in Baum VIRTUAL
    LET vslider&=13 ! BOX in Baum VIRTUAL
    LET vslbut&=14 ! BUTTON in Baum VIRTUAL
    LET virtbox2&=15 ! BOX in Baum VIRTUAL
    LET virtwork&=16 ! BUTTON in Baum VIRTUAL
    LET virtdir&=17 ! BUTTON in Baum VIRTUAL
    LET vrslide&=18 ! USERDEF in Baum VIRTUAL
    LET vlslide&=19 ! USERDEF in Baum VIRTUAL
    LET virtno&=20 ! BUTTON in Baum VIRTUAL
    LET virtplay&=21 ! USERDEF in Baum VIRTUAL
    LET virtstop&=24 ! USERDEF in Baum VIRTUAL
    '
    LET moving&=18 ! Formular/Dialog
    LET movngbox&=0 ! BOX in Baum MOVING
    LET movhlp&=1 ! BOXTEXT in Baum MOVING
    LET mvcutcpy&=3 ! BUTTON in Baum MOVING
    LET mvcutins&=4 ! BUTTON in Baum MOVING
    LET mvclrins&=5 ! BUTTON in Baum MOVING
    LET mvclrcpy&=6 ! BUTTON in Baum MOVING
    LET movexit&=7 ! BUTTON in Baum MOVING
    '
    LET arrmake&=19 ! Formular/Dialog
    LET makebox&=0 ! BOX in Baum ARRMAKE
    LET maketxt&=4 ! BOXTEXT in Baum ARRMAKE
    LET makefsel&=5 ! BUTTON in Baum ARRMAKE
    LET makerate&=6 ! BOXTEXT in Baum ARRMAKE
    LET makehelp&=9 ! BOXTEXT in Baum ARRMAKE
    LET makeok&=10 ! BUTTON in Baum ARRMAKE
    LET makexit&=11 ! BUTTON in Baum ARRMAKE
    '
    LET timeed&=20 ! Formular/Dialog
    LET timebox&=0 ! BOX in Baum TIMEED
    LET timebox2&=1 ! BOX in Baum TIMEED
    LET tedtxt&=2 ! FTEXT in Baum TIMEED
    LET tedexit&=4 ! BUTTON in Baum TIMEED
    LET tedhelp&=5 ! BOXTEXT in Baum TIMEED
    LET tedok&=6 ! BUTTON in Baum TIMEED
    '
    LET abackup&=21 ! Formular/Dialog
    LET abackbox&=0 ! BOX in Baum ABACKUP
    LET abacktxt&=1 ! BOXTEXT in Baum ABACKUP
    LET abackok&=2 ! BUTTON in Baum ABACKUP
    LET abackex&=3 ! BUTTON in Baum ABACKUP
    LET abackhlp&=5 ! BOXTEXT in Baum ABACKUP
    LET abackr1&=8 ! USERDEF in Baum ABACKUP
    LET abackr2&=9 ! USERDEF in Baum ABACKUP
    LET abackl1&=10 ! USERDEF in Baum ABACKUP
    LET abackl2&=11 ! USERDEF in Baum ABACKUP
    LET abackbo2&=12 ! BOX in Baum ABACKUP
    LET aback&=13 ! BUTTON in Baum ABACKUP
    LET abacknam&=14 ! BUTTON in Baum ABACKUP
    '
    LET inftxt&=22 ! Formular/Dialog
    LET infbox&=0 ! BOX in Baum INFTXT
    LET infbox2&=1 ! BOX in Baum INFTXT
    LET inftitel&=2 ! BUTTON in Baum INFTXT
    '
    LET smpinf&=23 ! Formular/Dialog
    LET sinfbox&=0 ! BOX in Baum SMPINF
    LET sinfok&=1 ! BUTTON in Baum SMPINF
    LET sinfexit&=2 ! BUTTON in Baum SMPINF
    LET sinfhelp&=3 ! BOXTEXT in Baum SMPINF
    LET sinfname&=6 ! BOXTEXT in Baum SMPINF
    LET sinflen&=8 ! BOXTEXT in Baum SMPINF
    LET sinfrate&=10 ! BOXTEXT in Baum SMPINF
    LET sinfsus2&=15 ! BOXTEXT in Baum SMPINF
    LET sinfrel2&=16 ! BOXTEXT in Baum SMPINF
    LET sinfl5&=18 ! BOXTEXT in Baum SMPINF
    LET sinfl6&=19 ! BOXTEXT in Baum SMPINF
    LET sinfl7&=22 ! BOXTEXT in Baum SMPINF
    LET sinfl8&=23 ! BOXTEXT in Baum SMPINF
    LET sinfl1&=24 ! BOXTEXT in Baum SMPINF
    LET sinfl2&=26 ! BOXTEXT in Baum SMPINF
    LET sinfl3&=28 ! BOXTEXT in Baum SMPINF
    LET sinfl4&=30 ! BOXTEXT in Baum SMPINF
    LET sinfdate&=32 ! BOXTEXT in Baum SMPINF
    LET sinfrel1&=33 ! BOXTEXT in Baum SMPINF
    LET sinfsus1&=34 ! BOXTEXT in Baum SMPINF
    LET sinfbox2&=35 ! BOX in Baum SMPINF
    LET sinfcomm&=36 ! FTEXT in Baum SMPINF
    LET sinfsrc&=37 ! FTEXT in Baum SMPINF
    LET sinfl9&=40 ! BOXTEXT in Baum SMPINF
    LET sinfl10&=41 ! BOXTEXT in Baum SMPINF
    LET sinfl11&=42 ! BOXTEXT in Baum SMPINF
    LET sinfl12&=43 ! BOXTEXT in Baum SMPINF
    '
    LET trakker&=24 ! Formular/Dialog
    LET trakbox&=0 ! BOX in Baum TRAKKER
    LET trakbox2&=1 ! BOX in Baum TRAKKER
    LET trakbox5&=2 ! BOX in Baum TRAKKER
    LET trkbx1&=3 ! BOX in Baum TRAKKER
    LET trklevo1&=4 ! USERDEF in Baum TRAKKER
    LET trklevt1&=5 ! BOXTEXT in Baum TRAKKER
    LET trklevu1&=6 ! USERDEF in Baum TRAKKER
    LET trkmute1&=7 ! USERDEF in Baum TRAKKER
    LET trakk1&=8 ! BOXTEXT in Baum TRAKKER
    LET trksolo1&=9 ! USERDEF in Baum TRAKKER
    LET trkact1&=10 ! USERDEF in Baum TRAKKER
    LET trkbx3&=11 ! BOX in Baum TRAKKER
    LET trklevo3&=12 ! USERDEF in Baum TRAKKER
    LET trklevt3&=13 ! BOXTEXT in Baum TRAKKER
    LET trklevu3&=14 ! USERDEF in Baum TRAKKER
    LET trkmute3&=15 ! USERDEF in Baum TRAKKER
    LET trakk3&=16 ! BOXTEXT in Baum TRAKKER
    LET trksolo3&=17 ! USERDEF in Baum TRAKKER
    LET trkact3&=18 ! USERDEF in Baum TRAKKER
    LET trktxt3&=19 ! BOXTEXT in Baum TRAKKER
    LET panl3&=20 ! USERDEF in Baum TRAKKER
    LET pantxt3&=21 ! BOXTEXT in Baum TRAKKER
    LET trkbx4&=22 ! BOX in Baum TRAKKER
    LET trklevo4&=23 ! USERDEF in Baum TRAKKER
    LET trklevt4&=24 ! BOXTEXT in Baum TRAKKER
    LET trklevu4&=25 ! USERDEF in Baum TRAKKER
    LET trkmute4&=26 ! USERDEF in Baum TRAKKER
    LET trakk4&=27 ! BOXTEXT in Baum TRAKKER
    LET trksolo4&=28 ! USERDEF in Baum TRAKKER
    LET trkact4&=29 ! USERDEF in Baum TRAKKER
    LET trktxt4&=30 ! BOXTEXT in Baum TRAKKER
    LET panl4&=31 ! USERDEF in Baum TRAKKER
    LET pantxt4&=32 ! BOXTEXT in Baum TRAKKER
    LET trkbx2&=33 ! BOX in Baum TRAKKER
    LET trklevo2&=34 ! USERDEF in Baum TRAKKER
    LET trklevt2&=35 ! BOXTEXT in Baum TRAKKER
    LET trklevu2&=36 ! USERDEF in Baum TRAKKER
    LET trkmute2&=37 ! USERDEF in Baum TRAKKER
    LET trakk2&=38 ! BOXTEXT in Baum TRAKKER
    LET trksolo2&=39 ! USERDEF in Baum TRAKKER
    LET trkact2&=40 ! USERDEF in Baum TRAKKER
    LET trktxt2&=41 ! BOXTEXT in Baum TRAKKER
    LET panl2&=42 ! USERDEF in Baum TRAKKER
    LET pantxt2&=43 ! BOXTEXT in Baum TRAKKER
    LET trktxt1&=44 ! BOXTEXT in Baum TRAKKER
    LET panr1&=45 ! USERDEF in Baum TRAKKER
    LET panl1&=46 ! USERDEF in Baum TRAKKER
    LET pantxt1&=47 ! BOXTEXT in Baum TRAKKER
    LET panr2&=48 ! USERDEF in Baum TRAKKER
    LET panr3&=49 ! USERDEF in Baum TRAKKER
    LET panr4&=50 ! USERDEF in Baum TRAKKER
    LET trakexit&=51 ! BUTTON in Baum TRAKKER
    LET trakhelp&=52 ! BOXTEXT in Baum TRAKKER
    LET trakslid&=53 ! BOX in Baum TRAKKER
    LET trakxbut&=54 ! BUTTON in Baum TRAKKER
    LET trakbox4&=55 ! BOX in Baum TRAKKER
    LET traktime&=56 ! BOXTEXT in Baum TRAKKER
    LET trakname&=57 ! BOXTEXT in Baum TRAKKER
    LET trkerr&=58 ! BOXTEXT in Baum TRAKKER
    LET pause2&=60 ! USERDEF in Baum TRAKKER
    LET rewind2&=61 ! USERDEF in Baum TRAKKER
    LET stop2&=62 ! USERDEF in Baum TRAKKER
    LET recplay2&=63 ! USERDEF in Baum TRAKKER
    LET smpplay3&=64 ! USERDEF in Baum TRAKKER
    LET smprpla2&=65 ! USERDEF in Baum TRAKKER
    LET forward2&=66 ! USERDEF in Baum TRAKKER
    LET trakanf&=67 ! USERDEF in Baum TRAKKER
    LET trakfull&=68 ! USERDEF in Baum TRAKKER
    LET smpstrt4&=69 ! USERDEF in Baum TRAKKER
    LET smpauto4&=70 ! USERDEF in Baum TRAKKER
    LET trakbox3&=71 ! BOX in Baum TRAKKER
    LET hlpedit3&=72 ! USERDEF in Baum TRAKKER
    LET hrdmerg2&=73 ! USERDEF in Baum TRAKKER
    LET trakload&=74 ! USERDEF in Baum TRAKKER
    LET trakplay&=75 ! USERDEF in Baum TRAKKER
    LET trakdel&=76 ! USERDEF in Baum TRAKKER
    LET traksall&=77 ! USERDEF in Baum TRAKKER
    LET traklall&=78 ! USERDEF in Baum TRAKKER
    LET killtrak&=79 ! USERDEF in Baum TRAKKER
    LET trakclip&=80 ! USERDEF in Baum TRAKKER
    LET tblksel&=81 ! USERDEF in Baum TRAKKER
    LET tblkmove&=82 ! USERDEF in Baum TRAKKER
    LET tblkcopy&=83 ! USERDEF in Baum TRAKKER
    LET tblkdrag&=84 ! USERDEF in Baum TRAKKER
    LET tblkedit&=85 ! USERDEF in Baum TRAKKER
    LET tblksnap&=86 ! USERDEF in Baum TRAKKER
    LET tblkvol&=87 ! USERDEF in Baum TRAKKER
    LET tblkcut&=88 ! USERDEF in Baum TRAKKER
    LET trakinfo&=92 ! BOXTEXT in Baum TRAKKER
    LET trakstrt&=93 ! BOXTEXT in Baum TRAKKER
    LET trakend&=94 ! BOXTEXT in Baum TRAKKER
    LET traklen&=95 ! BOXTEXT in Baum TRAKKER
    LET trksmpte&=96 ! BOXTEXT in Baum TRAKKER
    LET trakxr&=98 ! USERDEF in Baum TRAKKER
    LET trakxl&=99 ! USERDEF in Baum TRAKKER
    LET strtl&=100 ! USERDEF in Baum TRAKKER
    LET strtr&=101 ! USERDEF in Baum TRAKKER
    LET lend&=102 ! USERDEF in Baum TRAKKER
    LET ltime&=103 ! USERDEF in Baum TRAKKER
    LET rend&=104 ! USERDEF in Baum TRAKKER
    LET rtime&=105 ! USERDEF in Baum TRAKKER
    LET trkblk&=106 ! USERDEF in Baum TRAKKER
    LET trkcopy&=107 ! USERDEF in Baum TRAKKER
    LET trkdel&=108 ! USERDEF in Baum TRAKKER
    LET tblkplay&=109 ! USERDEF in Baum TRAKKER
    LET timeline&=110 ! BOXTEXT in Baum TRAKKER
    LET trkslot&=111 ! BOXTEXT in Baum TRAKKER
    LET trk4&=116 ! USERDEF in Baum TRAKKER
    LET trk8&=117 ! USERDEF in Baum TRAKKER
    LET trk12&=118 ! USERDEF in Baum TRAKKER
    LET trk16&=119 ! USERDEF in Baum TRAKKER
    LET spurslid&=120 ! BOX in Baum TRAKKER
    LET spurybut&=121 ! BUTTON in Baum TRAKKER
    LET spuro&=122 ! USERDEF in Baum TRAKKER
    LET spuru&=123 ! USERDEF in Baum TRAKKER
    LET zoomxl&=124 ! USERDEF in Baum TRAKKER
    LET zoomxr&=125 ! USERDEF in Baum TRAKKER
    LET zoomslid&=126 ! BOX in Baum TRAKKER
    LET zoomxbut&=127 ! BUTTON in Baum TRAKKER
    LET trakdur&=128 ! BOXTEXT in Baum TRAKKER
    LET tnamcom&=133 ! USERDEF in Baum TRAKKER
    LET curve&=134 ! USERDEF in Baum TRAKKER
    LET trksolo&=135 ! USERDEF in Baum TRAKKER
    LET trkrvol&=137 ! BOX in Baum TRAKKER
    LET trkrmax&=138 ! BOX in Baum TRAKKER
    LET trklvol&=139 ! BOX in Baum TRAKKER
    LET trklmax&=140 ! BOX in Baum TRAKKER
    LET trkvbox&=141 ! BOXTEXT in Baum TRAKKER
    LET trkvol&=143 ! USERDEF in Baum TRAKKER
    LET tpstrt&=144 ! BOXTEXT in Baum TRAKKER
    LET tpend&=145 ! BOXTEXT in Baum TRAKKER
    LET tpsl&=147 ! USERDEF in Baum TRAKKER
    LET tpel&=148 ! USERDEF in Baum TRAKKER
    LET tpsr&=149 ! USERDEF in Baum TRAKKER
    LET tper&=150 ! USERDEF in Baum TRAKKER
    LET trkmon&=151 ! BOXTEXT in Baum TRAKKER
    '
    LET dropdown&=25 ! Menuebaum
    LET ddstar&=3 ! TITLE in Baum DROPDOWN
    LET dddat&=4 ! TITLE in Baum DROPDOWN
    LET ddwind&=5 ! TITLE in Baum DROPDOWN
    LET ddfunc&=6 ! TITLE in Baum DROPDOWN
    LET ddplugin&=7 ! TITLE in Baum DROPDOWN
    LET ddinfo&=10 ! STRING in Baum DROPDOWN
    LET ddload&=19 ! STRING in Baum DROPDOWN
    LET ddsave&=20 ! STRING in Baum DROPDOWN
    LET ddexit&=21 ! STRING in Baum DROPDOWN
    LET ddsmp16&=23 ! STRING in Baum DROPDOWN
    LET ddblock&=24 ! STRING in Baum DROPDOWN
    LET ddpeak&=25 ! STRING in Baum DROPDOWN
    LET ddarr&=26 ! STRING in Baum DROPDOWN
    LET ddtrakk&=27 ! STRING in Baum DROPDOWN
    LET ddloop&=28 ! STRING in Baum DROPDOWN
    LET dddsp&=29 ! STRING in Baum DROPDOWN
    LET ddworkm&=30 ! STRING in Baum DROPDOWN
    LET ddsetup&=32 ! STRING in Baum DROPDOWN
    LET ddfader&=33 ! STRING in Baum DROPDOWN
    LET ddmidi&=34 ! STRING in Baum DROPDOWN
    LET ddbank&=35 ! STRING in Baum DROPDOWN
    LET ddmon&=37 ! STRING in Baum DROPDOWN
    LET ddauto&=38 ! STRING in Baum DROPDOWN
    LET ddmanu&=39 ! STRING in Baum DROPDOWN
    LET ddplay&=40 ! STRING in Baum DROPDOWN
    LET ddhost&=42 ! STRING in Baum DROPDOWN
    LET ddmix&=43 ! STRING in Baum DROPDOWN
    LET ddplug1&=45 ! STRING in Baum DROPDOWN
    LET ddplug2&=46 ! STRING in Baum DROPDOWN
    LET ddplug3&=47 ! STRING in Baum DROPDOWN
    LET ddplug4&=48 ! STRING in Baum DROPDOWN
    LET ddplug5&=49 ! STRING in Baum DROPDOWN
    LET ddplug6&=50 ! STRING in Baum DROPDOWN
    LET ddplug7&=51 ! STRING in Baum DROPDOWN
    LET ddplug8&=52 ! STRING in Baum DROPDOWN
    LET ddplug9&=53 ! STRING in Baum DROPDOWN
    LET ddplug10&=54 ! STRING in Baum DROPDOWN
    '
    LET wmode&=26 ! Formular/Dialog
    LET wmbox1&=0 ! BOX in Baum WMODE
    LET wmhelp&=1 ! BOXTEXT in Baum WMODE
    LET wmexit&=2 ! BUTTON in Baum WMODE
    LET wmbox2&=4 ! BOX in Baum WMODE
    LET mixcpu&=5 ! BUTTON in Baum WMODE
    LET mixdma&=6 ! BUTTON in Baum WMODE
    LET mixdsp&=7 ! BUTTON in Baum WMODE
    LET wmbox4&=9 ! BOX in Baum WMODE
    LET mast16&=10 ! BUTTON in Baum WMODE
    LET mast24&=11 ! BUTTON in Baum WMODE
    LET wmbox3&=13 ! BOX in Baum WMODE
    LET recm2&=14 ! BUTTON in Baum WMODE
    LET recm4&=15 ! BUTTON in Baum WMODE
    LET recm8&=16 ! BUTTON in Baum WMODE
    LET wmbox5&=18 ! BOX in Baum WMODE
    LET ramlo&=19 ! BUTTON in Baum WMODE
    LET ramhi&=20 ! BUTTON in Baum WMODE
    LET syncsrte&=23 ! FTEXT in Baum WMODE
    LET wmodebx2&=24 ! BOX in Baum WMODE
    LET synchz&=25 ! FTEXT in Baum WMODE
    LET wmodebx3&=26 ! BOX in Baum WMODE
    LET smpteset&=27 ! FTEXT in Baum WMODE
    LET syncpcg&=28 ! BUTTON in Baum WMODE
    LET syncadat&=29 ! BUTTON in Baum WMODE
    LET syncmtc&=30 ! BUTTON in Baum WMODE
    LET syncxmit&=31 ! BUTTON in Baum WMODE
    LET syncalc&=32 ! BUTTON in Baum WMODE
    LET clkfalc&=33 ! BUTTON in Baum WMODE
    LET wmbox7&=34 ! BOX in Baum WMODE
    LET frame24&=35 ! BUTTON in Baum WMODE
    LET frame25&=36 ! BUTTON in Baum WMODE
    LET frame30&=37 ! BUTTON in Baum WMODE
    '
    LET fsel&=27 ! Formular/Dialog
    LET fselbox&=0 ! BOX in Baum FSEL
    LET fselbox2&=1 ! BOX in Baum FSEL
    LET fsbut1&=2 ! BOXTEXT in Baum FSEL
    LET fsbut2&=3 ! BOXTEXT in Baum FSEL
    LET fsbut3&=4 ! BOXTEXT in Baum FSEL
    LET fsbut4&=5 ! BOXTEXT in Baum FSEL
    LET fsbut5&=6 ! BOXTEXT in Baum FSEL
    LET fsbut6&=7 ! BOXTEXT in Baum FSEL
    LET fsbut7&=8 ! BOXTEXT in Baum FSEL
    LET fsbut8&=9 ! BOXTEXT in Baum FSEL
    LET fsbut9&=10 ! BOXTEXT in Baum FSEL
    LET fsbut10&=11 ! BOXTEXT in Baum FSEL
    LET fsbut11&=12 ! BOXTEXT in Baum FSEL
    LET fsbut12&=13 ! BOXTEXT in Baum FSEL
    LET fsbut13&=14 ! BOXTEXT in Baum FSEL
    LET fsbut14&=15 ! BOXTEXT in Baum FSEL
    LET fsbut15&=16 ! BOXTEXT in Baum FSEL
    LET fstxt1&=17 ! BOXTEXT in Baum FSEL
    LET fstxt2&=18 ! BOXTEXT in Baum FSEL
    LET fstxt3&=19 ! BOXTEXT in Baum FSEL
    LET fstxt4&=20 ! BOXTEXT in Baum FSEL
    LET fstxt5&=21 ! BOXTEXT in Baum FSEL
    LET fstxt6&=22 ! BOXTEXT in Baum FSEL
    LET fstxt7&=23 ! BOXTEXT in Baum FSEL
    LET fstxt8&=24 ! BOXTEXT in Baum FSEL
    LET fstxt9&=25 ! BOXTEXT in Baum FSEL
    LET fstxt10&=26 ! BOXTEXT in Baum FSEL
    LET fstxt11&=27 ! BOXTEXT in Baum FSEL
    LET fstxt12&=28 ! BOXTEXT in Baum FSEL
    LET fstxt13&=29 ! BOXTEXT in Baum FSEL
    LET fstxt14&=30 ! BOXTEXT in Baum FSEL
    LET fstxt15&=31 ! BOXTEXT in Baum FSEL
    LET fsslide&=32 ! BOX in Baum FSEL
    LET fssldbut&=33 ! BUTTON in Baum FSEL
    LET fsok&=34 ! BUTTON in Baum FSEL
    LET fshelp&=35 ! BOXTEXT in Baum FSEL
    LET fsplay&=36 ! USERDEF in Baum FSEL
    LET fsexit&=37 ! BUTTON in Baum FSEL
    LET fsordner&=39 ! BUTTON in Baum FSEL
    LET fsotxt&=40 ! BOXTEXT in Baum FSEL
    LET fsmatic&=41 ! USERDEF in Baum FSEL
    LET fsins&=42 ! USERDEF in Baum FSEL
    LET fsdel&=43 ! USERDEF in Baum FSEL
    LET fsadd&=44 ! BUTTON in Baum FSEL
    LET fsnew&=45 ! BUTTON in Baum FSEL
    LET fsload&=46 ! USERDEF in Baum FSEL
    LET fssave&=47 ! USERDEF in Baum FSEL
    LET fsclf&=48 ! USERDEF in Baum FSEL
    LET fssldup&=49 ! USERDEF in Baum FSEL
    LET fsslddwn&=50 ! USERDEF in Baum FSEL
    LET fsstop&=51 ! USERDEF in Baum FSEL
    LET fswait&=52 ! USERDEF in Baum FSEL
    LET fsend&=53 ! USERDEF in Baum FSEL
    LET fstime&=54 ! BOXTEXT in Baum FSEL
    LET fslplay&=55 ! USERDEF in Baum FSEL
    LET tfsabc&=56 ! USERDEF in Baum FSEL
    LET tfsearch&=57 ! BUTTON in Baum FSEL
    '
    LET meldung&=28 ! Formular/Dialog
    LET meldbox&=0 ! BOX in Baum MELDUNG
    LET meldtxt&=1 ! BOXTEXT in Baum MELDUNG
    '
    LET trknamin&=29 ! Formular/Dialog
    LET trktxbox&=0 ! BOX in Baum TRKNAMIN
    LET trktxbo2&=1 ! BOX in Baum TRKNAMIN
    LET trktxtin&=2 ! FTEXT in Baum TRKNAMIN
    LET trktxex&=4 ! BUTTON in Baum TRKNAMIN
    LET trktxhlp&=5 ! BOXTEXT in Baum TRKNAMIN
    LET trktxok&=6 ! BUTTON in Baum TRKNAMIN
    '
    LET trkcomin&=30 ! Formular/Dialog
    LET trkcbox&=0 ! BOX in Baum TRKCOMIN
    LET trkcbox2&=1 ! BOX in Baum TRKCOMIN
    LET trkctxin&=2 ! FTEXT in Baum TRKCOMIN
    LET trkcexit&=4 ! BUTTON in Baum TRKCOMIN
    LET trkchlp&=5 ! BOXTEXT in Baum TRKCOMIN
    LET trkcok&=6 ! BUTTON in Baum TRKCOMIN
    '
    LET mrktxtin&=31 ! Formular/Dialog
    LET mtexbox&=0 ! BOX in Baum MRKTXTIN
    LET mtexbox2&=1 ! BOX in Baum MRKTXTIN
    LET mtex&=2 ! FTEXT in Baum MRKTXTIN
    LET mtexex&=4 ! BUTTON in Baum MRKTXTIN
    LET mtexhelp&=5 ! BOXTEXT in Baum MRKTXTIN
    LET mtexok&=6 ! BUTTON in Baum MRKTXTIN
    '
    LET mrkfind&=32 ! Formular/Dialog
    LET mrkfbox&=0 ! BOX in Baum MRKFIND
    LET mrkfex&=2 ! BUTTON in Baum MRKFIND
    LET mrkfhelp&=3 ! BOXTEXT in Baum MRKFIND
    LET mrkfok&=4 ! BUTTON in Baum MRKFIND
    LET mrkfbox2&=6 ! BOX in Baum MRKFIND
    LET mrkftims&=7 ! BOXTEXT in Baum MRKFIND
    LET mrkftime&=8 ! BOXTEXT in Baum MRKFIND
    LET mrkfbuts&=9 ! USERDEF in Baum MRKFIND
    LET mrkfbute&=10 ! USERDEF in Baum MRKFIND
    LET mrkfdown&=11 ! USERDEF in Baum MRKFIND
    LET mrkfslid&=12 ! BOX in Baum MRKFIND
    LET mrkfbut&=13 ! BUTTON in Baum MRKFIND
    LET mrkfup&=14 ! USERDEF in Baum MRKFIND
    LET mrkfnr&=15 ! BOXTEXT in Baum MRKFIND
    LET mrkfbuti&=16 ! USERDEF in Baum MRKFIND
    LET mrkfbutr&=17 ! USERDEF in Baum MRKFIND
    LET mrkftimi&=18 ! BOXTEXT in Baum MRKFIND
    LET mrkftimr&=19 ! BOXTEXT in Baum MRKFIND
    LET mrkftxt&=20 ! BOXTEXT in Baum MRKFIND
    '
    LET disked&=33 ! Formular/Dialog
    LET dskedbox&=0 ! BOX in Baum DISKED
    LET dskedex&=1 ! BUTTON in Baum DISKED
    LET dskedhlp&=2 ! BOXTEXT in Baum DISKED
    LET dskedbx4&=4 ! BOX in Baum DISKED
    LET dskedbx2&=5 ! BOX in Baum DISKED
    LET dskedit&=6 ! FTEXT in Baum DISKED
    LET dskren&=8 ! USERDEF in Baum DISKED
    LET dskopie&=9 ! USERDEF in Baum DISKED
    LET dskedbx3&=10 ! BOX in Baum DISKED
    LET dskedtxt&=11 ! BOXTEXT in Baum DISKED
    LET dskill&=13 ! USERDEF in Baum DISKED
    '
    LET clocks&=34 ! Formular/Dialog
    LET clkbox&=0 ! BOX in Baum CLOCKS
    LET clockex&=2 ! BUTTON in Baum CLOCKS
    LET clockhlp&=3 ! BOXTEXT in Baum CLOCKS
    LET clockok&=4 ! BUTTON in Baum CLOCKS
    LET clkbox2&=6 ! BOX in Baum CLOCKS
    LET clock1&=7 ! BOXTEXT in Baum CLOCKS
    LET clock2&=8 ! BOXTEXT in Baum CLOCKS
    LET clkdown&=9 ! USERDEF in Baum CLOCKS
    LET clkslid&=10 ! BOX in Baum CLOCKS
    LET clkbut&=11 ! BUTTON in Baum CLOCKS
    LET clkup&=12 ! USERDEF in Baum CLOCKS
    LET clock3&=13 ! BOXTEXT in Baum CLOCKS
    LET clock4&=14 ! BOXTEXT in Baum CLOCKS
    LET clock5&=15 ! BOXTEXT in Baum CLOCKS
    LET clockm&=16 ! BOXTEXT in Baum CLOCKS
    '
    LET marknumb&=35 ! Formular/Dialog
    LET mnumbox&=0 ! BOX in Baum MARKNUMB
    LET mnumbox2&=1 ! BOX in Baum MARKNUMB
    LET mnumtxt&=2 ! FTEXT in Baum MARKNUMB
    LET mnumexit&=4 ! BUTTON in Baum MARKNUMB
    LET mnumhelp&=5 ! BOXTEXT in Baum MARKNUMB
    LET mnumok&=6 ! BUTTON in Baum MARKNUMB
    '
    LET alertbox&=36 ! Formular/Dialog
    LET alertcol&=0 ! BOX in Baum ALERTBOX
  ELSE
    REM Resource Datei Indizes fÅr PANY2
    '
    LET smp16&=0 ! Formular/Dialog
    LET mainbox&=0 ! BOX in Baum SMP16
    LET exit&=1 ! BUTTON in Baum SMP16
    LET mainbox2&=2 ! BOX in Baum SMP16
    LET emph&=4 ! BUTTON in Baum SMP16
    LET audio&=5 ! BUTTON in Baum SMP16
    LET use&=6 ! BUTTON in Baum SMP16
    LET smp32&=8 ! BUTTON in Baum SMP16
    LET smp44&=9 ! BUTTON in Baum SMP16
    LET smp48&=10 ! BUTTON in Baum SMP16
    LET noval&=12 ! BUTTON in Baum SMP16
    LET confid&=13 ! BUTTON in Baum SMP16
    LET parity&=14 ! BUTTON in Baum SMP16
    LET biphase&=15 ! BUTTON in Baum SMP16
    LET nolock&=16 ! BUTTON in Baum SMP16
    LET prot&=18 ! BUTTON in Baum SMP16
    LET mainbox5&=19 ! BOX in Baum SMP16
    LET ydsp&=20 ! STRING in Baum SMP16
    LET dsp&=21 ! BOXTEXT in Baum SMP16
    LET dspcirc&=22 ! BOXCHAR in Baum SMP16
    LET mainbox6&=23 ! BOX in Baum SMP16
    LET input&=25 ! BOXTEXT in Baum SMP16
    LET incirc&=26 ! BOXCHAR in Baum SMP16
    LET rate2&=28 ! BOXTEXT in Baum SMP16
    LET ratecir2&=29 ! BOXCHAR in Baum SMP16
    LET helporig&=30 ! BOXTEXT in Baum SMP16
    LET mainbox4&=31 ! BOX in Baum SMP16
    LET source&=33 ! BOXTEXT in Baum SMP16
    LET srccirc&=34 ! BOXCHAR in Baum SMP16
    LET protect&=36 ! BOXTEXT in Baum SMP16
    LET protcirc&=37 ! BOXCHAR in Baum SMP16
    LET mode&=39 ! BOXTEXT in Baum SMP16
    LET modecirc&=40 ! BOXCHAR in Baum SMP16
    LET emphasis&=42 ! BOXTEXT in Baum SMP16
    LET emphcirc&=43 ! BOXCHAR in Baum SMP16
    LET bridge&=44 ! BUTTON in Baum SMP16
    '
    LET smpedit&=1 ! Formular/Dialog
    LET editbox7&=0 ! BOX in Baum SMPEDIT
    LET editbox&=1 ! BOX in Baum SMPEDIT
    LET smpsec&=2 ! BOXTEXT in Baum SMPEDIT
    LET editbox5&=5 ! BOX in Baum SMPEDIT
    LET smpanf&=6 ! USERDEF in Baum SMPEDIT
    LET smpr1&=7 ! USERDEF in Baum SMPEDIT
    LET smpl1&=8 ! USERDEF in Baum SMPEDIT
    LET smpl2&=9 ! USERDEF in Baum SMPEDIT
    LET smpr2&=10 ! USERDEF in Baum SMPEDIT
    LET smpl3&=11 ! USERDEF in Baum SMPEDIT
    LET smpmid&=12 ! USERDEF in Baum SMPEDIT
    LET smpend&=13 ! USERDEF in Baum SMPEDIT
    LET smpr3&=14 ! USERDEF in Baum SMPEDIT
    LET rate&=15 ! BOXTEXT in Baum SMPEDIT
    LET ratecirc&=16 ! BOXCHAR in Baum SMPEDIT
    LET editbox6&=17 ! BOX in Baum SMPEDIT
    LET smppmark&=18 ! USERDEF in Baum SMPEDIT
    LET midi&=19 ! USERDEF in Baum SMPEDIT
    LET mintext&=20 ! BOXTEXT in Baum SMPEDIT
    LET smploop&=22 ! USERDEF in Baum SMPEDIT
    LET smpcblk&=23 ! USERDEF in Baum SMPEDIT
    LET smpfile&=24 ! BOXTEXT in Baum SMPEDIT
    LET smprate&=25 ! BOXTEXT in Baum SMPEDIT
    LET trash&=26 ! USERDEF in Baum SMPEDIT
    LET zomslide&=28 ! BOX in Baum SMPEDIT
    LET zoombutt&=29 ! BUTTON in Baum SMPEDIT
    LET cetxt&=31 ! BOXTEXT in Baum SMPEDIT
    LET cstxt&=32 ! BOXTEXT in Baum SMPEDIT
    LET pixzoom&=34 ! USERDEF in Baum SMPEDIT
    LET showxy&=35 ! BOXTEXT in Baum SMPEDIT
    LET pntprsmp&=36 ! BOXTEXT in Baum SMPEDIT
    LET freemem&=37 ! BOXTEXT in Baum SMPEDIT
    LET clock&=38 ! BOXTEXT in Baum SMPEDIT
    LET smpname&=39 ! BOXTEXT in Baum SMPEDIT
    LET flyer&=41 ! USERDEF in Baum SMPEDIT
    LET zooml&=42 ! USERDEF in Baum SMPEDIT
    LET zoomr&=43 ! USERDEF in Baum SMPEDIT
    LET smpedhlp&=46 ! BOXTEXT in Baum SMPEDIT
    LET smpexit&=47 ! BUTTON in Baum SMPEDIT
    LET mover&=48 ! BOXTEXT in Baum SMPEDIT
    LET movecirc&=49 ! BOXCHAR in Baum SMPEDIT
    LET smpauto2&=51 ! USERDEF in Baum SMPEDIT
    LET smpstrt2&=52 ! USERDEF in Baum SMPEDIT
    LET recplay3&=53 ! USERDEF in Baum SMPEDIT
    LET smpplay&=54 ! USERDEF in Baum SMPEDIT
    LET smpstop&=55 ! USERDEF in Baum SMPEDIT
    LET smpwait&=56 ! USERDEF in Baum SMPEDIT
    LET hard&=57 ! USERDEF in Baum SMPEDIT
    LET editbox3&=59 ! BOX in Baum SMPEDIT
    LET edmtims&=60 ! BOXTEXT in Baum SMPEDIT
    LET edmtime&=61 ! BOXTEXT in Baum SMPEDIT
    LET edmdown&=62 ! USERDEF in Baum SMPEDIT
    LET edmslide&=63 ! BOX in Baum SMPEDIT
    LET edmbut&=64 ! BUTTON in Baum SMPEDIT
    LET edmup&=65 ! USERDEF in Baum SMPEDIT
    LET edmnr&=66 ! BOXTEXT in Baum SMPEDIT
    LET edmtimi&=67 ! BOXTEXT in Baum SMPEDIT
    LET edmtimr&=68 ! BOXTEXT in Baum SMPEDIT
    LET edmtxt&=69 ! BOXTEXT in Baum SMPEDIT
    LET edmbox&=70 ! BOX in Baum SMPEDIT
    LET edmbuts&=71 ! USERDEF in Baum SMPEDIT
    LET edmbute&=72 ! USERDEF in Baum SMPEDIT
    LET edmbuti&=73 ! USERDEF in Baum SMPEDIT
    LET edmbutr&=74 ! USERDEF in Baum SMPEDIT
    LET smplen&=75 ! BOXTEXT in Baum SMPEDIT
    LET resolu&=76 ! BOXTEXT in Baum SMPEDIT
    LET editbox2&=78 ! BOX in Baum SMPEDIT
    LET setuper&=79 ! USERDEF in Baum SMPEDIT
    LET edfade&=80 ! USERDEF in Baum SMPEDIT
    LET peaksw2&=81 ! USERDEF in Baum SMPEDIT
    LET disk&=82 ! USERDEF in Baum SMPEDIT
    LET loopart&=83 ! USERDEF in Baum SMPEDIT
    LET blocfunc&=84 ! USERDEF in Baum SMPEDIT
    LET arrange&=85 ! USERDEF in Baum SMPEDIT
    LET smpload&=86 ! USERDEF in Baum SMPEDIT
    LET smpsave&=87 ! USERDEF in Baum SMPEDIT
    LET infoicon&=88 ! USERDEF in Baum SMPEDIT
    LET edmidi&=89 ! USERDEF in Baum SMPEDIT
    LET trak&=90 ! USERDEF in Baum SMPEDIT
    LET edsmp16&=91 ! USERDEF in Baum SMPEDIT
    LET swdsp&=92 ! USERDEF in Baum SMPEDIT
    LET smpdbank&=93 ! USERDEF in Baum SMPEDIT
    LET wmodes&=94 ! USERDEF in Baum SMPEDIT
    LET scrubs&=95 ! USERDEF in Baum SMPEDIT
    LET swmark&=96 ! USERDEF in Baum SMPEDIT
    LET swblk&=97 ! USERDEF in Baum SMPEDIT
    LET swsearch&=98 ! USERDEF in Baum SMPEDIT
    LET swyzoom&=99 ! USERDEF in Baum SMPEDIT
    LET swclick&=100 ! USERDEF in Baum SMPEDIT
    LET swdraw&=101 ! USERDEF in Baum SMPEDIT
    LET curvbox&=102 ! BOX in Baum SMPEDIT
    LET editbox4&=103 ! BOX in Baum SMPEDIT
    LET editbox8&=104 ! BOX in Baum SMPEDIT
    LET smptxr&=105 ! TEXT in Baum SMPEDIT
    LET smptxl&=106 ! TEXT in Baum SMPEDIT
    LET rm80&=107 ! BOXTEXT in Baum SMPEDIT
    LET rp0&=108 ! BOXTEXT in Baum SMPEDIT
    LET rp80&=109 ! BOXTEXT in Baum SMPEDIT
    LET rp60&=110 ! BOXTEXT in Baum SMPEDIT
    LET rp40&=111 ! BOXTEXT in Baum SMPEDIT
    LET rm60&=112 ! BOXTEXT in Baum SMPEDIT
    LET rm40&=113 ! BOXTEXT in Baum SMPEDIT
    LET lp80&=114 ! BOXTEXT in Baum SMPEDIT
    LET lm80&=115 ! BOXTEXT in Baum SMPEDIT
    LET lp40&=116 ! BOXTEXT in Baum SMPEDIT
    LET lp60&=117 ! BOXTEXT in Baum SMPEDIT
    LET lm60&=118 ! BOXTEXT in Baum SMPEDIT
    LET lm40&=119 ! BOXTEXT in Baum SMPEDIT
    LET lm20&=120 ! BOXTEXT in Baum SMPEDIT
    LET lp0&=121 ! BOXTEXT in Baum SMPEDIT
    LET rp20&=122 ! BOXTEXT in Baum SMPEDIT
    LET rm20&=123 ! BOXTEXT in Baum SMPEDIT
    LET lp20&=124 ! BOXTEXT in Baum SMPEDIT
    LET scrlslde&=125 ! BOX in Baum SMPEDIT
    LET scrolbut&=126 ! BUTTON in Baum SMPEDIT
    LET lscroll&=127 ! USERDEF in Baum SMPEDIT
    LET rscroll&=128 ! USERDEF in Baum SMPEDIT
    LET lr100&=129 ! BOXTEXT in Baum SMPEDIT
    LET blkfile&=136 ! TEXT in Baum SMPEDIT
    LET blkfilel&=137 ! BOX in Baum SMPEDIT
    LET blkfiler&=138 ! BOX in Baum SMPEDIT
    '
    LET info&=2 ! Formular/Dialog
    LET infobox&=0 ! BOX in Baum INFO
    LET infoexit&=1 ! BUTTON in Baum INFO
    LET helpinfo&=2 ! BOXTEXT in Baum INFO
    LET infobild&=3 ! USERDEF in Baum INFO
    LET swelogo&=10 ! USERDEF in Baum INFO
    LET cpyrdrv&=12 ! TEXT in Baum INFO
    LET cpyright&=17 ! TEXT in Baum INFO
    '
    LET arranger&=3 ! Formular/Dialog
    LET arrbox&=0 ! BOX in Baum ARRANGER
    LET arrbox2&=1 ! BOX in Baum ARRANGER
    LET hlpedit2&=2 ! USERDEF in Baum ARRANGER
    LET arrload&=3 ! USERDEF in Baum ARRANGER
    LET arrsave&=4 ! USERDEF in Baum ARRANGER
    LET arrmidi&=5 ! USERDEF in Baum ARRANGER
    LET arrins&=6 ! USERDEF in Baum ARRANGER
    LET arrdel&=7 ! USERDEF in Baum ARRANGER
    LET smpauto3&=9 ! USERDEF in Baum ARRANGER
    LET smpstrt3&=10 ! USERDEF in Baum ARRANGER
    LET pause&=11 ! USERDEF in Baum ARRANGER
    LET rewind&=12 ! USERDEF in Baum ARRANGER
    LET recplay&=13 ! USERDEF in Baum ARRANGER
    LET smpplay2&=14 ! USERDEF in Baum ARRANGER
    LET smprplay&=15 ! USERDEF in Baum ARRANGER
    LET forward&=16 ! USERDEF in Baum ARRANGER
    LET arrstrt&=17 ! USERDEF in Baum ARRANGER
    LET arrend&=18 ! USERDEF in Baum ARRANGER
    LET stop&=19 ! USERDEF in Baum ARRANGER
    LET arrbox4&=20 ! BOX in Baum ARRANGER
    LET playlen&=21 ! BOXTEXT in Baum ARRANGER
    LET arreal&=22 ! USERDEF in Baum ARRANGER
    LET arrblk&=23 ! USERDEF in Baum ARRANGER
    LET arrbox3&=24 ! BOX in Baum ARRANGER
    LET arrbox5&=25 ! BOX in Baum ARRANGER
    LET hardfs1&=26 ! BUTTON in Baum ARRANGER
    LET spur1&=27 ! BOXTEXT in Baum ARRANGER
    LET arrbox6&=28 ! BOX in Baum ARRANGER
    LET hardfs2&=29 ! BUTTON in Baum ARRANGER
    LET spur2&=30 ! BOXTEXT in Baum ARRANGER
    LET arrbox7&=31 ! BOX in Baum ARRANGER
    LET hardfs3&=32 ! BUTTON in Baum ARRANGER
    LET spur3&=33 ! BOXTEXT in Baum ARRANGER
    LET arrbox8&=34 ! BOX in Baum ARRANGER
    LET hardfs4&=35 ! BUTTON in Baum ARRANGER
    LET spur4&=36 ! BOXTEXT in Baum ARRANGER
    LET hardst2&=38 ! BOXTEXT in Baum ARRANGER
    LET hardst3&=40 ! BOXTEXT in Baum ARRANGER
    LET hardst4&=42 ! BOXTEXT in Baum ARRANGER
    LET harde2&=44 ! BOXTEXT in Baum ARRANGER
    LET harde3&=46 ! BOXTEXT in Baum ARRANGER
    LET harde4&=48 ! BOXTEXT in Baum ARRANGER
    LET harde1&=50 ! BOXTEXT in Baum ARRANGER
    LET hardlen1&=52 ! BOXTEXT in Baum ARRANGER
    LET hardlen2&=54 ! BOXTEXT in Baum ARRANGER
    LET hardlen3&=56 ! BOXTEXT in Baum ARRANGER
    LET hardlen4&=58 ! BOXTEXT in Baum ARRANGER
    LET arrnr1&=61 ! BOXTEXT in Baum ARRANGER
    LET arrnr2&=63 ! BOXTEXT in Baum ARRANGER
    LET arrnr3&=65 ! BOXTEXT in Baum ARRANGER
    LET arrm1&=66 ! USERDEF in Baum ARRANGER
    LET arrm2&=67 ! USERDEF in Baum ARRANGER
    LET arrm3&=68 ! USERDEF in Baum ARRANGER
    LET arrm4&=69 ! USERDEF in Baum ARRANGER
    LET hardst1&=71 ! BOXTEXT in Baum ARRANGER
    LET arrnote2&=73 ! BOXTEXT in Baum ARRANGER
    LET arrnote3&=75 ! BOXTEXT in Baum ARRANGER
    LET arrnote4&=77 ! BOXTEXT in Baum ARRANGER
    LET arrnr4&=81 ! BOXTEXT in Baum ARRANGER
    LET arrmem1&=83 ! BOXTEXT in Baum ARRANGER
    LET arrmem2&=85 ! BOXTEXT in Baum ARRANGER
    LET arrmem3&=87 ! BOXTEXT in Baum ARRANGER
    LET arrmem4&=89 ! BOXTEXT in Baum ARRANGER
    LET arrnote1&=91 ! BOXTEXT in Baum ARRANGER
    LET arrch1&=93 ! BOXTEXT in Baum ARRANGER
    LET arrch2&=95 ! BOXTEXT in Baum ARRANGER
    LET arrch3&=97 ! BOXTEXT in Baum ARRANGER
    LET arrch4&=99 ! BOXTEXT in Baum ARRANGER
    LET arrtri1&=101 ! BUTTON in Baum ARRANGER
    LET arrtri2&=102 ! BUTTON in Baum ARRANGER
    LET arrtri3&=103 ! BUTTON in Baum ARRANGER
    LET arrtri4&=104 ! BUTTON in Baum ARRANGER
    LET arrloop1&=107 ! USERDEF in Baum ARRANGER
    LET arrloop2&=108 ! USERDEF in Baum ARRANGER
    LET arrloop3&=109 ! USERDEF in Baum ARRANGER
    LET arrloop4&=110 ! USERDEF in Baum ARRANGER
    LET arrsmpr1&=114 ! BOXTEXT in Baum ARRANGER
    LET arrsmpr2&=116 ! BOXTEXT in Baum ARRANGER
    LET arrsmpr3&=118 ! BOXTEXT in Baum ARRANGER
    LET arrsmpr4&=120 ! BOXTEXT in Baum ARRANGER
    LET arrdel1&=125 ! USERDEF in Baum ARRANGER
    LET arrdel2&=126 ! USERDEF in Baum ARRANGER
    LET arrdel3&=127 ! USERDEF in Baum ARRANGER
    LET arrdel4&=128 ! USERDEF in Baum ARRANGER
    LET hardstrt&=129 ! USERDEF in Baum ARRANGER
    LET hardend&=130 ! USERDEF in Baum ARRANGER
    LET arrplay1&=133 ! USERDEF in Baum ARRANGER
    LET arrplay2&=134 ! USERDEF in Baum ARRANGER
    LET arrplay3&=135 ! USERDEF in Baum ARRANGER
    LET arrplay4&=136 ! USERDEF in Baum ARRANGER
    LET arrslide&=137 ! BOX in Baum ARRANGER
    LET arrslbut&=138 ! BUTTON in Baum ARRANGER
    LET arrexit&=139 ! BUTTON in Baum ARRANGER
    LET arrhelp&=140 ! BOXTEXT in Baum ARRANGER
    LET arrclip&=141 ! USERDEF in Baum ARRANGER
    LET arrprint&=142 ! USERDEF in Baum ARRANGER
    LET klavier&=143 ! USERDEF in Baum ARRANGER
    LET slideup&=144 ! USERDEF in Baum ARRANGER
    LET slidedwn&=145 ! USERDEF in Baum ARRANGER
    LET playname&=146 ! BOXTEXT in Baum ARRANGER
    LET arrtrash&=147 ! USERDEF in Baum ARRANGER
    '
    LET trakker&=4 ! Formular/Dialog
    LET trakbox&=0 ! BOX in Baum TRAKKER
    LET trakbox3&=1 ! BOX in Baum TRAKKER
    LET hlpedit3&=2 ! USERDEF in Baum TRAKKER
    LET hrdmerg2&=3 ! USERDEF in Baum TRAKKER
    LET trakload&=4 ! USERDEF in Baum TRAKKER
    LET trakplay&=5 ! USERDEF in Baum TRAKKER
    LET trakdel&=6 ! USERDEF in Baum TRAKKER
    LET traksall&=7 ! USERDEF in Baum TRAKKER
    LET traklall&=8 ! USERDEF in Baum TRAKKER
    LET killtrak&=9 ! USERDEF in Baum TRAKKER
    LET trakclip&=10 ! USERDEF in Baum TRAKKER
    LET tblksel&=11 ! USERDEF in Baum TRAKKER
    LET tblkmove&=12 ! USERDEF in Baum TRAKKER
    LET tblkcopy&=13 ! USERDEF in Baum TRAKKER
    LET tblkdrag&=14 ! USERDEF in Baum TRAKKER
    LET tblkedit&=15 ! USERDEF in Baum TRAKKER
    LET tblksnap&=16 ! USERDEF in Baum TRAKKER
    LET tblkvol&=17 ! USERDEF in Baum TRAKKER
    LET tblkcut&=18 ! USERDEF in Baum TRAKKER
    LET trtfilel&=25 ! BOX in Baum TRAKKER
    LET trtfile&=26 ! TEXT in Baum TRAKKER
    LET trtfiler&=27 ! BOX in Baum TRAKKER
    LET trakedbx&=28 ! BOX in Baum TRAKKER
    LET trakbox2&=29 ! BOX in Baum TRAKKER
    LET trakbox5&=30 ! BOX in Baum TRAKKER
    LET trkbx1&=31 ! BOX in Baum TRAKKER
    LET trklevo1&=32 ! USERDEF in Baum TRAKKER
    LET trklevt1&=33 ! BOXTEXT in Baum TRAKKER
    LET trakk1&=34 ! BOXTEXT in Baum TRAKKER
    LET trktxt1&=35 ! BOXTEXT in Baum TRAKKER
    LET trkact1&=36 ! USERDEF in Baum TRAKKER
    LET trksolo1&=37 ! USERDEF in Baum TRAKKER
    LET trkmute1&=38 ! USERDEF in Baum TRAKKER
    LET pantxt1&=39 ! BOXTEXT in Baum TRAKKER
    LET panl1&=40 ! USERDEF in Baum TRAKKER
    LET panr1&=41 ! USERDEF in Baum TRAKKER
    LET trklevu1&=42 ! USERDEF in Baum TRAKKER
    LET trkbx2&=43 ! BOX in Baum TRAKKER
    LET trklevo2&=44 ! USERDEF in Baum TRAKKER
    LET trklevt2&=45 ! BOXTEXT in Baum TRAKKER
    LET trakk2&=46 ! BOXTEXT in Baum TRAKKER
    LET trktxt2&=47 ! BOXTEXT in Baum TRAKKER
    LET trkact2&=48 ! USERDEF in Baum TRAKKER
    LET trksolo2&=49 ! USERDEF in Baum TRAKKER
    LET trkmute2&=50 ! USERDEF in Baum TRAKKER
    LET pantxt2&=51 ! BOXTEXT in Baum TRAKKER
    LET panl2&=52 ! USERDEF in Baum TRAKKER
    LET panr2&=53 ! USERDEF in Baum TRAKKER
    LET trklevu2&=54 ! USERDEF in Baum TRAKKER
    LET trkbx4&=55 ! BOX in Baum TRAKKER
    LET trklevo4&=56 ! USERDEF in Baum TRAKKER
    LET trklevt4&=57 ! BOXTEXT in Baum TRAKKER
    LET trakk4&=58 ! BOXTEXT in Baum TRAKKER
    LET trktxt4&=59 ! BOXTEXT in Baum TRAKKER
    LET trkact4&=60 ! USERDEF in Baum TRAKKER
    LET trksolo4&=61 ! USERDEF in Baum TRAKKER
    LET trkmute4&=62 ! USERDEF in Baum TRAKKER
    LET pantxt4&=63 ! BOXTEXT in Baum TRAKKER
    LET panl4&=64 ! USERDEF in Baum TRAKKER
    LET panr4&=65 ! USERDEF in Baum TRAKKER
    LET trklevu4&=66 ! USERDEF in Baum TRAKKER
    LET trkbx3&=67 ! BOX in Baum TRAKKER
    LET trklevo3&=68 ! USERDEF in Baum TRAKKER
    LET trklevt3&=69 ! BOXTEXT in Baum TRAKKER
    LET trakk3&=70 ! BOXTEXT in Baum TRAKKER
    LET trktxt3&=71 ! BOXTEXT in Baum TRAKKER
    LET trkact3&=72 ! USERDEF in Baum TRAKKER
    LET trksolo3&=73 ! USERDEF in Baum TRAKKER
    LET trkmute3&=74 ! USERDEF in Baum TRAKKER
    LET pantxt3&=75 ! BOXTEXT in Baum TRAKKER
    LET panl3&=76 ! USERDEF in Baum TRAKKER
    LET panr3&=77 ! USERDEF in Baum TRAKKER
    LET trklevu3&=78 ! USERDEF in Baum TRAKKER
    LET trakslid&=79 ! BOX in Baum TRAKKER
    LET trakxbut&=80 ! BUTTON in Baum TRAKKER
    LET trakxl&=81 ! USERDEF in Baum TRAKKER
    LET timeline&=82 ! BOXTEXT in Baum TRAKKER
    LET trkslot&=83 ! BOXTEXT in Baum TRAKKER
    LET trktitxt&=84 ! TEXT in Baum TRAKKER
    LET spurslid&=85 ! BOX in Baum TRAKKER
    LET spurybut&=86 ! BUTTON in Baum TRAKKER
    LET zoomxr&=87 ! USERDEF in Baum TRAKKER
    LET zoomslid&=88 ! BOX in Baum TRAKKER
    LET zoomxbut&=89 ! BUTTON in Baum TRAKKER
    LET zoomxl&=90 ! USERDEF in Baum TRAKKER
    LET timelin2&=91 ! BOXTEXT in Baum TRAKKER
    LET trkslot2&=92 ! BOXTEXT in Baum TRAKKER
    LET trakxr&=93 ! USERDEF in Baum TRAKKER
    LET spuro&=94 ! USERDEF in Baum TRAKKER
    LET spuru&=95 ! USERDEF in Baum TRAKKER
    LET trakbxw&=96 ! BOX in Baum TRAKKER
    LET trakexit&=97 ! BUTTON in Baum TRAKKER
    LET trakhelp&=98 ! BOXTEXT in Baum TRAKKER
    LET trakbox4&=99 ! BOX in Baum TRAKKER
    LET traktime&=100 ! BOXTEXT in Baum TRAKKER
    LET trakname&=101 ! BOXTEXT in Baum TRAKKER
    LET trkerr&=102 ! BOXTEXT in Baum TRAKKER
    LET pause2&=104 ! USERDEF in Baum TRAKKER
    LET rewind2&=105 ! USERDEF in Baum TRAKKER
    LET stop2&=106 ! USERDEF in Baum TRAKKER
    LET recplay2&=107 ! USERDEF in Baum TRAKKER
    LET smpplay3&=108 ! USERDEF in Baum TRAKKER
    LET smprpla2&=109 ! USERDEF in Baum TRAKKER
    LET forward2&=110 ! USERDEF in Baum TRAKKER
    LET trakanf&=111 ! USERDEF in Baum TRAKKER
    LET trakfull&=112 ! USERDEF in Baum TRAKKER
    LET smpstrt4&=113 ! USERDEF in Baum TRAKKER
    LET smpauto4&=114 ! USERDEF in Baum TRAKKER
    LET trakinfo&=118 ! BOXTEXT in Baum TRAKKER
    LET trakstrt&=119 ! BOXTEXT in Baum TRAKKER
    LET trakend&=120 ! BOXTEXT in Baum TRAKKER
    LET traklen&=121 ! BOXTEXT in Baum TRAKKER
    LET trksmpte&=122 ! BOXTEXT in Baum TRAKKER
    LET strtl&=124 ! USERDEF in Baum TRAKKER
    LET strtr&=125 ! USERDEF in Baum TRAKKER
    LET lend&=126 ! USERDEF in Baum TRAKKER
    LET ltime&=127 ! USERDEF in Baum TRAKKER
    LET rend&=128 ! USERDEF in Baum TRAKKER
    LET rtime&=129 ! USERDEF in Baum TRAKKER
    LET trkblk&=130 ! USERDEF in Baum TRAKKER
    LET trkcopy&=131 ! USERDEF in Baum TRAKKER
    LET trkdel&=132 ! USERDEF in Baum TRAKKER
    LET tblkplay&=133 ! USERDEF in Baum TRAKKER
    LET trakdur&=137 ! BOXTEXT in Baum TRAKKER
    LET tnamcom&=142 ! USERDEF in Baum TRAKKER
    LET curve&=143 ! USERDEF in Baum TRAKKER
    LET trksolo&=144 ! USERDEF in Baum TRAKKER
    LET trkrvol&=146 ! BOX in Baum TRAKKER
    LET trkrmax&=147 ! BOX in Baum TRAKKER
    LET trklvol&=148 ! BOX in Baum TRAKKER
    LET trklmax&=149 ! BOX in Baum TRAKKER
    LET trkvbox&=150 ! BOXTEXT in Baum TRAKKER
    LET trkvol&=152 ! USERDEF in Baum TRAKKER
    LET tpstrt&=153 ! BOXTEXT in Baum TRAKKER
    LET tpend&=154 ! BOXTEXT in Baum TRAKKER
    LET tpsl&=156 ! USERDEF in Baum TRAKKER
    LET tpel&=157 ! USERDEF in Baum TRAKKER
    LET tpsr&=158 ! USERDEF in Baum TRAKKER
    LET tper&=159 ! USERDEF in Baum TRAKKER
    LET trakbox6&=160 ! BOX in Baum TRAKKER
    LET trk4&=161 ! BOXTEXT in Baum TRAKKER
    LET trk8&=162 ! BOXTEXT in Baum TRAKKER
    LET trk12&=163 ! BOXTEXT in Baum TRAKKER
    LET trk16&=164 ! BOXTEXT in Baum TRAKKER
    LET trkmon&=165 ! BOXTEXT in Baum TRAKKER
    LET trksize&=166 ! BOXTEXT in Baum TRAKKER
    '
    LET dspedit&=5 ! Formular/Dialog
    LET dspbox&=0 ! BOX in Baum DSPEDIT
    LET dspecho&=2 ! BUTTON in Baum DSPEDIT
    LET dsphall&=3 ! BUTTON in Baum DSPEDIT
    LET dsplow&=4 ! BUTTON in Baum DSPEDIT
    LET dsphigh&=5 ! BUTTON in Baum DSPEDIT
    LET dspband&=6 ! BUTTON in Baum DSPEDIT
    LET dspflang&=7 ! BUTTON in Baum DSPEDIT
    LET dspchor&=8 ! BUTTON in Baum DSPEDIT
    LET dspeq&=9 ! BUTTON in Baum DSPEDIT
    LET dsppink&=10 ! BUTTON in Baum DSPEDIT
    LET dsppass&=11 ! BUTTON in Baum DSPEDIT
    LET dspload&=12 ! BUTTON in Baum DSPEDIT
    LET dspsave&=13 ! BUTTON in Baum DSPEDIT
    LET helpdsp&=14 ! BOXTEXT in Baum DSPEDIT
    LET dspexit&=15 ! BUTTON in Baum DSPEDIT
    '
    LET peak&=6 ! Formular/Dialog
    LET peakbox&=0 ! BOX in Baum PEAK
    LET peaktl&=1 ! TEXT in Baum PEAK
    LET peaktr&=2 ! TEXT in Baum PEAK
    LET peakmtxt&=3 ! TEXT in Baum PEAK
    LET plmax&=4 ! BUTTON in Baum PEAK
    LET prmax&=5 ! BUTTON in Baum PEAK
    LET peakbox2&=6 ! BOX in Baum PEAK
    LET pmdb2&=7 ! TEXT in Baum PEAK
    LET pmdb3&=8 ! TEXT in Baum PEAK
    LET pmdb4&=9 ! TEXT in Baum PEAK
    LET pmdb5&=10 ! TEXT in Baum PEAK
    LET pmdb6&=11 ! TEXT in Baum PEAK
    LET pmdb7&=12 ! TEXT in Baum PEAK
    LET pmdb8&=13 ! TEXT in Baum PEAK
    LET pmdb9&=14 ! TEXT in Baum PEAK
    LET pmdb10&=15 ! TEXT in Baum PEAK
    LET pmdb1&=16 ! TEXT in Baum PEAK
    LET peakl&=17 ! USERDEF in Baum PEAK
    LET peakr&=18 ! USERDEF in Baum PEAK
    LET pmover&=19 ! TEXT in Baum PEAK
    LET peakname&=20 ! BOXTEXT in Baum PEAK
    LET pkmbox&=21 ! BOX in Baum PEAK
    LET volbox&=22 ! BOX in Baum PEAK
    LET volume&=24 ! ICON in Baum PEAK
    LET smpautop&=26 ! USERDEF in Baum PEAK
    LET smpstrtp&=27 ! USERDEF in Baum PEAK
    LET playpeak&=28 ! USERDEF in Baum PEAK
    LET recerror&=29 ! BOXTEXT in Baum PEAK
    LET balbox&=31 ! BOXTEXT in Baum PEAK
    LET balance&=33 ! ICON in Baum PEAK
    LET recpeaks&=35 ! BOXTEXT in Baum PEAK
    LET peakdb&=37 ! BOXTEXT in Baum PEAK
    LET peakbal&=38 ! BOXTEXT in Baum PEAK
    LET hardpeak&=57 ! USERDEF in Baum PEAK
    LET playstop&=58 ! USERDEF in Baum PEAK
    LET peakwait&=59 ! USERDEF in Baum PEAK
    LET volinout&=61 ! USERDEF in Baum PEAK
    LET peakch1&=62 ! BOXTEXT in Baum PEAK
    LET peakch4&=63 ! BOXTEXT in Baum PEAK
    LET peakch2&=64 ! BOXTEXT in Baum PEAK
    LET peakch3&=65 ! BOXTEXT in Baum PEAK
    LET pkmbox2&=66 ! BOX in Baum PEAK
    LET peakpos&=67 ! BOXTEXT in Baum PEAK
    LET peakmax&=68 ! BOXTEXT in Baum PEAK
    LET peakmaxt&=69 ! TEXT in Baum PEAK
    LET peakpost&=70 ! TEXT in Baum PEAK
    LET peakmute&=71 ! USERDEF in Baum PEAK
    LET balzero&=72 ! USERDEF in Baum PEAK
    LET peakhelp&=73 ! BOXTEXT in Baum PEAK
    LET peakexit&=74 ! BUTTON in Baum PEAK
    '
    LET loop&=7 ! Formular/Dialog
    LET loopbox&=0 ! BOX in Baum LOOP
    LET loopexit&=1 ! BUTTON in Baum LOOP
    LET loopbox2&=2 ! BOX in Baum LOOP
    LET forw&=3 ! BUTTON in Baum LOOP
    LET cross&=4 ! BUTTON in Baum LOOP
    LET backw&=5 ! BUTTON in Baum LOOP
    LET helploop&=7 ! BOXTEXT in Baum LOOP
    LET autoloop&=8 ! BUTTON in Baum LOOP
    '
    LET editfade&=8 ! Formular/Dialog
    LET fadebox&=0 ! BOX in Baum EDITFADE
    LET fadexit&=2 ! BUTTON in Baum EDITFADE
    LET fadelin&=4 ! BUTTON in Baum EDITFADE
    LET edfadbox&=5 ! BOX in Baum EDITFADE
    LET infade&=6 ! BUTTON in Baum EDITFADE
    LET ausfade&=7 ! BUTTON in Baum EDITFADE
    LET helpfade&=8 ! BOXTEXT in Baum EDITFADE
    LET fadexp&=9 ! BUTTON in Baum EDITFADE
    LET fadesqrt&=10 ! BUTTON in Baum EDITFADE
    LET fadeundo&=11 ! BUTTON in Baum EDITFADE
    LET fadedel&=12 ! BUTTON in Baum EDITFADE
    LET fdsquare&=13 ! BUTTON in Baum EDITFADE
    LET fadelog&=14 ! BUTTON in Baum EDITFADE
    LET fadload&=15 ! BUTTON in Baum EDITFADE
    LET fadsave&=16 ! BUTTON in Baum EDITFADE
    '
    LET blkfunc&=9 ! Formular/Dialog
    LET blkbox&=0 ! BOX in Baum BLKFUNC
    LET cutin&=1 ! USERDEF in Baum BLKFUNC
    LET cutout&=2 ! USERDEF in Baum BLKFUNC
    LET blkexit&=3 ! BUTTON in Baum BLKFUNC
    LET blkhelp&=5 ! BOXTEXT in Baum BLKFUNC
    LET cutdel&=6 ! USERDEF in Baum BLKFUNC
    LET norm&=10 ! USERDEF in Baum BLKFUNC
    LET resmp&=11 ! USERDEF in Baum BLKFUNC
    LET mono&=12 ! USERDEF in Baum BLKFUNC
    LET conmix&=13 ! USERDEF in Baum BLKFUNC
    LET conins&=14 ! USERDEF in Baum BLKFUNC
    LET conspace&=15 ! USERDEF in Baum BLKFUNC
    LET negate&=23 ! USERDEF in Baum BLKFUNC
    LET lrchange&=25 ! USERDEF in Baum BLKFUNC
    '
    LET virtual&=10 ! Formular/Dialog
    LET virtbox&=0 ! BOX in Baum VIRTUAL
    LET virthelp&=2 ! BOXTEXT in Baum VIRTUAL
    LET virtbloc&=4 ! BUTTON in Baum VIRTUAL
    LET virtok&=5 ! BUTTON in Baum VIRTUAL
    LET virtbox3&=6 ! BOX in Baum VIRTUAL
    LET vblkstrt&=7 ! FTEXT in Baum VIRTUAL
    LET vseconds&=8 ! BUTTON in Baum VIRTUAL
    LET vsamples&=9 ! BUTTON in Baum VIRTUAL
    LET vblkmlen&=10 ! BOXTEXT in Baum VIRTUAL
    LET vblkvlen&=11 ! BOXTEXT in Baum VIRTUAL
    LET vslider&=12 ! BOX in Baum VIRTUAL
    LET vslbut&=13 ! BUTTON in Baum VIRTUAL
    LET virtbox2&=14 ! BOX in Baum VIRTUAL
    LET virtwork&=15 ! BUTTON in Baum VIRTUAL
    LET virtdir&=16 ! BUTTON in Baum VIRTUAL
    LET vrslide&=17 ! USERDEF in Baum VIRTUAL
    LET vlslide&=18 ! USERDEF in Baum VIRTUAL
    LET virtno&=19 ! BUTTON in Baum VIRTUAL
    LET virtplay&=20 ! USERDEF in Baum VIRTUAL
    LET virtstop&=22 ! USERDEF in Baum VIRTUAL
    '
    LET wmode&=11 ! Formular/Dialog
    LET wmbox1&=0 ! BOX in Baum WMODE
    LET wmhelp&=1 ! BOXTEXT in Baum WMODE
    LET wmexit&=2 ! BUTTON in Baum WMODE
    LET wmbox2&=4 ! BOX in Baum WMODE
    LET mixcpu&=5 ! BUTTON in Baum WMODE
    LET mixdma&=6 ! BUTTON in Baum WMODE
    LET mixdsp&=7 ! BUTTON in Baum WMODE
    LET wmbox4&=9 ! BOX in Baum WMODE
    LET mast16&=10 ! BUTTON in Baum WMODE
    LET mast24&=11 ! BUTTON in Baum WMODE
    LET wmbox3&=13 ! BOX in Baum WMODE
    LET recm2&=14 ! BUTTON in Baum WMODE
    LET recm4&=15 ! BUTTON in Baum WMODE
    LET recm8&=16 ! BUTTON in Baum WMODE
    LET wmbox5&=18 ! BOX in Baum WMODE
    LET ramlo&=19 ! BUTTON in Baum WMODE
    LET ramhi&=20 ! BUTTON in Baum WMODE
    LET syncsrte&=23 ! FTEXT in Baum WMODE
    LET wmodebx2&=24 ! BOX in Baum WMODE
    LET synchz&=25 ! FTEXT in Baum WMODE
    LET wmodebx3&=26 ! BOX in Baum WMODE
    LET smpteset&=27 ! FTEXT in Baum WMODE
    LET syncpcg&=28 ! BUTTON in Baum WMODE
    LET syncadat&=29 ! BUTTON in Baum WMODE
    LET syncmtc&=30 ! BUTTON in Baum WMODE
    LET syncxmit&=31 ! BUTTON in Baum WMODE
    LET syncalc&=32 ! BUTTON in Baum WMODE
    LET clkfalc&=33 ! BUTTON in Baum WMODE
    LET wmbox7&=34 ! BOX in Baum WMODE
    LET frame24&=35 ! BUTTON in Baum WMODE
    LET frame25&=36 ! BUTTON in Baum WMODE
    LET frame30&=37 ! BUTTON in Baum WMODE
    '
    LET icon&=12 ! Formular/Dialog
    LET staricon&=1 ! ICON in Baum ICON
    '
    LET plugin&=13 ! Formular/Dialog
    LET panbox&=0 ! BOX in Baum PLUGIN
    LET panexit&=1 ! BUTTON in Baum PLUGIN
    LET panhelp&=2 ! BOXTEXT in Baum PLUGIN
    LET plglev1&=3 ! ICON in Baum PLUGIN
    LET plgbox1&=4 ! ICON in Baum PLUGIN
    LET plglev2&=5 ! ICON in Baum PLUGIN
    LET plgbox2&=6 ! ICON in Baum PLUGIN
    LET plglev3&=7 ! ICON in Baum PLUGIN
    LET plgbox3&=8 ! ICON in Baum PLUGIN
    LET plglev4&=9 ! ICON in Baum PLUGIN
    LET plgbox4&=10 ! ICON in Baum PLUGIN
    LET levtxt1&=11 ! BOXTEXT in Baum PLUGIN
    LET levtxt5&=12 ! BOXTEXT in Baum PLUGIN
    LET plglev5&=13 ! ICON in Baum PLUGIN
    LET plgbox5&=14 ! ICON in Baum PLUGIN
    LET levtxt3&=15 ! BOXTEXT in Baum PLUGIN
    LET levcnt1&=16 ! BOXTEXT in Baum PLUGIN
    LET levcnt2&=17 ! BOXTEXT in Baum PLUGIN
    LET levcnt3&=18 ! BOXTEXT in Baum PLUGIN
    LET levcnt4&=19 ! BOXTEXT in Baum PLUGIN
    LET levcnt5&=20 ! BOXTEXT in Baum PLUGIN
    LET plgtitel&=21 ! BOXTEXT in Baum PLUGIN
    LET levart1&=22 ! BOXTEXT in Baum PLUGIN
    LET levtxt4&=23 ! BOXTEXT in Baum PLUGIN
    LET levtxt2&=24 ! BOXTEXT in Baum PLUGIN
    LET levart2&=25 ! BOXTEXT in Baum PLUGIN
    LET levart3&=26 ! BOXTEXT in Baum PLUGIN
    LET levart4&=27 ! BOXTEXT in Baum PLUGIN
    LET levart5&=28 ! BOXTEXT in Baum PLUGIN
    LET plugct2&=29 ! BOXTEXT in Baum PLUGIN
    LET plugct3&=30 ! BOXTEXT in Baum PLUGIN
    LET plugct1&=31 ! BOXTEXT in Baum PLUGIN
    LET pluglin&=32 ! BOX in Baum PLUGIN
    '
    LET record&=14 ! Formular/Dialog
    LET recbox&=0 ! BOX in Baum RECORD
    LET recfree&=1 ! BOXTEXT in Baum RECORD
    LET recok&=2 ! BUTTON in Baum RECORD
    LET recexit&=3 ! BUTTON in Baum RECORD
    LET timemeld&=4 ! TEXT in Baum RECORD
    LET rechelp&=5 ! BOXTEXT in Baum RECORD
    LET timetxt&=9 ! FTEXT in Baum RECORD
    LET tinpul1&=12 ! USERDEF in Baum RECORD
    LET tinpul2&=14 ! USERDEF in Baum RECORD
    LET tinpul3&=15 ! USERDEF in Baum RECORD
    LET tinpul4&=16 ! USERDEF in Baum RECORD
    LET tinpuh1&=17 ! USERDEF in Baum RECORD
    LET tinpuh2&=18 ! USERDEF in Baum RECORD
    LET tinpuh3&=19 ! USERDEF in Baum RECORD
    LET tinpuh4&=20 ! USERDEF in Baum RECORD
    LET tinpdh1&=21 ! USERDEF in Baum RECORD
    LET tinpdh2&=22 ! USERDEF in Baum RECORD
    LET tinpdh3&=23 ! USERDEF in Baum RECORD
    LET tinpdh4&=24 ! USERDEF in Baum RECORD
    LET tinpdl1&=25 ! USERDEF in Baum RECORD
    LET tinpdl2&=26 ! USERDEF in Baum RECORD
    LET tinpdl3&=27 ! USERDEF in Baum RECORD
    LET tinpdl4&=28 ! USERDEF in Baum RECORD
    '
    LET savebloc&=15 ! Formular/Dialog
    LET savebox&=0 ! BOX in Baum SAVEBLOC
    LET savall&=1 ! USERDEF in Baum SAVEBLOC
    LET savblock&=2 ! USERDEF in Baum SAVEBLOC
    LET savexit&=3 ! BUTTON in Baum SAVEBLOC
    LET savetxt&=4 ! TEXT in Baum SAVEBLOC
    LET savehelp&=5 ! BOXTEXT in Baum SAVEBLOC
    '
    LET setup&=16 ! Formular/Dialog
    LET setupbox&=0 ! BOX in Baum SETUP
    LET sync&=2 ! BUTTON in Baum SETUP
    LET fseldef&=4 ! BUTTON in Baum SETUP
    LET fseltxt&=6 ! BOXTEXT in Baum SETUP
    LET setform&=8 ! BOXTEXT in Baum SETUP
    LET setfbut&=9 ! BOXCHAR in Baum SETUP
    LET seclen&=13 ! BOXTEXT in Baum SETUP
    LET secl&=14 ! BUTTON in Baum SETUP
    LET secr&=15 ! BUTTON in Baum SETUP
    LET nfsbut&=17 ! BUTTON in Baum SETUP
    LET mallmax&=20 ! BUTTON in Baum SETUP
    LET setupbx2&=21 ! BOX in Baum SETUP
    LET lenmall&=22 ! FTEXT in Baum SETUP
    LET sethelp&=23 ! BOXTEXT in Baum SETUP
    LET recm&=26 ! BOXTEXT in Baum SETUP
    LET recl&=27 ! BUTTON in Baum SETUP
    LET recr&=28 ! BUTTON in Baum SETUP
    LET tresdb&=31 ! BOXTEXT in Baum SETUP
    LET tresl&=32 ! BUTTON in Baum SETUP
    LET tresr&=33 ! BUTTON in Baum SETUP
    LET setexit&=34 ! BUTTON in Baum SETUP
    LET setsave&=35 ! BUTTON in Baum SETUP
    LET setload&=36 ! BUTTON in Baum SETUP
    LET setok&=37 ! BUTTON in Baum SETUP
    LET dreide&=38 ! BUTTON in Baum SETUP
    LET flip&=39 ! BUTTON in Baum SETUP
    LET timeset&=40 ! BUTTON in Baum SETUP
    LET setshow&=41 ! BUTTON in Baum SETUP
    LET setupbx3&=43 ! BOX in Baum SETUP
    LET vertline&=44 ! BUTTON in Baum SETUP
    LET linkdot&=45 ! BUTTON in Baum SETUP
    LET spacefil&=46 ! BUTTON in Baum SETUP
    LET zoomy&=47 ! BUTTON in Baum SETUP
    LET grid&=48 ! BUTTON in Baum SETUP
    LET posy&=49 ! BUTTON in Baum SETUP
    LET zerosnap&=50 ! BUTTON in Baum SETUP
    LET frec&=51 ! BUTTON in Baum SETUP
    LET menuset&=52 ! BUTTON in Baum SETUP
    LET freeze&=54 ! BUTTON in Baum SETUP
    LET viewset&=55 ! BUTTON in Baum SETUP
    LET emulset&=56 ! BUTTON in Baum SETUP
    '
    LET arrmname&=17 ! Formular/Dialog
    LET arrmnbox&=0 ! BOX in Baum ARRMNAME
    LET arrmnbx2&=1 ! BOX in Baum ARRMNAME
    LET memname&=2 ! FTEXT in Baum ARRMNAME
    LET amexit&=4 ! BUTTON in Baum ARRMNAME
    LET amhelp&=5 ! BOXTEXT in Baum ARRMNAME
    LET amok&=6 ! BUTTON in Baum ARRMNAME
    '
    LET moving&=18 ! Formular/Dialog
    LET movngbox&=0 ! BOX in Baum MOVING
    LET movhlp&=1 ! BOXTEXT in Baum MOVING
    LET mvcutcpy&=3 ! BUTTON in Baum MOVING
    LET mvcutins&=4 ! BUTTON in Baum MOVING
    LET mvclrins&=5 ! BUTTON in Baum MOVING
    LET mvclrcpy&=6 ! BUTTON in Baum MOVING
    LET movexit&=7 ! BUTTON in Baum MOVING
    '
    LET arrmake&=19 ! Formular/Dialog
    LET makebox&=0 ! BOX in Baum ARRMAKE
    LET maketxt&=4 ! BOXTEXT in Baum ARRMAKE
    LET makefsel&=5 ! BUTTON in Baum ARRMAKE
    LET makerate&=6 ! BOXTEXT in Baum ARRMAKE
    LET makehelp&=9 ! BOXTEXT in Baum ARRMAKE
    LET makeok&=10 ! BUTTON in Baum ARRMAKE
    LET makexit&=11 ! BUTTON in Baum ARRMAKE
    '
    LET timeed&=20 ! Formular/Dialog
    LET timebox&=0 ! BOX in Baum TIMEED
    LET timebox2&=1 ! BOX in Baum TIMEED
    LET tedtxt&=2 ! FTEXT in Baum TIMEED
    LET tedexit&=4 ! BUTTON in Baum TIMEED
    LET tedhelp&=5 ! BOXTEXT in Baum TIMEED
    LET tedok&=6 ! BUTTON in Baum TIMEED
    '
    LET abackup&=21 ! Formular/Dialog
    LET abackbox&=0 ! BOX in Baum ABACKUP
    LET abacktxt&=1 ! BOXTEXT in Baum ABACKUP
    LET abackok&=2 ! BUTTON in Baum ABACKUP
    LET abackex&=3 ! BUTTON in Baum ABACKUP
    LET abackhlp&=5 ! BOXTEXT in Baum ABACKUP
    LET abackr1&=8 ! USERDEF in Baum ABACKUP
    LET abackr2&=9 ! USERDEF in Baum ABACKUP
    LET abackl1&=10 ! USERDEF in Baum ABACKUP
    LET abackl2&=11 ! USERDEF in Baum ABACKUP
    LET abackbo2&=12 ! BOX in Baum ABACKUP
    LET aback&=13 ! BUTTON in Baum ABACKUP
    LET abacknam&=14 ! BUTTON in Baum ABACKUP
    '
    LET midiedit&=22 ! Formular/Dialog
    LET midibox&=0 ! BOX in Baum MIDIEDIT
    LET notetxt&=1 ! BOXTEXT in Baum MIDIEDIT
    LET chtxt&=3 ! BOXTEXT in Baum MIDIEDIT
    LET midiok&=5 ! BUTTON in Baum MIDIEDIT
    LET helpmidi&=7 ! BOXTEXT in Baum MIDIEDIT
    LET midinup&=10 ! USERDEF in Baum MIDIEDIT
    LET midioup&=11 ! USERDEF in Baum MIDIEDIT
    LET midindwn&=12 ! USERDEF in Baum MIDIEDIT
    LET midiodwn&=13 ! USERDEF in Baum MIDIEDIT
    LET midicup&=14 ! USERDEF in Baum MIDIEDIT
    LET midicdwn&=15 ! USERDEF in Baum MIDIEDIT
    '
    LET smpinf&=23 ! Formular/Dialog
    LET sinfbox&=0 ! BOX in Baum SMPINF
    LET sinfok&=1 ! BUTTON in Baum SMPINF
    LET sinfexit&=2 ! BUTTON in Baum SMPINF
    LET sinfhelp&=3 ! BOXTEXT in Baum SMPINF
    LET sinfname&=6 ! BOXTEXT in Baum SMPINF
    LET sinflen&=8 ! BOXTEXT in Baum SMPINF
    LET sinfrate&=10 ! BOXTEXT in Baum SMPINF
    LET sinfsus2&=15 ! BOXTEXT in Baum SMPINF
    LET sinfrel2&=16 ! BOXTEXT in Baum SMPINF
    LET sinfl5&=18 ! BOXTEXT in Baum SMPINF
    LET sinfl6&=19 ! BOXTEXT in Baum SMPINF
    LET sinfl7&=22 ! BOXTEXT in Baum SMPINF
    LET sinfl8&=23 ! BOXTEXT in Baum SMPINF
    LET sinfl1&=24 ! BOXTEXT in Baum SMPINF
    LET sinfl2&=26 ! BOXTEXT in Baum SMPINF
    LET sinfl3&=28 ! BOXTEXT in Baum SMPINF
    LET sinfl4&=30 ! BOXTEXT in Baum SMPINF
    LET sinfdate&=32 ! BOXTEXT in Baum SMPINF
    LET sinfrel1&=33 ! BOXTEXT in Baum SMPINF
    LET sinfsus1&=34 ! BOXTEXT in Baum SMPINF
    LET sinfbox2&=35 ! BOX in Baum SMPINF
    LET sinfcomm&=36 ! FTEXT in Baum SMPINF
    LET sinfsrc&=37 ! FTEXT in Baum SMPINF
    LET sinfl9&=40 ! BOXTEXT in Baum SMPINF
    LET sinfl10&=41 ! BOXTEXT in Baum SMPINF
    LET sinfl11&=42 ! BOXTEXT in Baum SMPINF
    LET sinfl12&=43 ! BOXTEXT in Baum SMPINF
    '
    LET fsel&=24 ! Formular/Dialog
    LET fselbox&=0 ! BOX in Baum FSEL
    LET fselbox2&=1 ! BOX in Baum FSEL
    LET fsbut1&=2 ! BOXTEXT in Baum FSEL
    LET fsbut2&=3 ! BOXTEXT in Baum FSEL
    LET fsbut3&=4 ! BOXTEXT in Baum FSEL
    LET fsbut4&=5 ! BOXTEXT in Baum FSEL
    LET fsbut5&=6 ! BOXTEXT in Baum FSEL
    LET fsbut6&=7 ! BOXTEXT in Baum FSEL
    LET fsbut7&=8 ! BOXTEXT in Baum FSEL
    LET fsbut8&=9 ! BOXTEXT in Baum FSEL
    LET fsbut9&=10 ! BOXTEXT in Baum FSEL
    LET fsbut10&=11 ! BOXTEXT in Baum FSEL
    LET fsbut11&=12 ! BOXTEXT in Baum FSEL
    LET fsbut12&=13 ! BOXTEXT in Baum FSEL
    LET fsbut13&=14 ! BOXTEXT in Baum FSEL
    LET fsbut14&=15 ! BOXTEXT in Baum FSEL
    LET fsbut15&=16 ! BOXTEXT in Baum FSEL
    LET fstxt1&=17 ! BOXTEXT in Baum FSEL
    LET fstxt2&=18 ! BOXTEXT in Baum FSEL
    LET fstxt3&=19 ! BOXTEXT in Baum FSEL
    LET fstxt4&=20 ! BOXTEXT in Baum FSEL
    LET fstxt5&=21 ! BOXTEXT in Baum FSEL
    LET fstxt6&=22 ! BOXTEXT in Baum FSEL
    LET fstxt7&=23 ! BOXTEXT in Baum FSEL
    LET fstxt8&=24 ! BOXTEXT in Baum FSEL
    LET fstxt9&=25 ! BOXTEXT in Baum FSEL
    LET fstxt10&=26 ! BOXTEXT in Baum FSEL
    LET fstxt11&=27 ! BOXTEXT in Baum FSEL
    LET fstxt12&=28 ! BOXTEXT in Baum FSEL
    LET fstxt13&=29 ! BOXTEXT in Baum FSEL
    LET fstxt14&=30 ! BOXTEXT in Baum FSEL
    LET fstxt15&=31 ! BOXTEXT in Baum FSEL
    LET fsslide&=32 ! BOX in Baum FSEL
    LET fssldbut&=33 ! BUTTON in Baum FSEL
    LET fsok&=34 ! BUTTON in Baum FSEL
    LET fshelp&=35 ! BOXTEXT in Baum FSEL
    LET fsplay&=36 ! USERDEF in Baum FSEL
    LET fsexit&=37 ! BUTTON in Baum FSEL
    LET fsordner&=39 ! BUTTON in Baum FSEL
    LET fsotxt&=40 ! BOXTEXT in Baum FSEL
    LET fsmatic&=41 ! USERDEF in Baum FSEL
    LET fsins&=42 ! USERDEF in Baum FSEL
    LET fsdel&=43 ! USERDEF in Baum FSEL
    LET fsadd&=44 ! BUTTON in Baum FSEL
    LET fsnew&=45 ! BUTTON in Baum FSEL
    LET fsload&=46 ! USERDEF in Baum FSEL
    LET fssave&=47 ! USERDEF in Baum FSEL
    LET fsclf&=48 ! USERDEF in Baum FSEL
    LET fssldup&=49 ! USERDEF in Baum FSEL
    LET fsslddwn&=50 ! USERDEF in Baum FSEL
    LET fsstop&=51 ! USERDEF in Baum FSEL
    LET fswait&=52 ! USERDEF in Baum FSEL
    LET fsend&=53 ! USERDEF in Baum FSEL
    LET fstime&=54 ! BOXTEXT in Baum FSEL
    LET fslplay&=55 ! USERDEF in Baum FSEL
    LET tfsabc&=56 ! USERDEF in Baum FSEL
    LET tfsearch&=57 ! BUTTON in Baum FSEL
    '
    LET meldung&=25 ! Formular/Dialog
    LET meldbox&=0 ! BOX in Baum MELDUNG
    LET meldtxt&=1 ! BOXTEXT in Baum MELDUNG
    '
    LET trknamin&=26 ! Formular/Dialog
    LET trktxbox&=0 ! BOX in Baum TRKNAMIN
    LET trktxbo2&=1 ! BOX in Baum TRKNAMIN
    LET trktxtin&=2 ! FTEXT in Baum TRKNAMIN
    LET trktxex&=4 ! BUTTON in Baum TRKNAMIN
    LET trktxhlp&=5 ! BOXTEXT in Baum TRKNAMIN
    LET trktxok&=6 ! BUTTON in Baum TRKNAMIN
    '
    LET trkcomin&=27 ! Formular/Dialog
    LET trkcbox&=0 ! BOX in Baum TRKCOMIN
    LET trkcbox2&=1 ! BOX in Baum TRKCOMIN
    LET trkctxin&=2 ! FTEXT in Baum TRKCOMIN
    LET trkcexit&=4 ! BUTTON in Baum TRKCOMIN
    LET trkchlp&=5 ! BOXTEXT in Baum TRKCOMIN
    LET trkcok&=6 ! BUTTON in Baum TRKCOMIN
    '
    LET mrktxtin&=28 ! Formular/Dialog
    LET mtexbox&=0 ! BOX in Baum MRKTXTIN
    LET mtexbox2&=1 ! BOX in Baum MRKTXTIN
    LET mtex&=2 ! FTEXT in Baum MRKTXTIN
    LET mtexex&=4 ! BUTTON in Baum MRKTXTIN
    LET mtexhelp&=5 ! BOXTEXT in Baum MRKTXTIN
    LET mtexok&=6 ! BUTTON in Baum MRKTXTIN
    '
    LET normaliz&=29 ! Formular/Dialog
    LET normbox&=0 ! BOX in Baum NORMALIZ
    LET normok&=2 ! BUTTON in Baum NORMALIZ
    LET normexit&=3 ! BUTTON in Baum NORMALIZ
    LET maxdb&=4 ! BOXTEXT in Baum NORMALIZ
    LET normbox2&=6 ! BOX in Baum NORMALIZ
    LET normauto&=7 ! BUTTON in Baum NORMALIZ
    LET normadj&=8 ! BUTTON in Baum NORMALIZ
    LET normbox3&=9 ! BOX in Baum NORMALIZ
    LET norml1&=10 ! USERDEF in Baum NORMALIZ
    LET norml2&=11 ! USERDEF in Baum NORMALIZ
    LET norml3&=12 ! USERDEF in Baum NORMALIZ
    LET normr1&=13 ! USERDEF in Baum NORMALIZ
    LET normr2&=14 ! USERDEF in Baum NORMALIZ
    LET normr3&=15 ! USERDEF in Baum NORMALIZ
    LET helpnorm&=16 ! BOXTEXT in Baum NORMALIZ
    LET normdb&=18 ! BOXTEXT in Baum NORMALIZ
    '
    LET resample&=30 ! Formular/Dialog
    LET resmpbox&=0 ! BOX in Baum RESAMPLE
    LET adjresmp&=1 ! BUTTON in Baum RESAMPLE
    LET helprsmp&=2 ! BOXTEXT in Baum RESAMPLE
    LET rsmptxt1&=3 ! TEXT in Baum RESAMPLE
    LET resmpbx2&=4 ! BOX in Baum RESAMPLE
    LET restxt&=5 ! FTEXT in Baum RESAMPLE
    LET resmpsec&=6 ! BOXTEXT in Baum RESAMPLE
    LET resmplen&=7 ! BOXTEXT in Baum RESAMPLE
    LET resmpfac&=8 ! BOXTEXT in Baum RESAMPLE
    LET rsmptxt2&=10 ! TEXT in Baum RESAMPLE
    LET resother&=11 ! BOXTEXT in Baum RESAMPLE
    LET resok&=12 ! BUTTON in Baum RESAMPLE
    LET resexit&=13 ! BUTTON in Baum RESAMPLE
    LET res32&=15 ! BUTTON in Baum RESAMPLE
    LET res44&=16 ! BUTTON in Baum RESAMPLE
    LET res48&=17 ! BUTTON in Baum RESAMPLE
    LET resr3&=18 ! USERDEF in Baum RESAMPLE
    LET resr2&=19 ! USERDEF in Baum RESAMPLE
    LET resr1&=20 ! USERDEF in Baum RESAMPLE
    LET resl1&=21 ! USERDEF in Baum RESAMPLE
    LET resl2&=22 ! USERDEF in Baum RESAMPLE
    LET resl3&=23 ! USERDEF in Baum RESAMPLE
    '
    LET mrkfind&=31 ! Formular/Dialog
    LET mrkfbox&=0 ! BOX in Baum MRKFIND
    LET mrkfex&=2 ! BUTTON in Baum MRKFIND
    LET mrkfhelp&=3 ! BOXTEXT in Baum MRKFIND
    LET mrkfok&=4 ! BUTTON in Baum MRKFIND
    LET mrkfbox2&=6 ! BOX in Baum MRKFIND
    LET mrkftims&=7 ! BOXTEXT in Baum MRKFIND
    LET mrkftime&=8 ! BOXTEXT in Baum MRKFIND
    LET mrkfdown&=9 ! USERDEF in Baum MRKFIND
    LET mrkfslid&=10 ! BOX in Baum MRKFIND
    LET mrkfbut&=11 ! BUTTON in Baum MRKFIND
    LET mrkfup&=12 ! USERDEF in Baum MRKFIND
    LET mrkfnr&=13 ! BOXTEXT in Baum MRKFIND
    LET mrkftimi&=14 ! BOXTEXT in Baum MRKFIND
    LET mrkftimr&=15 ! BOXTEXT in Baum MRKFIND
    LET mrkftxt&=16 ! BOXTEXT in Baum MRKFIND
    LET mrkfbox3&=17 ! BOX in Baum MRKFIND
    LET mrkfbuts&=18 ! USERDEF in Baum MRKFIND
    LET mrkfbute&=19 ! USERDEF in Baum MRKFIND
    LET mrkfbuti&=20 ! USERDEF in Baum MRKFIND
    LET mrkfbutr&=21 ! USERDEF in Baum MRKFIND
    '
    LET disked&=32 ! Formular/Dialog
    LET dskedbox&=0 ! BOX in Baum DISKED
    LET dskedex&=1 ! BUTTON in Baum DISKED
    LET dskedhlp&=2 ! BOXTEXT in Baum DISKED
    LET dskedbx4&=4 ! BOX in Baum DISKED
    LET dskedbx2&=5 ! BOX in Baum DISKED
    LET dskedit&=6 ! FTEXT in Baum DISKED
    LET dskren&=8 ! USERDEF in Baum DISKED
    LET dskopie&=9 ! USERDEF in Baum DISKED
    LET dskedbx3&=10 ! BOX in Baum DISKED
    LET dskedtxt&=11 ! BOXTEXT in Baum DISKED
    LET dskill&=13 ! USERDEF in Baum DISKED
    '
    LET clocks&=33 ! Formular/Dialog
    LET clkbox&=0 ! BOX in Baum CLOCKS
    LET clockex&=2 ! BUTTON in Baum CLOCKS
    LET clockhlp&=3 ! BOXTEXT in Baum CLOCKS
    LET clockok&=4 ! BUTTON in Baum CLOCKS
    LET clkbox2&=6 ! BOX in Baum CLOCKS
    LET clock1&=7 ! BOXTEXT in Baum CLOCKS
    LET clock2&=8 ! BOXTEXT in Baum CLOCKS
    LET clkdown&=9 ! USERDEF in Baum CLOCKS
    LET clkslid&=10 ! BOX in Baum CLOCKS
    LET clkbut&=11 ! BUTTON in Baum CLOCKS
    LET clkup&=12 ! USERDEF in Baum CLOCKS
    LET clock3&=13 ! BOXTEXT in Baum CLOCKS
    LET clock4&=14 ! BOXTEXT in Baum CLOCKS
    LET clock5&=15 ! BOXTEXT in Baum CLOCKS
    LET clockm&=16 ! BOXTEXT in Baum CLOCKS
    '
    LET marknumb&=34 ! Formular/Dialog
    LET mnumbox&=0 ! BOX in Baum MARKNUMB
    LET mnumbox2&=1 ! BOX in Baum MARKNUMB
    LET mnumtxt&=2 ! FTEXT in Baum MARKNUMB
    LET mnumexit&=4 ! BUTTON in Baum MARKNUMB
    LET mnumhelp&=5 ! BOXTEXT in Baum MARKNUMB
    LET mnumok&=6 ! BUTTON in Baum MARKNUMB
    '
    LET plgconfg&=35 ! Formular/Dialog
    LET pcfgbox&=0 ! BOX in Baum PLGCONFG
    LET pcfgexit&=1 ! BUTTON in Baum PLGCONFG
    LET pcfghelp&=2 ! BOXTEXT in Baum PLGCONFG
    LET plgrec1&=3 ! BOXTEXT in Baum PLGCONFG
    LET pcfgtex1&=4 ! BOXTEXT in Baum PLGCONFG
    LET plgrec2&=5 ! BOXTEXT in Baum PLGCONFG
    LET plgrec3&=6 ! BOXTEXT in Baum PLGCONFG
    LET plgrec4&=7 ! BOXTEXT in Baum PLGCONFG
    LET plgplay1&=8 ! BOXTEXT in Baum PLGCONFG
    LET plgplay2&=9 ! BOXTEXT in Baum PLGCONFG
    LET plgplay3&=10 ! BOXTEXT in Baum PLGCONFG
    LET plgplay4&=11 ! BOXTEXT in Baum PLGCONFG
    LET pcfgtex2&=12 ! BOXTEXT in Baum PLGCONFG
    LET pcfgtex3&=13 ! BOXTEXT in Baum PLGCONFG
    LET pcfgld&=14 ! BUTTON in Baum PLGCONFG
    LET pcfgsve&=15 ! BUTTON in Baum PLGCONFG
    LET pcfgclr&=16 ! BUTTON in Baum PLGCONFG
    LET plgcfg1&=18 ! BOXTEXT in Baum PLGCONFG
    LET plgcfg2&=19 ! BOXTEXT in Baum PLGCONFG
    LET plgcfg3&=20 ! BOXTEXT in Baum PLGCONFG
    LET plgcfg4&=21 ! BOXTEXT in Baum PLGCONFG
    LET plgcfg5&=22 ! BOXTEXT in Baum PLGCONFG
    LET plgcfg6&=23 ! BOXTEXT in Baum PLGCONFG
    LET plgcfg7&=24 ! BOXTEXT in Baum PLGCONFG
    LET plgcfg8&=25 ! BOXTEXT in Baum PLGCONFG
    LET plgcfg9&=26 ! BOXTEXT in Baum PLGCONFG
    LET plgcfg10&=27 ! BOXTEXT in Baum PLGCONFG
    LET plgrec5&=28 ! BOXTEXT in Baum PLGCONFG
    LET plgplay5&=29 ! BOXTEXT in Baum PLGCONFG
    LET plgrec&=30 ! BUTTON in Baum PLGCONFG
    LET plgplay&=31 ! BUTTON in Baum PLGCONFG
    '
    LET popups&=36 ! Formular/Dialog
    LET smppopup&=1 ! BOX in Baum POPUPS
    LET rate32&=2 ! STRING in Baum POPUPS
    LET rate44&=3 ! STRING in Baum POPUPS
    LET rate48&=4 ! STRING in Baum POPUPS
    LET rate88&=5 ! STRING in Baum POPUPS
    LET rate96&=6 ! STRING in Baum POPUPS
    LET rate8&=7 ! STRING in Baum POPUPS
    LET rate11&=8 ! STRING in Baum POPUPS
    LET rate12&=9 ! STRING in Baum POPUPS
    LET rate16&=10 ! STRING in Baum POPUPS
    LET rate17&=11 ! STRING in Baum POPUPS
    LET rate22&=12 ! STRING in Baum POPUPS
    LET rate24&=13 ! STRING in Baum POPUPS
    LET rate33&=14 ! STRING in Baum POPUPS
    LET ratexth2&=15 ! STRING in Baum POPUPS
    LET ratextl2&=16 ! STRING in Baum POPUPS
    LET ratexth1&=17 ! STRING in Baum POPUPS
    LET ratextl1&=18 ! STRING in Baum POPUPS
    LET ratediv&=19 ! STRING in Baum POPUPS
    LET dsppopup&=20 ! BOX in Baum POPUPS
    LET dspoff&=21 ! STRING in Baum POPUPS
    LET dspin&=22 ! STRING in Baum POPUPS
    LET dspout&=23 ! STRING in Baum POPUPS
    LET smppop2&=24 ! BOX in Baum POPUPS
    LET ad32&=25 ! STRING in Baum POPUPS
    LET ad44&=26 ! STRING in Baum POPUPS
    LET ad48&=27 ! STRING in Baum POPUPS
    LET ad88&=28 ! STRING in Baum POPUPS
    LET ad96&=29 ! STRING in Baum POPUPS
    LET ad8&=30 ! STRING in Baum POPUPS
    LET ad11&=31 ! STRING in Baum POPUPS
    LET ad12&=32 ! STRING in Baum POPUPS
    LET ad16&=33 ! STRING in Baum POPUPS
    LET ad17&=34 ! STRING in Baum POPUPS
    LET ad22&=35 ! STRING in Baum POPUPS
    LET ad24&=36 ! STRING in Baum POPUPS
    LET ad33&=37 ! STRING in Baum POPUPS
    LET adexth2&=38 ! STRING in Baum POPUPS
    LET adextl2&=39 ! STRING in Baum POPUPS
    LET adexth1&=40 ! STRING in Baum POPUPS
    LET adextl1&=41 ! STRING in Baum POPUPS
    LET addiv&=42 ! STRING in Baum POPUPS
    LET inpop&=43 ! BOX in Baum POPUPS
    LET analog&=44 ! STRING in Baum POPUPS
    LET digital&=45 ! STRING in Baum POPUPS
    LET srcpop&=46 ! BOX in Baum POPUPS
    LET opto&=47 ! STRING in Baum POPUPS
    LET coax&=48 ! STRING in Baum POPUPS
    LET aesebu&=49 ! STRING in Baum POPUPS
    LET popmark&=50 ! BOX in Baum POPUPS
    LET smpmark&=51 ! STRING in Baum POPUPS
    LET smpzoom&=52 ! STRING in Baum POPUPS
    LET smpscrol&=53 ! STRING in Baum POPUPS
    LET kopy&=54 ! STRING in Baum POPUPS
    LET move&=55 ! STRING in Baum POPUPS
    LET insert&=56 ! STRING in Baum POPUPS
    LET merge&=57 ! STRING in Baum POPUPS
    LET fade&=58 ! STRING in Baum POPUPS
    LET popmake&=59 ! BOX in Baum POPUPS
    LET make32&=60 ! STRING in Baum POPUPS
    LET make44&=61 ! STRING in Baum POPUPS
    LET make48&=62 ! STRING in Baum POPUPS
    LET make88&=63 ! STRING in Baum POPUPS
    LET make96&=64 ! STRING in Baum POPUPS
    LET popform&=65 ! BOX in Baum POPUPS
    LET sets16&=66 ! STRING in Baum POPUPS
    LET setwav&=67 ! STRING in Baum POPUPS
    LET setavr&=68 ! STRING in Baum POPUPS
    LET setaif&=69 ! STRING in Baum POPUPS
    LET setsnd&=70 ! STRING in Baum POPUPS
    LET setsd&=71 ! STRING in Baum POPUPS
    LET setau&=72 ! STRING in Baum POPUPS
    LET setsmp&=73 ! STRING in Baum POPUPS
    LET setall&=74 ! STRING in Baum POPUPS
    LET popscms&=75 ! BOX in Baum POPUPS
    LET scmsno&=76 ! STRING in Baum POPUPS
    LET scmsone&=77 ! STRING in Baum POPUPS
    LET scmsfree&=78 ! STRING in Baum POPUPS
    LET modepop&=79 ! BOX in Baum POPUPS
    LET consumer&=80 ! STRING in Baum POPUPS
    LET profess&=81 ! STRING in Baum POPUPS
    LET emphpop&=82 ! BOX in Baum POPUPS
    LET emphoff&=83 ! STRING in Baum POPUPS
    LET emphon&=84 ! STRING in Baum POPUPS
    '
    LET dropdown&=37 ! Menuebaum
    LET ddstar&=3 ! TITLE in Baum DROPDOWN
    LET dddat&=4 ! TITLE in Baum DROPDOWN
    LET ddwind&=5 ! TITLE in Baum DROPDOWN
    LET ddfunc&=6 ! TITLE in Baum DROPDOWN
    LET ddplugin&=7 ! TITLE in Baum DROPDOWN
    LET ddinfo&=10 ! STRING in Baum DROPDOWN
    LET ddload&=19 ! STRING in Baum DROPDOWN
    LET ddsave&=20 ! STRING in Baum DROPDOWN
    LET ddexit&=21 ! STRING in Baum DROPDOWN
    LET ddsmp16&=23 ! STRING in Baum DROPDOWN
    LET ddblock&=24 ! STRING in Baum DROPDOWN
    LET ddpeak&=25 ! STRING in Baum DROPDOWN
    LET ddarr&=26 ! STRING in Baum DROPDOWN
    LET ddtrakk&=27 ! STRING in Baum DROPDOWN
    LET ddloop&=28 ! STRING in Baum DROPDOWN
    LET dddsp&=29 ! STRING in Baum DROPDOWN
    LET ddworkm&=30 ! STRING in Baum DROPDOWN
    LET ddsetup&=32 ! STRING in Baum DROPDOWN
    LET ddfader&=33 ! STRING in Baum DROPDOWN
    LET ddmidi&=34 ! STRING in Baum DROPDOWN
    LET ddbank&=35 ! STRING in Baum DROPDOWN
    LET ddmon&=37 ! STRING in Baum DROPDOWN
    LET ddauto&=38 ! STRING in Baum DROPDOWN
    LET ddmanu&=39 ! STRING in Baum DROPDOWN
    LET ddplay&=40 ! STRING in Baum DROPDOWN
    LET ddhost&=42 ! STRING in Baum DROPDOWN
    LET ddmix&=43 ! STRING in Baum DROPDOWN
    LET ddplug1&=45 ! STRING in Baum DROPDOWN
    LET ddplug2&=46 ! STRING in Baum DROPDOWN
    LET ddplug3&=47 ! STRING in Baum DROPDOWN
    LET ddplug4&=48 ! STRING in Baum DROPDOWN
    LET ddplug5&=49 ! STRING in Baum DROPDOWN
    LET ddplug6&=50 ! STRING in Baum DROPDOWN
    LET ddplug7&=51 ! STRING in Baum DROPDOWN
    LET ddplug8&=52 ! STRING in Baum DROPDOWN
    LET ddplug9&=53 ! STRING in Baum DROPDOWN
    LET ddplug10&=54 ! STRING in Baum DROPDOWN
    LET ddconv&=56 ! STRING in Baum DROPDOWN
    LET ddmodld&=57 ! STRING in Baum DROPDOWN
    LET ddmodkil&=58 ! STRING in Baum DROPDOWN
    LET ddplgcfg&=60 ! STRING in Baum DROPDOWN
    '
    LET alertbox&=38 ! Formular/Dialog
    LET alertcol&=0 ! BOX in Baum ALERTBOX
    '
    LET inftxt&=39 ! Formular/Dialog
    LET infbox&=0 ! BOX in Baum INFTXT
    LET infbox2&=1 ! BOX in Baum INFTXT
    LET inftitel&=2 ! BUTTON in Baum INFTXT
  ENDIF
ENDIF
'
OPTION BASE 0
IF compile=FALSE THEN
  RESERVE 1000000
ENDIF
'
maxcol=WORK_OUT(13)
IF smalluse=TRUE THEN
  maxcol=2
ENDIF
'
IF acc=TRUE THEN
  ap_id&=APPL_INIT()
  IF ap_id&
    me_id&=MENU_REGISTER(ap_id&,"  StarTrack")
    DO
      ~EVNT_MESAG(0)
      IF MENU(1)=40
        accx=TRUE
        GOTO start
      ende:
      ENDIF
    LOOP
  ENDIF
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------AUFLôSUNG ERFRAGEN------------------------------------
' ------------------------------------------------------------------------------
start:
IF xwidth<640 OR ywidth<400 THEN
  @alerts(1)
  IF accx=FALSE THEN
    END
  ELSE
    GOTO ende
  ENDIF
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------RSC LADEN---------------------------------------------
' ------------------------------------------------------------------------------
DEFMOUSE 0
KEYPAD 0                    ! wg KompatibilitÑt (normale Tastatureinstellung)
'
IF compile=TRUE THEN
  lfw$=CHR$(GEMDOS(25)+65)+":"+DIR$(0)+"\"       ! funktioniert als COMPILAT !
ELSE
  lfw$="D:\"
ENDIF
IF accx=TRUE THEN
  lfw$="C:\"
ENDIF
s$=lfw$
lng$=s$+"LANGUAGE.TXT"      ! Name des Fehlerfiles
nonstop$=s$+"NONSTOP.S16"   ! Name des Info-Sounds
setup$=s$+"STARTRK.SET"     ! Name des Setup-Files
fsel$=s$+"STARTRK.SEL"      ! Name des Fileselector-Files
arrup$=s$+"STARTRK.ARR"     ! Name des Arrange-Files
fade$=s$+"STARTRK.FAD"      ! Name des Fader-Files
virt2$=s$+"STARTRK.FIX"     ! Name des Files zur Rettung von Marken/Loop/Midi/Block bei Wechsel zu virt. Bearbeitung
virt$=s$+"STARTRK.VIR"      ! Name des virtuellen Files fÅr Backup-Zwecke (Backup des Speicherinhalts)
aback2$=s$+"BACKUP.ARR"     ! Name des Backup-Arrange-files
inf$="INF"                  ! Extender fÅr INF-File
mbox$="BOX"                 ! Extender fÅr Musicbox-files
trkf$="TRK"                 ! Extender fÅr Tracker-Files
peak$="PBF"                 ! Extender fÅr Peakwerte-Files
plug$="PLG"                 ! Extender fÅr Plugins
plgcext$="PCG"              ! Extender fÅr Plugin-Configs
plgconf$="STARTRK.PCG"      ! Name des Plugin Configfiles fÅr Autoload
IF smalluse=TRUE THEN
  rsc$="STARLMON.RSC"        ! Name des kleinen,monochromen RSC-Files
ELSE
  IF bigfoot=FALSE THEN
    rsc$="STARLOW.RSC"        ! Name des kleinen Farb- und Mono RSC-Files
  ELSE
    rsc$="PANY2.RSC"       ! Name des groûen Farb- und Mono RSC-Files
  ENDIF
ENDIF
'
'
btree=alertbox&                    ! Anzahl der BÑume-1
DIM rx(btree)
DIM ry(btree)
DIM rb(btree)
DIM rh(btree)
alertflag=FALSE
@alertload
IF alertflag=FALSE THEN
  ALERT 1,"No Languagefile found !",1,"EXIT",g
  IF accx=FALSE THEN
    END
  ELSE
    GOTO ende
  ENDIF
ENDIF
@setload
IF ext$="S16" OR ext$="S24" THEN
  IF dig24=FALSE THEN
    ext$="S16"
  ELSE
    ext$="S24"
  ENDIF
ENDIF
ext2$=ext$
IF ext2$="*" THEN
  IF dig24=FALSE THEN
    ext2$="S16"
  ELSE
    ext2$="S24"
  ENDIF
ENDIF
virtfile$="VIRTWORK."+ext2$ ! Name des Files fÅr virtuelle Bearbeitung von StÅcken, die lÑnger als Speicherplatz sind
workfile$="WORK."+ext2$     ! Name des Files, zur Auslagerung beim öbergang mem->virt, wenn ein StÅck grîûer als Speicher wird
aback$="BACKUP."+ext2$       ! Name des Backup-Samplefiles
@rsc_init
'
init_xrsrc(s$+"XRSRC.OVL",TRUE) ! TRUE: wir brauchen die XRSRC-Routinen,
'                              weil die RSC im langen Format vorliegt und
'                              Farbicons verwendet werden (siehe Kommentar
'                              bei xrsrc_load())
'
IF rsc_mtsk!=TRUE THEN
  ~MENU_REGISTER(ap_id&,"  VME_SMP16")
ENDIF
'
mtype=INT(C:rsc_cookie%(L:CVL("_MCH"))/&H10000)          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
magicmac=INT(C:rsc_cookie%(L:CVL("MgMc")))          ! COOKIE-ABFRAGE MagicMac
magix=INT(C:rsc_cookie%(L:CVL("MagX")))          ! COOKIE-ABFRAGE MagiC
pci=INT(C:rsc_cookie%(L:CVL("_PCI")))          ! COOKIE-ABFRAGE PCI
mch=INT(C:rsc_cookie%(L:CVL("_MCH")))          ! COOKIE-ABFRAGE PCI
snd=INT(C:rsc_cookie%(L:CVL("_SND")))          ! COOKIE-ABFRAGE PCI
vdo=INT(C:rsc_cookie%(L:CVL("_VDO")))          ! COOKIE-ABFRAGE PCI
cpu=INT(C:rsc_cookie%(L:CVL("_CPU")))          ! COOKIE-ABFRAGE PCI
falcon=FALSE
IF mtype=2 THEN
  vme=&HFEFF0000
ELSE
  vme=&HDF0000
ENDIF
adr=vme+&H401
starint=adr+&H280
s$=lfw$
IF EXIST(s$+rsc$)=FALSE THEN
  IF EXIST("C:\"+rsc$)=TRUE THEN
    s$="C:\"
  ENDIF
ENDIF
IF XBIOS(xbs,1)<>&H71273800 THEN
  @treiberload
ENDIF
IF (XBIOS(103)=3 AND snd=&H1F AND mch=&H30000 AND vdo=&H30000 AND XBIOS(xbs,10)=0) OR magicmac<>0 OR falconda=TRUE THEN
  falcon=TRUE
  demo=TRUE
ELSE
  IF XBIOS(xbs,10)=0 THEN
    demo=TRUE
  ENDIF
ENDIF
IF falcon=TRUE THEN
  ~XBIOS(&H84,1)
  ~XBIOS(&H85,0,0)
  ~XBIOS(&H86,0)
  ~XBIOS(&H89,1,1)
  ~XBIOS(&H82,4,2)
  ~XBIOS(&H82,5,0)
  ~XBIOS(&H8B,3,8+4,0,1,1)
ENDIF
IF demo=FALSE THEN
  IF XBIOS(xbs,1)=&H71273800 THEN
    IF demo=FALSE THEN
      dspadr=LPEEK(XBIOS(xbs,13)+12)  ! DSP-Startadresse
    ELSE
      dspadr=0
    ENDIF
    IF BTST(XBIOS(xbs,12),5)=TRUE THEN
      dspda=TRUE
    ELSE
      dspda=FALSE
    ENDIF
  ENDIF
ENDIF
IF EXIST(s$+rsc$) THEN
  IF menuda=FALSE THEN
    mensa=-1
    m=@rsc_laden(s$+rsc$,btree,popups&,mensa,btree)  ! File$,Trees,Popup,Menu,Alert
  ELSE
    mensa=dropdown&
    m=@rsc_laden(s$+rsc$,btree,popups&,mensa,btree)  ! File$,Trees,Popup,Menu,Alert
  ENDIF
ELSE
  m=FALSE
ENDIF
rscda=FALSE
IF m=TRUE THEN ! File$,Trees,Popup,Menu,Alert
  rscda=TRUE
  @language
  @calc_windows
  @change_colors
ELSE
  rscda=FALSE
ENDIF
IF rscda=TRUE THEN
  @smpedit
  IF accx=FALSE THEN
    END
  ELSE
    GOTO ende
  ENDIF
ELSE
  @alerts(2)
  GEMSYS 109                                        ! Nur ab GEM 1.04!
  @goodbye
  IF accx=TRUE THEN
    GOTO ende
  ENDIF
ENDIF
IF away=TRUE THEN
  @alerts(3)
  IF accx=FALSE THEN
    END
  ELSE
    GOTO ende
  ENDIF
ENDIF
IF accx=FALSE THEN
  END
ELSE
  GOTO ende
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------PROZEDUREN--------------------------------------------
' ------------------------------------------------------------------------------
'                 HardwareabhÑngiger Teil - Adressenzuordnung
' ------------------------------------------------------------------------------
'
'  - Neues Flag bei WIND_CREATE:
'  0x4000 fÅr SMALLER  (muû gesetzt werden)
'  - Neue Messages (z.B. bei EVNT_MULTI ):
'  #34 fÅr ICONIFY (Parameter enthalten die Fensterposition)
'  #35 fÅr UNICONIFY (Parameter enthalten die Fensterposition)
'  #36 fÅr ALLICONIFY (alle Fenster sollen iconifiziert werden)
'  - Neue WIND_GET/SET Aufrufe:
'  #26 fÅr WIND_ICONIFY (Wird nach erhalt der Message #34/#37 aufgerufen)
'  #27 fÅr WIND_UNICONIFY (Wird nach erhalt der Message #36 aufgerufen)
'  NÑheres siehe Beispiellisting. Es wird ein Fenster geîffnet und
'  anschlieûend ist es mîglich dieses Fenster zu iconifizieren bzw. wieder zu
'  uniconifizieren. Ist vieleicht nicht das beste Listing, sollte aber
'  ausreichen :-)
'  *************************** Beispiel-Listing ****************************
'
' Kreieren des Fensters (Iconify, Bewegungsbalken, Closer, Titel)
'
IF handle&>0
  '
  ende!=FALSE
  REPEAT
    '
    ' Event-Abfrage (Nur Timer und Messages)
    event&=EVNT_MULTI(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,buffer_adr%,200)
    '
    ' Ist eine Message gemeldet worden
    IF BTST(event&,4)
      SELECT buffer&(0)
      CASE 20                                           !Fenster redraw
        '
        ' Abarbeiten der Rechtecklisten
        ~WIND_GET(handle&,11,rx&,ry&,rw&,rh&)
        WHILE rw&>0 AND rh&>0
          '
          ' Nur mit einer PBOX lîschen
          PBOX rx&,ry&,rx&+rw&-1,ry&+rh&-1
          ~WIND_GET(handle&,12,rx&,ry&,rw&,rh&)
        WEND
      CASE 22                                           !Schlieûfeld betÑtigt
        ende!=TRUE
      CASE 28                                           !Fenster verschieben
        ~WIND_SET(handle&,5,buffer&(4),buffer&(5),buffer&(6),buffer&(7))
      CASE 34                                           !Iconify
        ~WIND_SET(handle&,26,buffer&(4),buffer&(5),buffer&(6),buffer&(7))
      CASE 35                                           !UnIconify
        ~WIND_SET(handle&,27,buffer&(4),buffer&(5),buffer&(6),buffer&(7))
      CASE 36                                           !AllIconify
        ~WIND_SET(handle&,26,buffer&(4),buffer&(5),buffer&(6),buffer&(7))
      ENDSELECT
    ENDIF
    '
  UNTIL ende!
  '
  ' Schlieûen und Entfernen des Fensters
  ~WIND_CLOSE(handle&)
  ~WIND_DELETE(handle&)
ENDIF
'
'
> PROCEDURE kickstart
  IF demo=FALSE THEN
    @fifodel
    '  ~XBIOS(xbs,62)            ! Kickstart
  ENDIF
RETURN
'
> PROCEDURE write_int(a)
  LOCAL b
  IF a<>0 THEN
    intactive=TRUE
  ELSE
    intactive=FALSE
  ENDIF
  IF demo=FALSE THEN
    IF a>0 THEN
      intnr=a
    ENDIF
    IF falcon=FALSE THEN
      ~XBIOS(xbs,54,a)
      IF a=0 THEN
        ~XBIOS(xbs,55,0)
      ENDIF
    ELSE
      b=0
      IF a=1 OR a=3 THEN
        b=b+1
      ENDIF
      IF a=2 OR a=3 THEN
        b=b+4
      ENDIF
      ~XBIOS(&H88,b)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE digerrorcode
  .| Glob. Var.: demo#,rwert#,adr#
  .| Aufruf in : edhandler-2,
  IF demo=FALSE THEN
    rwert=XBIOS(xbs,42)
  ELSE
    rwert=7
  ENDIF
RETURN
'
> PROCEDURE digstatcode
  IF demo=FALSE THEN
    rwert=XBIOS(xbs,41)
  ELSE
    rwert=15
  ENDIF
RETURN
'
> PROCEDURE read_smp
  .| Glob. Var.: demo#,rwert#,adr#
  .| Aufruf in : peakwert-5,
  IF demo=FALSE THEN
    rwert=XBIOS(xbs,52)
  ENDIF
RETURN
'
> PROCEDURE write_smp(a)
  IF demo=FALSE THEN
    ~XBIOS(xbs,53,a)
  ENDIF
RETURN
'
> PROCEDURE read_digsrate
  IF demo=FALSE THEN
    rwert=XBIOS(xbs,40)
  ELSE
    rwert=0
  ENDIF
RETURN
'
> PROCEDURE dspreset
  IF demo=FALSE THEN
    ~XBIOS(xbs,61)
  ENDIF
RETURN
'
> PROCEDURE volwrite(l,r)
  .| Ruft auf  : volcs,waitchip,voldatai,volclk
  .| Aufruf in : setup-1,peak-1,do_peak-3,
  IF falcon=FALSE THEN
    IF demo=FALSE THEN
      ~XBIOS(xbs,50,l,r)
    ENDIF
  ELSE
    IF l<192 THEN
      l=192
    ENDIF
    IF r<192 THEN
      r=192
    ENDIF
    l=(l AND &H3F)
    l=INT(l/4)*16
    r=(r AND &H3F)
    r=INT(r/4)*16
    ~XBIOS(&H82,2,l)
    ~XBIOS(&H82,3,r)
  ENDIF
RETURN
'
> PROCEDURE volwrite2(l,r)
  .| Ruft auf  : volcs,waitchip,voldatai,volclk
  IF falcon=FALSE THEN
    IF demo=FALSE THEN
      ~XBIOS(xbs,51,l,r)
    ENDIF
  ELSE
    IF l>191 THEN
      l=191
    ENDIF
    IF r>191 THEN
      r=191
    ENDIF
    l=(l AND &HBF)
    l=INT(l/12)
    l=(15-l)*16
    r=(r AND &HBF)
    r=INT(r/12)
    r=(15-r)*16
    IF demo=FALSE THEN
      ~XBIOS(&H82,0,l)
      ~XBIOS(&H82,1,r)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE dspoff
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : do_main-1,
  dspw=0
  IF demo=FALSE THEN
    ~XBIOS(xbs,22,0)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,dspoff&)
    @textfeld(dsp&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE dspin
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : do_main-1,
  dspw=1
  IF demo=FALSE THEN
    ~XBIOS(xbs,22,1)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,dspin&)
    @textfeld(dsp&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE dspout
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : do_main-1,
  dspw=2
  IF demo=FALSE THEN
    ~XBIOS(xbs,22,2)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,dspout&)
    @textfeld(dsp&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE scmsfree
  scmsw=2
  IF demo=FALSE THEN
    ~XBIOS(xbs,32,2)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,scmsfree&)
    @textfeld(protect&,a$,1)
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE scmsone
  scmsw=1
  IF demo=FALSE THEN
    ~XBIOS(xbs,32,1)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,scmsone&)
    @textfeld(protect&,a$,1)
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE scmsno
  scmsw=0
  IF demo=FALSE THEN
    ~XBIOS(xbs,32,0)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,scmsno&)
    @textfeld(protect&,a$,1)
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE opto
  .| Glob. Var.: stl#,ad#,clk#,nr#,smp16&,a$,popups&,opto&,source&
  .| Ruft auf  : write_reglow,textfeld
  .| Aufruf in : do_main-1,
  digsource=0
  IF demo=FALSE THEN
    IF ad=0 OR digana=FALSE THEN
      ~XBIOS(xbs,21,0)   ! Optoeingang wÑhlen
      ~XBIOS(xbs,23,0)   ! Takt vom Digitaleingang
    ELSE
      ~XBIOS(xbs,21,0)   ! Optoeingang wÑhlen
      ~XBIOS(xbs,23,clk) ! Taktrate wÑhlen
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,opto&)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE coax
  .| Glob. Var.: stl#,ad#,clk#,nr#,smp16&,a$,popups&,coax&,source&
  .| Ruft auf  : write_reglow,textfeld
  .| Aufruf in : do_main-1,
  digsource=1
  IF demo=FALSE THEN
    IF ad=0 OR digana=FALSE THEN
      ~XBIOS(xbs,21,1)   ! Koaxeingang wÑhlen
      ~XBIOS(xbs,23,0)   ! Takt vom Digitaleingang
    ELSE
      ~XBIOS(xbs,21,1)   ! Koaxeingang wÑhlen
      ~XBIOS(xbs,23,clk) ! Taktrate wÑhlen
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,coax&)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE aesebu
  .| Glob. Var.: stl#,ad#,clk#,nr#,smp16&,a$,popups&,coax&,source&
  .| Ruft auf  : write_reglow,textfeld
  .| Aufruf in : do_main-1,
  digsource=2
  IF demo=FALSE THEN
    IF ad=0 OR digana=FALSE THEN
      ~XBIOS(xbs,21,2)   ! AESEBUeingang wÑhlen
      ~XBIOS(xbs,23,0)   ! Takt vom Digitaleingang
    ELSE
      ~XBIOS(xbs,21,2)   ! AESEBUeingang wÑhlen
      ~XBIOS(xbs,23,clk) ! Taktrate wÑhlen
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,aesebu&)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE emphoff
  '  @highsampling(FALSE)
  IF demo=FALSE THEN
    ~XBIOS(xbs,33,0)
  ENDIF
  empha=FALSE
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,emphoff&)
    @textfeld(emphasis&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE emphon
  '  @highsampling(TRUE)
  IF demo=FALSE THEN
    ~XBIOS(xbs,33,1)
  ENDIF
  empha=TRUE
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,emphon&)
    @textfeld(emphasis&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE consumer
  IF demo=FALSE THEN
    ~XBIOS(xbs,30,0)
  ENDIF
  proffm=FALSE
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,consumer&)
    @textfeld(mode&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE profess
  proffm=TRUE
  IF demo=FALSE THEN
    ~XBIOS(xbs,30,1)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,profess&)
    @textfeld(mode&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE fifodel
  .| Glob. Var.: sth#
  .| Ruft auf  : write_reghigh
  .| Aufruf in : maschruf4-1,peak-1,peakread-1,smpauto-1,smpstart-1,
  IF demo=FALSE THEN
    ~XBIOS(xbs,60) ! Reset REC-Fifo
  ENDIF
RETURN
'
> PROCEDURE digibridge
  IF bridge=FALSE THEN
    bridge=TRUE
    IF demo=FALSE THEN
      ~XBIOS(xbs,31,1)
    ENDIF
    IF nr=smp16& THEN
      setbutton(bridge&,1)
    ENDIF
  ELSE
    bridge=FALSE
    IF demo=FALSE THEN
      ~XBIOS(xbs,31,0)
    ENDIF
    IF nr=smp16& THEN
      setbutton(bridge&,0)
    ENDIF
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE digin
  .| Glob. Var.: sth#
  .| Ruft auf  : write_reghigh
  .| Aufruf in : digout-1,arrmidplay-2,smpplay-2,smppmhlp-2,
  IF demo=FALSE THEN
    ~XBIOS(xbs,25,0) ! Switch to Bypass-Output
  ENDIF
RETURN
'
> PROCEDURE digout(swert!)
  .| Glob. Var.: sth#,extclock#,digana#,ad#,stl#,clk#
  .| Ruft auf  : write_reghigh,write_reglow,digital,digin,analog
  .| Aufruf in : maschruf2-1,maschinit2b-1,maschinit5b-1,maschruf18-1
  .|     maschruf18b-1,newfsel-4,arrsethz-1,traksethz-1,trakforw-4,trkbackw-4
  .|     trkplay-3,arrplay-3,virtual-2,mforw-4,mbackw-4,monitor-2,smpplay-2
  .|     smpauto-1,record-1,
  bypmode=swert!
  IF swert!=TRUE THEN
    IF demo=FALSE THEN
      ~XBIOS(xbs,25,1) ! Switch to PLAY-Output
    ENDIF
    IF digana=TRUE AND ad=1 THEN
      IF demo=FALSE THEN
        ~XBIOS(xbs,20,1)   ! Analogeingang benutzen
        ~XBIOS(xbs,23,clk) ! Taktrate wÑhlen
      ENDIF
    ENDIF
    IF digana=TRUE AND ad=0 THEN
      @digital
    ENDIF
  ENDIF
  IF swert!=FALSE THEN
    IF dspuse=TRUE THEN
      @dspbypass
    ENDIF
    @digin
    IF ad=1 THEN
      @analog
    ELSE
      @digital
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE highsampling(state)
  hsbit=state
  IF demo=FALSE THEN
    IF state=TRUE THEN
      ~XBIOS(xbs,24,1)
    ELSE
      ~XBIOS(xbs,24,0)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE proffhz                      ! Hier muû nachgearbeitet werden !   HZ !!
  IF demo=FALSE THEN
    IF ext=0 THEN
      IF hz=32000 THEN
        ~XBIOS(xbs,23,1)
      ENDIF
      IF hz=44100 THEN
        ~XBIOS(xbs,23,2)
      ENDIF
      IF hz=48000 THEN
        ~XBIOS(xbs,23,3)
      ENDIF
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE adlow
  hz=32000
  ext=0
  clk=1
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE admid
  hz=44100
  ext=0
  clk=2
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE adhigh
  hz=48000
  ext=0
  clk=3
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE admid96
  hz=88200
  ext=0
  clk=2
  mod96=TRUE
  @adctrl
RETURN
'
> PROCEDURE adhigh96
  hz=96000
  ext=0
  clk=3
  mod96=TRUE
  @adctrl
RETURN
'
> PROCEDURE ad8
  hz=8000
  ext=0
  clk=4
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad11
  hz=11000
  ext=0
  clk=5
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad12
  hz=12000
  ext=0
  clk=6
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad16
  hz=16000
  ext=0
  clk=7
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad17
  hz=17000
  ext=0
  clk=8
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad22
  hz=22000
  ext=0
  clk=9
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad24
  hz=24000
  ext=0
  clk=10
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad33
  hz=33000
  ext=0
  clk=11
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE adexth2
  hz=INT(masterclk/768)
  ext=768
  clk=12
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE adextl2
  hz=INT(masterclk/512)
  ext=512
  clk=13
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE adexth1
  hz=INT(masterclk/384)
  ext=384
  clk=14
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE adextl1
  hz=INT(masterclk/256)
  ext=256
  clk=15
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE addiv
  LOCAL a1
  IF fmclk=FALSE THEN
    clkmode=2
  ELSE
    clkmode=3
  ENDIF
  ~GRAF_MKSTATE(v,v2,v3,v4)        ! NEU !!!
  IF v4<>0 OR cdivsms=-1 THEN
    firstclk=FALSE
    IF cdivsms=-1 THEN
      cdivsms=1
    ENDIF
    mrkobj=obj
    vorvornr=vornr
    vornr=nr
    nr=clocks&
    @rsc_draw(nr,0)
    @markhlp
    IF clkmode=1 THEN
      cdivz=60
    ENDIF
    IF clkmode=2 THEN
      cdivz=38
    ENDIF
    IF clkmode=3 THEN
      cdivz=14
    ENDIF
    IF cdivz<cdivsms THEN
      cdivsms=cdivz
    ENDIF
    @slideinit(clkslid&,clkbut&,cdivz,5,vcdivsms)
    vcdivsms=cdivsms-1
    @setslide(clkslid&,clkbut&,cdivz,5,vcdivsms)
    a$=STR$(masterclk)
    IF LEN(a$)>6 THEN
      a$=LEFT$(a$,LEN(a$)-6)+"."+RIGHT$(a$,6)
    ENDIF
    a$=a$+" MHz"+CHR$(0)
    @textfeld(clockm&,a$,1)
    j=0
    FOR i=1 TO 60 STEP 4
      INC j
      clkdiv(i,1)=INT(masterclk/256/j)
      clkdiv(i+1,1)=INT(masterclk/384/j)
      clkdiv(i+2,1)=INT(masterclk/512/j)
      clkdiv(i+3,1)=INT(masterclk/768/j)
    NEXT i
    @clocklook(cdivsms)
    REPEAT
      REPEAT
        REPEAT
          obj=@rsc_do(nr,0,popup&)
          ~@xrsrc_gaddr(0,nr,zu%)
          zuadr=zu%
          @mouse(x,y,v3)
        UNTIL obj<>0 AND obj<>-1
        buttadr=zuadr+24*obj
        but=DPEEK(buttadr+6) AND 255
      UNTIL but<>0
      '
      IF obj=clockhlp& THEN
      ENDIF
      IF obj=clkup& THEN
        @slideup(clkslid&,clkbut&,cdivz,1,5,vcdivsms,slflg)
        IF slflg=TRUE THEN
          @clocklook(vcdivsms+1)
        ENDIF
        @setbutton(clkup&,0)
      ENDIF
      IF obj=clkdown& THEN
        @slidedwn(clkslid&,clkbut&,cdivz,1,5,vcdivsms,slflg)
        IF slflg=TRUE THEN
          @clocklook(vcdivsms+1)
        ENDIF
        @setbutton(clkdown&,0)
      ENDIF
    UNTIL obj=clockex& OR obj=clockok& OR obj=clock3&
    @setbutton(obj,0)
    IF obj=clock3& AND maxcol=2 THEN
      PAUSE 5
      @setbutton(obj,1)
      PAUSE 5
      @setbutton(obj,0)
      PAUSE 5
      @setbutton(obj,1)
      PAUSE 5
      @setbutton(obj,0)
    ENDIF
    @restaura2
    IF obj=clockok& OR obj=clock3& THEN
      clkdfind=TRUE
      cdivsms=vcdivsms+1
      @addiv3
      @addiv2
      firstclk=TRUE
    ELSE
      clkdfind=FALSE
      IF firstclk=FALSE THEN
        cdivsms=-1
      ENDIF
      @fliphz
    ENDIF
    obj=mrkobj
    vornr=vorvornr
  ELSE
    @addiv2
  ENDIF
RETURN
'
> PROCEDURE addiv2
  LOCAL a1
  IF clkmode=1 THEN
    a1=cdivsms
  ENDIF
  IF clkmode=2 THEN
    a1=clkdiv(cdivsms,2)
  ENDIF
  IF clkmode=3 THEN
    a1=clkdiv(cdivsms,3)
  ENDIF
  hz=INT(clkdiv(a1,1))
  ext=a1
  clk=16
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE addiv3
  LOCAL a1
  IF clkmode=1 THEN
    a1=cdivsms
  ENDIF
  IF clkmode=2 THEN
    a1=clkdiv(cdivsms,2)
  ENDIF
  IF clkmode=3 THEN
    a1=clkdiv(cdivsms,3)
  ENDIF
  hz=INT(clkdiv(a1,1))
  ndiv$=" DIV     "
  b1$=STR$(INT(hz/100)/10)
  IF INSTR(b1$,".")=0 THEN
    b1$=b1$+".0"
  ENDIF
  IF LEN(b1$)<4 THEN
    b1$=" "+b1$
  ENDIF
  @stringfeld(popups&,addiv&,b1$+CHR$(0),6)
  @stringfeld(popups&,ratediv&,b1$+" kHz"+CHR$(0),6)
RETURN
'
> PROCEDURE clocklook(clook)
  LOCAL a,a$,a1,a2,a3,a4,a5
  IF clkmode=1 THEN
    a1=clook-2
    a2=clook-1
    a3=clook
    a4=clook+1
    a5=clook+2
  ENDIF
  IF clkmode=2 THEN
    IF (clook-2)>0 THEN
      a1=clkdiv(clook-2,2)
    ENDIF
    IF (clook-1)>0 THEN
      a2=clkdiv(clook-1,2)
    ENDIF
    a3=clkdiv(clook,2)
    IF (clook+1)<=cdivz THEN
      a4=clkdiv(clook+1,2)
    ENDIF
    IF (clook+2)<=cdivz THEN
      a5=clkdiv(clook+2,2)
    ENDIF
  ENDIF
  IF clkmode=3 THEN
    IF (clook-2)>0 THEN
      a1=clkdiv(clook-2,3)
    ENDIF
    IF (clook-1)>0 THEN
      a2=clkdiv(clook-1,3)
    ENDIF
    a3=clkdiv(clook,3)
    IF (clook+1)<=cdivz THEN
      a4=clkdiv(clook+1,3)
    ENDIF
    IF (clook+2)<=cdivz THEN
      a5=clkdiv(clook+2,3)
    ENDIF
  ENDIF
  IF clook<3 THEN
    a$=""
  ELSE
    a$=STR$(clkdiv(a1,1))+" Hz"
  ENDIF
  IF LEN(a$)<9 THEN
    a$=RIGHT$(SPACE$(9)+a$,9)
  ENDIF
  a$=a$+CHR$(0)
  @textfeld(clock1&,a$,1)
  IF clook<2 THEN
    a$=""
  ELSE
    a$=STR$(clkdiv(a2,1))+" Hz"
  ENDIF
  IF LEN(a$)<9 THEN
    a$=RIGHT$(SPACE$(9)+a$,9)
  ENDIF
  a$=a$+CHR$(0)
  @textfeld(clock2&,a$,1)
  a$=STR$(clkdiv(a3,1))+" Hz"
  IF LEN(a$)<9 THEN
    a$=RIGHT$(SPACE$(9)+a$,9)
  ENDIF
  a$=a$+CHR$(0)
  @textfeld(clock3&,a$,1)
  IF clook=cdivz THEN
    a$=""
  ELSE
    a$=STR$(clkdiv(a4,1))+" Hz"
  ENDIF
  IF LEN(a$)<9 THEN
    a$=RIGHT$(SPACE$(9)+a$,9)
  ENDIF
  a$=a$+CHR$(0)
  @textfeld(clock4&,a$,1)
  IF clook>(cdivz-2) THEN
    a$=""
  ELSE
    a$=STR$(clkdiv(a5,1))+" Hz"
  ENDIF
  IF LEN(a$)<9 THEN
    a$=RIGHT$(SPACE$(9)+a$,9)
  ENDIF
  a$=a$+CHR$(0)
  @textfeld(clock5&,a$,1)
RETURN
'
> PROCEDURE analog
  .| Glob. Var.: extclock#,stl#,digana#,clk#,ad#,nr#,smp16&,a$,popups&,analog&
  .|     input&
  .| Ruft auf  : write_reglow,textfeld,makehz
  .| Aufruf in : digout-1,adlow-1,admid-1,adhigh-1,do_main-1,arrsethz-1
  .|     traksethz-1,trkplay-1,arrmidplay-1,arrplay-1,setup2-1,smpplay-2
  .|     smppmhlp-1,
  LOCAL cdiv
  IF demo=FALSE THEN
    IF digana=TRUE THEN
      ~XBIOS(xbs,20,1)   ! Analogeingang benutzen
      ~XBIOS(xbs,23,clk) ! Taktrate wÑhlen
      '
      IF dspda=TRUE THEN
        IF ext=0 OR ext=256 OR ext=384 OR ext=512 OR ext=768 OR adat=TRUE THEN
          ~XBIOS(xbs,71,0)
        ELSE
          cdiv=INT((ext-1)/4)
          IF cdiv>0 THEN
            cdiv=cdiv+1
          ENDIF
          ~XBIOS(xbs,71,cdiv)
          cdiv2=16-(ext-INT((ext-1)/4)*4)
          ~XBIOS(xbs,23,cdiv2) ! Taktrate wÑhlen
        ENDIF
      ENDIF
      '
    ELSE
      ~XBIOS(xbs,20,1)   ! Analogeingang benutzen
      ~XBIOS(xbs,23,0)   ! Taktrate vom digitaleingang
    ENDIF
  ENDIF
  ad=1
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,analog&)
    @textfeld(input&,a$,1)
  ENDIF
  @makehz
  IF digana=FALSE THEN
    '    @digital
  ELSE
    '    @digout(TRUE)
  ENDIF
RETURN
'
> PROCEDURE digital
  .| Glob. Var.: extclock#,stl#,ad#,nr#,smp16&,a$,popups&,digital&,input&
  .| Ruft auf  : write_reglow,textfeld,makehz
  .| Aufruf in : digout-2,do_main-1,trkplay-1,arrmidplay-1,arrplay-1
  .|     smpplay-2,smppmhlp-1,
  IF demo=FALSE THEN
    ~XBIOS(xbs,20,0)   ! Digitaleingang benutzen
    ~XBIOS(xbs,23,0)   ! Taktrate vom digitaleingang
  ENDIF
  ad=0
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,digital&)
    @textfeld(input&,a$,1)
  ENDIF
  @makehz
RETURN
'
' ------------------------------------------------------------------------------
'          HardwareabhÑngiger Teil - Datenzugriff Register Write/Read
' ------------------------------------------------------------------------------
'
> PROCEDURE balwrite(volume,balance,balmax)
  LOCAL i,anfwert
  lbal=volume
  rbal=volume
  anfwert=4 ! maximal bis 9
  dev=anfwert/balmax
  IF balance>0 THEN
    lbal=INT(volume*LOG10(10-dev*balance))
  ENDIF
  IF balance<0 THEN
    rbal=INT(volume*LOG10(10-dev*ABS(balance)))
  ENDIF
  @volwrite(lbal,rbal)
RETURN
'
> PROCEDURE balwrite2(volume,balance,balmax)
  LOCAL i,anfwert
  lbal=volume
  rbal=volume
  anfwert=4 ! maximal bis 9
  dev=anfwert/balmax
  IF balance>0 THEN
    lbal=INT(volume*LOG10(10-dev*balance))
  ENDIF
  IF balance<0 THEN
    rbal=INT(volume*LOG10(10-dev*ABS(balance)))
  ENDIF
  @volwrite2(lbal,rbal)
RETURN
'
> PROCEDURE adctrl
  IF ad=0 THEN
    @digital
  ELSE
    @analog
  ENDIF
  @makehz
RETURN
'
> PROCEDURE makehz
  .| Glob. Var.: digana#,extclock#,clk#,hz#,hzc#,rwert#,ohz#,retime#,hzm#
  .| Ruft auf  : fliphz,read_statlow
  .| Aufruf in : adlow-1,admid-1,adhigh-1,ext32l-1,ext44l-1,ext48l-1,ext32h-1
  .|     ext44h-1,ext48h-1,ext256-1,ext384-1,analog-1,digital-1,smpsave-1
  .|     ldhlp-2,infrett-1,smpinfbutt-1,ldhead-1,resample-1,arranger-1
  .|     trakker-1,trkplay-1,arrplay-1,smpedit-1,time_edit-1,make-1,trash-1
  .|     setupdat-1,setup2-1,conspace-1,
  IF retime=1 THEN
    hz=hzm
  ENDIF
  IF digana=TRUE AND retime=0 THEN
    @fliphz
  ENDIF
  IF digana=FALSE THEN
    @read_digsrate
    hzc=rwert
    ohz=hz
    IF hzc=1 THEN
      hz=32000
    ENDIF
    IF hzc=2 THEN
      hz=44100
    ENDIF
    IF hzc=3 THEN
      hz=48000
    ENDIF
    IF digana=FALSE AND ohz<>hz THEN
      @fliphz
    ENDIF
  ENDIF
  IF hz<>256 AND hz<>384 AND hz<>512 AND hz<>768 THEN
    hz=INT(hz/100)*100
  ENDIF
  IF hz=0 THEN
    hz=44100
  ENDIF
RETURN
'
> PROCEDURE makehz2
  .| Glob. Var.: ad#,digana#,extclock#,clk#,hz#,hzc#,rwert#,ohz#,retime#,hzm#
  .| Ruft auf  : fliphz,read_statlow
  .| Aufruf in : smpauto-1,smpstart-1,
  IF retime=1 THEN
    hz=hzm
  ENDIF
  IF (ad=1 AND digana=TRUE AND retime=0) THEN
    @fliphz
  ENDIF
  IF ad=0 OR digana=FALSE THEN
    @read_digsrate
    hzc=rwert
    ohz=hz
    IF hzc=1 THEN
      hz=32000
    ENDIF
    IF hzc=2 THEN
      hz=44100
    ENDIF
    IF hzc=3 THEN
      hz=48000
    ENDIF
    IF digana=FALSE AND ohz<>hz THEN
      @fliphz
    ENDIF
  ENDIF
  IF hz<>256 AND hz<>384 AND hz<>512 AND hz<>768 THEN
    hz=INT(hz/100)*100
  ENDIF
RETURN
'
> PROCEDURE makehz3
  IF ad=0 THEN
    hzc=rwert
    ohz=hz
    IF hzc=1 THEN
      hz=32000
    ENDIF
    IF hzc=2 THEN
      hz=44100
    ENDIF
    IF hzc=3 THEN
      hz=48000
    ENDIF
    @fliphz
  ENDIF
  IF hz<>256 AND hz<>384 AND hz<>512 AND hz<>768 THEN
    hz=INT(hz/100)*100
  ENDIF
  IF hz=0 THEN
    hz=44100
  ENDIF
RETURN
'
> PROCEDURE fliphz
  .| Glob. Var.: nr#,smpedit&,extclock#,hz#,a$,popups&,rate32&,rate&,rate44&
  .|     rate48&,ext#,ext32l&,ext44l&,ext48l&,ext32h&,ext44h&,ext48h&
  .|     rateextl&,rateexth&,smp16&,ad32&,rate2&,ad44&,ad48&,adext32l&
  .|     adext44l&,adext48l&,adext32h&,adext44h&,adext48h&,adextl&,adexth&
  .| Ruft auf  : textfeld
  .| Aufruf in : makehz-2,makehz2-2,sethertz-1,rebuild-1,
  IF nr=smpedit& THEN
    IF ohz<>hz THEN
      @hztext
    ENDIF
    IF hz=32000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate32&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=44100 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate44&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=48000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate48&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=88200 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate88&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=96000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate96&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=8000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate8&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=11000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate11&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=12000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate12&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=16000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate16&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=17000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate17&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=22000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate22&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=24000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate24&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=33000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate33&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext=768 THEN
      a$=@rsc_text$(popups&,ratexth2&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext=512 THEN
      a$=@rsc_text$(popups&,ratextl2&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext=384 THEN
      a$=@rsc_text$(popups&,ratexth1&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext=256 THEN
      a$=@rsc_text$(popups&,ratextl1&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext>0 AND ext<>256 AND ext<>384 AND ext<>512 AND ext<>768 THEN
      a$=@rsc_text$(popups&,ratediv&)
      @textfeld(rate&,a$,1)
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    IF hz=32000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad32&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=44100 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad44&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=48000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad48&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=88200 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad88&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=96000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad96&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=8000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad8&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=11000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad11&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=12000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad12&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=16000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad16&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=17000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad17&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=22000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad22&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=24000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad24&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=33000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad33&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF ext=768 THEN
      a$=@rsc_text$(popups&,adexth2&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF ext=512 THEN
      a$=@rsc_text$(popups&,adextl2&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF ext=384 THEN
      a$=@rsc_text$(popups&,adexth1&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF ext=256 THEN
      a$=@rsc_text$(popups&,adextl1&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF ext>0 AND ext<>256 AND ext<>384 AND ext<>512 AND ext<>768 THEN
      a$=@rsc_text$(popups&,addiv&)
      @textfeld(rate2&,a$,1)
    ENDIF
  ENDIF
  IF digana=TRUE THEN
    IF ad=1 AND ext=0 THEN ! neu seit XBIOS-Umstrukturierung
      @proffhz
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE fliphz2
  IF digana=TRUE THEN
    IF hz=32000 AND ext=0 THEN
      @adlow
    ENDIF
    IF hz=44100 AND ext=0 THEN
      @admid
    ENDIF
    IF hz=48000 AND ext=0 THEN
      @adhigh
    ENDIF
    IF hz=88200 AND ext=0 THEN
      @admid96
    ENDIF
    IF hz=96000 AND ext=0 THEN
      @adhigh96
    ENDIF
    IF hz=8000 AND ext=0 THEN
      @ad8
    ENDIF
    IF hz=11000 AND ext=0 THEN
      @ad11
    ENDIF
    IF hz=12000 AND ext=0 THEN
      @ad12
    ENDIF
    IF hz=16000 AND ext=0 THEN
      @ad16
    ENDIF
    IF hz=17000 AND ext=0 THEN
      @ad17
    ENDIF
    IF hz=22000 AND ext=0 THEN
      @ad22
    ENDIF
    IF hz=24000 AND ext=0 THEN
      @ad24
    ENDIF
    IF hz=33000 AND ext=0 THEN
      @ad33
    ENDIF
    IF ext=768 THEN
      @adexth2
    ENDIF
    IF ext=512 THEN
      @adextl2
    ENDIF
    IF ext=384 THEN
      @adexth1
    ENDIF
    IF ext=256 THEN
      @adextl1
    ENDIF
    IF ext>0 AND ext<>256 AND ext<>384 AND ext<>512 AND ext<>768 THEN
      @addiv2
    ENDIF
    IF ad=1 THEN  ! neu seit XBIOS-Umstrukturierung
      @proffhz
    ENDIF
  ENDIF
RETURN
'
'
' ------------------------------------------------------------------------------
' ------------------------ASSEMBLER-ROUTINEN------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE maschruf1
  .| Glob. Var.: saa%,a#,sba%,b#,ena%,l#,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpsave-1,ldhlp-1,
  ' LOAD/SAVE
  '
  @busy_mouse
  saa%=a
  sba%=b
  ena%=l
  ~XBIOS(xbs,310,L:saa%,L:sba%,L:ena%)
RETURN
'
> PROCEDURE maschinit2
  .| Glob. Var.: mdat2%,back%
  .| Aufruf in : smpplay-1,smppmhlp-1,
  LOCAL a,g
  ' PLAY
  '
  ' 48E7FFFE             begin:    movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3  ; von
  ' 222F0044                       move.l    68(sp),d1  ; bis
  ' 282F0048                       move.l    72(sp),d4  ; Anzahl der For/Backstep
  ' 262F004C                       move.l    76(sp),d3  ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi)
  ' 242F0050                       move.l    80(sp),d2  ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
  ' 202F0054                       move.l    84(sp),d0  ; midi
  ' 206F0058                       move.l    88(sp),a0  ; StatH im Bytemode
  ' 226F005C                       move.l    92(sp),a1  ; Playread im Wordmode
  ' 286F0060                       move.l    96(sp),a4  ; Returnwert (momentanes Playbyte & Anzahl der loops)
  ' 45FA015C                       lea.l     midisuch(pc),a2
  ' 3480                           move.w    d0,(a2)
  ' 45FA0158                       lea.l     midiw(pc),a2
  ' 24BC00000000                   move.l    #0,(a2)
  ' 7C00                           moveq.l   #0,d6      ; LoopzÑhler
  ' 7A08                           moveq.l   #8,d5
  ' 61000044             anf:      bsr       play
  ' 4A40                           tst.w     d0
  ' 6632                           bne.s     weg
  ' 08030001             crosstst: btst      #1,d3
  ' 6724                           beq.s     looptst
  ' 5084                           addq.l    #8,d4
  ' 4484                           neg.l     d4
  ' 2001                           move.l    d1,d0
  ' 5980                           subq.l    #4,d0
  ' 220B                           move.l    a3,d1
  ' 5881                           addq.l    #4,d1
  ' 2640                           movea.l   d0,a3
  ' 61000028                       bsr       play
  ' 4A40                           tst.w     d0
  ' 6616                           bne.s     weg
  ' 4484                           neg.l     d4
  ' 5184                           subq.l    #8,d4
  ' 2001                           move.l    d1,d0
  ' 5980                           subq.l    #4,d0
  ' 220B                           move.l    a3,d1
  ' 5881                           addq.l    #4,d1
  ' 2640                           movea.l   d0,a3
  ' 08030000             looptst:  btst      #0,d3
  ' 6702                           beq.s     weg
  ' 60C6                           bra.s     anf
  ' 288A                 weg:      move.l    a2,(a4)   ; Returnwert Playbyte speichern
  ' 29460004                       move.l    d6,4(a4)  ; Returnwert Anzahl loops speichern
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 244B                 play:     movea.l   a3,a2
  ' 1010                 fill:     move.b    (a0),d0   ; FIFO halbleer ?
  ' C005                           and.b     d5,d0
  ' 660A                           bne.s     copyanf
  ' 610000E4                       bsr       brktst
  ' 4A40                           tst.w     d0
  ' 6642                           bne.s     playex
  ' 60F0                           bra.s     fill
  ' 3002                 copyanf:  move.w    d2,d0     ; ...dann FIFO halb-fuellen (fifolen)!
  ' 1E1A                 copy:     move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Rechter Kanal (Bit 8 geloescht)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 0B87                           bclr      d5,d7     ; Rechter Kanal (Bit 8 geloescht)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Linker Kanal (Bit 8 gesetzt)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 0BC7                           bset      d5,d7     ; Linker Kanal (Bit 8 gesetzt)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' B5C1                           cmpa.l    d1,a2
  ' 671E                           beq.s     playend
  ' D5C4                           adda.l    d4,a2
  ' 51C8FFE0                       dbra      d0,copy
  ' 610000B6                       bsr       brktst
  ' 4A40                           tst.w     d0
  ' 6614                           bne.s     playex
  ' 08030002                       btst      #2,d3
  ' 67BE                           beq.s     fill
  ' 6100000E                       bsr       midi
  ' 4A40                           tst.w     d0
  ' 6606                           bne.s     playex
  ' 60B4                           bra.s     fill
  ' 7000                 playend:  moveq.l   #0,d0
  ' 5286                           addq.l    #1,d6
  ' 4E75                 playex:   rts
  ' 48E77FF8             midi:     movem.l   d1-d7/a0-a4,-(sp)
  ' 41FA00AA                       lea.l     midisuch(pc),a0
  ' 3410                           move.w    (a0),d2
  ' 3F02                           move.w    d2,-(sp)
  ' 3F3C0003                       move.w    #3,-(sp)  ; MIDI
  ' 3F3C0001                       move.w    #1,-(sp)  ; Bconstat
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' B07C0000                       cmp.w     #0,d0
  ' 6768                           beq.s     nomidi
  ' 3F3C0003                       move.w    #3,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)  ; Bconin
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 341F                           move.w    (sp)+,d2
  ' 3F02                           move.w    d2,-(sp)
  ' 41FA0082                       lea.l     midiw(pc),a0
  ' 08000007                       btst      #7,d0
  ' 6708                           beq.s     midi2     ; Daten oder Befehl ?
  ' E042                           asr.w     #8,d2     ; Channel im oberen Byte des Wortes
  ' 9002                           sub.b     d2,d0     ; Channel vom Befehl abziehen
  ' 1080                           move.b    d0,(a0)   ; Befehl schreiben
  ' 6046                           bra.s     nomidi
  ' B002                 midi2:    cmp.b     d2,d0       ; Noten-DATA ?
  ' 671E                           beq.s     midi4
  ' B4280001                       cmp.b     1(a0),d2    ; Noten-data schon gewesen und korrekt ?
  ' 663C                           bne.s     nomidi
  ' 11400002             midi3:    move.b    d0,2(a0)    ; Velocitywert schreiben
  ' 0C100080                       cmp.b     #$80,(a0)   ; NOTE OFF ?
  ' 671A                           beq.s     midi5
  ' 0C100090                       cmp.b     #$90,(a0)   ; NOTE ON ?
  ' 671C                           beq.s     midi6
  ' 20BC00000000         midi3b:   move.l    #0,(a0)     ; Datenwort lîschen
  ' 6024                           bra.s     nomidi
  ' B4280001             midi4:    cmp.b     1(a0),d2    ; Noten-DATA schon gewesen ?
  ' 67E2                           beq.s     midi3       ; dann ist es nicht Note sondern Velocity
  ' 11400001                       move.b    d0,1(a0)    ; Notenwert schreiben
  ' 6018                           bra.s     nomidi
  ' B4280001             midi5:    cmp.b     1(a0),d2    ; NOTE OFF und Note OK ?
  ' 66E6                           bne.s     midi3b      ; wenn nein, Datenwort lîschen
  ' 601A                           bra.s     midiex      ; Abbruch, da NOTE OFF !
  ' B4280001             midi6:    cmp.b     1(a0),d2    ; NOTE ON und Note OK ?
  ' 66DE                           bne.s     midi3b      ; wenn nein, Datenwort lîschen
  ' 0C2800000002                   cmp.b     #0,2(a0)    ; Velocity ist Null ?
  ' 66D6                           bne.s     midi3b      ; wenn nein, Datenwort lîschen
  ' 600A                           bra.s     midiex      ; Abbruch, da NOTE ON und Velo=Null !
  ' 341F                 nomidi:   move.w    (sp)+,d2
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 7000                           moveq.w   #0,d0
  ' 4E75                           rts
  ' 341F                 midiex:   move.w    (sp)+,d2
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 7001                           moveq.w   #1,d0
  ' 4E75                           rts
  ' 48E77FF8             brktst:   movem.l   d1-d7/a0-a4,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF1FFE                       movem.l   (sp)+,d1-d7/a0-a4
  ' 4E75                           rts
  ' 0000                 midisuch: dc.w 0
  ' 00000000             midiw:    dc.l 0
anfbmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H222F,&H0044
  DATA &H282F,&H0048
  DATA &H262F,&H004C
  DATA &H242F,&H0050
  DATA &H202F,&H0054
  DATA &H206F,&H0058
  DATA &H226F,&H005C
  DATA &H286F,&H0060
  DATA &H45FA,&H015C
  DATA &H3480
  DATA &H45FA,&H0158
  DATA &H24BC,&H0000,&H0000
  DATA &H7C00
  DATA &H7A08
  DATA &H6100,&H0044
  DATA &H4A40
  DATA &H6632
  DATA &H0803,&H0001
  DATA &H6724
  DATA &H5084
  DATA &H4484
  DATA &H2001
  DATA &H5980
  DATA &H220B
  DATA &H5881
  DATA &H2640
  DATA &H6100,&H0028
  DATA &H4A40
  DATA &H6616
  DATA &H4484
  DATA &H5184
  DATA &H2001
  DATA &H5980
  DATA &H220B
  DATA &H5881
  DATA &H2640
  DATA &H0803,&H0000
  DATA &H6702
  DATA &H60C6
  DATA &H288A
  DATA &H2946,&H0004
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H244B
  DATA &H1010
  DATA &HC005
  DATA &H660A
  DATA &H6100,&H00E4
  DATA &H4A40
  DATA &H6642
  DATA &H60F0
  DATA &H3002
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1E1A
  DATA &H0B87
  DATA &H3287
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &H1E1A
  DATA &H0BC7
  DATA &H3287
  DATA &HB5C1
  DATA &H671E
  DATA &HD5C4
  DATA &H51C8,&HFFE0
  DATA &H6100,&H00B6
  DATA &H4A40
  DATA &H6614
  DATA &H0803,&H0002
  DATA &H67BE
  DATA &H6100,&H000E
  DATA &H4A40
  DATA &H6606
  DATA &H60B4
  DATA &H7000
  DATA &H5286
  DATA &H4E75
  DATA &H48E7,&H7FF8
  DATA &H41FA,&H00AA
  DATA &H3410
  DATA &H3F02
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &HB07C,&H0000
  DATA &H6768
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0002
  DATA &H4E4D
  DATA &H588F
  DATA &H341F
  DATA &H3F02
  DATA &H41FA,&H0082
  DATA &H0800,&H0007
  DATA &H6708
  DATA &HE042
  DATA &H9002
  DATA &H1080
  DATA &H6046
  DATA &HB002
  DATA &H671E
  DATA &HB428,&H0001
  DATA &H663C
  DATA &H1140,&H0002
  DATA &H0C10,&H0080
  DATA &H671A
  DATA &H0C10,&H0090
  DATA &H671C
  DATA &H20BC,&H0000,&H0000
  DATA &H6024
  DATA &HB428,&H0001
  DATA &H67E2
  DATA &H1140,&H0001
  DATA &H6018
  DATA &HB428,&H0001
  DATA &H66E6
  DATA &H601A
  DATA &HB428,&H0001
  DATA &H66DE
  DATA &H0C28,&H0000,&H0002
  DATA &H66D6
  DATA &H600A
  DATA &H341F
  DATA &H4CDF,&H1FFE
  DATA &H7000
  DATA &H4E75
  DATA &H341F
  DATA &H4CDF,&H1FFE
  DATA &H7001
  DATA &H4E75
  DATA &H48E7,&H7FF8
  DATA &H3F3C,&H0002
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H1FFE
  DATA &H4E75
  DATA &H0000
  DATA &H0000,&H0000
  '
  RESTORE anfbmasch
  FOR g=0 TO 394 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  back%=-1
RETURN
'
> PROCEDURE keymarkers
  keym=TRUE
  IF fkms=FALSE THEN
    INC kms
  ENDIF
  IF kms<=loopz THEN
    IF hdr=FALSE AND hdp=FALSE THEN
      IF sms2=0 THEN
        sms2=1
        @selblkshak(sms2,1)
      ENDIF
      IF nr=smpedit& AND sms=kms AND fkms=TRUE THEN
        @edmarkdel
      ENDIF
      loops%(kms,sms2)=point
      IF nr=smpedit& THEN
        IF kms=1 OR sms=kms THEN
          @edmarkset(kms)
        ELSE
          @edslidemove(kms)
        ENDIF
      ENDIF
      sms=kms
      IF nr=peak& THEN
        @htimeset
        a$=pknam$+" -> "+STR$(kms)+": "+a$
        @textfeld(peakname&,a$,1)
      ENDIF
    ELSE
      IF nr=smpedit& THEN
        @textfeld(edmtims&,CHR$(0),1)
        @textfeld(edmtime&,CHR$(0),1)
        @textfeld(edmtimi&,CHR$(0),1)
        @textfeld(edmtimr&,CHR$(0),1)
      ENDIF
      IF hdp=TRUE THEN
        IF virtual=FALSE THEN
          kms2=1
          bloops%(kms,kms2)=point
          a$=STR$(kms)+CHR$(0)
          IF nr=smpedit& THEN
            @textfeld(edmnr&,a$,1)
          ENDIF
          IF nr=peak& THEN
            @htimeset
            a$=pknam$+" -> "+STR$(kms)+": "+a$
            @textfeld(peakname&,a$,1)
          ENDIF
          vkms=kms-1
          IF nr=smpedit& THEN
            @setslide(edmslide&,edmbut&,loopz,5,vkms)
            @markhlp3(kms,kms2,bloops%(kms,kms2))
          ENDIF
        ELSE
          sms=kms
          IF sms2=0 THEN
            sms2=1
            @selblkshak(sms2,1)
          ENDIF
          loops%(sms,sms2)=point
          a$=STR$(sms)+CHR$(0)
          IF nr=smpedit& THEN
            @textfeld(edmnr&,a$,1)
          ENDIF
          IF nr=peak& THEN
            @htimeset
            a$=pknam$+" -> "+STR$(kms)+": "+a$
            @textfeld(peakname&,a$,1)
          ENDIF
          vsms=sms-1
          IF nr=smpedit& THEN
            @setslide(edmslide&,edmbut&,loopz,5,vsms)
            @markhlp3(sms,sms2,loops%(sms,sms2))
          ENDIF
        ENDIF
      ELSE
        IF sms2=0 THEN
          sms2=1
        ENDIF
        sms=kms
        loops%(sms,sms2)=point
        a$=STR$(sms)+CHR$(0)
        IF nr=smpedit& THEN
          @textfeld(edmnr&,a$,1)
        ENDIF
        IF nr=peak& THEN
          @htimeset
          a$=pknam$+" -> "+STR$(kms)+": "+a$
          @textfeld(peakname&,a$,1)
        ENDIF
        vsms=sms-1
        IF nr=smpedit& THEN
          @setslide(edmslide&,edmbut&,loopz,5,vsms)
          @markhlp3(sms,sms2,loops%(sms,sms2))
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  fkms=FALSE
RETURN
'
> PROCEDURE maschruf2
  .| Glob. Var.: demo#,saa%,a#,sba%,b#,sca%,adder#,sda%,l#,sea%,playfifolen#
  .|     sfa%,midiwort#,sga%,adr#,sha%,wback%,sia%,mdat%,t#,meml#,nr#,smpedit&
  .|     back%,back2%,back3%,hsec2#,hsec#,smpsec&,a$,sec$,mdat2%
  .| Ruft auf  : busy_mouse,digout,intzeiger1,htimeset,textfeld,intzeiger2
  .|     mousek,intzeiger3
  .| Aufruf in : smpplay-2,smppmhlp-2,
  LOCAL p,b$
  '  @busy_mouse
  ' PLAY
  '
  omspos=-1
  fkms=TRUE
  kms=sms
  IF dspuse=TRUE THEN
    @dspplay2
    '    PAUSE 20
  ENDIF
  '
  IF demo=FALSE THEN
    @digout(TRUE)
    saa%=a
    sba%=b
    IF dspuse=TRUE THEN
      v=b-a
      v=INT(v/&H2000)*&H2000
      b=a+v
      sba%=b
    ENDIF
    IF falcon=FALSE THEN
      sca%=adder
      sda%=l
      IF dspuse=FALSE THEN
        sea%=playfifolen/8-1
      ELSE
        sea%=&H800-1              ! war vorher &H1000-1
      ENDIF
      sfa%=midiwort
      sga%=adr+&H40
      sha%=adr+&H100
    ENDIF
    LPOKE wback%,0
    LPOKE wback%+4,0
    sia%=wback%
    p=mdat%
    IF XBIOS(xbs,1)=&H71273800 OR falcon=TRUE THEN
      IF falcon=FALSE THEN
        IF dspuse=FALSE THEN
          IF dig24=FALSE THEN
            a=XBIOS(xbs,122,0,L:saa%,L:sba%,L:0,sca%,sda%)
          ELSE
            a=XBIOS(xbs,122,2,L:saa%,L:sba%,L:0,sca%,sda%) ! fÅr 24Bit-Mode
          ENDIF
          '
          IF dig24=TRUE THEN
            '            ~XBIOS(xbs,28,1)
          ENDIF
          IF mod96=TRUE THEN
            ~XBIOS(xbs,24,1)
          ENDIF
          '
          PAUSE 5
          IF pwait=FALSE THEN
            IF mtc=TRUE THEN
              @wait_mtc
            ENDIF
            @write_int(1)
          ELSE
            intnr=1
            @pausewait
          ENDIF
        ELSE
          @write_int(0)
          ~XBIOS(xbs,55,0)
          ~XBIOS(&H8B,0,2,0,clk,1)
          ~XBIOS(&H8B,1,8,0,clk,1)
          a=XBIOS(xbs,122,1,L:saa%,L:sba%,L:0,sca%,sda%)
          ~XBIOS(xbs,74)
          '        ~XBIOS(xbs,73,0)
          ~XBIOS(112,&H12)
          ~XBIOS(xbs,55,1)
        ENDIF
      ELSE
        ~XBIOS(&H83,0,L:saa%,L:sba%)
        ~XBIOS(&H84,1)
        ~XBIOS(&H85,0,0)
        ~XBIOS(&H86,0)
        ~XBIOS(&H87,0,0)   ! war 1,0
        ~XBIOS(&H8B,0,8+4,0,clk,1)
        '
        '
        a=1
        IF sloop=1 THEN
          a=a+2
        ENDIF
        a=XBIOS(&H88,a)
        PAUSE 5
      ENDIF
      t=TIMER
      b=mbit*INT((saa%-meml)/mbit)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      REPEAT
      UNTIL @mousek=0
      wleer=0
      REPEAT
        IF falcon=FALSE THEN
          back%=LPEEK(a)
          back2%=LPEEK(a+28)
          back3%=LPEEK(a+8)
          back4%=LPEEK(a+24)
          wleer2=LPEEK(a+12)
        ELSE
          back2%=0
          back3%=0
          a=XBIOS(&H8C,0)
          IF a<>0 THEN
            INC wleer2%
          ENDIF
          a=XBIOS(&H8D,L:mdat2%)
          back%=LPEEK(mdat2%)
          back4%=LPEEK(mdat2%)-saa%
          '
          '          bi=XBIOS(500,308)
          '          bi$=STR$(LPEEK(bi))+" : "+STR$(LPEEK(bi+4))+SPACE$(10)
          '          TEXT 64,64,bi$
          '
        ENDIF
        hsec2=INT((TIMER-t)/2)
        point=INT(saa%-meml+back4%)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=INT((saa%-meml+back4%)/hz/mbit*100)
          @htimeset
          hsec=hsec2
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF wleer2<>wleer THEN
              wleer=wleer2
              b$=STR$(wleer)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            b=mbit*INT((back%-meml)/mbit)
            @intzeiger2(b)
          ENDIF
          '
          @makesmpte(point)
          '
        ENDIF
        k=@mousek
        ~FRE(0)
        @peakbreak
        IF BTST(em,0) AND (ky AND 255)=32 THEN
          @keymarkers
        ENDIF
        IF falcon=TRUE AND sloop=0 THEN
          IF back4%>=(sba%-saa%) OR back4%=0 THEN
            back3%=1
          ENDIF
        ENDIF
      UNTIL back3%=1 OR k=3 OR k=2
      @write_int(0)
      IF dspuse=TRUE THEN
        '        ~XBIOS(xbs,73,0)
        ~XBIOS(112,&H12)
        ~XBIOS(xbs,74)
        ~XBIOS(xbs,55,0)
        ~XBIOS(&H8B,0,2,0,clk,1)
        ~XBIOS(&H8B,3,11,0,clk,1)
      ENDIF
      IF dig24=TRUE THEN
        '        ~XBIOS(xbs,28,0)
      ENDIF
      IF mod96=TRUE THEN
        ~XBIOS(xbs,24,0)
      ENDIF
      IF nr=smpedit& THEN
        @intzeiger3
        @textfeld(smpsec&,sec$,1)
      ENDIF
    ENDIF
  ELSE
    back%=0
    back2%=0
  ENDIF
RETURN
'
> PROCEDURE maschinit2b
  .| Glob. Var.: mdat2%,demo#,sea%,playfifolen#,sga%,adr#,sha%,sia%,wback%
  .|     mdat%,back%
  .| Ruft auf  : busy_mouse,digout
  .| Aufruf in : maschruf18-1,maschruf18b-1,trkplay-1,arrplay-1,
  LOCAL a,g,p
  ' PLAY (fÅr Midiplay) - vorher
  '
  RESTORE anfbmasch
  FOR g=0 TO 394 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
  @busy_mouse
  IF demo=FALSE THEN
    @digout(TRUE)
    sea%=playfifolen/8-1
    sga%=adr+&H40
    sha%=adr+&H100
    sia%=wback%
  ENDIF
  IF XBIOS(xbs,1)<>&H71273800 THEN
    p=mdat%
    POKE p,7
    POKE p+1,4
    ~XBIOS(25,1,L:p)
  ENDIF
  back%=-1
RETURN
'
> PROCEDURE maschruf2c
  .| Glob. Var.: sca%,adder#,sda%,l#,sfa%,midiwort#,wback%,back%,demo#,a#,saa%
  .|     sba%,sea%,sga%,sha%,back2%,mdat2%,sia%
  .| Aufruf in : maschruf18-1,maschruf18b-1,trkplay-1,arrplay-1,
  ' PLAY (fÅr Midiplay) - jedesmal aufrufen
  sca%=adder
  sda%=l+4
  sfa%=midiwort
  LPOKE wback%,0
  LPOKE wback%+4,0
  back%=-1
  IF demo=FALSE THEN
    IF XBIOS(xbs,1)=&H71273800 THEN
      a=XBIOS(xbs,113,L:saa%,L:sba%,L:sca%,L:sda%,L:sfa%)
      back%=LPEEK(a)
      back2%=LPEEK(a+4)
    ELSE
      ~C:mdat2%(L:saa%,L:sba%,L:sca%,L:sda%,L:sea%,L:sfa%,L:sga%,L:sha%,L:sia%)
      back%=LPEEK(wback%)
      back2%=LPEEK(wback%+4)
    ENDIF
  ELSE
    back%=0
    back2%=0
  ENDIF
RETURN
'
> PROCEDURE maschinit2d
  .| Glob. Var.: mdat%
  .| Aufruf in : maschruf18-1,maschruf18b-1,trkplay-1,arrplay-1,
  LOCAL p
  ' PLAY (fÅr Midiplay) - nachher
  PAUSE 20
  p=mdat%
  POKE p,7
  POKE p+1,0
  ~XBIOS(25,1,L:p)
RETURN
'
> PROCEDURE maschruf3
  .| Glob. Var.: demo#,sab%,a#,sbb%,l#,scb%,sth#,sdb%,recfifolen#,seb%,adr#
  .|     sfb%,nr#,peak&,t#,b#,saa%,meml#,smpedit&,hsec#,hz#,peakmax&,a$
  .|     peakint#,back%,back3%,hsec2#,smpsec&,peakpos&,peakret#,sec$,edit_obj&
  .|     idx&,tree&,mdat%,mdat2%,cached#
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,peakrec
  .|     mousek,intzeiger3,rsc_message,markhlp
  .| Aufruf in : record-1,
  LOCAL p,b$
  ' RECORD
  '
  omspos=-1
  fkms=TRUE
  IF sblock=0 THEN
    kms=1
  ELSE
    kms=sms+1
  ENDIF
  IF dspuse=TRUE THEN
    @dsprec2
    '    PAUSE 20
  ENDIF
  '  @busy_mouse
  mausbm=TRUE
  IF demo=FALSE THEN
    sab%=a
    sbb%=a+l-mbit
    IF falcon=FALSE THEN
      scb%=sth
      sdb%=recfifolen/8-1
      seb%=adr+&H60
      sfb%=adr+&H100-1
    ENDIF
    IF dspuse=TRUE THEN
      sdb%=&H1000               ! war vorher 1000-1
    ENDIF
    IF XBIOS(xbs,1)=&H71273800 OR falcon=TRUE THEN
      IF falcon=FALSE THEN
        IF dspuse=FALSE THEN
          IF nr=peak& THEN
            a=XBIOS(xbs,130,0,L:sab%,L:sbb%)
          ELSE
            '
            IF dig24=TRUE THEN
              '              ~XBIOS(xbs,28,1)
            ENDIF
            IF mod96=TRUE THEN
              ~XBIOS(xbs,24,1)
            ENDIF
            '
            IF dig24=FALSE THEN
              a=XBIOS(xbs,121,0,L:sab%,L:sbb%)
            ELSE
              a=XBIOS(xbs,121,2,L:sab%,L:sbb%)   ! fÅr 24Bit-Mode
            ENDIF
          ENDIF
        ELSE
          @write_int(0)
          ~XBIOS(xbs,55,0)
          a=XBIOS(xbs,130,1,L:sab%,L:sbb%)
        ENDIF
      ELSE
        LPOKE mdat2%+4,sab%
        LPOKE mdat2%+8,0
        LPOKE mdat2%+12,0
        LPOKE mdat2%+16,0
        ~XBIOS(&H83,1,L:sab%,L:sbb%)
        ~XBIOS(&H84,1)
        ~XBIOS(&H85,0,0)
        ~XBIOS(&H86,0)
        ~XBIOS(&H87,0,0)
        IF digana=TRUE THEN
          ~XBIOS(&H8B,3,9,0,clk,1)
        ELSE
          ~XBIOS(&H8B,3,9,0,0,1)
        ENDIF
        a=4
        IF sloop=1 THEN
          a=a+8
        ENDIF
        ~XBIOS(&H88,a)
        back3%=0
      ENDIF
      PAUSE 5
      IF autorec=FALSE THEN
        '        @fifodel
      ENDIF
      IF dspuse=FALSE THEN
        IF falcon=FALSE THEN
          IF mtc=TRUE THEN
            @wait_mtc
          ENDIF
          @write_int(2)
        ENDIF
      ELSE
        '        ~XBIOS(xbs,73,0)
        ~XBIOS(112,&H12)
        ~XBIOS(xbs,55,1)
        PAUSE 5
        '        ~XBIOS(xbs,73,1)
        ~XBIOS(112,&H13)
      ENDIF
      t=TIMER
      peaktime=t
      b=mbit*INT((saa%-meml)/mbit)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      IF nr=peak& THEN
        hsec=INT(l/hz/mbit*100)
        @htimeset
        IF bigtxt=FALSE THEN
          @textfeld(peakmax&,a$,1)
        ELSE
          @bigtext(nr,a$,0)
        ENDIF
        @textfeld(recerror&,"0"+CHR$(0),1)
        @textfeld(recpeaks&,"0"+CHR$(0),1)
      ENDIF
      peakint=FALSE
      IF falcon=TRUE THEN
        peakret=mdat2%+8
        peakexit=mdat2%+12
        peakfull=mdat2%+16
      ENDIF
      REPEAT
      UNTIL @mousek=0
      rfull=0
      peaks=0
      peaks2=0
      REPEAT
        IF falcon=FALSE THEN
          peakret=a+16
          peakexit=a+8
          peakfull=a+12
          back%=LPEEK(a)
          back4%=LPEEK(a+24)
          rfull2=LPEEK(peakfull)
        ENDIF
        '
        IF falcon=FALSE AND ad=0 THEN            ! Digital Data ?
          ustart=XBIOS(xbs,151) ! Userblock DAT-Startmarke Adresse
          IF ustart<>0 AND ustart<>ustartp THEN
            ustartp=ustart
            point=INT(ustartp-meml-(recfifolen*4))
            IF point<0 THEN
              point=0
            ENDIF
            @keymarkers
          ENDIF
        ENDIF
        '
        hsec2=INT((TIMER-t)/2)
        point=INT(sab%-meml+back4%)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          IF falcon=TRUE THEN
            IF XBIOS(&H8C,0)<>0 THEN
              INC rfull2%
            ENDIF
            ~XBIOS(&H8D,L:mdat2%)
            back%=LPEEK(mdat2%+4)
            back4%=LPEEK(mdat2%+4)-sab%
          ENDIF
          hsec=INT((sab%-meml+back4%)/hz/mbit*100)
          @htimeset
          hsec=hsec2
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF rfull2<>rfull THEN
              rfull=rfull2
              b$=STR$(rfull)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            b=mbit*INT((back%-meml)/mbit)
            @intzeiger2(b)
          ENDIF
          IF nr=peak& THEN
            IF bigtxt=FALSE THEN
              @textfeld(peakpos&,a$,1)
            ELSE
              @bigtext(nr,a$,1)
            ENDIF
            IF rfull2<>rfull THEN
              rfull=rfull2
              b$=STR$(rfull)+CHR$(0)
              @textfeld(recerror&,b$,1)
            ENDIF
            IF peaks2<>peaks THEN
              peaks=peaks2
              b$=STR$(peaks)+CHR$(0)
              @textfeld(recpeaks&,b$,1)
            ENDIF
            @peakrec
          ENDIF
          '
          @makesmpte(point)
          '
        ENDIF
        k=@mousek
        ~FRE(0)
        IF falcon=FALSE THEN
          back3%=LPEEK(peakexit)
        ELSE
          IF (back4%>=(sbb%-sab%) OR back4%=0) AND sloop=0 THEN
            back3%=1
          ENDIF
        ENDIF
        @peakbreak
        IF BTST(em,0) AND (ky AND 255)=32 THEN
          @keymarkers
        ENDIF
        @read_digsrate
        IF hzc<>rwert THEN
          @makehz3
        ENDIF
      UNTIL back3%=1 OR k=3 OR k=2
      @write_int(0)
      IF dspuse=TRUE THEN
        ~XBIOS(xbs,55,0)
        '        ~XBIOS(xbs,73,0)
        ~XBIOS(112,&H12)
        ~XBIOS(xbs,74)
      ENDIF
      IF dig24=TRUE THEN
        '        ~XBIOS(xbs,28,0)
      ENDIF
      IF mod96=TRUE THEN
        ~XBIOS(xbs,24,0)
      ENDIF
      mausbm=FALSE
      IF nr=smpedit& THEN
        @intzeiger3
        @textfeld(smpsec&,sec$,1)
      ENDIF
      IF nr=peak& THEN
        a$=SPACE$(11)+CHR$(0)
        @textfeld(peakmax&,a$,1)
        @textfeld(peakpos&,a$,1)
        @setbutton(ed_obj,0)
        rsc_message(smpedit&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
        nr=smpedit&
        tree&=nr
        @markhlp
      ENDIF
    ENDIF
    cached=FALSE
  ENDIF
  fkms=FALSE
RETURN
'
> PROCEDURE maschruf3b
  .| Glob. Var.: demo#,scb%,sth#,sdb%,recfifolen#,seb%,adr#,sfb%,nr#,peak&,a#
  .|     sab%,sbb%,t#,b#,meml#,smpedit&,hsec#,l#,hz#,peakmax&,a$,peakint#
  .|     back%,back3%,hsec2#,smpsec&,peakpos&,peakret#,sec$,edit_obj&,idx&
  .|     tree&,p#,mdat%,mdat2%,cached#
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,peakrec
  .|     mousek,intzeiger3,rsc_message,markhlp
  .| Aufruf in : smpauto-1,
  ' RECORD
  '
  LOCAL b$
  '  @busy_mouse
  mausbm=TRUE
  IF demo=FALSE THEN
    scb%=sth
    sdb%=recfifolen/8-1
    seb%=adr+&H60
    sfb%=adr+&H100-1
    IF XBIOS(xbs,1)=&H71273800 THEN
      IF nr=peak& THEN
        a=XBIOS(xbs,130,0,L:sab%,L:sbb%)
      ELSE
        a=XBIOS(xbs,121,0,L:sab%,L:sbb%)
      ENDIF
      PAUSE 5
      IF autorec=FALSE THEN
        '        @fifodel
      ENDIF
      @write_int(2)
      t=TIMER
      peaktime=t
      b=mbit*INT((sab%-meml)/mbit)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      IF nr=peak& THEN
        hsec=INT(l/hz/mbit*100)
        @htimeset
        @textfeld(peakmax&,a$,1)
        @textfeld(recerror&,"0"+CHR$(0),1)
        @textfeld(recpeaks&,"0"+CHR$(0),1)
      ENDIF
      peakint=FALSE
      REPEAT
      UNTIL @mousek=0
      rfull=0
      peaks=0
      peaks2=0
      REPEAT
        peakret=a+16
        peakexit=a+8
        peakfull=a+12
        back%=LPEEK(a)
        rfull2=LPEEK(peakfull)
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF rfull2<>rfull THEN
              rfull=rfull2
              b$=STR$(rfull)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            b=mbit*INT((back%-meml)/mbit)
            @intzeiger2(b)
          ENDIF
          IF nr=peak& THEN
            @textfeld(peakpos&,a$,1)
            IF rfull2<>rfull THEN
              rfull=rfull2
              b$=STR$(rfull)+CHR$(0)
              @textfeld(recerror&,b$,1)
            ENDIF
            IF peaks2<>peaks THEN
              peaks=peaks2
              b$=STR$(peaks)+CHR$(0)
              @textfeld(recpeaks&,b$,1)
            ENDIF
            peakret=a+16
            @peakrec
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
        back3%=LPEEK(peakexit)
        @peakbreak
        IF BTST(em,0) AND (ky AND 255)=32 THEN
          @keymarkers
        ENDIF
        @read_digsrate
        IF hzc<>rwert THEN
          @makehz3
        ENDIF
      UNTIL back3%=1 OR k=3 OR k=2
      @write_int(0)
      mausbm=FALSE
      IF nr=smpedit& THEN
        @intzeiger3
        @textfeld(smpsec&,sec$,1)
      ENDIF
      IF nr=peak& THEN
        a$=SPACE$(11)+CHR$(0)
        @textfeld(peakmax&,a$,1)
        @textfeld(peakpos&,a$,1)
        @setbutton(ed_obj,0)
        rsc_message(smpedit&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
        nr=smpedit&
        tree&=nr
        @markhlp
      ENDIF
    ENDIF
    cached=FALSE
  ENDIF
  mausbm=FALSE
RETURN
'
> PROCEDURE maschruf4b
  .| Glob. Var.: demo#,tr%,th#,sac%,adr#,sbc%,a#,mdat3%,cached#
  .| Ruft auf  : maschinit4,fifodel
  .| Aufruf in : smpauto-1,
  ' RECORD AUTO-WAIT
  '
  IF demo=FALSE AND falcon=FALSE THEN
    IF dig24=FALSE THEN
      tr%=th
    ELSE
      tr%=SHL(th,8)
    ENDIF
    @fifodel
    IF XBIOS(xbs,1)=&H71273800 THEN
      a=XBIOS(xbs,111,L:tr%)
    ENDIF
    cached=FALSE
  ENDIF
RETURN
'
> PROCEDURE peakbreak
  LOCAL mx,mx,mb,mz,r%,n,shift&,c
  IF nr=peak& OR nr=smpedit& OR nr=virtual& OR nr=fsel& OR nr=arranger& OR nr=trakker& THEN
    '
    em=EVNT_MULTI(&X100011,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mb,shift&,ky,c)
    IF BTST(em,1) AND mb<>0 THEN
      mb=1
    ELSE
      mb=0
    ENDIF
    '
    IF mb=1 THEN
      r%=rsc_adr%(nr)
      obj=OBJC_FIND(r%,0,100,mx,my)
      IF (nr=peak& AND obj=playstop& AND volmake=FALSE AND balmake=FALSE) OR (nr=virtual& AND obj=virtstop&) OR (nr=smpedit& AND obj=smpstop&) OR (nr=fsel& AND (obj=fsstop& OR obj=fsend&)) OR (nr=arranger& AND obj=stop&) OR (nr=trakker& AND obj=stop2&)
        @setbutton(obj,1)
        PAUSE 1
        back3%=1
        exfill=TRUE
        REPEAT
        UNTIL @mousek=0
        @setbutton(obj,0)
        IF nr=peak& THEN
          @textfeld(recpeaks&,"0"+CHR$(0),1)
          @textfeld(recerror&,"0"+CHR$(0),1)
          @textfeld(peakname&,CHR$(0),1)
        ENDIF
        IF nr=fsel& AND obj=fsend& THEN
          fsbreak=TRUE
        ENDIF
      ENDIF
      IF (nr=smpedit& AND obj=smpwait&) OR (nr=fsel& AND obj=fswait&) OR (nr=peak& AND obj=peakwait& AND volmake=FALSE AND balmake=FALSE) OR (nr=arranger& AND obj=pause&) OR (nr=trakker& AND obj=pause2&) THEN
        @write_int(0)
        @setbutton(obj,1)
        @pausewait
      ENDIF
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE pausewait
  LOCAL mx,my,n,mb,evnt&,r%,shift&,key&,c
  REPEAT
  UNTIL @mousek=0
  r%=rsc_adr%(nr)
  REPEAT
    n=0
    REPEAT
      evnt&=EVNT_MULTI(&X100011,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mb,shift&,key&,c)
    UNTIL mb=1
    IF BTST(evnt&,1) AND mb<>0 THEN
      n=OBJC_FIND(r%,0,100,mx,my)
    ELSE
      n=0
    ENDIF
  UNTIL (nr=smpedit& AND n=smpwait&) OR (nr=fsel& AND n=fswait&) OR (nr=peak& AND n=peakwait& AND volmake=FALSE AND balmake=FALSE) OR (nr=arranger& AND n=pause&) OR (nr=trakker& AND n=pause2&)
  @write_int(intnr)
  @setbutton(n,0)
  REPEAT
  UNTIL @mousek=0
  pwait=FALSE
  obj=0
  next_obj&=0
RETURN
'
> PROCEDURE peakbreak3
  LOCAL mx,mx,mb,mz,r%,n,shift&,key&,c
  evnt&=EVNT_MULTI(&X100011,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mb,shift&,key&,c)
  IF BTST(evnt&,1) THEN
    mb=1
  ENDIF
  IF mb=1 THEN
    r%=rsc_adr%(nr)
    obj=OBJC_FIND(r%,0,100,mx,my)
    IF obj=stop2& THEN
      @setbutton(obj,1)
      back3%=1
      exfill=TRUE
      REPEAT
      UNTIL @mousek=0
      @setbutton(obj,0)
      obj=0
    ENDIF
    IF obj=pause2& THEN
      @write_int(0)
      @setbutton(obj,1)
      REPEAT
      UNTIL @mousek=0
      REPEAT
        REPEAT
          evnt&=EVNT_MULTI(&X100011,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mb,shift&,key&,c)
          IF BTST(evnt&,1) THEN
            mb=1
          ENDIF
        UNTIL mb=1
        n=OBJC_FIND(r%,0,100,mx,my)
      UNTIL obj=pause2&
      @write_int(intnr)
      @setbutton(obj,0)
      REPEAT
      UNTIL @mousek=0
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE fillpmem
  LOCAL i,membl,bw,memz
  IF memf=1 AND vmemf=0 THEN
    membl=meml1/mb
    memz=mems1
    IF adder<0 THEN
      vv=GEMDOS(66,L:offs,handle,0)
    ENDIF
    FOR i=1 TO membl
      IF firstp=FALSE THEN
        @busy_mouse
      ENDIF
      bw=GEMDOS(63,handle,L:mb,L:memz)
      IF bw=mb THEN
        memz=memz+bw
      ELSE
        exfill=TRUE
        IF (memz-mems1)<=(meme1-mems1) THEN
          sba%=memz
          one%=1
        ENDIF
        IF bw=0 THEN
          back3%=1
        ENDIF
      ENDIF
      @zeigtime
      @peakbreak
      IF BTST(em,0) AND (ky AND 255)=32 THEN
        @keymarkers
      ENDIF
      EXIT IF exfill=TRUE
    NEXT i
    offs=offs-meml2
    IF offs<0 THEN
      offs=0
    ENDIF
    IF firstp=FALSE THEN
      DEFMOUSE 0
      firstp=TRUE
    ENDIF
    vmemf=memf
  ENDIF
  IF memf=0 AND vmemf=1 THEN
    membl=meml2/mb
    memz=mems2
    IF adder<0 THEN
      vv=GEMDOS(66,L:offs,handle,0)
    ENDIF
    FOR i=1 TO membl
      bw=GEMDOS(63,handle,L:mb,L:memz)
      IF bw=mb THEN
        memz=memz+bw
      ELSE
        exfill=TRUE
        IF bw=0 THEN
          back3%=1
        ENDIF
      ENDIF
      @zeigtime
      @peakbreak
      IF BTST(em,0) AND (ky AND 255)=32 THEN
        @keymarkers
      ENDIF
      EXIT IF exfill=TRUE
    NEXT i
    offs=offs-meml1
    IF offs<0 THEN
      offs=0
    ENDIF
    vmemf=memf
  ENDIF
  @zeigtime
  @peakbreak
  IF BTST(em,0) AND (ky AND 255)=32 THEN
    @keymarkers
  ENDIF
RETURN
'
> PROCEDURE zeigtime
  IF intplay=TRUE THEN
    IF demo=FALSE THEN
      back%=LPEEK(recback+24)          ! Playbyte
      back2%=LPEEK(recback+4)       !4 Anzahl loops
      back3%=LPEEK(peakexit)  ! Breakflag
      memf=LPEEK(recback+4)        ! Memflag
      wleer2=LPEEK(peakfull)  ! Fehlerflag
    ENDIF
    point=INT(back%)
    hsec2=INT((TIMER-t)/2)
    IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
      hsec=INT((playpos+back%)/hz/mbit*100)
      @htimeset
      hsec=hsec2
      '      @busy_mouse
      IF nr=smpedit& THEN
        @textfeld(smpsec&,a$,1)
        IF wleer2<>wleer THEN
          wleer=wleer2
          b$=STR$(wleer)+CHR$(0)
          @textfeld(smprate&,b$,1)
        ENDIF
        IF nr=smpedit& AND virtual=TRUE THEN
          b=playpos+back%
          @intzeiger2(b)
        ENDIF
        @maketime
      ENDIF
      IF nr=peak& THEN
        @textfeld(peakpos&,a$,1)
        IF wleer2<>wleer THEN
          wleer=wleer2
          b$=STR$(wleer)+CHR$(0)
          @textfeld(recerror&,b$,1)
        ENDIF
        IF peaks2<>peaks THEN
          peaks=peaks2
          b$=STR$(peaks)+CHR$(0)
          @textfeld(recpeaks&,b$,1)
        ENDIF
        @peakrec
      ENDIF
      IF nr=trakker& THEN
        @edhandler5
      ENDIF
      IF nr=arranger& THEN
        @edhandler4
      ENDIF
      IF nr=fsel& THEN
        @textfeld(fstime&,a$,1)
      ENDIF
      '
      @makesmpte(point)
      '
    ENDIF
    ~FRE(0)
  ENDIF
  IF (back%>=sectors AND adder>=0) OR (-back%>=sectors AND adder<0) THEN
    @write_int(0)
    back3%=1
  ENDIF
RETURN
'
> PROCEDURE playinit
  mems1=meml
  meml1=INT(((memh-meml)-mbit)/mb/2)*mb
  meml1=INT(meml1/(adder+mbit))*(adder+mbit)
  IF meml1>g*mb THEN
    meml1=g*mb
    meml1=INT(meml1/mbit)*mbit
  ENDIF
  meml2=meml1
  meme1=mems1+meml1
  mems2=meme1
  meme2=mems2+meml2
  IF adder>=0 THEN
    saa%=mems1
    sba%=meme1
    saa2%=mems2
    sba2%=meme2
  ELSE
    saa%=meme1
    sba%=mems1
    saa2%=meme2
    sba2%=mems2
    offs=playpos-meml1
  ENDIF
  sca%=adder
  l=sret+sloop
  sda%=l
  sea%=playfifolen/8-1
  sfa%=midiwort
  sga%=adr+&H40
  sha%=adr+&H100
  sfila%=fileart
  memf=1
  vmemf=0
  recback=mdat2%
  back3%=0
  one%=0
  peakexit=recback+8    ! Break-Flag
  peakfull=recback+12   ! Fehlerflag
  peakret=recback+16    ! max. Peakwert
  zaehlpos=recback+24   ! zaehlerposition
  IF demo=FALSE THEN
    ~XBIOS(xbs,150)
  ENDIF
RETURN
'
> PROCEDURE maschrufb5
  .| Glob. Var.: demo#,mdat%,fastrec#,sad%,over#,flen#,sbd%,playfifolen#,scd%
  .|     handle#,sdd%,playpos#,sectors#,sed%,sfd%,sgd%,l#,shd%,sid%,midiwort#
  .|     sjd%,adr#,skd%,sld%,wback%,a#,t#,fxlen#,b2#,nr#,smpedit&,virtual#
  .|     sret#,sloop#,back%,back2%,back3%,hsec2#,hsec#,smpsec&,a$,b#,sec$
  .|     mdat2%
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,mousek
  .|     intzeiger3
  .| Aufruf in : newfsel-2,trakforw-2,trkbackw-2,virtual-1,mforw-2,mbackw-2,
  LOCAL p,b$,g
  ' HARDDISK-PLAY second generation (ersetzt wie maschruf5c)
  '
  vdig24=dig24
  hdp=TRUE
  IF virtual=FALSE THEN
    kms=0
  ELSE
    kms=sms
  ENDIF
  '
  IF kms>0 THEN
    IF sms2=0 AND kms=1 THEN
      kms=0
    ENDIF
  ENDIF
  '
  '  @busy_mouse
  DEFMOUSE 0
  exfill=FALSE
  firstp=FALSE
  IF dspuse=TRUE THEN
    @dspplay2
    '    PAUSE 20
  ENDIF
  IF demo=FALSE AND sectors>0 THEN
    g=8
    IF adder>mbit OR adder<(-mbit*2) THEN
      g=128
    ENDIF
    mb=32768
    mb=INT(mb/mbit)*mbit
    @playinit
    IF dspuse=TRUE THEN
      sea%=&H800-1            ! war vorher &H1000-1
    ENDIF
    v=GEMDOS(66,L:playpos,handle,0)     ! SEEK
    endcount=sectors-head
    @fillpmem
    IF nr=smpedit& AND virtual=TRUE THEN
      @intzeiger1(playpos)
    ENDIF
    IF XBIOS(xbs,1)=&H71273800 THEN
      IF dspuse=FALSE THEN
        IF pmo8=FALSE THEN
          recback=XBIOS(xbs,141,0,L:saa%,L:saa2%,L:saa2%-saa%,L:0,L:endcount,sfila%,sca%,sda%)
        ELSE
          recback=XBIOS(xbs,141,2,L:saa%,L:saa2%,L:saa2%-saa%,L:0,L:endcount,sfila%,sca%,sda%)
          ~XBIOS(xbs,27,2)
          ~XBIOS(xbs,72,14)
          '
          ~XBIOS(&H8B,0,2,0,0,0)
          ~XBIOS(&H8B,1,8,0,0,0)
          '
        ENDIF
        PAUSE 5
        IF pwait=FALSE THEN
          IF mtc=TRUE THEN
            @wait_mtc
          ENDIF
          @write_int(1)
        ELSE
          intnr=1
          @pausewait
        ENDIF
      ELSE
        ~XBIOS(xbs,55,0)
        @write_int(0)
        ~XBIOS(&H8B,0,2,0,clk,1)
        ~XBIOS(&H8B,1,8,0,clk,1)
        recback=XBIOS(xbs,141,1,L:saa%,L:saa2%,L:saa2%-saa%,L:0,L:endcount,sfila%,sca%,sda%)
        ~XBIOS(xbs,74)
        ~XBIOS(xbs,73,0)
        ~XBIOS(xbs,55,1)
      ENDIF
      intplay=TRUE
      t=TIMER
      peaktime=t
      IF nr=smpedit& THEN
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      IF nr=peak& THEN
        hsec=INT(sectors/hz/mbit*100)
        @htimeset
        @textfeld(peakmax&,a$,1)
        @textfeld(recerror&,"0"+CHR$(0),1)
        @textfeld(recpeaks&,"0"+CHR$(0),1)
      ENDIF
      peakint=FALSE
      REPEAT
      UNTIL @mousek=0
      wleer=0
      peakret=recback+16    ! max. Peakwert
      peakexit=recback+8    ! Break-Flag
      peakfull=recback+12   ! Fehlerflag
      zaehlpos=recback+24   ! zaehlerposition
      ~XBIOS(xbs,150)
      peaks=0
      peaks2=0
      REPEAT
        IF exfill=FALSE THEN
          @fillpmem
        ELSE
          @zeigtime
          @peakbreak
          IF BTST(em,0) AND (ky AND 255)=32 THEN
            @keymarkers
          ENDIF
        ENDIF
        k=@mousek
      UNTIL back3%=1 OR k=3 OR k=2
      intplay=FALSE
      @write_int(0)
      IF dspuse=TRUE THEN
        ~XBIOS(xbs,55,0)
        ~XBIOS(xbs,73,0)
        ~XBIOS(xbs,74)
        ~XBIOS(&H8B,0,2,0,clk,1)
        ~XBIOS(&H8B,3,11,0,clk,1)
      ENDIF
      IF nr=smpedit& THEN
        IF virtual=TRUE THEN
          @intzeiger3
        ENDIF
        @textfeld(smpsec&,sec$,1)
      ENDIF
      IF nr=peak& THEN
        @textfeld(recpeaks&,"0"+CHR$(0),1)
        @textfeld(recerror&,"0"+CHR$(0),1)
        @textfeld(peakname&,CHR$(0),1)
      ENDIF
    ENDIF
    IF XBIOS(xbs,1)=&H71273800 AND oldplay=FALSE THEN
      IF demo=FALSE THEN
        back%=LPEEK(zaehlpos)
      ENDIF
    ENDIF
  ENDIF
  hdp=FALSE
  dig24=vdig24
  IF dig24=FALSE THEN
    @setbitrate16
  ELSE
    @setbitrate24
  ENDIF
RETURN
'
> PROCEDURE maschinit5
  .| Glob. Var.: mdat2%
  .| Aufruf in : newfsel-2,trakforw-1,trkbackw-1,virtual-1,mforw-1,mbackw-1,
  LOCAL a,g
  ' HARDDISK-PLAY
  '
  ' 48E7FFFE                       movem.l   d0-d7/a0-a6,-(sp)
  ' 266F0040                       movea.l   64(sp),a3 ; adr
  ' 2A6F0044                       movea.l   68(sp),a5 ; len
  ' 2E2F0048                       move.l    72(sp),d7 ; handle
  ' 2C6F004C                       movea.l   76(sp),a6 ; seekbyte
  ' 242F0050                       move.l    80(sp),d2 ; sectors
  ' 2A2F0054                       move.l    84(sp),d5 ; Anzahl der For/Backstep
  ' 262F0058                       move.l    88(sp),d3 ; mode (Bit0=Loop ein/aus,Bit1=crossplay,Bit2=midi,Bit3=zusÑtzl
  '                                                            iche brkabfrage)
  ' 282F005C                       move.l    92(sp),d4 ; fifolen  (len/2/4-1) bei 8192Byte=$3FF
  ' 202F0060                       move.l    96(sp),d0 ; midi
  ' 206F0064                       movea.l   100(sp),a0          ; StatH im Bytemode
  ' 226F0068                       movea.l   104(sp),a1          ; Playread im Wordmode
  ' 286F006C                       movea.l   108(sp),a4          ; Returnwert (momentanes Playbyte & Anzahl der loops)
  ' 45FA0278                       lea.l     midisuch(pc),a2
  ' 3480                           move.w    d0,(a2)
  ' 45FA0274                       lea.l     midiw(pc),a2
  ' 24BC00000000                   move.l    #0,(a2)
  ' 4A85                           tst.l     d5
  ' 6B06                           bmi.s     backset
  ' 220B                           move.l    a3,d1     ; MEMende
  ' D28D                           add.l     a5,d1
  ' 6008                           bra.s     anf0
  ' 220B                 backset:  move.l    a3,d1
  ' 5981                           subq.l    #4,d1
  ' D7CD                           adda.l    a5,a3
  ' 598B                           subq.l    #4,a3
  ' 297C000000000008     anf0:     move.l    #0,8(a4)  ; Anzahl loops lîschen
  ' 297C000000000004               move.l    #0,4(a4)  ; Anzahl sektoren lîschen
  ' 28BC00000000                   move.l    #0,(a4)   ; playbyte lîschen
  ' 48E77FFE             anf:      movem.l   d1-d7/a0-a6,-(sp)
  ' 3F3C0000                       move.w    #0,-(sp)  ; Fseek
  ' 3F07                           move.w    d7,-(sp)
  ' 2F0E                           move.l    a6,-(sp)
  ' 3F3C0042                       move.w    #66,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000A                       lea.l     $a(sp),sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 61000044                       bsr       play
  ' 4A40                           tst.w     d0
  ' 6632                           bne.s     weg
  ' 08030001             crosstst: btst      #1,d3
  ' 6724                           beq.s     looptst
  ' 5085                           addq.l    #8,d5
  ' 4485                           neg.l     d5
  ' 2001                           move.l    d1,d0
  ' 5980                           subq.l    #4,d0
  ' 220B                           move.l    a3,d1
  ' 5881                           addq.l    #4,d1
  ' 2640                           movea.l   d0,a3
  ' 61000028                       bsr       play
  ' 4A40                           tst.w     d0
  ' 6616                           bne.s     weg
  ' 4485                           neg.l     d5
  ' 5185                           subq.l    #8,d5
  ' 2001                           move.l    d1,d0
  ' 5980                           subq.l    #4,d0
  ' 220B                           move.l    a3,d1
  ' 5881                           addq.l    #4,d1
  ' 2640                           movea.l   d0,a3
  ' 08030000             looptst:  btst      #0,d3
  ' 6702                           beq.s     weg
  ' 60AC                           bra.s     anf
  ' 288A                 weg:      move.l    a2,(a4)   ; Returnwert Playbyte speichern
  ' 29460004                       move.l    d6,4(a4)  ; Returnwert Anzahl sectors speichern
  ' 4CDF7FFF                       movem.l   (sp)+,d0-d7/a0-a6
  ' 4E75                           rts
  ' 7C00                 play:     moveq.l   #0,d6
  ' 5286                 play2:    addq.l    #1,d6
  ' 244B                           movea.l   a3,a2
  ' 48E77FFE                       movem.l   d1-d7/a0-a6,-(sp)
  ' 4A85                           tst.l     d5
  ' 6B02                           bmi.s     fseek
  ' 6018                           bra.s     fread
  ' 3F3C0001             fseek:    move.w    #1,-(sp)  ; Fseek
  ' 3F07                           move.w    d7,-(sp)
  ' 200D                           move.l    a5,d0
  ' D080                           add.l     d0,d0
  ' 4480                           neg.l     d0
  ' 2F00                           move.l    d0,-(sp)
  ' 3F3C0042                       move.w    #66,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000A                       lea.l     $a(sp),sp
  ' 200B                 fread:    move.l    a3,d0
  ' 4A85                           tst.l     d5
  ' 6A04                           bpl.s     readpos
  ' 2001                           move.l    d1,d0
  ' 5880                           addq.l    #4,d0
  ' 2F00                 readpos:  move.l    d0,-(sp)  ; Fread
  ' 2F0D                           move.l    a5,-(sp)
  ' 3F07                           move.w    d7,-(sp)
  ' 3F3C003F                       move.w    #63,-(sp)
  ' 4E41                           trap      #1
  ' 4FEF000C                       lea.l     $c(sp),sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 1010                 fill:     move.b    (a0),d0   ; FIFO halbleer ?
  ' 08000003                       btst      #3,d0
  ' 666A                           bne.s     copyanf
  ' 08030003                       btst      #3,d3     ; mehr Abbruchabfragen ?
  ' 6710                           beq.s     tstrest
  ' 08030002                       btst      #2,d3
  ' 670A                           beq.s     tstrest
  ' 610000D6                       bsr       midi
  ' 4A40                           tst.w     d0
  ' 660000CE                       bne       playex
  ' 4A85                 tstrest:  tst.l     d5
  ' 6B06                           bmi.s     tstmin
  ' 2001                           move.l    d1,d0
  ' 908A                           sub.l     a2,d0
  ' 6004                           bra.s     tstrest2
  ' 200A                 tstmin:   move.l    a2,d0
  ' 9081                           sub.l     d1,d0
  ' E480                 tstrest2: asr.l     #2,d0
  ' B044                           cmp.w     d4,d0
  ' 6ECE                           bgt.s     fill
  ' 3F07                 restplay: move.w    d7,-(sp)
  ' 3F04                           move.w    d4,-(sp)
  ' 7E08                           moveq.l   #8,d7
  ' 7804                           moveq.l   #4,d4
  ' 1010                 rest2:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     rest2
  ' 101A                           move.b    (a2)+,d0
  ' 0F80                           bclr      d7,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 rest3:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     rest3
  ' 101A                           move.b    (a2)+,d0
  ' 0F80                           bclr      d7,d0     ; Rechter Kanal (Bit 8 geloescht)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' 1010                 rest4:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     rest4
  ' 101A                           move.b    (a2)+,d0
  ' 0FC0                           bset      d7,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; High-Byte senden
  ' 1010                 rest5:    move.b    (a0),d0
  ' C004                           and.b     d4,d0
  ' 67FA                           beq.s     rest5
  ' 101A                           move.b    (a2)+,d0
  ' 0FC0                           bset      d7,d0     ; Linker Kanal (Bit 8 gesetzt)
  ' 3280                           move.w    d0,(a1)   ; Low-Byte senden
  ' D5C5                           adda.l    d5,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 674C                           beq.s     bufend
  ' 60C8                           bra.s     rest2
  ' 3004                 copyanf:  move.w    d4,d0     ; ...dann FIFO halb-fuellen (fifolen)!
  ' 3F07                           move.w    d7,-(sp)
  ' 3F04                           move.w    d4,-(sp)
  ' 7808                           moveq.l   #8,d4
  ' 1E1A                 copy:     move.b    (a2)+,d7
  ' 0987                           bclr      d4,d7     ; Rechter Kanal (Bit 8 geloescht)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 0987                           bclr      d4,d7     ; Rechter Kanal (Bit 8 geloescht)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 09C7                           bset      d4,d7     ; Linker Kanal (Bit 8 gesetzt)
  ' 3287                           move.w    d7,(a1)   ; High-Byte senden
  ' 1E1A                           move.b    (a2)+,d7
  ' 09C7                           bset      d4,d7     ; Linker Kanal (Bit 8 gesetzt)
  ' 3287                           move.w    d7,(a1)   ; Low-Byte senden
  ' D5C5                 faster:   adda.l    d5,a2
  ' B5C1                           cmpa.l    d1,a2
  ' 6724                           beq.s     bufend
  ' 51C8FFE0                       dbra      d0,copy
  ' 381F                           move.w    (sp)+,d4
  ' 3E1F                           move.w    (sp)+,d7
  ' 610000E4                       bsr       brktst
  ' 4A40                           tst.w     d0
  ' 6642                           bne.s     playex
  ' 08030002                       btst      #2,d3
  ' 6700FF52                       beq       fill
  ' 6100003A                       bsr       midi
  ' 4A40                           tst.w     d0
  ' 6632                           bne.s     playex
  ' 6000FF46                       bra       fill
  ' 381F                 bufend:   move.w    (sp)+,d4
  ' 3E1F                           move.w    (sp)+,d7
  ' BC82                           cmp.l     d2,d6
  ' 671C                           beq.s     playend
  ' 610000C0                       bsr       brktst
  ' 4A40                           tst.w     d0
  ' 661E                           bne.s     playex
  ' 08030002                       btst      #2,d3
  ' 6700FEEA                       beq       play2
  ' 61000016                       bsr       midi
  ' 4A40                           tst.w     d0
  ' 660E                           bne.s     playex
  ' 6000FEDE                       bra       play2
  ' 7000                 playend:  moveq.l   #0,d0
  ' 06AC000000010008               addi.l    #1,8(a4)
  ' 4E75                 playex:   rts
  ' 48E77FFE             midi:     movem.l   d1-d7/a0-a6,-(sp)
  ' 41FA00AA                       lea.l     midisuch(pc),a0
  ' 3410                           move.w    (a0),d2
  ' 3F02                           move.w    d2,-(sp)
  ' 3F3C0003                       move.w    #3,-(sp)  ; MIDI
  ' 3F3C0001                       move.w    #1,-(sp)  ; Bconstat
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 0C400000                       cmpi.w    #0,d0
  ' 6768                           beq.s     nomidi
  ' 3F3C0003                       move.w    #3,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)  ; Bconin
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 341F                           move.w    (sp)+,d2
  ' 3F02                           move.w    d2,-(sp)
  ' 41FA0082                       lea.l     midiw(pc),a0
  ' 08000007                       btst      #7,d0
  ' 6708                           beq.s     midi2     ; Daten oder Befehl ?
  ' E042                           asr.w     #8,d2     ; Channel im oberen Byte des Wortes
  ' 9002                           sub.b     d2,d0     ; Channel vom Befehl abziehen
  ' 1080                           move.b    d0,(a0)   ; Befehl schreiben
  ' 6046                           bra.s     nomidi
  ' B002                 midi2:    cmp.b     d2,d0     ; Noten-DATA ?
  ' 671E                           beq.s     midi4
  ' B4280001                       cmp.b     1(a0),d2  ; Noten-data schon gewesen und korrekt ?
  ' 663C                           bne.s     nomidi
  ' 11400002             midi3:    move.b    d0,2(a0)  ; Velocitywert schreiben
  ' 0C100080                       cmpi.b    #$80,(a0) ; NOTE OFF ?
  ' 671A                           beq.s     midi5
  ' 0C100090                       cmpi.b    #$90,(a0) ; NOTE ON ?
  ' 671C                           beq.s     midi6
  ' 20BC00000000         midi3b:   move.l    #0,(a0)   ; Datenwort lîschen
  ' 6024                           bra.s     nomidi
  ' B4280001             midi4:    cmp.b     1(a0),d2  ; Noten-DATA schon gewesen ?
  ' 67E2                           beq.s     midi3     ; dann ist es nicht Note sondern Velocity
  ' 11400001                       move.b    d0,1(a0)  ; Notenwert schreiben
  ' 6018                           bra.s     nomidi
  ' B4280001             midi5:    cmp.b     1(a0),d2  ; NOTE OFF und Note OK ?
  ' 66E6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 601A                           bra.s     midiex    ; Abbruch, da NOTE OFF !
  ' B4280001             midi6:    cmp.b     1(a0),d2  ; NOTE ON und Note OK ?
  ' 66DE                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 0C2800000002                   cmpi.b    #0,2(a0)  ; Velocity ist Null ?
  ' 66D6                           bne.s     midi3b    ; wenn nein, Datenwort lîschen
  ' 600A                           bra.s     midiex    ; Abbruch, da NOTE ON und Velo=Null !
  ' 341F                 nomidi:   move.w    (sp)+,d2
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 7000                           moveq.l   #0,d0
  ' 4E75                           rts
  ' 341F                 midiex:   move.w    (sp)+,d2
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 7001                           moveq.l   #1,d0
  ' 4E75                           rts
  ' 48E77FFE             brktst:   movem.l   d1-d7/a0-a6,-(sp)
  ' 3F3C0002                       move.w    #2,-(sp)
  ' 3F3C0001                       move.w    #1,-(sp)
  ' 4E4D                           trap      #13
  ' 588F                           addq.l    #4,sp
  ' 4CDF7FFE                       movem.l   (sp)+,d1-d7/a0-a6
  ' 4E75                           rts
  ' 0000                 midisuch: DC.w 0
  ' 00000000             midiw:    DC.l 0
anfgmasch:
  DATA &H48E7,&HFFFE
  DATA &H266F,&H0040
  DATA &H2A6F,&H0044
  DATA &H2E2F,&H0048
  DATA &H2C6F,&H004C
  DATA &H242F,&H0050
  DATA &H2A2F,&H0054
  DATA &H262F,&H0058
  DATA &H282F,&H005C
  DATA &H202F,&H0060
  DATA &H206F,&H0064
  DATA &H226F,&H0068
  DATA &H286F,&H006C
  DATA &H45FA,&H0278
  DATA &H3480
  DATA &H45FA,&H0274
  DATA &H24BC,&H0000,&H0000
  DATA &H4A85
  DATA &H6B06
  DATA &H220B
  DATA &HD28D
  DATA &H6008
  DATA &H220B
  DATA &H5981
  DATA &HD7CD
  DATA &H598B
  DATA &H297C,&H0000,&H0000,&H0008
  DATA &H297C,&H0000,&H0000,&H0004
  DATA &H28BC,&H0000,&H0000
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0000
  DATA &H3F07
  DATA &H2F0E
  DATA &H3F3C,&H0042
  DATA &H4E41
  DATA &H4FEF,&H000A
  DATA &H4CDF,&H7FFE
  DATA &H6100,&H0044
  DATA &H4A40
  DATA &H6632
  DATA &H0803,&H0001
  DATA &H6724
  DATA &H5085
  DATA &H4485
  DATA &H2001
  DATA &H5980
  DATA &H220B
  DATA &H5881
  DATA &H2640
  DATA &H6100,&H0028
  DATA &H4A40
  DATA &H6616
  DATA &H4485
  DATA &H5185
  DATA &H2001
  DATA &H5980
  DATA &H220B
  DATA &H5881
  DATA &H2640
  DATA &H0803,&H0000
  DATA &H6702
  DATA &H60AC
  DATA &H288A
  DATA &H2946,&H0004
  DATA &H4CDF,&H7FFF
  DATA &H4E75
  DATA &H7C00
  DATA &H5286
  DATA &H244B
  DATA &H48E7,&H7FFE
  DATA &H4A85
  DATA &H6B02
  DATA &H6018
  DATA &H3F3C,&H0001
  DATA &H3F07
  DATA &H200D
  DATA &HD080
  DATA &H4480
  DATA &H2F00
  DATA &H3F3C,&H0042
  DATA &H4E41
  DATA &H4FEF,&H000A
  DATA &H200B
  DATA &H4A85
  DATA &H6A04
  DATA &H2001
  DATA &H5880
  DATA &H2F00
  DATA &H2F0D
  DATA &H3F07
  DATA &H3F3C,&H003F
  DATA &H4E41
  DATA &H4FEF,&H000C
  DATA &H4CDF,&H7FFE
  DATA &H1010
  DATA &H0800,&H0003
  DATA &H666A
  DATA &H0803,&H0003
  DATA &H6710
  DATA &H0803,&H0002
  DATA &H670A
  DATA &H6100,&H00D6
  DATA &H4A40
  DATA &H6600,&H00CE
  DATA &H4A85
  DATA &H6B06
  DATA &H2001
  DATA &H908A
  DATA &H6004
  DATA &H200A
  DATA &H9081
  DATA &HE480
  DATA &HB044
  DATA &H6ECE
  DATA &H3F07
  DATA &H3F04
  DATA &H7E08
  DATA &H7804
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0F80
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0F80
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0FC0
  DATA &H3280
  DATA &H1010
  DATA &HC004
  DATA &H67FA
  DATA &H101A
  DATA &H0FC0
  DATA &H3280
  DATA &HD5C5
  DATA &HB5C1
  DATA &H674C
  DATA &H60C8
  DATA &H3004
  DATA &H3F07
  DATA &H3F04
  DATA &H7808
  DATA &H1E1A
  DATA &H0987
  DATA &H3287
  DATA &H1E1A
  DATA &H0987
  DATA &H3287
  DATA &H1E1A
  DATA &H09C7
  DATA &H3287
  DATA &H1E1A
  DATA &H09C7
  DATA &H3287
  DATA &HD5C5
  DATA &HB5C1
  DATA &H6724
  DATA &H51C8,&HFFE0
  DATA &H381F
  DATA &H3E1F
  DATA &H6100,&H00E4
  DATA &H4A40
  DATA &H6642
  DATA &H0803,&H0002
  DATA &H6700,&HFF52
  DATA &H6100,&H003A
  DATA &H4A40
  DATA &H6632
  DATA &H6000,&HFF46
  DATA &H381F
  DATA &H3E1F
  DATA &HBC82
  DATA &H671C
  DATA &H6100,&H00C0
  DATA &H4A40
  DATA &H661E
  DATA &H0803,&H0002
  DATA &H6700,&HFEEA
  DATA &H6100,&H0016
  DATA &H4A40
  DATA &H660E
  DATA &H6000,&HFEDE
  DATA &H7000
  DATA &H06AC,&H0000,&H0001,&H0008
  DATA &H4E75
  DATA &H48E7,&H7FFE
  DATA &H41FA,&H00AA
  DATA &H3410
  DATA &H3F02
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H0C40,&H0000
  DATA &H6768
  DATA &H3F3C,&H0003
  DATA &H3F3C,&H0002
  DATA &H4E4D
  DATA &H588F
  DATA &H341F
  DATA &H3F02
  DATA &H41FA,&H0082
  DATA &H0800,&H0007
  DATA &H6708
  DATA &HE042
  DATA &H9002
  DATA &H1080
  DATA &H6046
  DATA &HB002
  DATA &H671E
  DATA &HB428,&H0001
  DATA &H663C
  DATA &H1140,&H0002
  DATA &H0C10,&H0080
  DATA &H671A
  DATA &H0C10,&H0090
  DATA &H671C
  DATA &H20BC,&H0000,&H0000
  DATA &H6024
  DATA &HB428,&H0001
  DATA &H67E2
  DATA &H1140,&H0001
  DATA &H6018
  DATA &HB428,&H0001
  DATA &H66E6
  DATA &H601A
  DATA &HB428,&H0001
  DATA &H66DE
  DATA &H0C28,&H0000,&H0002
  DATA &H66D6
  DATA &H600A
  DATA &H341F
  DATA &H4CDF,&H7FFE
  DATA &H7000
  DATA &H4E75
  DATA &H341F
  DATA &H4CDF,&H7FFE
  DATA &H7001
  DATA &H4E75
  DATA &H48E7,&H7FFE
  DATA &H3F3C,&H0002
  DATA &H3F3C,&H0001
  DATA &H4E4D
  DATA &H588F
  DATA &H4CDF,&H7FFE
  DATA &H4E75
  DATA &H0000
  DATA &H0000,&H0000
  '
  RESTORE anfgmasch
  FOR g=0 TO 690 STEP 2
    READ a
    DPOKE mdat2%+g,a
  NEXT g
RETURN
'
> PROCEDURE maschinit5b
  .| Glob. Var.: mdat3%,demo#,sad%,mdat%,sbd%,flen#,playfifolen#,shd%,sjd%
  .|     adr#,skd%,sld%,wback%,fastrec#
  .| Ruft auf  : busy_mouse,digout
  .| Aufruf in : maschruf18b-1,trkplay-1,arrplay-1,smpplay-1,
  LOCAL g,a,p
  RESTORE anfgmasch
  FOR g=0 TO 690 STEP 2
    READ a
    DPOKE mdat3%+g,a
  NEXT g
  @busy_mouse
  IF demo=FALSE THEN
    @digout(TRUE)
    sad%=mdat%
    sbd%=flen               !len
    shd%=playfifolen/8-1
    sjd%=adr+&H40
    skd%=adr+&H100
    sld%=wback%
  ENDIF
  IF fastrec=TRUE AND XBIOS(xbs,1)<>&H71273800 THEN
    p=mdat%
    POKE p,7
    POKE p+1,4
    ~XBIOS(25,1,L:p)
  ENDIF
RETURN
'
> PROCEDURE maschruf5c
  .| Glob. Var.: demo#,fastrec#,mdat%,over#,sad%,flen#,scd%,handle#,sdd%
  .|     playpos#,sectors#,sed%,sfd%,sgd%,l#,sid%,midiwort#,a#,sbd%,shd%,sjd%
  .|     skd%,t#,fxlen#,b2#,nr#,smpedit&,virtual#,sret#,sloop#,back%,back2%
  .|     back3%,hsec2#,hsec#,smpsec&,a$,b#,sec$,mdat3%,sld%,wback%
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,mousek
  .|     intzeiger3
  .| Aufruf in : maschruf18b-2,trkplay-2,arrplay-2,smpplay-4,
  LOCAL p,b$
  ' HARDDISK-PLAY
  '
  vdig24=dig24
  omspos=-1
  @busy_mouse
  IF demo=FALSE THEN
    IF fastrec=FALSE AND XBIOS(xbs,1)<>&H71273800 THEN
      p=mdat%
      POKE p,&H12
      ~XBIOS(25,0,L:p)
    ENDIF
    IF over<0 THEN
      sad%=mdat%+flen-mbit
    ENDIF
    scd%=handle
    sdd%=playpos            !playposition
    IF sectors<=1 THEN
      sectors=2
    ENDIF
    sed%=sectors            !sectors
    sfd%=over
    '
    sgd%=l+8
    '
    sid%=midiwort
    sfa%=fileart
    IF XBIOS(xbs,1)=&H71273800 THEN
      a=XBIOS(xbs,125,L:sad%,L:sbd%,L:sed%,L:sdd%,scd%,sfa%,sfd%,sgd%)
      PAUSE 5
      IF pwait=FALSE THEN
        @write_int(1)
      ELSE
        intnr=1
        @pausewait
      ENDIF
      intplay=TRUE
      t=TIMER
      fxlen=flen/2
      b2=mbit*INT(playpos/mbit)
      IF nr=smpedit& AND virtual=TRUE AND sret=0 AND sloop=0 THEN
        @intzeiger1(b2)
      ENDIF
      IF nr=smpedit& THEN
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      REPEAT
      UNTIL @mousek=0
      wleer=0
      REPEAT
        back%=LPEEK(a+4)
        back2%=LPEEK(a+28)
        back3%=LPEEK(a+8)
        wleer2=LPEEK(a+12)
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          @busy_mouse
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF wleer2<>wleer THEN
              wleer=wleer2
              b$=STR$(wleer)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            IF virtual=TRUE AND sret=0 AND sloop=0 THEN
              b=b2+mbit*INT((back%*fxlen)/mbit)
              @intzeiger2(b)
            ENDIF
          ENDIF
          IF nr=trakker& THEN
            @edhandler5
          ENDIF
          IF nr=arranger& THEN
            @edhandler4
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
      UNTIL back3%=1 OR k=3 OR k=2
      intplay=FALSE
      @write_int(0)
      IF nr=smpedit& THEN
        IF virtual=TRUE AND sret=0 AND sloop=0 THEN
          @intzeiger3
        ENDIF
        @textfeld(smpsec&,sec$,1)
      ENDIF
    ELSE
      ~C:mdat3%(L:sad%,L:sbd%,L:scd%,L:sdd%,L:sed%,L:sfd%,L:sgd%,L:shd%,L:sid%,L:sjd%,L:skd%,L:sld%)
      back%=LPEEK(wback%+4)
    ENDIF
    IF fastrec=FALSE AND XBIOS(xbs,1)<>&H71273800 THEN
      p=mdat%
      POKE p,8
      ~XBIOS(25,0,L:p)
    ENDIF
  ELSE
    back%=0
  ENDIF
  dig24=vdig24
  IF dig24=FALSE THEN
    @setbitrate16
  ELSE
    @setbitrate24
  ENDIF
RETURN
'
> PROCEDURE maschinit5d
  .| Glob. Var.: fastrec#,mdat%
  .| Aufruf in : smpplay-1,
  LOCAL p
  ' HARDPLAY - nachher
  IF fastrec=TRUE AND XBIOS(xbs,1)<>&H71273800 THEN
    PAUSE 20
    p=mdat%
    POKE p,7
    POKE p+1,0
    ~XBIOS(25,1,L:p)
  ENDIF
RETURN
'
> PROCEDURE maschruf6
  .| Glob. Var.: demo#,sad%,playfifolen#,sbd%,adr#,scd%,a#,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : monitor-1,
  ' MONITOR
  '
  @busy_mouse
  IF demo=FALSE AND falcon=FALSE THEN
    @write_int(0)
    IF XBIOS(xbs,1)=&H71273800 THEN
      a=XBIOS(xbs,110)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE maschruf7
  .| Glob. Var.: demo#,saa%,a#,sba%,b#,sca%,adder#,sda%,l#,sea%,playfifolen#
  .|     sfa%,midiwort#,sga%,adr#,sha%,wback%,sia%,mdat%,t#,meml#,nr#,smpedit&
  .|     back%,back2%,back3%,hsec2#,hsec#,smpsec&,a$,sec$,mdat2%
  .| Ruft auf  : busy_mouse,digout,intzeiger1,htimeset,textfeld,intzeiger2
  .|     mousek,intzeiger3
  .| Aufruf in : smpplay-2,smppmhlp-2,
  LOCAL b$
  '  @busy_mouse
  ' RECPLAY
  '
  IF demo=FALSE THEN
    @digout(TRUE)
    saa%=a
    saap%=a+16384
    sba%=a+l-mbit
    sca%=sth
    sda%=0
    sea%=recfifolen/8-1
    sga%=adr+&H40
    sha%=adr+&H100-1
    sia%=adr+&H280-1
    IF XBIOS(xbs,1)=&H71273800 THEN
      a2=XBIOS(xbs,121,0,L:saa%,L:sba%)
      a=XBIOS(xbs,123,0,L:saap%,L:sba%,L:0,0,0)
      PAUSE 5
      IF mtc=TRUE THEN
        @wait_mtc
      ENDIF
      @write_int(3)
      t=TIMER
      b=mbit*INT((saa%-meml)/mbit)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      REPEAT
      UNTIL @mousek=0
      wleer=0
      REPEAT
        back%=LPEEK(a)           ! Returnwert play
        back2%=LPEEK(a2)        ! Returnwert rec
        back3%=LPEEK(a+8)        ! Break play
        back4%=LPEEK(a2+8)       ! Break rec
        wleer2=LPEEK(a+12)       ! Fehler play
        wleer3=LPEEK(a2+12)       ! Fehler rec
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          IF nr=smpedit& THEN
            @textfeld(smpsec&,a$,1)
            IF wleer3<>wleer THEN
              wleer=wleer3
              b$=STR$(wleer)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            b=mbit*INT((back%-meml)/mbit)
            @intzeiger2(b)
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
        @peakbreak
        IF BTST(em,0) AND (ky AND 255)=32 THEN
          @keymarkers
        ENDIF
      UNTIL back4%=1 OR back3%=1 OR k=3 OR k=2
      @write_int(0)
      @digout(FALSE)
      cached=FALSE
      IF nr=smpedit& THEN
        @intzeiger3
        @textfeld(smpsec&,sec$,1)
      ENDIF
      ~XBIOS(&H8B,0,0,0,clk,1)
      ~XBIOS(&H8B,1,0,0,clk,1)
      ~XBIOS(&H8B,3,11,0,clk,1)
    ENDIF
  ELSE
    back%=0
    back2%=0
  ENDIF
RETURN
'
> PROCEDURE peakbreak2
  LOCAL mx,mx,mb,shift&,c
  IF nr=peak& OR nr=smpedit& OR nr=trakker& OR nr=arranger& THEN
    em=EVNT_MULTI(&X100011,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mb,shift&,ky,c)
    IF BTST(em,1) THEN
      mb=1
    ENDIF
    IF mb=1 THEN
      r%=rsc_adr%(nr)
      obj=OBJC_FIND(r%,0,100,mx,my)
      IF (nr=peak& AND obj=playstop& AND volmake=FALSE AND balmake=FALSE) OR (nr=virtual& AND obj=virtstop&) OR (nr=smpedit& AND obj=smpstop&) OR (nr=fsel& AND obj=fsstop&) OR (nr=arranger& AND obj=stop&) OR (nr=trakker& AND obj=stop2&) THEN
        @setbutton(obj,1)
        exfill2=TRUE
        PAUSE 2
        @setbutton(obj,0)
        IF nr=peak& THEN
          @textfeld(recpeaks&,"0"+CHR$(0),1)
          @textfeld(recerror&,"0"+CHR$(0),1)
          @textfeld(peakname&,CHR$(0),1)
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  IF rsc_mtsk!=TRUE THEN
    '    @winhandler
  ENDIF
RETURN
'
> PROCEDURE fillrmem
  LOCAL i,membl,bw,memz
  brkex2=FALSE
  @zeigtime2
  IF memf=1 AND vmemf=0 THEN
    IF rch4=FALSE THEN
      membl=meml1/mb
      memz=mems1
    ELSE
      '      membl=dis1/mb
      mb=dis1
      membl=1
      '
      memz=nsaa%
      memz2=dsaa%
    ENDIF
    FOR i=1 TO membl
      @zeigtime2
      bw=GEMDOS(64,handle,L:mb,L:memz)
      IF rch4=TRUE THEN
        bw2=GEMDOS(64,dhandle,L:mb,L:memz2)
      ENDIF
      IF bw=mb THEN
        memz=memz+bw
        IF rch4=TRUE THEN
          memz2=memz2+bw
        ENDIF
        rmlen=rmlen-bw
      ELSE
        rmlen=0
      ENDIF
      @peakbreak2
      IF BTST(em,0) AND (ky AND 255)=32 THEN
        @keymarkers
      ENDIF
      IF rmlen<=0 THEN
        exfill2=TRUE
        back3%=1
      ENDIF
      '      EXIT IF exfill2=TRUE
      IF exfill2=TRUE AND brkex2=FALSE THEN
        @setbutton(ed_obj,0)
        brkex2=TRUE
      ENDIF
    NEXT i
    vmemf=memf
  ENDIF
  IF memf=0 AND vmemf=1 THEN
    IF rch4=FALSE THEN
      membl=meml2/mb
      memz=mems2
    ELSE
      '      membl=dis2/mb
      mb=dis2
      membl=1
      '
      memz=nsaa2%
      memz2=dsaa2%
    ENDIF
    FOR i=1 TO membl
      @zeigtime2
      bw=GEMDOS(64,handle,L:mb,L:memz)
      IF rch4=TRUE THEN
        bw2=GEMDOS(64,dhandle,L:mb,L:memz2)
      ENDIF
      IF bw=mb THEN
        memz=memz+bw
        IF rch4=TRUE THEN
          memz2=memz2+bw
        ENDIF
        rmlen=rmlen-bw
      ELSE
        rmlen=0
      ENDIF
      @peakbreak2
      IF BTST(em,0) AND (ky AND 255)=32 THEN
        @keymarkers
      ENDIF
      IF rmlen<=0 THEN
        exfill2=TRUE
        back3%=1
      ENDIF
      '      EXIT IF exfill2=TRUE
      IF exfill2=TRUE AND brkex2=FALSE THEN
        @setbutton(ed_obj,0)
        brkex2=TRUE
      ENDIF
    NEXT i
    vmemf=memf
  ENDIF
  @peakbreak2
  IF BTST(em,0) AND (ky AND 255)=32 THEN
    @keymarkers
  ENDIF
  IF exfill2=TRUE THEN
    exfill=TRUE
    back3%=1
  ENDIF
RETURN
'
> PROCEDURE zeigtime2
  IF demo=FALSE THEN
    back%=LPEEK(recback+24) ! ZÑhlbyte
    back3%=LPEEK(peakexit)  ! Breakflag
    back4%=LPEEK(recback)   ! Recbyte
    memf=LPEEK(recback+4)  ! Memflag
    wleer2=LPEEK(peakfull)  ! Fehlerflag
  ENDIF
  point=INT(back%)
  '
  IF brkex2=FALSE THEN
    hsec2=INT((TIMER-t)/2)
    IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
      hsec=INT(back%/hz/mbit*100)
      @htimeset
      hsec=hsec2
      IF nr=smpedit& THEN
        @textfeld(smpsec&,a$,1)
        IF wleer2<>wleer THEN
          wleer=wleer2
          b$=STR$(wleer)+CHR$(0)
          @textfeld(smprate&,b$,1)
        ENDIF
        @maketime
      ENDIF
      IF nr=peak& THEN
        @textfeld(peakpos&,a$,1)
        IF wleer2<>wleer THEN
          wleer=wleer2
          b$=STR$(wleer)+CHR$(0)
          @textfeld(recerror&,b$,1)
        ENDIF
        IF peaks2<>peaks THEN
          peaks=peaks2
          b$=STR$(peaks)+CHR$(0)
          @textfeld(recpeaks&,b$,1)
        ENDIF
        @peakrec
      ENDIF
      IF nr=trakker& THEN
        @edhandler5
      ENDIF
      IF nr=arranger& THEN
        @edhandler4
      ENDIF
      '
      @makesmpte(point)
      '
    ENDIF
  ENDIF
  ~FRE(0)
RETURN
'
> PROCEDURE hearfour
  @dspbypass
  ~XBIOS(xbs,20,1)   ! Analogeingang benutzen
  ~XBIOS(xbs,23,0)   ! Taktrate vom digitaleingang
  '
  ~XBIOS(xbs,26,1)
  ~XBIOS(&H8B,3,11,0,0,1)
  '
  POKE &HFEFF0441,0
  POKE &HFEFF0441,4
  POKE &HFEFF0441,4
  POKE &HFEFF0441,4
  POKE &HFEFF0441,4
  POKE &HFEFF0481,1+4+32
RETURN
'
> PROCEDURE maschruf8c
  LOCAL a,b,pe,a$,b$,mdigana
  ' HARDDISK-RECORD Type 2 second generation (ersetzt maschruf8b)
  '
  hdr=TRUE
  kms=0
  omspos=-1
  vdig24=dig24
  IF rch4=FALSE THEN
    IF dspuse=TRUE THEN
      @dsprec2
    ENDIF
  ELSE
    @dsprec4
    '
    IF demo=FALSE THEN
      ~XBIOS(xbs,26,1)
    ENDIF
  ENDIF
  exfill=FALSE
  exfill2=FALSE
  DEFMOUSE 0
  mausbm=TRUE
  rmlen=sectors       !max. Bytes
  pbuf2=(INT(rmlen/(128))+128)
  nopeakmem2=FALSE
  peakmem2%=@malloc(pbuf2,1)     ! Peak-Buffer
  IF peakmem2%<=0 THEN
    nopeakmem2=TRUE
  ENDIF
  IF nopeakmem2=FALSE THEN
    a$=fil$+CHR$(0)
    a=VARPTR(a$)        !Pfad
    filadr=a
    handle=GEMDOS(60,L:a,L:0)
    IF rch4=TRUE THEN
      da$=LEFT$(fil$,INSTR(fil$,".")-1)
      slash=RINSTR(da$,"\")
      IF (LEN(da$)-slash)>6 THEN
        da$=LEFT$(da$,slash)+MID$(da$,slash+1,6)
      ENDIF
      da$=da$+"_B."+RIGHT$(fil$,LEN(fil$)-INSTR(fil$,"."))
      da$=da$+CHR$(0)
      da=VARPTR(da$)        !Pfad
      dhandle=GEMDOS(60,L:da,L:0)
    ENDIF
    '
    IF rch4=TRUE THEN
      mdigana=digana
      digana=FALSE
      @makehz
    ENDIF
    @rec_headinit(a$)
    IF rch4=TRUE THEN
      digana=mdigana
      @makehz
    ENDIF
    '
    IF handle>=0 THEN
      bw=GEMDOS(64,handle,L:head,L:danf)  ! neu seit 18.5.98
      mb=8192*4
      mb=INT(mb/mbit)*mbit
      mems1=meml
      meml1=INT(((memh-meml)-mbit)/mb/2)*mb
      meml1=INT(meml1/mbit)*mbit
      meml2=meml1
      meme1=mems1+meml1
      mems2=meme1
      meme2=mems2+meml2
      saa%=mems1
      sba%=meme1
      psect%=INT(rmlen/(recfifolen/2))
      IF dspuse=TRUE THEN
        psect%=INT(rmlen/&H1000)      ! war vorher /&H1000
      ENDIF
      IF psect%=0 THEN
        psect%=1
      ENDIF
      saa2%=mems2
      sba2%=meme2
      sfila%=sfileart
      sea%=recfifolen/8-1
      IF rmo8=TRUE THEN
        sea%=recfifolen/8/4-1
        @setadatr
      ENDIF
      IF dspuse=TRUE THEN
        sea%=&H1000-1
      ENDIF
      IF rch4=TRUE THEN
        sea2%=511
      ENDIF
      sda%=sth
      sga%=adr+&H60
      sha%=adr+&H100-1
      memf=0
      vmemf=0
      recback=mdat2%
      back3%=0
      peakexit=recback+8    ! Break-Flag
      peakfull=recback+12   ! Fehlerflag
      peakret=recback+16    ! max. Peakwert
      peakmemend=recback+20 ! Ende des Peakmem-Buffers
      IF rch4=TRUE THEN
        dis1=INT((meme1-mems1)/2)
        dis1=INT(dis1/mbit)*mbit
        dis2=INT((meme2-mems2)/2)
        dis2=INT(dis2/mbit)*mbit
        nsaa%=mems1
        nsba%=mems1+dis1
        nsaa2%=mems2
        nsba2%=mems2+dis2
        dsaa%=mems1+dis1
        dsba%=mems1+dis1+dis1
        dsaa2%=mems2+dis2
        dsba2%=mems2+dis2+dis2
      ENDIF
      IF demo=FALSE THEN
        ~XBIOS(xbs,150)
      ENDIF
      '
      IF demo=FALSE THEN
        IF XBIOS(xbs,1)=&H71273800 THEN
          IF nr=peak& OR nr=smpedit& OR nr=arranger& OR nr=trakker& THEN
            IF dspuse=FALSE THEN
              IF rmo8=FALSE THEN
                IF rch4=FALSE THEN
                  recback=XBIOS(xbs,140,0,L:saa%,L:saa2%,L:saa2%-saa%,L:rmlen,sfila%,L:peakmem2%)
                ELSE
                  '
                  recback=XBIOS(xbs,143,L:nsaa%,L:nsaa2%,L:dsaa%,L:dsaa2%,L:dis1,L:rmlen,sfila%,L:peakmem2%,L:peakmem2%)
                  '
                ENDIF
              ELSE
                recback=XBIOS(xbs,140,2,rchmo,L:saa%,L:saa2%,L:saa2%-saa%,L:rmlen,sfila%,L:peakmem2%)
                '
                ~XBIOS(xbs,72,14)
                ~XBIOS(xbs,27,2)
                ~XBIOS(xbs,26,2)
                IF mixdsp=FALSE THEN
                  ~XBIOS(&H8B,2,1,0,clk,1)
                ELSE
                  IF dspmodemix=FALSE THEN
                    @dspmix8
                  ELSE
                    @dspeffmix8
                  ENDIF
                  ~XBIOS(&H8B,1,1,0,clk,1)
                  ~XBIOS(&H8B,2,2,0,clk,1)    ! Record vom external RDATA (Achtkanal)
                ENDIF
                '
              ENDIF
            ELSE
              ~XBIOS(xbs,55,0)
              @write_int(0)
              recback=XBIOS(xbs,140,1,L:saa%,L:saa2%,L:saa2%-saa%,L:rmlen,sfila%,L:peakmem2%)
            ENDIF
            peakexit=recback+8    ! Break-Flag
            peakfull=recback+12   ! Fehlerflag
            peakret=recback+16    ! max. Peakwert
            peakmemend=recback+20 ! Ende des Peakmem-Buffers
          ENDIF
          '          PAUSE 5
          IF autorec=FALSE THEN
            '            @fifodel
          ENDIF
          IF rch4=FALSE THEN
            IF dspuse=FALSE THEN
              IF mtc=TRUE THEN
                @wait_mtc
              ENDIF
              @write_int(2)
            ELSE
              ~XBIOS(xbs,55,0)
              @write_int(0)
              ~XBIOS(xbs,73,0)
              ~XBIOS(xbs,55,1)
              ~XBIOS(xbs,73,1)
            ENDIF
          ELSE
            IF mtc=TRUE THEN
              @wait_mtc
            ENDIF
            @write_int(2)
            ~XBIOS(xbs,55,0)
            PAUSE 2
            ~XBIOS(xbs,73,0)
            PAUSE 5
            @write_int(2)
            ~XBIOS(xbs,55,1)
            PAUSE 2
            ~XBIOS(xbs,73,1)
          ENDIF
          intrec=TRUE
          t=TIMER
          peaktime=t
          IF nr=smpedit& THEN
            @textfeld(smprate&,"0"+CHR$(0),1)
          ENDIF
          IF nr=peak& THEN
            '            IF rmo8=FALSE THEN
            hsec=INT(rmlen/hz/mbit*100)
            '          ELSE
            '            hsec=INT(rmlen/hz/16*100)
            '          ENDIF
            @htimeset
            @textfeld(peakmax&,a$,1)
            @textfeld(recerror&,"0"+CHR$(0),1)
            @textfeld(recpeaks&,"0"+CHR$(0),1)
          ENDIF
          peakint=FALSE
          ~XBIOS(xbs,150)
          REPEAT
          UNTIL @mousek=0
          rfull=0
          peaks=0
          peaks2=0
          REPEAT
            IF exfill=FALSE THEN
              @fillrmem
            ELSE
              @zeigtime2
              @peakbreak2
              IF BTST(em,0) AND (ky AND 255)=32 THEN
                @keymarkers
              ENDIF
            ENDIF
            k=@mousek
            @read_digsrate
            IF hzc<>rwert THEN
              @makehz3
            ENDIF
          UNTIL back3%=1 OR k=3 OR k=2
          intrec=FALSE
          @write_int(0)
          IF dspuse=TRUE OR rch4=TRUE THEN
            ~XBIOS(xbs,55,0)
            ~XBIOS(xbs,73,0)
            ~XBIOS(xbs,74)
          ENDIF
          IF nr=peak& THEN
            @textfeld(recpeaks&,"0"+CHR$(0),1)
            @textfeld(recerror&,"0"+CHR$(0),1)
            @textfeld(peakname&,CHR$(0),1)
          ENDIF
          '
          IF rch4=FALSE THEN
            s=RINSTR(fil$,".")
            a$=LEFT$(fil$,s)+peak$+CHR$(0)
            a=VARPTR(a$)        !Pfad
            phandle=GEMDOS(60,L:a,L:0)
            pe=LPEEK(peakmemend)
            b=pe-peakmem2%
            a=GEMDOS(64,phandle,L:b,L:peakmem2%)
            ~GEMDOS(62,phandle)
          ENDIF
          '
          ~MFREE(peakmem2%)
          '
          IF rmlen>0 THEN
            @zeigtime2
            IF rch4=FALSE THEN
              IF memf=0 THEN
                memz=mems1
                rmlen=back4%-mems1
              ELSE
                memz=mems2
                rmlen=back4%-mems2
              ENDIF
            ELSE
              IF memf=0 THEN
                memz=nsaa%
                rmlen=back4%-nsaa%
                memz2=dsaa%
              ELSE
                memz=mems2
                memz2=dsaa2%
                rmlen=back4%-mems2
              ENDIF
            ENDIF
            membl=INT(rmlen/mb)
            FOR i=1 TO membl
              @busy_mouse
              bw=GEMDOS(64,handle,L:mb,L:memz)
              IF rch4=TRUE THEN
                dbw=GEMDOS(64,dhandle,L:mb,L:memz2)
              ENDIF
              memz=memz+mb
              memz2=memz2+mb
            NEXT i
            DEFMOUSE 0
          ENDIF
          mausbm=FALSE
          '          PAUSE 10
          @rec_header
          IF nr=smpedit& THEN
            @textfeld(smpsec&,sec$,1)
          ENDIF
          IF nr=trakker& THEN
            @setbutton(ed_obj,0)
          ENDIF
          IF nr=peak& THEN
            a$=SPACE$(11)+CHR$(0)
            @textfeld(peakmax&,a$,1)
            @textfeld(peakpos&,a$,1)
            @setbutton(ed_obj,0)
            '          rsc_message(smpedit&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
            '          nr=smpedit&
            '          tree&=nr
            '          @markhlp
          ENDIF
        ENDIF
      ENDIF
      ~GEMDOS(62,handle)
      IF demo=FALSE THEN
        ~XBIOS(xbs,26,0)
      ENDIF
      IF rch4=TRUE THEN
        ~GEMDOS(62,dhandle)
        IF demo=FALSE THEN
          IF ad=0 THEN
            @digital
          ELSE
            @analog
          ENDIF
        ENDIF
      ENDIF
      IF rmo8=TRUE AND demo=FALSE THEN
        ~XBIOS(xbs,26,0)
        ~XBIOS(xbs,27,0)
        ~XBIOS(&H8B,3,11,0,clk,1)
        @setadatp
      ENDIF
    ENDIF
    mausbm=FALSE
  ENDIF
  hdr=FALSE
  dig24=vdig24
  IF dig24=FALSE THEN
    @setbitrate16
  ELSE
    @setbitrate24
  ENDIF
RETURN
'
> PROCEDURE adatmoni
  IF demo=FALSE THEN
    '  ~XBIOS(500,26,2)
    POKE &HFEFF0441,0
    POKE &HFEFF0441,4
    POKE &HFEFF0481,36+3
    POKE &HFEFF0441,4
    POKE &HFEFF0481,36+3
    POKE &HFEFF0441,4
    POKE &HFEFF0481,36+1
    POKE &HFEFF0441,0
    POKE &HFEFF0615,3
    '
    POKE &HFEFF0615,3+8
    pt=0
    a=XBIOS(&H86,pt)
  ENDIF
RETURN
'
> PROCEDURE maschruf9(ca,cb)
  .| Glob. Var.: cfa%,cfb%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpmhlp-18,smpcut-8,virtmove-2,sampleinf-1,make-1,trash-1
  .|     setup-1,conspace-2,coninsert-3,memtovirt-1,memtovirt2-1,makeresmp-4,
  ' CUT
  '
  @busy_mouse
  ~XBIOS(xbs,300,L:ca,L:cb)
  '  muster=&H10000
  '  INPUT muster
  ' v=XBIOS(xbs,305,L:ca,L:cb)
  IF nr<>trakker& THEN
    cached=FALSE
  ENDIF
RETURN
'
> PROCEDURE maschruf10(ca,cb,cc,cd)
  .| Glob. Var.: cfa%,cfb%,cfc%,cfd%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpkhlp-5,makeresmp-2,
  ' COPY
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  cfc%=cc
  cfd%=cd
  ~XBIOS(xbs,309,L:cfa%,L:cfb%,L:cfc%,L:cfd%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf11(ca,cb,cc)
  .| Glob. Var.: cfa%,cfb%,cfc%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpkhlp-1,
  ' BACK-COPY
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  cfc%=cc
  ~XBIOS(xbs,311,L:cfa%,L:cfb%,L:cfc%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf12(ca,cb)
  .| Glob. Var.: cfa%,cfb%,wback%,cfc%,mdat2%,back%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : normtest-3,
  ' PEAK-SUCH
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  back%=XBIOS(xbs,312,L:cfa%,L:cfb%)
RETURN
'
> PROCEDURE maschruf13(ca,cb,cc,cd)
  LOCAL j,shft
  .| Glob. Var.: cfa%,cfb%,cfc%,cfd%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : makenorm-2,
  ' NORMALIZE
  '
  @busy_mouse
  IF dig24=TRUE THEN
    j=1
    shft=0
    REPEAT
      IF j<cd THEN
        j=j*2
        INC shft
      ENDIF
    UNTIL j>=cd
    cc=INT(j*cc/cd)
    cd=shft
  ENDIF
  cfa%=ca
  cfb%=cb
  cfc%=cc
  cfd%=cd
  ~XBIOS(xbs,313,L:cfa%,L:cfb%,L:cfc%,L:cfd%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf16(a,b,c,d,e,f)
  .| Glob. Var.: saa%,sba%,sca%,sda%,sea%,sfa%,wback%,sga%,mdat2%,back%
  .|     cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : arr_resmp-1,makeresmp-5,
  ' RESAMPLE
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  ' c - destanf
  ' d - destende
  ' e - source-sample-rate (320,441,480)
  ' f - dest-sample-rate (320,441,480)
  ' back% - destende-RETURN-Wert
  '
  saa%=a
  sba%=b
  sca%=c
  sda%=d
  sea%=e
  sfa%=f
  back%=XBIOS(xbs,314,L:saa%,L:sba%,L:sca%,L:sda%,sea%,sfa%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf17(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : mono-3,
  ' MONO
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~XBIOS(xbs,315,L:saa%,L:sba%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf18
  .| Glob. Var.: saa%,a#,sba%,b#,sret#,adder#,l#,sloop#,raus#,x#,y#,v#,v2#,v3#
  .|     v4#,xx#,ch#,xx2#,note#,xx3#,yy#,demo#
  .| Ruft auf  : digout,maschinit2b,maschruf2c,maschinit2d
  .| Aufruf in : smpplay-2,smppmhlp-2,
  ' MIDI-PLAY,MIDI-BACKPLAY,MIDI-CROSSPLAY
  '
  ' a - sourceanf
  ' b - sourceende
  ' l - LÑnge
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  @digout(TRUE)
  saa%=a
  sba%=b
  @maschinit2b
  REPEAT
    IF sret=0 THEN
      adder=0
      l=0
    ENDIF
    IF sret=1 THEN
      adder=-mbit*2
      l=0
    ENDIF
    IF sret=2 THEN
      adder=0
      l=2
    ENDIF
    IF sloop=1 THEN
      l=l+1
    ENDIF
    raus=FALSE
    REPEAT
      x=INP?(3)
      y=INP?(2)
      ~GRAF_MKSTATE(v,v2,v3,v4)
      IF x=TRUE AND v3<>2 THEN
        xx=INP(3)
        IF xx=&H90+(ch-1) THEN
          REPEAT
            x=INP?(3)
            y=INP?(2)
            ~GRAF_MKSTATE(v,v2,v3,v4)
          UNTIL x=TRUE OR y=TRUE OR v3=2
          IF y=FALSE AND x=TRUE AND v3<>2 THEN
            xx2=INP(3)
            IF xx2=note AND v3<>2 THEN
              REPEAT
                x=INP?(3)
                y=INP?(2)
                ~GRAF_MKSTATE(v,v2,v3,v4)
              UNTIL x=TRUE OR y=TRUE OR v3=2
              IF y=FALSE AND x=TRUE AND v3<>2 THEN
                xx3=INP(3)
                IF xx=&H90+(ch-1) AND xx2=note AND xx3<>0 THEN
                  raus=TRUE
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      IF y=TRUE AND v3<>2 THEN
        yy=INP(2)
      ENDIF
      ~GRAF_MKSTATE(v,v2,v3,v4)
    UNTIL y=TRUE OR raus=TRUE OR v3=2
    IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
      @maschruf2c
    ENDIF
    ~GRAF_MKSTATE(v,v2,v3,v4)
  UNTIL v3=2 OR y=TRUE OR INP?(2)=TRUE
  @maschinit2d
RETURN
'
> PROCEDURE maschruf18b
  .| Glob. Var.: lmax2#,n#,midiwort#,raus#,x#,y#,v#,v2#,v3#,v4#,xx#,xx2#,xx3#
  .|     ch#,note#,z#,vch#,vnote#,l#,saa%,meml#,sba%,adder#,yy#,demo#,vhz#,pa$
  .|     sectors#,handle#,playpos#,flen#,over#
  .| Felder    : midi#(),arrmidi#(),arrpath$(),arrloop#(),arrtri#(),arrstrt#()
  .|     arrend#(),arrsrate#()
  .| Ruft auf  : busy_mouse,digout,maschinit2b,maschinit5b,swtosrate
  .|     maschruf2c,maschruf5c,maschinit2d
  .| Aufruf in : arrmidplay-2,
  LOCAL i,j,m
  ' ARR-MIDIPLAY,ARR-MIDICROSSPLAY,ARR-MIDIBACKPLAY
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  ' l - LÑnge
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  @digout(TRUE)
  @maschinit2b
  @maschinit5b
  FOR j=0 TO 15
    FOR i=0 TO 127
      midi(j,i)=0
    NEXT i
  NEXT j
  FOR i=1 TO lmax2
    m=(arrmidi(i) AND 255)
    n=INT(midiwort/256)
    IF m>=0 AND m<128 AND n>=0 AND n<16 THEN
      IF midi(n,m)=0 THEN
        midi(n,m)=i
      ENDIF
    ENDIF
  NEXT i
  REPEAT
    raus=FALSE
    REPEAT
      x=INP?(3)
      y=INP?(2)
      ~GRAF_MKSTATE(v,v2,v3,v4)
      IF x=TRUE AND v3<>2 THEN
        xx=INP(3)
        IF xx>=&H90 AND xx<=&H9F THEN     ! xx-&H90 = channel
          REPEAT
            x=INP?(3)
            y=INP?(2)
            ~GRAF_MKSTATE(v,v2,v3,v4)
          UNTIL x=TRUE OR y=TRUE OR v3=2
          IF y=FALSE AND x=TRUE AND v3<>2 THEN
            xx2=INP(3)
            IF v3<>2 THEN             ! xx2 = note
              REPEAT
                x=INP?(3)
                y=INP?(2)
                ~GRAF_MKSTATE(v,v2,v3,v4)
              UNTIL x=TRUE OR y=TRUE OR v3=2
              IF y=FALSE AND x=TRUE AND v3<>2 THEN
                xx3=INP(3)
                IF xx>=&H90 AND xx<=&H9F AND xx3<>0 THEN
                  ch=xx-&H90
                  note=xx2
                  z=midi(ch,note)
                  midiwort=arrmidi(z)
                  vch=INT(midiwort/256)
                  vnote=midiwort AND 255
                  ~GRAF_MKSTATE(v,v2,v3,v4)
                  IF vch=ch AND vnote=note AND arrpath$(z)<>"" THEN
                    IF arrloop(z)=0 THEN
                      l=0
                    ELSE
                      l=1
                    ENDIF
                    IF arrtri(z)=0 OR arrtri(z)=2 THEN
                      saa%=arrstrt(z)+meml
                      sba%=arrend(z)+meml
                      adder=0
                      IF arrtri(z)=2 THEN
                        l=l+2
                      ENDIF
                    ENDIF
                    IF arrtri(z)=1 THEN
                      sba%=arrstrt(z)+meml
                      saa%=arrend(z)+meml
                      IF arrpath$(z)="MEMORY" THEN
                        adder=-mbit*2
                      ENDIF
                    ENDIF
                    raus=TRUE
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      ~GRAF_MKSTATE(v,v2,v3,v4)
      IF y=TRUE AND v3<>2 THEN
        yy=INP(2)
      ENDIF
    UNTIL y=TRUE OR raus=TRUE OR v3=2
    IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
      IF arrpath$(z)="MEMORY" THEN
        vhz=arrsrate(z)
        @swtosrate(vhz)
        @maschruf2c
      ENDIF
      IF arrpath$(z)<>"MEMORY" AND arrpath$(z)<>"" THEN
        pa$=arrpath$(z)+CHR$(0)
        sectors=arrend(z)-arrstrt(z)
        handle=GEMDOS(61,L:VARPTR(pa$),0)
        IF arrtri(z)=0 OR arrtri(z)=2 THEN
          playpos=arrstrt(z)*flen
          vhz=arrsrate(z)
          @swtosrate(vhz)
          over=0
          l=arrloop(z)+4
          IF arrtri(z)=2 THEN
            l=l+2
          ENDIF
          @maschruf5c
        ENDIF
        IF arrtri(z)=1 THEN
          playpos=arrend(z)*flen
          vhz=arrsrate(z)
          @swtosrate(vhz)
          l=arrloop(z)+4
          over=-mbit*2
          @maschruf5c
        ENDIF
        ~GEMDOS(62,handle)
      ENDIF
    ENDIF
    ~GRAF_MKSTATE(v,v2,v3,v4)
  UNTIL v3=2 OR y=TRUE OR INP?(2)<>0
  @maschinit2d
RETURN
'
> PROCEDURE maschruf18c
  .| Glob. Var.: midiwort#,ch#,note#,sda%,raus#,x#,y#,v#,v2#,v3#,v4#,xx#,xx2#
  .|     xx3#,yy#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpplay-2,
  ' MIDI-WAIT
  '
  @busy_mouse
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  midiwort=(ch-1)*256+note
  sda%=midiwort
  raus=FALSE
  REPEAT
    x=INP?(3)
    y=INP?(2)
    ~GRAF_MKSTATE(v,v2,v3,v4)
    IF x=TRUE AND v3<>2 THEN
      xx=INP(3)
      IF xx=&H90+(ch-1) THEN
        REPEAT
          x=INP?(3)
          y=INP?(2)
          ~GRAF_MKSTATE(v,v2,v3,v4)
        UNTIL x=TRUE OR y=TRUE OR v3=2
        IF y=FALSE AND x=TRUE AND v3<>2 THEN
          xx2=INP(3)
          IF xx2=note AND v3<>2 THEN
            REPEAT
              x=INP?(3)
              y=INP?(2)
              ~GRAF_MKSTATE(v,v2,v3,v4)
            UNTIL x=TRUE OR y=TRUE OR v3=2
            IF y=FALSE AND x=TRUE AND v3<>2 THEN
              xx3=INP(3)
              IF xx=&H90+(ch-1) AND xx2=note AND xx3<>0 THEN
                raus=TRUE
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    IF y=TRUE AND v3<>2 THEN
      yy=INP(2)
    ENDIF
    ~GRAF_MKSTATE(v,v2,v3,v4)
  UNTIL y=TRUE OR raus=TRUE OR v3=2 OR INP?(2)=TRUE
RETURN
'
> PROCEDURE maschruf28(start,datalen)
  .| Glob. Var.: sad%,sbd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpsave-2,ldhlp-1,
  ' LOAD-INTEL-DATA
  '
  @busy_mouse
  sad%=start
  sbd%=start+datalen
  ~XBIOS(xbs,316,L:sad%,L:sbd%)
RETURN
'
> PROCEDURE maschruf29(start,dest)
  .| Glob. Var.: sad%,sbd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : make-2,
  ' COPYBACK
  '
  @busy_mouse
  sad%=start
  sbd%=dest
  ~XBIOS(xbs,317,L:sad%,L:sbd%)
RETURN
'
> PROCEDURE maschruf30(daten,werte,von,bis)
  .| Glob. Var.: sad%,sbd%,scd%,meml#,sdd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : fade_it-3,
  ' FADE IN&OUT
  '
  @busy_mouse
  sad%=daten
  sbd%=werte
  scd%=INT((meml+von)/mbit)*mbit
  sdd%=INT((meml+bis)/mbit)*mbit
  sed%=INT((sdd%-scd%)/mbit/werte)
  ~XBIOS(xbs,303,L:sad%,sbd%,L:scd%,L:sdd%,L:sed%)
RETURN
'
> PROCEDURE maschruf31
  .| Glob. Var.: virtual#,sac%,i#,sbc%,stp#,vcs#,mdat2%,a#,am#
  .| Aufruf in : curve-2,hardproof2-2,
  ' MITTEL2/Hîchstwert berechnen
  '  LOCAL p
  '
  IF virtual=FALSE THEN
    sac%=i
    sbc%=i+stp
  ELSE
    sac%=i-vcs
    sbc%=(i+stp)-vcs
  ENDIF
  p=XBIOS(xbs,308,L:sac%,L:sbc%)
  a=LPEEK(p)
  am=LPEEK(p+4)
  IF dig24=TRUE THEN
    a=SHR(a,8)
    am=SHR(am,8)
  ENDIF
RETURN
'
> PROCEDURE maschruf32(ca,cb,cc)
  .| Glob. Var.: cfa%,meml#,cfb%,cfc%,back%,wback%,cfd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : fade_it-4,springart-4,
  ' ZERONO
  '
  @busy_mouse
  cfa%=INT((meml+ca)/mbit)*mbit
  cfb%=INT((meml+cb)/mbit)*mbit
  cfc%=cc
  back%=XBIOS(xbs,302,L:cfa%,L:cfb%,cfc%)
  IF back%>=0 THEN
    back%=INT((back%-meml)/mbit)*mbit
  ENDIF
  IF back%<0 THEN
    back%=-1
  ENDIF
RETURN
'
> PROCEDURE maschruf33(ca,cb,cc)
  .| Glob. Var.: cfa%,meml#,cfb%,cfc%,back%,wback%,cfd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : springart-4,
  ' ZERO
  '
  @busy_mouse
  cfa%=INT((meml+ca)/mbit)*mbit
  cfb%=INT((meml+cb)/mbit)*mbit
  cfc%=cc
  back%=XBIOS(xbs,318,L:cfa%,L:cfb%,cfc%)
  IF back%<>-1 THEN
    back%=INT((back%-meml)/mbit)*mbit
  ENDIF
  IF back%<0 AND back%<>-1 THEN
    back%=-1
  ENDIF
RETURN
'
> PROCEDURE maschruf34(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : negate-3,
  ' NEGATE
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~XBIOS(xbs,319,L:saa%,L:sba%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf35(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : lrchange-3,
  ' Left/Right-Change LRCHANGE
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~XBIOS(xbs,320,L:saa%,L:sba%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf36(l,h,l2,h2,hdl,VAR ret)
  .| Glob. Var.: saa%,sba%,sca%,sda%,sea%,mdat2%,mdat3%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : sdsave-2,
  ' Save Mono  SDMONO
  '
  @busy_mouse
  saa%=l
  sba%=h
  sca%=l2
  sda%=h2
  sea%=hdl
  ret=XBIOS(xbs,321,L:saa%,L:sba%,L:sca%,L:sda%,sea%)
RETURN
'
> PROCEDURE maschruf37(l,h,l2,h2,hdl,VAR ret)
  .| Glob. Var.: saa%,sba%,sca%,sda%,sea%,mdat2%,mdat3%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : sdload-2,
  ' Load 2xMono  SDSTEREO
  '
  @busy_mouse
  saa%=l
  sba%=h
  sca%=l2
  sda%=h2
  sea%=hdl
  ret=XBIOS(xbs,322,L:saa%,L:sba%,L:sca%,L:sda%,sea%)
RETURN
'
> PROCEDURE maschruf38(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : sdsave-2,ldhlp-1,
  ' WAVALON
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~XBIOS(xbs,323,L:saa%,L:sba%)
  cached=FALSE
RETURN
' ------------------------------------------------------------------------------
' ------------------------FLYDIALS--------------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE key
  .| Glob. Var.: key&,edit_obj&,cont&,rsc_adr%,next_obj&,idx&,obj&,mrkhandle2#
  .|     v1#,v2#,v3#,ascii|,scan|,a#,shift&,title&,shcut#,nob#,nr#,keytab%,a&
  .|     a$,tree&,evnt&,mb&,mx&,my&
  .| Felder    : rsc_adr%()
  .| Ruft auf  : form_keybd,rsc_shortcut
  .| Aufruf in : rsc_do-1,
  LOCAL bs
  ' Mîchten Sie erweiterte Tastaturkommandos? Dann entREMen Sie
  ' diese Zeile und ersetzen die Prozedur durch:
  '  IF key& AND edit_obj&<>0     ! vorher so....
  IF (key& AND edit_obj&<>0) OR (((key& AND 255)=13) AND ((key& DIV 256)<>50))    ! jetzt so....
    cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  ENDIF
  '  cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  '
  obj&=0
  ~WIND_GET(MENU(4),10,mrkhandle2,v1,v2,v3)
  '  ~WIND_GET(mrkhandle,10,mrkhandle2,v1,v2,v3)
  '
  ascii|=BYTE(key&)                                  ! ASCII-Code
  scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
  a=@rsc_shortcut(dropdown&,scan|,shift&,title&)
  shcut=FALSE
  IF a<>0 THEN
    nob=a
    obj&=a
    shcut=TRUE
  ELSE
    mscan=scan|
  ENDIF
  '
  rsc_adr%=rsc_adr%(nr)
  IF ascii|=0                                        ! Kein ASCII-Code...
    '
    IF scan|=97 OR scan|=98                          ! UNDO/HELP...
      ascii|=ADD(SUB(scan|,97),14)
      mb&=0
      obj&=0
      '
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
      '
      IF BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE IF scan|>=59 AND scan|<=68                  ! F-Tasten...
      ascii|=SUB(scan|,58)
      obj&=0
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
      IF SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE                                             ! ALT+Buchstabe...
      '
      IF scan|>=120 AND scan|<=129                   ! Zahlen...
        SUB scan|,118
        keytab%={XBIOS(16,L:-1,L:-1,L:-1)}           ! ...ohne Shift
      ELSE                                           ! Alles andere...
        keytab%={ADD(XBIOS(16,L:-1,L:-1,L:-1),4)}    ! ...mit Shift
      ENDIF
      '
      ascii|=BYTE{ADD(keytab%,scan|)}                ! ASCII-Code holen
      IF ascii|<>0                                      ! Tastaturbedienbar...
        CLR a&,obj&
        '
        DO WHILE NOT BTST(OB_FLAGS(rsc_adr%,obj&),5) ! Nicht LASTOBJ
          INC obj&
          '
          scan|=BYTE(SHR(OB_TYPE(rsc_adr%,obj&),8))
          IF scan|=26 OR scan|=28                    ! Ein Button/String...
            a$=@rsc_text$(tree&,obj&)                ! ...Text
            '
            a&=INSTR(a$,"[")
            IF a&                                    ! Tastaturbedienbar...
              a&=ASC(MID$(a$,SUCC(a&),1))
              a&=(BCLR(a&,5)=ascii|) OR (a&>=48 AND a&<=57 AND a&=ascii|)
            ENDIF
            '                                        ! '[' vor Zeichen
          ENDIF
          '
        LOOP UNTIL a&                                ! ...gefunden
        '
        IF a&                                        ! Objekt gefunden...
          key&=0                                     ! ...keine Eingabe mehr
          mb&=0
          '                                          ! +SHIFT Circle-Butt?
          IF BTST(shift&,1) AND BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5) AND SHR(OB_TYPE(rsc_adr%,obj&+2),8)=27
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simulieren
            ~OBJC_OFFSET(rsc_adr%,obj&+2,mx&,my&)
            '                                        ! Ist es ein Popup...
          ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5)
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simul.
            ~OBJC_OFFSET(rsc_adr%,obj&,mx&,my&)
          ELSE                                       ! ...Button bedienen
            cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
          ENDIF
        ENDIF
        '
      ENDIF
    ENDIF
    '
  ENDIF
  '
  IF next_obj&<>0 AND edit_obj&<>next_obj&
    ~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,3,idx&)  ! ...Eingabe
  ENDIF
  '  obj=obj&
  '
  IF shcut=FALSE THEN
    @shortcuts
  ENDIF
RETURN
> PROCEDURE vor_update
  nr=a
  @markhlp
  ~WIND_GET(ha1,11,x1,y1,b1,h1)
  CLIP x1,y1,b1,h1
  ~WIND_UPDATE(1)                                    ! BEG_UPDATE
  ~WIND_UPDATE(3)                                    ! BEG_UPDATE
  cupdate=TRUE
RETURN
> PROCEDURE nach_update
  cupdate=FALSE
  ~WIND_UPDATE(0)                                    ! BEG_UPDATE
  ~WIND_UPDATE(2)                                    ! BEG_UPDATE
  CLIP OFF
  nr=mnr
  @markhlp
RETURN
PROCEDURE message
  .| Glob. Var.: handle&,a&,rsc_trees&,accwindopen#,tree&,rsc_window&
  .|     next_obj&,edit_obj&,idx&,nr#,peak&,peakint#,mx#,my#,mz#,rsc_adr%,n#
  .|     butdirect#,butnr#,donr#,h#,a#,smpedit&,mnr#,cs#,ce#
  .| Felder    : rsc_handle%(),rsc_adr%()
  .| Ruft auf  : markhlp,rsc_message,mouse,button,rsc_redraw_obj,curve
  .|     markprod3
  .| Aufruf in : rsc_do-1,helptxt-2,
  LOCAL iz,a,a&,n,h,ha1,x1,y1,b1,h1
  IF nr=1 AND iconify=FALSE THEN
    @markhlp
  ENDIF
  handle&=MENU(4)                                    ! ...Fenster-Handle
  '
  FOR a&=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
    EXIT IF handle&=rsc_handle%(a&)
  NEXT a&
  '
  '  IF handle&=rsc_handle%(a&) THEN
  '  mywindow=TRUE
  '  wind_active=a&
  ' ELSE
  '  mywindow=FALSE
  '  wind_active=0
  ' ENDIF
  '
  IF MENU(1)=&H4724 THEN
    accwindopen=TRUE
  ENDIF
  IF MENU(1)=27                                 ! Fenster vergrîûern...
    IF handle&=rsc_handle%(a&) THEN
      tree&=a&
      IF tree&=smpedit& THEN
        xneu=MENU(5)
        yneu=MENU(6)
        bneu=MENU(7)
        hneu=MENU(8)
        @calc_editsize
      ENDIF
      IF tree&=peak& THEN
        xneu2=MENU(5)
        yneu2=MENU(6)
        bneu2=MENU(7)
        hneu2=MENU(8)
        @calc_peaksize
      ENDIF
      IF tree&=trakker& THEN
        xneu3=MENU(5)
        yneu3=MENU(6)
        bneu3=MENU(7)
        hneu3=MENU(8)
        @calc_traksize
      ENDIF
    ENDIF
  ENDIF
  IF MENU(1)=23                                 ! Fenster auf volle Grîûe...
    IF handle&=rsc_handle%(a&) THEN
      tree&=a&
      IF tree&=smpedit& THEN
        IF rscw&(tree&)=xwidth AND rsch&(tree&)=ywidth-3 AND bold<>0 AND hold<>0 THEN
          IF bold<>0 AND hold<>0 THEN
            bneu=bold
            hneu=hold
          ENDIF
        ELSE
          xold=rscx&(tree&)
          yold=rscy&(tree&)
          bold=rscw&(tree&)
          hold=rsch&(tree&)
          IF yold<19 THEN
            yold=19
          ENDIF
          IF hold>ywidth-19 THEN
            hold=ywidth-19
          ENDIF
          xneu=0
          yneu=19
          bneu=xwidth
          hneu=ywidth-19
        ENDIF
        @calc_editsize
      ENDIF
      IF tree&=peak& THEN
        IF rsch&(tree&)=ywidth-3 AND bold2<>0 AND hold2<>0 THEN
          IF bold2<>0 AND hold2<>0 THEN
            bneu2=bold2
            hneu2=hold2
          ENDIF
        ELSE
          xold2=rscx&(tree&)
          yold2=rscy&(tree&)
          bold2=rscw&(tree&)
          hold2=rsch&(tree&)
          IF yold2<19 THEN
            yold2=19
          ENDIF
          IF hold2>ywidth-19 THEN
            hold2=ywidth-19
          ENDIF
          xneu2=0
          yneu2=19
          bneu2=xwidth
          hneu2=ywidth-19
        ENDIF
        @calc_peaksize
      ENDIF
      IF tree&=trakker& THEN
        IF rscw&(tree&)=xwidth AND rsch&(tree&)=INT((ywidth-3)/4)*4 AND bold3<>0 AND hold3<>0 THEN
          IF bold3<>0 AND hold3<>0 THEN
            bneu3=bold3
            hneu3=hold3
          ENDIF
        ELSE
          xold3=rscx&(tree&)
          yold3=rscy&(tree&)
          bold3=rscw&(tree&)
          hold3=rsch&(tree&)
          IF yold3<19 THEN
            yold3=19
          ENDIF
          IF hold3>ywidth-19 THEN
            hold3=ywidth-19
          ENDIF
          xneu3=0
          yneu3=19
          bneu3=xwidth
          hneu3=ywidth-19
        ENDIF
        @calc_traksize
      ENDIF
    ENDIF
  ENDIF
  IF MENU(1)=41 OR (MENU(1)=22 AND tree&=a&)         ! AC_CLOSE/Closer...
    MUL rsc_window&,-(MENU(1)=22)
    '
    next_obj&=9999                                   ! ...Exit-Code
    '
    GOTO rsc_dox_ende                                ! ...rsc_do verlassen
    '
  ELSE IF a&>-1 AND NOT (MENU(1)=21 AND a&<>tree&)   ! Ein RSC-Fenster....
    rsc_message(a&,MENU(1),MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    '
  ELSE IF MENU(1)=40 OR MENU(1)=21                   ! AC_OPEN/Anderes Fenster toppen...
    '
    IF a&<>-1 THEN
      IF handle&=rsc_handle%(a&) THEN
        tree&=a&
        IF nr=wmode& THEN
          edit_obj&=0
        ENDIF
        IF nr=smpedit& OR nr=smp16& THEN
          nonhz=hz
        ENDIF
        IF nr=peak& OR nr=info& THEN
          intplay=FALSE
          @write_int(0)
          IF nr=info& THEN
            hz=nonhz
            @fliphz2
            @digout(nbypmode)
          ENDIF
        ENDIF
        nr=tree&
        IF nr=peak& THEN
          peakint=FALSE
        ENDIF
        @mouse(mx,my,mz)
        rsc_adr%=rsc_adr%(tree&)
        n=OBJC_FIND(rsc_adr%,0,100,mx,my)
        IF n<>0 AND n<>-1 THEN
          @button
          butdirect=TRUE
          butnr=donr
        ENDIF
        '        @rsc_redraw_obj(nr,0)
      ENDIF
    ENDIF
    '
    rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    @markhlp                ! neu
    IF nr=arranger& THEN
      IF adrag=TRUE THEN
        @setbutton(arrclip&,1)
      ELSE
        @setbutton(arrclip&,0)
      ENDIF
    ENDIF
    IF nr=info& THEN
      nonhz=hz
    ENDIF
    IF nr=trakker& THEN
      wpl=0   ! peakhold left
      wpr=0   ! peakhold right
      @trakvolinit
      IF tdrag=TRUE OR trdrag=TRUE THEN
        @setbutton(trakclip&,1)
      ELSE
        @setbutton(trakclip&,0)
      ENDIF
      IF hz<>thz THEN
        thz=hz
        IF trkz>0 THEN
          @wischwasch
          @timeline
          @tractdraw
        ENDIF
      ENDIF
    ENDIF
    IF nr=smpedit& THEN
      IF dig24=FALSE THEN
        @textfeld(resolu&,"16 BIT"+CHR$(0),1)
      ELSE
        @textfeld(resolu&,"24 BIT"+CHR$(0),1)
      ENDIF
      IF idrag=TRUE THEN
        @setbutton(flyer&,1)
      ELSE
        @setbutton(flyer&,0)
      ENDIF
      IF hrd=1 THEN
        @setbutton(hard&,1)
      ELSE
        @setbutton(hard&,0)
      ENDIF
      '      IF trkmemr=TRUE THEN
      '      @getmem
      '      trkmemr=FALSE
      '    ENDIF
    ENDIF
    IF nr=smp16& THEN
      @makehz
      @sethertz
    ENDIF
    IF nr=wmode& THEN
      edit_obj&=0
    ENDIF
    IF nr=peak& THEN
      wpl=0   ! peakhold left
      wpr=0   ! peakhold right
      @volinit
      IF hrd=1 THEN
        @setbutton(hardpeak&,1)
      ELSE
        @setbutton(hardpeak&,0)
      ENDIF
      IF adat=TRUE OR rch8=TRUE THEN
        @hidetree(peakch1&,FALSE,peakbox&)
        @hidetree(peakch2&,FALSE,peakbox&)
        @hidetree(peakch3&,FALSE,peakbox&)
        @hidetree(peakch4&,FALSE,peakbox&)
      ELSE
        @hidetree2(peakch1&,TRUE)
        @hidetree2(peakch2&,TRUE)
        @hidetree2(peakch3&,TRUE)
        @hidetree2(peakch4&,TRUE)
        @rsc_redraw_obj(nr,0)
        IF rchmo=0 THEN
          @setbutton(peakch1&,1)
        ENDIF
        IF rchmo=1 THEN
          @setbutton(peakch2&,1)
        ENDIF
        IF rchmo=2 THEN
          @setbutton(peakch3&,1)
        ENDIF
        IF rchmo=3 THEN
          @setbutton(peakch4&,1)
        ENDIF
      ENDIF
    ENDIF
    '
  ELSE IF MENU(1)<>21 AND MENU(1)<>22                ! nicht toppen/schlieûen...
  ELSE                                               ! Nichts zu machen...
    ~BIOS(3,2,7)
  ENDIF
  IF MENU(1)=20 THEN
    mnr=nr
    h=MENU(4)                                    ! ...Fenster-Handle
    FOR a=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
      EXIT IF h=rsc_handle%(a)
    NEXT a
    ha1=h
    IF a<>-1 THEN
      IF a=peak& AND BTST(winh,a)=TRUE THEN
        peakint=FALSE
        wpl=0   ! peakhold left
        wpr=0   ! peakhold right
        @vor_update
        IF b1<>0 AND h1<>0 THEN
          @bigtext2
          REPEAT
            ~WIND_GET(ha1,12,x1,y1,b1,h1)
            IF b1<>0 AND h1<>0 THEN
              CLIP x1,y1,b1,h1
              @bigtext2
            ENDIF
          UNTIL b1=0 OR h1=0
        ENDIF
        @nach_update
      ENDIF
      IF a=smpedit& AND BTST(winh,a)=TRUE THEN
        @vor_update
        IF b1<>0 AND h1<>0 THEN
          @putcsize
          IF memc=0 OR cached=FALSE OR (drawnew2=TRUE AND mnr=smpedit&) THEN
            credraw=TRUE
            @curve(cs,ce)
            @blkupdate
            credraw=FALSE
            IF drawnew2=TRUE AND mnr=smpedit& THEN
              @getcurve
            ENDIF
          ELSE
            @putcurve
          ENDIF
          REPEAT
            ~WIND_GET(ha1,12,x1,y1,b1,h1)
            IF b1<>0 AND h1<>0 THEN
              CLIP x1,y1,b1,h1
              IF memc=0 OR cached=FALSE OR (drawnew2=TRUE AND mnr=smpedit&) THEN
                credraw=TRUE
                @curve(cs,ce)
                @blkupdate
                credraw=FALSE
                IF drawnew2=TRUE AND mnr=smpedit& THEN
                  @getcurve
                ENDIF
              ELSE
                @putcurve
              ENDIF
            ENDIF
          UNTIL b1=0 OR h1=0
        ENDIF
        @nach_update
      ENDIF
      '
      IF a=editfade& AND BTST(winh,a)=TRUE THEN
        @vor_update
        IF b1<>0 AND h1<>0 THEN
          @putfsize
          IF memfade=0 OR (drawnew3=TRUE AND mnr=editfade&) THEN
            credraw=TRUE
            IF fadericht=0 THEN
              @infade
            ELSE
              @ausfade
            ENDIF
            IF drawnew3=TRUE AND mnr=editfade& THEN
              @getfade
            ENDIF
            credraw=FALSE
          ELSE
            @putfade
          ENDIF
          REPEAT
            ~WIND_GET(ha1,12,x1,y1,b1,h1)
            IF b1<>0 AND h1<>0 THEN
              CLIP x1,y1,b1,h1
              IF memfade=0 OR (drawnew3=TRUE AND mnr=editfade&) THEN
                credraw=TRUE
                IF fadericht=0 THEN
                  @infade
                ELSE
                  @ausfade
                ENDIF
                IF drawnew3=TRUE AND mnr=editfade& THEN
                  @getfade
                ENDIF
                credraw=FALSE
              ELSE
                @putfade
              ENDIF
            ENDIF
          UNTIL b1=0 OR h1=0
        ENDIF
        @nach_update
      ENDIF
      '
      IF a=trakker& AND BTST(winh,a)=TRUE THEN
        wpl=0   ! peakhold left
        wpr=0   ! peakhold right
        '        tcached=TRUE             ! entfernt seit 13.6.98
        IF hz<>thz AND mnr=trakker& THEN
          thz=hz
          tcached=FALSE
        ENDIF
        @vor_update
        IF b1<>0 AND h1<>0 THEN
          @puttrsize
          IF memtrak=0 OR tcached=FALSE OR (drawnew4=TRUE AND mnr=trakker&) THEN
            credraw=TRUE
            @timeline
            credraw=FALSE
            IF drawnew4=TRUE AND mnr=trakker& THEN
              @gettrak
            ENDIF
          ELSE
            @puttrak
          ENDIF
          REPEAT
            ~WIND_GET(ha1,12,x1,y1,b1,h1)
            IF b1<>0 AND h1<>0 THEN
              CLIP x1,y1,b1,h1
              IF memtrak=0 OR tcached=FALSE OR (drawnew4=TRUE AND mnr=trakker&) THEN
                credraw=TRUE
                @timeline
                credraw=FALSE
                IF drawnew4=TRUE AND mnr=trakker& THEN
                  @gettrak
                ENDIF
              ELSE
                @puttrak
              ENDIF
            ENDIF
          UNTIL b1=0 OR h1=0
        ENDIF
        @nach_update
      ENDIF
    ENDIF
  ENDIF
  '
  IF MENU(1)=34 THEN                            ! iconify
    ~WIND_SET(handle&,26,buffer&(4),buffer&(5),buffer&(6),buffer&(7))
    rsc_message(tree&,20,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    GCONTRL(0)=165
    GCONTRL(1)=2
    GCONTRL(2)=1
    GCONTRL(3)=4
    GCONTRL(4)=0
    '
    GINTIN(0)=3
    GINTIN(1)=staricon&
    '
    ~@xrsrc_gaddr(0,a&,zus%)
    ADDRIN(0)=zus%
    DPOKE mdat%,-1
    DPOKE mdat%+2,-1
    DPOKE mdat%+4,-1
    DPOKE mdat%+6,-1
    '
    POKE mdat%+16,ASC("E")
    POKE mdat%+17,ASC("D")
    POKE mdat%+18,ASC("I")
    POKE mdat%+19,ASC("T")
    POKE mdat%+20,ASC("O")
    POKE mdat%+21,ASC("R")
    POKE mdat%+22,0
    ADDRIN(1)=mdat%
    ADDRIN(2)=mdat%+16
    ~@xrsrc_gaddr(0,icon&,zus2%)
    ADDRIN(3)=zus2%
    '
    GEMSYS                                               ! OBJC_SYSVAR()
    '
    STOP
  ENDIF
  IF MENU(1)=35 THEN                            ! uniconify
    ~WIND_SET(handle&,27,buffer&(4),buffer&(5),buffer&(6),buffer&(7))
    rsc_message(tree&,20,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    GCONTRL(0)=165
    GCONTRL(1)=1
    GCONTRL(2)=1
    GCONTRL(3)=4
    GCONTRL(4)=0
    '
    GINTIN(0)=4
    GINTIN(1)=staricon&
    '
    ~@xrsrc_gaddr(0,icon&,zus3%)
    ADDRIN(0)=zus3%
    DPOKE mdat%,-1
    DPOKE mdat%+2,-1
    DPOKE mdat%+4,-1
    DPOKE mdat%+6,-1
    POKE mdat%+16,0
    ADDRIN(1)=mdat%
    ADDRIN(2)=mdat%+16
    ~@xrsrc_gaddr(0,smpedit&,zus4%)
    ADDRIN(3)=zus4%
    GEMSYS                                               ! OBJC_SYSVAR()
    shading=FALSE
    iconify=FALSE
    '
    obj=0
    edit_obj&=0
    obj&=0
  ENDIF
  IF MENU(1)=36 THEN
    ~WIND_SET(handle&,26,buffer&(4),buffer&(5),buffer&(6),buffer&(7))
    rsc_message(tree&,20,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
  ENDIF
  '
rsc_dox_ende:
RETURN
> PROCEDURE button
  .| Glob. Var.: mrkhandle2#,mx&,my&,rsc_adr%,nr#,next_obj&,fsel&,fssldbut&
  .|     fsslide&,fsmax#,fsz#,slflg#,arranger&,arrslbut&,arrslide&,slmax#,pbz#
  .|     trakker&,trakxbut&,trakslid&,tmax#,trakkz#,trakybut&,trkvslid&,tymax#
  .|     trakkyz#,virtual&,vslbut&,vslider&,hbg#,hbz#,vhbldstrt#,smplen#,zu%
  .|     edit_obj&,idx&,vblkstrt&,a$,slr#,hbgm#,mt#,vslc#,lslide#,smpedit&
  .|     zoombutt&,mrz#,zoomp#,mrcs#,cs#,mrce#,ce#,zomslide&,zmax#,mrzoom#
  .|     scrlslde&,scrolbut&,scmax#,scrollp#,mrscroll#,scteil#,scrolm#,vmem#
  .|     cached#,scstep#,peak&,cont&,tree&,evnt&,obj&,ob_tail&,rsc_popup&,b$
  .|     popup&,rate&,digana#,mover&,input&,source&,dsp&,rate2&,smp16&
  .|     makerate&,arrmake&,make&,mb&,editfade&,peakmute&,arrm1&,arrm2&,arrm3&
  .|     arrm4&,arrclip&,leave#,v#,v2#,v3#,v4#
  .| Felder    : rsc_adr%(),rscx&(),rscy&(),rscw&(),rsch&()
  .| Ruft auf  : sliding,fsnrset,setbutton,slideupdate,arrnrset,timeline
  .|     blkart,slidelr,textbutt,zoomcalc,scrollinit,setslide,restaura
  .|     rsc_movedial,rsc_text,rsc_popup,rsc_set_cursor,edhandler2
  .| Aufruf in : message-1,rsc_do-2,
  LOCAL popok,dif
  rsc_adr%=rsc_adr%(nr)
  IF next_obj&<>-1 OR rsc_handle%(tree&)>1000 THEN
    next_obj&=OBJC_FIND(rsc_adr%,0,100,mx&,my&)
  ENDIF
  IF (intactive=FALSE OR NOT (nr=smpedit& OR nr=virtual& OR nr=trakker& OR nr=arranger& OR nr=fsel&)) AND next_obj&<>-1 THEN
    leave=FALSE
    mrkhandle2=WIND_FIND(mx&,my&)
    '  IF mrkhandle=mrkhandle2 THEN
    '  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
    '  IF v<>0 AND kenn=mrkhandle2 THEN
    '
    '                                                  ! String vor Popup...
    IF next_obj&>0
      IF BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND SHR(OB_TYPE(rsc_adr%,next_obj&),8)=28 AND BTST(OB_STATE(rsc_adr%,SUCC(next_obj&)),5)
        ' (TOUCHEXIT, STRING, SUCC: SHADOWED)
        INC next_obj&
      ENDIF
    ENDIF
    '
    IF next_obj&=-1                                    ! Neben die Box...
      IF rsc_mtsk!=FALSE THEN
        '        SOUND 1,15,10,4,10
        '        SOUND 0,0,0,0,0
      ENDIF
      next_obj&=0
    ELSE
      '
      IF tfselm=TRUE AND nr=fsel& AND next_obj&=fssldbut& THEN
        IF tfsz2>(tfsmax-tfstep) THEN
          tfsz2=tfsmax-tfstep
        ENDIF
        @sliding2(fsslide&,fssldbut&,tfsmax+2,tfstep,tfsz2,slflg)
        IF slflg=TRUE THEN
          @clearfsel
          @tfscalc
          @tfsgetsel2
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF tfselm=TRUE AND nr=fsel& AND next_obj&=fsslide& THEN
        ay&=rscy&(nr)
        @slideupdate2(fsslide&,fssldbut&,ay&+3,tfsmax,mx&,my&,tfstep,tfsz2,slflg)
        IF slflg=TRUE THEN
          @clearfsel
          @tfscalc
          @tfsgetsel2
        ENDIF
        next_obj&=0
      ENDIF
      '
      IF tfselm=FALSE AND nr=fsel& AND next_obj&=fssldbut& THEN
        IF fsz2>(fsmax-fstep) THEN
          fsz2=fsmax-fstep
        ENDIF
        @sliding3(fsslide&,fssldbut&,fsmax,fstep,fsz2,slflg)
        IF slflg=TRUE THEN
          @clearfsel
          @fscalc
          @getsel2
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF tfselm=FALSE AND nr=fsel& AND next_obj&=fsslide& THEN
        ay&=rscy&(nr)
        @slideupdate2(fsslide&,fssldbut&,ay&+3,fsmax,mx&,my&,fstep,fsz2,slflg)
        IF slflg=TRUE THEN
          @clearfsel
          @fscalc
          @getsel2
        ENDIF
        next_obj&=0
      ENDIF
      '
      IF nr=trakker& AND next_obj&=spurybut& THEN
        @sliding(spurslid&,spurybut&,trkvmax-4,5,trkvz,slflg)
        IF slflg=TRUE THEN
          @spurbutt
          @timeline
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      IF nr=trakker& AND next_obj&=spurslid& THEN
        @slideupdate(spurslid&,spurybut&,ay&+42,trkvmax-4,mx&,my&,4,5,trkvz,slflg)    ! war vorher ay&-32
        IF slflg=TRUE THEN
          @spurbutt
          @timeline
        ENDIF
        next_obj&=0
      ENDIF
      '
      IF nr=arranger& AND next_obj&=arrslbut& THEN
        @sliding(arrslide&,arrslbut&,slmax-3,5,pbz,slflg)
        IF slflg=TRUE THEN
          @arrnrset
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=arranger& AND next_obj&=arrslide& THEN
        @slideupdate(arrslide&,arrslbut&,ay&-33,slmax-3,mx&,my&,4,5,pbz,slflg)
        IF slflg=TRUE THEN
          @arrnrset
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=trakker& AND next_obj&=trakxbut& THEN
        IF dclick=FALSE THEN
          @killpmark2
          IF trakkz2>(tscmax-tscstep) THEN
            trakkz2=tscmax-tscstep
          ENDIF
          @sliding2(trakslid&,trakxbut&,tscmax,tscstep,trakkz2,slflg)
          IF slflg=TRUE THEN
            @timeinit2
            @timeinit3
            @timeline
          ENDIF
        ELSE
          @trkgotime
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      IF nr=trakker& AND next_obj&=trakslid& THEN
        @killpmark2
        IF trakkz2>(tscmax-tscstep) THEN
          trakkz2=tscmax-tscstep
        ENDIF
        @slideupdate2(trakslid&,trakxbut&,ax&+1,tscmax,mx&,my&,tscstep,trakkz2,slflg)
        IF slflg=TRUE THEN
          @timeinit2
          @timeinit3
          @timeline
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=trakker& AND next_obj&=zoomxbut& THEN
        @killpmark2
        @sliding(zoomslid&,zoomxbut&,tymax,5,trakkyz,slflg)
        @delcache
        IF slflg=TRUE THEN
          @timeinit6
          trakkz=0
          trakkz2=0
          tmax=trkztop
          @timeinit
          @timeinit3
          @slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
          @setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
          @timeline
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=trakker& AND next_obj&=zoomslid& THEN
        @killpmark2
        IF bigfoot=FALSE THEN
          tzj=1
        ELSE
          tzj=7   ! war 4
        ENDIF
        @slideupdate(zoomslid&,zoomxbut&,ax&+tzj,tymax,mx&,my&,1,5,trakkyz,slflg)
        @delcache
        IF slflg=TRUE THEN
          @timeinit6
          trakkz=0
          trakkz2=0
          tmax=trkztop
          @timeinit
          @timeinit3
          @slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
          @setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
          @timeline
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& THEN
        IF nr=smpedit& AND next_obj&=smpstop& THEN
          @setbutton(obj,1)
          back3%=1
          exfill=TRUE
          PAUSE 2
          @setbutton(obj,0)
          IF nr=peak& THEN
            @textfeld(recpeaks&,"0"+CHR$(0),1)
            @textfeld(recerror&,"0"+CHR$(0),1)
            @textfeld(peakname&,CHR$(0),1)
          ENDIF
          IF nr=fsel& AND obj=fsend& THEN
            fsbreak=TRUE
          ENDIF
        ENDIF
        IF nr=smpedit& AND (next_obj&=smpwait& AND pwait=FALSE AND intactive=TRUE) THEN
          pwait=TRUE
          @write_int(0)
          @setbutton(smpwait&,1)
          @pausewait
          pwait=FALSE
        ENDIF
      ENDIF
      '
      IF nr=smpedit& AND next_obj&=edmbut& THEN
        @sliding(edmslide&,edmbut&,loopz,5,vsms,slflg)
        IF slflg=TRUE THEN
          @edslidemove(vsms+1)
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& AND next_obj&=edmslide& THEN
        IF bigfoot=FALSE THEN
          edj=242
        ELSE
          edj=rsch&(smpedit&)-156
        ENDIF
        vdifb=INT((loopz+1)/50)
        @slideupdate(edmslide&,edmbut&,ay&+edj,loopz,mx&,my&,vdifb,5,vsms,slflg)
        IF slflg=TRUE THEN
          @edslidemove(vsms+1)
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=mrkfind& AND next_obj&=mrkfbut& THEN
        @sliding(mrkfslid&,mrkfbut&,loopz,5,vedsms,slflg)
        IF slflg=TRUE THEN
          @mrkfslidemove(vedsms+1)
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=mrkfind& AND next_obj&=mrkfslid& THEN
        ay&=rscy&(nr)
        @slideupdate(mrkfslid&,mrkfbut&,ay&+51,loopz,mx&,my&,1,5,vedsms,slflg)
        IF slflg=TRUE THEN
          @mrkfslidemove(vedsms+1)
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=clocks& AND next_obj&=clkbut& THEN
        @sliding(clkslid&,clkbut&,cdivz,5,vcdivsms,slflg)
        IF slflg=TRUE THEN
          @clocklook(vcdivsms+1)
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=clocks& AND next_obj&=clkslid& THEN
        ay&=rscy&(nr)
        @slideupdate(clkslid&,clkbut&,ay&+85,cdivz,mx&,my&,5,5,vcdivsms,slflg)
        IF slflg=TRUE THEN
          @clocklook(vcdivsms+1)
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=virtual& AND next_obj&=vslbut& THEN
        @sliding2(vslider&,vslbut&,lslide,hbreit,hbz,slflg)
        @setbutton(vslbut&,0)
        IF slflg=TRUE THEN
          vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
          ~OBJC_EDIT(zu%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
          edit_obj&=vblkstrt&
          @blkart
        ENDIF
        idx&=LEN(a$)
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=virtual& AND next_obj&=vslider& THEN
        hbgm=(smplen/mt)       ! Einteilungsanzahl
        @slideupdate2(vslider&,vslbut&,ax&+14,lslide,mx&,my&,hbreit,hbz,slflg)
        IF slflg=TRUE THEN
          vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
          ~OBJC_EDIT(zu%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
          edit_obj&=vblkstrt&
          @blkart
        ENDIF
        idx&=LEN(a$)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& AND next_obj&=zoombutt& THEN
        mrz=zoomp
        mrcs=cs
        mrce=ce
        @sliding(zomslide&,zoombutt&,zmax,16,zoomp,slflg)
        IF slflg=TRUE THEN
          IF mrz<>zoomp THEN
            a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
            @textbutt(zomslide&,zoombutt&,a$,1)
            @zoomcalc
            mrzoom=zoomp
            IF mrcs<>cs OR mrce<>ce THEN
              @scrollinit
              @setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
              mrscroll=scrollp
            ENDIF
          ENDIF
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& AND next_obj&=zomslide& THEN
        mrcs=cs
        mrce=ce
        mrz=zoomp
        IF bigfoot=FALSE THEN
          zj=12
        ELSE
          zj=INT((rscw&(smpedit&)/2)-505)
        ENDIF
        @slideupdate(zomslide&,zoombutt&,ax&+zj,zmax,mx&,my&,1,16,zoomp,slflg)
        IF slflg=TRUE THEN
          IF mrz<>zoomp THEN
            a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
            @textbutt(zomslide&,zoombutt&,a$,1)
            @zoomcalc
            mrzoom=zoomp
            IF mrcs<>cs OR mrce<>ce THEN
              @scrollinit
              @setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
              mrscroll=scrollp
            ENDIF
          ENDIF
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& AND next_obj&=scrolbut& THEN
        mrcs=cs
        mrce=ce
        mrz=scrollp
        @sliding2(scrlslde&,scrolbut&,scmax,scstep,scrollp,slflg)
        IF slflg=TRUE THEN
          IF scrollp<>mrz THEN
            dif=ce-cs
            cs=scrollp*scteil
            ce=dif+scrollp*scteil
            IF ce>vmem THEN
              cs=vmem-dif
              ce=vmem
            ENDIF
            cs=INT(cs/mbit)*mbit
            ce=INT(ce/mbit)*mbit
            cached=FALSE
            IF mrcs<>cs OR mrce<>ce THEN
              @setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
              mrscroll=scrollp
            ENDIF
            @restaura
          ENDIF
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& AND next_obj&=scrlslde& THEN
        mrcs=cs
        mrce=ce
        mrz=scrollp
        @slideupdate2(scrlslde&,scrolbut&,ax&+12,scmax,mx&,my&,scstep,scrollp,slflg)
        IF slflg=TRUE THEN
          dif=ce-cs
          cs=scrollp*scteil
          ce=dif+scrollp*scteil
          IF ce>vmem THEN
            cs=vmem-dif
            ce=vmem
          ENDIF
          cs=INT(cs/mbit)*mbit
          ce=INT(ce/mbit)*mbit
          cached=FALSE
          @setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
          mrscroll=scrollp
          @restaura
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=plugin& AND next_obj&=plgbox1& THEN
        leave=TRUE
      ENDIF
      IF nr=trakker& THEN
        IF next_obj&=tpsl& OR next_obj&=tpsr& OR next_obj&=tpel& OR next_obj&=tper& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=strtl& OR next_obj&=strtr& OR next_obj&=lend& OR next_obj&=rend& OR next_obj&=ltime& OR next_obj&=rtime& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=trklevo1& OR next_obj&=trklevo2& OR next_obj&=trklevo3& OR next_obj&=trklevo4& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=trklevu1& OR next_obj&=trklevu2& OR next_obj&=trklevu3& OR next_obj&=trklevu4& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=panl1& OR next_obj&=panl2& OR next_obj&=panl3& OR next_obj&=panl4& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=panr1& OR next_obj&=panr2& OR next_obj&=panr3& OR next_obj&=panr4& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=trkvol& THEN
          leave=TRUE
        ENDIF
      ENDIF
      IF nr<>plugin& AND nr<>peak& AND NOT (nr=trakker& AND leave=TRUE) THEN
        cont&=FORM_BUTTON(rsc_adr%,next_obj&,1,next_obj&)        ! fÅr MagiC weggelassen, macht Probleme
      ENDIF
      ' ------------------------------------------------ Flydial-Ecke
      IF BTST(OB_STATE(rsc_adr%,next_obj&),1)          ! (CROSSED)
        rsc_movedial(tree&,edit_obj&,idx&)             ! ...Dialog verschieben
        '
        next_obj&=0                                    ! Damit der Cursor..
        cont&=1                                        ! ..bleibt wo er ist
        ' ---------------------------------------------- Circle-Button...
      ELSE IF SHR(OB_TYPE(rsc_adr%,next_obj&),8)=27 AND BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),5) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),3))
        ' (G_BOXCHAR, PRED: SHADOWED /NOT DISABLED)
        '
        popok2=TRUE
        IF next_obj&=ratecirc& AND nr=smpedit& THEN
          @testsrate
          IF (adat=TRUE OR digana=FALSE OR (retime=1 AND digana=TRUE AND tstsr=TRUE)) THEN
            popok2=FALSE
          ENDIF
        ENDIF
        IF next_obj&=ratecir2& AND nr=smp16& THEN
          IF (adat=TRUE OR digana=FALSE OR (retime=1 AND digana=TRUE AND tstsr=TRUE)) THEN
            @testsrate
            popok2=FALSE
          ENDIF
        ENDIF
        '
        IF popok2=TRUE THEN
          next_obj&=PRED(next_obj&)                      ! Objektnr. Button
          a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
          evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
          '
          obj&=1
          FOR ob_tail&=1 TO PRED(evnt&)
            obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
          NEXT ob_tail&
          '
          evnt&=SUCC(obj&)
          b$=@rsc_text$(rsc_popup&,evnt&)
          DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
            INC evnt&                                    ! Defaulteintrag
          LOOP
          '
          REPEAT
            INC evnt&                                    ! NÑchster Eintrag...
            IF evnt&>OB_TAIL(rsc_adr%(rsc_popup&),obj&)  ! ...gibt es nicht
              evnt&=SUCC(obj&)                           ! ...dann wieder 1.
            ENDIF
            '                                            ! bis nicht DISABLED
          UNTIL NOT BTST(OB_STATE(rsc_adr%(rsc_popup&),evnt&),3)
          '                                              ! Button Ñndern...
          rsc_text(tree&,next_obj&,@rsc_text$(rsc_popup&,evnt&))
          ~OBJC_DRAW(rsc_adr%,next_obj&,1,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
          popup&=SUB(evnt&,obj&)
          '          REPEAT
          '          ~GRAF_MKSTATE(v,v2,v3,v4)
          '        UNTIL v3=0
          ' ---------------------------------------------- Popup-Menue...
        ENDIF
      ELSE IF BTST(OB_STATE(rsc_adr%,next_obj&),5) AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND (NOT BTST(OB_STATE(rsc_adr%,next_obj&),3))
        popok=FALSE
        IF (next_obj&=rate& AND digana=TRUE AND nr=smpedit&) THEN
          @testsrate
          IF adat=FALSE AND ((retime=0 OR (retime=1 AND tstsr=FALSE))) THEN
            popok=TRUE
          ENDIF
        ENDIF
        IF next_obj&=mover& AND nr=smpedit& THEN
          popok=TRUE
        ENDIF
        IF adat=FALSE AND ((next_obj&=rate2& AND digana=TRUE AND nr=smp16&)) THEN
          @testsrate
          IF (retime=0 OR (retime=1 AND tstsr=FALSE)) THEN
            popok=TRUE
          ENDIF
        ENDIF
        IF ((next_obj&=protect& OR next_obj&=mode& OR next_obj&=emphasis& OR next_obj&=input& OR next_obj&=source& OR next_obj&=dsp&) AND nr=smp16&) THEN
          popok=TRUE
        ENDIF
        IF next_obj&=makerate& AND nr=arrmake& THEN
          popok=TRUE
        ENDIF
        IF next_obj&=setform& AND nr=setup& THEN
          popok=TRUE
        ENDIF
        IF popok=TRUE THEN
          ' (SHADOWED, TOUCHEXIT, NOT DISABLED)
          evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
          obj&=1
          FOR ob_tail&=1 TO PRED(evnt&)
            obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
          NEXT ob_tail&
          ob_tail&=OB_TAIL(rsc_adr%(rsc_popup&),obj&)
          a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
          evnt&=SUCC(obj&)
          DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
            INC evnt&                                    ! Ausrichtung ermitteln
          LOOP UNTIL evnt&>ob_tail&
          '
          IF evnt&<=ob_tail&                             ! Defaulteintrag...
            popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,SUB(evnt&,SUCC(obj&)))
          ELSE                                           ! Sonst ohne...
            IF tree&=smpedit& OR tree&=make& THEN
              popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,1)
            ENDIF
          ENDIF
          IF popup&=0                                    ! Abbruch...
            cont&=1                                      ! ...weiter geht's
            next_obj&=0                                  ! ...Cursor 'festhalten'
          ENDIF
        ENDIF
        ' ---------------------------------------------- Cursor positionieren
        ' Mîchten Sie den Cursor mit der Maus zeichengenau positionieren?
        ' Dann entREMen Sie diese Zeilen und laden diese Prozedur nach:
      ELSE IF BTST(OB_FLAGS(rsc_adr%,next_obj&),3)
        @rsc_set_cursor(rsc_adr%,mx&,my&,edit_obj&,next_obj&,idx&)
      ENDIF
      '
    ENDIF
    IF cont&=0 OR (next_obj&<>0 AND next_obj&<>edit_obj&)
      ~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
    ENDIF
    ' ENDIF
    ' ENDIF
    IF nr=smpedit& AND mb&<>0 THEN
      @edhandler2
    ENDIF
    IF nr=smpedit& THEN
      IF next_obj&=flyer& AND (edcart2<>0 OR edcart<>0) THEN
        leave=TRUE
      ENDIF
      IF next_obj&=edmnr& AND ((edcart2=0 AND edcart3=0) OR (edcart=1 AND edcart3=1)) THEN
        leave=TRUE
      ENDIF
      IF next_obj&=edmbuts& AND ((edcart2=0 AND edcart3=0) OR (edcart>1 AND edcart<6 AND edcart3=1)) THEN
        leave=TRUE
      ENDIF
      IF next_obj&=edmbute& AND ((edcart2=0 AND edcart3=0) OR (edcart>1 AND edcart<6 AND edcart3=1)) THEN
        leave=TRUE
      ENDIF
      IF next_obj&=edmbuti& AND ((edcart2=0 AND edcart3=0) OR (edcart>1 AND edcart<6 AND edcart3=1)) THEN
        leave=TRUE
      ENDIF
      IF next_obj&=edmbutr& AND ((edcart2=0 AND edcart3=0) OR (edcart>1 AND edcart<6 AND edcart3=1)) THEN
        leave=TRUE
      ENDIF
    ENDIF
    IF nr=editfade& OR nr=peak& OR ((next_obj&=arrm1& OR next_obj&=arrm2& OR next_obj&=arrm3& OR next_obj&=arrm4& OR next_obj&=arrclip&) AND nr=arranger&) THEN
      leave=TRUE
    ENDIF
    IF nr=plugin& AND next_obj&=plgbox1& THEN
      leave=TRUE
    ENDIF
    IF ((next_obj&=trakk1& OR next_obj&=trakk2& OR next_obj&=trakk3& OR next_obj&=trakk4& OR next_obj&=trakclip&) AND nr=trakker&) THEN
      leave=TRUE
    ENDIF
    '    REPEAT
    '    ~GRAF_MKSTATE(v,v2,v3,v4)        ! fÅr MagiC weggelassen,macht Probleme
    '  UNTIL v3=0 OR leave=TRUE
    IF next_obj&=0 AND nr<>editfade& THEN
      next_obj&=-1
    ENDIF
  ENDIF
RETURN
> PROCEDURE rsc_init
  .| Glob. Var.: ap_id&,rsc_aes&,rsc_mtsk!,rsc_alert&,wchar&,hchar&,rsc_vh&
  .|     planes&,deskx&,desky&,deskw&,deskh&,rsc_flyd%,rsc_bitblt%,rsc_obspec%
  .|     rsc_cookie%
  .| Felder    : rsc_adr%()
  .| Aufruf in : HAUPTPROGRAMM-1,
  LOCAL a&
  '
  ' Initialisiert die von den RSC-Routinen benîtigten Variablen...
  '
  ap_id&=APPL_INIT()                         ! Applikations-ID
  '
  rsc_aes&=INT{{ADD(GB,4)}}                  ! AES-Version
  rsc_mtsk!=INT{ADD({ADD(GB,4)},2)}<>1       ! Multitasking?
  rsc_alert&=-1                              ! Noch keine fliegenden Alerts
  '
  CONTRL(6)=GRAF_HANDLE(wchar&,hchar&,a&,a&) ! AES-Handle, Zeichenbreite/Hîhe
  rsc_vh&=V_OPNVWK(1)                        ! Virt.Workst. fÅr Flydials îffnen
  IF rsc_vh&=0
    rsc_vh&=V~H                              ! ...Fehler, dann eben die alte
  ENDIF
  CONTRL(6)=V~H
  '
  INTIN(0)=1
  VDISYS 102,1,0
  planes&=INTOUT(4)                          ! Bitplanes
  '
  ~WIND_GET(0,7,deskx&,desky&,deskw&,deskh&) ! Hintergrundfenster
  ' ------------------------------------------------------ Inline vorbereiten
  INLINE rsc_flyd%,2834
  '
  rsc_bitblt%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,16)})      ! BITBLT-Routine
  rsc_obspec%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,18)})      ! OB_SPEC-Routine...
  rsc_cookie%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,20)})      ! COOKIE-Routine...
  '
  {ADD(rsc_flyd%,22)}=ADD(GB,24)                         ! VDI-Parameterblock
  INT{ADD(rsc_flyd%,26)}=rsc_vh&                         ! Virt. Workstation
  INT{ADD(rsc_flyd%,28)}=wchar&                          ! Zeichenzellenbreite
  INT{ADD(rsc_flyd%,30)}=hchar&                          ! Zeichenzellenhîhe
  ' ------------------------------------------------------
  ' Berechnet den Speicherbedarf einer Bitmap-Grafik...
  DEFFN getsize(w&,h&)=SHL(SHR(ADD(MUL(MUL(SHR(ADD(w&,15),3),h&),planes&),255),8),8)
  '
  ' GegenstÅck zur Prozedur rsc_text: Universelles Objekt-Text auslesen...
  DEFFN rsc_text$(tree&,obj&)=CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}
  '
RETURN
> PROCEDURE rsc_exit
  .| Glob. Var.: rsc_vh&,popup_back%,rsc_userblk%
  .| Aufruf in : goodbye-1,
  '
  CONTRL(6)=rsc_vh&
  VDISYS 38,0,0                              ! vqt_attributes
  IF ABS(INTOUT(0))<>1                       ! Anderer AES-Zeichensatz (MTOS)...
    ~VST_UNLOAD_FONTS(0)                     ! ...freigeben
  ENDIF
  '
  IF rsc_vh&<>V~H                            ! Flydial-Workstation freigeben...
    ~V_CLSVWK()
  ENDIF
  '
  ' Die folgenden Zeilen sind nur im Interpreter relevant und kînnen im
  ' Compilat wegfallen. Tip: Mit dem ERGO!pro-PrÑprozessor ausblenden.
  '
  ~RSRC_FREE()                               ! Resource entfernen
  '
  IF popup_back%
    ~MFREE(popup_back%)                      ! Popup-Hintergrund freigeben
  ENDIF
  '
  IF rsc_userblk%
    ~MFREE(rsc_userblk%)                     ! Userblks freigeben
  ENDIF
  '
RETURN
> FUNCTION rsc_laden(file$,trees&,popup&,menu&,alert&)
$F%
.| Glob. Var.: popup_back%,rsc_trees&,rsc_popup&,rsc_menu&,rsc_alert&
.|     rsc_aes&,rsc_vh&,dreidim#,rsc_flyd%
.| Felder    : rsc_adr%(),rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&()
.| Ruft auf  : xrsrc_load,xrsrc_gaddr,rsc_walk_tree
.| Aufruf in : HAUPTPROGRAMM-2,
LOCAL tree&,obj&,font_h&,font_id&,color3d&,a%
popup_back%=0
'
' LÑdt die Resource und initialisiert einige globale Variablen...
' ------------------------------------------------------ RSC laden
' Wollen Sie das RSC-File direkt im Programmcode 'aufbewahren'?
' Dann entREMen Sie diese Zeilen und laden Sie die Funktion
' 'rsc_conv' aus EXTENDED.LST hinzu...
' INLINE rsc%,3160
' IF @rsrc_conv(rsc%)=0
IF @xrsrc_load(file$)=0
  ~FORM_ALERT(1,"[3][ | Fehler beim Laden | der RSC-Datei! | ][Abbruch]")
  RETURN FALSE
ENDIF
' ------------------------------------------------------
DIM rsc_adr%(trees&),rsc_handle%(trees&)
DIM rscx&(trees&),rscy&(trees&),rscw&(trees&),rsch&(trees&)
'
rsc_trees&=trees&                                      ! Anzahl ObjektbÑume-1
rsc_popup&=popup&                                      ! Popup-Baum
rsc_menu&=menu&                                        ! Dropdown-Baum
rsc_alert&=alert&                                      ! Alert-Baum
' ------------------------------------------------------ Adressen ermitteln
FOR tree&=0 TO trees&
  '
  ~@xrsrc_gaddr(0,tree&,a%)  ! Kompatibel zu den XRSRC-Routinen
  rsc_adr%(tree&)=a%
  IF tree&<>menu&
    ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
  ENDIF
  '
NEXT tree&
' ------------------------------------------------------ Grîûtes Popup
IF popup&>-1
  obj&=1
  WHILE obj&>0
    popup_back%=MAX(popup_back%,@getsize(ADD(OB_W(rsc_adr%(popup&),obj&),21),OB_H(rsc_adr%(popup&),obj&)))
    obj&=OB_NEXT(rsc_adr%(popup&),obj&)
  WEND
  popup_back%=@malloc(popup_back%,7)                   ! Hintergrundpuffer...
  IF popup_back%=0
    RETURN FALSE                                       ! ...nicht geklappt
  ENDIF
ENDIF
' ------------------------------------------------------ Anderer Zeichensatz
IF rsc_aes&>=&H400 OR APPL_FIND("?API")=0              ! Hat APPL_GETINFO()...
  '
  GCONTRL(0)=130
  GCONTRL(1)=1
  GCONTRL(2)=5
  GCONTRL(3)=0
  GCONTRL(4)=0
  GINTIN(0)=0
  '
  GEMSYS                                               ! APPL_GETINFO()
  '
  IF GINTOUT(0)=1                                      ! Hat geklappt...
    font_h&=GINTOUT(1)                                 ! AES-Font Hîhe
    font_id&=GINTOUT(2)                                ! AES-Font ID
    '
    IF ABS(font_id&)<>1 AND GDOS?<>0                   ! Anderer AES-Font...
      V~H=rsc_vh&
      ~VST_LOAD_FONTS(0)                               ! ...Fonts laden
      DEFTEXT ,,,,font_id&
      DEFTEXT ,,,font_h&                               ! ...und einstellen
      V~H=-1
    ENDIF
  ENDIF
ENDIF
' ------------------------------------------------------ 3D-Darstellung
IF rsc_aes&>=&H340                                     ! Ab AES 3.40...
  GCONTRL(0)=48
  GCONTRL(1)=4
  GCONTRL(2)=3
  GCONTRL(3)=0
  GCONTRL(4)=0
  '
  GINTIN(0)=0                                          ! Inquire
  GINTIN(1)=5                                          ! Background
  '
  GEMSYS                                               ! OBJC_SYSVAR()
  '
  IF GINTOUT(0)>0                                      ! Hat geklappt...
    color3d&=GINTOUT(1)                                ! ...3D-Farbe
  ENDIF
ENDIF
IF dreidim=0 OR maxcol=2 THEN
  color3d&=0
ELSE
  color3d&=8
ENDIF
' ------------------------------------------------------
INT{ADD(rsc_flyd%,32)}=color3d&>0                      ! 3D-Darstellung an/aus
INT{ADD(rsc_flyd%,34)}=color3d&                        ! 3D-Farbe
' ------------------------------------------------------
IF @rsc_walk_tree(trees&)
  RETURN TRUE                                          ! alles ok
ENDIF
'
RETURN FALSE                                           ! Error!
ENDFUNC
> FUNCTION rsc_walk_tree(trees&)
$F%
.| Glob. Var.: rsc_userblk%,hchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_instal_userdef
.| Aufruf in : rsc_laden-1,
LOCAL a&,b&,userblk&,tree&,obj&,a%
'
' RSC-Baum durchgehen und userdefs installieren...
'
' ------------------------------------------------------ Userdefs ermitteln
FOR tree&=0 TO trees&
'
obj&=-1
'
REPEAT
  '
  INC obj&
  '
  a&=SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)           ! Es ist ein userdef...
  ADD userblk&,-AND(a&>=17,a&<=22)
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! ...bis LAST_OBJ
'
NEXT tree&
'
rsc_userblk%=@malloc(SHL(SUCC(userblk&),3),7)             ! Userblks(+1) anfordern (*8)
IF rsc_userblk%=0                                      ! Zu wenig Speicher...
RETURN FALSE                                         ! ...Error!
ENDIF
a%=rsc_userblk%                                        ! Merken
' ------------------------------------------------------ ObjektbÑume modifiz.
FOR tree&=0 TO trees&
'
obj&=-1
REPEAT
  '
  INC obj&
  '
  SELECT SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)       ! OB_TYPE
    ' ------------------------------------------------ Flydial-Ecke...
  CASE 17
    rsc_instal_userdef(tree&,obj&,5)
    ' ------------------------------------------------ Button/String...
  CASE 18
    '
    a&=OB_FLAGS(rsc_adr%(tree&),obj&)                ! OB_FLAGS
    b&=BYTE(OB_TYPE(rsc_adr%(tree&),obj&))           ! Alter OB_TYPE
    '
    IF BTST(a&,4)                                    ! Radiobutton...
      rsc_instal_userdef(tree&,obj&,1)
      '                                              ! BUTTON, nicht EXIT
    ELSE IF b&=26 AND (NOT BTST(a&,2))               ! Checkbutton...
      rsc_instal_userdef(tree&,obj&,2)
      '
    ELSE                                             ! Normale EXIT-Buttons...
      '
      IF b&<>28                                      ! Kein STRING...
        a&=SUCC(-BTST(a&,1)-BTST(a&,2)-BTST(a&,6))
        IF a&>1 !EXIT       DEFAULT    TOUCHEXIT
          OB_X(rsc_adr%(tree&),obj&)=SUB(OB_X(rsc_adr%(tree&),obj&),a&)
          OB_Y(rsc_adr%(tree&),obj&)=SUB(OB_Y(rsc_adr%(tree&),obj&),a&)
          OB_W(rsc_adr%(tree&),obj&)=ADD(OB_W(rsc_adr%(tree&),obj&),ADD(a&,a&))
          OB_H(rsc_adr%(tree&),obj&)=SUCC(ADD(OB_H(rsc_adr%(tree&),obj&),ADD(a&,a&)))
        ENDIF                                        ! ...fÅr Redraw grîûer
      ENDIF
      '
      rsc_instal_userdef(tree&,obj&,6)
      '
    ENDIF
    ' ------------------------------------------------ Unterstr. Text...
  CASE 19
    rsc_instal_userdef(tree&,obj&,4)
    OB_FLAGS(rsc_adr%(tree&),obj&)=BSET(OB_FLAGS(rsc_adr%(tree&),obj&),13)
    ' ...OB_FLAG 13 setzen, wird in 'rsc_draw' benîtigt
    ' ------------------------------------------------ Rahmen...
  CASE 20
    rsc_instal_userdef(tree&,obj&,3)
    ' ------------------------------------------------ Niceline...
  CASE 21
    rsc_instal_userdef(tree&,obj&,8)
    ' ------------------------------------------------ Circlebutton...
  CASE 22
    IF hchar&=8 OR hchar&=16                         ! ...nur wenn mîglich
      rsc_instal_userdef(tree&,obj&,7)               ! ...als Bitmap
    ELSE
      OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(27,8),BYTE(OB_TYPE(rsc_adr%(tree&),obj&)))
    ENDIF                                            ! ...sonst Pfeil lassen
    '
  ENDSELECT
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! Bis LAST_OB gesetzt
'
NEXT tree&
'
{rsc_userblk%}=0                                       ! FÅr Nullstrings
rsc_userblk%=a%                                        ! FÅr MFREE() am Ende
'
RETURN TRUE                                            ! Alles OK
ENDFUNC
> PROCEDURE rsc_instal_userdef(tree&,obj&,nr&)
.| Glob. Var.: rsc_userblk%,rsc_flyd%
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_walk_tree-8,
'
' Userdef-Objekt installieren...
'
' nr& bezeichnet eine der folgenden Ausgaberoutinen:
' 1  Radiobutton, rund
' 2  Check-Button
' 3  Rahmen
' 4  Unterstr. Text
' 5  Flydial
' 6  Button
' 7  Circlebutton
' 8  Niceline
'
{rsc_userblk%}=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,SHL(PRED(nr&),1))})
{ADD(rsc_userblk%,4)}=OB_SPEC(rsc_adr%(tree&),obj&)
'
OB_SPEC(rsc_adr%(tree&),obj&)=rsc_userblk%             ! userdef und alter Typ
OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(BYTE(OB_TYPE(rsc_adr%(tree&),obj&)),8),24)
'                                                      ! im oberen Byte
ADD rsc_userblk%,8
'
RETURN
> PROCEDURE rsc_draw(tree&,flag%)
.| Glob. Var.: hchar&,deskx&,desky&,deskw&,deskh&,rsc_window&,rsc_obspec%
.|     rsc_userblk%,mrkhandle#,rsc_list$
.| Felder    : rsc_adr%(),rscx&(),rscy&(),rscw&(),rsch&(),rsc_handle%()
.| Ruft auf  : rsc_menu_ienable,rsc_message,rsc_bitblt
.| Aufruf in : rsc_alert-1,main-1,normalize-1,fade-1,smptime-1,movefrag-1
.|     smpsave-1,blklfrag-1,newfsel-4,sampleinf-2,resample-1,arranger-1
.|     trakker-1,arrsmpr-1,arrdelay-1,arrmname-1,virtual-1,abackup-1
.|     makeaback-1,smpedit-1,blkfunc-1,time_edit-1,make-2,info-1,setupdat-1
.|     conspace-1,memtovirt2-1,midi-1,loopwahl-1,dspwahl-1,peak-1,
LOCAL fly&,title&,obj&,x&,y&,w&,h&,rx&,ry&,rb&,rh&,handle&,a%,rsc_adr%
'
' Stellt einen Dialog auf dem Bildschirm dar...
'
' tree&   : Index des Dialogbaumes
' flag%   : Bitbelegung
'           Bit 0 -> Fensterdialog
'           Bit 1 -> Schlieûfeld
'           Bit 2 -> Bei Fensterdialogen: Sofort zeichnen
'
'  mywindow=TRUE
'  wind_active=tree&
'
IF flag%=0 THEN
fly=TRUE
ELSE
fly=FALSE
ENDIF
rsc_adr%=rsc_adr%(tree&)
' --------------------------------------------------- Titel & Flugecke suchen
DO WHILE NOT (fly&>0 AND title&>0)
INC obj&
IF BTST(OB_STATE(rsc_adr%,obj&),1)                ! Flugecke...
  fly&=obj&
ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),13)          ! Dialogtitel...
  title&=obj&
ENDIF
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
' --------------------------------------------------- Als Fenster-Dialog
IF BTST(flag%,0)
x&=SUCC(rscx&(tree&))
y&=ADD(ADD(rscy&(tree&),SHL(hchar&,1)),5)
w&=SUB(rscw&(tree&),2)
h&=SUB(SUB(rsch&(tree&),SHL(hchar&,1)),5)
'
IF fly&                                           ! Flugecke hidden...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                 ! Rahmen: 1 Pixel auûen...
OB_SPEC(rsc_adr%,0)=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
'
rx&=OR(&X1001,SHL(-BTST(flag%,1),1))              ! Ggf. Schlieûfeld
'
IF bigfoot=TRUE AND (tree&=smpedit& OR tree&=peak& OR tree&=trakker&) THEN
  rx&=(rx& OR &H46E4)              !  Fuller,Mover und Rollpfeile (Rollpfeile wegen MagiC)
ENDIF
'
handle&=WIND_CREATE(rx&,deskx&,desky&,deskw&,deskh&)
'    ~WIND_SET(handle&,10,handle&,0,0,0)  ! Fenstertitel setzen
IF handle&>0                                      ! Fenster vorhanden...
  '
  ~WIND_UPDATE(1)                                 ! BEG_UPDATE
  '
  INC rsc_window&                                 ! Anz. offene Fenster+1
  rsc_menu_ienable(FALSE)                         ! MenÅtitel disablen
  '
  IF title&                                       ! Dialogtitel existiert...
    a%=C:rsc_obspec%(L:rsc_adr%,title&)           ! ...Adresse des Titels
  ELSE
    a%=rsc_userblk%                               ! ...sonst Nullstring
  ENDIF
  ~WIND_SET(handle&,2,INT(SWAP(a%)),INT(a%),0,0)  ! Fenstertitel setzen
  mrkhandle=handle&
  '
  ~WIND_CALC(0,&X1001,x&,y&,w&,h&,rx&,ry&,rb&,rh&)! WC_BORDER
  ~WIND_OPEN(handle&,rx&,ry&,rb&,rh&)
  '
  rsc_handle%(tree&)=handle&
  '
  IF BTST(flag%,2)                                ! Sofort zeichnen...
    rsc_message(tree&,20,x&,y&,w&,h&,0,0)         ! ...redrawen
    REPEAT
      obj&=EVNT_MULTI(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1000)
      IF BTST(obj&,4) AND (MENU(4)<>rsc_handle%(tree&))
        '           message_auswerten(MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
      ENDIF
    UNTIL BTST(obj&,5)                            ! ...bis Timer-Event
  ENDIF
  '
  ~WIND_UPDATE(0)                                 ! END_UPDATE
  '
ENDIF
ENDIF
' --------------------------------------------------- Als normaler Dialog
IF rsc_handle%(tree&)=0
a%=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
OB_SPEC(rsc_adr%,0)=OR(a%,SHL(2,16))              ! Rahmen: 2 Pixel innen
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'                                                 ! Auûerhalb des Screens...
IF rscy&(tree&)<desky& OR ADD(rscx&(tree&),PRED(w&))>ADD(deskx&,PRED(deskw&)) OR ADD(rscy&(tree&),PRED(h&))>ADD(desky&,PRED(deskh&))
  ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                             ! ...wieder in die Mitte
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
'
rsc_list$=rsc_list$+MKI$(tree&)                   ! Dialog in die Liste aufnehmen
'
rsc_handle%(tree&)=@malloc(@getsize(w&,h&),7)
IF rsc_handle%(tree&)                             ! Hintergrund retten...
  rsc_bitblt(0,0,0,rsc_handle%(tree&),w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
  '
ENDIF
'
IF fly&>0 AND rsc_handle%(tree&)>0               ! Flugecke sichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BCLR(OB_FLAGS(rsc_adr%,fly&),7)
ELSE IF fly&                                     ! unsichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                ! Zeichnen...
~OBJC_DRAW(rsc_adr%,0,9,rscx&(tree&),rscy&(tree&),w&,h&)
ENDIF
'  mrkhandle=WIND_FIND(x&,y&)
RETURN
> PROCEDURE rsc_menu_ienable(stat!)
.| Glob. Var.: rsc_menu&,rsc_window&,rsc_aes&,rsc_mtsk!,ap_id&
.| Felder    : rsc_adr%(),rscw&()
.| Aufruf in : rsc_draw-1,rsc_back-1,main-1,windows-1,fade-1,arranger-1
.|     trakker-1,abackup-1,makeaback-1,smpedit-3,blkfunc-1,info-1
.|     loopwahl-1,dspwahl-1,
LOCAL obj&,title&,rsc_adr%
'
' Disabled/enabled alle MenÅ-Titel und den 'About...'-MenÅ-Eintrag...
'                                ! Gibt es ein MenÅ..
IF rsc_menu&>-1 AND rsc_window&=1! und ist es das 1. Fenster?
'
rsc_adr%=rsc_adr%(rsc_menu&)
'                              ! Objektbreite verÑndern...
IF stat!                       ! Enablen...
  OB_W(rsc_adr%,2)=rscw&(rsc_menu&)
ELSE                           ! Disablen...
  rscw&(rsc_menu&)=OB_W(rsc_adr%,2)
  OB_W(rsc_adr%,2)=OB_W(rsc_adr%,3)
ENDIF
'
obj&=3                         ! Ersten MenÅtitel Åberspringen
'
REPEAT
  INC obj&
  '                            ! G_TITEL...
  IF BYTE(OB_TYPE(rsc_adr%,obj&))=32
    '
    ~MENU_IENABLE(rsc_adr%,obj&,stat!)
    '
    title&=obj&                ! Wird fÅr 'About...' gebraucht
  ENDIF
  '
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
'                              ! 'About...' dis/enablen
~MENU_IENABLE(rsc_adr%,ADD(title&,3),stat!)
'                              ! Unter MultiTOS...
IF (rsc_aes&>=&H400) AND rsc_mtsk!
  ' zzz=MENU_BAR(rsc_adr%,-1)
  ' IF ap_id&=zzz THEN
  ~MENU_BAR(rsc_adr%,1)      ! ...Menu nur neu anzeigen, wenn erlaubt
  ' ENDIF
ELSE                           ! Unter SingleTOS...
  ~MENU_BAR(rsc_adr%,1)        ! ...Menu immer neu anzeigen
ENDIF
'
ENDIF
'
RETURN
> FUNCTION rsc_do(tree&,next_obj&,VAR popup&)
$F%
.| Glob. Var.: obj#,donr#,nr#,edit_obj&,idx&,tim&,mx&,my&,mb&,shift&,c#
.|     shcut#,winh#,smp16&,peak&,editfade&,smpedit&,digana#,xd#,xm#,ce#,cs#
.|     stay1#,stay2#,show#,showdat#,tedart#,hz#,showbdat#,shw$,showxy&
.|     butdirect#,othernr#
.| Felder    : rsc_handle%(),rsc_adr%()
.| Ruft auf  : message,drop,button,key,drop2,edhandler,peakread,fadehandler
.|     maketime,edhandler3,textfeld
.| Aufruf in : rsc_alert-1,windows-1,normalize-1,fade-1,smptime-1
.|     movefrag-1,smpsave-1,blklfrag-1,newfsel-1,sampleinf-1,resample-1
.|     arrsmpr-1,arrdelay-1,arrmname-1,virtual-1,abackup-1,time_edit-1
.|     make-1,setupdat-1,conspace-1,midi-1,
LOCAL a&,handle&,a$,c
LOCAL cont&,ob_tail&,obj&,flags&,rsc_adr%,keytab%
LOCAL ascii|,scan|,evnt&,mc&,key&
'
' Dialog auswerten...
'
obj=0
donr=nr
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(1)                                      ! ...BEG_UPDATE
~WIND_UPDATE(3)                                      ! ...BEG_MCTRL
flags&=&X11                                          ! ...BUTTON/KEYBD-Events
'
ELSE                                                   ! Fenster-Dialog...
flags&=&X110011                                      ! ...zus. MESSAGE-Events
ENDIF
'  IF nr=arranger& AND intplay=TRUE THEN
'  flags&=&X10011                                          ! keine Timer-Events wegen Interrupts
' ENDIF
'
rsc_adr%=rsc_adr%(tree&)
cont&=TRUE
' ------------------------------------------------------ Editierbares Objekt
DO WHILE (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3)) OR BTST(OB_STATE(rsc_adr%,next_obj&),3)
INC next_obj&
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,next_obj&),5)
IF BTST(OB_FLAGS(rsc_adr%,next_obj&),5) AND (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3))
next_obj&=0
ENDIF
' ------------------------------------------------------
'
'  IF cont&<>0 AND (next_obj&<>0 AND edit_obj&=0)             ! Ggf. Cursor setzen...  NEU !!!
IF cont&<>0 AND (next_obj&<>0 AND edit_obj&<>next_obj&)             ! Ggf. Cursor setzen...
edit_obj&=next_obj&                                ! ...Exit-Code zurÅck
next_obj&=0                                        ! ...'rsc_do' verlassen
~OBJC_EDIT(rsc_adr%,edit_obj&,27,idx&,1,idx&)       ! ...Cursor ein
ENDIF
'
next_obj&=0
tim&=20   ! EVENT-TIMER in msec
REPEAT
c=0
evnt&=EVNT_MULTI(flags&,2,1,1,0,0,0,0,0,0,0,0,0,0,0,tim&,mx&,my&,mb&,shift&,key&,c)
IF c=1 THEN
click=TRUE
ELSE
click=FALSE
ENDIF
IF c=2 THEN
dclick=TRUE
ELSE
dclick=FALSE
ENDIF
IF evnt&<>0 THEN
IF donr=nr THEN
  IF BTST(evnt&,4) THEN
    @message
    @drop
    @wischwasch    ! ganz neu !!!!
  ENDIF
  '
  IF BTST(evnt&,5) OR BTST(evnt&,0) OR BTST(evnt&,1) OR prkey<>0 OR prbut<>0 THEN
    ~GRAF_MKSTATE(x,v,prbut,prkey)
    v4=prkey
    k=prbut
    IF v4=0 THEN
      nokey=TRUE
    ELSE
      nokey=FALSE
    ENDIF
    IF (v4 AND 1)=0 THEN
      lshft=FALSE
    ELSE
      lshft=TRUE
    ENDIF
    IF (v4 AND 2)=0 THEN
      rshft=FALSE
    ELSE
      rshft=TRUE
    ENDIF
    IF (v4 AND 4)=0 THEN
      ctrlkey=FALSE
    ELSE
      ctrlkey=TRUE
    ENDIF
    IF (v4 AND 8)=0 THEN
      altkey=FALSE
    ELSE
      altkey=TRUE
    ENDIF
  ENDIF
  IF BTST(evnt&,1) OR BTST(evnt&,5) AND nr=trakker& THEN
    ' Drag & Drop
    IF k=1 THEN
      IF (v4=0 AND trmode=1) AND dclick=FALSE THEN
        @searchtrak
        @pmarkhlp2
        IF tfound=TRUE THEN
          @opentrk
        ENDIF
      ENDIF
      IF (v4=4 AND trmode<>5) OR ((v4=4 OR v4=0) AND trmode=5) THEN
        ntrmode=5
        obj=tblkedit&
        @tmarkmode
        obj=0
        @searchtrak
        @wischwasch
        IF tfound=TRUE THEN
          nr=smpedit&
          @editselect
          @loadtoedit
          @wischwasch
          '
          ~XBIOS(xbs,27,0)
          IF pch4=TRUE OR pmo8=TRUE THEN
            ~XBIOS(&H8B,0,2,0,clk,1)
            ~XBIOS(&H8B,3,11,0,clk,1)
          ENDIF
          IF pmo8=TRUE THEN
            ~XBIOS(xbs,72,14)
          ENDIF
          matrixplay=FALSE
          pch4=FALSE
          pmo8=FALSE
          pch16=FALSE
          '
        ENDIF
      ENDIF
    ENDIF
    IF k=1 OR k=2 THEN
      IF v4=0 OR v4=1 OR v4=2 THEN
        IF trmode=2 OR (v4=0 AND k=2 AND trmode<>6) THEN
          ntrmode=2
          obj=tblkmove&
          @tmarkmode
          obj=0
        ENDIF
        IF (v4=1 OR v4=2) OR (trmode=6 AND ((v4=1 OR v4=2) OR (v4=0 AND (k=1 OR k=2)))) THEN
          IF trmode=6 AND v4=0 AND (k=1 OR k=2) THEN
            IF k=1 THEN
              v4=2
            ELSE
              v4=1
            ENDIF
          ENDIF
          ntrmode=6
          obj=tblksnap&
          @tmarkmode
          obj=0
        ENDIF
        IF trmode=2 OR trmode=6 THEN
          @searchtrak
          IF tfound=TRUE THEN
            @opentrk
            @trakmoving
          ENDIF
        ENDIF
      ENDIF
      IF (v4=8 AND trmode<>3) OR (trmode=3 AND (v4=0 OR v4=8)) THEN
        ntrmode=3
        obj=tblkcopy&
        @tmarkmode
        obj=0
        @searchtrak
        IF tfound=TRUE THEN
          @opentrk
          @trakcopydrag
        ENDIF
      ENDIF
      IF (v4=12 AND trmode<>4) OR (trmode=4 AND (v4=0 OR v4=12)) THEN
        ntrmode=4
        obj=tblkdrag&
        @tmarkmode
        obj=0
        @searchtrak
        IF tfound=TRUE THEN
          @opentrk
          tdrag2=FALSE
          @trakdrag
        ENDIF
      ENDIF
    ENDIF
    IF just=TRUE AND k=0 THEN
      just=FALSE
      @timeline
    ENDIF
  ENDIF
  '
  IF next_obj&=-1 AND BTST(evnt&,1)=FALSE THEN
    next_obj&=0
  ENDIF
  IF BTST(evnt&,1) THEN
    @button
  ENDIF
  IF BTST(evnt&,0) AND (key&<>7181 OR (next_obj&=0 AND key&=7181)) THEN
    '        IF BTST(evnt&,0) THEN
    @key
    IF obj&<>0 AND mb&=1 THEN
      @button
    ENDIF
    IF obj&<>0 AND shcut=TRUE AND mb&=0 THEN
      @drop2
    ENDIF
  ENDIF
  IF BTST(evnt&,5) AND BTST(winh,smp16&)=TRUE AND nr=smp16& THEN
    @edhandler
  ENDIF
  IF BTST(evnt&,5) AND BTST(winh,info&)=TRUE AND nr=info& THEN
    @nonstop2
  ENDIF
  IF BTST(winh,arranger&)=TRUE AND nr=arranger& AND intplay=TRUE THEN
    @edhandler4
  ENDIF
  IF BTST(evnt&,5) AND nr=peak& THEN
    @peakread
    IF peaks2<>peaks THEN
      peaks=peaks2
      b$=STR$(peaks)+CHR$(0)
      @textfeld(recpeaks&,b$,1)
    ENDIF
  ENDIF
  IF BTST(evnt&,5) AND BTST(evnt&,4)=FALSE AND nr=editfade& THEN
    @fadehandler
  ENDIF
  @maketime
  IF BTST(evnt&,5) AND nr=smpedit& THEN
    IF digana=FALSE THEN
      @edhandler3
    ENDIF
    IF mx&>=xd AND mx&<=(xm+xd) AND xm>0 AND ce>cs AND my&>=stay1 AND my&<=stay2 AND show=TRUE THEN
      showdat=(INT((INT((ce-cs)/mbit))/xm*(mx&-xd)))+INT(cs/mbit)
      IF virtual=FALSE THEN
        showert=meml+showdat*mbit
        IF dig24=FALSE THEN
          show$=HEX$(DPEEK(showert))+" "+HEX$(DPEEK(showert+2))+CHR$(0)
        ELSE
          show$=HEX$(PEEK(showert)*&H10000+PEEK(showert+1)*256+PEEK(showert+2))+" "+HEX$(PEEK(showert+3)*&H10000+PEEK(showert+4)*256+PEEK(showert+5))+CHR$(0)
        ENDIF
      ENDIF
      IF tedart=0 THEN
        showdat=showdat/hz
      ENDIF
      IF showbdat<>showdat THEN
        showbdat=showdat
        IF tedart=1 THEN
          a$=STR$(showdat)
          @formatsmp
          shw$=a$+CHR$(0)
        ELSE
          hsec=showdat*100
          @htimeset
          shw$=a$
        ENDIF
        IF LEN(shw$)>13 THEN
          shw$=LEFT$(shw$,13)+CHR$(0)
        ENDIF
        @textfeld(freemem&,show$,1)
        @textfeld(showxy&,shw$,1)
      ENDIF
    ENDIF
  ENDIF
ENDIF
ENDIF
IF mc&=2 AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6)      ! Doppelklick auf
next_obj&=WORD(BSET(next_obj&,15))                   ! TOUCHEXIT...
ENDIF
UNTIL (next_obj&>0 OR donr<>nr)
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(0)                                      ! END_UPDATE
~WIND_UPDATE(2)                                      ! END_MCTRL
ENDIF
IF donr<>nr AND butdirect=FALSE THEN
next_obj&=0
ENDIF
othernr=FALSE
rsc_do_ende:
RETURN next_obj&
ENDFUNC
> FUNCTION rsc_popup(a!,tree&,button&,popup&,def&)
$F%
.| Glob. Var.: rsc_popup&,hchar&,popup_back%,rsc_vh&,wchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_text
.| Aufruf in : button-2,
LOCAL x&,y&,b&,h&,m!
LOCAL evnt&,mx&,my&,mb&,shift&,key&,mc&,ascii|,scan|
LOCAL obj&,old_obj&,first&,anz&
LOCAL rsc&,rsc_adr%
'
' Popup-MenÅ darstellen und auswerten...
'
' a!       : TRUE: Button verÑndern, FALSE: Nur Popup
' tree&    : Index des Dialogbaumes
' button&  : Objektnr. des betÑtigten Buttons
' popup&   : Index des Popups
' def&     : Default-Eintrag (1-x)
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~WIND_UPDATE(3)                                   ! BEG_MCTRL
'
rsc_adr%=rsc_adr%(rsc_popup&)
'
first&=OB_HEAD(rsc_adr%,popup&)                   ! erster Eintrag
anz&=SUB(OB_TAIL(rsc_adr%,popup&),first&)         ! Anzahl EintrÑge-1
' ------------------------------------------------- Popup positionieren
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)
OB_X(rsc_adr%,0)=SUB(x&,OB_X(rsc_adr%,popup&))
OB_Y(rsc_adr%,0)=MAX(ADD(hchar&,4),MIN(SUB(WORK_OUT(1),4)-OB_H(rsc_adr%,popup&),SUB(y&,MUL(def&,hchar&))))-OB_Y(rsc_adr%,popup&)
'
x&=ADD(OB_X(rsc_adr%,0),PRED(OB_X(rsc_adr%,popup&)))
y&=ADD(OB_Y(rsc_adr%,0),PRED(OB_Y(rsc_adr%,popup&)))
b&=ADD(OB_W(rsc_adr%,popup&),4)
h&=ADD(OB_H(rsc_adr%,popup&),4)
' -------------------------------------------------
'
rsc_bitblt(0,0,0,popup_back%,b&,h&,x&,y&,b&,h&,0,0)
'
~OBJC_DRAW(rsc_adr%,0,7,x&,y&,b&,h&)              ! Popup zeichnen
'
IF a!                                             ! Button verÑndern...
'
~GRAF_MOUSE(256,0)                              ! Hidem
V~H=rsc_vh&                                     ! ...Default-Eintrag mit...
GRAPHMODE 2
'
INTIN(0)=8                                      ! ...HÑkchen versehen
PTSIN(0)=ADD(x&,DIV(wchar&,2))
PTSIN(1)=y&-DIV(hchar&,6)+MUL(SUCC(def&),hchar&)
VDISYS 8,1,1                                    ! ...v_gtext()
'
GRAPHMODE 1
V~H=-1
~GRAF_MOUSE(257,0)                              ! Showm
'
ENDIF
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)      ! Objekt unter der Maus...
'
IF obj&<=0                                        ! Daneben...
obj&=ADD(first&,def&)                           ! ...Default-Eintrag nehmen
ENDIF
'
old_obj&=obj&
IF (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))   ! Nicht disabled...
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
ENDIF                                             ! ...selektieren
'
~EVNT_TIMER(200)
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
IF mb&=1
m!=TRUE
evnt&=4
ENDIF
'
' --------------------------------------------------
DO
'
IF NOT m!
evnt&=EVNT_MULTI(&X111,1,1,1,1,mx&,my&,1,1,0,0,0,0,0,0,0,mx&,my&,mb&,shift&,key&,mc&)
ELSE
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
ENDIF
'
IF BTST(evnt&,0)                                 ! Tastaturereignis...
ascii|=BYTE(key&)
scan|=BYTE(SHR(key&,8))
'                                              ! Noch kein sel. Eintrag...
IF NOT (obj&>=first& AND obj&<=ADD(first&,anz&))
obj&=first&
'
ELSE IF scan|=80                               ! ...Cursor runter
INC obj&
IF obj&>ADD(first&,anz&)
  obj&=first&
ENDIF
'
ELSE IF scan|=72                               ! ...Cursor runter
DEC obj&
IF obj&<first&
  obj&=ADD(first&,anz&)
ENDIF
'
ENDIF
'
ENDIF
'
IF BTST(evnt&,2)                                 ! Mausereignis...
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)
ENDIF
'                                                ! Alten Eintrag deselekt...
IF obj&<>old_obj&
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),1)
ENDIF
'                                                ! Im MenÅ und nicht disabled...
IF (obj&>=first& AND obj&<=ADD(first&,anz&)) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
'                                              ! ...neuen selektieren
old_obj&=obj&
rsc&=SUB(obj&,first&)                          ! RÅckgabe
ENDIF
'
LOOP UNTIL BTST(evnt&,1) OR (mb&<>1 AND m!) OR ascii|=13 OR ascii|=27 OR scan|=97
' --------------------------------------------------
rsc_bitblt(popup_back%,b&,h&,0,0,0,0,0,b&,h&,x&,y&)! Hintergrund restaurieren
'
IF rsc&=SUB(obj&,first&) AND scan|<>97 AND ascii|<>27 ! Eintrag ausgewÑhlt...
'
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,obj&),0),0)
'
IF a!                                            ! Button verÑndern...
'                                              ! Neuen Text eintragen:
rsc_text(tree&,button&,@rsc_text$(rsc_popup&,obj&))
'
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)    ! Button zeichnen
~OBJC_DRAW(rsc_adr%(tree&),button&,1,x&,y&,OB_W(rsc_adr%(tree&),button&),OB_H(rsc_adr%(tree&),button&))
'
ENDIF
'
ELSE                                               ! Daneben => Abbruch...
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),0)
'
rsc&=-1                                          ! ...Abbruch markieren
'
ENDIF
'
REPEAT
~GRAF_MKSTATE(mx&,my&,mb&,shift&)                ! Mausknopf 'entprellen'
UNTIL mb&=0
'
~WIND_UPDATE(2)                                    ! END_MCTRL
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN SUCC(rsc&)
ENDFUNC
> PROCEDURE rsc_message(tree&,message&,x&,y&,w&,h&,edit_obj&,idx&)
.| Glob. Var.: wchar&,hchar&
.| Felder    : rsc_handle%(),rsc_adr%(),rscx&(),rscy&()
.| Ruft auf  : rsc_cursor
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,message-2,rsc_draw-1
.|     rsc_back-1,rsc_redraw_obj-1,main-1,fade-1,arranger-1,trakker-1
.|     blkfunc-1,info-1,loopwahl-1,peak-1,
LOCAL a|,ax&,ay&,ab&,ah&,handle&,obj&,rsc_adr%,a%,a$
'
' Wertet ein innerhalb des 'rsc_do' eingetroffenes Message-Ereignis aus...
'
IF nr<>smpinf& AND nr<>fsel& THEN
handle&=rsc_handle%(tree&)                         ! Fensterhandle des Dialogs
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
SELECT message&
' --------------------------------------------------------------------------
CASE 20,21                                         ! WM_REDRAW/WM_TOPPED
IF message&=20                                   ! WM_REDRAW...
~GRAF_MOUSE(256,0)                           ! Hidem
~WIND_GET(handle&,11,ax&,ay&,ab&,ah&)          ! 1. Rechteck
'
REPEAT
  '
  IF RC_INTERSECT(x&,y&,w&,h&,ax&,ay&,ab&,ah&) ! ...redrawen
    ~OBJC_DRAW(rsc_adr%(tree&),0,7,ax&,ay&,ab&,ah&)
  ENDIF
  '
  ~WIND_GET(handle&,12,ax&,ay&,ab&,ah&)        ! NÑchstes Rechteck...
UNTIL ab&=0 AND ah&=0                          ! ...kein Redraw mehr nîtig
'
~GRAF_MOUSE(257,0)                           ! Showm
'
ELSE                                             ! WM_TOPPED...
~WIND_SET(handle&,10,0,0,0,0)                  ! ...toppen
ENDIF
'
~WIND_GET(0,10,ax&,ay&,ay&,ay&)                  ! Oberstes Fenster...
IF ax&=handle& AND edit_obj&>0                   ! Ist das unsrige...
' ---------------------------------------------- Cursor-Setz-Orgie...
rsc_adr%=rsc_adr%(tree&)
'
obj&=edit_obj&                                 ! Parent ermitteln...
'
REPEAT
  obj&=OB_NEXT(rsc_adr%,obj&)
UNTIL obj&<edit_obj&
'
~OBJC_OFFSET(rsc_adr%,edit_obj&,ax&,ay&)       ! Koordinaten des Objekts
'
a$=CHAR{{ADD(OB_SPEC(rsc_adr%,edit_obj&),4)}}  ! Maske: "Eingabe:______"
ah&=1
WHILE MID$(a$,ah&,1)<>"_"                      ! LÑnge des Vortextes...
  INC ah&
WEND                                           ! ...ermitteln
'
ADD ax&,MUL(wchar&,ADD(PRED(ah&),idx&))        ! Cursor-Position im Pixeln
ah&=ADD(OB_H(rsc_adr%,edit_obj&),6)            ! Cursor ist grîûer hchar&
'                                              ! Cursor lîschen...
~OBJC_DRAW(rsc_adr%,obj&,7,ax&,SUB(ay&,3),wchar&,ah&)
rsc_cursor(rsc_adr%,edit_obj&,idx&)            ! ...und setzen
'
ENDIF
' --------------------------------------------------------------------------
CASE 28                                            ! WM_MOVED
~WIND_CALC(1,&X1001,x&,y&,w&,h&,ax&,ay&,ab&,ah&)
'
rscx&(tree&)=PRED(ax&)
rscy&(tree&)=SUB(SUB(ay&,5),MUL(hchar&,2))
OB_X(rsc_adr%(tree&),0)=ADD(rscx&(tree&),3)
OB_Y(rsc_adr%(tree&),0)=ADD(rscy&(tree&),3)
'
~WIND_SET(handle&,5,x&,y&,w&,h&)
'
ENDSELECT
'
~WIND_UPDATE(0)                                    ! END_UPDATE
'
ENDIF
RETURN
> PROCEDURE rsc_back(tree&)
.| Glob. Var.: rsc_window&,nr#,smp16&,blkfunc&,peak&,loop&,editfade&
.|     arranger&,info&,trakker&,smpedit&,edit_obj&,idx&,rsc_list$
.| Felder    : rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&(),rsc_adr%()
.| Ruft auf  : rsc_menu_ienable,rsc_message,rsc_bitblt
.| Aufruf in : rsc_alert-1,goodbye-1,normalize-1,blklfrag-1,newfsel-4
.|     restaura2-1,restaura2b-1,sampleinf-1,resample-1,make-1,conspace-1
.|     memtovirt2-1,
'
' Entfernt den Dialog vom Bildschirm...
'
' ---------------------------------------------------- Als Fenster-Dialog
IF windowda=TRUE THEN
fly=FALSE
IF rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
rsc_menu_ienable(TRUE)                             ! ...MenÅ wieder wÑhlbar
'
IF rsc_window&                                     ! Fenster existiert...
'
~WIND_CLOSE(rsc_handle%(tree&))
~WIND_DELETE(rsc_handle%(tree&))                 ! ...schlieûen & abmelden
'
DEC rsc_window&                                  ! Anz. offene Fenster-1
'
ELSE                                               ! Sonst Redraw auslîsen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF
' -------------------------------------------------- Als normaler Dialog
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
IF rsc_window&>0 THEN
IF nr=plugin& OR nr=wmode& OR nr=dspedit& OR nr=smp16& OR nr=blkfunc& OR nr=peak& OR nr=loop& OR nr=editfade& OR nr=arranger& OR nr=info& OR nr=trakker& THEN
  nr=smpedit&
  tree&=smpedit&
  rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
ENDIF
ELSE
rsc_list$=LEFT$(rsc_list$,SUB(LEN(rsc_list$),2))   ! Dialog aus der Liste entf.
'
IF rsc_handle%(tree&)                              ! Hintergrund gerettet...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~MFREE(rsc_handle%(tree&))
'
ELSE                                               ! Desktop redrawen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
IF rsc_list$<>""                                 ! Noch ein Dialog drunter...
  ~OBJC_DRAW(rsc_adr%(CVI(RIGHT$(rsc_list$,2))),0,7,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                            ! ...diesen auch redrawen
ENDIF
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
ENDIF
ENDIF
RETURN
> PROCEDURE rsc_text(tree&,robj&,a$)
.| Aufruf in : button-1,rsc_popup-1,rsc_alert-2,
'
' Universelle Objekt-Text Belegung...
'
CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),robj&)}=a$
RETURN
> PROCEDURE rsc_bitblt(a%,w&,h&,b%,rb&,rh&,ax&,ay&,ab&,ah&,gx&,gy&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : rsc_draw-1,rsc_popup-2,rsc_back-1,rsc_movedial-3
.|     rsc_flipping-23,
'
' Universeller Raster-Kopierer (benutzt vro_cpyfm oder vrt_cpyfm)...
'
IF ab&>0 AND ah&>0                 ! Breite und Hîhe vorhanden...
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:a%,w&,h&,0,planes&,L:b%,rb&,rh&,0,planes&,ax&,ay&,ab&,ah&,gx&,gy&,1)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_cursor(rsc_adr%,edit_obj&,idx&)
.| Aufruf in : rsc_message-1,rsc_movedial-1,
LOCAL a|,a%
'
' Zeichengenaue Positionierung des Cursors...
'
a%=ADD({OB_SPEC(rsc_adr%,edit_obj&)},idx&)
'
a|=BYTE{a%}                                        ! Zeichen merken
BYTE{a%}=0                                         ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)       ! Cursor setzen
BYTE{a%}=a|                                        ! ...Zeichen restaurieren
'
RETURN
> PROCEDURE busy_mouse
.| Glob. Var.: m_adr%,m_busy%
.| Aufruf in : HAUPTPROGRAMM-1,maschruf-1,maschruf2-1,maschinit2b-1
.|     maschruf3-1,maschruf3b-1,maschruf5-1,maschinit5b-1,maschruf5c-1
.|     maschruf6-1,maschruf8-1,maschruf8b-1,maschruf9-1,maschruf10-1
.|     maschruf11-1,maschruf12-1,maschruf13-1,maschruf16-1,maschruf17-1
.|     maschruf18b-1,maschruf18c-1,maschruf28-1,maschruf29-1,maschruf30-1
.|     maschruf31b-1,maschruf32-1,maschruf33-1,maschruf34-1,maschruf35-1
.|     maschruf36-1,maschruf37-1,maschruf38-1,fade_it-7,smpkhlp-1,smpihlp-5
.|     smpcut-3,virtmove-7,virtcopy-2,virtins-4,putpix-3,edhandler2-7
.|     smpsave-2,ldhlp-1,sampleinf-1,trakload-1,arrinsert-1,arrdelete-1
.|     hardfs-1,hardproof2-2,rettmem-1,arrload-1,arrsave-1,make-3,trash-2
.|     setload-1,setsave-1,fseldef-1,conspace-1,coninsert-4,mono-3,negate-3
.|     lrchange-3,springart-1,
' Eine Busy-Maus in der Form eines kleines Balles...
'
IF m_adr%=ADD(m_busy%,518)
m_adr%=m_busy%
'
ELSE
ADD m_adr%,74
ENDIF
'
~GRAF_MOUSE(255,m_adr%)
'
RETURN
> FUNCTION malloc(b%,c%)
LOCAL g,a%
IF gemvers>=&H1900 THEN
a%=@mxalloc(b%,3)     ! Buffer anfordern
IF a%<=0 THEN
a%=MALLOC(b%)       ! Buffer anfordern
ENDIF
ELSE
a%=MALLOC(b%)         ! Buffer fÅr Tracker-Caches
ENDIF
IF a%<=0 THEN
IF (c% AND 3)=1 THEN
@alerts(3)
ENDIF
IF (c% AND 3)=2 THEN
@alerts(4)
ENDIF
IF (c% AND 7)=3 THEN
@alerts(5)
ENDIF
IF (c% AND 7)=7 THEN
@alerts(6)
ENDIF
IF (g=2 AND (c% AND 7)=7) OR (c% AND 4)=4 THEN
@goodbye
ENDIF
ENDIF
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION rsc_get(x&,y&,w&,h&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : fseldef-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%,b%,g
'
b%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
a%=@malloc(b%,1)         ! Buffer fÅr Tracker-Caches
'
IF a%>0 THEN                       ! Hat geklappt...
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
'                                ! Kopieren...
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION rsc_get2(x&,y&,w&,h&,md%)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-3,dragging2-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%
a%=md%                           ! Speicher anfordern
IF a%>0 THEN
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> PROCEDURE rsc_put(a%,x&,y&,m&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&
'
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,0,0,w&,h&,x&,y&,m&)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_put2(a%,x&,y&,m&,sx,bx)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&
'
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,sx,0,bx,h&,x&,y&,m&)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_putblock(a%,x&,y&,x2&,y2&,b2&,h2&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&
'
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,x2&,y2&,b2&,h2&,x&,y&,1)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> FUNCTION rsc_len(w&,h&)
LOCAL a%
'
a%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
' ------------------------------------------------------------------------------
' ------------------------INTERFACE-FARBICONS-----------------------------------
' ------------------------------------------------------------------------------
' ************************************************************************
' **   Von den XRSRC- / Mydial-Routinen zusÑtzlich benîtigte Routinen   **
' ************************************************************************
DEFFN fnf_or_ner$=" fehlt|oder zuwenig Speicher.|Programm wird abgebrochen.][OK]"
' fnf_or_ner: '<F>ile <n>ot <f>ound <or> <n>ot <e>nough <R>AM'
' wird benîtigt von: init_xrsrc(), init_mydial()
> FUNCTION compiled
$F% ! 3.1.93 sm
' benîtigt: -
' wird benîtigt von: init_xrsrc(), init_mydial()
' RÅckgabe: BOOLEAN (TRUE, falls compiliert, sonst FALSE)
RETURN (BYTE{BASEPAGE+256}<>96)   ! s. ST-Computer 9/91
ENDFUNC
> PROCEDURE global_exit
' wird benîtigt von: init_xrsrc(), init_mydial()
'
' hier AufrÑumaktionen des Hauptprogramms:
'
@goodbye
RETURN
' ************************************************************************
' **                        XRSRC-Routinen                              **
' ************************************************************************
> PROCEDURE init_xrsrc(file$,essential!)  ! Initialisierung der Routinen, am Anfang 1* aufrufen
LOCAL base%,empty$,dummy%
LOCAL scalc%,init%,resident!
'
resident!=FALSE
@xrsrc_global_var(0,scalc%,init%,resident!)
'
empty$=STRING$(100,0)
'
IF NOT @compiled  ! also im Interpreter
IF LONG{BASEPAGE+180}=&H58525343  ! Kennung "XRSC"
scalc%=LONG{BASEPAGE+184}       ! _hinter_ der DTA, keine Panik !!
init%=LONG{BASEPAGE+188}
resident!=TRUE
WORD{init%+4+36}=128          ! Nummer von init
$C+
dummy%=C:scalc%()
$C-
@xrsrc_global_var(0,scalc%,init%,resident!)
xload=TRUE
GOTO end_init_xrsrc
ENDIF
ENDIF
IF SHEL_FIND(file$)
file$=file$+CHR$(0)
base%=GEMDOS(75,3,L:V:file$,L:V:empty$,L:V:empty$)
'
IF base%>=0
xload=TRUE
init%={base%+8}
dummy%=0
{init%+4}=V:empty$
$C+
dummy%=C:init%(L:base%)
$C-
IF dummy%=0
scalc%={init%+42}
WORD{init%+4+36}=128          ! Nummer von init
$C+
dummy%=C:scalc%()
$C-
IF dummy%=1
resident!=TRUE
@xrsrc_global_var(0,scalc%,init%,resident!)
IF NOT @compiled
LONG{BASEPAGE+180}=&H58525343
LONG{BASEPAGE+184}=scalc%
LONG{BASEPAGE+188}=init%
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF !if shel_find...
IF NOT resident!
IF essential!
~FORM_ALERT(1,"[3][|"+file$+@fnf_or_ner$)
global_exit
ENDIF
ENDIF
end_init_xrsrc:
RETURN
> PROCEDURE exit_xrsrc  ! Deinitialisierung der Routinen, am Ende 1* aufrufen
LOCAL scalc%,init%,resident!
@xrsrc_global_var(1,scalc%,init%,resident!)
IF resident!
WORD{init%+4+36}=129          ! Nummer der Function
$C+
~C:scalc%()
$C-
resident!=FALSE
ENDIF
RETURN
> PROCEDURE xrsrc_global_var(cmd&,VAR scalc%,init%,resident!)
' Die Prozedur dient zum 'Verstecken' der globalen Variablen
' der XRSRC-Routinen. Mit cmd&=1 wird gelesen, sonst geschrieben.
LOCAL xrgvadr%
INLINE xrgvadr%,9
IF cmd&=1 !Lesen
scalc%=LONG{xrgvadr%}
init%=LONG{xrgvadr%+4}
resident!=BYTE{xrgvadr%+8}
ELSE
LONG{xrgvadr%}=scalc%
LONG{xrgvadr%+4}=init%
BYTE{xrgvadr%+8}=ABS(resident!)
ENDIF
RETURN
'
> FUNCTION xrsrc_free
$F%
' RÅckgabe: WORD
LOCAL scalc%,init%,resident!,r&
@xrsrc_global_var(1,scalc%,init%,resident!)
'
IF resident!
WORD{init%+4+36}=2          ! Nummer der Function
$C+
r&=C:scalc%()
$C-
ELSE
r&=RSRC_FREE()
ENDIF
RETURN r&
ENDFUNC
> FUNCTION xrsrc_gaddr(re_gtype&,re_gindex&,VAR re_gaddr%)
$F%
' RÅckgabe: WORD
LOCAL scalc%,init%,resident!,r&
@xrsrc_global_var(1,scalc%,init%,resident!)
'
IF resident!
WORD{init%+4+36}=3          ! Nummer der Function
WORD{init%+4+0}=re_gtype&
WORD{init%+4+2}=re_gindex&
{init%+4+16}=V:re_gaddr%
$C+
r&=C:scalc%()
$C-
ELSE
r&=RSRC_GADDR(re_gtype&,re_gindex&,re_gaddr%)
ENDIF
RETURN r&
ENDFUNC
> FUNCTION xrsrc_load(file$)
$F%
' RÅckgabe: WORD
'
' Auf meine (SM) Anfrage zu xrsrc_load() antwortete Olaf Meisiek folgendes:
' SM> Macht xrsrc_load() eigentlich einen Check auf den RSC-Header (lange
' SM> oder normale RSC) ?
' Ja. xrsrc_load lÑdt normale und lange Resourcen mit und ohne Farbicons. Eine
' öberprÅfung, ob es sich Åberhaupt um eine Resource handelt, findet nicht
' statt. Wenn es sich um eine normale Resource handelt, wird der Header in
' einen Header fÅr eine lange Resource gewandelt.
' SM> Was macht es sonst noch ? vr_trnfm() der Icons, Images etc., oder nicht
' SM>(=Original) ?
' vr_trnfm wird fÅr alle Farbicon-Strukturen (CICON *) gemacht. Normale
' ICONBLK-Strukturen bleiben aus KompatibilitÑtsgrÅnden so wie sie waren. D.h.
' man muû dafÅr noch selber vr_trnfm aufrufen.
' Das gilt auch fÅr die ICONBLK-Struktur in einem Farbicon.
'
LOCAL scalc%,init%,resident!,r&
@xrsrc_global_var(1,scalc%,init%,resident!)
'
IF resident!
file$=file$+CHR$(0)
WORD{init%+4+36}=1          ! Nummer der Function
{init%+4+16}=V:file$
$C+
r&=C:scalc%()
$C-
ELSE
r&=RSRC_LOAD(file$)
ENDIF
RETURN r&
ENDFUNC
> FUNCTION xrsrc_obfix(re_gaddr%,re_obj&)
$F%
' RÅckgabe: WORD
LOCAL scalc%,init%,resident!,r&
@xrsrc_global_var(1,scalc%,init%,resident!)
'
IF resident!
WORD{init%+4+36}=5          ! Nummer der Function
WORD{init%+4+0}=re_obj&
{init%+4+16}=re_gaddr%
$C+
r&=C:scalc%()
$C-
ELSE
r&=RSRC_OBFIX(re_gaddr%,re_obj&)
ENDIF
RETURN r&
ENDFUNC
' ------------------------------------------------------------------------------
' ------------------------ENHANCED-FLYDIALS-------------------------------------
' ------------------------------------------------------------------------------
DEFFN rsc_flags(tree&,obj&,bit&)=BTST(OB_FLAGS(rsc_adr%(tree&),obj&),bit&)
DEFFN rsc_state(tree&,obj&,bit&)=BTST(OB_STATE(rsc_adr%(tree&),obj&),bit&)
> FUNCTION form_keybd(rsc_adr%,edit_obj&,key&,a&,VAR next_obj&,key_back&,idx&)
.| Ruft auf  : form_search_flag
.| Aufruf in : key-1,
' ZusÑtzliche Tastaturkommandos...
' Einfach FORM_KEYBD in 'rsc_do' durch @form_keybd ersetzen.
$F%
LOCAL scan|,cont&
'
' Ersetzt FORM_KEYBD()...
'
key_back&=0
cont&=1
'
SELECT key&
'
' ------------------------------------------------- SHIFT right
CASE &H4D36
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
' ------------------------------------------------- SHIFT left
CASE &H4B34
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
'
a&=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=0
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=a&
'
' ------------------------------------------------- Cursor runter
CASE &H5000
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
' ------------------------------------------------- Cursor rauf
CASE &H4800
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,-1)
' ------------------------------------------------- SHIFT runter/HOME
CASE &H5032,&H4737                                  ! =>letztes Feld
REPEAT
next_obj&=edit_obj&
edit_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
UNTIL edit_obj&=0
' ------------------------------------------------- SHIFT rauf, HOME
CASE &H4838,&H4700                                  ! =>erstes Feld
next_obj&=@form_search_flag(rsc_adr%,0,3,1)
' ------------------------------------------------- HELP/UNDO
CASE &H6200,&H6100
key_back&=key&
' ------------------------------------------------- Alles andere
DEFAULT
scan|=BYTE(SHR(key&,8))                           ! SCAN-Code
'
IF BYTE(key&)>0 OR scan|=75 OR scan|=77           ! Cursor rauf/runter
cont&=FORM_KEYBD(rsc_adr%,edit_obj&,key&,0,next_obj&,key&)
'                                               ! Kein Ende&TAB u. EDITABLE
IF cont&>0 AND BYTE(key&)<>9 AND BTST(OB_FLAGS(rsc_adr%,edit_obj&),3)
'
scan|=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)+8}+idx&}! Maske 'A' oder 'N'...
IF scan|=65 OR (scan|=78 AND (BYTE(key&)<48 OR BYTE(key&)>57))
key&=BCLR(key&,5)                             ! ...Groûschrift setzen
ENDIF
'
~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,2,idx&) ! ...Eingabe
ENDIF
'
ELSE
key_back&=key&
ENDIF
'
ENDSELECT
'
RETURN cont&
ENDFUNC
> FUNCTION form_search_flag(rsc_adr%,obj&,flag&,step&)
$F%
.| Aufruf in : form_keybd-4,
'
' Unterroutine fÅr form_keybd. Sucht das nÑchste/vorhergehende Objekt mit
' dem gesetzten Bit 'flag&' in OB_FLAGS...
'
' Sonderfall: Letztes Objekt ist edierbar, Cursor runter:
IF NOT (BTST(OB_FLAGS(rsc_adr%,obj&),5)=TRUE AND step&>0)
'
REPEAT
ADD obj&,step&
'
IF BTST(OB_FLAGS(rsc_adr%,obj&),flag&) AND (NOT BTST(OB_STATE(rsc_adr%,obj&),3))
RETURN obj&
ENDIF
UNTIL (obj&<=0) OR BTST(OB_FLAGS(rsc_adr%,obj&),5)
'
ENDIF
'
RETURN 0
ENDFUNC
> PROCEDURE rsc_movedial(tree&,edit_obj&,idx&)
.| Glob. Var.: deskx&,deskw&,desky&,deskh&
.| Felder    : rscw&(),rsch&(),rscx&(),rscy&(),rsc_handle%(),rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_flipping,rsc_cursor
.| Aufruf in : button-1,
' SOLID Flydials...
' Einfach die Prozedur 'rsc_movedial' ersetzen.
LOCAL x&,y&,w&,h&,fx&,fy&,mx&,my&,mb&,shift&,rsc%
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'
~GRAF_MKSTATE(mx&,my&,x&,y&)
' Nicht zusÑtzl. rechte Maustaste oder SHIFT/CONTROL/ALT...
IF NOT (x&=3 OR AND(y&,&X1111)>0)
rsc%=@malloc(@getsize(w&,h&),7)                    ! Dialog retten
ENDIF
IF rsc%                                           ! Hat geklappt...
rsc_bitblt(0,0,0,rsc%,w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
ENDIF
'
~GRAF_MOUSE(4,0)                                  ! FLAT_HAND
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
fx&=SUB(mx&,SUCC(rscx&(tree&)))                   ! Relativer Mausfaktor
fy&=SUB(my&,SUCC(rscy&(tree&)))
'
mx&=rscx&(tree&)
my&=rscy&(tree&)
' ------------------------------------------------- Bewegen
IF rsc%                                           ! SOLID...
REPEAT
'
~GRAF_MKSTATE(x&,y&,mb&,shift&)
'
x&=SUB(PRED(x&),fx&)
y&=SUB(PRED(y&),fy&)                          ! Clipping...
x&=MIN(MAX(x&,deskx&),SUB(ADD(deskx&,deskw&),w&))
y&=MIN(MAX(y&,desky&),SUB(ADD(desky&,deskh&),h&))
'
IF mx&<>x& OR my&<>y&
rsc_flipping(rsc_handle%(tree&),rsc%,mx&,my&,w&,h&,x&,y&)
mx&=x&
my&=y&
'
ENDIF
'
UNTIL mb&=0
'
~MFREE(rsc%)
'
ELSE                                              ! Nicht SOLID...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~GRAF_DRAGBOX(rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),deskx&,desky&,deskw&,deskh&,x&,y&)
ENDIF
' ------------------------------------------------- Hinsetzen
rscx&(tree&)=x&
rscy&(tree&)=y&
OB_X(rsc_adr%(tree&),0)=ADD(x&,3)
OB_Y(rsc_adr%(tree&),0)=ADD(y&,3)
'
IF rsc%=0                                         ! Nicht SOLID...
rsc_bitblt(0,0,0,rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
~OBJC_DRAW(rsc_adr%(tree&),0,10,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
'
IF edit_obj&
rsc_cursor(rsc_adr%(tree&),edit_obj&,idx&)    ! ...Cursor ein
ENDIF
ENDIF
'
~GRAF_MOUSE(0,0)
'
RETURN
> PROCEDURE rsc_flipping(rsc_back%,rsc%,ax&,ay&,w&,h&,x&,y&)
.| Ruft auf  : rsc_bitblt
.| Aufruf in : rsc_movedial-1,
LOCAL rb&,rh&,gw&,gh&
'
gw&=ABS(SUB(x&,ax&))         ! Verschiebbreite
gh&=ABS(SUB(y&,ay&))         ! Verschiebhîhe
rb&=SUB(w&,gw&)              ! Restbreite
rh&=SUB(h&,gh&)              ! Resthîhe
'
IF rb&<0 OR rh&<0            ! rsc% auûerhalb von rsc_back%
'
' Gesamten Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,h&,ax&,ay&)
'
' Gesamten Dialog aktualisieren -----
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,h&,0,0)
'
ELSE IF x&>ax&               ! nach rechts...
'
IF y&>ay&                  ! nach rechts-unten veschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,gh&,gw&,rh&,ax&,ADD(ay&,gh&))
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,gh&,ax&,ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,gh&,rb&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),rb&,gh&,0,rh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ELSE                      ! nach rechts-oben / rechts verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,gw&,rh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,0,rb&,rh&,0,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,rb&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ENDIF
'                         ! nach links / oben / unten...
ELSE IF y&>ay&              ! nach links-unten / unten verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,rb&,gh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,h&,ADD(ax&,rb&),ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,gh&,rb&,rh&,gw&,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,gw&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),w&,gh&,0,rh&)
'
ELSE                        ! nach links-oben / links / oben verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,rh&,ADD(ax&,rb&),ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,0,rb&,rh&,gw&,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,gh&),gw&,rh&,0,gh&)
'
ENDIF
'
rsc_bitblt(rsc%,w&,h&,0,0,0,0,0,w&,h&,x&,y&)
'
RETURN
> PROCEDURE rsc_set_cursor(rsc_adr%,mx&,my&,VAR edit_obj&,next_obj&,idx&)
.| Glob. Var.: wchar&
.| Aufruf in : button-1,
' Zeichengenaues Cursor-Positionieren mit der Maus...
' Nur die entsprechenden 2 Zeilen in 'rsc_do' (ziemlich am Ende) entREMen.
LOCAL x&,a&,i&,ob_spec%,a$
'
ob_spec%=OB_SPEC(rsc_adr%,next_obj&)
'
~OBJC_OFFSET(rsc_adr%,next_obj&,x&,a&)          ! Absolute X-Position
'
x&=DIV(SUB(mx&+SHR(wchar&,2),x&),wchar&)        ! Spaltenposition
'
a$=CHAR{{ADD(ob_spec%,4)}}                      ! Maske lesen
'
FOR a&=1 TO x&                                  ! Pos. im Eingabefeld...
IF MID$(a$,a&,1)="_"
INC i&                                      ! ...nur relevante
ENDIF
NEXT a&
SUB x&,(x&-i&)
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)    ! Cursor aus
'
ob_spec%=ADD({ob_spec%},x&)
'
a&=BYTE{ob_spec%}                               ! Zeichen merken
BYTE{ob_spec%}=0                                ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,next_obj&,0,idx&,1,idx&)    ! Cursor setzen
BYTE{ob_spec%}=a&                               ! ...und Zeichen restaurieren
'
edit_obj&=next_obj&
'
RETURN
> FUNCTION rsc_shortcut(tree&,scan|,shift&,VAR title&)
.| Felder    : rsc_adr%()
.| Aufruf in : key-1,
' MenÅshortcut ermitteln...
$F%
LOCAL a&,obj&,rsc_adr%,s$,t$
'
' tree&      : Index des MenÅbaumes
' scan|      : SCAN-Code der gedrÅckten Taste
' shift&     : Status der tastaturumschalttasten
' VAR title& : Bei Erfolg Objektnummer des MenÅtitels
'
SELECT scan|
CASE 2 TO 10                                   ! 1-2...
s$=CHR$(ADD(47,scan|))
CASE 15                                        ! TAB...
s$="I"
shift&=BSET(shift&,2)                        ! ...entspricht "^I"
'
CASE 59 TO 68,84 TO 93                         ! Ftasten...
IF scan|<84
s$="F"+STR$(SUB(scan|,58))                 ! ...normal
ELSE
s$="F"+STR$(SUB(scan|,83))                 ! ...mit Shift
ENDIF
CASE 71                                        ! ClrHome...
s$="CLR"
CASE 83                                        ! DELETE...
s$="DEL"
CASE 97                                        ! UNDO...
s$="UNDO"
CASE 98                                        ! HELP...
s$="HELP"
DEFAULT                                        ! Alles andere...
rsc_adr%={XBIOS(16,L:-1,L:-1,L:-1)}
s$=CHR$(BCLR(BYTE{ADD(rsc_adr%,scan|)},5))
ENDSELECT
'
IF BTST(shift&,3)                              ! Alternate...
s$=CHR$(7)+s$
ENDIF
IF BTST(shift&,2)                              ! Control...
s$="^"+s$
ENDIF
IF BTST(shift&,0) OR BTST(shift&,1)            ! Shift...
s$=CHR$(1)+s$
ENDIF
'
title&=2                                       ! Position des Titels
obj&=5                                         ! Beginn der eigentl. MenÅs
rsc_adr%=rsc_adr%(tree&)                       ! öbersichtlicher
'
REPEAT                                         ! alle Objekte d. MenÅbaums
INC obj&
'
IF BYTE(OB_TYPE(rsc_adr%,obj&))=28           ! G_STRING...
IF NOT BTST(OB_STATE(rsc_adr%,obj&),3)     ! disabled ?
'
t$=TRIM$(CHAR{OB_SPEC(rsc_adr%,obj&)})   ! MenÅpunkt-Text
'
a&=RINSTR(t$," ")
IF a&                                    ! Shortcut vorhanden ?
'
IF MID$(t$,SUCC(a&))=s$                ! hier der vermutete Shortcut
RETURN obj&                          ! gefunden
ENDIF
'
ENDIF
ENDIF
'
ELSE IF BYTE(OB_TYPE(rsc_adr%,obj&))=20      ! G_STRING ?
INC title&
ENDIF
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)          ! LAST_OB ?
'
title&=0
RETURN 0                                       ! nicht gef. oder disabled
ENDFUNC
> FUNCTION rsc_alert(icon&,text$,def&,button$)
.| Glob. Var.: rsc_alert&,wchar&,hchar&
.| Felder    : rsc_adr%(),rscw&(),rsch&(),rscx&(),rscy&()
.| Ruft auf  : rsc_text,rsc_draw,rsc_do,rsc_back
.| Aufruf in : copytoarr-1,
' Fliegende ALERT-Box...
$F%
LOCAL a&,b&,h&,i&,l&,len&,w&,x&,y&,z&,ab&,ah&,rsc&,rsc_adr%,a$,knr,kobj,rdraw
'
' Alert-Box darstellen...
'
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF rsc_alert&>-1 AND rscda=TRUE AND exerr=FALSE THEN      ! Wenn's den Baum gibt:
rsc_adr%=rsc_adr%(rsc_alert&)                               ! rsc_alert=GLOBAL
'
text$=text$+"|"
button$=button$+"|"
' ---------------------------------------------------- Icon bestimmen
OB_FLAGS(rsc_adr%,2)=BSET(OB_FLAGS(rsc_adr%,2),7)    ! Hidden...
OB_FLAGS(rsc_adr%,3)=BSET(OB_FLAGS(rsc_adr%,3),7)
OB_FLAGS(rsc_adr%,4)=BSET(OB_FLAGS(rsc_adr%,4),7)
'
OB_FLAGS(rsc_adr%,SUCC(icon&))=BCLR(OB_FLAGS(rsc_adr%,SUCC(icon&)),7)
' ---------------------------------------------------- Buttons
OB_FLAGS(rsc_adr%,10)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,10)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,11)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,11)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,12)=OR(&X100101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,12))) ! LAST_OB+EXIT+SELECT.
'                                                    ! Default-Button...
OB_FLAGS(rsc_adr%,9+def&)=BSET(OB_FLAGS(rsc_adr%,9+def&),1)
' ---------------------------------------------------- Textzeilen setzen
FOR i&=1 TO 5
a&=INSTR(text$,"|")
a$=LEFT$(text$,MIN(30,MAX(0,PRED(a&))))
IF LEN(a$)>0 THEN
a$=a$+" "
ENDIF
IF LEN(a$)>30 THEN
a$=LEFT$(a$,30)
ENDIF
text$=MID$(text$,SUCC(a&))
'
z&=MAX(z&,-i&*(a$<>""))                            ! Hîchste belegte Zeile
l&=MAX(l&,LEN(a$))                                 ! LÑngste Zeile
'
rsc_text(rsc_alert&,ADD(4,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Button-Texte setzen
FOR i&=1 TO 3
a&=INSTR(button$,"|")
a$=LEFT$(button$,MIN(10,MAX(0,PRED(a&))))
button$=MID$(button$,SUCC(a&))
'
ADD b&,-(a$<>"")                                   ! Anzahl Buttons
len&=MAX(len&,LEN(a$))                             ! LÑngster Button
'
rsc_text(rsc_alert&,ADD(9,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Dialog-Breite Ñndern
l&=MAX(l&,MUL(10,b&))                                ! Minimal-Breite
'
w&=OB_W(rsc_adr%,3)+MUL(wchar&,ADD(l&,5))
OB_W(rsc_adr%,0)=w&                                  ! Neue Breite
'
OB_X(rsc_adr%,1)=w&-PRED(OB_W(rsc_adr%,1))           ! Flydial verschieben
rscw&(rsc_alert&)=ADD(w&,6)
' ---------------------------------------------------- Dialog-Hîhe Ñndern
h&=OB_H(rsc_adr%,10)+MUL(hchar&,ADD(z&,2))
OB_H(rsc_adr%,0)=h&                                  ! Neue Hîhe
rsch&(rsc_alert&)=ADD(h&,6)
' ---------------------------------------------------- Buttons plazieren
len&=MUL(wchar&,MAX(8,SUCC(len&)))
OB_W(rsc_adr%,10)=len&                               ! Breite anpassen..
OB_W(rsc_adr%,11)=len&
OB_W(rsc_adr%,12)=len&
'
good=TRUE
SELECT b&                                            ! Anzahl Buttons...
CASE 1
OB_FLAGS(rsc_adr%,11)=BSET(OB_FLAGS(rsc_adr%,11),7)! ...hidden
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
' OB_X(rsc_adr%,10)=SHR(SUB(w&,OB_W(rsc_adr%,10)),1)
OB_X(rsc_adr%,10)=SUB(w&,OB_W(rsc_adr%,10))-2*wchar&
'
CASE 2
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
x&=w&-OB_W(rsc_adr%,11)-2*wchar&
OB_X(rsc_adr%,11)=x&
OB_X(rsc_adr%,10)=x&-OB_W(rsc_adr%,10)-wchar&
'
CASE 3
x&=w&-OB_W(rsc_adr%,12)-SHL(wchar&,1)              ! ...Mitte
OB_X(rsc_adr%,12)=x&
OB_X(rsc_adr%,11)=x&-OB_W(rsc_adr%,10)-wchar&
OB_X(rsc_adr%,10)=OB_X(rsc_adr%,11)-OB_W(rsc_adr%,10)-wchar&
'
ENDSELECT
'
y&=h&-OB_H(rsc_adr%,10)-SHR(hchar&,1)
OB_Y(rsc_adr%,10)=y&
OB_Y(rsc_adr%,11)=y&
OB_Y(rsc_adr%,12)=y&
' ---------------------------------------------------- Anzeigen
~FORM_CENTER(rsc_adr%(rsc_alert&),rscx&(rsc_alert&),rscy&(rsc_alert&),rscw&(rsc_alert&),rsch&(rsc_alert&))
'
rdraw=FALSE
'    IF rsc_handle%(nr)>1000                             ! Normaler Dialog...
'      rsc_back(nr)
'      rdraw=TRUE
'  ENDIF
knr=nr
kobj=obj
nr=alertbox&
@rsc_draw(nr,0)
rsc&=@rsc_do(nr,0,popup&)
rsc_back(nr)
nr=knr
obj=kobj
'    IF rdraw=TRUE THEN
'    @rsc_draw(nr,0)
'  ENDIF
rdraw=FALSE
' ----------------------------------------------------
OB_STATE(rsc_adr%,rsc&)=BCLR(OB_STATE(rsc_adr%,rsc&),0)! SELECTED lîschen
'
RETURN SUB(rsc&,9)                                   ! Nummer des Buttons 1-3
ELSE
' Normaler Alert...
WHILE INSTR(button$,"[")>0
button$=LEFT$(button$,PRED(INSTR(button$,"[")))+MID$(button$,SUCC(INSTR(button$,"[")))
WEND                                                   ! ...'[' rausfiltern
RETURN FORM_ALERT(def&,"["+STR$(icon&)+"]["+text$+"]["+button$+"]")
ENDIF
ENDFUNC
> PROCEDURE rsc_state(tree&,obj&,bit&,stat!)
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_tristate-4,rsc_tristate2-4,
' Setzen und Abfragen einzelner Bits in OB_STATE und OB_FLAGS...
'
' tree& : Index des Objektbaumes
' obj&  : Objektnummer
' bit&  : Zu setzendes Bit
' stat! : TRUE =Bit setzen, FALSE =Bit lîschen
'
IF stat!
OB_STATE(rsc_adr%(tree&),obj&)=BSET(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ELSE
OB_STATE(rsc_adr%(tree&),obj&)=BCLR(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ENDIF
'
RETURN
> PROCEDURE rsc_tristate(tree&,obj&)
.| Glob. Var.: tri#
.| Ruft auf  : rsc_state,rsc_draw_obj
.| Aufruf in : arrtristate-1,
' Behandlung eines Tristate-Buttons...
'
INC tri
IF tri=3 THEN
tri=0
ENDIF
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
RETURN
> PROCEDURE rsc_tristate2(tree&,obj&)
.| Glob. Var.: tri#
.| Ruft auf  : rsc_state,rsc_draw_obj
.| Aufruf in : arrnrset-4,arranger-4,arrdel-4,
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
RETURN
> PROCEDURE rsc_draw_obj(tree&,obj&)
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_tristate-1,rsc_tristate2-1,
' Zeichnen eines einzelnen Objektes...
LOCAL x&,y&
'
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
~OBJC_DRAW(rsc_adr%(tree&),obj&,8,x&,y&,OB_W(rsc_adr%(tree&),obj&),OB_H(rsc_adr%(tree&),obj&))
'
RETURN
> PROCEDURE rsc_redraw_obj(tree&,obj&)
.| Glob. Var.: edit_obj&,idx&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_message
.| Aufruf in : message-1,fadehandler-1,clsfade-1,fadedel-1,restaura3-1
.|     trakload-1,trakforw-1,trkbackw-1,hardfs-1,mforw-1,mbackw-1
.|     time_edit-1,coninsert-1,record2-1,record3-1,
' Sauberer Redraw eines Objektes, nur fÅr Fensterdialoge!...
LOCAL x&,y&,w&,h&
'
' Sendet einen Redraw-Event fÅr ein Objekt
' --------------------------------------------------
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
w&=OB_W(rsc_adr%(tree&),obj&)
h&=OB_H(rsc_adr%(tree&),obj&)
'
'  appl_write(ap_id&,20,rsc_handle%(tree&),x&-3,y&-3,w&+6,h&+6,"")   ! WM_REDRAW
rsc_message(tree&,20,x&-3,y&-3,w&+6,h&+6,edit_obj&,idx&)   ! WM_REDRAW
'
RETURN
> PROCEDURE appl_write(id&,msg&,handle&,x&,y&,w&,h&,a$)
.| Glob. Var.: msg%,ap_id&
.| Aufruf in : helptxt-2,
' LOCAL b$
'
' Sendet eine Message an ein Programm. Dabei kann es sich auch um
' das eigene Programm handeln (id&=ap_id&), siehe 'rsc_redraw_obj'
' --------------------------------------------------
INLINE msg%,256
'
INT{msg%}=msg&                                     ! 0 Message-ID
INT{msg%+2}=ap_id&                                 ! 1 Unsere ID
INT{msg%+4}=0                                      ! 2 Keine öberlÑnge
INT{msg%+6}=handle&                                ! 3
INT{msg%+8}=x&                                     ! 4 MenÅpunkt
INT{msg%+10}=y&                                    ! 5
INT{msg%+12}=w&                                    ! 6
INT{msg%+14}=h&                                    ! 7
'
'  IF x&=0                                            ! String (z.B. fÅr VA_START)...
CHAR{msg%+16}=LEFT$(a$,240)
{msg%+6}=msg%+16
' ENDIF
'
~APPL_WRITE(id&,16,msg%)                           ! Weg damit
'
RETURN
' ------------------------------------------------------------------------------
' ------------------------RCS-Zugriffs-Routinen---------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE windowtest
LOCAL v,v1,v1,wb,wh
IF fly=TRUE THEN
mywindow=TRUE
shading=FALSE
ELSE
~WIND_GET(v,10,wind_active,v,v,v)
IF wind_active=rsc_handle%(nr) THEN
mywindow=TRUE
~WIND_GET(rsc_handle%(nr),11,v1,v2,wb,wh)
IF wb=0 THEN
shading=TRUE
ELSE
shading=FALSE
ENDIF
ELSE
mywindow=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE textfeld(txtname,txt$,versatz)
LOCAL a
@windowtest
IF mywindow=TRUE THEN
~@xrsrc_gaddr(0,nr,zu%)
string=LPEEK(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
IF cupdate=FALSE AND shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'      @rsc_draw_obj(nr,txtname)
~OBJC_DRAW(zu%,txtname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
~FRE(0)
ENDIF
RETURN
'
> PROCEDURE textfeld2(drawnr,txtname,txt$,versatz)
LOCAL a
~@xrsrc_gaddr(0,drawnr,dzu%)
string=LPEEK(LPEEK(dzu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
RETURN
'
> PROCEDURE stringfeld(numb,txtname,txt$,versatz)
LOCAL a
~@xrsrc_gaddr(0,numb,zu%)
string=LPEEK(zu%+24*txtname+12)
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
EXIT IF a=0
POKE string+it-1+(versatz-1),a
NEXT it
RETURN
'
> PROCEDURE textbutt(parent,txtname,txt$,versatz)
@windowtest
IF mywindow=TRUE THEN
~@xrsrc_gaddr(0,nr,zu%)
string=(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
POKE string+it-1+(versatz-1),ASC(MID$(txt$,it,1))
NEXT it
IF shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,parent,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
RETURN
'
> PROCEDURE setbutton(buttnr,buttflag)
@windowtest
IF mywindow=TRUE THEN
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
IF shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE setbutton2(buttnr,buttflag,n)
LOCAL buttadr,zu%
@windowtest
IF mywindow=TRUE THEN
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,n,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
IF shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE drawbutton(buttnr)
@windowtest
IF mywindow=TRUE THEN
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,nr,zu%)
IF shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE setbild(buttnr,buttflag)
@windowtest
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
RETURN
'
> PROCEDURE hidetree(buttnr,buttflag,box)
LOCAL bf
@windowtest
IF mywindow=TRUE THEN
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
IF shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
IF shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,box,99,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE hidetree2(buttnr,buttflag)
LOCAL bf
@windowtest
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,0    ! setbutton lîschen
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
ENDIF
RETURN
'
> PROCEDURE readbutton(buttnr)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+10)
RETURN
'
> PROCEDURE flagbutton(buttnr,bfl)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE (buttadr+8),bfl
RETURN
'
> PROCEDURE readflag(buttnr)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+8)
RETURN
'
PROCEDURE readpos(buttnr)
.| Glob. Var.: nr#,zu%,buttadr#,bx#,by#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : dragging1-1,dragging2-1,
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
bx=DPEEK(buttadr+16)
by=DPEEK(buttadr+18)
RETURN
'
> PROCEDURE setpos(buttnr,bx,by)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+16,bx
DPOKE buttadr+18,by
RETURN
'
> PROCEDURE colorbox(nrr,buttnr,col,fill)
.| Glob. Var.: zu%,buttadr#,colflag#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : HAUPTPROGRAMM-68,
~@xrsrc_gaddr(0,nrr,zu%)
buttadr=zu%+24*buttnr
colflag=DPEEK(buttadr+14)
colflag=(colflag AND &HFFF0)+col
colflag=(colflag AND &HFF8F)+fill*16
DPOKE buttadr+14,colflag
RETURN
'
> PROCEDURE textcolor(nrr,buttnr,col,rahmen,fill)
~@xrsrc_gaddr(0,nrr,zu%)
buttadr=LPEEK(zu%+24*buttnr+12)
colflag=DPEEK(buttadr+18)
colflag=(colflag AND &HF0)+col*256+rahmen*4096+fill
DPOKE buttadr+18,colflag
RETURN
'
> PROCEDURE editread(edread)
.| Glob. Var.: nr#,zu%,editadr#,erd#,a$,bv$
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-2,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkproof-1,tedproof-1,setupdat-1,setsave-1,
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edread+12
erd=LPEEK(LPEEK(editadr))
a$=""
WHILE PEEK(erd)<>0
bv$=CHR$(PEEK(erd))
a$=a$+bv$
erd=erd+1
WEND
RETURN
'
> PROCEDURE editfeld(edname,ed$)
.| Glob. Var.: edit_obj&,nr#,zu%,editadr#,edanf#,edz#,ef#,ap#,xwidth#
.|     ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-8,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkart-1,tedart-2,setdat-1,
@windowtest
edit_obj&=0
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edname+12
edanf=LPEEK(LPEEK(editadr))
edz=LEN(ed$)
FOR ef=1 TO edz
ap=ASC(MID$(ed$,ef,1))
POKE edanf+ef-1,ap
NEXT ef
IF shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,edname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
~FRE(0)
RETURN
'
> PROCEDURE mouse(VAR mx,my,mk)
.| Aufruf in : message-1,normalize-1,fadehandler-2,markhandl4-1,arrsmpr-1
.|     dragging1-2,dragging2-2,arrmname-1,virtual-1,setupdat-1,midi-1
.|     do_peak-1,markhandler-1,
LOCAL void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx,my,mk,void&)
~WIND_UPDATE(2)
'
SUB mx,WORD{WINDTAB+64}
SUB my,WORD{WINDTAB+66}
RETURN
'
> FUNCTION mousek
$F%
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf4b-1
.|     maschruf5-1,maschruf5c-1,maschruf8b-1,fadehandler-1,fade-1,smptime-1
.|     movefrag-1,drawpix-2,edhandler2-3,smpsave-1,blklfrag-1,newfsel-1
.|     sampleinf-1,trkplay-1,dragging2-1,arrtristate-1,arrdelay-1,arrplay-1
.|     abackup-1,time_edit-1,make-1,smpsts-1,smpes-1,do_peak-1,peakwert-1
.|     markhandler-1,
LOCAL void&
'
'  ~WIND_UPDATE(3)
~GRAF_MKSTATE(void&,void&,mk&,void&)
'  ~WIND_UPDATE(2)
'
RETURN mk&
'
ENDFUNC
'
> FUNCTION mousex
$F%
.| Aufruf in : markhandl4-1,do_peak-1,
LOCAL mx&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx&,void&,void&,void&)
~WIND_UPDATE(2)
SUB mx&,WORD{WINDTAB+64}
'
RETURN mx&
'
ENDFUNC
'
> FUNCTION mousey
$F%
.| Aufruf in : markhandl4-1,do_peak-1,
LOCAL my&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(void&,my&,void&,void&)
~WIND_UPDATE(2)
SUB my&,WORD{WINDTAB+66}
'
RETURN my&
'
ENDFUNC
'
' ------------------------------------------------------------------------------
'          HardwareunabhÑngiger Teil - GEM
' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------
' ------------------------HAUPTPROGRAMM-----------------------------------------
' ------------------------------------------------------------------------------
'
> PROCEDURE calc_windows
IF freez=TRUE THEN                              ! Screen-Restauration
FOR i=0 TO 31
pkreinit=FALSE
IF i<>mensa AND i<>popups& AND i<>btree THEN
IF nosetload=FALSE THEN          ! Versionskontrolle
rscx&(i)=rx(i)
rscy&(i)=ry(i)
ENDIF
IF nosetload=FALSE AND (i=smpedit& OR i=peak& OR i=trakker&) THEN
IF prgversion<1.2 THEN          ! Versionskontrolle
b=OB_W(rsc_adr%(i),0)
h=OB_H(rsc_adr%(i),0)
ENDIF
IF prgversion>=1.2 THEN          ! Versionskontrolle
rscw&(i)=rb(i)
rsch&(i)=rh(i)
b=rb(i)
h=rh(i)
IF i=smpedit& THEN
xold=rscx&(i)
yold=rscy&(i)+19
bold=rscw&(i)
hold=rsch&(i)-19
xneu=rscx&(i)
yneu=rscy&(i)+19
bneu=rscw&(i)
hneu=rsch&(i)-19
ENDIF
IF i=peak& THEN
xold2=rscx&(i)
yold2=rscy&(i)+19
bold2=rscw&(i)
hold2=rsch&(i)-19
xneu2=rscx&(i)
yneu2=rscy&(i)+19
bneu2=rscw&(i)
hneu2=rsch&(i)-19
nr=i
notopen=TRUE
@calc_peaksize
nr=smpedit&
notopen=FALSE
ENDIF
IF i=trakker& THEN
xold3=rscx&(i)
yold3=rscy&(i)+19
bold3=rscw&(i)
hold3=rsch&(i)-19
xneu3=rscx&(i)
yneu3=rscy&(i)+19
bneu3=rscw&(i)
hneu3=rsch&(i)-19
nr=i
notopen=TRUE
@calc_traksize
nr=smpedit&
notopen=FALSE
ENDIF
ENDIF
ELSE
b=OB_W(rsc_adr%(i),0)
h=OB_H(rsc_adr%(i),0)
ENDIF
IF (rscx&(i)+b)>xwidth THEN
rscx&(i)=xwidth-b
IF i=smpedit& THEN
xold=rscx&(i)
xneu=rscx&(i)
ENDIF
IF i=peak& THEN
xold2=rscx&(i)
xneu2=rscx&(i)
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
xold3=rscx&(i)
xneu3=rscx&(i)
pkreinit=TRUE
ENDIF
ENDIF
IF (rscy&(i)+h)>ywidth THEN
rscy&(i)=ywidth-h
IF i=smpedit& THEN
yold=rscy&(i)+19
yneu=rscy&(i)+19
ENDIF
IF i=peak& THEN
yold2=rscy&(i)+19
yneu2=rscy&(i)+19
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
yold3=rscy&(i)+19
yneu3=rscy&(i)+19
pkreinit=TRUE
ENDIF
ENDIF
IF rscx&(i)<0 THEN
rscx&(i)=0
IF i=smpedit& THEN
xold=rscx&(i)
xneu=rscx&(i)
ENDIF
IF i=peak& THEN
xold2=rscx&(i)
xneu2=rscx&(i)
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
xold3=rscx&(i)
xneu3=rscx&(i)
pkreinit=TRUE
ENDIF
ENDIF
IF rscy&(i)<0 THEN
rscy&(i)=0
IF i=smpedit& THEN
yold=rscy&(i)+19
yneu=rscy&(i)+19
ENDIF
IF i=peak& THEN
yold2=rscy&(i)+19
yneu2=rscy&(i)+19
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
yold3=rscy&(i)+19
yneu3=rscy&(i)+19
pkreinit=TRUE
ENDIF
ENDIF
IF (rscx&(i)+rscw&(i))>xwidth THEN
rscw&(i)=xwidth-rscx&(i)
IF i=smpedit& THEN
bold=rscw&(i)
bneu=rscw&(i)
ENDIF
IF i=peak& THEN
bold2=rscw&(i)
bneu2=rscw&(i)
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
bold3=rscw&(i)
bneu3=rscw&(i)
pkreinit=TRUE
ENDIF
ENDIF
IF (rscy&(i)+rsch&(i))>ywidth THEN
rsch&(i)=ywidth-rscy&(i)
IF i=smpedit& THEN
hold=rsch&(i)-19
hneu=rsch&(i)-19
ENDIF
IF i=peak& THEN
hold2=rsch&(i)-19
hneu2=rsch&(i)-19
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
hold3=rsch&(i)-19
hneu3=rsch&(i)-19
pkreinit=TRUE
ENDIF
ENDIF
IF i=peak& AND pkreinit=TRUE THEN
nr=i
notopen=TRUE
@calc_peaksize
nr=smpedit&
notopen=FALSE
ENDIF
IF i=trakker& AND pkreinit=TRUE THEN
nr=i
notopen=TRUE
@calc_traksize
nr=smpedit&
notopen=FALSE
ENDIF
OB_X(rsc_adr%(i),0)=ADD(rscx&(i),3)
OB_Y(rsc_adr%(i),0)=ADD(rscy&(i),3)
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE change_colors
IF maxcol=2 THEN
@textcolor(peak&,peakmax&,0,1,1)  !text,rahmen,fill
@textcolor(peak&,peakch1&,1,1,0)  !text,rahmen,fill
@textcolor(peak&,peakch2&,1,1,0)  !text,rahmen,fill
@textcolor(peak&,peakch3&,1,1,0)  !text,rahmen,fill
@textcolor(peak&,peakch4&,1,1,0)  !text,rahmen,fill
@textcolor(marknumb&,mnumhelp&,1,1,0)
@textcolor(smp16&,helporig&,1,1,0)
@textcolor(smp16&,input&,1,1,0)
@textcolor(smp16&,rate2&,1,1,0)
@textcolor(smp16&,source&,1,1,0)
@textcolor(smp16&,mode&,1,1,0)
@textcolor(smp16&,protect&,1,1,0)
@textcolor(smp16&,emphasis&,1,1,0)
@textcolor(smp16&,dsp&,1,1,0)
@textcolor(smpedit&,smpedhlp&,1,1,0)
@textcolor(smpedit&,mover&,1,1,0)
@textcolor(smpedit&,rate&,1,1,0)
@textcolor(smpedit&,lr100&,1,1,0)
@textcolor(smpedit&,lp80&,1,1,0)
@textcolor(smpedit&,lp60&,1,1,0)
@textcolor(smpedit&,lp40&,1,1,0)
@textcolor(smpedit&,lp20&,1,1,0)
@textcolor(smpedit&,lp0&,1,1,0)
@textcolor(smpedit&,lm20&,1,1,0)
@textcolor(smpedit&,lm40&,1,1,0)
@textcolor(smpedit&,lm60&,1,1,0)
@textcolor(smpedit&,lm80&,1,1,0)
@textcolor(smpedit&,rp80&,1,1,0)
@textcolor(smpedit&,rp60&,1,1,0)
@textcolor(smpedit&,rp40&,1,1,0)
@textcolor(smpedit&,rp20&,1,1,0)
@textcolor(smpedit&,rp0&,1,1,0)
@textcolor(smpedit&,rm20&,1,1,0)
@textcolor(smpedit&,rm40&,1,1,0)
@textcolor(smpedit&,rm60&,1,1,0)
@textcolor(smpedit&,rm80&,1,1,0)
@textcolor(dspedit&,helpdsp&,1,1,0)
@textcolor(peak&,peakhelp&,1,1,0)
@textcolor(peak&,peakmax&,1,1,0)
@textcolor(peak&,peakpos&,1,1,0)
@textcolor(peak&,peakdb&,1,1,0)
@textcolor(peak&,peakbal&,1,1,0)
@textcolor(peak&,peakname&,1,1,0)
@textcolor(peak&,recpeaks&,1,1,0)
@textcolor(peak&,recerror&,1,1,0)
@textcolor(peak&,balbox&,1,1,0)
@textcolor(loop&,helploop&,1,1,0)
@textcolor(normaliz&,helpnorm&,1,1,0)
@textcolor(normaliz&,normdb&,1,1,0)
@textcolor(normaliz&,maxdb&,1,1,0)
@textcolor(resample&,helprsmp&,1,1,0)
@textcolor(resample&,resmplen&,1,1,0)
@textcolor(resample&,resmpsec&,1,1,0)
@textcolor(resample&,resmpfac&,1,1,0)
@textcolor(resample&,resother&,1,1,0)
@textcolor(midiedit&,helpmidi&,1,1,0)
@textcolor(midiedit&,notetxt&,1,1,0)
@textcolor(midiedit&,chtxt&,1,1,0)
@textcolor(editfade&,helpfade&,1,1,0)
@textcolor(record&,rechelp&,1,1,0)
@textcolor(record&,recfree&,1,1,0)
@textcolor(blkfunc&,blkhelp&,1,1,0)
@textcolor(savebloc&,savehelp&,1,1,0)
@textcolor(arranger&,arrhelp&,1,1,0)
@textcolor(arranger&,playlen&,1,1,0)
@textcolor(arranger&,playname&,1,1,0)
@textcolor(arranger&,arrnr1&,1,1,0)
@textcolor(arranger&,arrmem1&,1,1,0)
@textcolor(arranger&,spur1&,1,1,0)
@textcolor(arranger&,arrsmpr1&,1,1,0)
@textcolor(arranger&,arrnote1&,1,1,0)
@textcolor(arranger&,arrch1&,1,1,0)
@textcolor(arranger&,hardst1&,1,1,0)
@textcolor(arranger&,harde1&,1,1,0)
@textcolor(arranger&,hardlen1&,1,1,0)
@textcolor(arranger&,arrnr2&,1,1,0)
@textcolor(arranger&,arrmem2&,1,1,0)
@textcolor(arranger&,spur2&,1,1,0)
@textcolor(arranger&,arrsmpr2&,1,1,0)
@textcolor(arranger&,arrnote2&,1,1,0)
@textcolor(arranger&,arrch2&,1,1,0)
@textcolor(arranger&,hardst2&,1,1,0)
@textcolor(arranger&,harde2&,1,1,0)
@textcolor(arranger&,hardlen2&,1,1,0)
@textcolor(arranger&,arrnr3&,1,1,0)
@textcolor(arranger&,arrmem3&,1,1,0)
@textcolor(arranger&,spur3&,1,1,0)
@textcolor(arranger&,arrsmpr3&,1,1,0)
@textcolor(arranger&,arrnote3&,1,1,0)
@textcolor(arranger&,arrch3&,1,1,0)
@textcolor(arranger&,hardst3&,1,1,0)
@textcolor(arranger&,harde3&,1,1,0)
@textcolor(arranger&,hardlen3&,1,1,0)
@textcolor(arranger&,arrnr4&,1,1,0)
@textcolor(arranger&,arrmem4&,1,1,0)
@textcolor(arranger&,spur4&,1,1,0)
@textcolor(arranger&,arrsmpr4&,1,1,0)
@textcolor(arranger&,arrnote4&,1,1,0)
@textcolor(arranger&,arrch4&,1,1,0)
@textcolor(arranger&,hardst4&,1,1,0)
@textcolor(arranger&,harde4&,1,1,0)
@textcolor(arranger&,hardlen4&,1,1,0)
@textcolor(setup&,sethelp&,1,1,0)
@textcolor(setup&,tresdb&,1,1,0)
@textcolor(setup&,recm&,1,1,0)
@textcolor(setup&,seclen&,1,1,0)
@textcolor(setup&,fseltxt&,1,1,0)
@textcolor(setup&,setform&,1,1,0)
@textcolor(info&,helpinfo&,1,1,0)
@textcolor(arrmname&,amhelp&,1,1,0)
@textcolor(trknamin&,trktxhlp&,1,1,0)
@textcolor(virtual&,virthelp&,1,1,0)
@textcolor(virtual&,vblkmlen&,1,1,0)
@textcolor(virtual&,vblkvlen&,1,1,0)
@textcolor(arrmake&,makehelp&,1,1,0)
@textcolor(arrmake&,maketxt&,1,1,0)
@textcolor(arrmake&,makerate&,1,1,0)
@textcolor(timeed&,tedhelp&,1,1,0)
@textcolor(smpinf&,sinfhelp&,1,1,0)
@textcolor(smpinf&,sinfname&,1,1,0)
@textcolor(smpinf&,sinflen&,1,1,0)
@textcolor(smpinf&,sinfrate&,1,1,0)
@textcolor(smpinf&,sinfdate&,1,1,0)
@textcolor(smpinf&,sinfsus1&,1,1,0)
@textcolor(smpinf&,sinfsus2&,1,1,0)
@textcolor(smpinf&,sinfrel1&,1,1,0)
@textcolor(smpinf&,sinfrel2&,1,1,0)
@textcolor(smpinf&,sinfl1&,1,1,0)
@textcolor(smpinf&,sinfl2&,1,1,0)
@textcolor(smpinf&,sinfl3&,1,1,0)
@textcolor(smpinf&,sinfl4&,1,1,0)
@textcolor(smpinf&,sinfl5&,1,1,0)
@textcolor(smpinf&,sinfl6&,1,1,0)
@textcolor(smpinf&,sinfl7&,1,1,0)
@textcolor(smpinf&,sinfl8&,1,1,0)
@textcolor(smpinf&,sinfl9&,1,1,0)
@textcolor(smpinf&,sinfl10&,1,1,0)
@textcolor(smpinf&,sinfl11&,1,1,0)
@textcolor(smpinf&,sinfl12&,1,1,0)
@textcolor(trakker&,trakhelp&,1,1,0)
IF bigfoot=TRUE THEN
@textcolor(trakker&,trk4&,1,1,0)
@textcolor(trakker&,trk8&,1,1,0)
@textcolor(trakker&,trk12&,1,1,0)
@textcolor(trakker&,trk16&,1,1,0)
ENDIF
@textcolor(trakker&,trkmon&,1,1,0)
@textcolor(trakker&,trakk1&,1,1,0)
@textcolor(trakker&,trakk2&,1,1,0)
@textcolor(trakker&,trakk3&,1,1,0)
@textcolor(trakker&,trakk4&,1,1,0)
@textcolor(trakker&,trakstrt&,1,1,0)
@textcolor(trakker&,trakend&,1,1,0)
@textcolor(trakker&,traklen&,1,1,0)
@textcolor(trakker&,trksmpte&,1,1,0)
@textcolor(trakker&,trakdur&,1,1,0)
@textcolor(trakker&,tpstrt&,1,1,0)
@textcolor(trakker&,tpend&,1,1,0)
@textcolor(trakker&,trakinfo&,1,1,0)
@textcolor(trakker&,trakname&,1,1,0)
@textcolor(trakker&,traktime&,1,1,0)
@textcolor(trakker&,trkerr&,1,1,0)
@textcolor(trakker&,timeline&,1,1,0)
IF bigfoot=TRUE THEN
@textcolor(trakker&,timelin2&,1,1,0)
@textcolor(trakker&,trkslot2&,1,1,0)
ENDIF
@textcolor(trakker&,trkslot&,1,1,0)
@textcolor(fsel&,fshelp&,1,1,0)
@textcolor(fsel&,fsotxt&,1,1,0)
@textcolor(fsel&,fsbut1&,1,1,0)
@textcolor(fsel&,fsbut2&,1,1,0)
@textcolor(fsel&,fsbut3&,1,1,0)
@textcolor(fsel&,fsbut4&,1,1,0)
@textcolor(fsel&,fsbut5&,1,1,0)
@textcolor(fsel&,fsbut6&,1,1,0)
@textcolor(fsel&,fsbut7&,1,1,0)
@textcolor(fsel&,fsbut8&,1,1,0)
@textcolor(fsel&,fsbut9&,1,1,0)
@textcolor(fsel&,fsbut10&,1,1,0)
@textcolor(fsel&,fsbut11&,1,1,0)
@textcolor(fsel&,fsbut12&,1,1,0)
@textcolor(fsel&,fsbut13&,1,1,0)
@textcolor(fsel&,fsbut14&,1,1,0)
@textcolor(fsel&,fsbut15&,1,1,0)
@textcolor(fsel&,fstxt1&,1,1,0)
@textcolor(fsel&,fstxt2&,1,1,0)
@textcolor(fsel&,fstxt3&,1,1,0)
@textcolor(fsel&,fstxt4&,1,1,0)
@textcolor(fsel&,fstxt5&,1,1,0)
@textcolor(fsel&,fstxt6&,1,1,0)
@textcolor(fsel&,fstxt7&,1,1,0)
@textcolor(fsel&,fstxt8&,1,1,0)
@textcolor(fsel&,fstxt9&,1,1,0)
@textcolor(fsel&,fstxt10&,1,1,0)
@textcolor(fsel&,fstxt11&,1,1,0)
@textcolor(fsel&,fstxt12&,1,1,0)
@textcolor(fsel&,fstxt13&,1,1,0)
@textcolor(fsel&,fstxt14&,1,1,0)
@textcolor(fsel&,fstxt15&,1,1,0)
@textcolor(fsel&,fstime&,1,1,0)
@textcolor(arranger&,hlpedit2&,1,1,0)
@textcolor(moving&,movhlp&,1,1,0)
@textcolor(abackup&,abackhlp&,1,1,0)
@textcolor(abackup&,abacktxt&,1,1,0)
@textcolor(smpedit&,cstxt&,1,1,0)
@textcolor(smpedit&,cetxt&,1,1,0)
@textcolor(smpedit&,edmtims&,1,1,0)
@textcolor(smpedit&,edmtime&,1,1,0)
@textcolor(smpedit&,edmtimi&,1,1,0)
@textcolor(smpedit&,edmtimr&,1,1,0)
@textcolor(smpedit&,edmnr&,1,1,0)
@textcolor(smpedit&,edmtxt&,1,1,0)
@textcolor(smpedit&,smplen&,1,1,0)
@textcolor(smpedit&,smpfile&,1,1,0)
@textcolor(smpedit&,smpname&,1,1,0)
@textcolor(smpedit&,showxy&,1,1,0)
@textcolor(smpedit&,freemem&,1,1,0)
@textcolor(smpedit&,clock&,1,1,0)
@textcolor(smpedit&,pntprsmp&,1,1,0)
@textcolor(smpedit&,smprate&,1,1,0)
@textcolor(smpedit&,smpsec&,1,1,0)
@textcolor(smpedit&,mintext&,1,1,0)
@textcolor(trakker&,trklevt1&,1,1,0)
@textcolor(trakker&,trklevt2&,1,1,0)
@textcolor(trakker&,trklevt3&,1,1,0)
@textcolor(trakker&,trklevt4&,1,1,0)
@textcolor(trakker&,trktxt1&,1,1,0)
@textcolor(trakker&,trktxt2&,1,1,0)
@textcolor(trakker&,trktxt3&,1,1,0)
@textcolor(trakker&,trktxt4&,1,1,0)
@textcolor(trakker&,pantxt1&,1,1,0)
@textcolor(trakker&,pantxt2&,1,1,0)
@textcolor(trakker&,pantxt3&,1,1,0)
@textcolor(trakker&,pantxt4&,1,1,0)
@textcolor(trakker&,trksize&,1,1,0)
@textcolor(trakker&,trkvbox&,1,1,0)
@textcolor(disked&,dskedtxt&,1,1,0)
@textcolor(meldung&,meldtxt&,1,1,0)
@textcolor(mrkfind&,mrkfnr&,1,1,0)
@textcolor(mrkfind&,mrkftims&,1,1,0)
@textcolor(mrkfind&,mrkftime&,1,1,0)
@textcolor(mrkfind&,mrkftimi&,1,1,0)
@textcolor(mrkfind&,mrkftimr&,1,1,0)
@textcolor(mrkfind&,mrkftxt&,1,1,0)
@textcolor(smpedit&,edmnr&,1,1,0)
@textcolor(smpedit&,edmtims&,1,1,0)
@textcolor(smpedit&,edmtime&,1,1,0)
@textcolor(smpedit&,edmtimi&,1,1,0)
@textcolor(smpedit&,edmtimr&,1,1,0)
@textcolor(smpedit&,edmtxt&,1,1,0)
@textcolor(smpedit&,smpedhlp&,1,1,0)
@textcolor(trkcomin&,trkchlp&,1,1,0)
@textcolor(mrktxtin&,mtexhelp&,1,1,0)
@textcolor(mrkfind&,mrkfhelp&,1,1,0)
@textcolor(disked&,dskedhlp&,1,1,0)
@textcolor(wmode&,wmhelp&,1,1,0)
@textcolor(clocks&,clockhlp&,1,1,0)
@textcolor(clocks&,clockm&,1,1,0)
@textcolor(clocks&,clock1&,1,1,0)
@textcolor(clocks&,clock2&,1,1,0)
@textcolor(clocks&,clock3&,0,1,1)
@textcolor(clocks&,clock4&,1,1,0)
@textcolor(clocks&,clock5&,1,1,0)
@textcolor(smpedit&,resolu&,1,1,0)
@textcolor(plugin&,panhelp&,1,1,0)
@textcolor(plugin&,levcnt1&,1,1,0)
@textcolor(plugin&,levcnt2&,1,1,0)
@textcolor(plugin&,levcnt3&,1,1,0)
@textcolor(plugin&,levcnt4&,1,1,0)
@textcolor(plugin&,levcnt5&,1,1,0)
@textcolor(plugin&,levart1&,1,1,0)
@textcolor(plugin&,levart2&,1,1,0)
@textcolor(plugin&,levart3&,1,1,0)
@textcolor(plugin&,levart4&,1,1,0)
@textcolor(plugin&,levart5&,1,1,0)
@textcolor(plugin&,levtxt1&,1,1,0)
@textcolor(plugin&,levtxt2&,1,1,0)
@textcolor(plugin&,levtxt3&,1,1,0)
@textcolor(plugin&,levtxt4&,1,1,0)
@textcolor(plugin&,levtxt5&,1,1,0)
@textcolor(plugin&,plugct1&,1,1,0)
@textcolor(plugin&,plugct2&,1,1,0)
@textcolor(plugin&,plugct3&,1,1,0)
@textcolor(plugin&,plgtitel&,1,1,0)
@textcolor(plgconfg&,pcfghelp&,1,1,0)
@textcolor(plgconfg&,plgcfg1&,1,1,0)
@textcolor(plgconfg&,plgcfg2&,1,1,0)
@textcolor(plgconfg&,plgcfg3&,1,1,0)
@textcolor(plgconfg&,plgcfg4&,1,1,0)
@textcolor(plgconfg&,plgcfg5&,1,1,0)
@textcolor(plgconfg&,plgcfg6&,1,1,0)
@textcolor(plgconfg&,plgcfg7&,1,1,0)
@textcolor(plgconfg&,plgcfg8&,1,1,0)
@textcolor(plgconfg&,plgcfg9&,1,1,0)
@textcolor(plgconfg&,plgcfg10&,1,1,0)
@textcolor(plgconfg&,plgrec1&,1,1,0)
@textcolor(plgconfg&,plgrec2&,1,1,0)
@textcolor(plgconfg&,plgrec3&,1,1,0)
@textcolor(plgconfg&,plgrec4&,1,1,0)
@textcolor(plgconfg&,plgrec5&,1,1,0)
@textcolor(plgconfg&,plgplay1&,1,1,0)
@textcolor(plgconfg&,plgplay2&,1,1,0)
@textcolor(plgconfg&,plgplay3&,1,1,0)
@textcolor(plgconfg&,plgplay4&,1,1,0)
@textcolor(plgconfg&,plgplay5&,1,1,0)
@textcolor(plgconfg&,pcfgtex1&,1,1,0)
@textcolor(plgconfg&,pcfgtex2&,1,1,0)
@textcolor(plgconfg&,pcfgtex3&,1,1,0)
@colorbox(plugin&,panbox&,0,7)
@colorbox(plgconfg&,pcfgbox&,0,7)
@colorbox(smp16&,mainbox6&,0,7)
@colorbox(smp16&,mainbox&,0,7)
@colorbox(smp16&,mainbox2&,0,7)
@colorbox(smp16&,mainbox4&,0,7)
@colorbox(smp16&,mainbox5&,0,7)
@colorbox(smpedit&,editbox&,0,7)
@colorbox(smpedit&,editbox2&,0,7)
@colorbox(smpedit&,editbox3&,0,7)
@colorbox(smpedit&,editbox5&,0,7)
@colorbox(smpedit&,editbox6&,0,7)
@colorbox(smpedit&,editbox7&,0,7)
@colorbox(smpedit&,zomslide&,1,1)
@colorbox(smpedit&,edmslide&,1,1)
@colorbox(smpedit&,scrlslde&,1,1)
@colorbox(smpedit&,curvbox&,0,7)
@colorbox(smpedit&,editbox4&,0,7)
@colorbox(smpedit&,editbox8&,0,7)
@colorbox(peak&,peakbox&,0,7)
@colorbox(peak&,pkmbox&,0,7)
@colorbox(peak&,pkmbox2&,0,7)
@colorbox(peak&,peakbox2&,0,7)
@colorbox(peak&,volbox&,0,7)
@colorbox(loop&,loopbox&,0,7)
@colorbox(loop&,loopbox2&,0,7)
@colorbox(normaliz&,normbox&,0,7)
@colorbox(normaliz&,normbox2&,0,7)
@colorbox(resample&,resmpbox&,0,7)
@colorbox(midiedit&,midibox&,0,7)
@colorbox(editfade&,fadebox&,0,7)
@colorbox(editfade&,edfadbox&,0,7)
@colorbox(record&,recbox&,0,7)
@colorbox(blkfunc&,blkbox&,0,7)
@colorbox(savebloc&,savebox&,0,7)
@colorbox(arranger&,arrbox&,0,7)
@colorbox(arranger&,arrbox2&,0,7)
@colorbox(arranger&,arrbox3&,0,7)
@colorbox(arranger&,arrbox4&,0,7)
@colorbox(arranger&,arrbox5&,0,7)
@colorbox(arranger&,arrbox6&,0,7)
@colorbox(arranger&,arrbox7&,0,7)
@colorbox(arranger&,arrbox8&,0,7)
@colorbox(arranger&,arrslide&,1,1)
@colorbox(info&,infobox&,0,7)
@colorbox(trknamin&,trktxbox&,0,7)
@colorbox(trknamin&,trktxbo2&,0,7)
@colorbox(arrmname&,arrmnbox&,0,7)
@colorbox(arrmname&,arrmnbx2&,0,7)
@colorbox(dspedit&,dspbox&,0,7)
@colorbox(virtual&,virtbox&,0,7)
@colorbox(virtual&,virtbox2&,0,7)
@colorbox(virtual&,virtbox3&,0,7)
@colorbox(virtual&,vslider&,1,1)
@colorbox(moving&,movngbox&,0,7)
@colorbox(arrmake&,makebox&,0,7)
@colorbox(timeed&,timebox&,0,7)
@colorbox(timeed&,timebox2&,0,7)
@colorbox(abackup&,abackbox&,0,7)
@colorbox(abackup&,abackbo2&,0,7)
@colorbox(inftxt&,infbox&,0,7)
@colorbox(inftxt&,infbox2&,0,7)
@colorbox(trakker&,trakbox&,0,7)
@colorbox(trakker&,trakedbx&,0,7)
@colorbox(trakker&,trakbox2&,0,7)
@colorbox(trakker&,trakbox3&,0,7)
@colorbox(trakker&,trakbox4&,0,7)
@colorbox(trakker&,trakbox5&,0,7)
@colorbox(trakker&,trakbxw&,0,7)
@colorbox(trakker&,trakslid&,1,1)
@colorbox(trakker&,zoomslid&,1,1)
@colorbox(trakker&,spurslid&,1,1)
@colorbox(mrkfind&,mrkfslid&,1,1)
@colorbox(setup&,setupbox&,0,7)
@colorbox(setup&,setupbx2&,0,7)
@colorbox(setup&,setupbx3&,0,7)
@colorbox(fsel&,fselbox&,0,7)
@colorbox(fsel&,fselbox2&,0,7)
@colorbox(fsel&,fsslide&,1,1)
@colorbox(smpinf&,sinfbox&,0,7)
@colorbox(smpinf&,sinfbox2&,0,7)
@colorbox(trakker&,tlevbox&,0,7)
@colorbox(trakker&,trkbx1&,0,7)
@colorbox(trakker&,trkbx2&,0,7)
@colorbox(trakker&,trkbx3&,0,7)
@colorbox(trakker&,trkbx4&,0,7)
@colorbox(meldung&,meldbox&,0,7)
@colorbox(trkcomin&,trkcbox&,0,7)
@colorbox(trkcomin&,trkcbox2&,0,7)
@colorbox(mrktxtin&,mtexbox&,0,7)
@colorbox(mrktxtin&,mtexbox2&,0,7)
@colorbox(mrkfind&,mrkfbox&,0,7)
@colorbox(mrkfind&,mrkfbox2&,0,7)
IF bigfoot=TRUE THEN
@colorbox(mrkfind&,mrkfbox3&,0,7)
@colorbox(trakker&,trakbox6&,0,7)
ENDIF
@colorbox(disked&,dskedbox&,0,7)
@colorbox(disked&,dskedbx2&,0,7)
@colorbox(disked&,dskedbx3&,0,7)
@colorbox(disked&,dskedbx4&,0,7)
@colorbox(alertbox&,alertcol&,0,7)
@colorbox(wmode&,wmbox1&,0,7)
@colorbox(wmode&,wmbox2&,0,7)
@colorbox(wmode&,wmbox3&,0,7)
@colorbox(wmode&,wmbox4&,0,7)
@colorbox(wmode&,wmbox5&,0,7)
@colorbox(wmode&,wmbox7&,0,7)
@colorbox(clocks&,clkbox&,0,7)
@colorbox(clocks&,clkbox2&,0,7)
@colorbox(clocks&,clkslid&,1,1)
@colorbox(marknumb&,mnumbox&,0,7)
@colorbox(marknumb&,mnumbox2&,0,7)
ELSE
@colorbox(smpedit&,curvbox&,smpwcol,7)
@colorbox(smpedit&,editbox4&,smpblkcol,7)
@colorbox(smpedit&,editbox8&,smpblkcol,7)
@colorbox(trakker&,trakbox2&,smpblkcol,7)
@colorbox(trakker&,trakedbx&,smpwcol,7)
@textcolor(trakker&,trkslot&,0,smpwcol,smpwcol)
@textcolor(trakker&,trkslot2&,0,smpwcol,smpwcol)
@textcolor(trakker&,timeline&,0,smpwcol,smpwcol)
@textcolor(trakker&,timelin2&,0,smpwcol,smpwcol)
@textcolor(trakker&,trktitxt&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lr100&,6,smpwcol,smpwcol)
@textcolor(smpedit&,lp80&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lp60&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lp40&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lp20&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lp0&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lm20&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lm40&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lm60&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lm80&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rp80&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rp60&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rp40&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rp20&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rp0&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rm20&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rm40&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rm60&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rm80&,0,smpwcol,smpwcol)
@textcolor(smpedit&,smptxl&,0,smpwcol,smpwcol)
@textcolor(smpedit&,smptxr&,0,smpwcol,smpwcol)
ENDIF
RETURN
'
> PROCEDURE bigtext(tre,t$,n)
LOCAL l,s
@markhlp
s=40
GRAPHMODE 1
DEFFILL 1,1,1
PBOX ax&-1+texposx,ay&-38+texposy+n*(s+5),ax&-1+texposx+bneu2-21,ay&-38+texposy-s-1+n*(s+5)
IF n=0 THEN
IF maxcol=2 THEN
DEFTEXT 0,2,0,s
ELSE
DEFTEXT 9,0,0,s
ENDIF
ELSE
DEFTEXT 0,0,0,s
ENDIF
GRAPHMODE 2
l=LEN(t$)
IF l>11 THEN
t$=LEFT$(t$,11)
ENDIF
TEXT ax&-1+texposx+13,ay&-38+texposy-4+n*(s+5),t$
DEFTEXT 1,0,0,4
RETURN
'
> PROCEDURE bigtext2
LOCAL s
IF bigtxt=TRUE AND nr=peak& THEN
@markhlp
s=40
GRAPHMODE 1
DEFFILL 1,1,1
PBOX ax&-1+texposx,ay&-38+texposy+0*(s+5),ax&-1+texposx+bneu2-21,ay&-38+texposy-s-1+0*(s+5)
PBOX ax&-1+texposx,ay&-38+texposy+1*(s+5),ax&-1+texposx+bneu2-21,ay&-38+texposy-s-1+1*(s+5)
ENDIF
RETURN
'
> PROCEDURE bigtext3(x,y,n,t$,a,b)
LOCAL l,s,m,m2,m3
s=11
s2=6
GRAPHMODE 1
IF maxcol=2 THEN
DEFFILL 0,1,0
ELSE
DEFFILL smpwcol,1,smpwcol
ENDIF
m=s2*n*11
m2=INT(m/2/n)+2
m3=LEN(t$)*s2
IF a=0 THEN
PBOX x-m2-5,y,x+m2-4,y-s
m3=INT(m3/2)
ELSE
PBOX x-m2-5,y,x+m2-4,y-s
m3=INT(m3/2)+5
ENDIF
IF maxcol=2 THEN
IF b=6 THEN
DEFTEXT 1,2,0,s
ELSE
DEFTEXT 1,0,0,s
ENDIF
ELSE
DEFTEXT b,0,0,s
ENDIF
GRAPHMODE 2
l=LEN(t$)
IF l>11 THEN
t$=LEFT$(t$,11)
ENDIF
TEXT x-m3+1,y,t$
DEFTEXT 1,0,0,4
RETURN
'
> PROCEDURE calc_editsize
LOCAL v,hadd,hadd2,hadd4,q
IF (freez=TRUE AND notopen=TRUE) OR notopen=FALSE THEN
IF bneu<1020 THEN
bneu=1020
ENDIF
IF hneu<562 THEN
hneu=562
ENDIF
bneu=bneu-6
hneu=hneu-6
@buttbh(editbox7&,b,h)
badd=bneu-b
IF cefadd2=FALSE THEN
cefadd=16
cefadd2=TRUE
ELSE
cefadd=0
ENDIF
hadd=hneu-h+cefadd
hadd2=INT(hadd/2)
hadd4=INT(hadd/4)
@setbuttbh(editbox7&,bneu,hneu)
@buttbh(editbox2&,b,h)
b=b+badd
@setbuttbh(editbox2&,b,h)
@buttbh(curvbox&,b,h)
b=b+badd
h=h+hadd
@setbuttbh(curvbox&,b,h)
@buttbh(editbox4&,b,h)
b=b+badd
h=h+hadd2
@setbuttbh(editbox4&,b,h)
@buttbh(editbox8&,b,h)
b=b+badd
h=h+hadd2
@setbuttbh(editbox8&,b,h)
@readpos(editbox&)
bx=INT(bx+badd/2)
by=by+hadd
@setpos(editbox&,bx,by)
@readpos(lscroll&)
by=by+hadd
@setpos(lscroll&,bx,by)
@readpos(rscroll&)
bx=bx+badd
by=by+hadd
@setpos(rscroll&,bx,by)
@readpos(scrlslde&)
by=by+hadd
@setpos(scrlslde&,bx,by)
@buttbh(scrlslde&,b,h)
b=b+badd
@setbuttbh(scrlslde&,b,h)
@readpos(editbox8&)
by=by+hadd2
@setpos(editbox8&,bx,by)
@readpos(smpsave&)
v=16
bx=bneu-v-32
@setpos(smpsave&,bx,by)
bx=bneu-v-32*2
@setpos(smpload&,bx,by)
bx=bneu-v-32*3
@setpos(disk&,bx,by)
bx=bneu-v-32*4
@setpos(smpdbank&,bx,by)
@readpos(blkfiler&)
bx=bneu-v-15-32
@setpos(blkfiler&,bx,by)
bx=bneu-(v-1)-32*4
@setpos(blkfilel&,bx,by)
@readpos(blkfile&)
bx=bneu-(v-21)-32*3
@setpos(blkfile&,bx,by)
@calc_editboxes1
cached=FALSE
q=(ym+3)/10
@readpos(lp80&)
by2=4+q
@setpos(lp80&,bx,by2)
@readpos(lp60&)
by2=by2+q
by=INT(by2)
@setpos(lp60&,bx,by)
@readpos(lp40&)
by2=by2+q
by=INT(by2)
@setpos(lp40&,bx,by)
@readpos(lp20&)
by2=by2+q
by=INT(by2)
@setpos(lp20&,bx,by)
@readpos(lp0&)
by2=by2+q
by=INT(by2)
@setpos(lp0&,bx,by)
@readpos(lm20&)
by2=by2+q
by=INT(by2)
@setpos(lm20&,bx,by)
@readpos(lm40&)
by2=by2+q
by=INT(by2)
@setpos(lm40&,bx,by)
@readpos(lm60&)
by2=by2+q
by=INT(by2)
@setpos(lm60&,bx,by)
@readpos(lm80&)
by2=by2+q
by=INT(by2)
@setpos(lm80&,bx,by)
@readpos(lr100&)
by2=by2+q+1
by=INT(by2)
@setpos(lr100&,bx,by)
@readpos(rp80&)
by2=by2+q+2
by=INT(by2)
@setpos(rp80&,bx,by)
@readpos(rp60&)
by2=by2+q
by=INT(by2)
@setpos(rp60&,bx,by)
@readpos(rp40&)
by2=by2+q
by=INT(by2)
@setpos(rp40&,bx,by)
@readpos(rp20&)
by2=by2+q
by=INT(by2)
@setpos(rp20&,bx,by)
@readpos(rp0&)
by2=by2+q
by=INT(by2)
@setpos(rp0&,bx,by)
@readpos(rm20&)
by2=by2+q
by=INT(by2)
@setpos(rm20&,bx,by)
@readpos(rm40&)
by2=by2+q
by=INT(by2)
@setpos(rm40&,bx,by)
@readpos(rm60&)
by2=by2+q
by=INT(by2)
@setpos(rm60&,bx,by)
@readpos(rm80&)
by2=by2+q
by=INT(by2)
@setpos(rm80&,bx,by)
@readpos(smptxl&)
bx=bneu-38
by=by+hadd4
@setpos(smptxl&,bx,by)
@readpos(smptxr&)
bx=bneu-38
by=by+hadd2+hadd4
@setpos(smptxr&,bx,by)
IF smpedda=TRUE THEN
@rsc_back(nr)
ENDIF
rscx&(nr)=xneu
rscy&(nr)=yneu-18
rscw&(nr)=bneu+6
rsch&(nr)=hneu+6+16
@setpos(editbox7&,xneu+3,yneu+3-18)
@scrollinit
@wischwasch
IF notopen=FALSE THEN
@rsc_draw(nr,7)
@restaura
ENDIF
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
ENDIF
RETURN
'
> PROCEDURE calc_peaksize
IF (freez=TRUE AND notopen=TRUE) OR notopen=FALSE THEN
bigpeak=532
IF bneu2<>316 THEN
bneu2=316
ENDIF
IF hneu2<406 THEN
hneu2=406
ENDIF
bneu2=bneu2-6
hneu2=hneu2-6
IF hneu2>bigpeak THEN
IF bigtxt=FALSE THEN
@readpos(pkmbox&)
pkmx=bx
@readpos(pkmbox2&)
pkmx2=bx
@readpos(peakhelp&)
pkmx3=bx
pkmy3=by
@readpos(peakexit&)
pkmx4=bx
pkmy4=by
@readpos(peakmute&)
pkmx5=bx
pkmy5=by
@readpos(balzero&)
pkmx6=bx
pkmy6=by
hadds=32
ELSE
@readpos(pkmbox&)
by=by+102
@setpos(pkmbox&,pkmx,by)
@readpos(pkmbox2&)
by=by+432
@setpos(pkmbox2&,pkmx2,by)
'
@readpos(peakhelp&)
by=by-84
@setpos(peakhelp&,pkmx3,by)
@readpos(peakexit&)
by=by-55
@setpos(peakexit&,pkmx4,by)
@readpos(peakmute&)
by=by+130
@setpos(peakmute&,pkmx5,by)
@readpos(balzero&)
by=by+105
@setpos(balzero&,pkmx6,by)
hadds=0
ENDIF
bigtxt=TRUE
@hidetree2(peakpos&,TRUE)
@hidetree2(peakpost&,TRUE)
@hidetree2(peakmax&,TRUE)
@hidetree2(peakmaxt&,TRUE)
ELSE
IF bigtxt=TRUE THEN
@readpos(pkmbox&)
by=by+102
@setpos(pkmbox&,pkmx,by)
@readpos(pkmbox2&)
by=by+432
@setpos(pkmbox2&,pkmx2,by)
@readpos(peakhelp&)
by=by-84
@setpos(peakhelp&,pkmx3,by)
@readpos(peakexit&)
by=by-55
@setpos(peakexit&,pkmx4,by)
@readpos(peakmute&)
by=by+130
@setpos(peakmute&,pkmx5,by)
@readpos(balzero&)
by=by+105
@setpos(balzero&,pkmx6,by)
hadds=-32
ELSE
hadds=0
ENDIF
bigtxt=FALSE
@hidetree2(peakpos&,FALSE)
@hidetree2(peakpost&,FALSE)
@hidetree2(peakmax&,FALSE)
@hidetree2(peakmaxt&,FALSE)
ENDIF
texposx=4
texposy=hneu2-62-32
@buttbh(peakbox&,b,h)
badd=bneu2-b
hadd=hneu2-h+16-hadds
hadd2=INT(hadd/2)
hadd4=INT(hadd/4)
@setbuttbh(peakbox&,bneu2,hneu2+16)
@readpos(peakname&)
by=by+hadd
@setpos(peakname&,bx,by)
@readpos(peakmute&)
by=by+hadd
IF hneu2>bigpeak THEN
bx=bneu2-78
by=by-130
ENDIF
@setpos(peakmute&,bx,by)
@readpos(balzero&)
by=by+hadd
IF hneu2>bigpeak THEN
bx=bneu2-78
by=by-105
ENDIF
@setpos(balzero&,bx,by)
@readpos(peakhelp&)
by=by+hadd
IF hneu2>bigpeak THEN
bx=8
by=by+84
ENDIF
@setpos(peakhelp&,bx,by)
@readpos(peakexit&)
by=by+hadd
IF hneu2>bigpeak THEN
bx=bneu2-76
by=by+55
ENDIF
@setpos(peakexit&,bx,by)
'
@readpos(pkmbox&)
by=by+hadd
IF hneu2>bigpeak THEN
by=by-102
ENDIF
@setpos(pkmbox&,bx,by)
bx2=bx
@readpos(pkmbox2&)
by=by+hadd
IF hneu2>bigpeak THEN
by=by-432
bx=bx2+30
ENDIF
@setpos(pkmbox2&,bx,by)
@readpos(peaktl&)
by=by+hadd
@setpos(peaktl&,bx,by)
@readpos(peaktr&)
by=by+hadd
@setpos(peaktr&,bx,by)
@buttbh(peakbox2&,b,h)
h=h+hadd
@setbuttbh(peakbox2&,b,h)
@buttbh(plmax&,b,h)
h=h+hadd
@setbuttbh(plmax&,b,h)
@buttbh(prmax&,b,h)
h=h+hadd
@setbuttbh(prmax&,b,h)
IF smpedda=TRUE THEN
@rsc_back(nr)
ENDIF
nr=peak&
rscx&(nr)=xneu2
rscy&(nr)=yneu2-18
rscw&(nr)=bneu2+6
rsch&(nr)=hneu2+6+16
@setpos(peakbox&,xneu2+3,yneu2+3-18)
@buttbh(plmax&,v,peaksize)
DEC peaksize
wymax=peaksize
pkblk=(wymax+3)/9                  ! Einteilungs-Blockgroesse
pkrot=pkblk-2                      ! roter Bereich in Pixeln
pksix=pkrot+4*pkblk                ! -6db-Bereich
@readpos(pmdb1&)
by2=by-1
@readpos(pmdb2&)
by2=by2+pkblk
@setpos(pmdb2&,bx,by2)
@readpos(pmdb3&)
by2=by2+pkblk
@setpos(pmdb3&,bx,by2)
@readpos(pmdb4&)
by2=by2+pkblk
@setpos(pmdb4&,bx,by2)
@readpos(pmdb5&)
by2=by2+pkblk
@setpos(pmdb5&,bx,by2)
@readpos(pmdb6&)
by2=by2+pkblk
@setpos(pmdb6&,bx,by2)
@readpos(pmdb7&)
by2=by2+pkblk
@setpos(pmdb7&,bx,by2)
@readpos(pmdb8&)
by2=by2+pkblk
@setpos(pmdb8&,bx,by2)
@readpos(pmdb9&)
by2=by2+pkblk
@setpos(pmdb9&,bx,by2)
@readpos(pmdb10&)
by2=by2+pkblk
@setpos(pmdb10&,bx,by2)
wpl=0   ! peakhold left
wpr=0   ! peakhold right
vpl=0   ! peakhold left
vpr=0   ! peakhold right
pl=0   ! peakhold left
pr=0   ! peakhold right
@wischwasch
IF notopen=FALSE THEN
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE calc_traksize
LOCAL v,hadd,hadd2,hadd4,q
IF (freez=TRUE AND notopen=TRUE) OR notopen=FALSE THEN
tcached=FALSE
IF bneu3<1008 THEN
bneu3=1008
ENDIF
IF hneu3<692 THEN
hneu3=692
ENDIF
bneu3=bneu3-6
hneu3=hneu3-6
@buttbh(trakbox&,b,h)
badd=bneu3-b
badd2=INT(badd/2)
IF cefaddb2=FALSE THEN
cefaddb=16
cefaddb2=TRUE
ELSE
cefaddb=0
ENDIF
hadd=hneu3-h+cefaddb
hadd=INT(hadd/4)*4
hneu3=hadd+h-cefaddb
hadd2=hadd/2
hadd4=hadd/4
@setbuttbh(trakbox&,bneu3,hneu3)
@readpos(trakbxw&)
bx=bx+badd2
by=by+hadd
@setpos(trakbxw&,bx,by)
@buttbh(trakedbx&,b,h)
b=b+badd
h=h+hadd
@setbuttbh(trakedbx&,b,h)
@buttbh(trakbox3&,b,h)
b=b+badd
@setbuttbh(trakbox3&,b,h)
@readpos(zoomslid&)
by=by+hadd
@setpos(zoomslid&,bx,by)
@readpos(zoomxl&)
by=by+hadd
@setpos(zoomxl&,bx,by)
@readpos(zoomxr&)
by=by+hadd
@setpos(zoomxr&,bx,by)
@readpos(trakxl&)
by=by+hadd
@setpos(trakxl&,bx,by)
@readpos(trakslid&)
by=by+hadd
@setpos(trakslid&,bx,by)
@buttbh(trakslid&,b,h)
b=b+badd
@setbuttbh(trakslid&,b,h)
@readpos(trakxr&)
bx=bx+badd
by=by+hadd
@setpos(trakxr&,bx,by)
@readpos(spuro&)
bx=bx+badd
@setpos(spuro&,bx,by)
@readpos(spurslid&)
bx=bx+badd
@setpos(spurslid&,bx,by)
@buttbh(spurslid&,b,h)
h=h+hadd
@setbuttbh(spurslid&,b,h)
@readpos(spuru&)
bx=bx+badd
by=by+hadd
@setpos(spuru&,bx,by)
@buttbh(trakbox5&,b,h)
h=h+hadd
@setbuttbh(trakbox5&,b,h)
@buttbh(trakbox2&,b,h)
b=b+badd
h=h+hadd
@setbuttbh(trakbox2&,b,h)
@readpos(traksall&)
bx=bx+badd
@setpos(traksall&,bx,by)
@readpos(traklall&)
bx=bx+badd
@setpos(traklall&,bx,by)
@readpos(trakload&)
bx=bx+badd
@setpos(trakload&,bx,by)
@readpos(trtfiler&)
bx=bx+badd
@setpos(trtfiler&,bx,by)
@readpos(trtfile&)
bx=bx+badd
@setpos(trtfile&,bx,by)
@readpos(trtfilel&)
bx=bx+badd
@setpos(trtfilel&,bx,by)
@readpos(trkbx1&)
@buttbh(trkbx1&,b,h)
h=h+hadd4
@setbuttbh(trkbx1&,b,h)
by=by+h+2
@setpos(trkbx2&,bx,by)
@setbuttbh(trkbx2&,b,h)
by=by+h+2
@setpos(trkbx3&,bx,by)
@setbuttbh(trkbx3&,b,h)
by=by+h+2
@setpos(trkbx4&,bx,by)
@setbuttbh(trkbx4&,b,h)
h2=h
@buttbh(trakk1&,b,h)
@setbuttbh(trakk1&,b,h2)
@setbuttbh(trakk2&,b,h2)
@setbuttbh(trakk3&,b,h2)
@setbuttbh(trakk4&,b,h2)
trht=8    ! Texthîhe
@buttbh(trkbx1&,mxb,trhb)
trhb=trhb-1                ! Hîhe der Boxen
trhc=INT((trhb-trht)/2)    ! Hîhe der curves
@readpos(trakedbx&)
trhs=by
trhs=trhs-28               ! add zu y-box startlocation
@buttbh(trakbox2&,dig,v)   ! Breite des Boxenfeldes gesamt
dig=dig-mxb-1
dix=mxb-16             ! Abstand Boxen zum linken x-Rand
IF smpedda=TRUE THEN
@rsc_back(nr)
ENDIF
nr=trakker&
rscx&(nr)=xneu3
rscy&(nr)=yneu3-18
rscw&(nr)=bneu3+6
rsch&(nr)=hneu3+6+16
@setpos(trakbox&,xneu3+3,yneu3+3-18)
@timeinit
@slidelen(trakslid&,trakxbut&,v,tscmax)
tscstep=tscmax/tmax
tscplus=tscstep/14
IF notopen=FALSE THEN
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
ENDIF
@wischwasch
@calc_trakboxes
IF notopen=FALSE THEN
tcached=FALSE
@rsc_draw(nr,7)
@timeinit2
IF toffs3>0 THEN
trakkz2=toffs2/toffs3*tscstep
ELSE
trakkz2=0
ENDIF
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
ENDIF
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
ENDIF
RETURN
'
> PROCEDURE shortcuts
IF nr=smpedit& AND altkey=TRUE AND ascii|=ASC("V") THEN
vtedart=tedart
@viewset
tedart=vtedart
@hztext
ENDIF
RETURN
'
> PROCEDURE formatsmp
sc$=""
s=LEN(a$)
REPEAT
IF s>3 THEN
sc$="."+RIGHT$(a$,3)+sc$
a$=LEFT$(a$,s-3)
s=s-3
ENDIF
UNTIL s<4
IF s>0 THEN
sc$=a$+sc$
ENDIF
a$=sc$
RETURN
'
> PROCEDURE initplugins
LOCAL d$,d,dta,da,n$,i,a,dn,nam$,nam,p,b,c,found,n,h,f$,f2$,f3$,f4$,n2$,k,m$
@plugfinder
d$=s$+"*."+plug$+CHR$(0)
d=VARPTR(d$)
dta=GEMDOS(47)   ! fgetdta
da=GEMDOS(78,L:d,0)
IF da=0 THEN
n$=""
i=0
REPEAT
a=PEEK(dta+30+i)
INC i
n$=n$+CHR$(a)
UNTIL a=0
found=FALSE
l=mdat2%
n2$=s$+n$
n=VARPTR(n2$)
h=GEMDOS(61,L:n,0)
IF h>=0 THEN
h=GEMDOS(63,h,L:512,L:mdat2%)
FOR k=0 TO 511
f$=CHR$(PEEK(mdat2%+k))
IF f$="P" THEN
f2$=f$+CHR$(PEEK(mdat2%+k+1))
IF f2$="PL" THEN
f3$=f2$+CHR$(PEEK(mdat2%+k+2))
IF f3$="PLU" THEN
f4$=f3$+CHR$(PEEK(mdat2%+k+3))+CHR$(PEEK(mdat2%+k+4))+CHR$(PEEK(mdat2%+k+5))
ENDIF
ENDIF
ENDIF
EXIT IF f4$="PLUGIN"
NEXT k
m$=""
IF f4$="PLUGIN" THEN
k2=k+7
REPEAT
a=PEEK(mdat2%+k2)
m$=m$+CHR$(a)
INC k2
UNTIL a=0
ENDIF
FOR j=1 TO maxplug
IF m$=plugnam$(j) AND m$<>"" THEN
found=TRUE
ENDIF
NEXT j
ENDIF
~GEMDOS(62,h)
IF found=FALSE THEN
n$=s$+n$
a=EXEC(0,n$,CHR$(0),CHR$(0))
@plugfinder
ENDIF
REPEAT
dn=GEMDOS(79)
IF dn=0 THEN
n$=""
i=0
REPEAT
a=PEEK(dta+30+i)
INC i
n$=n$+CHR$(a)
UNTIL a=0
found=FALSE
'
l=mdat2%
n2$=s$+n$
n=VARPTR(n2$)
h=GEMDOS(61,L:n,0)
IF h>=0 THEN
h=GEMDOS(63,h,L:512,L:mdat2%)
f$=""
f2$=""
f3$=""
f4$=""
FOR k=0 TO 511
f$=CHR$(PEEK(mdat2%+k))
IF f$="P" THEN
f2$=f$+CHR$(PEEK(mdat2%+k+1))
IF f2$="PL" THEN
f3$=f2$+CHR$(PEEK(mdat2%+k+2))
IF f3$="PLU" THEN
f4$=f3$+CHR$(PEEK(mdat2%+k+3))+CHR$(PEEK(mdat2%+k+4))+CHR$(PEEK(mdat2%+k+5))
ENDIF
ENDIF
ENDIF
EXIT IF f4$="PLUGIN"
NEXT k
m$=""
IF f4$="PLUGIN" THEN
k2=k+7
REPEAT
a=PEEK(mdat2%+k2)
m$=m$+CHR$(a)
INC k2
UNTIL a=0
ENDIF
FOR j=1 TO maxplug
IF m$=plugnam$(j) AND m$<>"" THEN
found=TRUE
ENDIF
NEXT j
ENDIF
~GEMDOS(62,h)
IF found=FALSE THEN
n$=s$+n$
~EXEC(0,n$,CHR$(0),CHR$(0))
@plugfinder
ENDIF
ENDIF
UNTIL dn<>0
ENDIF
FOR i=1 TO maxplug
plugnam$(i)=""
NEXT i
pcount=XBIOS(500,250)
IF pcount>0 THEN
FOR i=1 TO maxplug
p=XBIOS(500,253,i)
IF p<>-1 THEN
nam=LPEEK(p+10)
nam$=""
REPEAT
b=PEEK(nam)
nam$=nam$+CHR$(b)
INC nam
UNTIL b=0
plugnam$(i)=nam$
plugpara(i)=LPEEK(p+18)
plugparnr(i)=DPEEK(p)
ENDIF
NEXT i
plugcmax=XBIOS(500,256)
plugcnow=XBIOS(500,258)
ENDIF
FOR i=1 TO maxplug
IF plugnam$(i)<>"" THEN
IF i<10 THEN
@droptxt(ddplug1&-1+i,LEFT$("  "+LEFT$(plugnam$(i),LEN(plugnam$(i))-1)+SPACE$(18),18)+"F"+CHR$(48+i))
ELSE
@droptxt(ddplug1&-1+i,LEFT$("  "+LEFT$(plugnam$(i),LEN(plugnam$(i))-1)+SPACE$(17),17)+"F10")
ENDIF
ELSE
@rsc_state(dropdown&,ddplug1&-1+i,3,TRUE)
ENDIF
NEXT i
'
IF EXIST(lfw$+plgconf$)=TRUE THEN
OPEN "I",#1,lfw$+plgconf$
INPUT #1,plgv$              !  "STARTRACK-PLUGCONFIG V1.0"  Versionskontrolle
IF plgv$="STARTRACK-PLUGCONFIG V1.0" THEN          ! Versionskontrolle
INPUT #1,vplgsel
IF vplgsel>0 THEN
FOR i=1 TO vplgsel
INPUT #1,vplgsel$(i)
NEXT i
ENDIF
INPUT #1,plgr
IF plgr>0 THEN
FOR i=1 TO plgr
INPUT #1,plgrlist(i)
NEXT i
ENDIF
INPUT #1,plgp
IF plgp>0 THEN
FOR i=1 TO plgp
INPUT #1,plgplist(i)
NEXT i
ENDIF
ENDIF
CLOSE #1
@plugcfgctrl
@plugcfgset
ENDIF
RETURN
'
> PROCEDURE plugfinder
FOR i=1 TO maxplug
plugnam$(i)=""
NEXT i
pcount=XBIOS(500,250)
IF pcount>0 THEN
FOR i=1 TO maxplug
p=XBIOS(500,253,i)
IF p<>-1 THEN
nam=LPEEK(p+10)
nam$=""
REPEAT
b=PEEK(nam)
nam$=nam$+CHR$(b)
INC nam
UNTIL b=0
plugnam$(i)=nam$
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE plugin(p)
@plugwindow(p)
RETURN
'
> PROCEDURE plugwindow(p)
LOCAL a,b
plugwind=p
IF plugpara(p)<>-1 THEN
IF BTST(winh,plugin&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=plugin&
'
s=plugpara(p)+plugparnr(p)*8
IF plugparnr(p)>0 THEN
FOR j=1 TO plugparnr(p)
plugcmax(j)=LPEEK(plugpara(p)+j*8-8)
plugcset(j)=LPEEK(plugpara(p)+j*8-4)
plugctxt$(j)=""
REPEAT
t=PEEK(s)
plugctxt$(j)=plugctxt$(j)+CHR$(t)
INC s
UNTIL t=0
plugcart$(j)="("
REPEAT
t=PEEK(s)
plugcart$(j)=plugcart$(j)+CHR$(t)
INC s
UNTIL t=0
plugcart$(j)=LEFT$(plugcart$(j),LEN(plugcart$(j))-1)+")"+CHR$(0)
NEXT j
ENDIF
plugcr$=""
REPEAT
t=PEEK(s)
plugcr$=plugcr$+CHR$(t)
INC s
UNTIL t=0
@textfeld2(nr,plugct1&,"COPYRIGHT BY"+CHR$(0),1)
a=LEN(plugcr$)
IF a>24 THEN
plugcr1$=LEFT$(plugcr$,24)+CHR$(0)
plugcr2$=CHR$(0)
b=RINSTR(plugcr1$," ")
IF b<>0 THEN
plugcr1$=LEFT$(plugcr1$,b-1)+CHR$(0)
plugcr2$=RIGHT$(plugcr$,a-b)
ENDIF
@textfeld2(nr,plugct2&,plugcr1$,1)
@textfeld2(nr,plugct3&,plugcr2$,1)
ELSE
@textfeld2(nr,plugct2&,plugcr$,1)
@textfeld2(nr,plugct3&,CHR$(0),1)
ENDIF
'
@hidetree2(plugct1&,FALSE)
@hidetree2(plugct2&,FALSE)
@hidetree2(plugct3&,FALSE)
@textfeld2(nr,plgtitel&,plugnam$(p),1)
@hidetree2(plglev1&,TRUE)
@hidetree2(plgbox1&,TRUE)
@hidetree2(levtxt1&,TRUE)
@hidetree2(levart1&,TRUE)
@hidetree2(levcnt1&,TRUE)
@hidetree2(plglev2&,TRUE)
@hidetree2(plgbox2&,TRUE)
@hidetree2(levtxt2&,TRUE)
@hidetree2(levart2&,TRUE)
@hidetree2(levcnt2&,TRUE)
@hidetree2(plglev3&,TRUE)
@hidetree2(plgbox3&,TRUE)
@hidetree2(levtxt3&,TRUE)
@hidetree2(levart3&,TRUE)
@hidetree2(levcnt3&,TRUE)
@hidetree2(plglev4&,TRUE)
@hidetree2(plgbox4&,TRUE)
@hidetree2(levtxt4&,TRUE)
@hidetree2(levart4&,TRUE)
@hidetree2(levcnt4&,TRUE)
@hidetree2(plglev5&,TRUE)
@hidetree2(plgbox5&,TRUE)
@hidetree2(levtxt5&,TRUE)
@hidetree2(levart5&,TRUE)
@hidetree2(levcnt5&,TRUE)
@buttbh(panbox&,b,h)
b=160
DPOKE (zu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
DPOKE (zu%+24*plgtitel&+16),20                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*panexit&+16),86                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*plugct1&+16),4
DPOKE (zu%+24*plugct2&+16),4
DPOKE (zu%+24*plugct3&+16),4
IF plugparnr(p)>0 THEN
@hidetree2(plglev1&,FALSE)
@hidetree2(plgbox1&,FALSE)
@hidetree2(levtxt1&,FALSE)
@hidetree2(levart1&,FALSE)
@hidetree2(levcnt1&,FALSE)
'
a$=plugcart$(1)+CHR$(0)
@textfeld2(nr,levart1&,a$,1)
a$=plugctxt$(1)+CHR$(0)
@textfeld2(nr,levtxt1&,a$,1)
@buttbh(panbox&,b,h)
b=160
DPOKE (zu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
py=INT(105/plugcmax(1)*plugcset(1))
DPOKE (zu%+24*plgbox1&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@plugcalc(1)
a$=STR$(a)+CHR$(0)
@textfeld2(nr,levcnt1&,a$,1)
DPOKE (zu%+24*plgtitel&+16),20                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*panexit&+16),86                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*plugct1&+16),4
DPOKE (zu%+24*plugct2&+16),4
DPOKE (zu%+24*plugct3&+16),4
ENDIF
IF plugparnr(p)>1 THEN
@hidetree2(plglev2&,FALSE)
@hidetree2(plgbox2&,FALSE)
@hidetree2(levtxt2&,FALSE)
@hidetree2(levart2&,FALSE)
@hidetree2(levcnt2&,FALSE)
a$=plugcart$(2)+CHR$(0)
@textfeld2(nr,levart2&,a$,1)
a$=plugctxt$(2)+CHR$(0)
@textfeld2(nr,levtxt2&,a$,1)
b=160
DPOKE (zu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
py=INT(105/plugcmax(2)*plugcset(2))
DPOKE (zu%+24*plgbox2&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@plugcalc(2)
a$=STR$(a)+CHR$(0)
@textfeld2(nr,levcnt2&,a$,1)
DPOKE (zu%+24*plgtitel&+16),20                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*panexit&+16),86                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*plugct1&+16),4
DPOKE (zu%+24*plugct2&+16),4
DPOKE (zu%+24*plugct3&+16),4
ENDIF
IF plugparnr(p)>2 THEN
@hidetree2(plglev3&,FALSE)
@hidetree2(plgbox3&,FALSE)
@hidetree2(levtxt3&,FALSE)
@hidetree2(levart3&,FALSE)
@hidetree2(levcnt3&,FALSE)
a$=plugcart$(3)+CHR$(0)
@textfeld2(nr,levart3&,a$,1)
a$=plugctxt$(3)+CHR$(0)
@textfeld2(nr,levtxt3&,a$,1)
b=224
DPOKE (zu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
py=INT(105/plugcmax(3)*plugcset(3))
DPOKE (zu%+24*plgbox3&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@plugcalc(3)
a$=STR$(a)+CHR$(0)
@textfeld2(nr,levcnt3&,a$,1)
DPOKE (zu%+24*plgtitel&+16),52                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*panexit&+16),150                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*plugct1&+16),36
DPOKE (zu%+24*plugct2&+16),36
DPOKE (zu%+24*plugct3&+16),36
ENDIF
IF plugparnr(p)>3 THEN
@hidetree2(plglev4&,FALSE)
@hidetree2(plgbox4&,FALSE)
@hidetree2(levtxt4&,FALSE)
@hidetree2(levart4&,FALSE)
@hidetree2(levcnt4&,FALSE)
a$=plugcart$(4)+CHR$(0)
@textfeld2(nr,levart4&,a$,1)
a$=plugctxt$(4)+CHR$(0)
@textfeld2(nr,levtxt4&,a$,1)
b=288
DPOKE (zu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
py=INT(105/plugcmax(4)*plugcset(4))
DPOKE (zu%+24*plgbox4&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@plugcalc(4)
a$=STR$(a)+CHR$(0)
@textfeld2(nr,levcnt4&,a$,1)
DPOKE (zu%+24*plgtitel&+16),84                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*panexit&+16),214                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*plugct1&+16),68
DPOKE (zu%+24*plugct2&+16),68
DPOKE (zu%+24*plugct3&+16),68
ENDIF
IF plugparnr(p)>4 THEN
@hidetree2(plglev5&,FALSE)
@hidetree2(plgbox5&,FALSE)
@hidetree2(levtxt5&,FALSE)
@hidetree2(levart5&,FALSE)
@hidetree2(levcnt5&,FALSE)
a$=plugcart$(5)+CHR$(0)
@textfeld2(nr,levart5&,a$,1)
a$=plugctxt$(5)+CHR$(0)
@textfeld2(nr,levtxt5&,a$,1)
b=352
DPOKE (zu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
py=INT(105/plugcmax(5)*plugcset(5))
DPOKE (zu%+24*plgbox5&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@plugcalc(5)
a$=STR$(a)+CHR$(0)
@textfeld2(nr,levcnt5&,a$,1)
DPOKE (zu%+24*plgtitel&+16),116                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*panexit&+16),278                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (zu%+24*plugct1&+16),100
DPOKE (zu%+24*plugct2&+16),100
DPOKE (zu%+24*plugct3&+16),100
ENDIF
'
IF plugparnr(p)=1 THEN
@buttbh(plglev1&,b2,h2)
panbox=68
DPOKE (zu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=68-b2/2+13
DPOKE (zu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=68-b2/2+13
DPOKE (zu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=68-b2/2+12
DPOKE (zu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF plugparnr(p)=2 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (zu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (zu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (zu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (zu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (zu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (zu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (zu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (zu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF plugparnr(p)=3 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (zu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (zu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (zu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (zu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (zu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (zu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (zu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (zu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev3&,b2,h2)
panbox=164
DPOKE (zu%+24*plglev3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt3&,b2,h2)
panbox=164-b2/2+13
DPOKE (zu%+24*levtxt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart3&,b2,h2)
panbox=164-b2/2+13
DPOKE (zu%+24*levart3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt3&,b2,h2)
panbox=164-b2/2+12
DPOKE (zu%+24*levcnt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF plugparnr(p)=4 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (zu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (zu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (zu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (zu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (zu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (zu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (zu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (zu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev3&,b2,h2)
panbox=164
DPOKE (zu%+24*plglev3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt3&,b2,h2)
panbox=164-b2/2+13
DPOKE (zu%+24*levtxt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart3&,b2,h2)
panbox=164-b2/2+13
DPOKE (zu%+24*levart3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt3&,b2,h2)
panbox=164-b2/2+12
DPOKE (zu%+24*levcnt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev4&,b2,h2)
panbox=228
DPOKE (zu%+24*plglev4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt4&,b2,h2)
panbox=228-b2/2+13
DPOKE (zu%+24*levtxt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart4&,b2,h2)
panbox=228-b2/2+13
DPOKE (zu%+24*levart4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt4&,b2,h2)
panbox=228-b2/2+12
DPOKE (zu%+24*levcnt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF plugparnr(p)=5 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (zu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (zu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (zu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (zu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (zu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (zu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (zu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (zu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev3&,b2,h2)
panbox=164
DPOKE (zu%+24*plglev3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt3&,b2,h2)
panbox=164-b2/2+13
DPOKE (zu%+24*levtxt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart3&,b2,h2)
panbox=164-b2/2+13
DPOKE (zu%+24*levart3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt3&,b2,h2)
panbox=164-b2/2+12
DPOKE (zu%+24*levcnt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev4&,b2,h2)
panbox=228
DPOKE (zu%+24*plglev4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt4&,b2,h2)
panbox=228-b2/2+13
DPOKE (zu%+24*levtxt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart4&,b2,h2)
panbox=228-b2/2+13
DPOKE (zu%+24*levart4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt4&,b2,h2)
panbox=228-b2/2+12
DPOKE (zu%+24*levcnt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev5&,b2,h2)
panbox=292
DPOKE (zu%+24*plglev5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt5&,b2,h2)
panbox=292-b2/2+13
DPOKE (zu%+24*levtxt5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart5&,b2,h2)
panbox=292-b2/2+13
DPOKE (zu%+24*levart5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt5&,b2,h2)
panbox=292-b2/2+12
DPOKE (zu%+24*levcnt5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=plugin&
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
ENDIF
RETURN
'
> FUNCTION plugcalc(a)
LOCAL n,max,a$
n=plugcset(a)
max=plugcmax(a)
a$=plugcart$(a)
'
IF a$="(MS)"+CHR$(0) THEN
@makehz
b=INT(n/hz*1000)
ENDIF
IF a$="(DB)"+CHR$(0) THEN
IF n>0 THEN
b=INT(aufloes-(20*LOG10(n*2)*100))/100
ELSE
b=0
ENDIF
ENDIF
RETURN b
ENDFUNC
'
> PROCEDURE do_plugin
LOCAL ps
~@xrsrc_gaddr(0,plugin&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
'
IF obj=panhelp& THEN
@helptxt("PLUGINS")
ENDIF
'
IF (obj=plgbox1& OR obj=plgbox2& OR obj=plgbox3& OR obj=plgbox4& OR obj=plgbox5&) OR plgmake=TRUE
SELECT obj
CASE plgbox1&
boxsel=1
cntsel=levcnt1&
levsel=plglev1&
CASE plgbox2&
boxsel=2
cntsel=levcnt2&
levsel=plglev2&
CASE plgbox3&
boxsel=3
cntsel=levcnt3&
levsel=plglev3&
CASE plgbox4&
boxsel=4
cntsel=levcnt4&
levsel=plglev4&
CASE plgbox5&
boxsel=5
cntsel=levcnt5&
levsel=plglev5&
ENDSELECT
~@xrsrc_gaddr(1,obj,zu2%)
REPEAT
~GRAF_MKSTATE(x,y,k,pshift)
IF k=1 AND plgmake=FALSE THEN
plgmake=TRUE
DEFMOUSE mf
opy=y
ENDIF
IF opy<>y THEN
opy=y
py=y-yd-40
IF py<=105 AND py>=0 THEN
lev=INT(plugcmax(boxsel)/105*py)
plugcset(boxsel)=lev
'
ps=@plugcalc(boxsel)
a$=STR$(ps)+CHR$(0)
@textfeld(cntsel,a$,1)
'
DPOKE (zu%+24*obj+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,levsel,9,0,0,xwidth,ywidth)     ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
LPOKE plugpara(plugwind)+boxsel*8-4,lev
ENDIF
ENDIF
UNTIL k=0
plgmake=FALSE
DEFMOUSE 0
obj=0
ENDIF
'
IF obj=panexit& OR obj=9999 THEN
winh=BCLR(winh,plugin&)
@setbutton(panexit&,0)
@restaura2b
obj=0
@sethertz
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
RETURN
'
> PROCEDURE plugconfig
LOCAL l,a$,i,wahl,j
IF pcount>0 THEN
vornr=nr
nr=plgconfg&
FOR i=1 TO pcount
@hidetree2(plgcfg1&-1+i,FALSE)
NEXT i
plgsel=0
FOR i=1 TO maxplug
IF plugnam$(i)<>"" THEN
INC plgsel
@textfeld2(nr,plgcfg1&+plgsel-1,plugnam$(i),1)
plgsel$(plgsel)=plugnam$(i)
ENDIF
NEXT i
@textfeld2(nr,plgrec1&,CHR$(0),1)
@textfeld2(nr,plgrec2&,CHR$(0),1)
@textfeld2(nr,plgrec3&,CHR$(0),1)
@textfeld2(nr,plgrec4&,CHR$(0),1)
@textfeld2(nr,plgrec5&,CHR$(0),1)
@textfeld2(nr,plgplay1&,CHR$(0),1)
@textfeld2(nr,plgplay2&,CHR$(0),1)
@textfeld2(nr,plgplay3&,CHR$(0),1)
@textfeld2(nr,plgplay4&,CHR$(0),1)
@textfeld2(nr,plgplay5&,CHR$(0),1)
'
IF plgr>0 THEN
FOR i=1 TO plgr
IF plgrlist(i)>0 AND plgrlist(i)<=plgsel THEN
a$=plgsel$(plgrlist(i))
SELECT i
CASE 1
@textfeld2(nr,plgrec1&,a$,1)
CASE 2
@textfeld2(nr,plgrec2&,a$,1)
CASE 3
@textfeld2(nr,plgrec3&,a$,1)
CASE 4
@textfeld2(nr,plgrec4&,a$,1)
CASE 5
@textfeld2(nr,plgrec5&,a$,1)
ENDSELECT
ENDIF
NEXT i
ENDIF
IF plgp>0 THEN
FOR i=1 TO plgp
IF plgplist(i)>0 AND plgplist(i)<=plgsel THEN
a$=plgsel$(plgplist(i))
SELECT i
CASE 1
@textfeld2(nr,plgplay1&,a$,1)
CASE 2
@textfeld2(nr,plgplay2&,a$,1)
CASE 3
@textfeld2(nr,plgplay3&,a$,1)
CASE 4
@textfeld2(nr,plgplay4&,a$,1)
CASE 5
@textfeld2(nr,plgplay5&,a$,1)
ENDSELECT
ENDIF
NEXT i
ENDIF
'
@rsc_draw(nr,0)
@setbutton(plgplay&,0)
@setbutton(plgrec&,1)
wahl=0
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(1,obj,zu%)
IF obj>=plgcfg1& AND obj<=plgcfg10& THEN
a$=plgsel$(obj-plgcfg1&+1)
IF wahl=0 THEN
IF plgr<5 THEN
INC plgr
plgrlist(plgr)=obj-plgcfg1&+1
SELECT plgr
CASE 1
@textfeld(plgrec1&,a$,1)
CASE 2
@textfeld(plgrec2&,a$,1)
CASE 3
@textfeld(plgrec3&,a$,1)
CASE 4
@textfeld(plgrec4&,a$,1)
CASE 5
@textfeld(plgrec5&,a$,1)
ENDSELECT
ENDIF
ELSE
IF plgp<5 THEN
INC plgp
plgplist(plgp)=obj-plgcfg1&+1
SELECT plgp
CASE 1
@textfeld(plgplay1&,a$,1)
CASE 2
@textfeld(plgplay2&,a$,1)
CASE 3
@textfeld(plgplay3&,a$,1)
CASE 4
@textfeld(plgplay4&,a$,1)
CASE 5
@textfeld(plgplay5&,a$,1)
ENDSELECT
ENDIF
ENDIF
ENDIF
IF obj=plgrec& THEN
wahl=0
@setbutton(plgplay&,0)
ENDIF
IF obj=plgplay& THEN
wahl=1
@setbutton(plgrec&,0)
ENDIF
IF obj=pcfgld& THEN
@plugcfgload
ENDIF
IF obj=pcfgsve& THEN
@plugcfgsave
ENDIF
IF obj=pcfgclr& THEN
IF wahl=0 THEN
IF plgr>0 THEN
FOR i=1 TO plgr
plgrlist(i)=0
NEXT i
@textfeld(plgrec1&,CHR$(0),1)
@textfeld(plgrec2&,CHR$(0),1)
@textfeld(plgrec3&,CHR$(0),1)
@textfeld(plgrec4&,CHR$(0),1)
@textfeld(plgrec5&,CHR$(0),1)
ENDIF
plgr=0
ELSE
IF plgp>0 THEN
FOR i=1 TO plgp
plgplist(i)=0
NEXT i
@textfeld(plgplay1&,CHR$(0),1)
@textfeld(plgplay2&,CHR$(0),1)
@textfeld(plgplay3&,CHR$(0),1)
@textfeld(plgplay4&,CHR$(0),1)
@textfeld(plgplay5&,CHR$(0),1)
ENDIF
plgp=0
ENDIF
ENDIF
IF obj=pcfghelp& THEN
@helptxt("PLUGIN CONFIG")
ENDIF
IF obj<>0 AND obj<>pcfghelp& AND obj<>plgplay& AND obj<>plgrec& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=pcfgexit&
@plugcfgset
@setbutton(obj,0)
@restaura2
obj=0
ELSE
@editselect
ENDIF
RETURN
'
> PROCEDURE plugcfgsave
LOCAL i,g2
@fileselect(lfw$+"*."+plgcext$,plgconf$,"PLUGCFG-SAVE:")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+"."+plgcext$
ELSE
IF RIGHT$(fil$,3)<>plgcext$ THEN
fil$=LEFT$(fil$,g2)+plgcext$
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=sector THEN
OPEN "O",#1,fil$
PRINT #1,"STARTRACK-PLUGCONFIG V1.0"               !versionskontrolle
PRINT #1,plgsel
IF plgsel>0 THEN
FOR i=1 TO plgsel
PRINT #1,plgsel$(i)
NEXT i
ENDIF
PRINT #1,plgr
IF plgr>0 THEN
FOR i=1 TO plgr
PRINT #1,plgrlist(i)
NEXT i
ENDIF
PRINT #1,plgp
IF plgp>0 THEN
FOR i=1 TO plgp
PRINT #1,plgplist(i)
NEXT i
ENDIF
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
RETURN
'
> PROCEDURE plugcfgload
LOCAL i,g2
@fileselect(lfw$+"*."+plgcext$,"","PLUGCFG-LOAD:")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+"."+plgcext$
ELSE
IF RIGHT$(fil$,3)<>plgcext$ THEN
fil$=LEFT$(fil$,g2)+plgcext$
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
IF EXIST(fil$)=TRUE THEN
FOR i=1 TO maxplug
plgrlist(i)=0
plgplist(i)=0
plgsel$(i)=""
NEXT i
OPEN "I",#1,fil$
INPUT #1,plgv$              !  "STARTRACK-PLUGCONFIG V1.0"  Versionskontrolle
IF plgv$="STARTRACK-PLUGCONFIG V1.0" THEN          ! Versionskontrolle
INPUT #1,vplgsel
IF vplgsel>0 THEN
FOR i=1 TO vplgsel
INPUT #1,vplgsel$(i)
NEXT i
ENDIF
INPUT #1,plgr
IF plgr>0 THEN
FOR i=1 TO plgr
INPUT #1,plgrlist(i)
NEXT i
ENDIF
INPUT #1,plgp
IF plgp>0 THEN
FOR i=1 TO plgp
INPUT #1,plgplist(i)
NEXT i
ENDIF
ENDIF
CLOSE #1
@plugcfgctrl
@textfeld(plgrec1&,CHR$(0),1)
@textfeld(plgrec2&,CHR$(0),1)
@textfeld(plgrec3&,CHR$(0),1)
@textfeld(plgrec4&,CHR$(0),1)
@textfeld(plgrec5&,CHR$(0),1)
@textfeld(plgplay1&,CHR$(0),1)
@textfeld(plgplay2&,CHR$(0),1)
@textfeld(plgplay3&,CHR$(0),1)
@textfeld(plgplay4&,CHR$(0),1)
@textfeld(plgplay5&,CHR$(0),1)
IF plgr>0 THEN
FOR i=1 TO plgr
IF plgrlist(i)>0 AND plgrlist(i)<=plgsel THEN
a$=plgsel$(plgrlist(i))
SELECT i
CASE 1
@textfeld(plgrec1&,a$,1)
CASE 2
@textfeld(plgrec2&,a$,1)
CASE 3
@textfeld(plgrec3&,a$,1)
CASE 4
@textfeld(plgrec4&,a$,1)
CASE 5
@textfeld(plgrec5&,a$,1)
ENDSELECT
ENDIF
NEXT i
ENDIF
IF plgp>0 THEN
FOR i=1 TO plgp
IF plgplist(i)>0 AND plgplist(i)<=plgsel THEN
a$=plgsel$(plgplist(i))
SELECT i
CASE 1
@textfeld(plgplay1&,a$,1)
CASE 2
@textfeld(plgplay2&,a$,1)
CASE 3
@textfeld(plgplay3&,a$,1)
CASE 4
@textfeld(plgplay4&,a$,1)
CASE 5
@textfeld(plgplay5&,a$,1)
ENDSELECT
ENDIF
NEXT i
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE plugcfgctrl
LOCAL i,j,k,l
IF vplgsel>0 THEN
plgsel=0
FOR i=1 TO maxplug
IF plugnam$(i)<>"" THEN
INC plgsel
plgsel$(plgsel)=plugnam$(i)
ENDIF
NEXT i
IF plgsel>0 THEN
FOR i=1 TO vplgsel
FOR j=1 TO plgsel
EXIT IF vplgsel$(i)=plgsel$(j) AND plgsel$(j)<>""
NEXT j
IF vplgsel$(i)=plgsel$(j) AND plgsel$(j)<>"" THEN
IF plgr>0 THEN
FOR k=1 TO plgr
IF plgrlist(k)=i THEN
plgrlist(k)=j
ENDIF
NEXT k
ENDIF
IF plgp>0 THEN
FOR k=1 TO plgp
IF plgplist(k)=i THEN
plgplist(k)=j
ENDIF
NEXT k
ENDIF
ELSE
IF plgr>0 THEN
FOR k=1 TO plgr
IF plgrlist(k)=i AND plgr>0 THEN
FOR l=k TO plgr
IF l<plgr THEN
plgrlist(l)=plgrlist(l+1)
ELSE
plgrlist(l)=0
ENDIF
NEXT l
DEC plgr
ENDIF
NEXT k
ENDIF
IF plgp>0 THEN
FOR k=1 TO plgp
IF plgplist(k)=i AND plgp>0 THEN
FOR l=k TO plgp
IF l<plgp THEN
plgplist(l)=plgplist(l+1)
ELSE
plgplist(l)=0
ENDIF
NEXT l
DEC plgp
ENDIF
NEXT k
ENDIF
ENDIF
NEXT i
ENDIF
ELSE
plgsel=0
FOR i=1 TO maxplug
plgrlist(i)=0
plgplist(i)=0
plgsel$(i)=""
NEXT i
ENDIF
RETURN
'
> PROCEDURE plugcfgset
l=mdat2%
IF plgr>0 THEN
FOR i=1 TO plgr
FOR j=1 TO maxplug
EXIT IF plgsel$(plgrlist(i))=plugnam$(j) AND plugnam$(j)<>""
NEXT j
IF j<=maxplug THEN
IF plgsel$(plgrlist(i))=plugnam$(j) AND plugnam$(j)<>"" THEN
DPOKE l,j
l=l+2
ENDIF
ENDIF
NEXT i
ENDIF
DPOKE l,0
c=XBIOS(500,255,L:mdat2%)
l=mdat2%
IF plgp>0 THEN
FOR i=1 TO plgp
FOR j=1 TO maxplug
EXIT IF plgsel$(plgplist(i))=plugnam$(j) AND plugnam$(j)<>""
NEXT j
IF j<=maxplug THEN
IF plgsel$(plgplist(i))=plugnam$(j) AND plugnam$(j)<>"" THEN
DPOKE l,j
l=l+2
ENDIF
ENDIF
NEXT i
ENDIF
DPOKE l,0
c=XBIOS(500,254,L:mdat2%)
RETURN
'
> PROCEDURE drop2
.| Glob. Var.: nr#,rsc_adr%,rsc_menu&,nob#,ddinfo&,smpedit&,obj#,infoicon&
.|     ddblock&,blocfunc&,ddsmp16&,edsmp16&,ddpeak&,peaksw2&,ddarr&,arrange&
.|     ddtrakk&,trak&,ddloop&,loopart&,ddload&,smpload&,ddsave&,smpsave&
.|     ddfader&,edfade&,ddsetup&,setuper&,ddmon&,monitor&,dddsp&,swdsp&
.|     ddauto&,smpauto2&,ddmanu&,smpstrt2&,ddplay&,smpplay&,ddexit&,g#
.|     ddmidi&,edmidi&,obj&
.| Felder    : rsc_handle%(),rsc_adr%()
.| Ruft auf  : info,blkfunc,main,peak,arranger,trakker,loopwahl,smpload
.|     smpsave,fade,setupdat,monitor,dspwahl,smpauto,smpstart,smpplay
.|     goodbye,midi
.| Aufruf in : rsc_do-1,drop-1,
IF rsc_handle%(nr)>0 AND rsc_handle%(nr)<1000 THEN
rsc_adr%=rsc_adr%(rsc_menu&)
~MENU_TNORMAL(rsc_adr%,MENU(4),1)
'
IF nob=ddhost& THEN
obj=nob
IF dspuse=FALSE THEN
dspuse=TRUE
ELSE
dspuse=FALSE
ENDIF
@rsc_state(rsc_menu&,obj,2,dspuse)
ENDIF
IF nob=ddmix& THEN
obj=nob
IF dspmodemix=FALSE THEN
dspmodemix=TRUE
ELSE
dspmodemix=FALSE
ENDIF
@rsc_state(rsc_menu&,obj,2,dspmodemix)
ENDIF
'
IF nob>=ddplug1& AND nob<=ddplug10& THEN
@plugin(nob-ddplug1&+1)
ENDIF
IF nob=ddinfo& THEN
obj=infoicon&
nr=smpedit&
@editselect
@setbutton(obj,1)
@info
ENDIF
IF nob=ddworkm& THEN
obj=wmodes&
nr=smpedit&
@editselect
@setbutton(obj,1)
@workmode
ENDIF
IF nob=ddblock& THEN
nr=smpedit&
obj=blocfunc&
@editselect
@setbutton(obj,1)
@blkfunc
ENDIF
IF nob=ddplgcfg& THEN
@plugconfig
ENDIF
IF nob=ddsmp16& THEN
obj=edsmp16&
nr=smpedit&
@editselect
@setbutton(obj,1)
@main
ENDIF
IF nob=ddpeak& THEN
obj=peaksw2&
nr=smpedit&
@editselect
@setbutton(obj,1)
@write_int(0)
peakint=FALSE
@peak
ENDIF
IF nob=ddarr& THEN
obj=arrange&
nr=smpedit&
@editselect
@setbutton(obj,1)
@arranger
ENDIF
IF nob=ddtrakk& THEN
obj=trak&
nr=smpedit&
@editselect
@setbutton(obj,1)
@trakker
ENDIF
IF nob=ddloop& THEN
obj=loopart&
nr=smpedit&
@editselect
@setbutton(obj,1)
@loopwahl
ENDIF
IF nob=ddload& THEN
IF nr=arranger& THEN
obj=arrload&
@setbutton(obj,1)
@arrload
ENDIF
IF nr=trakker& THEN
obj=traklall&
@setbutton(obj,1)
@trkloadall
ENDIF
IF nr<>arranger& AND nr<>trakker& THEN
obj=smpload&
neufsel=FALSE
nr=smpedit&
@editselect
@setbutton(obj,1)
@smpload
@editredraw
ENDIF
ENDIF
IF nob=ddbank& THEN
obj=smpdbank&
neufsel=TRUE
@write_int(0)
nr=smpedit&
@editselect
@setbutton(obj,1)
@smpload
@editredraw
ENDIF
IF nob=ddsave& THEN
IF nr=arranger& THEN
obj=arrsave&
@setbutton(obj,1)
@arrsave
ENDIF
IF nr=trakker& THEN
obj=traksall&
@setbutton(obj,1)
@trksaveall
ENDIF
IF nr<>arranger& AND nr<>trakker& THEN
obj=smpsave&
@write_int(0)
nr=smpedit&
@editselect
@setbutton(obj,1)
@smpsave
ENDIF
ENDIF
IF nob=ddfader& THEN
obj=edfade&
nr=smpedit&
@editselect
@setbutton(obj,1)
@fade
ENDIF
IF nob=ddsetup& THEN
obj=setuper&
nr=smpedit&
@editselect
@setbutton(obj,1)
@setupdat
ENDIF
IF nob=ddmon& THEN
'      obj=monitor&
nr=smpedit&
@editselect
'      @setbutton(obj,1)
@write_int(0)
@monitor
peakint=FALSE
ENDIF
IF nob=dddsp& THEN
obj=swdsp&
nr=smpedit&
@editselect
@setbutton(obj,1)
@dspwahl
ENDIF
IF nob=ddauto& THEN
obj=0
IF nr=smpedit& THEN
obj=smpauto2&
@setbutton(obj,1)
@smpauto
ENDIF
IF nr=peak& THEN
obj=smpautop&
@setbutton(obj,1)
@smpauto
peakint=FALSE
ENDIF
IF nr=arranger& THEN
obj=smpauto3&
hrdmrk=hrd
hrd=1
@setbutton(obj,1)
@smpauto
hrd=hrdmrk
ENDIF
IF nr=trakker& THEN
obj=smpauto4&
hrdmrk=hrd
hrd=1
@setbutton(obj,1)
@smpauto
hrd=hrdmrk
ENDIF
ENDIF
IF nob=ddmanu& THEN
IF nr=smpedit& THEN
obj=smpstrt2&
@setbutton(obj,1)
@smpstart
ENDIF
IF nr=peak& THEN
obj=smpstrtp&
@setbutton(obj,1)
@smpstart
peakint=FALSE
ENDIF
IF nr=arranger& THEN
obj=smpstrt3&
hrdmrk=hrd
hrd=1
@setbutton(obj,1)
@smpstart
hrd=hrdmrk
ENDIF
IF nr=trakker& THEN
obj=smpstrt4&
hrdmrk=hrd
hrd=1
@setbutton(obj,1)
@smpstart
hrd=hrdmrk
ENDIF
ENDIF
IF nob=ddplay& THEN
obj=0
IF nr=smpedit& THEN
obj=smpplay&
@setbutton(obj,1)
@smpplay
ENDIF
IF nr=peak& AND hrd=1 THEN
obj=playpeak&
@setbutton(obj,1)
@smpplay
peakint=FALSE
ENDIF
IF nr=arranger& THEN
obj=arrmidi&
@setbutton(obj,1)
@arrmidplay
ENDIF
IF nr=trakker& THEN
obj=trakplay&
hz=thz
@setbutton(obj,1)
@trkplay
ENDIF
ENDIF
IF nob=ddexit& THEN
@alerts(99)
IF g=1 THEN
@goodbye
ENDIF
ENDIF
IF nob=ddmidi& THEN
obj=edmidi&
nr=smpedit&
@editselect
@setbutton(obj,1)
@midi
ENDIF
obj=0
obj&=0
ENDIF
nob=0
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE setup
.| Glob. Var.: noppause#,peakint#,extclock#,ext#,trkz#,mamidi#,trakact#
.|     butdirect#,isave#,vtst#,infbutt#,rett#,cached#,away#,virtual#
.|     virtwfile#,virtld#,makevirt3#,makevirt2#,makevirt#,blockld#,deltime#
.|     spc#,vcs#,vce#,scmax#,zmax#,buttg#,aufloes#,lmax#,lmax2#,lmax3#
.|     lmax4#,anspiel#,sector#,recfifolen#,playfifolen#,sram#,hbuf#,mdat%
.|     mdat2%,tedart#,tim$,btim$,mdatf#,mdatf2#,mdat3%,mdat4%,wback%,gohome#
.|     adr#,mtst#,mallmax#,memmx#,manf#,merkfrei#,meml#,memh#,mlen#,big#
.|     sramda#,g#,dat#,anfload#,cs#,ce#,vmem#,xm#,loopz#,bloopz#,i#,cwerte1#
.|     mbs#,vmbs#,n#,lz#,smplen#,ext2$,ext$,smpnam$,path$,lfw$,retime#,ad#
.|     xmp#,okmark#,merkerr#,merkfreq#,protnr#,lded#,hrd#,merk1#,merk2#
.|     merk3#,merk4#,merkc#,stl#,clk#,sth#,std#,vol#
.| Felder    : ls#(),le#(),lcs#(),lce#(),arrfn$(),arrpath$(),arrstrt#()
.|     arrend#(),arrlen#(),arrmidi#(),midi#(),arrloop#(),arrtri#()
.|     arrsrate#(),trkfn$(),trkpath$(),trktime#(),trkvor#(),trknext#()
.|     trkstrt#(),trkend#(),trklen#(),trkloop#(),trktri#(),trksrate#()
.|     trkch#(),trkpnt#(),dbank$(),dbank2$(),wurlnr#(),cachep1#(),cachep2#()
.|     cachem1#(),cachem2#(),mblocks#(),mblocke#(),mblockp$(),loops#()
.|     loope#(),vloops#(),vloope#(),bloops#(),bloope#(),vbloops#()
.|     vbloope#()
.| Ruft auf  : markhlp,maschinit9,maschruf9,volwrite
.| Aufruf in : smpedit-1,
LOCAL vnr
DEFTEXT 1,0,0,4
notrkmem=FALSE
blue=4       ! FÅllfarbe blau = 4
green=3      ! FÅllfarbe dunkelgrÅn
bred=2+8     ! FÅllfarbe dunkelrot
red=2        ! FÅllfarbe rot
spuren=2
prest=0.95   ! AbschwÑchwert relativ zum bisherigen Wert
pschwell=1   ! Schwellwert zur Erkennung von abfallendem Peakwert
just=FALSE
rettfound=FALSE
ldtrk=FALSE
exerr=FALSE
leaveprog=FALSE
vio=FALSE
adrag=FALSE
tfselm=FALSE
idrag=FALSE
tdrag=FALSE
trdrag=FALSE
memc=0
memtrak=0
memfade=0
nonstm=0
clipart=0
trkcart=0
clk=2
drawnew=FALSE
drawnew2=FALSE
edcart2=FALSE
fmclk=FALSE
tvideo=TRUE
tsolo=FALSE
adat=FALSE
wisch=FALSE
timedraw=FALSE
oldplay=FALSE
sabc=FALSE
trkmemr=FALSE
tncom=FALSE
noppause=FALSE
cupdate=FALSE
peakint=FALSE
extclock=FALSE
tplaystart=-1
tplayend=-1
cdivsms=-1
rchmo=0
wurl=0
spc=0
ext=0
arrcwert=0
edcart=0
aretime=0
trkz=0
mamidi=0
trakact=0
trkcwert=0
butdirect=FALSE
isave=FALSE
vtst=FALSE
infbutt=FALSE
infobinv=FALSE
rett=FALSE
proff=FALSE
cached=FALSE
away=FALSE
virtual=FALSE
virtwfile=FALSE
virtld=FALSE
makevirt3=FALSE
makevirt2=FALSE
makevirt=FALSE
blockld=FALSE
wfil$=""
tbkurz=17 ! Breite des Sliders, Ausnahme fÅr Zoomslider im Tracker-MenÅ
trakkz=0               ! Scrollposition fÅr Tracker
trakkyz=5              ! Zoomstufe fÅr Tracker
trkztop=10             ! Anzahl Scrolleinteilungen fÅr Tracker
tmax=trkztop
vcs=0
vce=0
scmax=50               ! Scroll-Auflîsungsstufen
zmax=30                ! Zoom-Auflîsungsstufen
buttg=16               ! Mindestbreite der Sliderbuttons
db16=96.32             ! dB-Auflîsung bei 16 bit
db24=144.49            ! dB-Auflîsung bei 24 bit
@setpeakblks
IF dig24=FALSE THEN
aufloes=db16           ! dB-Aufloesung der Wandler (16Bit)
mbit=4
ELSE
aufloes=db24           ! dB-Aufloesung der Wandler (16Bit)
mbit=6
ENDIF
lmax=100               ! Feldgrîûe fÅr SCROLL
lmax2=100              ! Feldgrîûe fÅr ARRANGER
lmax3=500              ! Feldgrîûe fÅr TRAKKER-Files und loaded-Samples im Editor
lmax4=100              ! Feldgrîûe fÅr File-Datenbank
trkvmax=100            ! Feldgrîûe fÅr Anzahl virtuelle Spuren
anspiel=10*48000*mbit  ! anzuspielende Sektoren
sector=4096            ! Grîûe der Fifos
recfifolen=sector      ! Grîûe des RECORD-FIFO
playfifolen=sector     ! Grîûe des PLAY-FIFO
sram=&HFE900000        ! Anfang des SRAM
hbuf=65536             ! Grîûe des PLAY/REC Buffers
hbuf2=32768            ! Grîûe des Bitblt & Assembler-Buffers
hbuf3=4192             ! Grîûe der restlichen Assembler-Buffer
IF smalluse=TRUE THEN
tmlen=&H80000        ! 512 KB-Tracker-Cache
ELSE
tmlen=&H200000       ! 2 MB-Tracker-Cache
ENDIF
IF smalluse=TRUE THEN
mrest=&H10000        ! Mindestrest-Speicher fÅr andere Applikationen
ELSE
mrest=&H40000        ! Mindestrest-Speicher fÅr andere Applikationen
ENDIF
lmcurv=xwidth*ywidth*planes&/8
lmfade=248*224*planes&/8
lmtrak=xwidth*ywidth*planes&/8
mrest=mrest+lmcurv+lmfade+lmtrak
mwmin=&H20000          ! Mindest-Samplespeicher
notmem=FALSE
m=@malloc(-1,0)
IF m<(hbuf+hbuf2+hbuf3+tmlen+mrest+mwmin) THEN
windcache=FALSE
mrest=mrest-(lmcurv+lmfade+lmtrak)
memfade=0
memc=0
memtrak=0
ELSE
windcache=TRUE
memfade=@rsc_get(0,0,248,224)
memc=@rsc_get(0,0,xwidth,ywidth)
memtrak=@rsc_get(0,0,xwidth,ywidth)
firstfade=1
firstnc=1
firsttrak=1
ENDIF
IF m>(hbuf+hbuf2+hbuf3+tmlen+mrest+mwmin) THEN
tmem=@malloc(tmlen,0)         ! Buffer fÅr Tracker-Caches
mdat%=@malloc(hbuf,0)     ! Buffer fÅr HARD-REC/PLAY-Buffer und anderes
mdat2%=@malloc(hbuf2+hbuf3,0)   ! Buffer fÅr Assembler-Code
tim$=TIME$
btim$=tim$
mdatf=mdat%
mdatf2=mdat2%
IF mdat%<=0 OR mdat2%<=0 OR tmem<=0 THEN
away=TRUE
ELSE
mdat%=INT(mdat%/2)*2+2
mdat2%=INT(mdat2%/2)*2+2
mdat3%=mdat2%+hbuf2
mdat4%=mdat2%+hbuf2+(hbuf3/2)
mdatb4%=mdat4%+hbuf2+(hbuf3/4*3)
IF notmem=FALSE THEN
@maschruf9(tmem,tmem+tmlen)
ENDIF
wback%=INT((mdat2%+(hbuf2-32))/mbit)*mbit
mtst=@malloc(-1,0)
IF mallmax=FALSE AND mtst>=(memmx+mrest) AND memmx<>0 THEN
mtst=memmx
ELSE
mtst=mtst-mrest
ENDIF
IF mtst>=mwmin THEN
mtst=INT(mtst/24)*24
manf=@malloc(mtst,0)
merkfrei=manf
IF manf>0 THEN
manf=INT(manf/24)*24+24
meml=manf
memh=meml+mtst-24
mlen=memh-meml
big=1
ELSE
away=TRUE
ENDIF
ELSE
away=TRUE
ENDIF
IF away=FALSE THEN
dat=((INT(anfload/2))*2)+2
cs=0
ce=mlen-1
vmem=INT(mlen/mbit)*mbit
DIM clkdiv(60,3)
clkdata:
DATA 1,2,3,4,7,10,17,21,25,18,15,12,19,26,41,16,49,34,27,20,31,42,35,50,39,28,43,58,32,51,36,55,40,44,48,52,56,60
DATA 3,4,7,17,8,25,29,22,37,41,45,49,53,57
RESTORE clkdata
FOR i=1 TO 38
READ a
clkdiv(i,2)=a
NEXT i
FOR i=1 TO 14
READ a
clkdiv(i,3)=a
NEXT i
DIM ls(lmax)
DIM le(lmax)
DIM lcs(lmax)
DIM lce(lmax)
DIM arrfn$(lmax2)
DIM arrpath$(lmax2)
DIM arrstrt(lmax2)
DIM arrend(lmax2)
DIM arrlen(lmax2)
DIM arrmidi(lmax2)
DIM midi(15,127)
DIM arrloop(lmax2)
DIM arrtri(lmax2)
DIM arrsrate(lmax2)
DIM trkfn$(lmax3)     ! track-name
DIM trktnr(lmax3)     ! Nummer in der Fileselect-Liste
DIM trkcom$(lmax3)    ! track-Kommentar (selbstdefiniert) in der Fileliste
DIM trkpath$(lmax3)   ! track-filepfad
DIM trktime(lmax3)    ! smpte-start in 1/1000tel sekunden
DIM trkvor(lmax3)     ! zeiger auf vorheriges sample im gleichen kanal
DIM trknext(lmax3)    ! zeiger auf nÑchstes sample im gleichen kanal
DIM trkstrt(lmax3)    ! anfangspunkt im sample
DIM trkend(lmax3)     ! endpunkt im sample
DIM trklen(lmax3)     ! gesamtlÑnge des samples
DIM trkloop(lmax3)    ! loopen ja/nein
DIM trktri(lmax3)     ! richtung
DIM trksrate(lmax3)   ! sample-rate in hz
DIM trkch(lmax3)      ! track-kanal
DIM trkx(lmax3)       ! X-Position der Curve-Darstellung
DIM trkb(lmax3)       ! Breite der Curve-Darstellung
DIM trkmem(lmax3)     ! Memory-Adresse des Balken-Caches
DIM trkg(lmax3)       ! Anzahl der Pixel des Balken-Caches
DIM tcach(lmax3)      ! Balken-Cache cached/noncached
DIM trkmax(lmax3)     ! maxilmaler Peakwert des Balken-Caches
'
DIM trkpnt(trkvmax)         ! welche position hat das erste sample im kanal x ?
DIM trklev(trkvmax)         ! LautstÑrkewerte der einzelnen Tracks (0-200)
DIM trkpan(trkvmax)         ! Balancewerte der einzelnen Tracks (-50 bis 50)
DIM trkmute(trkvmax)        ! Mute fÅr einzelne Tracks
DIM trksmute(trkvmax)       ! Mute-Merker fÅr Solo-Play
DIM trkstereo(trkvmax)      ! Kanal ist Stereokanal oder Monokanal ?
DIM trktxt$(trkvmax)        ! Textbeschreibung fÅr Kanal
'
maxspur=16
DIM trkwahl(maxspur)        ! welche sind die ausgewÑhlten Tracks ?
DIM trkswahl(maxspur)       ! Merker fÅr Soloplay fÅr ausgewÑhlte Tracks
DIM trkplay(maxspur)        ! welche ist das aktuelle sample im kanal x beim abspielen ?
DIM aktpos(maxspur)         ! aktuelle position der 8 tracks bei play
DIM thandle(maxspur)        ! aktuelle handles der 8 tracks
DIM trkclr(maxspur)         ! Kanal schonmal gelîscht ?
DIM trkclr2(maxspur)        ! Kanal-Ende und schon gelîscht ?
DIM trkseek(maxspur)        ! Seek-Position fÅr Playstart-Position <>0
DIM trkmplay(maxspur)       ! Nummer der geÑnderten Play-Startposition retten fÅr Playstart-Position <>0
DIM trkseek2(maxspur)       ! Seek-Position fÅr Playend-Position <>0
DIM trkmplay2(maxspur)      ! Nummer der geÑnderten Play-Endposition retten fÅr PlayEnd-Position <>0
DIM trkmplay3(maxspur)      ! Nummer der geÑnderten Next-position retten fÅr PlayEnd-Position <>0
FOR i=0 TO trkvmax
trklev(i)=100
trktxt$(i)="-----"
trkstereo(i)=TRUE
NEXT i
trkmem(0)=tmem
@markhlp
maxplug=10
DIM plugnam$(maxplug)
DIM plugpara(maxplug)
DIM plugparnr(maxplug)
DIM plugcmax(maxplug)
DIM plugcset(maxplug)
DIM plugctxt$(maxplug)
DIM plugcart$(maxplug)
DIM plgrlist(maxplug)
DIM plgplist(maxplug)
DIM plgsel$(maxplug)
DIM vplgsel$(maxplug)
DIM dbank$(lmax4)
DIM dbank2$(lmax4)
DIM mbank$(lmax4)
DIM mbank2$(lmax4)
DIM tdbank$(lmax4)
DIM tdbank2$(lmax4)
DIM mblocks(lmax3)
DIM mblocke(lmax3)
DIM mblockp$(lmax3)
loopz=999
DIM loops%(loopz,4)
DIM vloops%(loopz,4)
DIM edmtxt$(loopz)
DIM vedmtxt$(loopz)
bloopz=8
DIM bloops%(loopz,4)
DIM vbloops%(loopz,4)
FOR i=1 TO bloopz
FOR j=1 TO 4
bloops%(i,j)=-1
vbloops%(i,j)=-1
NEXT j
NEXT i
FOR i=1 TO loopz
FOR j=1 TO 4
loops%(i,j)=-1
vloops%(i,j)=-1
NEXT j
NEXT i
cwerte1=0
mbs=0
vmbs=0
n=60
FOR i=1 TO lmax2
arrmidi(i)=n
INC n
IF n>127 THEN
n=0
ENDIF
NEXT i
lz=1
smplen=mlen
ext2$=ext$
IF ext2$="*" THEN
IF dig24=FALSE THEN
ext2$="S16"
ELSE
ext2$="S24"
ENDIF
ENDIF
smpnam$="MEMORY."+ext2$
path$=lfw$+smpnam$
@maschruf9(meml,memh)
retime=0
xmp=0
okmark=0
merkerr=0
merkfreq=0
protnr=0
lded=0
hrd=0
merk1=-1
merk2=-1
merk3=-1
merk4=-1
merkc=-1
prt=-1
plt=-1
prw=FALSE
plw=FALSE
zsf=TIMER
stl=0
sth=0
std=4
staes=0
@balwrite(vol,volinbal,balinmax)                                 ! Eingang auf 0 db stellen
balinmax2=24
@balwrite2(vol2,volinbal2,balinmax2)                             ! Ausgang auf 0 db stellen
ENDIF
ENDIF
ELSE
away=TRUE
ENDIF
IF away=TRUE THEN
@nomem2
ENDIF
RETURN
'
> PROCEDURE errorcode
e$=ERR$(ERR)
e=INSTR(2,e$,"[")
e$=RIGHT$(e$,LEN(e$)-e)
e=INSTR(e$,"]")
e$=LEFT$(e$,e-1)
e=INSTR(e$,"|")
e2=FALSE
IF e<>0 THEN
e$=LEFT$(e$,e-1)
e2=TRUE
ENDIF
IF e2=FALSE AND LEN(e$)>28 THEN
e$=LEFT$(e$,25)+"..."
ENDIF
IF e2=TRUE THEN
IF LEN(e$)>25 THEN
e$=LEFT$(e$,25)+"..."
ELSE
e$=e$+"..."
ENDIF
ENDIF
RETURN
'
> PROCEDURE alertload
LOCAL a$,a,lngnr
IF EXIST(lng$)=TRUE THEN
IF alertflag=TRUE THEN
ERASE lng$()
ENDIF
DIM lng$(300)
OPEN "I",#1,lng$
DO
INPUT #1,a$
a=INSTR(a$," ")
lngnr=VAL(LEFT$(a$,a-1))
EXIT IF lngnr=999
a$=RIGHT$(a$,LEN(a$)-a-1)
lng$(lngnr)=LEFT$(a$,LEN(a$)-1)
LOOP
alertflag=TRUE
CLOSE #1
ENDIF
RETURN
'
> PROCEDURE alerts(alert)
LOCAL aobj,afly,a$,abc,ja$,no$,naja$,ok$,exit$
aobj=obj
afly=fly
fly=TRUE
edit_obj&=0
@wischwasch
a$=lng$(alert)
ja$=lng$(56)
no$=lng$(57)
naja$=lng$(58)
ok$=lng$(59)
exit$=lng$(60)
SELECT alert
CASE 1
g=@rsc_alert(3,a$,1,exit$)
CASE 2
g=@rsc_alert(3,a$,1,exit$)
CASE 3
g=@rsc_alert(3,a$,1,exit$)
CASE 4
g=@rsc_alert(3,a$,1,ok$)
CASE 5
g=@rsc_alert(3,a$,2,ok$+"|"+exit$)
CASE 6
g=@rsc_alert(3,a$,2,ok$+"|"+exit$)
CASE 7
g=@rsc_alert(1,a$,1,ok$)
CASE 8
g=@rsc_alert(3,a$,1,exit$)
CASE 9
g=@rsc_alert(3,a$,1,exit$)
CASE 10
g=@rsc_alert(3,a$,1,exit$)
CASE 11
g=@rsc_alert(1,a$,1,exit$)
CASE 12
g=@rsc_alert(1,a$,1,ok$)
CASE 13
g=@rsc_alert(1,a$,1,ok$)
CASE 14
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 15
g=@rsc_alert(1,a$,1,exit$)
CASE 16
g=@rsc_alert(1,a$,1,ok$)
CASE 17
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 18
g=@rsc_alert(1,a$,1,ok$)
CASE 19
g=@rsc_alert(1,a$,1,exit$)
CASE 20
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 21
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 22
g=@rsc_alert(1,a$,1,exit$)
CASE 23
g=@rsc_alert(1,a$,1,exit$)
CASE 24
g=@rsc_alert(1,a$,1,ok$)
CASE 25
g=@rsc_alert(3,a$,1,exit$)
CASE 26
g=@rsc_alert(2,a$,1,ok$+"|"+exit$)
CASE 27
g=@rsc_alert(3,a$,1,exit$)
CASE 28
g=@rsc_alert(1,a$,1,exit$)
CASE 29
g=@rsc_alert(1,a$,1,naja$)
CASE 30
alrt$=a$+"|"+alrt$
g=@rsc_alert(1,alrt$,1,ok$)
CASE 31
g=@rsc_alert(2,a$,1,ok$+"|"+exit$)
CASE 32
g=@rsc_alert(1,a$,1,exit$)
CASE 33
g=@rsc_alert(1,a$,1,exit$)
CASE 34
g=@rsc_alert(1,a$,1,ok$)
CASE 35
g=@rsc_alert(1,a$,1,ok$)
CASE 36
g=@rsc_alert(1,a$,1,ok$)
CASE 37
g=@rsc_alert(1,a$,1,ok$)
CASE 38
g=@rsc_alert(1,a$,1,ok$)
CASE 39
g=@rsc_alert(3,a$,1,exit$)
CASE 40
g=@rsc_alert(2,a$,2,ja$+"|"+no$)
CASE 41
g=@rsc_alert(2,a$,2,ja$+"|"+no$)
CASE 42
g=@rsc_alert(1,a$,1,exit$)
CASE 43
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 44
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 45
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 46
a=@rsc_alert(3,a$,1,ok$)
CASE 47
g=@rsc_alert(1,a$,1,exit$)
CASE 48
frag=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 49
g=@rsc_alert(0,a$,1,ok$)
CASE 50
@errorcode
abc=RINSTR(a$,"|")
g=@rsc_alert(3,LEFT$(a$,abc)+STR$(ERR)+"|"+e$+RIGHT$(a$,LEN(a$)-abc+1),2,ja$+"|"+no$)
CASE 51
g=@rsc_alert(1,a$,1,ok$)
CASE 61
g=@rsc_alert(2,a$,1,ok$+"|"+exit$)
CASE 62
g=@rsc_alert(2,a$,1,ok$+"|"+exit$)
CASE 99
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
ENDSELECT
obj=aobj
fly=afly
edit_obj&=0
wischwasch
RETURN
'
> PROCEDURE alerts2(alert)
SELECT alert
CASE 1
m$=lng$(52)+CHR$(0)
CASE 2
m$=lng$(53)+CHR$(0)
ENDSELECT
RETURN
'
> PROCEDURE alerts3(alert)
SELECT alert
CASE 1
@write(lng$(54),5)
CASE 2
@write(lng$(55),6)
ENDSELECT
RETURN
'
> PROCEDURE language
LOCAL l,fx,fb,zu%,boxadr,fx1,fx2,fx3
'
fx=88
fx1=88+16
fb=8*(LEN(lng$(201))+1)
@droppos(dddat&,fx,fb)             ! MenÅbalken Datei
fx=fx+fb
fx2=fx+16
fb=8*(LEN(lng$(202))+1)
@droppos(ddwind&,fx,fb)            ! MenÅbalken Fenster
fx=fx+fb
fx3=fx+16
fb=8*(LEN(lng$(203))+1)
@droppos(ddfunc&,fx,fb)            ! MenÅbalken Funktion
fx=fx+fb
fx4=fx+16
fb=8*(LEN(lng$(223))+1)
@droppos(ddplugin&,fx,fb)            ! MenÅbalken Plugins
'
zu%=rsc_adr%(dropdown&)
boxadr=zu%+24*2                    ! MenÅ-Balken
DPOKE boxadr+20,fx+fb
'
l=8*(LEN(lng$(205))+3)
@droppos(ddload&-1,fx1,l)          ! Box fÅr MenÅ Datei
l=8*(LEN(lng$(208))+3)
@droppos(ddsmp16&-1,fx2,l)         ! Box fÅr MenÅ Fenster
l=8*(LEN(lng$(215))+3)
@droppos(ddsetup&-1,fx3,l)         ! Box fÅr MenÅ Funktion
l=8*21
@droppos(ddplug1&-1,fx4,l)         ! Box fÅr MenÅ Plugins
l=8*(LEN(lng$(205))+3)
'
@droppos(ddload&,0,l)              ! Box fÅr load
@droppos(ddsave&,0,l)              ! Box fÅr save
@droppos(ddexit&,0,l)              ! Box fÅr exit
'
@droptxt(ddstar&,lng$(200))
@droptxt(dddat&,lng$(201))
@droptxt(ddwind&,lng$(202))
@droptxt(ddfunc&,lng$(203))
@droptxt(ddinfo&,lng$(204))
@droptxt(ddplugin&,lng$(223))
@droptxt(ddload&,lng$(205)+"^L ")
@droptxt(ddsave&,lng$(206)+"^S ")
@droptxt(ddexit&,lng$(207)+"^Q ")
@droptxt(ddsmp16&,lng$(208)+"^G ")
@droptxt(ddblock&,lng$(209)+"^B ")
@droptxt(ddpeak&,lng$(210)+"^P ")
@droptxt(ddarr&,lng$(211)+"^A ")
@droptxt(ddtrakk&,lng$(212)+"^T ")
@droptxt(ddloop&,lng$(213)+"^O ")
@droptxt(dddsp&,lng$(214)+"^D ")
@droptxt(ddsetup&,lng$(215)+"^E ")
@droptxt(ddfader&,lng$(216)+"^F ")
@droptxt(ddmidi&,lng$(217)+"^N ")
@droptxt(ddbank&,lng$(218)+"^U ")
@droptxt(ddmon&,lng$(219)+"^M ")
@droptxt(ddauto&,lng$(220)+CHR$(1)+"^A ")
@droptxt(ddmanu&,lng$(221)+CHR$(1)+"^R ")
@droptxt(ddplay&,lng$(222)+CHR$(1)+"^P ")
RETURN
'
> PROCEDURE droptxt(dpoint,dtxt$)
LOCAL string,it
zu%=rsc_adr%(dropdown&)
CHAR{C:rsc_obspec%(L:zu%,dpoint)}=dtxt$
RETURN
'
> PROCEDURE droppos(dpoint,xp,bp)
LOCAL string,it
zu%=rsc_adr%(dropdown&)
buttadr=zu%+24*dpoint
DPOKE buttadr+16,xp
DPOKE buttadr+20,bp
RETURN
'
> PROCEDURE dropentrys(dpoint,hp)
LOCAL zu%,buttadr,h
zu%=rsc_adr%(dropdown&)
buttadr=zu%+24*dpoint
'  h=DPEEK(buttadr+22)
DPOKE buttadr+22,hp*16
RETURN
'
> PROCEDURE killedit
IF nr=smpedit& THEN
mbs=0
zoomp=0
scrollp=0
IF virtual=TRUE THEN
@trashvirt
ENDIF
@maschruf9(meml,memh)
cs=0
ce=mlen
@zslidecalc
@scrollinit
@makepnt
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@markdel
@clsed
@restaura
ENDIF
RETURN
'
> PROCEDURE loadtoedit
ldtrk=TRUE
ldtrk2=TRUE
a$=trkpath$(trkp)
b$=trkfn$(trkp)
a=INSTR(a$,CHR$(0))
IF a>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
a=INSTR(b$,CHR$(0))
IF a>0 THEN
b$=LEFT$(b$,a-1)
ENDIF
a=RINSTR(a$,"\")
IF LEN(a$)=0 THEN
ordner$=""
ELSE
ordner$=LEFT$(a$,a)
ENDIF
IF LEN(b$)=0 THEN
nam$=""
fil$=""
ELSE
nam$=b$
fil$=ordner$+b$
ENDIF
tblks=blks
blks=0
IF virtual=TRUE THEN
@trashvirt
ENDIF
cs=0
ce=mlen
@smpload
@wischwasch
ldtrk3=TRUE
a=sms+1
IF trkstrt(trkp)=loops%(sms,1) AND sms>0 THEN
a=sms
ENDIF
IF a>loopz THEN
a=loopz
ENDIF
loops%(a,1)=trkstrt(trkp)
sms=a
IF trkend(trkp)=loops%(sms,2) AND sms>0 THEN
a=sms
ENDIF
loops%(a,2)=trkend(trkp)
@restaura
IF sms>0 AND sms<=loopz THEN
@edmarkset(sms)
ENDIF
ldtrk2=FALSE
blks=tblks
RETURN
'
> PROCEDURE filltrkmem
LOCAL i,membl,bw,memz
IF memf=1 THEN
memz=mems1+(ltrk*c)-ltrk+dpos
bw=GEMDOS(63,thandle(c),L:tlen,L:memz)
'    PRINT "0>";thandle(c),memz,tlen,bw
ENDIF
IF memf=0 THEN
memz=mems2+(ltrk*c)-ltrk+dpos
bw=GEMDOS(63,thandle(c),L:tlen,L:memz)
'    PRINT "1>";thandle(c),memz,tlen,bw
ENDIF
@time8
RETURN
'
> PROCEDURE tcorr
IF dspuse=TRUE THEN
back%=back%/spuren
ENDIF
RETURN
'
> PROCEDURE time8
LOCAL v,v2,k,v4
IF tdown=FALSE THEN
hsec2=INT((TIMER-t)/2)
back%=LPEEK(recback+24)          !36 Playbyte
@tcorr
peakret=recback+16    !28 max. Peakwert
@peakrec3
IF INT(hsec2/16)<>INT(hsec/16) THEN            ! ums langsamer zu machen !
hsec=INT(back%/thz/mbit*100)
@htimeset                                  ! zeituhr zeigen
hsec=hsec2
@textfeld(traktime&,a$,1)
~GRAF_MKSTATE(v,v2,k,v4)
IF k=2 AND pmo8=TRUE THEN
IF v4=0 THEN
INC pt
IF pt=4 THEN
pt=0
ENDIF
ELSE
IF pt=0 THEN
pt=4
ENDIF
DEC pt
ENDIF
@channel
REPEAT
UNTIL @mousek=0
ENDIF
ENDIF
@peakbreak3
ENDIF
RETURN
'
> PROCEDURE trkplay
LOCAL r,akku,j,rr,a,i,cl,ts,pm,sa,tm,tp,tl,ts
'
'  16 Channel-harddisk-player
'
pl=0
pr=0
vpl=0
vpr=0
wpl=0   ! peakhold left
wpr=0   ! peakhold right
sfila%=0
IF demo=FALSE AND falcon=FALSE THEN
@spuren(spuren*2)
@setadatp
spurz=spuren*2
'
IF dspuse=TRUE THEN
SELECT spurz
CASE 1 TO 4
@dspplay4
'      PAUSE 20
CASE 5 TO 8
@dspplay8
'      PAUSE 20
CASE 9 TO 12
CASE 13 TO 16
ENDSELECT
ENDIF
IF pch4=TRUE THEN
@dspplay2
'    PAUSE 20
~XBIOS(xbs,27,1)
ENDIF
@soloplay1
FOR i=1 TO spurz
trkstereo(i)=TRUE
trkplay(i)=0
NEXT i
tprint=FALSE
IF tprint=TRUE THEN
CLS
ENDIF
sa=0
FOR a=1 TO spurz
IF trkwahl(a)>0 THEN
trkplay(a)=trkpnt(trkwahl(a))
tm=trkmute(trkwahl(a))
IF tm=TRUE THEN
INC sa
ENDIF
ELSE
INC sa
ENDIF
trkclr(a)=0
trkclr2(a)=0
IF tplaystart<>-1 THEN
aktpos(a)=tplaystart
ELSE
aktpos(a)=0
ENDIF
NEXT a
IF tplaystart>0 THEN
FOR a=1 TO spurz    ! Startpositionen anpassen fÅr Play-Startposition>0
trkseek(a)=0
trkmplay(a)=0
a2=trkplay(a)
IF a2<>0 THEN
a5=0
REPEAT
a3=trktime(a2)
IF a3<=tplaystart THEN
a5=a2
ENDIF
a2=trknext(a2)
UNTIL a3>tplaystart OR a2=0
IF a5<>0 THEN
trkplay(a)=a5
trkseek(a)=tplaystart-trktime(a5)
IF trkseek(a)<0 OR (trkseek(a)+trkstrt(a5))>=trkend(a5) THEN
trkseek(a)=0
trkplay(a)=trknext(a5)   !neu
ENDIF
trkstrt(a5)=trkstrt(a5)+trkseek(a)
trktime(a5)=trktime(a5)+trkseek(a)
trkmplay(a)=a5
ELSE
trkseek(a)=0
ENDIF
ENDIF
NEXT a
ENDIF
'
'
IF tplayend>0 THEN
FOR a=1 TO spurz    ! Endpositionen anpassen fÅr Play-Endposition
trkseek2(a)=0
trkmplay2(a)=0
trkmplay3(a)=0
a2=trkplay(a)
IF a2<>0 THEN
a5=0
REPEAT
a3=trktime(a2)
IF a3<tplayend THEN
a5=a2
ENDIF
a2=trknext(a2)
UNTIL a3>tplayend OR a2=0
IF a5<>0 THEN
trkseek2(a)=(trktime(a5)+(trkend(a5)-trkstrt(a5)))-tplayend
IF trkseek2(a)<0 THEN
trkseek2(a)=0
ENDIF
trkmplay3(a)=trknext(a5)
trknext(a5)=0
trkend(a5)=trkend(a5)-trkseek2(a)
trkmplay2(a)=a5
ELSE
trkplay(a)=0
trkseek2(a)=0
ENDIF
ENDIF
NEXT a
ENDIF
'
IF tplayend>0 THEN
endcount=tplayend
ELSE
endcount=0
FOR a=1 TO spurz    ! Endpositionen anpassen fÅr Play-Endposition
a2=trkplay(a)
IF a2<>0 THEN
REPEAT
a3=trktime(a2)+(trkend(a2)-trkstrt(a2))
IF a3>=endcount THEN
endcount=a3
ENDIF
a2=trknext(a2)
UNTIL a2=0
ENDIF
NEXT a
ENDIF
IF tplaystart>0 THEN
strtcount=tplaystart
ELSE
strtcount=0
ENDIF
'
z=0
adder=0
voldplay=oldplay
oldplay=FALSE
IF virtual=TRUE THEN
@alerts(7)
ENDIF
vad=ad
IF vad=0 THEN
@analog
ENDIF
@wait
over=0
@digout(TRUE)
g=8     ! blocks
ts=sector*g
mb=1024*1024  ! grîûe der blocks
@playinit
IF pmo8=TRUE THEN
IF pch16=FALSE THEN
sea%=playfifolen/8/4-1
ELSE
sea%=playfifolen/16/4-1
ENDIF
ENDIF
IF dspuse=TRUE THEN
IF spurz=4 THEN
sea%=&H1000/4-1     ! WICHTIG !!! : muû umgestellt werden auf &H1000/2-1 = $7FF, sonst nicht kompatibel mit XBIOS !!!
ENDIF
IF spurz=8 THEN
sea%=&H1000/2-1
ENDIF
ENDIF
'  LPOKE recback+12,0   ! ???
'  LPOKE recback+24,0          !36 Playbyte
IF dspuse=FALSE AND pmo8=FALSE THEN
ltrk=INT(meml2/(spuren+1))     ! lÑnge der einzelnen Channel-Memory-Blocks
ELSE
ltrk=INT(meml2/(spuren*2))     ! lÑnge der einzelnen Channel-Memory-Blocks
ENDIF
ltrk=INT(ltrk/ts)*ts
'
ltrk=INT(ltrk/mbit)*mbit
'
saa%=saa%+(ltrk*spuren)
saa2%=saa2%+(ltrk*spuren)
FOR a=1 TO spurz
IF trkwahl(a)>0 THEN
tp=trkpnt(trkwahl(a))
tm=trkmute(trkwahl(a))
ELSE
tp=0
tm=TRUE
ENDIF
thandle(a)=0
IF tm=TRUE OR tp=0 THEN
trkclr(a)=2
trkclr2(a)=2
trkplay(a)=0
ENDIF
IF tm=FALSE THEN
IF trkwahl(a)>0 THEN
tl=trklev(trkwahl(a))
ELSE
tl=100
ENDIF
IF dig24=TRUE THEN
tl=128*tl/100
ENDIF
DPOKE mdat3%+(a*2)-2,tl
ELSE
DPOKE mdat3%+(a*2)-2,0
ENDIF
NEXT a
i=0
c=1
@maschruf9(mems1,mems1+(ltrk*(spuren+1)))    ! bereich lîschen
@maschruf9(mems2,mems2+(ltrk*(spuren+1)))    ! bereich lîschen
i=0
t=TIMER
back%=0       ! aktuelle mem-playposition
back3%=0      ! abbruch ?
IF tplaystart<>-1 THEN
mempos=tplaystart      ! anfang aktueller blockbereich
ELSE
mempos=0
ENDIF
t_start=FALSE ! erster sampleload ?
j=0
dpos=0
trkerr=0
mft=FALSE
memf=1
exfill=FALSE
IF sa<spurz THEN
@deltrktxt
GRAPHMODE 1
REPEAT
FOR c=1 TO spuren
IF trkwahl(c)>0 THEN
tp=trkpnt(trkwahl(c))
tm=trkmute(trkwahl(c))
ts=trkstereo(trkwahl(c))
ELSE
tp=0
tm=TRUE
ts=TRUE
ENDIF
'      IF ts=TRUE THEN
'      IF c/2=INT(c/2) THEN
'      INC c
'    ENDIF
'    ENDIF
IF tm=FALSE THEN
REPEAT
IF t_start=TRUE THEN               ! nicht beim ersten aufruf...
IF tdown=FALSE THEN
back%=LPEEK(recback+24)          !36 Playbyte
@tcorr
back3%=LPEEK(recback+8)          ! Breakflag
ELSE
back3%=0
ENDIF
IF mft=FALSE THEN
IF tdown=FALSE THEN
memf=LPEEK(recback+4)           !12 Memflag
ENDIF
mft=TRUE
ENDIF
ENDIF
cnr=trkplay(c)        ! zeiger auf aktuelles Channel-File
IF memf=1 THEN
pm=mems1
ELSE
pm=mems2
ENDIF
IF cnr=0 THEN
IF trkclr2(c)<2 THEN
IF tprint=TRUE THEN
PRINT "ACLR(ch,strt,len):",c,(pm+(ltrk*c)-ltrk),ltrk
ENDIF
@maschruf9(pm+(ltrk*c)-ltrk,pm+(ltrk*c))    ! bereich lîschen
trkclr(c)=2
INC trkclr2(c)
ENDIF
aktpos(c)=aktpos(c)+ltrk            ! aktuelle position ist jetzt ende des blocks
ELSE
pat$=trkpath$(cnr)+CHR$(0)   ! Filepfad
st=trktime(cnr)                    ! smpte-startzeit holen
st3=trkend(cnr)-trkstrt(cnr)       ! lÑnge des samples
IF trknext(cnr)<>0 THEN
ns=trktime(trknext(cnr))
IF st3>ns-st THEN
st3=ns-st
ENDIF
ENDIF
IF st>=mempos AND st<=(mempos+ltrk) THEN       ! ist sample in der aufzubereitenden zeit ?
st2=st3
dpos=st-aktpos(c)                  ! relativ zu speicheranfang
IF dpos>0 AND aktpos(c)<st THEN
ms=pm+(ltrk*c)-ltrk+(aktpos(c)-mempos)
me=ms+dpos
tlen=dpos
IF tprint=TRUE THEN
PRINT "CLR(a->|) (ch,strt,len,ms,me):",c,aktpos(c),tlen,ms,me
ENDIF
aktpos(c)=aktpos(c)+tlen           ! aktuelle position ist jetzt ende des blocks
@maschruf9(ms,me)    ! bereich lîschen
trkclr(c)=0
trkclr2(c)=0
dpos=st-mempos                  ! relativ zu speicheranfang
ELSE
dpos=st-mempos                  ! relativ zu speicheranfang
ENDIF
tstrt=aktpos(c)                  ! aktuelle zeitposition
tend=aktpos(c)+st2               ! ende der aktuellen zeit+lÑnge
IF tend>mempos+ltrk THEN
tend=mempos+ltrk               ! ende geht Åber aufzubereitenden bereich hinaus ? -> kÅrzen
ENDIF
tlen=tend-tstrt                  ! lÑnge des grîûtmîglichen ladebereichs
IF thandle(c)=0 THEN
thandle(c)=GEMDOS(61,L:VARPTR(pat$),0)    ! open sample
ENDIF
@headart2(pat$)
v=GEMDOS(66,L:trkstrt(cnr)+head,thandle(c),0)     ! SEEK
IF tprint=TRUE THEN
PRINT "OPEN(ch,nr,handle,name,len,h):",c,cnr,thandle(c),pat$,trkend(cnr)-trkstrt(cnr)
PRINT "LOAD(ch,nr,name,strt,end,len,dpos):",c,cnr,trkfn$(cnr),aktpos(c),tend-strt,tlen
ENDIF
trkclr(c)=0
trkclr2(c)=0
@filltrkmem                              ! sample in aufzubereitenden speicher laden
aktpos(c)=aktpos(c)+tlen                 ! aktuelle position ist jetzt ende des samples
IF tlen=st2 THEN
cnr=trknext(cnr)                   ! zeiger auf nÑchstes sample im channel
trkplay(c)=cnr                     ! zeiger merken
cl=GEMDOS(62,thandle(c))           ! close sample
thandle(c)=0                       ! handle entfernen
IF tprint=TRUE THEN
PRINT "nCLOSE(ch,handle,closeok,name):",c,thandle(c),cl,trkfn$(cnr)
ENDIF
ENDIF
ELSE
IF thandle(c)<>0 AND st<mempos THEN     ! sample schon geîffnet und restsample existent ?
st2=st+st3-mempos                ! restlÑnge des samples
IF st2>0 THEN
dpos=0
tstrt=mempos                        ! aktuelle zeitposition
tend=mempos+st2                     ! ende der aktuellen zeit+lÑnge
IF tend>mempos+ltrk THEN
tend=mempos+ltrk                  ! ende geht Åber aufzubereitenden bereich hinaus ? -> kÅrzen
IF tprint=TRUE THEN
PRINT "NEXTLOAD(ch,nr,name,strt,end,len):",c,cnr,trkfn$(cnr),aktpos(c),tend-strt,tend-strt-aktpos(c)
ENDIF
tlen=tend-tstrt                     ! lÑnge des grîûtmîglichen ladebereichs
trkclr(c)=0
trkclr2(c)=0
@filltrkmem                         ! sample in aufzubereitenden speicher laden
aktpos(c)=aktpos(c)+tlen            ! aktuelle position ist jetzt ende des samples
ELSE
IF tprint=TRUE THEN
PRINT "CLOSE(ch,h,nam,st,e,ln):",c,thandle(c),trkfn$(cnr),aktpos(c),tend-strt,tend-strt-aktpos(c)
ENDIF
cnr=trknext(cnr)                    ! zeiger auf nÑchstes sample im channel
trkplay(c)=cnr                      ! zeiger merken
tlen=tend-tstrt                     ! lÑnge des grîûtmîglichen ladebereichs
trkclr(c)=0
trkclr2(c)=0
@filltrkmem                         ! sample in aufzubereitenden speicher laden
aktpos(c)=aktpos(c)+tlen            ! aktuelle position ist jetzt ende des samples
cl=GEMDOS(62,thandle(c))            ! close sample
thandle(c)=0                        ! handle entfernen
IF tprint=TRUE THEN
PRINT cl
ENDIF
IF cnr=0 THEN
ms=pm+(ltrk*c)-ltrk+(aktpos(c)-mempos)
me=pm+(ltrk*c)
tlen=me-ms
IF tprint=TRUE THEN
PRINT "CLR(|e) (ch,strt,len,ms,me):",c,aktpos(c),tlen,ms,me
ENDIF
aktpos(c)=aktpos(c)+tlen           ! aktuelle position ist jetzt ende des blocks
@maschruf9(ms,me)    ! bereich lîschen
trkclr(c)=0
trkclr2(c)=0
ENDIF
ENDIF
ENDIF
ELSE
IF st>mempos THEN     ! leerlauf ?
tstrt=aktpos(c)
tend=trktime(cnr)
IF tend>mempos+ltrk THEN
tend=mempos+ltrk               ! ende geht Åber aufzubereitenden bereich hinaus ? -> kÅrzen
ENDIF
tlen=tend-tstrt
a2=pm+aktpos(c)-mempos
ms=a2+(ltrk*c)-ltrk
me=pm+(ltrk*c)
IF (tlen=ltrk AND trkclr(c)<2) OR tlen<>ltrk THEN
IF tprint=TRUE THEN
PRINT "CLR(|->e) (ch,strt,len,ms,me):",c,aktpos(c),tlen,ms,me
ENDIF
@maschruf9(ms,me)    ! bereich lîschen
IF tlen=ltrk THEN
INC trkclr(c)
ELSE
trkclr(c)=0
trkclr2(c)=0
ENDIF
ENDIF
aktpos(c)=aktpos(c)+tlen           ! aktuelle position ist jetzt ende des blocks
ENDIF
ENDIF
ENDIF
ENDIF
@time8
UNTIL exfill=TRUE OR aktpos(c)=mempos+ltrk OR cnr=0 OR back3%=1       ! solange weitere samples laden bis memblock voll ist
IF cnr=0 THEN
a2=pm+aktpos(c)-mempos
ms=a2+(ltrk*c)-ltrk
me=pm+(ltrk*c)
tlen=me-ms
IF tlen>0 THEN
IF tprint=TRUE THEN
PRINT "CLR(|->exit) (ch,strt,len,ms,me):",c,aktpos(c),tlen,ms,me
ENDIF
@maschruf9(ms,me)    ! bereich lîschen
aktpos(c)=aktpos(c)+tlen           ! aktuelle position ist jetzt ende des blocks
ENDIF
ENDIF
EXIT IF back3%=1 OR exfill=TRUE
ENDIF
NEXT c                                       ! nÑchster channel
blen%=ltrk
IF memf=1 THEN
src%=mems1
dst%=mems1+(ltrk*spuren)
IF tprint=TRUE THEN
PRINT "MIX0"
ENDIF
ELSE
src%=mems2
dst%=mems2+(ltrk*spuren)
IF tprint=TRUE THEN
PRINT "MIX1"
ENDIF
ENDIF
SELECT spurz
CASE 1 TO 4
IF pch4=FALSE THEN
IF dspuse=FALSE THEN
mix4=XBIOS(xbs,100,4,L:src%,L:blen%,L:dst%,L:mdat3%)
ELSE
mix4=XBIOS(xbs,101,4,L:src%,L:blen%,L:dst%)
ENDIF
ENDIF
CASE 5 TO 8
IF dspuse=FALSE THEN
IF pmo8=FALSE THEN
mix8=XBIOS(xbs,100,8,L:src%,L:blen%,L:dst%,L:mdat3%)
ELSE
IF pch16=FALSE THEN
mix8=XBIOS(xbs,101,8,L:src%,L:blen%,L:dst%)
ELSE
mix8=XBIOS(xbs,101,16,L:src%,L:blen%,L:dst%)
ENDIF
ENDIF
ELSE
mix8=XBIOS(xbs,101,8,L:src%,L:blen%,L:dst%)
ENDIF
CASE 9 TO 12
mix12=XBIOS(xbs,100,12,L:src%,L:blen%,L:dst%,L:mdat3%)
CASE 13 TO 16
IF pmo8=FALSE THEN
mix16=XBIOS(xbs,100,16,L:src%,L:blen%,L:dst%,L:mdat3%)
ELSE
IF pch16=TRUE THEN
mix16=XBIOS(xbs,101,16,L:src%,L:blen%,L:dst%)
ENDIF
ENDIF
ENDSELECT
IF tprint=TRUE THEN
'    PRINT "MIX:",dst%,mix4,mix4-dst%
ENDIF
IF z>0 AND j<spuren AND exfill=FALSE THEN
REPEAT
@time8
IF tdown=FALSE THEN
memf=LPEEK(recback+4)           !12 Memflag
back3%=LPEEK(recback+8)           ! Breakflag
ELSE
@downmix2
ENDIF
UNTIL vmemf<>memf OR back3%=1 OR exfill=TRUE OR tdown=TRUE
vmemf=memf
ENDIF
IF z=0 THEN
INC z
'
@trakplay8                                   ! abspielen starten
'
IF pmo8=TRUE THEN
'
IF mixdsp=TRUE THEN
pt=3
ELSE
pt=0
ENDIF
@channel
'
ENDIF
'
mft=FALSE
t_start=TRUE
vmemf=0
IF tdown=FALSE THEN
memf=0
ELSE
@downmix2
ENDIF
ENDIF
mempos=mempos+ltrk                          ! zum nÑchsten block
'
IF back%>mempos THEN
INC trkerr
@textfeld(trkerr&,"ERR:"+STR$(trkerr)+CHR$(0),1)
ENDIF
'
j=0
FOR a=1 TO spuren
IF trkplay(a)=0 THEN
INC j                       ! alle samples geladen...
'        IF trkwahl(a)>0 THEN
'          ts=trkstereo(trkwahl(a))
'        ELSE
'          ts=TRUE
'        ENDIF
'        IF ts=TRUE AND a/2=INT(a/2) THEN
'         INC j
'         INC a
'        ENDIF
ENDIF
NEXT a
@time8
UNTIL (j=spuren AND back%>=tend) OR back3%=1 OR exfill=TRUE OR (tdown=TRUE AND tlen=0 AND j=spuren)                        ! ...dann ende
FOR i=1 TO spuren
IF thandle(i)>0 THEN
cl=GEMDOS(62,thandle(i))                           ! close sample
IF tprint=TRUE THEN
PRINT ".CLOSE(handle,close):",thandle(i),cl
ENDIF
ENDIF
NEXT i
IF hardopen=FALSE THEN
@opentrk2
ENDIF
ENDIF
IF tprint=TRUE THEN
PRINT "ENDE"
ENDIF
intplay=FALSE
@write_int(0)
IF dspuse=TRUE OR pch4=TRUE THEN
~XBIOS(xbs,55,0)
~XBIOS(xbs,73,0)
ENDIF
IF nr=smpedit& THEN
@intzeiger3
@textfeld(smpsec&,sec$,1)
ENDIF
IF tdown=FALSE THEN
back%=LPEEK(recback+24)           !36 letztes playbyte
@tcorr
ENDIF
@digout(FALSE)
'
IF tplaystart>0 THEN
FOR a=1 TO spurz   ! gerettete Startpositionen zurÅckschreiben (fÅr Startplay-Position>0)
a2=trkmplay(a)
IF a2<>0 THEN
IF trkseek(a)<>0 THEN
trkstrt(a2)=trkstrt(a2)-trkseek(a)
trktime(a2)=trktime(a2)-trkseek(a)
ENDIF
ENDIF
NEXT a
ENDIF
'
IF tplayend>0 THEN
FOR a=1 TO spurz   ! gerettete Endpositionen zurÅckschreiben (fÅr Endplay-Position<>0)
a2=trkmplay2(a)
IF a2<>0 THEN
IF trkseek2(a)<>0 THEN
trkend(a2)=trkend(a2)+trkseek2(a)
ENDIF
trknext(a2)=trkmplay3(a)
ENDIF
NEXT a
ENDIF
'
IF trkerr>0 THEN
@textfeld(trkerr&,"        "+CHR$(0),1)
ENDIF
IF vad=0 THEN
@digital
ELSE
@analog
ENDIF
ENDIF
@setbutton(trakplay&,0)
IF demo=FALSE THEN
oldplay=voldplay
cached=tcach(0)
@soloplay2
~XBIOS(xbs,27,0)
IF pch4=TRUE OR pmo8=TRUE THEN
IF digana=TRUE AND ad=1 THEN
~XBIOS(&H8B,0,2,0,clk,1)
~XBIOS(&H8B,3,11,0,clk,1)
ELSE
~XBIOS(&H8B,0,2,0,0,1)
~XBIOS(&H8B,3,11,0,0,1)
ENDIF
ENDIF
IF pmo8=TRUE THEN
~XBIOS(xbs,72,14)
ENDIF
matrixplay=FALSE
pch4=FALSE
pmo8=FALSE
pch16=FALSE
ENDIF
RETURN
'
> PROCEDURE soloplay1
LOCAL i
IF tsolo=TRUE THEN
FOR i=1 TO trkvmax
trksmute(i)=trkmute(i)
trkmute(i)=TRUE
NEXT i
FOR i=1 TO spurz
trkswahl(i)=trkwahl(i)
trkwahl(i)=FALSE
NEXT i
trkmute(trakact)=FALSE
trkwahl(1)=trakact
ENDIF
RETURN
'
> PROCEDURE soloplay2
LOCAL i
IF tsolo=TRUE THEN
FOR i=1 TO trkvmax
trkmute(i)=trksmute(i)
NEXT i
FOR i=1 TO spurz
trkwahl(i)=trkswahl(i)
NEXT i
ENDIF
RETURN
'
> PROCEDURE channel
IF demo=FALSE THEN
a=XBIOS(&H86,pt)
ENDIF
IF pt=0 THEN
IF bigfoot=FALSE THEN
a$="1+2"
ELSE
a$="M 1+2"
ENDIF
ENDIF
IF pt=1 THEN
IF bigfoot=FALSE THEN
a$="3+4"
ELSE
a$="M 3+4"
ENDIF
ENDIF
IF pt=2 THEN
IF bigfoot=FALSE THEN
a$="5+6"
ELSE
a$="M 5+6"
ENDIF
ENDIF
IF pt=3 THEN
IF bigfoot=FALSE THEN
a$="7+8"
ELSE
a$="M 7+8"
ENDIF
ENDIF
IF nr=trakker& THEN
a$=a$+CHR$(0)
@textfeld(trkmon&,a$,1)
ENDIF
RETURN
'
> PROCEDURE trakplay8
LOCAL p,b$,g,tclk
' HARDDISK-PLAY second generation (ersetzt wie maschruf5c)
'
IF digana=TRUE THEN
tclk=clk
ELSE
tclk=0
ENDIF
'
DEFMOUSE 0
exfill=FALSE
firstp=FALSE
IF dspuse=FALSE AND pmo8=FALSE THEN
sba%=saa%+ltrk
sba2%=saa2%+ltrk
ELSE
sba%=saa%+ltrk*spuren
sba2%=saa2%+ltrk*spuren
ENDIF
IF XBIOS(xbs,1)=&H71273800 THEN
IF tdown=FALSE THEN
IF dspuse=FALSE THEN
IF pmo8=FALSE THEN
IF pch4=FALSE THEN
recback=XBIOS(xbs,141,0,L:saa%,L:saa2%,L:sba%-saa%,L:strtcount,L:endcount,sfila%,sca%,sda%)
ELSE
nsaa%=mems1
nsba%=mems1+ltrk
nsaa2%=mems2
nsba2%=mems2+ltrk
dsaa%=mems1+ltrk
dsba%=mems1+ltrk*2
dsaa2%=mems2+ltrk
dsba2%=mems2+ltrk*2
sea2%=&H1000/2-1
recback=XBIOS(xbs,144,L:nsaa%,L:nsaa2%,L:dsaa%,L:dsaa2%,L:ltrk,L:strtcount,L:endcount,sfila%,sca%,sda%)
'
~XBIOS(xbs,27,1)
~XBIOS(&H8B,0,10,0,tclk,1)
'
ENDIF
ELSE
IF pch16=FALSE THEN
recback=XBIOS(xbs,141,2,L:saa%,L:saa2%,L:sba%-saa%,L:strtcount,L:endcount,sfila%,sca%,sda%)
ELSE
recback=XBIOS(xbs,141,3,L:saa%,L:saa2%,L:sba%-saa%,L:strtcount,L:endcount,sfila%,sca%,sda%)
ENDIF
IF pmo8=TRUE THEN
IF dspmodemix=FALSE THEN
@dspmix8
ELSE
@dspeffmix8
ENDIF
IF mixdsp=TRUE THEN
pt=3
ELSE
pt=0
ENDIF
IF pch16=FALSE THEN
~XBIOS(xbs,27,2)
ELSE
~XBIOS(xbs,27,3)
ENDIF
@channel
IF matrixplay=TRUE THEN
~XBIOS(xbs,72,14)
~XBIOS(&H8B,0,8+4,0,tclk,1)
ELSE
~XBIOS(xbs,72,15)
~XBIOS(&H8B,0,2,0,tclk,1)
~XBIOS(&H8B,1,8+4,0,tclk,1)
ENDIF
ENDIF
ENDIF
IF pch4=FALSE AND dspuse=FALSE THEN
@wait_mtc
@write_int(1)
ELSE
IF pch4=TRUE THEN
~XBIOS(xbs,74)            ! DSP-Clear, muû wieder raus
~XBIOS(xbs,55,0)
~XBIOS(xbs,55,1)      ! Probeweise entfernt, muû wieder rein
~XBIOS(xbs,73,0)
@wait_mtc
@write_int(1)
ELSE
IF dspuse=TRUE THEN
~XBIOS(xbs,73,0)
~XBIOS(xbs,55,1)
ENDIF
ENDIF
ENDIF
ELSE
@write_int(0)
~XBIOS(&H8B,0,2,0,tclk,1)
~XBIOS(&H8B,1,8,0,tclk,1)
recback=XBIOS(xbs,141,1,L:saa%,L:saa2%,L:sba%-saa%,L:strtcount,L:endcount,sfila%,sca%,sda%)
'        ~XBIOS(xbs,73,0)
'       ~XBIOS(xbs,55,1)
'
~XBIOS(xbs,74)
~XBIOS(xbs,73,0)
~XBIOS(xbs,55,1)
'
ENDIF
ENDIF
t=TIMER
intplay=TRUE
ENDIF
RETURN
'
> PROCEDURE wait_mtc
LOCAL fz
IF mtc=TRUE THEN
fz=framez
'
'    h=0
'    m=0
'    s=0
'    ms=0
'
'    frames=h*fz*60*60+m*fz*60+s*fz+ms
frames=smptestrt
'
@write_int(0)
~XBIOS(xbs,162,1)           ! framecounter starten
REPEAT
IF INP?(2)=TRUE THEN
~INP(2)
ENDIF
UNTIL INP?(2)=FALSE
'
~XBIOS(xbs,164,L:frames,fz)      ! wait auf mtc oder space-taste
'
REPEAT
IF INP?(2)=TRUE THEN
~INP(2)
ENDIF
UNTIL INP?(2)=FALSE
ENDIF
RETURN
'
> PROCEDURE downmix
LOCAL cl
tdown=TRUE
dpz=0
@fileselect(op$+"*."+ext$,"","SAVE DOWNMIX:")
IF LEN(fil$)>0 THEN
IF INSTR(fil$,".")=0 THEN
fil$=fil$+"."+ext$
ENDIF
IF RIGHT$(fil$,3)=ext$ THEN
IF pret<>0 AND pbutt=1 THEN
dm$=fil$+CHR$(0)
'
dpch4=pch4
dpmo8=pmo8
dpch16=pch16
dmatrixplay=matrixplay
dmatrix=matrix
pch4=FALSE
pmo8=FALSE
pch16=FALSE
matrixplay=FALSE
matrix=FALSE
'
@trkplay
'
pch4=dpch4
pmo8=dpmo8
pch16=dpch16
matrixplay=dmatrixplay
matrix=dmatrix
'
IF dpz>0 THEN
@headmake
@headmake2
~GEMDOS(66,L:0,dmh,0)             ! seek to zero
~GEMDOS(64,dmh,L:head,L:danf)
cl=GEMDOS(62,dmh)                 ! close sample
ENDIF
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
tdown=FALSE
@setbutton(hrdmerg2&,0)
RETURN
'
> PROCEDURE downmix2
back%=back%+ltrk
back3%=0
dsrc%=dst%    ! bufferadresse
IF dpz=0 THEN
dmh=GEMDOS(60,L:VARPTR(dm$),0)    ! open sample
danf=mdat%
vln=0
fil$=LEFT$(dm$,LEN(dm$)-1)
@headart
fileart=sfileart
IF head>0 THEN
~GEMDOS(64,dmh,L:head,L:danf)
ENDIF
ENDIF
INC dpz
dbw=GEMDOS(64,dmh,L:ltrk,L:dsrc%)
vln=vln+ltrk
IF memf=1 THEN
memf=0
ELSE
memf=1
ENDIF
@busy_mouse
RETURN
'
> PROCEDURE treiberload
IF EXIST(s$+"SOUND.PRG"+CHR$(0))=TRUE THEN
a=EXEC(0,s$+"SOUND.PRG"+CHR$(0),CHR$(0),CHR$(0))
z=0
REPEAT
PAUSE 1
INC z
UNTIL XBIOS(xbs,1)=&H71273800 OR z=50
IF a<>0 OR XBIOS(xbs,1)<>&H71273800 THEN
@alerts(8)
END
ENDIF
ELSE
@alerts(9)
END
ENDIF
RETURN
'
> PROCEDURE rec_headinit(r$)
fil$=LEFT$(r$,INSTR(r$,CHR$(0))-1)
danf=mdat%
@headart
IF sfileart=0 THEN
inf=FALSE
@alerts(10)
ENDIF
RETURN
'
> PROCEDURE rec_header
IF sfileart<>0 THEN
fileart=sfileart
OPEN "I",#1,fil$+CHR$(0)
vmlen=mlen
mlen=LOF(#1)-head
CLOSE #1
vblks=blks
vsret=sret
vsblock=sblock
blks=0
sret=0
sblock=0
vfileart=fileart
fileart=sfileart
@headmake
fileart=vfileart
mlen=vmlen
blks=vblks
sret=vsret
sblock=vsblock
a$=fil$+CHR$(0)
a=VARPTR(a$)        !Pfad
filadr=a
h%=GEMDOS(61,L:filadr,2)
IF h%>0 THEN
ok%=GEMDOS(66,L:0,h%,0)
ok%=GEMDOS(64,h%,L:head,L:danf)
ok%=GEMDOS(62,h%)
ENDIF
ENDIF
RETURN
'
> FUNCTION mxalloc(giveme,art)
a=GEMDOS(68,L:giveme,art)
RETURN a
ENDFUNC
'
> PROCEDURE intzeiger1(bx)
.| Glob. Var.: cs#,ce#,cx#,xm#,c1#,sret#,c2#,sblock#,xd#,stay1#,stay2#,cx2#
.| Ruft auf  : blocklook
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf5-1,maschruf5c-1,
LOCAL j
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
@blocklook
'  IF ((bx=c1 AND (sret=0 OR sret=2)) OR (bx=c2-8 AND sret=1)) AND sblock=1 THEN
GRAPHMODE 3
'    ELSE
'     GRAPHMODE 1
' ENDIF
LINE cx+xd,stay1,cx+xd,stay2
cx2=cx
COLOR 0
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ELSE
cx2=-1
ENDIF
RETURN
'
> PROCEDURE intzeiger2(bx)
.| Glob. Var.: cs#,ce#,cx#,xm#,cx2#,xd#,stay1#,stay2#
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf5-1,maschruf5c-1,
LOCAL j
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
cx=bx-cs
cx=cx/(ce-cs)*xm
'
IF hardcursor=FALSE THEN
~GRAF_MKSTATE(x,y,k,v4)
IF x>=cxd-16 AND x<=cxd+xmc+16 AND y>=ym1-16 AND y<=ym2+ymc+16 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
ENDIF
ENDIF
COLOR 1
GRAPHMODE 3
IF cx2<>-1 THEN
LINE cx2+xd,stay1,cx2+xd,stay2
drawnew=TRUE
ENDIF
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
LINE cx+xd,stay1,cx+xd,stay2
drawnew=TRUE
ENDIF
cx2=cx
COLOR 0
GRAPHMODE 1
IF hardcursor=FALSE THEN
~GRAF_MKSTATE(x,y,k,v4)
IF x>=cxd-16 AND x<=cxd+xmc+16 AND y>=ym1-16 AND y<=ym2+ymc+16 THEN
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ELSE
IF cx2<>-1 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
IF hardcursor=FALSE THEN
~GRAF_MKSTATE(x,y,k,v4)
IF x>=cxd-16 AND x<=cxd+xmc+16 AND y>=ym1-16 AND y<=ym2+ymc+16 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
ENDIF
ENDIF
COLOR 1
GRAPHMODE 3
LINE cx2+xd,stay1,cx2+xd,stay2
drawnew=TRUE
COLOR 0
GRAPHMODE 1
IF hardcursor=FALSE THEN
~GRAF_MKSTATE(x,y,k,v4)
IF x>=cxd-16 AND x<=cxd+xmc+16 AND y>=ym1-16 AND y<=ym2+ymc+16 THEN
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
cx2=-1
ENDIF
RETURN
'
> PROCEDURE intzeiger3
.| Glob. Var.: bx#,cs#,ce#,cx2#,xd#,stay1#,stay2#
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf5-1,maschruf5c-1,
LOCAL j
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF cx2<>-1 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE cx2+xd,stay1,cx2+xd,stay2
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
ENDIF
COLOR 0
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
IF cx2<>-1 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE cx2+xd,stay1,cx2+xd,stay2
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
COLOR 0
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
RETURN
'
> PROCEDURE drop
.| Glob. Var.: nob#
.| Ruft auf  : drop2
.| Aufruf in : rsc_do-1,
IF MENU(1)=10 THEN
nob=MENU(5)
@drop2
ENDIF
RETURN
'
> PROCEDURE editselect
~@xrsrc_gaddr(0,nr,zu%)
@wischwasch
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
@wischwasch
IF nr=smpedit& THEN
IF hrd=1 THEN
@setbutton(hard&,1)
ELSE
@setbutton(hard&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE editredraw
@wischwasch
@rsc_redraw_obj(nr,0)
@wischwasch
@curve(cs,ce)
@markprod3
@getcurve
RETURN
'
> PROCEDURE winbuttset
.| Glob. Var.: nr#,smpedit&,winh#,info&,infoicon&,peak&,peaksw2&,blkfunc&
.|     blocfunc&,loop&,loopart&,smp16&,edsmp16&,editfade&,edfade&,arranger&
.|     arrange&,trakker&,trak&
.| Ruft auf  : setbutton
.| Aufruf in : smpedit-1,
IF nr=smpedit& THEN
IF BTST(winh,info&)=TRUE THEN
@setbutton(infoicon&,1)
ENDIF
IF BTST(winh,peak&)=TRUE THEN
@setbutton(peaksw2&,1)
ENDIF
IF BTST(winh,blkfunc&)=TRUE THEN
@setbutton(blocfunc&,1)
ENDIF
IF BTST(winh,loop&)=TRUE THEN
@setbutton(loopart&,1)
ENDIF
IF BTST(winh,smp16&)=TRUE THEN
@setbutton(edsmp16&,1)
ENDIF
IF BTST(winh,editfade&)=TRUE THEN
@setbutton(edfade&,1)
ENDIF
IF BTST(winh,arranger&)=TRUE THEN
@setbutton(arrange&,1)
ENDIF
IF BTST(winh,trakker&)=TRUE THEN
@setbutton(trak&,1)
ENDIF
IF BTST(winh,dspedit&)=TRUE THEN
@setbutton(swdsp&,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE main
.| Glob. Var.: winh#,smp16&,rsc_window&,vornr#,nr#,menuda#,edsmp16&,g#
.|     smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,setbutton,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,smp16&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=smp16&
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@makehz
@sethertz
@fliphz2
@sourcein
ELSE
@setbutton(edsmp16&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=smp16&
IF vornr=smpedit& THEN
@setbutton2(edsmp16&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_main
.| Glob. Var.: smp16&,zu%,zuadr#,buttadr#,obj#,but#,dsp&,a$,popups&
.|     dsppopup&,popup&,rate2&,digana#,smppop2&,input&,inpop&,source&
.|     srcpop&,protect&,swdsp&,helporig&,exit&,winh#,nr#,smpedit&,edsmp16&
.|     nob#
.| Ruft auf  : xrsrc_gaddr,textfeld,dspoff,dspin,dspout,adlow,admid,adhigh
.|     ext32l,ext44l,ext48l,ext32h,ext44h,ext48h,ext256,ext384,analog
.|     digital,opto,coax,prot,setbutton,dspwahl,helptxt,restaura2b
.| Aufruf in : windows-1,
~@xrsrc_gaddr(0,smp16&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
IF but=22 THEN
IF obj=dsp& THEN
a$=@rsc_text$(popups&,dsppopup&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@dspoff
ENDIF
IF popup&=2 THEN
@dspin
ENDIF
IF popup&=3 THEN
@dspout
ENDIF
ENDIF
IF obj=rate2& AND digana=TRUE THEN
@testsrate
IF (retime=0 OR (retime=1 AND tstsr=FALSE)) THEN
a$=@rsc_text$(popups&,smppop2&+popup&)
@textfeld(obj,a$,1)
IF popup&<>0 THEN
IF popup&=1 THEN
@adlow
ENDIF
IF popup&=2 THEN
@admid
ENDIF
IF popup&=3 THEN
@adhigh
ENDIF
IF popup&=4 THEN
@admid96
ENDIF
IF popup&=5 THEN
@adhigh96
ENDIF
IF popup&=6 THEN
@ad8
ENDIF
IF popup&=7 THEN
@ad11
ENDIF
IF popup&=8 THEN
@ad12
ENDIF
IF popup&=9 THEN
@ad16
ENDIF
IF popup&=10 THEN
@ad17
ENDIF
IF popup&=11 THEN
@ad22
ENDIF
IF popup&=12 THEN
@ad24
ENDIF
IF popup&=13 THEN
@ad33
ENDIF
IF popup&=14 THEN
@adexth2
ENDIF
IF popup&=15 THEN
@adextl2
ENDIF
IF popup&=16 THEN
@adexth1
ENDIF
IF popup&=17 THEN
@adextl1
ENDIF
@kickstart
ENDIF
ENDIF
ENDIF
IF obj=input& THEN
a$=@rsc_text$(popups&,inpop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@analog
ENDIF
IF popup&=2 THEN
@digital
ENDIF
ENDIF
IF obj=source& THEN
a$=@rsc_text$(popups&,srcpop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@opto
ENDIF
IF popup&=2 THEN
@coax
ENDIF
IF popup&=3 THEN
@aesebu
ENDIF
ENDIF
IF obj=emphasis& THEN
a$=@rsc_text$(popups&,emphpop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@emphoff
ENDIF
IF popup&=2 THEN
@emphon
ENDIF
ENDIF
IF obj=mode& THEN
a$=@rsc_text$(popups&,modepop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@consumer
ENDIF
IF popup&=2 THEN
@profess
ENDIF
ENDIF
IF obj=protect& THEN
a$=@rsc_text$(popups&,popscms&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@scmsno
ENDIF
IF popup&=2 THEN
@scmsone
ENDIF
IF popup&=3 THEN
@scmsfree
ENDIF
ENDIF
ENDIF
IF obj=bridge& THEN
@digibridge
ENDIF
IF obj=helporig& THEN
@helptxt("EINSTELLUNGEN")
ENDIF
IF obj=exit& OR obj=9999 THEN
winh=BCLR(winh,smp16&)
@setbutton(exit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(edsmp16&,0)
ENDIF
@sethertz
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
nob=0
RETURN
'
> PROCEDURE windows
.| Glob. Var.: menuda#,obj#,nr#,popup&,info&,dspedit&,arranger&,trakker&
.|     loop&,peak&,blkfunc&,smp16&,smpedit&,smpexit&,g#
.| Ruft auf  : rsc_menu_ienable,rsc_do,do_info,do_dsp,do_arrange,do_trakker
.|     do_loop,do_peak,do_blkf,do_main,maketime,do_smpedit,goodbye
.| Aufruf in : smpedit-1,
REPEAT
REPEAT
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
obj=@rsc_do(nr,obj,popup&)
IF obj<>0 AND nr=peak& THEN
@do_peak
obj=0
ENDIF
IF peakmrk=peak& AND nr<>peak& THEN
@write_int(0)
ENDIF
IF obj<>0 AND nr=info& THEN
@do_info
obj=0
ENDIF
IF obj<>0 AND nr=wmode& THEN
IF obj=-1 OR obj=synchz& OR obj=smpteset& OR obj=syncsrte& THEN
'          edit_obj&=0
'          obj=0
ELSE
@do_workmode
obj=0
ENDIF
ENDIF
IF obj<>0 AND nr=dspedit& THEN
@do_dsp
obj=0
ENDIF
IF obj<>0 AND nr=editfade& THEN
@do_fade
obj=0
ENDIF
IF obj<>0 AND nr=arranger& THEN
@do_arrange
obj=0
ENDIF
IF obj<>0 AND nr=trakker& THEN
@do_trakker
obj=0
ENDIF
IF obj<>0 AND nr=loop& THEN
@do_loop
obj=0
ENDIF
IF obj<>0 AND nr=blkfunc& THEN
@do_blkf
obj=0
ENDIF
IF obj<>0 AND nr=smp16& THEN
@do_main
obj=0
ENDIF
IF obj<>0 AND nr=plugin& THEN
@do_plugin
obj=0
ENDIF
IF obj<>0 AND nr=smpedit& THEN
@maketime
@do_smpedit
IF obj<>9999 AND obj<>smpexit& THEN
obj=0
ENDIF
ENDIF
~FRE(0)
IF nr=smpedit& AND ldtrk=TRUE AND (obj=smpexit& OR obj=9999) THEN
IF startup=TRUE THEN
trkstrt(trkp)=loops%(sms,1)
trkend(trkp)=loops%(sms,2)
IF virtual=TRUE THEN
@trashvirt
ENDIF
@killedit
nr=trakker&
@editselect
'
~XBIOS(xbs,27,0)
IF pch4=TRUE OR pmo8=TRUE THEN
~XBIOS(&H8B,0,2,0,clk,1)
~XBIOS(&H8B,3,11,0,clk,1)
ENDIF
IF pmo8=TRUE THEN
~XBIOS(xbs,72,14)
ENDIF
'
obj=0
ldtrk=FALSE
ldtrk3=FALSE
hsec=INT(trkstrt(trkp)/thz/mbit*100)
@htimeset
@textfeld(trakstrt&,a$,1)
hsec=INT(trkend(trkp)/thz/mbit*100)
@htimeset
@textfeld(trakend&,a$,1)
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz/mbit*100)
@htimeset
@textfeld(trakdur&,a$,1)
@setbutton(trakend&,0)
GRAPHMODE 1
@timeline
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
IF obj=9999 AND nr=smpedit& AND ldtrk=FALSE THEN
leaveprog=TRUE
ENDIF
UNTIL leaveprog=TRUE AND (nr=smpedit& AND ldtrk=FALSE AND (obj=smpexit& OR obj=9999))
@alerts(99)
IF g=1 THEN
@write_int(0)
@goodbye
ELSE
leaveprog=FALSE
ENDIF
obj=0
UNTIL g=1
RETURN
'
> PROCEDURE winhandler
LOCAL flags&,evnt&,key&,tim&,flags&,mx,my,mb
tim&=1   ! EVENT-TIMER in msec
flags&=&X110011                                      ! ...zus. MESSAGE-Events
evnt&=EVNT_MULTI(&X110011,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mb,shift&,key&,c)
IF BTST(evnt&,4) THEN
@message
@drop
@markhlp
ENDIF
IF BTST(evnt&,1) THEN
@button
'    @windows
ENDIF
RETURN
'
> PROCEDURE goodbye
.| Glob. Var.: demo#,peakint#,i#,winh#
.| Ruft auf  : rsc_back,rsc_exit,xrsrc_exit,exit
.| Aufruf in : drop2-1,windows-1,fehler-1,
CLOSE
IF demo=FALSE THEN
IF XBIOS(xbs,1)=&H71273800 THEN
peakint=FALSE
@write_int(0)
ENDIF
ENDIF
IF rscda=TRUE AND windowda=TRUE THEN
FOR i=31 TO 0 STEP -1
IF BTST(winh,i)=TRUE THEN
@rsc_back(i)
ENDIF
NEXT i
ENDIF
GEMSYS 109                                        ! Nur ab GEM 1.04!
'
IF rscda=TRUE THEN
@rsc_exit
ENDIF
IF xload=TRUE THEN
~@xrsrc_free    ! gibt RSC frei
exit_xrsrc      ! beendet xrsrc-Routinen
ENDIF
' hier eventuell noch AufrÑumaktionen von Libs/Routinen
' einfÅgen, die vor den XRSRC-/Mydial-Routinen gestartet werden
'
@exit
RESERVE         ! Reservierung lîschen
IF accx=FALSE THEN
END
ENDIF
RETURN
'
> PROCEDURE memfeld(memolen,grenz)
.| Glob. Var.: mem$,nr#,smp16&,smpedit&
.| Aufruf in : fnamwrite-1,smplen-1,smpplay-1,record3-1,
LOCAL a,b
b=memolen
a=LEN(STR$(b))
IF a>6 THEN
b=INT(b/1024)
ENDIF
mem$=STR$(b)
IF nr=smp16& THEN
IF a>6 THEN
mem$=mem$+" KB used"+CHR$(0)
ELSE
mem$=mem$+" Bytes used"+CHR$(0)
ENDIF
ENDIF
IF nr=smpedit& THEN
IF a>6 THEN
mem$="LEN "+mem$+" KB"+CHR$(0)
ELSE
mem$="LEN "+mem$+" BYTES"+CHR$(0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE secfeld(seclen,grenz)
.| Glob. Var.: sec$,nr#,smpedit&
.| Aufruf in : fnamwrite-1,smpsec-1,do_blkf-1,smpplay-1,record3-1,
IF nr=smpedit& THEN
hsec=INT(seclen*100)
@htimeset
sec$="= "+a$+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE fnamwrite
.| Glob. Var.: nr#,smpedit&,smpfile&,smpnam$,smplen#,smplen&,mem$,sec#,hz#
.|     smpsec&,sec$
.| Ruft auf  : textfeld,memfeld,secfeld,smpfree
.| Aufruf in : smplen-1,smpsec-1,smpsave-1,smpload-1,ldhlp-1,smpedit-1
.|     do_smpedit-11,rebuild-1,markdel-1,setup2-1,memtovirt-1,memtovirt2-1
.|     smpplay-1,record2-1,record4-1,
IF nr=smpedit& THEN
@textfeld(smpfile&,smpnam$+CHR$(0),1)
@memfeld(smplen,8)
@textfeld(smplen&,mem$,1)
sec=smplen/(hz*mbit)
@secfeld(sec,8)
@textfeld(smpsec&,sec$,1)
@smpfree
ENDIF
RETURN
'
> PROCEDURE smpfree
.| Glob. Var.: lfw$,op$,smpname&
.| Ruft auf  : textfeld
.| Aufruf in : fnamwrite-1,setupdat-1,
LOCAL a$,a
a=ASC(LEFT$(lfw$,1))-64
a=INT(DFREE(a)/1024)
a$=LEFT$(lfw$,2)+STR$(a)+"K  "
a=ASC(LEFT$(op$,1))-64
a=INT(DFREE(a)/1024)
a$=a$+LEFT$(op$,2)+STR$(a)+"K"
IF LEN(a$)>20 THEN
a$=LEFT$(a$,20)
ENDIF
a$=a$+CHR$(0)
@textfeld(smpname&,a$,1)
RETURN
'
> PROCEDURE smplen
.| Glob. Var.: mlen#,mem$,smplen&
.| Ruft auf  : memfeld,textfeld,fnamwrite,setbutton
.| Aufruf in : do_smpedit-1,
@memfeld(mlen,8)
mem$="MAX"+RIGHT$(mem$,LEN(mem$)-3)
@textfeld(smplen&,mem$,1)
PAUSE 100
@fnamwrite
@setbutton(smplen&,0)
RETURN
'
> PROCEDURE smpsec
.| Glob. Var.: mlen#,hz#,sec$,smpsec&
.| Ruft auf  : secfeld,textfeld,fnamwrite,setbutton
.| Aufruf in : do_smpedit-1,
LOCAL s
s=(mlen/(hz*mbit))
hsec=INT(s*100)
@htimeset
sec$="MAX "+a$+CHR$(0)
@textfeld(smpsec&,sec$,1)
PAUSE 100
@fnamwrite
@setbutton(smpsec&,0)
RETURN
'
> PROCEDURE selblkstxt(i,a$)        ! Zeit in Marker schreiben
SELECT i
CASE 1
@textfeld(edmtims&,a$,1)
CASE 2
@textfeld(edmtime&,a$,1)
CASE 3
@textfeld(edmtimi&,a$,1)
CASE 4
@textfeld(edmtimr&,a$,1)
ENDSELECT
RETURN
'
> PROCEDURE selblkshak(i,b)     ! Marker auswÑhlen
.| Glob. Var.: hacksa&,hacksb&,hacksc&,hacksd&,hackse&,hackss&
.| Aufruf in : markprod3-1,smpstx-1,smpsts-1,smph3-1,
LOCAL a
SELECT i
CASE 1
a=edmbuts&
@setbutton(a,b)
CASE 2
a=edmbute&
@setbutton(a,b)
CASE 3
a=edmbuti&
@setbutton(a,b)
CASE 4
a=edmbutr&
@setbutton(a,b)
ENDSELECT
RETURN
'
> PROCEDURE helptxt(search$)        ! Hilfstexte von 1st Guide aktivieren
'
' Der Pfad der IDX-Datei muû vorher im 1stGuide Konfigurationsdialog eingegeben werden !!!
'
LOCAL g,hlpfound,t,a,hobj,vfly
msg_id=APPL_FIND("1STGUIDE")
IF msg_id<>-1 THEN
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=s$+"1STGUIDE.IDX"
ENDIF
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=op$+"1STGUIDE.IDX"
ENDIF
IF EXIST(hpath$)=FALSE THEN
hlpfound=FALSE
'    ~GRAF_MOUSE(256,0)                              ! Hidem
'    ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
'   ~GRAF_MOUSE(257,0)                              ! Showm
@fileselect(op$+"*.IDX","1STGUIDE.IDX","Search 1STGUIDE.IDX:")
'   @rsc_put(ab,rscx&(nr),rscy&(nr),1)
IF ordner$<>"" AND pret<>0 AND pbutt=1 THEN
hpath$=ordner$+"1STGUIDE.IDX"
IF EXIST(hpath$)=TRUE THEN
hlpfound=TRUE
ENDIF
ENDIF
ELSE
hlpfound=TRUE
ENDIF
IF hlpfound=TRUE THEN
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
normd=FALSE
IF rsc_handle%(nr)>1000                             ! Normaler Dialog...
normd=TRUE
ndnr=nr
@rsc_back(nr)
ENDIF
'
hpath$=hpath$+CHR$(0)
@appl_write(msg_id,&H4711,0,0,0,0,0,hpath$)    ! VA_START
accwindopen=FALSE
ON MENU MESSAGE GOSUB message
t=TIMER
REPEAT
ON MENU
UNTIL accwindopen=TRUE OR (TIMER-t)>400
@wischwasch
search$=search$+CHR$(0)
a=1025
accwindopen=FALSE
@appl_write(msg_id,a,0,0,0,0,0,search$)                           ! AC_HELP
ON MENU MESSAGE GOSUB message
t=TIMER
REPEAT
ON MENU
UNTIL accwindopen=TRUE OR (TIMER-t)>400
@wischwasch
IF normd=TRUE THEN                            ! Normaler Dialog...
IF rsc_handle%(vornr)<1000                  ! FensterDialog...
IF ndnr=trkcomin& THEN
nr=vorvornr
@editselect
ENDIF
nr=vornr
@editselect
ENDIF
nr=ndnr
@rsc_draw(nr,0)
ENDIF
ELSE
'
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
ENDIF
ELSE
'
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
@wischwasch
@readbutton(obj)
hobj=obj
vfly=fly
fly=TRUE
edit_obj&=0
@alerts(12)
fly=vfly
obj=hobj
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
ENDIF
RETURN
'
> PROCEDURE markhlp
.| Glob. Var.: nr#,handle&,ax&,ay&,ab&,ah&,xd#,yd#,xm#,ym#,sline#,stay1#
.|     ym1#,ym2#,stay2#,dazu#
.| Felder    : rsc_handle%()
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,message-1,normalize-1
.|     fadehandler-1,fade-1,fadelinear-1,fadesquare-1,fadexp-1,fadesqrt-1
.|     fadelog-1,infade-1,ausfade-1,smptime-2,smpkhlp-1,smpmhlp-1,smpihlp-1
.|     zoomhelp-1,smpl-1,smpr-2,smpcut-1,movefrag-1,edhandler2-1,blkstest-1
.|     smpsave-5,blklfrag-2,newfsel-1,blkltest-1,ldhlp-6,sampleinf-1
.|     curve-1,resample-1,slideupdate-1,slidelr-1,dragging1-1,dragging2-1
.|     arrdelay-1,arrmname-1,write-1,smpedit-1,blkfunc-1,time_edit-1,make-1
.|     info-1,trash-2,setupdat-1,smpstx-1,smpsts-1,smpex-1,smpes-1
.|     markhlp6-1,setup-1,conspace-2,midi-1,loopwahl-1,dspwahl-1,peak-1
.|     do_peak-2,peakread2-1,
IF rsc_handle%(nr)<1001                             ! Normaler Dialog...
handle&=rsc_handle%(nr)                         ! Fensterhandle des Dialogs
~WIND_GET(handle&,4,ax&,ay&,ab&,ah&)          ! 1. Rechteck
xd=ax&+24+8           ! X-Locator
yd=ay&+14           ! Y-Locator
dazu=yd+222         ! Y-Locator fÅr Fade
IF bigfoot=FALSE THEN
xm=594              ! Breite der Box
ym=76               ! Hîhe der Box
stay1=yd+24         ! Anfang der Markline
stay2=yd+195        ! Ende der Markline
ELSE
@calc_editboxes1
'
'
'      xm=952             ! Breite der Box
'      ym=206             ! Hîhe der Box
'      stay1=yd+24+8        ! Anfang der Markline
'      stay2=yd+447+8       ! Ende der Markline
ENDIF
ENDIF
RETURN
'
> PROCEDURE calc_editboxes1
IF nr=smpedit& THEN
@buttbh(editbox4&,xm,ym)
stay1=yd+24+8        ! Anfang der Markline
stay2=stay1+11+ym*2-3
xm=xm-2
ym=ym-3
ENDIF
RETURN
'
> PROCEDURE calc_editboxes2
LOCAL v
IF nr=smpedit& THEN
@buttbh(editbox4&,v,ym2)
ym1=ay&+41+8          ! Y-Locator erste Box
ym2=ym2+ym1+3         ! Y-Locator zweite Box
ENDIF
RETURN
'
> PROCEDURE calc_trakboxes
LOCAL bb3,v
IF nr=trakker& THEN
@buttbh(trakbox2&,trboxl,trboxh)
@buttbh(trkbx1&,bb3,v)
trxstp=(trboxl-bb3-2)/10   ! Pixelabstand pro Zeiteinheits-Teilung der X-Achse
trboxl=trboxl-bb3+2
ENDIF
RETURN
'
> PROCEDURE markhlp2
.| Glob. Var.: cs#,xd#,stay1#,stay2#,t$
.| Aufruf in : smpstx-1,smpsts-1,smpex-1,smpes-1,
IF cs=0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE xd,stay1,xd,stay2
DEFTEXT 1,0,0,4
TEXT xd-2,stay1-1,t$
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
ENDIF
RETURN
'
> PROCEDURE markhlp3(i,i2,stxnr)
LOCAL sc,sc$,s,a$
IF tedart=0 THEN
hsec=INT(stxnr/hz/mbit*100)
@htimeset
sc$=a$
ELSE
sc=INT(stxnr/mbit)
a$=STR$(sc)
@formatsmp
a$=sc$
IF LEN(sc$)>13 THEN
sc$=LEFT$(sc$,13)
ENDIF
sc$=sc$+CHR$(0)
ENDIF
IF i>0 AND i<=loopz THEN
@selblkstxt(i2,sc$)
ENDIF
IF i=9998 THEN
@textfeld(cstxt&,sc$,1)
ENDIF
IF i=9999 THEN
@textfeld(cetxt&,sc$,1)
ENDIF
RETURN
'
> PROCEDURE markhlp8(i,i2,bx)
.| Glob. Var.: cs#,ce#,cx#,xm#,xd#,stay1#,stay2#,loopz#
.| Ruft auf  : selblkstxt,selblketxt
.| Aufruf in : smph3-2,
LOCAL j
IF i>0 AND i<=loopz THEN
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
LINE cx+xd,stay1,cx+xd,stay2
COLOR smpwcol
GRAPHMODE 1
FOR j=xd+cx-3 TO xd+cx+3
LINE j,stay1,j,stay1-5
NEXT j
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
@selblkstxt(i2,CHR$(0))
ENDIF
RETURN
'
> PROCEDURE normalize
.| Glob. Var.: makecurve#,vorvornr#,vornr#,nr#,normaliz&,normadj&,normauto&
.|     norma#,obj#,popup&,zu%,zuadr#,x#,y#,v#,buttadr#,but#,norml1&,norml2&
.|     norml3&,normr1&,normr2&,normr3&,objadr#,objflag#,helpnorm&,normok&
.|     normexit&,norm&
.| Ruft auf  : rsc_draw,markhlp,setbutton,normtest,rsc_do,xrsrc_gaddr,mouse
.|     norml,normr,helptxt,normauto,normadj,rsc_back,blkrestaura
.| Aufruf in : do_blkf-1,
makecurve=0
vorvornr=vornr
vornr=nr
nr=normaliz&
IF norma=1 THEN
@hidetree2(normbox3&,TRUE)
ENDIF
@rsc_draw(nr,0)
@markhlp
IF norma=0 THEN
@setbutton(normauto&,0)
@setbutton(normadj&,1)
db$=STR$(db)+CHR$(0)
ELSE
@setbutton(normadj&,0)
@setbutton(normauto&,1)
db$=STR$(0)+CHR$(0)
ENDIF
@textfeld(normdb&,db$,1)
@normtest
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
IF obj=norml1& OR obj=norml2& OR obj=norml3& OR obj=normr1& OR obj=normr2& OR obj=normr3& THEN
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=norml1& OR obj=norml2& OR obj=norml3& THEN
@norml
ENDIF
IF obj=normr1& OR obj=normr2& OR obj=normr3& THEN
@normr
ENDIF
IF obj=normauto& THEN
norma=1
db$=STR$(0)+CHR$(0)
@textfeld(normdb&,db$,1)
@hidetree(normbox3&,TRUE,normbox&)
ENDIF
IF obj=normadj& THEN
norma=0
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
@hidetree(normbox3&,FALSE,normbox&)
ENDIF
IF obj=helpnorm& THEN
@helptxt("OPTIMIZE")
ENDIF
UNTIL obj=normok& OR obj=normexit&
nr=normaliz&
@setbutton(obj,0)
@rsc_back(nr)
IF obj=normok& THEN
nr=smpedit&
@editselect
IF norma=1 THEN
@normauto
ENDIF
IF norma=0 THEN
@normadj
ENDIF
ENDIF
nr=blkfunc&
@blkrestaura
@setbutton(norm&,0)
vornr=vorvornr
obj=0
RETURN
'
> PROCEDURE fadehandler
.| Glob. Var.: x#,y#,k#,yd#,yma#,dazu#,xd#,fxl#,xm#,ym#,fadericht#,fadnr#,i#
.|     v3#,nr#,buttadr#,zuadr#,obj#,but#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : markhlp,mouse,mousek,rsc_redraw_obj
.| Aufruf in : rsc_do-1,
IF cupdate=FALSE THEN
@windowtest
IF mywindow=TRUE THEN
@markhlp
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
@mouse(x,y,k)
IF y>=yd AND y<=(yd+225) AND x>=(xd+fxl) AND x<=(xd+242) AND k=1 THEN
@clsfade
GRAPHMODE 1
yma=dazu
IF x<xd+fxl THEN
x=xd+fxl
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
LINE x,y,x,y
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
xm=x
ym=y
IF fadericht=1 THEN
IF xm>xd+10 THEN
xm=xd+10
ENDIF
ENDIF
REPEAT
@mouse(x,y,k)
IF fadericht=0 THEN
IF x>=xm AND x>xd+fxl-1 AND x<xd+fxl+fadnr-1 THEN
IF y>ym THEN
y=ym
ENDIF
IF y<yd THEN
y=yd
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
LINE xm,ym,x,y
FOR i=xm TO x
LINE i,yma,i,y
fadeni(i-xd-fxl)=fadnr-(y-yd)
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
xm=x
ym=y
ENDIF
ELSE
IF x>=xm AND x>xd+fxl-1 AND x<xd+fxl+fadnr-1 THEN
IF ym>y THEN
y=ym
ENDIF
IF y>dazu THEN
y=dazu
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
LINE xm,ym,x,y
FOR i=xm TO x
LINE i,yma,i,y
fadeno(i-xd-fxl)=fadnr-(y-yd)
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
xm=x
ym=y
ENDIF
ENDIF
v3=@mousek
UNTIL v3=0
@getfade
drawnew=TRUE
IF x<xd+fxl+fadnr-1 THEN
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE fade
IF BTST(winh,editfade&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=editfade&
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
'
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
fxl=-14   ! Linke Kante-X Fadefenster
GRAPHMODE 1
~@xrsrc_gaddr(0,nr,zu%)
boxadr=zu%
@markhlp
CLIP 0,0,xwidth,ywidth
'  tree&=nr
IF fadericht=0 THEN
@setbutton(infade&,33)
ELSE
@setbutton(ausfade&,33)
ENDIF
yma=dazu
FOR i=1 TO fadnr
bfadeni(i)=fadeni(i)
bfadeno(i)=fadeno(i)
NEXT i
FOR i=1 TO fadnr
IF fadericht=0 THEN
a=fadeni(i)/fadnr*(dazu-yd)
y=dazu-a
ELSE
a=fadeno(i)/fadnr*(dazu-yd)
y=dazu-a
ENDIF
IF a<>0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
LINE i+xd+fxl,yma,i+xd+fxl,y
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
ENDIF
NEXT i
'
@getfade
CLIP OFF
ELSE
@setbutton(edfade&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=editfade&
IF vornr=smpedit& THEN
@setbutton2(edfade&,1,vornr)
ENDIF
'    tree&=nr
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_fade
fxl=-14   ! Linke Kante-X Fadefenster
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
IF obj=helpfade& THEN
@helptxt("FADE-EDITOR")
ENDIF
IF obj=infade& THEN
@infade
ENDIF
IF obj=ausfade& THEN
@ausfade
ENDIF
IF obj=fadelin& THEN
@fadelinear
ENDIF
IF obj=fadexp& THEN
@fadexp
ENDIF
IF obj=fadesqrt& THEN
@fadesqrt
ENDIF
IF obj=fadedel& THEN
@fadedel
ENDIF
IF obj=fdsquare& THEN
@fadesquare
ENDIF
IF obj=fadelog& THEN
@fadelog
ENDIF
IF obj=fadload& THEN
@fadeload
ENDIF
IF obj=fadsave& THEN
@fadesave
ENDIF
IF obj=fadexit& OR obj=fadeundo& OR obj=infade& OR obj=ausfade& THEN
aw=FORM_BUTTON(boxadr,obj,1,a)
REPEAT
UNTIL @mousek=0
ELSE
IF obj<>9999 THEN
@setbutton(obj,1)
PAUSE 1
@setbutton(obj,0)
ENDIF
ENDIF
IF obj=fadexit& THEN
@setbutton(obj,0)
ENDIF
IF obj=fadeundo& THEN
@setbutton(obj,0)
IF fadericht=0 THEN
FOR i=1 TO fadnr
fadeni(i)=bfadeni(i)
NEXT i
@infade
ELSE
FOR i=1 TO fadnr
fadeno(i)=bfadeno(i)
NEXT i
@ausfade
ENDIF
ENDIF
IF obj=fadexit& OR obj=9999 THEN
winh=BCLR(winh,nr)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(edfade&,0)
ENDIF
ENDIF
GRAPHMODE 3
RETURN
'
> PROCEDURE getfade
LOCAL x,y,b,h
IF nr=editfade& THEN
IF windcache=TRUE THEN
@windowtest
@markhlp
IF bigfoot=FALSE THEN
x=ax&+23-1          ! X-Locator
y=ay&+41-8          ! Y-Locator erste Box
ELSE
x=ax&+24-8          ! X-Locator
y=ay&+41-28          ! Y-Locator erste Box
ENDIF
b=248              ! Breite der Box
h=224              ! Hîhe der Box
lmfade=b*h*planes&/8
~GRAF_MOUSE(256,0)                              ! Hidem
IF shading=FALSE THEN
IF firstfade=0 THEN
memfade=@rsc_get(x,y,b,h)
firstfade=1
ELSE
memfade=@rsc_get2(x,y,b,h,memfade)
ENDIF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
IF ((x+b)>xwidth OR (y+h)>ywidth) THEN
drawnew3=TRUE
ENDIF
ELSE
drawnew3=TRUE
ENDIF
ENDIF
RETURN
'
> PROCEDURE putfsize
IF bigfoot=FALSE THEN
x=ax&+23-1          ! X-Locator
y=ay&+41-8          ! Y-Locator erste Box
ELSE
x=ax&+24-8          ! X-Locator
y=ay&+41-28          ! Y-Locator erste Box
ENDIF
b=248              ! Breite der Box
h=224              ! Hîhe der Box
IF nr=editfade& THEN
IF (x+b)>xwidth OR (y+h)>ywidth THEN
drawnew3=TRUE
ELSE
IF drawnew3=TRUE THEN
credraw=TRUE
IF fadericht=0 THEN
@infade
ELSE
@ausfade
ENDIF
credraw=FALSE
@getfade
ENDIF
drawnew3=FALSE
ENDIF
ELSE
drawnew3=FALSE
ENDIF
RETURN
'
> PROCEDURE putfade
LOCAL x,y,b,h
IF nr=editfade& THEN
IF windcache=TRUE THEN
@windowtest
@markhlp
IF bigfoot=FALSE THEN
x=ax&+23-1          ! X-Locator
y=ay&+41-8          ! Y-Locator erste Box
ELSE
x=ax&+24-8          ! X-Locator
y=ay&+41-28          ! Y-Locator erste Box
ENDIF
b=248              ! Breite der Box
h=224              ! Hîhe der Box
IF (x1+b1)>=x AND x1<=x+b AND (y1+h1)>=y AND y1<=y+h THEN
mx=x1
my=y1
mx1=x1-x
my1=y1-y
IF x1<x THEN
mx1=0
mx=x
ENDIF
IF y1<y THEN
my1=0
my=y
ENDIF
mb1=b1
mh1=h1
IF x1<x THEN
mb1=(x1+b1)-x
ENDIF
IF y1<y THEN
mh1=(y1+h1)-y
ENDIF
IF mb1>b THEN
mb1=b
ENDIF
IF mh1>h THEN
mh1=h
ENDIF
IF mx+mb1>x+b THEN
mb1=(x+b)-mx
ENDIF
IF my+mh1>y+h THEN
mh1=(y+h)-my
ENDIF
'
IF mx+mb1>xwidth THEN
mb1=xwidth-mx
ENDIF
IF my+mh1>ywidth THEN
mh1=ywidth-my
ENDIF
IF mx>=x AND my>=y AND mx1>=0 AND my1>=0 AND mb1>0 AND mh1>0 THEN
IF shading=FALSE THEN
~GRAF_MOUSE(256,0)                              ! Hidem
@rsc_putblock(memfade,mx,my,mx1,my1,mb1,mh1)
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
ENDIF
ELSE
drawnew3=TRUE
ENDIF
ENDIF
RETURN
'
> PROCEDURE clsfade
.| Glob. Var.: nr#
.| Ruft auf  : rsc_redraw_obj
.| Aufruf in : fadelinear-1,fadesquare-1,fadexp-1,fadesqrt-1,fadelog-1
.|     infade-1,ausfade-1,
IF nr=editfade& THEN
'  @markhlp
'  COLOR 0
'  GRAPHMODE 1
'  PBOX xd+fxl,dazu-fadnr+24,xd+fxl+fadnr,dazu
'  COLOR 1
IF cupdate=FALSE THEN
@rsc_redraw_obj(nr,0)
@getfade
ENDIF
ENDIF
RETURN
'
> PROCEDURE fadelinear
.| Glob. Var.: fadericht#,ym#,dazu#,y#,i#,fadnr#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL i
@clsfade
GRAPHMODE 1
@markhlp
CLIP 0,0,xwidth,ywidth
IF fadericht=0 THEN
fadewin=0
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
FOR i=1 TO fadnr
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
fadeni(i)=y
y=y+1
drawnew=TRUE
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=0
ym=dazu
y=fadnr-1
~GRAF_MOUSE(256,0)                              ! Hidem
FOR i=1 TO fadnr
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
fadeno(i)=y
y=y-1
drawnew=TRUE
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
@getfade
CLIP OFF
RETURN
'
> PROCEDURE fadesquare
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
c=SQR(fadnr)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
CLIP 0,0,xwidth,ywidth
IF fadericht=0 THEN
fadewin=1
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=teil
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=b
fadeni(i)=y
a=a+teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=1
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=b
fadeno(i)=y
a=a-teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
@getfade
CLIP OFF
RETURN
'
> PROCEDURE fadexp
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
d=8
c=LOG(fadnr*d)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
CLIP 0,0,xwidth,ywidth
IF fadericht=0 THEN
fadewin=2
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=0
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=b
fadeni(i)=y
a=a+teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=2
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=b
fadeno(i)=y
a=a-teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
@getfade
CLIP OFF
RETURN
'
> PROCEDURE fadesqrt
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
c=SQR(fadnr)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
CLIP 0,0,xwidth,ywidth
IF fadericht=0 THEN
fadewin=3
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=fadnr-b
fadeni(i)=y
a=a-teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=3
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=0
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=fadnr-b
fadeno(i)=y
a=a+teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
@getfade
CLIP OFF
RETURN
'
> PROCEDURE fadelog
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
d=8
c=LOG(fadnr*d)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
CLIP 0,0,xwidth,ywidth
IF fadericht=0 THEN
fadewin=4
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=fadnr-b
fadeni(i)=y
a=a-teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=4
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=0
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+xd+fxl,ym,i+xd+fxl,ym-(y/fadnr*(dazu-yd))
ENDIF
y=fadnr-b
fadeno(i)=y
a=a+teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
@getfade
CLIP OFF
RETURN
'
> PROCEDURE setlinear
.| Glob. Var.: y#,i#,fadnr#
.| Felder    : fadeni#(),fadeno#()
.| Aufruf in : fadeset-1,
y=0
FOR i=1 TO fadnr
fadeni(i)=y
y=y+1
NEXT i
y=fadnr
FOR i=1 TO fadnr
fadeno(i)=y
y=y-1
NEXT i
RETURN
'
> PROCEDURE infade
.| Glob. Var.: fadericht#,ausfade&,infade&,yma#,dazu#,i#,fadnr#,a#,yd#,y#
.|     xd#,fxl#
.| Felder    : fadeni#()
.| Ruft auf  : markhlp,clsfade,setbutton
.| Aufruf in : fade-1,fadesave-1,fadeload-1,
LOCAL i
@markhlp
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
fadericht=0
GRAPHMODE 1
IF nr=editfade& AND cupdate=FALSE THEN
@clsfade
@setbutton(ausfade&,0)
@setbutton(infade&,1)
ENDIF
yma=dazu
'  IF nr=editfade& THEN
~GRAF_MOUSE(256,0)                              ! Hidem
' ENDIF
FOR i=1 TO fadnr
a=fadeni(i)/fadnr*(dazu-yd)
y=dazu-a
IF a<>0 AND nr=editfade& THEN
LINE i+xd+fxl,yma,i+xd+fxl,y
ENDIF
NEXT i
drawnew=TRUE
'  IF nr=editfade& THEN
~GRAF_MOUSE(257,0)                              ! Showm
' ENDIF
@getfade
IF credraw=FALSE THEN
CLIP OFF
ENDIF
RETURN
'
> PROCEDURE ausfade
.| Glob. Var.: fadericht#,infade&,ausfade&,yma#,dazu#,i#,fadnr#,a#,yd#,y#
.|     xd#,fxl#
.| Felder    : fadeno#()
.| Ruft auf  : markhlp,clsfade,setbutton
.| Aufruf in : fade-1,fadesave-1,fadeload-1,
LOCAL i
@markhlp
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
fadericht=1
GRAPHMODE 1
IF nr=editfade& AND cupdate=FALSE THEN
@clsfade
@setbutton(infade&,0)
@setbutton(ausfade&,1)
ENDIF
yma=dazu
'  IF nr=editfade& THEN
~GRAF_MOUSE(256,0)                              ! Hidem
' ENDIF
FOR i=1 TO fadnr
a=fadeno(i)/fadnr*(dazu-yd)
y=dazu-a
IF a<>0 AND nr=editfade& THEN
LINE i+xd+fxl,yma,i+xd+fxl,y
ENDIF
NEXT i
drawnew=TRUE
'  IF nr=editfade& THEN
~GRAF_MOUSE(257,0)                              ! Showm
' ENDIF
@getfade
IF credraw=FALSE THEN
CLIP OFF
ENDIF
RETURN
'
> PROCEDURE fadedel
.| Glob. Var.: i#,fadnr#,fadericht#,nr#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : rsc_redraw_obj
.| Aufruf in : fade-1,
FOR i=1 TO fadnr
IF fadericht=0 THEN
fadeni(i)=0
ELSE
fadeno(i)=0
ENDIF
NEXT i
@rsc_redraw_obj(nr,0)
@getfade
RETURN
'
> PROCEDURE fade_it
.| Glob. Var.: sblock#,b1#,c1#,b2#,c2#,mlen#,sms#,sme#,fadericht#,a1#,a2#
.|     vmem#,virtual#,okay#,virtwfile#,virtpath$,a#,virtln#,virtp$,virtfile$
.|     vln#,bytes#,e#,meml#,e2#,i#,fadnr#,mdat3%,c#,back%,g#,cached#,path$
.|     smpnam$,noblkdel#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : blocklook,busy_mouse,maschinit31,maschruf31b,maschinit32
.|     maschruf32,maschinit30,maschruf30,restaura,hardproof3,memtovirt2
.|     nomem
.| Aufruf in : smpl-1,smpr-1,
LOCAL teil
teil=1024
IF sblock=1 THEN
@blocklook
b1=INT(c1/mbit)*mbit
b2=INT(c2/mbit)*mbit
ELSE
b1=0
b2=INT(mlen/mbit)*mbit
ENDIF
IF sblock=0 OR (sblock=1 AND c1<c2 AND c1>=0 AND c2>0 AND sms<>0) THEN
IF fadericht=1 THEN
a1=b1
a2=b1+teil
IF a2>vmem THEN
a1=b1-teil
a2=b1
ENDIF
IF a1<0 THEN
a1=0
IF (a2-a1)<teil THEN
a2=teil
ENDIF
ENDIF
ENDIF
IF fadericht=0 THEN
a1=b2-teil
a2=b2
IF a1<0 THEN
a1=b2
a2=b2+teil
ENDIF
IF a2>vmem THEN
a2=vmem
IF (a2-a1)<teil THEN
a1=vmem-teil
ENDIF
ENDIF
ENDIF
IF virtual=FALSE OR (virtual=TRUE AND c2-c1<=mlen) THEN
IF virtual=TRUE THEN
okay=FALSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
SEEK #1,a1
vln=a2-a1
bytes=INT(mlen/mbit)*mbit
e=0
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ENDIF
IF e=0 AND sblock=1 THEN
e=16384
ENDIF
IF e<>0 AND sblock=1 THEN
FOR i=1 TO fadnr
IF fadericht=0 THEN
DPOKE mdat3%+i*2-2,INT(65535/fadnr*fadeni(i))
ELSE
DPOKE mdat3%+i*2-2,INT(65535/fadnr*fadeno(i))
ENDIF
NEXT i
IF virtual=FALSE THEN
IF fadericht=0 THEN
c=0
@maschruf32(b1,b2,c)
IF back%<>-1 THEN
b1=back%
ENDIF
ENDIF
IF fadericht=1 THEN
c=1
@maschruf32(b1,b2,c)
IF back%<>-1 THEN
b2=back%
ENDIF
ENDIF
@maschruf30(mdat3%,fadnr,b1,b2)
ELSE
IF okay=TRUE THEN
SEEK #1,b1
vln=b2-b1
bytes=INT(mlen/mbit)*mbit
IF vln<=bytes THEN
@busy_mouse
bytes=INT(vln/mbit)*mbit
IF bytes>3 THEN
BGET #1,meml,bytes
IF fadericht=0 THEN
c=0
@maschruf32(0,bytes,c)
IF back%<>-1 THEN
b1=b1+back%
ENDIF
ENDIF
IF fadericht=1 THEN
c=1
@maschruf32(0,bytes,c)
IF back%<>-1 THEN
b2=b2-((b2-b1)-back%)
ENDIF
ENDIF
ENDIF
ENDIF
IF virtwfile=FALSE THEN
SEEK #1,b1
IF (b2-b1)<=mlen THEN
@busy_mouse
BGET #1,meml,b2-b1
@maschruf30(mdat3%,fadnr,0,b2-b1)
SEEK #1,b1
BPUT #1,meml,b2-b1
CLOSE #1
ELSE
@alerts(3)
ENDIF
ELSE
SEEK #1,0
IF (b2-b1)<=mlen THEN
vln=b1
bytes=INT(mlen/mbit)*mbit
IF vln>0 THEN
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
@busy_mouse
vln=b2-b1
bytes=INT(vln/mbit)*mbit
BGET #1,meml,bytes
@maschruf30(mdat3%,fadnr,0,b2-b1)
BPUT #2,meml,bytes
vln=INT((virtln-b2)/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
IF vln>0 THEN
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ELSE
@alerts(3)
ENDIF
ENDIF
ENDIF
ENDIF
IF virtual=FALSE OR (virtual=TRUE AND okay=TRUE AND (b2-b1)<=mlen AND virtwfile=TRUE) THEN
cached=FALSE
@restaura
ENDIF
ELSE
@alerts(13)
ENDIF
IF okay=TRUE THEN
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
@busy_mouse
path$=virtpath$
a=RINSTR(virtpath$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
cached=FALSE
@restaura
ENDIF
ENDIF
ELSE
IF (c2-c1)>mlen THEN
@alerts(3)
ELSE
@nomem
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@alerts(13)
ENDIF
RETURN
'
> PROCEDURE fadesave
.| Glob. Var.: fade$,lfw$,fil$,pret#,pbutt#,a#,sector#,i#,fadnr#,fadericht#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : fileselect,nomem,infade,ausfade
.| Aufruf in : fade-1,
LOCAL p$,g,g2
g=RINSTR(fade$,"\")
@fileselect(lfw$+"*."+RIGHT$(fade$,3),RIGHT$(fade$,LEN(fade$)-g),"FADER-SAVE:")
g2=INSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+RIGHT$(fade$,4)
ELSE
IF RIGHT$(fil$,4)<>RIGHT$(fil$,4) THEN
fil$=LEFT$(fil$,g2)+RIGHT$(fade$,3)
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=sector THEN
OPEN "O",#1,fil$
FOR i=1 TO fadnr
PRINT #1,fadeni(i)
PRINT #1,fadeno(i)
NEXT i
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
IF fadericht=0 THEN
@infade
ELSE
ausfade
ENDIF
RETURN
'
> PROCEDURE fadeload
.| Glob. Var.: fade$,lfw$,fil$,pret#,pbutt#,i#,fadnr#,fadericht#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : fileselect,infade,ausfade
.| Aufruf in : fade-1,
LOCAL p$,g
g=RINSTR(fade$,"\")
@fileselect(lfw$+"*."+RIGHT$(fade$,3),RIGHT$(fade$,LEN(fade$)-g),"FADER-LOAD:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
IF EXIST(fil$) THEN
OPEN "I",#1,fil$
FOR i=1 TO fadnr
INPUT #1,fadeni(i)
INPUT #1,fadeno(i)
NEXT i
CLOSE #1
ENDIF
ENDIF
IF fadericht=0 THEN
@infade
ELSE
ausfade
ENDIF
RETURN
'
> PROCEDURE fadeset
.| Glob. Var.: fadnr#,fade$,i#
.| Felder    : fadeni#(),fadeno#(),bfadeni#(),bfadeno#()
.| Ruft auf  : setlinear
.| Aufruf in : setload-1,
IF fadnr<>246 THEN
fadnr=246          ! Breite des Fadefensters in Pixeln
DIM fadeni(fadnr)
DIM fadeno(fadnr)
DIM bfadeni(fadnr)
DIM bfadeno(fadnr)
IF EXIST(fade$) THEN
OPEN "I",#1,fade$
FOR i=1 TO fadnr
INPUT #1,fadeni(i)
INPUT #1,fadeno(i)
NEXT i
CLOSE #1
ELSE
@setlinear
ENDIF
ENDIF
RETURN
'
> PROCEDURE blocklook
.| Glob. Var.: master#,loopz#,sms#,msms#,sme#,msme#,c1#,c2#,xm#,ce#,mce#
.|     meml#,mcs#
.| Felder    : loops#(),loope#()
.| Aufruf in : intzeiger1-1,fade_it-1,smpkhlp-1,movingmark-1,smpmhlp-1
.|     smpihlp-1,smpl-1,smpr-1,smpcut-1,sampleinf-1,resample-1,copytoarr-1
.|     trash-1,mono-2,negate-2,lrchange-2,makenorm-1,normtest-1,makeresmp-1
.|     smpplay-2,smpauto-1,record-1,
IF sms2<>0 AND sms>0 AND sms<=loopz THEN
c1=loops%(sms,1)
c2=loops%(sms,2)
ENDIF
IF xm>0 AND ce<>0 AND sms<>0 AND c2>c1 AND c2<>-1 AND c1<>-1 THEN
mce=c2+meml
mce=INT(mce/mbit)*mbit
mcs=c1+meml
mcs=INT(mcs/mbit)*mbit
ENDIF
RETURN
'
> PROCEDURE smptime
LOCAL a,a2,tex,a$
.| Glob. Var.: hrd#,vornr#,nr#,record&,min$,min#,timetxt&,oldmin#,obj#
.|     popup&,zu%,zuadr#,buttadr#,but#,objadr#,objflag#,rechelp&,recexit&
.|     recok&,recl1&,recl2&,recr1&,recr2&
.| Ruft auf  : markhlp,rsc_draw,textfeld,rsc_do,xrsrc_gaddr,mousek,helptxt
.|     setbutton,restaura2
.| Aufruf in : smpauto-1,smpstart-1,
a=ASC(LEFT$(fil$,1))-64
a2=DFREE(a)
a2=INT(a2-(a2/254)-16384)
IF a2<=0 THEN
nofile=0
@nomem
ELSE
vornr=nr
nr=record&
a$="RECORD-TIME"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
@rsc_draw(nr,0)
@markhlp
hsec=INT(a2/hz/mbit*100)
mmax=hsec
@htimeset
a$="FREETIME: "+a$
@textfeld(recfree&,a$,1)
REPEAT
@timeinp(mmax,rtime)
IF obj=rechelp& THEN
@helptxt("RECORD-TIME")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
@minwrite
ENDIF
ENDIF
RETURN
'
> PROCEDURE timeinp(timax,VAR tiwert)
LOCAL tex,otiwert
IF tiwert>timax THEN
tiwert=timax
ENDIF
hsec=tiwert
@htimeset2
@editfeld(timetxt&,ab$)
otiwert=tiwert
REPEAT
REPEAT
tex=FALSE
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>timetxt&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=tinpul1& OR obj=tinpul2& OR obj=tinpul3& OR obj=tinpul4& THEN
tex=TRUE
ENDIF
IF obj=tinpuh1& OR obj=tinpuh2& OR obj=tinpuh3& OR obj=tinpuh4& THEN
tex=TRUE
ENDIF
IF obj=tinpdl1& OR obj=tinpdl2& OR obj=tinpdl3& OR obj=tinpdl4& THEN
tex=TRUE
ENDIF
IF obj=tinpdh1& OR obj=tinpdh2& OR obj=tinpdh3& OR obj=tinpdh4& THEN
tex=TRUE
ENDIF
UNTIL obj=rechelp& OR obj=recexit& OR obj=recok& OR tex=TRUE
IF obj=recexit& OR obj=recok& OR tex=TRUE THEN
@setbutton(obj,0)
ENDIF
@editread(timetxt&)
IF LEN(a$)=8 THEN
tiwert=VAL(LEFT$(a$,2))*360000+VAL(MID$(a$,3,2))*6000+VAL(MID$(a$,5,2))*100+VAL(MID$(a$,7,2))
ENDIF
UNTIL obj=rechelp& OR obj=recexit& OR ((obj=recok& OR tex=TRUE) AND LEN(a$)=8 AND tiwert<(24*60*60*100))
IF tex=TRUE THEN
IF obj=tinpul1& AND tiwert<=(timax-360000) THEN
tiwert=tiwert+360000
ENDIF
IF obj=tinpul2& AND tiwert<=(timax-6000) THEN
tiwert=tiwert+6000
ENDIF
IF obj=tinpul3& AND tiwert<=(timax-100) THEN
tiwert=tiwert+100
ENDIF
IF obj=tinpul4& AND tiwert<timax THEN
tiwert=tiwert+1
ENDIF
IF obj=tinpuh1& AND tiwert<=(timax-3600000) THEN
tiwert=tiwert+3600000
ENDIF
IF obj=tinpuh2& AND tiwert<=(timax-60000) THEN
tiwert=tiwert+60000
ENDIF
IF obj=tinpuh3& AND tiwert<=(timax-1000) THEN
tiwert=tiwert+1000
ENDIF
IF obj=tinpuh4& AND tiwert<=(timax-10) THEN
tiwert=tiwert+10
ENDIF
IF obj=tinpdl1& AND tiwert>=360000 THEN
tiwert=tiwert-360000
ENDIF
IF obj=tinpdl2& AND tiwert>=6000 THEN
tiwert=tiwert-6000
ENDIF
IF obj=tinpdl3& AND tiwert>=100 THEN
tiwert=tiwert-100
ENDIF
IF obj=tinpdl4& AND tiwert>0 THEN
tiwert=tiwert-1
ENDIF
IF obj=tinpdh1& AND tiwert>=3600000 THEN
tiwert=tiwert-3600000
ENDIF
IF obj=tinpdh2& AND tiwert>=60000 THEN
tiwert=tiwert-60000
ENDIF
IF obj=tinpdh3& AND tiwert>=1000 THEN
tiwert=tiwert-1000
ENDIF
IF obj=tinpdh4& AND tiwert>=10 THEN
tiwert=tiwert-10
ENDIF
hsec=tiwert
@htimeset2
@editfeld(timetxt&,ab$)
ENDIF
UNTIL obj=recexit& OR obj=recok& OR obj=rechelp&
IF obj=recexit& THEN
tiwert=otiwert
ENDIF
RETURN
'
> PROCEDURE minwrite
IF nr=smpedit& THEN
hsec=rtime
@htimeset
a$=LEFT$(a$,8)+CHR$(0)
@textfeld(mintext&,a$,1)
ENDIF
RETURN
'
> PROCEDURE smpkhlp
.| Glob. Var.: mrkp$,mp$,g#,sms#,sme#,loopz#,xm#,ce#,c2#,c1#,c#,xmp#
.|     virtual#,mcs#,meml#,mce#,memh#,vmem#,mcd#,noms#,xmo#,ncs#,nce#,a#
.|     lfw$,mlen#,workfile$,sblock#,b#,v#,seek#,bytes#,path$,smpnam$
.|     noblkdel#,makevirt3#,workf$,virtwfile#,mm#,virtln#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp,blocklook,maschinit10,maschruf10,maschinit11
.|     maschruf11,busy_mouse,rettmem,memtovirt2,nomem,virtcopy,restaura
.| Aufruf in : smpanf-1,smpend-1,smpl-1,smpr-1,edhandler2-1,
LOCAL makev
makev=FALSE
mrkp$=mp$
@alerts(14)
IF g=1 THEN
IF sms<>0 AND sms<=loopz THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND c2>c1 AND ((c<>0 AND xmp=-1) OR (c=0 AND xmp=0)) THEN
IF virtual=FALSE THEN
IF mcs>=meml AND mce+mbit<memh AND c=1 THEN     !vorwÑrts key
sms=1
loops%(1,1)=c2
loops%(1,2)=c2+(c2-c1)
IF loops%(1,2)>vmem THEN
makev=TRUE
ENDIF
IF makev=FALSE THEN
@maschruf10(mcs,mce,mce+mbit,memh)
ENDIF
ENDIF
IF mcs>=meml AND mce+mbit<memh AND c=2 THEN   ! ans Ende
sms=1
loops%(1,1)=vmem
loops%(1,2)=vmem+(c2-c1)
makev=TRUE
ENDIF
IF mcs>meml AND c=-1 THEN
mcd=mcs-(mce-mcs)
IF mcd<meml THEN
mcd=meml
mcs=mce-(mcs-meml)
ENDIF
@maschruf10(mcs,mce,mcd,mcs)
sms=1
loops%(1,2)=c1
loops%(1,1)=c1-(c2-c1)
IF loops%(1,1)<0 THEN
loops%(1,1)=c1
loops%(1,2)=c2
ENDIF
ENDIF
IF mcs>meml AND c=-2 THEN
noms=0
mcd=mcs-(mce-mcs)
IF mcd<meml THEN
noms=1
mcd=meml
mcs=mce-(mcs-meml)
ELSE
mcd=meml
ENDIF
@maschruf10(mcs,mce,mcd,mcs)
sms=1
loops%(1,2)=c2-c1
loops%(1,1)=0
IF noms=1 THEN
loops%(1,1)=c1
loops%(1,2)=c2
ENDIF
ENDIF
IF xmp=0 AND c=0 THEN
loops%(1,1)=INT((c1+xmo)/mbit)*mbit
loops%(1,2)=INT((c2+xmo)/mbit)*mbit
sms=1
IF loops%(1,1)<0 THEN
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
IF loops%(1,2)>vmem THEN         ! vor per Maus
makev=TRUE
ENDIF
IF makev=FALSE THEN
ncs=loops%(1,1)+meml
ncs=INT(ncs/mbit)*mbit
nce=loops%(1,2)+meml
nce=INT(nce/mbit)*mbit
IF ncs>=mce THEN
@maschruf10(mcs,mce,ncs,memh)
ENDIF
IF ncs<mcs THEN
@maschruf10(mcs,mce,ncs,mce)
ENDIF
IF ncs<mce AND ncs>mcs THEN
@maschruf11(mce,mcs,nce)
ENDIF
ENDIF
ENDIF
IF makev=TRUE THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF loops%(sms,1)>=0 AND loops%(sms,2)<=mlen AND sblock=1 THEN
a=loops%(sms,1)
b=loops%(sms,2)
ELSE
a=0
b=mlen
ENDIF
b=INT(b/mbit)*mbit
a=INT(a/mbit)*mbit
v=b-a
v=INT(v/mbit)*mbit
IF a>=0 AND b<=mlen THEN
@busy_mouse
BPUT #1,meml+a,v
ENDIF
IF loops%(1,1)>b THEN
seek=v
ELSE
seek=loops%(1,1)
ENDIF
SEEK #1,seek
c=INT((c2-c1)/mbit)*mbit
BPUT #1,meml+c1,c
bytes=LOF(#1)
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
@rettmem
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
IF c=1 THEN
IF virtwfile=FALSE THEN
loops%(1,1)=c2
loops%(1,2)=c2+(c2-c1)
ENDIF
@virtcopy(c1,c2,c2-c1)
ENDIF
IF c=-1 THEN
mm=c1-(c2-c1)
IF mm<0 THEN
mm=0
ENDIF
IF virtwfile=FALSE THEN
loops%(1,2)=c1
loops%(1,1)=c1-(c2-c1)
IF loops%(1,1)<0 THEN
loops%(1,1)=c1
loops%(1,2)=c2
ENDIF
ENDIF
@virtcopy(c1,mm,c2-c1)
ENDIF
IF c=-2 THEN
IF virtwfile=FALSE THEN
loops%(1,2)=c2-c1
loops%(1,1)=0
ENDIF
@virtcopy(c1,0,c2-c1)
ENDIF
IF c=2 THEN
IF virtwfile=FALSE THEN
loops%(1,1)=vmem-(c2-c1)
loops%(1,2)=vmem
ENDIF
@virtcopy(c1,virtln-(c2-c1),c2-c1)
ENDIF
IF xmp=0 AND c=0 THEN
xmo=INT(xmo/mbit)*mbit
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
@virtcopy(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
@restaura
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE movingmark
.| Glob. Var.: cm1#,c1#,xmo#,i#,loopz#,cm2#,sms#,sme#
.| Felder    : loops#(),loope#()
.| Ruft auf  : blocklook,selblkstxt,selblketxt
.| Aufruf in : smpmhlp-1,
@blocklook
IF cm1<=c1 THEN
xmo=c1-cm1
ELSE
xmo=cm1-c1
xmo=-xmo
ENDIF
FOR i=1 TO loopz
IF loops%(i,1)>=cm1 AND loops%(i,1)<=cm2 AND sms<>i THEN
loops%(i,1)=loops%(i,1)+xmo
@selblkstxt(sms2,CHR$(0))
ENDIF
NEXT i
FOR i=1 TO loopz
IF loops%(i,2)>=cm1 AND loops%(i,2)<=cm2 AND sms<>i THEN
loops%(i,2)=loops%(i,2)+xmo
@selblkstxt(sms2,CHR$(0))
ENDIF
NEXT i
RETURN
'
> PROCEDURE smpmhlp
.| Glob. Var.: moveart#,sms#,sme#,loopz#,cm1#,c1#,cm2#,c2#,sblock#,xm#,ce#
.|     virtual#,a#,lfw$,mlen#,workfile$,xmp#,mcs#,meml#,mce#,memh#,bytes#
.|     virtfile$,m#,mrkstax#,mrkeax#,xmo#,vmem#,ncs#,path$,smpnam$,noblkdel#
.|     makevirt3#,workf$,virt$,n#,g#,virtwfile#,virtln#,cached#
.| Felder    : loops#(),loope#()
.| Ruft auf  : movefrag,markhlp,blocklook,rettmem,maschinit9,maschruf9,nomem
.|     memtovirt2,virtmove,movingmark,restaura
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,edhandler2-1,
@movefrag
IF moveart>0 THEN
IF sms<>0 AND sms<=loopz THEN
@markhlp
@blocklook
cm1=c1
cm2=c2
IF sblock=1 THEN
IF xm>0 AND ce<>0 AND sms<>0 AND c2>c1 THEN
IF virtual=FALSE THEN
sms=1
IF moveart=3 THEN                       ! CLEAR/INS
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF xmp=1 AND mcs>meml THEN          ! zum Anfang
BPUT #1,mcs,mce-mcs
@rettmem
@maschruf9(mcs,mce)
BPUT #1,meml,memh-meml
loops%(1,1)=0
loops%(1,2)=c2-c1
bytes=LOF(#1)
ENDIF
IF xmp=3 THEN                       ! ans Ende
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#2,lfw$+virtfile$
BPUT #2,mcs,mce-mcs
CLOSE #2
@rettmem
@maschruf9(mcs,mce)
BPUT #1,meml,memh-meml
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
bytes=LOF(#1)
loops%(1,1)=mlen
loops%(1,2)=bytes
CLOSE #2
KILL lfw$+virtfile$
ELSE
@nomem
ENDIF
ENDIF
IF xmp=2 THEN                        ! zur Mitte
m=((memh-meml)/2)+meml-((mce-mcs)/2)
m=INT(m/mbit)*mbit
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#2,lfw$+virtfile$
BPUT #2,mcs,mce-mcs
CLOSE #2
@rettmem
@maschruf9(mcs,mce)
BPUT #1,meml,m-meml
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
BPUT #1,m,memh-m
CLOSE #2
KILL lfw$+virtfile$
bytes=LOF(#1)
loops%(1,1)=m-meml
loops%(1,2)=(m-meml)+(c2-c1)
ELSE
@nomem
ENDIF
ENDIF
IF xmp=0 THEN                     ! Maus-move
mrkstax=loops%(1,1)
mrkeax=loops%(1,2)
loops%(1,1)=INT((c1+xmo)/mbit)*mbit
loops%(1,2)=INT((c2+xmo)/mbit)*mbit
IF loops%(1,1)<0 THEN
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
IF loops%(1,2)>vmem THEN
loops%(1,2)=INT(vmem/mbit)*mbit
loops%(1,1)=loops%(1,2)-(c2-c1)
ENDIF
ncs=loops%(1,1)+meml
ncs=INT(ncs/mbit)*mbit
IF DFREE(a)>(c2-c1) THEN
@rettmem
OPEN "O",#2,lfw$+virtfile$
BPUT #2,mcs,mce-mcs
CLOSE #2
@maschruf9(mcs,mce)
BPUT #1,meml,ncs-meml
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
BPUT #1,ncs,memh-ncs
CLOSE #2
KILL lfw$+virtfile$
bytes=LOF(#1)
ELSE
@nomem
ENDIF
ENDIF
loops%(1,1)=INT(loops%(1,1)/mbit)*mbit
loops%(1,2)=INT(loops%(1,2)/mbit)*mbit
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 OR moveart=1 OR moveart=2 THEN
IF xmp=1 AND mcs>meml THEN          ! zum Anfang
IF moveart=4 THEN
BMOVE mcs,meml,mce-mcs
IF mcs>meml+(mce-mcs) THEN
@maschruf9(mcs,mce)
ELSE
@maschruf9(meml+(mce-mcs),mce)
ENDIF
ENDIF
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
IF moveart=2 THEN                            ! CUT/INS
BMOVE meml,meml+(mce-mcs),mlen-(mce-mcs)
ENDIF
OPEN "I",#1,virt$
BGET #1,meml,mce-mcs
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ENDIF
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
IF xmp=3 THEN                        ! ans Ende
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,lfw$+virtfile$
BPUT #1,mcs,mce-mcs
CLOSE #1
IF moveart=1 THEN                ! CUT/COPY
BMOVE mce,mcs,memh-mce
OPEN "I",#1,lfw$+virtfile$
BGET #1,memh-(mce-mcs),mce-mcs
CLOSE #1
KILL lfw$+virtfile$
loops%(1,2)=(INT(vmem/mbit)*mbit)
loops%(1,1)=loops%(1,2)-(c2-c1)
ENDIF
IF moveart=2 THEN                ! CUT/INS
@rettmem
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
BPUT #1,meml,mlen
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
CLOSE #2
KILL lfw$+virtfile$
bytes=LOF(#1)
loops%(1,1)=mlen
loops%(1,2)=bytes
loops%(1,1)=INT(loops%(1,1)/mbit)*mbit
loops%(1,2)=INT(loops%(1,2)/mbit)*mbit
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 THEN            ! CLEAR/COPY
IF mce<memh-(mce-mcs) THEN
BMOVE mcs,memh-(mce-mcs),mce-mcs
@maschruf9(mcs,mce)
loops%(1,2)=(INT(vmem/mbit)*mbit)
loops%(1,1)=loops%(1,2)-(c2-c1)
ELSE
BMOVE mcs,memh-(mce-mcs),mce-mcs
@maschruf9(mcs,memh-(mce-mcs))
loops%(1,2)=INT(vmem/mbit)*mbit
loops%(1,1)=loops%(1,2)-(c2-c1)
ENDIF
ENDIF
ENDIF
IF xmp=2 THEN                        ! zur Mitte
m=((memh-meml)/2)+meml-((mce-mcs)/2)
m=INT(m/mbit)*mbit
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
IF moveart=2 THEN                            ! CUT/INS
BMOVE m,m+(mce-mcs),memh-m-(mce-mcs)
ENDIF
OPEN "I",#1,virt$
BGET #1,m,mce-mcs
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 THEN
IF mcs>=m+(mce-mcs) OR mce<m THEN
BMOVE mcs,m,mce-mcs
@maschruf9(mcs,mce)
ENDIF
IF mcs<m+(mce-mcs) AND mcs>=m AND mce>m+(mce-mcs) THEN
BMOVE mcs,m,mce-mcs
@maschruf9(m+(mce-mcs),mce)
ENDIF
IF mcs<m AND mce>=m AND mce<m+(mce-mcs) THEN
BMOVE mcs,m,mce-mcs
@maschruf9(mcs,m-1)
ENDIF
ENDIF
n=INT((c2-c1)/2)
loops%(1,1)=INT((vmem/2-n)/mbit)*mbit
loops%(1,2)=loops%(1,1)+(c2-c1)
ENDIF
IF xmp=0 THEN                     ! Maus-move
mrkstax=loops%(1,1)
mrkeax=loops%(1,2)
loops%(1,1)=INT((c1+xmo)/mbit)*mbit
loops%(1,2)=INT((c2+xmo)/mbit)*mbit
IF loops%(1,1)<0 THEN
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
IF loops%(1,2)>vmem THEN
loops%(1,2)=INT(vmem/mbit)*mbit
loops%(1,1)=loops%(1,2)-(c2-c1)
ENDIF
ncs=loops%(1,1)+meml
ncs=INT(ncs/mbit)*mbit
IF moveart=1 OR moveart=2 THEN
IF ncs<mcs OR ncs>mce THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
OPEN "I",#1,virt$
IF mce<=ncs THEN
IF moveart=2 THEN                            ! CUT/INS
BMOVE ncs-(mce-mcs),ncs,memh-ncs
ENDIF
BGET #1,ncs-(mce-mcs),mce-mcs
loops%(1,1)=loops%(1,1)-(mce-mcs)
loops%(1,1)=INT(loops%(1,1)/mbit)*mbit
loops%(1,2)=loops%(1,2)-(mce-mcs)
loops%(1,2)=INT(loops%(1,2)/mbit)*mbit
ELSE
IF moveart=2 THEN                            ! CUT/INS
BMOVE ncs,ncs+(mce-mcs),memh-ncs-(mce-mcs)
ENDIF
BGET #1,ncs,mce-mcs
ENDIF
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ELSE
loops%(1,1)=mrkstax
loops%(1,2)=mrkeax
@alerts(15)
@restaura
ENDIF
ENDIF
IF moveart=4 THEN
BMOVE mcs,ncs,mce-mcs
IF mcs>=ncs+(mce-mcs) OR mce<ncs THEN
@maschruf9(mcs,mce)
ENDIF
IF mcs<ncs+(mce-mcs) AND mcs>=ncs AND mce>ncs+(mce-mcs) THEN
@maschruf9(ncs+(mce-mcs),mce)
ENDIF
IF mcs<ncs AND mce>=ncs AND mce<ncs+(mce-mcs) THEN
@maschruf9(mcs,ncs-1)
ENDIF
ENDIF
ENDIF
ENDIF
ELSE
IF moveart>0 THEN
IF xmp=1 AND mcs>meml THEN        ! an Anfang
IF virtwfile=FALSE THEN
loops%(1,2)=c2-c1
loops%(1,1)=0
ENDIF
@virtmove(c1,0,c2-c1)
ENDIF
IF xmp=2 THEN                     ! zur Mitte
n=INT((c2-c1)/2)
n=INT((vmem/2-n)/mbit)*mbit
IF virtwfile=FALSE THEN
loops%(1,1)=n
loops%(1,2)=loops%(1,1)+(c2-c1)
ENDIF
@virtmove(c1,n,c2-c1)
ENDIF
IF xmp=3 THEN                     ! ans Ende
IF virtwfile=FALSE THEN
IF moveart=4 OR moveart=1 THEN
loops%(1,1)=vmem-(c2-c1)
loops%(1,2)=vmem
ELSE
loops%(1,1)=vmem
loops%(1,2)=vmem+(c2-c1)
ENDIF
ENDIF
IF moveart=4 OR moveart=1 THEN
@virtmove(c1,virtln-(c2-c1),c2-c1)
ELSE
@virtmove(c1,virtln,c2-c1)
ENDIF
ENDIF
IF xmp=0 THEN             ! Maus-move
xmo=INT(xmo/mbit)*mbit
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
@virtmove(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
ENDIF
cached=FALSE
@movingmark
@restaura
ENDIF
ELSE
@alerts(16)
@restaura
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE smpihlp                     ! Routine fÅr mem fehlt noch
.| Glob. Var.: mrkp$,mp$,g#,sms#,sme#,loopz#,xm#,ce#,c2#,c1#,virtual#
.|     sblock#,xmp#,xmo#,mlen#,m#,vmem#,ncs#,meml#,a#,lfw$,workfile$,cached#
.|     b#,bytes#,path$,smpnam$,noblkdel#,makevirt3#,workf$,virtwfile#
.|     virtln#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp,blocklook,busy_mouse,nomem,rettmem,memtovirt2,virtins
.|     restaura
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,edhandler2-1,
LOCAL makev
mrkp$=mp$
makev=FALSE
@alerts(17)
IF g=1 THEN
IF sms<>0 AND sms<=loopz THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND c2>c1 THEN
IF virtual=FALSE THEN
IF sblock=1 THEN
IF xmp=1 THEN
xmo=-c1
ENDIF
IF xmp=3 THEN
xmo=mlen-c2
ENDIF
IF xmp=2 THEN
m=mlen/2
m=INT(m/mbit)*mbit
xmo=m-c1
ENDIF
IF loops%(sms,1)>=0 AND loops%(sms,2)<=mlen THEN
sms=1
IF mlen>=(c2+xmo) AND (c1+xmo)>=0 THEN
xmo=INT(xmo/mbit)*mbit
IF ((c1+xmo)<=loops%(sms,2) AND (loops%(sms,2)+(c2-c1))<=mlen) OR ((c1+xmo)>loops%(sms,2) AND (c1+xmo+(c2-c1))<=mlen) THEN
loops%(1,1)=INT((c1+xmo)/mbit)*mbit
loops%(1,2)=INT((c2+xmo)/mbit)*mbit
IF loops%(1,1)<0 THEN
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
IF loops%(1,2)>vmem THEN
loops%(1,2)=INT(vmem/mbit)*mbit
loops%(1,1)=loops%(1,2)-(c2-c1)
ENDIF
ncs=loops%(1,1)+meml
ncs=INT(ncs/mbit)*mbit
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>=(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
@busy_mouse
BPUT #1,c1+meml,c2-c1
CLOSE #1
IF ((c1+xmo)<=loops%(sms,2) AND (loops%(sms,2)+(c2-c1))<=mlen) THEN
BMOVE ncs,ncs+(c2-c1),loops%(sms,2)-loops%(1,1)
loops%(sms,2)=loops%(sms,2)+(c2-c1)
ENDIF
OPEN "I",#1,lfw$+workfile$
@busy_mouse
BGET #1,ncs,c2-c1
CLOSE #1
KILL lfw$+workfile$
cached=FALSE
ELSE
@nomem
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
@alerts(16)
@restaura
ENDIF
IF makev=TRUE THEN
a=ASC(LEFT$(lfw$,1))-64
IF DFREE(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF loops%(sms,1)>=0 AND loops%(sms,2)<=mlen AND sblock=1 THEN
a=loops%(sms,1)
b=loops%(sms,2)
ELSE
a=0
b=mlen
ENDIF
IF a>=0 AND b<=mlen THEN
IF (c1+xmo)<a THEN
@busy_mouse
BPUT #1,meml+c1,c2-c1
BPUT #1,meml+a,b-a
ENDIF
IF (c1+xmo)>=a AND (c1+xmo)<=b THEN
@busy_mouse
BPUT #1,meml+a,(c1+xmo)-a
BPUT #1,meml+c1,c2-c1
IF (c1+xmo)<b THEN
BPUT #1,meml+c1+xmo,b-(c1+xmo)
ENDIF
ENDIF
IF (c1+xmo)>b THEN
@busy_mouse
BPUT #1,meml,b-a
BPUT #1,meml+c1,c2-c1
ENDIF
ENDIF
bytes=LOF(#1)
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
@rettmem
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
IF xmp=1 THEN
IF virtwfile=FALSE THEN
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
@virtins(c1,0,c2-c1)
ENDIF
IF xmp=2 THEN
m=(virtln/2)
m=INT(m/mbit)*mbit
IF virtwfile=FALSE THEN
loops%(1,1)=m
loops%(1,2)=m+(c2-c1)
ENDIF
@virtins(c1,m,c2-c1)
ENDIF
IF xmp=3 THEN
IF virtwfile=FALSE THEN
loops%(1,1)=virtln
loops%(1,2)=virtln+(c2-c1)
ENDIF
@virtins(c1,virtln,c2-c1)
ENDIF
IF xmp=0 THEN
xmo=INT(xmo/mbit)*mbit
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
@virtins(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
@restaura
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE marktextsel(i)
SELECT i
CASE 1
t$="S"
CASE 2
t$="E"
CASE 3
t$="I"
CASE 4
t$="R"
ENDSELECT
RETURN
'
> PROCEDURE markprod2
LOCAL i
IF markmode=2 THEN
i=1
@selblkshak(sms2,0)     ! Marker abwÑhlen
sms2=i
@selblkshak(sms2,1)     ! Marker auswÑhlen
'
@marktextsel(i)
@markhlp6(loops%(sms,i))
@markhlp3(sms,i,loops%(sms,i))
'
i=2
@marktextsel(i)
a=loops%(sms,i)
@markhandler(a)
IF a<>loops%(sms,i) THEN
@selblkshak(sms2,0)     ! Marker abwÑhlen
sms2=i
loops%(sms,i)=a
@selblkshak(sms2,1)     ! Marker auswÑhlen
@markhlp3(sms,sms2,loops%(sms,i))
ENDIF
ELSE
FOR i=1 TO 4
IF loops%(sms,i)<>-1 THEN
@marktextsel(i)
a=loops%(sms,i)
@markhandler(a)
IF a<>loops%(sms,i) THEN
@selblkshak(sms2,0)     ! Marker abwÑhlen
sms2=i
loops%(sms,i)=a
@selblkshak(sms2,1)     ! Marker auswÑhlen
@markhlp3(sms,sms2,loops%(sms,i))
ENDIF
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE markprod3
.| Aufruf in : message-2,restaura4-1,smpedit-1,time_edit-1,record2-1,
IF nr=smpedit& THEN
IF sms>0 AND sms<=loopz THEN
@edmarkset(sms)
ENDIF
ENDIF
RETURN
'
> PROCEDURE markprod3b
IF nr=smpedit& THEN
IF sms>0 AND sms<=loopz THEN
@edslidemove(sms)
ENDIF
ENDIF
RETURN
'
> PROCEDURE tplaymark
IF tplaystart<>-1 THEN
hsec=INT(tplaystart/thz/mbit*100)
@htimeset
@textfeld(tpstrt&,a$,1)
t$="s"
@pmarkhlp(tplaystart)
ENDIF
IF tplayend<>-1 THEN
hsec=INT(tplayend/thz/mbit*100)
@htimeset
@textfeld(tpend&,a$,1)
t$="e"
@pmarkhlp(tplayend)
ENDIF
RETURN
'
> PROCEDURE pmarkhlp(bx)
LOCAL cx,bs,be,by1,by2,pxm
IF bx<>-1 THEN
@markhlp
by1=yd+37
by2=yd+37+4*(trhb+trhd)
IF bigfoot=TRUE THEN
by1=by1+8
by2=by2+8
ENDIF
bs=toffs2/1000*thz*mbit
be=(toffs2+toffs3)/1000*thz*mbit
pxm=dig-1
txax=dix+1
IF bigfoot=TRUE THEN
pxm=pxm-1
ENDIF
txay=17
IF bigfoot=TRUE THEN
txay=16
ENDIF
IF bx>=bs AND bx<=be AND bx<>-1 THEN
cx=bx-bs
cx=cx/(be-bs)*pxm
cx=cx+txax
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE cx+xd,by1,cx+xd,by2
DEFTEXT 1,0,0,4
TEXT cx+xd-2,by1-txay,t$
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
RETURN
'
> PROCEDURE pmarkhlp2
IF tplaystart<>-1 THEN
t$="s"
a=tplaystart
@pmarkhandler(tpstrt&,a)
tplaystart=a
hsec=INT(tplaystart/thz/mbit*100)
@htimeset
@textfeld(tpstrt&,a$,1)
ENDIF
IF tplayend<>-1 THEN
t$="e"
a=tplayend
@pmarkhandler(tpend&,a)
tplayend=a
hsec=INT(tplayend/thz/mbit*100)
@htimeset
@textfeld(tpend&,a$,1)
ENDIF
RETURN
'
> PROCEDURE pmarkdel(bx)
LOCAL cx,bs,be,by1,by2,pxm
IF bx<>-1 THEN
@markhlp
by1=yd+37
by2=yd+37+4*(trhb+trhd)
IF bigfoot=TRUE THEN
by1=by1+8
by2=by2+8
ENDIF
bs=toffs2/1000*thz*mbit
be=(toffs2+toffs3)/1000*thz*mbit
pxm=dig-1
txax=dix+1
IF bigfoot=TRUE THEN
pxm=pxm-1
ENDIF
txay=17
IF bigfoot=TRUE THEN
txay=16
ENDIF
IF bx>=bs AND bx<=be AND bx<>-1 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
cx=bx-bs
cx=cx/(be-bs)*pxm
cx=cx+txax
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR smpwcol
GRAPHMODE 1
FOR i=cx+xd-4 TO cx+xd+3
LINE i,by1-txay+1,i,by1-txay-4
NEXT i
COLOR 1
GRAPHMODE 3
LINE cx+xd,by1,cx+xd,by2
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE pmarkhandler(po,VAR tx)
LOCAL cx,bs,be,by1,by2,pxm
LOCAL ux,i,vtx
by1=yd+37
by2=yd+37+4*(trhb+trhd)
IF bigfoot=TRUE THEN
by1=by1+8
by2=by2+8
ENDIF
bs=toffs2/1000*thz*mbit
be=(toffs2+toffs3)/1000*thz*mbit
pxm=dig-1
txax=dix+1
IF bigfoot=TRUE THEN
pxm=pxm-1
ENDIF
txay=17
IF bigfoot=TRUE THEN
txay=16
ENDIF
'
cx=bx-bs
cx=cx/(be-bs)*pxm
cx=cx+dix
'
vtx=tx
@mouse(x,y,k)
IF vtx>=bs AND vtx<=be AND (be-bs)>0 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
ux=vtx-bs
ux=INT(ux/(be-bs)*pxm)
IF x>ux+xd+txax-2 AND x<ux+xd+txax+2 AND y>=by1-txay-2 AND y<=by2 THEN
k=@mousek
~GRAF_MOUSE(256,0)                              ! Hidem
IF k=1 THEN
COLOR smpwcol
GRAPHMODE 1
FOR i=x-4 TO x+3
LINE i,by1-txay+1,i,by1-txay-4
NEXT i
drawnew=TRUE
GRAPHMODE 3
f=0
x3=-1
REPEAT
@mouse(x2,v2,k)
'
IF x2>=xd+txax AND x2<=(pxm+xd+txax) AND be>bs AND v2>=by1-txay-2 AND v2<=by2 THEN
pshowdat=((INT((INT((be-bs)/mbit))/pxm*(x2-xd-txax)))+INT(bs/mbit))*mbit
IF pshowbdat<>pshowdat THEN
pshowbdat=pshowdat
hsec=INT(pshowdat/thz/mbit*100)
@htimeset
@textfeld(po,a$,1)
ENDIF
ENDIF
'
IF x<>x2 THEN
INC f
ENDIF
x=x2
IF x>=xd+txax AND x<=pxm+xd+txax AND y>=by1-txay-2 AND y<=by2 AND x<>ux+xd+txax AND x3<>x THEN
GRAPHMODE 3
COLOR 0
LINE ux+xd+txax,by1,ux+xd+txax,by2
COLOR 1
vtx=INT(((be-bs)/pxm*(x-xd-txax)+bs)/mbit)*mbit
ux=vtx-bs
ux=INT(ux/(be-bs)*pxm)
x3=x
LINE ux+xd+txax,by1,ux+xd+txax,by2
GRAPHMODE 3
drawnew=TRUE
ENDIF
UNTIL k=0
IF zsnap=TRUE AND shit=TRUE THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4<>0 THEN
@springart(vtx)
IF back%>=cs AND back%<=ce THEN
vtx=back%
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
GRAPHMODE 3
COLOR 0
LINE ux+xd,stay1+1,ux+xd,stay2
COLOR 1
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
x3=x
LINE ux+xd,stay1+1,ux+xd,stay2
GRAPHMODE 3
drawnew=TRUE
ENDIF
ENDIF
tx=vtx
COLOR 1
GRAPHMODE 3
DEFTEXT 1,0,0,4
TEXT ux+xd+txax-2,by1-txay,t$
drawnew=TRUE
@gettrak
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
GRAPHMODE 1
obj=0
RETURN
'
> PROCEDURE killpmark
@pmarkdel(tplaystart)
@pmarkdel(tplayend)
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(tpstrt&,a$,1)
@textfeld(tpend&,a$,1)
tplaystart=-1
tplayend=-1
RETURN
'
> PROCEDURE killpmark2
@ptextdel(tplaystart)
@ptextdel(tplayend)
RETURN
'
> PROCEDURE ptextdel(bx)
LOCAL cx,bs,be,by1,by2,pxm
IF bx<>-1 THEN
@markhlp
by1=yd+37
by2=yd+37+4*(trhb+trhd)
IF bigfoot=TRUE THEN
by1=by1+8
by2=by2+8
ENDIF
bs=toffs2/1000*thz*mbit
be=(toffs2+toffs3)/1000*thz*mbit
pxm=dig-1
txax=dix+1
IF bigfoot=TRUE THEN
pxm=pxm-1
ENDIF
txay=17
IF bigfoot=TRUE THEN
txay=16
ENDIF
IF bx>=bs AND bx<=be AND bx<>-1 THEN
cx=bx-bs
cx=cx/(be-bs)*pxm
cx=cx+txax
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR smpwcol
GRAPHMODE 1
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
FOR i=cx+xd-4 TO cx+xd+3
LINE i,by1-txay+1,i,by1-txay-4
NEXT i
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
COLOR 1
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
RETURN
'
> PROCEDURE testsrate
tstsr=FALSE
IF hzm=8000 THEN
tstsr=TRUE
ENDIF
IF hzm=11000 THEN
tstsr=TRUE
ENDIF
IF hzm=12000 THEN
tstsr=TRUE
ENDIF
IF hzm=16000 THEN
tstsr=TRUE
ENDIF
IF hzm=17000 THEN
tstsr=TRUE
ENDIF
IF hzm=22000 THEN
tstsr=TRUE
ENDIF
IF hzm=24000 THEN
tstsr=TRUE
ENDIF
IF hzm=33000 THEN
tstsr=TRUE
ENDIF
IF hzm=32000 THEN
tstsr=TRUE
ENDIF
IF hzm=44100 THEN
tstsr=TRUE
ENDIF
IF hzm=48000 THEN
tstsr=TRUE
ENDIF
IF hzm=INT(masterclk/768) THEN
tstsr=TRUE
ENDIF
IF hzm=INT(masterclk/512) THEN
tstsr=TRUE
ENDIF
IF hzm=INT(masterclk/384) THEN
tstsr=TRUE
ENDIF
IF hzm=INT(masterclk/256) THEN
tstsr=TRUE
ENDIF
IF hzm=768 THEN
tstsr=TRUE
ENDIF
IF hzm=512 THEN
tstsr=TRUE
ENDIF
IF hzm=384 THEN
tstsr=TRUE
ENDIF
IF hzm=256 THEN
tstsr=TRUE
ENDIF
IF ext=768 THEN
tstsr=TRUE
ENDIF
IF ext=512 THEN
tstsr=TRUE
ENDIF
IF ext=384 THEN
tstsr=TRUE
ENDIF
IF ext=256 THEN
tstsr=TRUE
ENDIF
IF ext>0 THEN
tstsr=TRUE
ENDIF
RETURN
'
> PROCEDURE hztext
LOCAL j
IF nr=smpedit& THEN
IF sms>0 THEN
FOR j=1 TO 4
IF loops%(sms,j)<>-1 THEN
@markhlp3(sms,j,loops%(sms,j))
ENDIF
NEXT j
ENDIF
@markhlp3(9998,0,cs)
@markhlp3(9999,0,ce)
ENDIF
RETURN
'
> PROCEDURE smph2
.| Glob. Var.: master#,loopz#,t$,a#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhandl2,markhlp3
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
@marktextsel(sms2)
a=loops%(sms,sms2)
@markhandl2(a)
loops%(sms,sms2)=a
@markhlp3(sms,sms2,loops%(sms,sms2))
ENDIF
RETURN
'
> PROCEDURE smpanf
.| Glob. Var.: smark#,xmo#,xmp#,c#,x#,lzhold#,lz#,smpanf&
.| Ruft auf  : smpmhlp,smpihlp,smpkhlp,smph1,smph2,zoomhelp,setbutton
.|     flipptest
.| Aufruf in : do_smpedit-1,
IF smark=6 THEN
xmo=0
xmp=1
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=0
xmp=1
@smpihlp
ENDIF
IF smark=5 THEN
c=-2
@smpkhlp
ENDIF
IF smark=3 THEN
@smph1
x=0
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=1
@zoomhelp
ENDIF
@setbutton(smpanf&,0)
@flipptest
RETURN
'
> PROCEDURE smpend
.| Glob. Var.: smark#,xmp#,xmo#,xm#,c#,x#,vmem#,lzhold#,lz#,lzmrk#,smpend&
.| Ruft auf  : smpmhlp,smpihlp,smpkhlp,smph1,smph2,zoomhelp,setbutton
.|     flipptest
.| Aufruf in : do_smpedit-1,
IF smark=6 THEN
xmp=3
xmo=xm
@smpmhlp
ENDIF
IF smark=4 THEN
xmp=3
xmo=xm
@smpihlp
ENDIF
IF smark=5 THEN
c=2
@smpkhlp
ENDIF
IF smark=3 THEN
@smph1
x=vmem
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=lzmrk
@zoomhelp
ENDIF
@setbutton(smpend&,0)
@flipptest
RETURN
'
> PROCEDURE smpmid
.| Glob. Var.: smark#,xmo#,xm#,xmp#,x#,vmem#,lzhold#,lz#,lzmrk#,smpmid&
.| Ruft auf  : smpmhlp,smpihlp,smph1,smph2,zoomhelp,setbutton,flipptest
.| Aufruf in : do_smpedit-1,
IF smark=6 THEN
xmo=xm/2
xmp=2
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=xm/2
xmp=2
@smpihlp
ENDIF
IF smark=3 THEN
@smph1
x=INT(vmem/2)
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=INT(lzmrk/2)
IF lz=0 THEN
lz=1
ENDIF
@zoomhelp
ENDIF
@setbutton(smpmid&,0)
@flipptest
RETURN
'
> PROCEDURE zoomhelp
.| Glob. Var.: lz#,cs#,ce#,zoomstop#,lzhold#,xm#,cached#
.| Felder    : lce#(),lcs#()
.| Ruft auf  : curvetest,markhlp,zslidecalc,restaura
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,
IF lce(lz)>0 THEN
cs=lcs(lz)
ce=lce(lz)
ENDIF
@curvetest(cs,ce)
IF zoomstop=FALSE THEN
@markhlp
ELSE
lz=lzhold
ENDIF
IF xm>0 AND ce>cs THEN
@zslidecalc
cached=FALSE
@restaura
ENDIF
RETURN
'
> PROCEDURE smpl
.| Glob. Var.: c#,smark#,xmp#,obj#,smpl1&,smpl2&,smpl3&,xmo#,c2#,c1#,ce#,cs#
.|     xm#,x#,lz#,xs#,v#,v2#,v3#,v4#,lzhold#,memh#,cached#,u#,fadericht#
.| Ruft auf  : markhlp,blocklook,smpmhlp,smpihlp,smpkhlp,smph1,smph2
.|     zoomhelp,zslidecalc,restaura,fade_it,flipptest
.| Aufruf in : do_smpedit-1,
LOCAL mf
@markhlp
c=0
IF smark=6 OR smark=4 THEN
xmp=0
@blocklook
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
IF obj=smpl1& THEN
xmo=INT((c2-c1)/(mbit*4))*mbit
xmo=-xmo
ENDIF
IF obj=smpl2& THEN
xmo=INT((c2-c1)/(mbit*2))*mbit
xmo=-xmo
ENDIF
IF obj=smpl3& THEN
xmo=INT((c2-c1)/mbit)*mbit
xmo=-xmo
ENDIF
IF smark=6 THEN
@smpmhlp
ELSE
@smpihlp
ENDIF
ENDIF
ENDIF
IF smark=5 THEN
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
c=-1
@smpkhlp
ENDIF
ENDIF
IF smark=3 THEN
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
@smph1
mf=INT((ce-cs)/xm/mbit)*mbit
IF obj=smpl1& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x-1*mf
ELSE
x=x-mbit
ENDIF
ENDIF
IF obj=smpl2& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x-3*mf
ELSE
x=x-3*mbit
ENDIF
ENDIF
IF obj=smpl3& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x-10*mf
ELSE
x=x-10*mbit
ENDIF
ENDIF
@smph2
ENDIF
ENDIF
IF smark=2 THEN
IF lz>1 THEN
@smph1
IF obj=smpl1& THEN
xs=1
ENDIF
IF obj=smpl2& THEN
xs=2
ENDIF
IF obj=smpl3& THEN
xs=3
ENDIF
IF lz>xs AND (obj=smpl1& OR obj=smpl2& OR obj=smpl3&) THEN
~WIND_UPDATE(3)
~GRAF_MKSTATE(v,v2,v3,v4)
~WIND_UPDATE(2)
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& AND v4=0 THEN
lzhold=lz
lz=lz-xs
@zoomhelp
ENDIF
IF obj=smpl1& AND v4<>0 THEN
ce=((ce-cs)*1.5)+cs
IF ce>memh THEN
ce=memh
ENDIF
ce=INT(ce/mbit)*mbit
IF xm>0 AND ce>cs THEN
@zslidecalc
cached=FALSE
@restaura
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF smark=1 THEN
IF obj=smpl1& THEN
xs=(ce-cs)/4
ENDIF
IF obj=smpl2& THEN
xs=(ce-cs)/2
ENDIF
IF obj=smpl3& THEN
xs=ce-cs
ENDIF
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
IF cs-xs>0 THEN
cs=cs-xs
cs=INT(cs/mbit)*mbit
ce=ce-xs
ce=INT(ce/mbit)*mbit
ELSE
u=cs
cs=0
ce=ce-u
ce=INT(ce/mbit)*mbit
ENDIF
cached=FALSE
@restaura
ENDIF
ENDIF
IF smark=8 THEN
fadericht=0
@fade_it
ENDIF
@flipptest
RETURN
'
> PROCEDURE smpr
.| Glob. Var.: c#,smark#,xmp#,obj#,smpr1&,smpr2&,smpr3&,xmo#,c2#,c1#,ce#,cs#
.|     xm#,x#,lz#,lmax#,xs#,xmul#,zoomstop#,i#,loopz#,sms#,dcs#,sme#,dce#
.|     lzmrk#,cached#,g#,vmem#,u#,fadericht#
.| Felder    : lcs#(),lce#(),loops#(),loope#()
.| Ruft auf  : markhlp,blocklook,smpmhlp,smpihlp,smpkhlp,smph1,smph2
.|     curvetest,zslidecalc,restaura,fade_it,flipptest
.| Aufruf in : do_smpedit-1,
LOCAL mf
@markhlp
c=0
IF smark=6 OR smark=4 THEN
xmp=0
@blocklook
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
IF obj=smpr1& THEN
xmo=INT((c2-c1)/(mbit*4))*mbit
ENDIF
IF obj=smpr2& THEN
xmo=INT((c2-c1)/(mbit*2))*mbit
ENDIF
IF obj=smpr3& THEN
xmo=INT((c2-c1)/mbit)*mbit
ENDIF
IF smark=6 THEN
@smpmhlp
ELSE
@smpihlp
ENDIF
ENDIF
ENDIF
IF smark=5 THEN
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
c=1
@smpkhlp
ENDIF
ENDIF
IF smark=3 THEN
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@smph1
mf=INT((ce-cs)/xm/mbit)*mbit
IF obj=smpr1& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x+1*mf
ELSE
x=x+mbit
ENDIF
ENDIF
IF obj=smpr2& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x+3*mf
ELSE
x=x+3*mbit
ENDIF
ENDIF
IF obj=smpr3& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x+10*mf
ELSE
x=x+10*mbit
ENDIF
ENDIF
@smph2
ENDIF
ENDIF
IF smark=2 THEN
IF lz<lmax THEN
@smph1
IF obj=smpr1& THEN
xs=1
xmul=1.5
ENDIF
IF obj=smpr2& THEN
xs=1
xmul=2
ENDIF
IF obj=smpr3& THEN
xs=1
xmul=3
ENDIF
IF (lz+xs)<lmax AND (obj=smpr1& OR obj=smpr2& OR obj=smpr3&) THEN
@curvetest(cs,ce)
IF zoomstop=FALSE THEN
lcs(lz)=cs
lce(lz)=ce
@markhlp
dcs=loops%(sms,1)
dce=loops%(sms,2)
IF sms=0 THEN
dcs=0
dce=INT(ce-cs)
ENDIF
lz=lz+xs
lzmrk=lz
cs=dcs
IF dce>=ce THEN
ce=INT(((ce-cs)/xmul)+cs)
ELSE
ce=dce
ENDIF
ce=INT(ce/mbit)*mbit
lcs(lz)=cs
lce(lz)=ce
IF xm>0 AND ce>cs THEN
@zslidecalc
cached=FALSE
@restaura
ENDIF
ELSE
@alerts(18)
ENDIF
ENDIF
ENDIF
ENDIF
IF smark=1 THEN
IF obj=smpr1& THEN
xs=(ce-cs)/4
ENDIF
IF obj=smpr2& THEN
xs=(ce-cs)/2
ENDIF
IF obj=smpr3& THEN
xs=ce-cs
ENDIF
IF ce+xs<vmem THEN
cs=cs+xs
cs=INT(cs/mbit)*mbit
ce=ce+xs
ce=INT(ce/mbit)*mbit
ELSE
u=vmem-ce
cs=cs+u
cs=INT(cs/mbit)*mbit
ce=ce+u
ce=INT(ce/mbit)*mbit
ENDIF
cached=FALSE
@restaura
ENDIF
IF smark=8 THEN
fadericht=1
@fade_it
ENDIF
@flipptest
RETURN
'
> PROCEDURE movemark(strtmark,mdif)
.| Glob. Var.: i#,loopz#
.| Felder    : loops#(),loope#()
.| Aufruf in : smpcut-1,
FOR i=1 TO loopz
IF (loops%(i,1)>(strtmark-mdif) AND mdif<0) OR (loops%(i,1)<strtmark AND mdif>0) THEN
loops%(i,1)=loops%(i,1)+mdif
ENDIF
NEXT i
FOR i=1 TO loopz
IF (loops%(i,2)>(strtmark-mdif) AND mdif<0) OR (loops%(i,2)<strtmark AND mdif>0) THEN
loops%(i,2)=loops%(i,2)+mdif
ENDIF
NEXT i
RETURN
'
> PROCEDURE blkfunc
.| Glob. Var.: winh#,blkfunc&,rsc_window&,vornr#,nr#,menuda#,makevirt3#
.|     blocfunc&,g#,smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,markhlp,setbutton,setbutton2
.|     rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,blkfunc&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=blkfunc&
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
makevirt3=FALSE
@markhlp
ELSE
@setbutton(blocfunc&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=blkfunc&
IF vornr=smpedit& THEN
@setbutton2(blocfunc&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
'  @wischwasch
ENDIF
RETURN
'
> PROCEDURE do_blkf
.| Glob. Var.: obj#,blkhelp&,conins&,conmix&,cached#,conspace&,norm&,resmp&
.|     mono&,negate&,lrchange&,cutin&,cutout&,cutdel&,blkexit&,butdirect#
.|     winh#,blkfunc&,smpedit&,makecurve#,p$,hz#,smprate&,sec#,smplen#
.|     smpsec&,sec$,blocfunc&
.| Ruft auf  : helptxt,coninsert,conmix,conspace,normalize,resample,mono
.|     negate,lrchange,smpcut,setbutton,restaura2b,textfeld,secfeld,timecorr
.| Aufruf in : windows-1,
IF obj=blkhelp& THEN
@helptxt("BLOCK-FUNKTIONEN")
ENDIF
IF obj=conins& THEN
@coninsert
ENDIF
IF obj=conmix& THEN
@conmix
cached=FALSE
ENDIF
IF obj=conspace& THEN
@conspace
cached=FALSE
ENDIF
IF obj=norm& THEN
@normalize
ENDIF
IF obj=resmp& THEN
@resample
ENDIF
IF obj=mono& THEN
@mono
ENDIF
IF obj=negate& THEN
@negate
ENDIF
IF obj=lrchange& THEN
@lrchange
ENDIF
IF obj=cutin& OR obj=cutout& OR obj=cutdel& THEN
@smpcut
ENDIF
IF obj<>blkexit& AND butdirect=TRUE THEN
butdirect=FALSE
'    nr=butnr
'    @rsc_redraw_obj(nr,0)
ENDIF
IF obj=blkexit& OR obj=9999 THEN
@setbutton(blkexit&,0)
winh=BCLR(winh,blkfunc&)
@restaura2b
IF BTST(winh,smpedit&)=TRUE THEN
IF makecurve=1 THEN
p$=STR$(hz/1000)+CHR$(0)
@textfeld(smprate&,p$,1)
sec=smplen/(hz*mbit)
@secfeld(sec,8)
@textfeld(smpsec&,sec$,1)
@timecorr
ENDIF
@setbutton(blocfunc&,0)
ENDIF
obj=0
ENDIF
RETURN
'
> PROCEDURE smpcut
.| Glob. Var.: vobj#,obj#,sms#,sme#,loopz#,cutexit&,xm#,ce#,c2#,c1#,virtual#
.|     cutout&,mcs#,meml#,memh#,mce#,cutin&,cutdel&,virtln2#,virtln#
.|     virtwfile#,virtpath$,a#,virtp$,virtfile$,seekz#,mlen#,bytes#,path$
.|     smpnam$,vmem#,noblkdel#
.| Ruft auf  : markhlp,blocklook,maschinit9,maschruf9,movemark,busy_mouse
.|     hardproof3,memtovirt2,nomem,setbutton,blkrestaura
.| Aufruf in : do_blkf-1,
LOCAL okay,vln,ml,delrange
vobj=obj
@setbutton(vobj,1)
IF sms<>0 AND sms<=loopz AND obj<>cutexit& THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND c2>c1 THEN
IF virtual=FALSE THEN
IF obj=cutout& THEN
IF mcs>meml THEN
@maschruf9(meml,mcs)
ENDIF
IF memh>mce THEN
@maschruf9(mce,memh)
ENDIF
ENDIF
IF obj=cutin& THEN
@maschruf9(mcs,mce)
ENDIF
IF obj=cutdel& THEN
IF mce>mcs AND mcs>=meml THEN
mce=INT(mce/mbit)*mbit
@maschruf9(mcs,mce)
IF mce<memh THEN
delrange=(memh-(mce+mbit))
BMOVE mce+mbit,mcs,delrange
@maschruf9(memh-(mce-mcs),memh)
@movemark(c1,c1-c2)
ENDIF
ENDIF
ENDIF
ELSE
virtln2=virtln
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
virtln2=INT(virtln2/mbit)*mbit
okay=FALSE
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
IF virtwfile=FALSE AND obj<>cutdel& THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
seekz=0
ml=INT(mlen/mbit)*mbit
IF c1>0 THEN
IF okay=TRUE THEN
vln=c1
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=ml
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutout& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln=0
ENDIF
ENDIF
virtln2=virtln2-seekz
IF c2>c1 AND c2<=virtln THEN
IF okay=TRUE THEN
vln=c2-c1
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutin& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
IF obj<>cutdel& THEN
BPUT #2,meml,bytes
ENDIF
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln=0
virtln2=virtln2-(c2-c1)
ENDIF
ENDIF
IF c2<virtln THEN
IF okay=TRUE THEN
vln=virtln2
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutout& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
ENDIF
ENDIF
IF okay=TRUE THEN
CLOSE #1
IF virtwfile=TRUE OR obj=cutdel& THEN
CLOSE #2
ENDIF
IF virtwfile=FALSE AND obj=cutdel& THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
cs=0
ce=vmem
nr=smpedit&
@editselect
@memtovirt2
ENDIF
IF virtwfile=FALSE AND (obj=cutin& OR obj=cutout&) THEN
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
nr=smpedit&
@editselect
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
ENDIF
ENDIF
ENDIF
@blkrestaura
@setbutton(vobj,0)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
RETURN
'
> PROCEDURE movefrag
.| Glob. Var.: vornr#,nr#,moving&,obj#,popup&,zu%,zuadr#,buttadr#,but#
.|     objadr#,objflag#,movhlp&,mvcutcpy&,mvcutins&,mvclrins&,mvclrcpy&
.|     movexit&,moveart#
.| Ruft auf  : rsc_draw,markhlp,rsc_do,xrsrc_gaddr,mousek,helptxt,setbutton
.|     restaura2
.| Aufruf in : smpmhlp-1,
vornr=nr
nr=moving&
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=movhlp& THEN
@helptxt("MOVE")
ENDIF
UNTIL obj=mvcutcpy& OR obj=mvcutins& OR obj=mvclrins& OR obj=mvclrcpy& OR obj=movexit&
@setbutton(obj,0)
moveart=0
IF obj=mvcutcpy& THEN
moveart=1
ENDIF
IF obj=mvcutins& THEN
moveart=2
ENDIF
IF obj=mvclrins& THEN
moveart=3
ENDIF
IF obj=mvclrcpy& THEN
moveart=4
ENDIF
@restaura2
obj=0
RETURN
'
> PROCEDURE virtmove(ks,kd,kl)
.| Glob. Var.: sms#,sme#,virtln#,a#,virtpath$,vln#,moveart#,virtwfile#
.|     virtp$,virtfile$,bytes#,mlen#,meml#,seek#,memh#,path$,smpnam$,vmem#
.|     g#
.| Ruft auf  : busy_mouse,maschinit9,maschruf9,hardproof3,memtovirt2,nomem
.| Aufruf in : smpmhlp-5,
IF ks<>kd THEN
sms=1
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=vln+kl THEN
IF moveart=4 OR ((moveart=1 OR moveart=3 OR moveart=2) AND (kd>ks+kl OR kd<ks))
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 OR moveart=3 OR moveart=2 THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
IF moveart=4 THEN               ! CLR/COPY
vln=virtln
ENDIF
IF moveart=1 OR (moveart=2 AND kd>ks+kl) THEN               ! CUT/COPY
vln=ks
ENDIF
IF moveart=3 OR (moveart=2 AND kd<ks) THEN               ! CLR/INS
vln=kd
ENDIF
bytes=INT(mlen/mbit)*mbit
IF vln>0 THEN
REPEAT                          ! Source in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
IF moveart=3 OR (moveart=2 AND kd<ks) THEN
seek=0
vln=kl
bytes=INT(mlen/mbit)*mbit
REPEAT                          ! Sourceblock in Destblock kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
SEEK #1,ks+seek
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
IF moveart=1 OR moveart=3 OR (moveart=2 AND (kd>ks+kl OR kd<ks)) THEN    ! bei CUT/COPY den Sourceteil weglassen, den Rest kopieren
IF moveart=1 THEN
SEEK #1,ks+kl
vln=virtln-(ks+kl)
ENDIF
IF moveart=3 THEN
SEEK #1,kd
vln=virtln-kd
ENDIF
IF moveart=2 AND kd>ks+kl THEN    ! StÅck zwischen Sourceende und Destanfang kopieren
SEEK #1,ks+kl
vln=kd-(ks+kl)
ENDIF
IF moveart=2 AND kd<ks THEN   ! StÅck zwischen Destende und Sourceanfang kopieren
SEEK #1,kd
vln=ks-kd
ENDIF
vln=INT(vln/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
IF vln>0 THEN
REPEAT                          ! Source in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ENDIF
IF moveart=2 AND (kd>ks+kl OR kd<ks) THEN
IF kd>ks+kl THEN
SEEK #1,ks
vln=kl
vln=INT(vln/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
REPEAT                          ! Sourceblock in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
IF kd>ks+kl THEN
SEEK #1,kd
vln=virtln-kd
ENDIF
IF kd<ks THEN
SEEK #1,ks+kl
vln=virtln-(ks+kl)
ENDIF
vln=INT(vln/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
IF vln>0 THEN
REPEAT                          ! Von Dest bis Ende in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ENDIF
CLOSE #2
OPEN "U",#2,virtp$
IF moveart<>2 THEN
IF kd<ks OR moveart=4 THEN
SEEK #2,kd
ELSE
SEEK #2,kd-kl
ENDIF
ENDIF
ELSE
OPEN "U",#1,virtpath$
ENDIF
IF moveart=1 OR moveart=4 THEN
vln=INT(kl/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
seek=0
REPEAT                                ! Sourceblock nach Destblock kopieren
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
IF moveart=4 OR moveart=3 THEN                   ! nur fÅr CLR/COPY und CLR/INS
vln=INT(kl/mbit)*mbit
IF moveart=3 AND kd<ks AND kd+kl>ks THEN
vln=ks-kd
vln=INT(vln/mbit)*mbit
ENDIF
bytes=INT(mlen/mbit)*mbit
IF vln>=bytes THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+vln)
ENDIF
seek=0
IF moveart=3 AND kd<ks
seek=kl
ENDIF
IF moveart=3 AND kd<ks AND kd+kl>ks THEN
seek=kl*2-vln
ENDIF
IF kd>ks AND kd<(ks+kl) AND moveart=4 THEN
vln=kd-ks
vln=INT(vln/mbit)*mbit
ENDIF
IF kd<ks AND kd+kl>ks AND moveart=4 THEN
vln=ks-kd
vln=INT(vln/mbit)*mbit
seek=kd+kl-ks
seek=INT(seek/mbit)*mbit
ENDIF
IF vln>0 THEN
REPEAT                             ! Source mit Zero Åberschreiben
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=3 THEN
SEEK #2,ks+seek
BPUT #2,meml,bytes
ELSE
SEEK #1,ks+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
ENDIF
CLOSE #1
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 OR moveart=3 OR moveart=2 THEN ! Source del,Dest-Source rename
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
ENDIF
IF virtwfile=FALSE THEN                                ! Display erneuern
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF (moveart=2 OR moveart=3 OR moveart=1) AND kd<=ks+kl AND kd>ks
@alerts(15)
ENDIF
ELSE
@nomem
ENDIF
ENDIF
RETURN
'
> PROCEDURE virtcopy(ks,kd,kl)
.| Glob. Var.: virtln#,a#,virtpath$,vln#,virtwfile#,virtp$,virtfile$,bytes#
.|     mlen#,meml#,seek#,path$,smpnam$,vmem#
.| Ruft auf  : busy_mouse,hardproof3,memtovirt2,nomem
.| Aufruf in : smpkhlp-5,
IF ks<>kd THEN
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=vln+kl THEN
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
vln=virtln
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #2
OPEN "U",#2,virtp$
SEEK #2,kd
ELSE
OPEN "U",#1,virtpath$
ENDIF
vln=INT(kl/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
seek=0
REPEAT
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
CLOSE #1
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
ENDIF
IF virtwfile=FALSE THEN
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
ENDIF
RETURN
'
> PROCEDURE virtins(ks,kd,kl)
.| Glob. Var.: virtln#,a#,virtpath$,vln#,virtwfile#,virtp$,virtfile$,bytes#
.|     mlen#,meml#,seek#,path$,smpnam$,vmem#
.| Ruft auf  : busy_mouse,hardproof3,memtovirt2,nomem
.| Aufruf in : smpihlp-4,
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=vln+kl THEN
IF virtwfile=TRUE OR kd<virtln THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
vln=INT(kd/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
'
vln=INT(kl/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
SEEK #1,ks
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
'
vln=INT((virtln-kd)/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
SEEK #1,kd
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
CLOSE #1
CLOSE #2
ELSE
OPEN "U",#1,virtpath$
vln=INT(kl/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
seek=0
REPEAT
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
CLOSE #1
ENDIF
IF virtwfile=FALSE AND kd<virtln THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
IF virtwfile=FALSE THEN
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE markhandl4
.| Glob. Var.: y#,stay1#,stay2#,smark#,xmp#,c#,tx#,x#,vc1#,tx2#,vc2#,tm#
.|     tm2#,d1#,d2#,ag#,xd#,mdat%,ag2#,mdat2%,k#,xm#,x2#,t$,t2$
.| Ruft auf  : mousey,rsc_get2,rsc_put,mouse
.| Aufruf in : edhandler2-1,
y=@mousey
IF y>=stay1 AND y<=stay2 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
IF smark=6 OR smark=5 OR smark=4 THEN
xmp=0
c=0
ENDIF
tx=x-(x-vc1)
tx2=x+(vc2-x)
tm=tx
tm2=tx2
COLOR 0
GRAPHMODE 3
COLOR 1
d1=x-vc1
d2=vc2-x
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
mb1=tx2-tx+2
mh1=stay2-stay1+1
IF (tx+xd+(tx2-tx+2))>xwidth THEN
mb1=xwidth-(tx+xd)
ENDIF
IF (stay1+(stay2-stay1+1))>ywidth THEN
mh1=ywidth-stay1
ENDIF
mha4=@rsc_get(tx+xd,stay1,mb1,mh1)
mhb4=@rsc_get(tx+xd,stay1,mb1,mh1)
@rsc_putblock(mha4,tx+xd,stay1,0,0,mb1,mh1)
REPEAT
@mouse(x,y,k)
IF x-d1>=0 AND x+d2<=xm AND y>=stay1 AND y<=stay2 AND x<>x2 THEN
IF (tx+xd+(tx2-tx+2))>xwidth THEN
mb1=xwidth-(tx+xd)
ENDIF
IF (stay1+(stay2-stay1+1))>ywidth THEN
mh1=ywidth-stay1
ENDIF
@rsc_putblock(mhb4,tx+xd,stay1,0,0,mb1,mh1)
tx=x-d1
tx2=x+d2
x2=x
mhb4=@rsc_get2(tx+xd,stay1,mb1,mh1,mhb4)
IF (tx+xd+(tx2-tx+2))>xwidth THEN
mb1=xwidth-(tx+xd)
ENDIF
IF (stay1+(stay2-stay1+1))>ywidth THEN
mh1=ywidth-stay1
ENDIF
@rsc_putblock(mha4,tx+xd,stay1,0,0,mb1,mh1)
ENDIF
UNTIL k=0
GRAPHMODE 3
~MFREE(mha4)
~MFREE(mhb4)
DEFTEXT 1,0,0,4
TEXT tx+xd-2,stay1,t$
TEXT tx2+xd-2,stay1,t2$
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE putpix
.| Glob. Var.: edff#,virtual#,v4#,meml#,cs#,a#,wd#,g2#,mdat%,virtwfile#
.|     virtpath$,dsk#,virtln#,f#,virtp$,virtfile$,vln#,bytes#,mlen#
.| Ruft auf  : busy_mouse,nomem
.| Aufruf in : drawpix-2,
edff=TRUE
IF virtual=FALSE THEN
IF virtual=FALSE THEN
DPOKE meml+cs+((a-1)*mbit)+wd,g2
ELSE
DPOKE mdat%+((a-1)*mbit)+wd,g2
ENDIF
IF markmode=6 THEN
cached=FALSE
@drawnewcurve
ENDIF
ELSE
IF markmode=7 THEN
vw=((a-1)*mbit)+wd
DPOKE meml+(cs-vcs)+vw,g2
ELSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
@busy_mouse
PAUSE 1
vw=((a-1)*mbit)+wd
SEEK #1,cs+vw
@busy_mouse
PAUSE 1
DPOKE meml+(cs-vcs)+vw,g2
BPUT #1,meml+(cs-vcs)+vw,2
CLOSE #1
cached=FALSE
@drawnewcurve
ELSE
dsk=ASC(LEFT$(virtpath$,1))-64
IF DFREE(dsk)>virtln THEN
f=RINSTR(virtpath$,"\")
IF f>0 THEN
virtp$=LEFT$(virtpath$,f)+virtfile$
OPEN "O",#2,virtp$
OPEN "I",#1,virtpath$
vln=virtln
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
CLOSE #1
vw=((a-1)*mbit)+wd
SEEK #2,cs+vw
DPOKE meml+(cs-vcs)+vw,g2
BPUT #2,meml+(cs-vcs)+vw,2
CLOSE #2
cached=FALSE
@drawnewcurve
ENDIF
ELSE
@nomem
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
RETURN
'
> PROCEDURE drawnewcurve
@putcsize
IF memc=0 OR cached=FALSE OR (drawnew2=TRUE AND mnr=smpedit&) THEN
credraw=TRUE
@curve(cs,ce)
@blkupdate
credraw=FALSE
IF drawnew2=TRUE AND mnr=smpedit& THEN
@getcurve
ENDIF
ELSE
@putcurve
ENDIF
RETURN
'
> PROCEDURE drawpix
.| Glob. Var.: edff#,z#,x#,xd#,xm#,a#,b#,w#,d#,w2#,yd#,dist#,ym#,i#,m#,wd#
.| Felder    : cachep1#(),cachem1#(),cachep2#(),cachem2#()
.| Ruft auf  : mousek,putpix
.| Aufruf in : edhandler2-6,
LOCAL f,dsk,v,v2,v3,v4,g,g2,h1,h2
edff=TRUE
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
REPEAT
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL @mousek=0 OR (v2<>z AND v4=0) OR markmode=7
IF markmode=7 THEN
IF v>x THEN
x=v
ENDIF
IF x>xd+xm THEN
x=xd+xm
ENDIF
a=INT(b/xm*(x-xd))+1
w=xd-1+((a-1)*d)
w2=xd-1+(a*d)
IF w>xd+xm THEN
w=xd+xm
ENDIF
IF w2>xd+xm THEN
w2=xd+xm
ENDIF
ENDIF
h1=z0
h2=ym/2
IF v2>=h1-h2 AND v2<=h1+h2 THEN
COLOR 1
IF markmode=6 THEN
GRAPHMODE 3
ENDIF
IF markmode=7 THEN
GRAPHMODE 1
ENDIF
IF z>=h1-h2 AND z<h1 THEN
FOR i=w TO w2
LINE i,h1-1,i,z
NEXT i
ENDIF
IF z>h1 AND z<=h1+h2 THEN
FOR i=w TO w2
LINE i,h1+1,i,z
NEXT i
ENDIF
IF v2>=h1-h2 AND v2<h1 THEN
FOR i=w TO w2
LINE i,h1-1,i,v2
NEXT i
ENDIF
IF v2>h1 AND v2<=h1+h2 THEN
FOR i=w TO w2
LINE i,h1+1,i,v2
NEXT i
ENDIF
z=v2
ENDIF
UNTIL markmode=7 OR @mousek=0
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
g=z-h1
g=INT(g/ym*2*m)
~GRAF_MOUSE(257,0)                              ! Showm
IF g<=0 THEN
g2=ABS(g)
ELSE
g2=65536-g
ENDIF
IF dist=0 THEN
wd=0
@putpix
DPOKE tma+(a-1)*8,0
DPOKE tma+(a-1)*8+2,0
'    cachep1(a)=0
'    cachem1(a)=0
IF g<=0 THEN
DPOKE tma+(a-1)*8,ABS(g)
'      cachep1(a)=ABS(g)
ENDIF
IF g>=0 THEN
DPOKE tma+(a-1)*8+2,ABS(g)
'      cachem1(a)=g
ENDIF
ELSE
wd=2
@putpix
DPOKE tma+(a-1)*8+4,0
DPOKE tma+(a-1)*8+6,0
'    cachep2(a)=0
'    cachem2(a)=0
IF g<=0 THEN
DPOKE tma+(a-1)*8+4,ABS(g)
'      cachep2(a)=ABS(g)
ELSE
DPOKE tma+(a-1)*8+6,ABS(g)
'      cachem2(a)=g
ENDIF
ENDIF
GRAPHMODE 3
RETURN
'
> PROCEDURE edhandler
.| Glob. Var.: rwert#,merkc#,merkfreq#,smp16&,smp32&,digana#,hz#,smp44&
.|     smp48&,merkerr#,errdel#,noval&,confid&,slipped&,crc&,parity&,biphase&
.|     nolock&,zi#,merk3#,merk4#,prot&,emph&,use&,audio&
.| Ruft auf  : smprate,setbutton2,sethertz,read_statlow,read_statmid
.|     subframe,emphasis
.| Aufruf in : rsc_do-1,
LOCAL merk1,merk2,a,b,c
@read_digsrate
c=rwert
IF c<>merkc THEN
merkc=c
IF c=1 THEN
IF merkfreq<>0 THEN
@setbutton2(merkfreq,0,smp16&)
ENDIF
@setbutton2(smp32&,1,smp16&)
merkfreq=smp32&
IF digana=FALSE THEN
hz=32000
@sethertz
ENDIF
ENDIF
IF c=2 THEN
IF merkfreq<>0 THEN
@setbutton2(merkfreq,0,smp16&)
ENDIF
@setbutton2(smp44&,1,smp16&)
merkfreq=smp44&
IF digana=FALSE THEN
hz=44100
@sethertz
ENDIF
ENDIF
IF c=3 THEN
IF merkfreq<>0 THEN
@setbutton2(merkfreq,0,smp16&)
ENDIF
@setbutton2(smp48&,1,smp16&)
merkfreq=smp48&
IF digana=FALSE THEN
hz=48000
@sethertz
ENDIF
ENDIF
ENDIF
zsf2=TIMER-zsf
IF zsf2>=50 THEN
zsf=TIMER
@digerrorcode
b=(rwert AND 7)           ! Status Mid
IF b=0 THEN
IF merkerr<>0 THEN
@setbutton2(merkerr,0,smp16&)
merkerr=0
errdel=1
ENDIF
ENDIF
IF b=1 THEN
IF merkerr<>0 AND merkerr<>noval& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(noval&,1,smp16&)
merkerr=noval&
errdel=1
ENDIF
IF b=2 THEN
IF merkerr<>0 AND merkerr<>confid& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(confid&,1,smp16&)
merkerr=confid&
errdel=1
ENDIF
IF b=3 THEN
IF merkerr<>0 AND merkerr<>slipped& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
merkerr=0
errdel=1
ENDIF
IF b=4 THEN
IF merkerr<>0 AND merkerr<>crc& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
merkerr=0
errdel=1
ENDIF
IF b=5 THEN
IF merkerr<>0 AND merkerr<>parity& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(parity&,1,smp16&)
merkerr=parity&
errdel=1
ENDIF
IF b=6 THEN
IF merkerr<>0 AND merkerr<>biphase& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(biphase&,1,smp16&)
merkerr=biphase&
errdel=1
ENDIF
IF b=7 THEN
IF merkerr<>0 AND merkerr<>nolock& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(nolock&,1,smp16&)
merkerr=nolock&
errdel=1
ENDIF
errdel=0
@digstatcode
b=rwert      ! Status Mid
IF merk4<>b THEN
merk4=b
IF (b AND 4)=4 THEN
@setbutton2(prot&,1,smp16&)
ELSE
@setbutton2(prot&,0,smp16&)
ENDIF
IF (b AND 8)=8 THEN
@setbutton2(emph&,1,smp16&)
ELSE
@setbutton2(emph&,0,smp16&)
ENDIF
IF (b AND 1)=1 THEN
'    "CONSUMER"
@setbutton2(use&,0,smp16&)
ELSE
'    "PROFI"
@setbutton2(use&,1,smp16&)
ENDIF
IF (b AND 2)=2 THEN
'    "DIGITAL"
@setbutton2(audio&,1,smp16&)
ELSE
'    "DATA"
@setbutton2(audio&,0,smp16&)
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler2
.| Glob. Var.: edff#,xmp#,k#,mb&,x#,mx&,y#,my&,xd#,xm#,ce#,cs#,stay1#,stay2#
.|     max#,yzoom#,wyzoom#,rubmax#,v#,v2#,v3#,v4#,ym1#,yd#,z#,dist#,ym2#
.|     sline#,virtual#,virtpath$,mdat%,cached#,virtwfile#,dsk#,virtln#,f#
.|     virtp$,virtfile$,vln#,bytes#,mlen#,meml#,master#,masta#,xx#,zsnap#
.|     back%,loopz#,t$,smark#,sms#,c1#,sme#,c2#,t2$,vc1#,vc2#,xmo#,tx#,tm#
.|     ymd#
.| Felder    : cachep1#(),cachem1#(),cachep2#(),cachem2#(),loops#(),loope#()
.| Ruft auf  : markhlp,drawpix,busy_mouse,mousek,restaura,nomem,smph1
.|     springart,markhlp3,markhlp6,markhandl4,smpkhlp,smpmhlp,smpihlp
.|     flipptest,rubbermax,markprod2
.| Aufruf in : button-1,
LOCAL xw,ym,a1,a2,a,b,c,d,i,w,w2,m
edff=FALSE
xmp=-1
c=0
k=@mousek
IF k<>0 THEN
~GRAF_MKSTATE(v,v2,v3,v4)
@markhlp
x=mx&
y=my&
'
IF bigfoot=FALSE THEN
cxd=ax&+23          ! X-Locator
ym1=ay&+41          ! Y-Locator erste Box
ym2=ay&+129         ! Y-Locator zweite Box
ELSE
cxd=ax&+24          ! X-Locator
ym1=ay&+41+8          ! Y-Locator erste Box
ym2=ay&+253+8         ! Y-Locator zweite Box
ENDIF
'
IF k<>0 AND x>=xd AND x<=(xm+xd) AND xm>0 AND ce>cs AND y>=stay1 AND y<=stay2 AND (ce-cs)<=xm THEN
IF max=0 OR yzoom=FALSE THEN
m=32767
ELSE
m=max
ENDIF
IF wyzoom=TRUE THEN
m=rubmax
ENDIF
b=(ce-cs)/mbit
b=INT(b)
d=xm/b
a=INT(b/xm*(x-xd))+1
az=INT((x-xd))+1
w=xd+2+((a-1)*d)
w2=xd+2+(a*d)
'      ~GRAF_MKSTATE(v,v2,v3,v4)
IF markmode=6 AND k=1 THEN
IF y>=ym1 AND y<=ym1+ym THEN
a1=DPEEK(tma+(az-1)*8)
a2=DPEEK(tma+(az-1)*8+2)
'          a1=cachep1(a)
'          a2=cachem1(a)
IF a1>a2 THEN
c=INT(a1/m*ym/2)
c0=ym1+ym/2
IF y>=c0-c AND y<c0-c+4 THEN
z=ym1+ym/2-c
z0=ym1+ym/2
dist=0
@drawpix
ENDIF
ELSE
c=INT(a2/m*ym/2)
c0=ym1+ym/2
IF y<=c0+c AND y>c0+c-4 THEN
z=ym1+ym/2+c
z0=ym1+ym/2
dist=0
@drawpix
ENDIF
ENDIF
ENDIF
IF y>=ym2 AND y<=ym2+ym THEN
a1=DPEEK(tma+(az-1)*8+4)
a2=DPEEK(tma+(az-1)*8+6)
'          a1=cachep2(a)
'          a2=cachem2(a)
IF a1>a2 THEN
c=INT(a1/m*ym/2)
c0=ym2+ym/2
IF y>=c0-c AND y<c0-c+4 THEN
z=ym2+ym/2-c
z0=ym2+ym/2
'              z=yd+65+sline-c
dist=1
@drawpix
ENDIF
ELSE
c=INT(a2/m*ym/2)
c0=ym2+ym/2
IF y<=c0+c AND y>c0+c-4 THEN
'              z=yd+65+sline+c
z=ym2+ym/2+c
z0=ym2+ym/2
dist=1
@drawpix
ENDIF
ENDIF
ENDIF
ENDIF
IF markmode=7 AND k=1 THEN
IF y>=ym1 AND y<=ym1+ym THEN
z=ym1+ym/2
z0=ym1+ym/2
dist=0
REPEAT
@drawpix
UNTIL @mousek=0
ENDIF
IF y>=ym2 AND y<=ym2+ym THEN
z=ym2+ym/2
z0=ym2+ym/2
dist=1
REPEAT
@drawpix
UNTIL @mousek=0
ENDIF
IF edff=TRUE THEN
cached=FALSE
@restaura
ENDIF
IF virtual=TRUE AND edff=TRUE THEN
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
@busy_mouse
SEEK #1,cs
BPUT #1,meml+(cs-vcs),ce-cs
@busy_mouse
PAUSE 1
CLOSE #1
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
dsk=ASC(LEFT$(virtpath$,1))-64
IF DFREE(dsk)>virtln THEN
f=RINSTR(virtpath$,"\")
IF f>0 THEN
virtp$=LEFT$(virtpath$,f)+virtfile$
OPEN "O",#2,virtp$
OPEN "I",#1,virtpath$
vln=virtln
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
CLOSE #1
SEEK #2,cs
@busy_mouse
BPUT #2,meml+(cs-vcs),ce-cs
@busy_mouse
CLOSE #2
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ELSE
@nomem
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF ((markmode=1 OR markmode=2) AND k=1) AND y>=stay1 AND y<=stay2 THEN
IF markmode=2 THEN
IF sms=0 THEN
sms=1
ENDIF
xx=INT(((ce-cs)/xm*(x-xd)+cs)/mbit)*mbit
@edmarkdel
loops%(sms,1)=xx
loops%(sms,2)=xx
sms2=2
masta=xx
ELSE
IF sms<=loopz THEN
IF sms2<>0 THEN
masta=loops%(sms,sms2)
ENDIF
ENDIF
ENDIF
IF masta<cs OR masta>ce AND sms2<>0 THEN
xw=x
IF k<>0 AND xw>=xd AND xw<=(xm+xd) AND xm>0 AND ce>cs THEN
IF xw>=xd AND xw<=(xm+xd) AND xm>0 AND ce>cs THEN
@smph1
IF sms>0 AND x>ce OR x<cs THEN
edff=TRUE
xx=INT(((ce-cs)/xm*(xw-xd)+cs)/mbit)*mbit
IF zsnap=TRUE THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4<>0 THEN
@springart(xx)
IF back%>=cs AND back%<=ce THEN
xx=back%
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
loops%(sms,sms2)=xx
@marktextsel(sms2)
@markhlp3(sms,sms2,loops%(sms,sms2))
ENDIF
@markhlp6(xx)
REPEAT
k=@mousek
UNTIL k=0
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF k=1 AND y>=stay1 AND y<=stay2 AND x>=xd AND x<=(xm+xd) AND xm>0 THEN
IF smark=6 OR smark=5 OR smark=4 THEN
IF sms>0 THEN
c1=loops%(sms,1)
t$="S"
c2=loops%(sms,2)
t2$="E"
ENDIF
IF (ce-cs)>0 AND c1>=cs AND c2<=ce AND c2>c1 THEN
vc1=INT(xm/(ce-cs)*(c1-cs))
vc2=INT(xm/(ce-cs)*(c2-cs))
IF x>=vc1+xd AND x<=vc2+xd THEN
edff=TRUE
@markhandl4
IF sms>0 THEN
loops%(sms,1)=c1
loops%(sms,2)=c2
ENDIF
IF smark=5 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpkhlp
ENDIF
IF smark=6 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpihlp
ENDIF
@flipptest
ENDIF
ENDIF
ENDIF
IF edff=FALSE AND k=1 AND x>=xd AND x<=(xm+xd) AND xm>0 AND ce>cs AND y>=stay1 AND y<=stay2 THEN
IF y>=ym AND y<=ym1+ym THEN
ymd=ym1
@rubbermax
ENDIF
IF y>=ym2 AND y<=ym2+ym THEN
ymd=ym2
@rubbermax
ENDIF
ENDIF
IF smark=1 OR smark=2 OR smark=3 THEN
@markprod2
@flipptest
xmp=0
c=0
ENDIF
ENDIF
IF @mousek=0 AND drawnew=TRUE THEN
drawnew=FALSE
@getcurve
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler3
.| Glob. Var.: digana#,c#,rwert#,merkc#,merkfreq#,smp32&,hz#,smp44&,smp48&
.| Ruft auf  : smprate,sethertz
.| Aufruf in : rsc_do-1,smpplay-1,
IF digana=FALSE THEN
@read_digsrate
c=rwert
IF c<>merkc THEN
merkc=c
IF c=1 THEN
merkfreq=smp32&
IF digana=FALSE THEN
hz=32000
@sethertz
ENDIF
ENDIF
IF c=2 THEN
merkfreq=smp44&
IF digana=FALSE THEN
hz=44100
@sethertz
ENDIF
ENDIF
IF c=3 THEN
merkfreq=smp48&
IF digana=FALSE THEN
hz=48000
@sethertz
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler4
IF nr=arranger& THEN
IF XBIOS(xbs,1)=&H71273800 THEN
bc=back%
hsec=INT((sectpos+bc)/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler5
IF nr=trakker& THEN
IF XBIOS(xbs,1)=&H71273800 THEN
bc=back%
hsec=INT((sectpos+bc)/hz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE rubbermax
.| Glob. Var.: v#,v2#,v3#,v4#,ce#,cs#,xm#,x#,y#,x2#,y2#,a1#,ymd#,a2#,ym#,a#
.|     max#,m#,wyzoom#,rubmax#,qspacefill#,spacefill#,g#,xd#,scrlslde&
.|     scrolbut&,scmax#,scrollp#,mrscroll#,cached#
.| Ruft auf  : scrollinit,setslide,zslidecalc,writeyproz,restaura
.| Aufruf in : edhandler2-2,
LOCAL x1
~GRAF_MKSTATE(v,v2,v3,v4)
IF (v4=0 AND markmode=5 AND (ce-cs)>=xm) OR (v4=8 AND markmode=5) THEN
~GRAF_RUBBERBOX(x,y,10,10,x2,y2)
a1=y-ymd
a2=ymd+ym-(y2+y)
IF a2>ymd+ym THEN
a2=ymd+ym
ENDIF
IF a1<0 THEN
a1=0
ENDIF
IF a2<0 THEN
a2=0
ENDIF
IF a1<a2 THEN
a=a1
ELSE
a=a2
ENDIF
a=ABS(a)
a=((ym/2)-a)*2
IF max=0 THEN
m=32767
ELSE
m=max
ENDIF
IF wyzoom=TRUE THEN
m=rubmax
ENDIF
a=m/ym*a
IF wyzoom=FALSE THEN
qspacefill=spacefill
ENDIF
wyzoom=TRUE
spacefill=TRUE
IF v4=0 AND markmode=5 THEN
rubmax=INT(a)
IF (100/32767*rubmax)<6 THEN
rubmax=INT(32767/100*6)
@alerts(18)
ENDIF
x1=x-xd
x1=cs+((ce-cs)/xm*x1)
'      cs=INT(x1/mbit)*mbit
x2=x2+x-xd
x2=cs+((ce-cs)/xm*x2)
'      ce=INT(x2/mbit)*mbit
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
mrscroll=scrollp
cached=FALSE
@zslidecalc
ENDIF
IF (v4=8 AND markmode=5) THEN
IF rubmax=0 THEN
rubmax=32767
ENDIF
rubmax=rubmax*1.5
IF rubmax>32767 THEN
rubmax=32767
wyzoom=FALSE
spacefill=qspacefill
ENDIF
ENDIF
@writeyproz
@restaura
ENDIF
RETURN
'
> PROCEDURE blkstest
.| Glob. Var.: master#,shlp#,blksa#,meml#,blkse#,smrk#,c1#,loopz#,c2#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp
.| Aufruf in : smpsave-1,
'  war sms=0 AND shlp=1
IF sms2=0 THEN
blksa=meml
blkse=smrk
blstest=FALSE
ELSE
@markhlp
c1=loops%(sms,1)
c2=loops%(sms,2)
IF c1<>-1 AND c2<>-1 THEN
blkse=c2+meml
blkse=INT(blkse/mbit)*mbit
blksa=c1+meml
blksa=INT(blksa/mbit)*mbit
blstest=TRUE
ELSE
blksa=meml
blkse=smrk
blstest=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE markhlp7
.| Glob. Var.: i#,loopz#,sms#,lmin#,sme#,lma#,blks#,blksa#,meml#
.| Felder    : loops#(),loope#()
.| Aufruf in : smpsave-2,sampleinf-1,
lmin=loops%(sms,1)
lma=loops%(sms,2)
IF blks=0 THEN
lmin=INT(lmin/mbit)*mbit
lma=INT(lma/mbit)*mbit
ELSE
lmin=lmin-(blksa-meml)
lmin=INT(lmin/mbit)*mbit
lma=lma-(blksa-meml)
lma=INT(lma/mbit)*mbit
ENDIF
RETURN
'
> PROCEDURE makesmphead
.| Glob. Var.: danf#,hz#,len#,blks#,m2#,meml#,blksa#,blkse#,j#,nam$
.| Felder    : loops#(),loope#()
.| Aufruf in : sdsave-2,
LOCAL a$,i,a,m
FOR i=0 TO 295
POKE danf+i,0
NEXT i
DPOKE (danf+76),16     ! Bits
LPOKE (danf+72),hz     ! Sample-Rate
a=INT(len/mbit)
LPOKE (danf+92),a      ! datasize
LPOKE (danf+140),a     ! datasize2
LPOKE (danf),0         ! Sample-start
LPOKE (danf+4),a       ! Sample-end
IF blks=0 THEN
m=0
m2=meml
ELSE
m=blksa-meml
m2=blkse-meml
ENDIF
FOR j=1 TO 5
a=INT((loops%(j,1)-m)/mbit)
IF a<0 OR a>m2 THEN
a=0
ENDIF
LPOKE (danf+4+j*4),a       ! Start L1-L5
a=INT((loops%(j,2)-m)/mbit)
IF a<0 OR a>m2 THEN
a=0
ENDIF
LPOKE (danf+36+j*4),a      ! End L1-L5
NEXT j
LPOKE (danf+28),0      ! Start L6
LPOKE (danf+60),0      ! End L6
LPOKE (danf+28),0      ! Start L7
LPOKE (danf+60),0      ! End L7
a$=nam$
POKE danf+77,&H10
a=RINSTR(a$,".")
IF a>0 THEN
a=a-1
ENDIF
FOR i=1 TO a
POKE danf+77+i,ASC(MID$(a$,i,1))
NEXT i
LPOKE danf+96,&HFFFFFFFF   ! ??
LPOKE danf+100,&HFFFFFFFF  ! ??
DPOKE danf+144,1           ! ??
LPOKE danf+104,0       ! Marker 1
LPOKE danf+108,0       ! Marker 2
LPOKE danf+112,0       ! Marker 3
LPOKE danf+116,0       ! Marker 4
LPOKE danf+120,0       ! Marker 5
LPOKE danf+124,0       ! Marker 6
LPOKE danf+128,0       ! Marker 7
LPOKE danf+132,0       ! Marker 8
RETURN
'
> PROCEDURE sdsave
.| Glob. Var.: a#,fil$,b#,a$,danf#,head#,fileart#,datx#,len#,hdl#,mdat%
.|     hbuf#,ret#,i#
.| Ruft auf  : maschinit38,maschruf38,maschinit36,maschruf36,makesmphead
.|     nomem
.| Aufruf in : smpsave-1,
a=INSTR(fil$,".")
b=RINSTR(fil$,"\")
IF (a-b)>8 THEN
a$=LEFT$(fil$,a-2)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ELSE
a$=LEFT$(fil$,a-1)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ENDIF
OPEN "O",#1,a$
BPUT #1,danf,head
CLOSE #1
IF fileart=6 THEN
@maschruf38(datx,datx+len)
ENDIF
hdl=GEMDOS(61,L:VARPTR(a$),2)
~GEMDOS(66,L:head,hdl,0)
@maschruf36(datx,datx+len,mdat%+2048,mdat%+hbuf-mbit,hdl,ret)
a=GEMDOS(62,hdl)
IF fileart=6 THEN
@makesmphead
OPEN "U",#1,a$
SEEK #1,LOF(#1)
BPUT #1,danf,296   ! Header
CLOSE #1
ENDIF
IF ret=(datx+len) THEN
a=INSTR(fil$,".")
b=RINSTR(fil$,"\")
IF (a-b)>8 THEN
a$=LEFT$(fil$,a-2)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ELSE
a$=LEFT$(fil$,a-1)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ENDIF
IF fileart=6 THEN
LPOKE danf,&HF07E0001                    ! Kennung
FOR i=danf+4 TO danf+19
POKE i,0
NEXT i
ENDIF
OPEN "O",#1,a$
BPUT #1,danf,head
CLOSE #1
hdl=GEMDOS(61,L:VARPTR(a$),2)
~GEMDOS(66,L:head,hdl,0)
@maschruf36(datx+2,datx+len+2,mdat%+2048,mdat%+hbuf-mbit,hdl,ret)
~GEMDOS(62,hdl)
IF fileart=6 THEN
@makesmphead
OPEN "U",#1,a$
SEEK #1,LOF(#1)
BPUT #1,danf,296   ! Header
CLOSE #1
ENDIF
IF ret<>datx+len+2 THEN
@nomem
ENDIF
ELSE
@nomem
ENDIF
IF fileart=6 THEN
@maschruf38(datx,datx+len)
ENDIF
RETURN
'
> PROCEDURE headart
head=0
IF INSTR(fil$,".")=0 THEN
fil$=fil$+"."+vext$
ENDIF
@headart2(fil$)
IF head>0 THEN
FOR i=0 TO head-1
POKE danf+i,0
NEXT i
ENDIF
RETURN
'
> PROCEDURE headart2(head$)
LOCAL h
sfileart=0
h=INSTR(head$,CHR$(0))
IF h<>0 THEN
head$=LEFT$(head$,h-1)
ENDIF
IF RIGHT$(head$,4)=".S16" THEN
sfileart=1
head=20
@setbitrate16
ENDIF
IF RIGHT$(head$,4)=".S24" THEN
sfileart=1
head=20
@setbitrate24
ENDIF
IF RIGHT$(head$,4)=".AVR" THEN
sfileart=2
head=128
ENDIF
IF RIGHT$(head$,4)=".WAV" THEN
sfileart=3
head=44
ENDIF
IF RIGHT$(head$,3)=".AU" OR RIGHT$(head$,4)=".SND" THEN
sfileart=4
head=28
ENDIF
IF RIGHT$(head$,3)=".SD" THEN
sfileart=5
head=1336
ENDIF
IF RIGHT$(head$,4)=".SMP" THEN
sfileart=6
head=20+296
ENDIF
IF RIGHT$(head$,4)=".AIF" THEN
sfileart=7
head=54+458
ENDIF
RETURN
'
> PROCEDURE headmake
IF fileart=1 THEN                          ! S16-File
DPOKE danf,&HF07E                        ! SDS-Startkennung
POKE danf+2,1                            ! MIDI-Kanalnummer
POKE danf+3,1
DPOKE danf+4,&H100                       ! Sample-Nr.
POKE danf+6,16                           ! Bits
per=10^9/hz
x=INT(per/65536)
y=per-x*65536
POKE danf+7,x                            ! Periodendauer eines Samples
DPOKE danf+8,y                           ! Periodendauer eines Samples
IF blks=1 AND blstest=TRUE THEN
mlh=INT((blkse-blksa)/(mbit/2))
ELSE
mlh=INT(mlen/(mbit/2))
ENDIF
x2=INT(mlh/256)
y2=mlh-x2*256
DPOKE danf+10,x2                          ! Sample Len in Worten
POKE danf+12,y2                           ! Sample Len in Worten
@markhlp
@markhlp7
x3=INT(lmin/65536)
y3=lmin-x3*65536
POKE danf+13,x3                           ! Sustain Loop-Start
DPOKE danf+14,y3                          ! Sustain Loop-Start
x4=INT(lma/256)
y4=lma-x4*256
DPOKE danf+16,x4                          ! Sustain Loop-End
POKE danf+18,y4                          ! Sustain Loop-End
IF sret=0 THEN
la=0
ELSE
la=1
ENDIF
IF sblock=0 THEN
la=&H7F
ENDIF
POKE danf+19,la                           ! Loop-Art
'      POKE danf+20,&HF7                  ! SDS-Endkennung
ENDIF
'
IF fileart=2 THEN                          ! AVR-File
cdavr=TRUE
'
LPOKE danf,&H32424954                    ! AVR-Kennung
i=INSTR(nam$,".")
a$=LEFT$(nam$,i-1)
FOR i=1 TO LEN(a$)
POKE danf+3+i,ASC(MID$(a$,i,1))        ! Name des Samples
NEXT i
DPOKE danf+12,&HFFFF                     ! mode
IF dig24=FALSE THEN
DPOKE danf+14,16                         ! resolution
ELSE
DPOKE danf+14,24                         ! resolution
ENDIF
DPOKE danf+16,&HFFFF                     ! sign
la=0
IF sblock=1 AND blstest=TRUE AND cdavr=FALSE THEN
la=&HFFFF     ! herausgenommen wegen Problem mit CD-Rekorder Audio !!!
ENDIF
DPOKE danf+18,la                         ! loop
DPOKE danf+20,&HFFFF                     ! note
LPOKE danf+22,hz                         ! speed
IF blks=1 AND blstest=TRUE THEN
mlh=INT((blkse-blksa)/2)
ELSE
mlh=INT(mlen/2)
ENDIF
LPOKE danf+26,mlh                        ! len
@markhlp
IF sblock=1 AND blstest=TRUE AND cdavr=FALSE THEN
@markhlp7
LPOKE danf+30,INT(lmin/2)              ! beg_loop
LPOKE danf+34,INT(lma/2)               ! end_loop
ELSE
LPOKE danf+30,0
LPOKE danf+34,mlh
ENDIF
ENDIF
'
IF fileart=3 THEN                          ! WAV-File
LPOKE danf,&H52494646                    ! "RIFF"
IF blks=1 AND blstest=TRUE THEN
len=blkse-blksa
ELSE
len=mlen
ENDIF
len2=len+head-4
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+4,a4
POKE danf+5,a3
POKE danf+6,a2
POKE danf+7,a1
LPOKE danf+8,&H57415645                  ! "WAVE"
LPOKE danf+12,&H666D7420                 ! "fmt "
POKE danf+16,16                          ! LÑnge des fmt-Chunks
POKE danf+17,0
POKE danf+18,0
POKE danf+19,0
POKE danf+20,1                           ! format PCM
POKE danf+21,0
POKE danf+22,2                           ! channels
POKE danf+23,0
len2=hz
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+24,a4                           ! frequency
POKE danf+25,a3
POKE danf+26,a2
POKE danf+27,a1
len2=hz*mbit                              ! average
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+28,a4                           ! average
POKE danf+29,a3
POKE danf+30,a2
POKE danf+31,a1
POKE danf+32,4                            ! align
POKE danf+33,0
IF dig24=FALSE THEN
POKE danf+34,16                           ! bps
ELSE
POKE danf+34,24                           ! bps
ENDIF
POKE danf+35,0
LPOKE danf+36,&H64617461                  ! "data"
len2=len
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+40,a4                           ! LÑnge des data-chunks
POKE danf+41,a3
POKE danf+42,a2
POKE danf+43,a1
ENDIF
'
IF fileart=4 THEN                          ! AU-File
LPOKE danf,&H2E736E64                    ! AVR-Kennung
LPOKE danf+4,28                          ! datalocation
LPOKE danf+12,3                          ! dataformat
LPOKE danf+20,2                          ! channelcount
LPOKE danf+24,0                          ! info
LPOKE danf+16,hz                         ! samplingrate
IF blks=1 AND blstest=TRUE THEN
mlh=blkse-blksa
ELSE
mlh=mlen
ENDIF
LPOKE danf+8,mlh                         ! datasize
@markhlp
ENDIF
'
IF fileart=5 THEN                          ! SD-File
'   0-3    05 38 00 0C          -> Kennung'
'  58-61   FF FF FF 80'
'  64-67   01 47 04 00'
'  69-74   25 53 63 61 6C 65     %Scale'
' 109-114  20 20 6D 73 65 63       msec'
' 148-151  00 04 CC 66          -> LÑnge des Samples in Bytes'
' 184-187  00 04 CC 66          -> LÑnge des Samples in Bytes'
' 1020-1023 AC 44               -> Samplerate'
' 1031-1036 4C 69 6E 65 61 72     Linear'
' 1336-xxxx Daten'
LPOKE danf,&H538000C                     ! SD-Kennung
LPOKE danf+58,&HFFFFFF80                 ! ?
LPOKE danf+64,&H1470400                  ! ?
POKE danf+69,&H25                        ! "%"
LPOKE danf+70,&H5363616C                 ! "Scal"
POKE danf+74,&H65                        ! "e"
POKE danf+109,&H20                       ! " "
LPOKE danf+110,&H206D7365                ! " mse"
POKE danf+114,&H63                       ! "c"
IF blks=1 AND blstest=TRUE THEN
mlh=INT((blkse-blksa)/2)
ELSE
mlh=INT(mlen/2)
ENDIF
LPOKE danf+148,mlh                       ! len
LPOKE danf+184,mlh                       ! len
LPOKE danf+1020,hz                       ! speed
POKE danf+1031,&H4C                      ! "L"
LPOKE danf+1032,&H696E6561               ! "inea"
POKE danf+1036,&H72                      ! "r"
IF blks=1 AND blstest=TRUE THEN
len=blkse-blksa
ELSE
len=mlen
ENDIF
ENDIF
'
IF fileart=6 THEN                          ! Avalon SMP-File
LPOKE danf,&HF07E0001                    ! Kennung
FOR i=danf+4 TO danf+19
POKE i,0
NEXT i
head=20
IF blks=1 AND blstest=TRUE THEN
len=blkse-blksa
ELSE
len=mlen
ENDIF
ENDIF
IF fileart=7 THEN                          ! AIFF-File
LPOKE danf,&H464F524D                    ! "FORM"
IF blks=1 AND blstest=TRUE THEN
mlh=blkse-blksa
ELSE
mlh=mlen
ENDIF
LPOKE danf+4,mlh+512-12                  ! formsize
LPOKE danf+8,&H41494646                  ! "AIFF"
LPOKE danf+12,&H434F4D4D                 ! "COMM"
LPOKE danf+16,&H12                       ! commsize
DPOKE danf+20,2                          ! channels
LPOKE danf+22,INT(mlh/mbit)              ! frames
IF dig24=FALSE THEN
DPOKE danf+26,16                         ! bits
ELSE
DPOKE danf+26,24                         ! bits
ENDIF
DPOKE danf+28,&H400E                     ! lead
DPOKE danf+30,hz                         ! samplingrate
DPOKE danf+32,0                          ! dummy 1
DPOKE danf+34,0                          ! dummy 2
DPOKE danf+36,0                          ! dummy 3
LPOKE danf+38,&H53534E44                 ! "SSND"
LPOKE danf+42,mlh+512-46                 ! soundsize
LPOKE danf+46,458                        ! Offset
LPOKE danf+50,512                        ! blocksize
@markhlp
ENDIF
RETURN
'
> PROCEDURE headmake2
LOCAL len,len2,mlh,x2,y2,a1,a2,a3,a4
IF fileart=1 THEN                          ! S16-File
mlh=INT(vln/(mbit/2))
x2=INT(mlh/256)
y2=mlh-x2*256
DPOKE danf+10,x2                          ! Sample Len in Worten
POKE danf+12,y2                           ! Sample Len in Worten
ENDIF
'
IF fileart=2 THEN                          ! AVR-File
mlh=INT(vln/2)
LPOKE danf+26,mlh                        ! len
IF sblock=1 AND blstest=TRUE THEN
LPOKE danf+30,INT(lmin/2)              ! beg_loop
LPOKE danf+34,INT(lma/2)               ! end_loop
ELSE
LPOKE danf+30,0
LPOKE danf+34,mlh
ENDIF
ENDIF
'
IF fileart=3 THEN                          ! WAV-File
len=vln
len2=len+head-4
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+4,a4
POKE danf+5,a3
POKE danf+6,a2
POKE danf+7,a1
len2=len
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+40,a4                           ! LÑnge des data-chunks
POKE danf+41,a3
POKE danf+42,a2
POKE danf+43,a1
ENDIF
'
IF fileart=4 THEN                          ! AU-File
mlh=vln
LPOKE danf+8,mlh                         ! datasize
ENDIF
'
IF fileart=5 THEN                          ! SD-File
'   0-3    05 38 00 0C          -> Kennung'
'  58-61   FF FF FF 80'
'  64-67   01 47 04 00'
'  69-74   25 53 63 61 6C 65     %Scale'
' 109-114  20 20 6D 73 65 63       msec'
' 148-151  00 04 CC 66          -> LÑnge des Samples in Bytes'
' 184-187  00 04 CC 66          -> LÑnge des Samples in Bytes'
' 1020-1023 AC 44               -> Samplerate'
' 1031-1036 4C 69 6E 65 61 72     Linear'
' 1336-xxxx Daten'
mlh=INT(vln/2)
LPOKE danf+148,mlh                       ! len
LPOKE danf+184,mlh                       ! len
len=vln
ENDIF
'
IF fileart=6 THEN                          ! Avalon SMP-File
len=vln
ENDIF
IF fileart=7 THEN                          ! AIFF-File
mlh=vln
LPOKE danf+4,mlh+512-12                  ! formsize
LPOKE danf+22,INT(mlh/mbit)              ! frames
LPOKE danf+42,mlh+512-46                 ! soundsize
ENDIF
RETURN
'
> PROCEDURE headmake3
LOCAL len,len2,mlh,x2,y2,a1,a2,a3,a4,per,x,y
IF fileart=1 THEN                          ! S16-File
per=10^9/hz
x=INT(per/65536)
y=per-x*65536
POKE meml+7,x                            ! Periodendauer eines Samples
DPOKE meml+8,y                           ! Periodendauer eines Samples
ENDIF
'
IF fileart=2 THEN                          ! AVR-File
LPOKE meml+22,hz                         ! speed
ENDIF
'
IF fileart=3 THEN                          ! WAV-File
len2=hz
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE meml+24,a4                           ! frequency
POKE meml+25,a3
POKE meml+26,a2
POKE meml+27,a1
len2=hz*mbit                                 ! average
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE meml+28,a4                           ! average
POKE meml+29,a3
POKE meml+30,a2
POKE meml+31,a1
ENDIF
'
IF fileart=4 THEN                          ! AU-File
LPOKE meml+16,hz                         ! samplingrate
ENDIF
'
IF fileart=5 THEN                          ! SD-File
LPOKE meml+1020,hz                       ! speed
ENDIF
'
IF fileart=7 THEN                          ! AIFF-File
DPOKE meml+30,hz                         ! samplingrate
ENDIF
RETURN
'
> PROCEDURE smpsave
.| Glob. Var.: inf#,nomem#,vornr#,nr#,savebloc&,zu%,versatz#,a$,string#
.|     savetxt&,it#,obj#,popup&,zuadr#,buttadr#,but#,objadr#,objflag#
.|     savehelp&,savexit&,savall&,savblock&,blks#,sms#,loopz#,msms#,sme#
.|     msme#,big#,anfloadx#,mlen#,blkse#,blksa#,meml#,datx#,danf#,mdat%
.|     virtual#,g#,virtpath$,op$,virtwfile#,mp$,ext2$,fil$,pret#,pbutt#,a#
.|     l#,vext$,nam$,sfileart#,head#,fileart#,i#,isave#,bnam$,smplen#,b#,hz#
.|     per#,x#,y#,mlh#,x2#,y2#,x3#,lmin#,y3#,x4#,lma#,y4#,sret#,la#,sblock#
.|     len#,len2#,a2#,a3#,a4#,a1#,oeffne#,path$,smpnam$,vln#,virtln#,stt#
.|     c2#,c1#,vp$,virtfile$,seekz#,bytes#,smpedit&,smpfile&,smpsave&
.| Ruft auf  : infhol,markhlp,xrsrc_gaddr,rsc_draw,rsc_do,mousek,helptxt
.|     setbutton,restaura2,blkstest,makehz,maschinit,busy_mouse,fileselect
.|     sampleinf,maschruf,markhlp7,nomem,maschinit28,maschruf28,sdsave
.|     makedatum,fnamwrite,infsave,textfeld,restaura4
.| Aufruf in : drop2-1,do_smpedit-1,
inf=FALSE
nomem=FALSE
@infhol
@markhlp
vornr=nr
nr=savebloc&
~@xrsrc_gaddr(0,nr,zu%)
versatz=1
a$="SAVE"
string=LPEEK(LPEEK(zu%+24*savetxt&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=savehelp& THEN
@helptxt("SAVE")
ENDIF
UNTIL obj=savexit& OR obj=savall& OR obj=savblock&
IF obj=savall& THEN
blks=0
ENDIF
IF obj=savblock& THEN
blks=1
ENDIF
@setbutton(obj,0)
@restaura2
IF obj<>savexit& THEN
@blkstest
@makehz
IF big=0 THEN
IF blks=0 THEN
anfloadx=@malloc(mlen+&H200,1)
ELSE
anfloadx=@malloc((blkse-blksa)+&H200,1)
ENDIF
ELSE
IF blks=0 THEN
anfloadx=meml
ELSE
anfloadx=blksa
ENDIF
ENDIF
IF anfloadx<>0 AND anfloadx<>-1 THEN
IF big=0 THEN
datx=((INT(anfloadx/mbit))*mbit)+mbit
ELSE
datx=anfloadx
ENDIF
danf=mdat%
@busy_mouse
IF virtual=TRUE THEN
g=RINSTR(virtpath$,"\")
IF g>0 THEN
op$=LEFT$(virtpath$,g)
ENDIF
IF virtwfile=TRUE THEN
mp$=""
ENDIF
ENDIF
@fileselect(op$+"*."+ext2$,mp$,"SAVE SAMPLE:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 THEN
IF blks=0 THEN
a=meml
l=mlen
IF virtual=TRUE THEN
a=0
l=vmem
ENDIF
ELSE
a=blksa
l=blkse-blksa
ENDIF
vext$=ext2$
IF vext$="*" THEN
IF dig24=FALSE THEN
vext$="S16"
ELSE
vext$="S24"
ENDIF
ENDIF
IF INSTR(nam$,".")=0 THEN
nam$=nam$+"."+vext$
ENDIF
@headart
IF sfileart=0 THEN
inf=FALSE
@alerts(10)
ELSE
fileart=sfileart
isave=TRUE
bnam$=nam$
smplen=l
@sampleinf
isave=FALSE
ENDIF
IF inf=TRUE THEN
b=datx
IF big=0 THEN
@maschruf1
ENDIF
hz=INT(hz/100)*100
@headmake
a=ASC(LEFT$(fil$,1))-64
oeffne=FALSE
IF DFREE(a)>(head+(blkse-blksa)) THEN
oeffne=TRUE
ELSE
IF virtual=FALSE THEN
@nomem
ENDIF
ENDIF
IF oeffne=TRUE THEN
IF virtual=FALSE THEN
IF blks=0 THEN
len=mlen
ELSE
len=blkse-blksa
ENDIF
IF fileart=3 THEN
@maschruf28(datx,len)
ENDIF
IF len>0 THEN
a=ASC(LEFT$(fil$,1))-64
IF fileart=5 OR fileart=6 THEN
IF DFREE(a)>=(head+len*2) THEN
@sdsave
ELSE
@nomem
ENDIF
ELSE
IF DFREE(a)>=(head+len) THEN
OPEN "O",#1,fil$
BPUT #1,danf,head
BPUT #1,datx,len
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
path$=fil$
smpnam$=nam$
smplen=len
@makedatum
@fnamwrite
IF nomem=FALSE THEN
@infsave
ENDIF
ELSE
@alerts(16)
ENDIF
IF fileart=3 THEN
@maschruf28(datx,len)
ENDIF
ELSE
'
IF nomem=FALSE THEN
@infsave
ENDIF
'
IF blks=0 THEN
vln=virtln
stt=0
ELSE
vln=c2-c1
stt=c1
ENDIF
IF vln>0 THEN
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=vln THEN
IF virtwfile=TRUE THEN
a=RINSTR(virtpath$,"\")
IF a>0 THEN
vp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
ELSE
vp$=virtpath$
ENDIF
IF EXIST(vp$)=FALSE THEN
vp$=virtpath$
ENDIF
OPEN "I",#1,vp$
OPEN "O",#2,fil$
'
IF sfileart<>ldfileart THEN
IF vln>ldhead THEN
stt=stt+ldhead
vln=vln-ldhead
ENDIF
@headmake2
BPUT #2,danf,head
ENDIF
'
vln=INT(vln/mbit)*mbit
seekz=INT(stt/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
IF seekz>0 THEN
SEEK #1,seekz
ENDIF
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF sfileart=3 AND sfileart<>ldfileart THEN
@maschruf28(meml,bytes)
ENDIF
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #1
CLOSE #2
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
ELSE
@alerts(16)
ENDIF
ENDIF
ENDIF
IF nr=smpedit& THEN
@textfeld(smpfile&,nam$+CHR$(0),1)
ENDIF
ENDIF
ENDIF
ENDIF
IF big=0 AND anfloadx<>0 THEN
~MFREE(anfloadx)
ENDIF
'    @restaura4
ENDIF
IF nr=smpedit& THEN
@setbutton(smpsave&,0)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE blklfrag
.| Glob. Var.: vornr#,nr#,savebloc&,zu%,versatz#,a$,string#,savetxt&,it#
.|     obj#,popup&,zuadr#,buttadr#,but#,objadr#,objflag#,savehelp&,savexit&
.|     savall&,savblock&,blks#
.| Ruft auf  : markhlp,xrsrc_gaddr,rsc_draw,rsc_do,mousek,helptxt,setbutton
.|     rsc_back
.| Aufruf in : ldhlp-1,
@markhlp
vornr=nr
nr=savebloc&
~@xrsrc_gaddr(0,nr,zu%)
versatz=1
a$="LOAD"
string=LPEEK(LPEEK(zu%+24*savetxt&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=savehelp& THEN
@helptxt("LOAD")
ENDIF
UNTIL obj=savexit& OR obj=savall& OR obj=savblock&
IF obj=savall& THEN
blks=0
ENDIF
IF obj=savblock& THEN
blks=1
ENDIF
@setbutton(obj,0)
@rsc_back(nr)
nr=vornr
'  @restaura2
RETURN
'
> PROCEDURE clearfsel
.| Glob. Var.: fsbut1&,fsbut2&,fsbut3&,fsbut4&,fsbut5&,fsbut6&,fsbut7&
.|     fsbut8&,fsbut9&,fsbut10&,fsbut11&,fsbut12&,fsbut13&,fsbut14&,fsbut15&
.|     fstxt1&,fstxt2&,fstxt3&,fstxt4&,fstxt5&,fstxt6&,fstxt7&,fstxt8&
.|     fstxt9&,fstxt10&,fstxt11&,fstxt12&,fstxt13&,fstxt14&,fstxt15&
.| Ruft auf  : setbutton,textfeld
.| Aufruf in : getsel5-1,fsnrset-1,newfsel-5,
@setbutton(fsbut1&,0)
@setbutton(fsbut2&,0)
@setbutton(fsbut3&,0)
@setbutton(fsbut4&,0)
@setbutton(fsbut5&,0)
@setbutton(fsbut6&,0)
@setbutton(fsbut7&,0)
@setbutton(fsbut8&,0)
@setbutton(fsbut9&,0)
@setbutton(fsbut10&,0)
@setbutton(fsbut11&,0)
@setbutton(fsbut12&,0)
@setbutton(fsbut13&,0)
@setbutton(fsbut14&,0)
@setbutton(fsbut15&,0)
@textfeld(fsbut1&,CHR$(0),1)
@textfeld(fsbut2&,CHR$(0),1)
@textfeld(fsbut3&,CHR$(0),1)
@textfeld(fsbut4&,CHR$(0),1)
@textfeld(fsbut5&,CHR$(0),1)
@textfeld(fsbut6&,CHR$(0),1)
@textfeld(fsbut7&,CHR$(0),1)
@textfeld(fsbut8&,CHR$(0),1)
@textfeld(fsbut9&,CHR$(0),1)
@textfeld(fsbut10&,CHR$(0),1)
@textfeld(fsbut11&,CHR$(0),1)
@textfeld(fsbut12&,CHR$(0),1)
@textfeld(fsbut13&,CHR$(0),1)
@textfeld(fsbut14&,CHR$(0),1)
@textfeld(fsbut15&,CHR$(0),1)
@textfeld(fstxt1&,CHR$(0),1)
@textfeld(fstxt2&,CHR$(0),1)
@textfeld(fstxt3&,CHR$(0),1)
@textfeld(fstxt4&,CHR$(0),1)
@textfeld(fstxt5&,CHR$(0),1)
@textfeld(fstxt6&,CHR$(0),1)
@textfeld(fstxt7&,CHR$(0),1)
@textfeld(fstxt8&,CHR$(0),1)
@textfeld(fstxt9&,CHR$(0),1)
@textfeld(fstxt10&,CHR$(0),1)
@textfeld(fstxt11&,CHR$(0),1)
@textfeld(fstxt12&,CHR$(0),1)
@textfeld(fstxt13&,CHR$(0),1)
@textfeld(fstxt14&,CHR$(0),1)
@textfeld(fstxt15&,CHR$(0),1)
RETURN
'
> PROCEDURE clearfsel2
.| Glob. Var.: i#,flist#,wurl#
.| Felder    : dbank$(),dbank2$(),wurlnr#()
.| Aufruf in : getsel5-1,
FOR i=1 TO flist
dbank$(i)=""
dbank2$(i)=""
NEXT i
RETURN
'
> PROCEDURE getsel
.| Glob. Var.: b$,flist#,op$
.| Felder    : dbank$(),dbank2$()
.| Aufruf in : getsel5-4,
LOCAL g,a$
g=FALSE
a$=RIGHT$(b$,5)
a$=LEFT$(a$,LEN(a$)-1)
IF a$=".S16" THEN
g=TRUE
ENDIF
IF a$=".S24" THEN
g=TRUE
ENDIF
IF a$=".WAV" THEN
g=TRUE
ENDIF
IF a$=".AU" THEN
g=TRUE
ENDIF
IF a$=".SND" THEN
g=TRUE
ENDIF
IF a$=".SMP" THEN
g=TRUE
ENDIF
IF a$=".AVR" THEN
g=TRUE
ENDIF
IF a$=".AIF" THEN
g=TRUE
ENDIF
IF a$=".SD" THEN
g=TRUE
ENDIF
IF g=TRUE THEN
INC flist
dbank$(flist)=b$
dbank2$(flist)=op$+b$
ENDIF
RETURN
'
> PROCEDURE getsel2
LOCAL gl,mbv
.| Glob. Var.: flist#,j#,fsz#,lmax4#,i3#,wurl#,i#,fsmplay#,b$,fsbut1&
.|     fsbut2&,fsbut3&,fsbut4&,fsbut5&,fsbut6&,fsbut7&,fsbut8&,fsbut9&
.|     fsbut10&,fsbut11&,fsbut12&,fsbut13&,fsbut14&,fsbut15&,i2#,bloopz#,a#
.|     c$,src$,a$,fstxt1&,fstxt2&,fstxt3&,fstxt4&,fstxt5&,fstxt6&,fstxt7&
.|     fstxt8&,fstxt9&,fstxt10&,fstxt11&,fstxt12&,fstxt13&,fstxt14&,fstxt15&
.| Felder    : wurlnr#(),dbank$(),dbank2$()
.| Ruft auf  : textfeld
.| Aufruf in : getsel5-2,fsnrset-1,newfsel-5,
IF fsz<0 THEN
fsz=0
ENDIF
IF fsmplay=FALSE THEN
mbv=flist
ELSE
mbv=wurl
ENDIF
IF mbv>0 THEN
j=fsz+1
'
IF j+14>mbv THEN
j=mbv-14
ENDIF
'
IF j<1 THEN
j=1
ENDIF
gl=j+14
IF mbv<(j+14) THEN
gl=mbv-j+1
ENDIF
IF gl<1 THEN
gl=1
ENDIF
mboxa=j-1
FOR i=j TO gl
IF i<=mbv THEN
IF fsmplay=FALSE THEN
b$=dbank$(i)
ELSE
IF mbank$(i)<>"" AND i<=wurl THEN
b$=mbank$(i)
ELSE
b$=""
ENDIF
ENDIF
IF fsmplay=FALSE OR (fsmplay=TRUE AND mbank$(i)<>"" AND b$<>"") THEN
IF i=j THEN
@textfeld(fsbut1&,b$,1)
ENDIF
IF i=j+1 THEN
@textfeld(fsbut2&,b$,1)
ENDIF
IF i=j+2 THEN
@textfeld(fsbut3&,b$,1)
ENDIF
IF i=j+3 THEN
@textfeld(fsbut4&,b$,1)
ENDIF
IF i=j+4 THEN
@textfeld(fsbut5&,b$,1)
ENDIF
IF i=j+5 THEN
@textfeld(fsbut6&,b$,1)
ENDIF
IF i=j+6 THEN
@textfeld(fsbut7&,b$,1)
ENDIF
IF i=j+7 THEN
@textfeld(fsbut8&,b$,1)
ENDIF
IF i=j+8 THEN
@textfeld(fsbut9&,b$,1)
ENDIF
IF i=j+9 THEN
@textfeld(fsbut10&,b$,1)
ENDIF
IF i=j+10 THEN
@textfeld(fsbut11&,b$,1)
ENDIF
IF i=j+11 THEN
@textfeld(fsbut12&,b$,1)
ENDIF
IF i=j+12 THEN
@textfeld(fsbut13&,b$,1)
ENDIF
IF i=j+13 THEN
@textfeld(fsbut14&,b$,1)
ENDIF
IF i=j+14 THEN
@textfeld(fsbut15&,b$,1)
ENDIF
'
IF fsmplay=FALSE THEN
b$=dbank2$(i)
ELSE
IF mbank$(i)<>"" AND i<=wurl THEN
b$=mbank2$(i)
ELSE
b$=""
ENDIF
ENDIF
IF b$<>"" THEN
b$=LEFT$(b$,INSTR(b$,"."))+"INF"+CHR$(0)
IF EXIST(b$)=TRUE THEN
OPEN "I",#2,b$
@loadloops(FALSE)
c$=""
src$=""
REPEAT
INPUT #2,a$
c$=c$+a$
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
c$=c$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
REPEAT
INPUT #2,a$
src$=src$+a$
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
src$=src$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
CLOSE #2
a$=""
IF c$<>"" AND c$<>CHR$(0) THEN
IF RIGHT$(c$,1)=CHR$(0) THEN
c$=LEFT$(c$,LEN(c$)-1)
ENDIF
a$=c$
ENDIF
IF src$<>"" AND src$<>CHR$(0) THEN
IF RIGHT$(src$,1)=CHR$(0) THEN
src$=LEFT$(src$,LEN(src$)-1)
ENDIF
IF LEN(a$)>0 THEN
a$=a$+","
ENDIF
a$=a$+src$
ENDIF
IF a$<>"" THEN
IF bigfoot=FALSE THEN
nfstl=60
ELSE
nfstl=98
ENDIF
IF LEN(a$)>nfstl THEN
a$=LEFT$(a$,nfstl)
ENDIF
a$=a$+CHR$(0)
IF i=j THEN
@textfeld(fstxt1&,a$,1)
ENDIF
IF i=j+1 THEN
@textfeld(fstxt2&,a$,1)
ENDIF
IF i=j+2 THEN
@textfeld(fstxt3&,a$,1)
ENDIF
IF i=j+3 THEN
@textfeld(fstxt4&,a$,1)
ENDIF
IF i=j+4 THEN
@textfeld(fstxt5&,a$,1)
ENDIF
IF i=j+5 THEN
@textfeld(fstxt6&,a$,1)
ENDIF
IF i=j+6 THEN
@textfeld(fstxt7&,a$,1)
ENDIF
IF i=j+7 THEN
@textfeld(fstxt8&,a$,1)
ENDIF
IF i=j+8 THEN
@textfeld(fstxt9&,a$,1)
ENDIF
IF i=j+9 THEN
@textfeld(fstxt10&,a$,1)
ENDIF
IF i=j+10 THEN
@textfeld(fstxt11&,a$,1)
ENDIF
IF i=j+11 THEN
@textfeld(fstxt12&,a$,1)
ENDIF
IF i=j+12 THEN
@textfeld(fstxt13&,a$,1)
ENDIF
IF i=j+13 THEN
@textfeld(fstxt14&,a$,1)
ENDIF
IF i=j+14 THEN
@textfeld(fstxt15&,a$,1)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
NEXT i
IF fsmplay=FALSE THEN
@fsbutset
ENDIF
ENDIF
RETURN
'
> PROCEDURE getsel3
.| Glob. Var.: fsmplay#,obj#,k#,k2#,vfil$,op$
.| Felder    : dbank$()
.| Ruft auf  : setbutton
.| Aufruf in : newfsel-16,
IF fsmplay=TRUE THEN
@setbutton(obj,0)
ENDIF
IF nfk<>0 AND nfk2<>0 AND obj<>nfk2 THEN
@setbutton(nfk2,0)
ENDIF
IF obj=nfk2 AND nfk<>0 AND dbank$(nfk)<>"" AND fsmplay=FALSE THEN
@setbutton(obj,1)
ENDIF
nfk2=obj
IF dbank$(nfk)<>"" AND nfk<>0 THEN
vfil$=op$+dbank$(nfk)
ELSE
vfil$=""
ENDIF
RETURN
'
> PROCEDURE getsel4
.| Glob. Var.: fsel$,a$,op$,fsotxt&
.| Ruft auf  : textfeld
.| Aufruf in : getsel5-1,
IF EXIST(fsel$)=TRUE THEN
a$="FILESELECT-DATEI -->"+fsel$
ELSE
a$=op$
ENDIF
IF LEN(a$)>50 THEN
a$="..."+RIGHT$(a$,47)
ENDIF
a$=a$+CHR$(0)
nfil$=a$
@textfeld(fsotxt&,a$,1)
RETURN
'
> PROCEDURE getsel5
.| Glob. Var.: flist#,fsel$,a$,nf$,op$,a#,dta#,pdta#,b$,k#
.| Ruft auf  : clearfsel,clearfsel2,getsel4,getsel,getsel2
.| Aufruf in : newfsel-6,
LOCAL g
flist=0
@clearfsel2
g=FALSE
IF EXIST(fsel$)=TRUE THEN
g=TRUE
OPEN "I",#1,fsel$
IF LOF(#1)>0 THEN
g=TRUE
WHILE EOF(#1)=FALSE
INPUT #1,a$
nf$=a$+CHR$(0)
op$=LEFT$(a$,LEN(a$)-3)
a=GEMDOS(78,L:VARPTR(nf$),0)
IF a=0 THEN
dta=GEMDOS(47)
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WHILE GEMDOS(79)=0
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WEND
ENDIF
WEND
ENDIF
CLOSE #1
@getsel2
ENDIF
IF g=FALSE THEN
nf$=op$+"*.*"+CHR$(0)
a=GEMDOS(78,L:VARPTR(nf$),0)
IF a=0 THEN
dta=GEMDOS(47)
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WHILE GEMDOS(79)=0
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WEND
@getsel2
ENDIF
ENDIF
nfk=0
RETURN
'
> PROCEDURE getsel6
LOCAL g
ERASE dbank$()
ERASE dbank2$()
@clearfsel
@getsel4
flist=0
g=FALSE
IF EXIST(fsel$)=TRUE THEN
g=TRUE
OPEN "I",#1,fsel$
IF LOF(#1)>0 THEN
g=TRUE
WHILE EOF(#1)=FALSE
INPUT #1,a$
nf$=a$+CHR$(0)
op$=LEFT$(a$,LEN(a$)-3)
a=GEMDOS(78,L:VARPTR(nf$),0)
IF a=0 THEN
dta=GEMDOS(47)
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel7
WHILE GEMDOS(79)=0
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel7
WEND
ENDIF
WEND
ENDIF
CLOSE #1
ENDIF
IF g=FALSE THEN
nf$=op$+"*.*"+CHR$(0)
a=GEMDOS(78,L:VARPTR(nf$),0)
IF a=0 THEN
dta=GEMDOS(47)
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WHILE GEMDOS(79)=0
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel7
WEND
ENDIF
ENDIF
nfk=0
IF flist>=fsl THEN
DIM dbank$(flist)
DIM dbank2$(flist)
ELSE
DIM dbank$(fsl)
DIM dbank2$(fsl)
ENDIF
RETURN
'
> PROCEDURE getsel7
LOCAL g,a$
g=FALSE
a$=RIGHT$(b$,5)
a$=LEFT$(a$,LEN(a$)-1)
IF a$=".S16" THEN
g=TRUE
ENDIF
IF a$=".S24" THEN
g=TRUE
ENDIF
IF a$=".WAV" THEN
g=TRUE
ENDIF
IF a$=".AU" THEN
g=TRUE
ENDIF
IF a$=".SND" THEN
g=TRUE
ENDIF
IF a$=".SMP" THEN
g=TRUE
ENDIF
IF a$=".AVR" THEN
g=TRUE
ENDIF
IF a$=".AIF" THEN
g=TRUE
ENDIF
IF a$=".SD" THEN
g=TRUE
ENDIF
IF g=TRUE THEN
INC flist
ENDIF
RETURN
'
> PROCEDURE fsnrset
.| Ruft auf  : clearfsel,getsel2
.| Aufruf in : button-2,newfsel-2,
@clearfsel
@getsel2
RETURN
'
> PROCEDURE fsbutset
IF fsmplay=FALSE THEN
IF mfsz<>0 THEN
a=mfsz-fsz
IF a>=1 AND a<=15 THEN
IF a=1 THEN
obj=fsbut1&
ENDIF
IF a=2 THEN
obj=fsbut2&
ENDIF
IF a=3 THEN
obj=fsbut3&
ENDIF
IF a=4 THEN
obj=fsbut4&
ENDIF
IF a=5 THEN
obj=fsbut5&
ENDIF
IF a=6 THEN
obj=fsbut6&
ENDIF
IF a=7 THEN
obj=fsbut7&
ENDIF
IF a=8 THEN
obj=fsbut8&
ENDIF
IF a=9 THEN
obj=fsbut9&
ENDIF
IF a=10 THEN
obj=fsbut10&
ENDIF
IF a=11 THEN
obj=fsbut11&
ENDIF
IF a=12 THEN
obj=fsbut12&
ENDIF
IF a=13 THEN
obj=fsbut13&
ENDIF
IF a=14 THEN
obj=fsbut14&
ENDIF
IF a=15 THEN
obj=fsbut15&
ENDIF
@setbutton(obj,1)
nfk=a
mfsz=fsz+nfk
nfk2=obj
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE fscalc
LOCAL a
IF fsmplay=FALSE THEN
fsz=flist/fsmax*fsz2
IF fsz2>fsmax-fstep THEN
fsz2=fsmax-fstep
@setslide2(fsslide&,fssldbut&,fsmax,fsz2,fstep)
ENDIF
IF fsz>(flist-15) THEN
fsz=flist-15
ENDIF
ELSE
fsz=wurl/fsmax*fsz2
IF fsz2>fsmax-fstep THEN
fsz2=fsmax-fstep
@setslide2(fsslide&,fssldbut&,fsmax,fsz2,fstep)
ENDIF
IF fsz>(wurl-15) THEN
fsz=wurl-15
ENDIF
ENDIF
IF fsz<0 THEN
fsz=0
ENDIF
fsz=ROUND(fsz)
@fsbutset
RETURN
'
> PROCEDURE fselslidset
@slidelen(fsslide&,fssldbut&,v,fsbr)
IF flist=0 THEN
fbbut=fsbr
ELSE
fbbut=INT(fsbr/flist*fsl)  ! Buttonbreite
ENDIF
IF fbbut>fsbr THEN
fbbut=fsbr
ENDIF
fsmax=fsbr                 ! Breite des Sliders
IF flist<=fsl THEN
fstep=0      ! Schrittweite des Sliders
fsplus=0         ! Einzelschritt
ELSE
fstep=fsmax/flist*fsl      ! Schrittweite des Sliders
fsplus=fsmax/flist         ! Einzelschritt
ENDIF
@slideinit(fsslide&,fssldbut&,fsmax,fbbut,fsz)
@setslide(fsslide&,fssldbut&,fsmax,fbbut,fsz)
fsz=0
fsz2=0
RETURN
'
> PROCEDURE mboxslidset
@slidelen(fsslide&,fssldbut&,v,fsbr)
IF wurl=0 THEN
fbbut=fsbr
ELSE
fbbut=INT(fsbr/wurl*fsl)  ! Buttonbreite
ENDIF
IF fbbut>fsbr THEN
fbbut=fsbr
ENDIF
fsmax=fsbr                 ! Breite des Sliders
IF wurl<=fsl THEN
fstep=0      ! Schrittweite des Sliders
fsplus=0         ! Einzelschritt
ELSE
fstep=fsmax/wurl*fsl      ! Schrittweite des Sliders
fsplus=fsmax/wurl         ! Einzelschritt
ENDIF
@slideinit(fsslide&,fssldbut&,fsmax,fbbut,fsz)
@setslide(fsslide&,fssldbut&,fsmax,fbbut,fsz)
fsz=0
fsz2=0
RETURN
'
> PROCEDURE ntstbut
n=0
IF obj=fsbut1& THEN
n=1
ENDIF
IF obj=fsbut2& THEN
n=2
ENDIF
IF obj=fsbut3& THEN
n=3
ENDIF
IF obj=fsbut4& THEN
n=4
ENDIF
IF obj=fsbut5& THEN
n=5
ENDIF
IF obj=fsbut6& THEN
n=6
ENDIF
IF obj=fsbut7& THEN
n=7
ENDIF
IF obj=fsbut8& THEN
n=8
ENDIF
IF obj=fsbut9& THEN
n=9
ENDIF
IF obj=fsbut10& THEN
n=10
ENDIF
IF obj=fsbut11& THEN
n=11
ENDIF
IF obj=fsbut12& THEN
n=12
ENDIF
IF obj=fsbut13& THEN
n=13
ENDIF
IF obj=fsbut14& THEN
n=14
ENDIF
IF obj=fsbut15& THEN
n=15
ENDIF
RETURN
'
> PROCEDURE newfsel
.| Glob. Var.: vornr#,nr#,fsel&,wurload#,zu%,fsmax#,lmax4#,fsslide&
.|     fssldbut&,fsz#,fsload&,fssave&,k#,wurl#,vop$,op$,vnam$,nam$,vfil$
.|     fil$,fsmplay#,fsmatic&,obj#,popup&,zuadr#,buttadr#,but#,objadr#
.|     objflag#,fshelp&,fsins&,buttflag#,fsdel&,a#,i#,fsordner&,fsadd&
.|     fsnew&,fsclf&,lfw$,mbox$,pret#,pbutt#,g#,dfil$,dfil2$,fsplay&,handle#
.|     playpos#,l#,sectors#,flen#,anspiel#,over#,fil2$,jz#,iz#,fsbut1&
.|     fsbut2&,fsbut3&,fsbut4&,fsbut5&,fsbut6&,fsbut7&,fsbut8&,fsbut9&
.|     fsbut10&,fsbut11&,fsbut12&,fsbut13&,fsbut14&,fsel$,ordner$,ext$
.|     fssldup&,slflg#,fsslddwn&,fsbut15&,fsexit&,fsok&,k2#
.| Felder    : wurlnr#(),dbank$(),dbank2$()
.| Ruft auf  : xrsrc_gaddr,slideinit,rsc_draw,setslide,setbutton,markhlp
.|     getsel5,rsc_do,mousek,readbutton,helptxt,clearfsel,getsel2,fileselect
.|     rsc_back,maschinit5,digout,maschruf5,slideup,fsnrset,slidedwn,getsel3
.| Aufruf in : ldhlp-1,
LOCAL j,g,x,y,k,v1,v2,v3,v4,nobj,ofil$,nx,ny
vornr=nr
nr=fsel&
~@xrsrc_gaddr(0,nr,zu%)
nfk=0
nfil$=""
vop$=op$
vnam$=nam$
vfil$=fil$
fsmplay=FALSE
fsbreak=FALSE
@hidetree2(fsload&,TRUE)
@hidetree2(fssave&,TRUE)
@hidetree2(fsdel&,TRUE)
@hidetree2(fsins&,FALSE)
@hidetree2(fsordner&,FALSE)
@hidetree2(fsadd&,FALSE)
@hidetree2(fsnew&,FALSE)
@hidetree2(fsok&,FALSE)
@readpos(fsotxt&)
@buttbh(fsotxt&,nx,ny)
IF bigfoot=FALSE THEN
@setpos(fsotxt&,184,by)
@setbuttbh(fsotxt&,444,ny)
ELSE
@setpos(fsotxt&,222,by)
@setbuttbh(fsotxt&,705,ny)
ENDIF
@readpos(fsexit&)
IF bigfoot=FALSE THEN
@setpos(fsexit&,520,by)
ELSE
@setpos(fsexit&,810,by)
ENDIF
@flagbutton(fstxt1&,0)
@flagbutton(fstxt2&,0)
@flagbutton(fstxt3&,0)
@flagbutton(fstxt4&,0)
@flagbutton(fstxt5&,0)
@flagbutton(fstxt6&,0)
@flagbutton(fstxt7&,0)
@flagbutton(fstxt8&,0)
@flagbutton(fstxt9&,0)
@flagbutton(fstxt10&,0)
@flagbutton(fstxt11&,0)
@flagbutton(fstxt12&,0)
@flagbutton(fstxt13&,0)
@flagbutton(fstxt14&,0)
@flagbutton(fstxt15&,0)
@flagbutton(fsexit&,1029)
@flagbutton(fsok&,1031)
@flagbutton(tfsearch&,0)
@hidetree2(tfsearch&,TRUE)
@rsc_draw(nr,0)
@analog
@digout(TRUE)
fsl=15                     ! Anzahl der lines
fsz=0
fsz2=0
mfsz=0
nfk=0
IF maxcol<>2 THEN
@textcolor(fsel&,fstxt1&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt2&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt3&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt4&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt5&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt6&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt7&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt8&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt9&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt10&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt11&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt12&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt13&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt14&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt15&,1,1,3)  !text,rahmen,fill
ENDIF
@getsel6
@getsel5
@fselslidset
@getsel2
@markhlp
@setbutton(fsmatic&,0)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
@readbutton(obj)
IF obj=fshelp& THEN
IF fsmplay=FALSE THEN
@helptxt("HYPER-FILESELECTOR")
ELSE
@helptxt("MUSICBOX")
ENDIF
ENDIF
IF obj=fsins& AND buttflag<>8 THEN
IF wurl<lmax4 THEN
INC wurl
mbank$(wurl)=dbank$(fsz+nfk)
mbank2$(wurl)=dbank2$(fsz+nfk)
ELSE
@alerts(19)
ENDIF
PAUSE 3
@setbutton(fsins&,0)
ENDIF
IF obj=fsdel& AND buttflag<>8 THEN
IF fsmplay=TRUE THEN
~@xrsrc_gaddr(0,nr,zu%)
IF wurl>0 THEN
nobj=obj
REPEAT
@mouse(x,y,k)
IF k=1 THEN
obj=OBJC_FIND(zu%,0,10,x,y)
@ntstbut
IF n>0 AND (mboxa+n)<=wurl THEN
@setbutton(obj,1)
PAUSE 10
@setbutton(obj,0)
ENDIF
ENDIF
UNTIL k=2 OR (k=1 AND n>0 AND (mboxa+n)<=wurl)
obj=nobj
IF k=1 AND n>0 AND (mboxa+n)<=wurl THEN
a=0
mbank$(mboxa+n)=""
mbank2$(mboxa+n)=""
IF (mboxa+n)<wurl THEN
FOR i=mboxa+n TO wurl
mbank$(i)=mbank$(i+1)
mbank2$(i)=mbank2$(i+1)
NEXT i
mbank$(wurl)=""
mbank2$(wurl)=""
ENDIF
DEC wurl
ENDIF
ENDIF
ENDIF
fsz=0
fsz2=0
@mboxslidset
@clearfsel
@getsel2
PAUSE 3
@setbutton(fsdel&,0)
ENDIF
IF obj=fsmatic& THEN
IF fsmplay=FALSE THEN
fsmplay=TRUE
fsz=0
fsz2=0
@mboxslidset
@readpos(fsotxt&)
@buttbh(fsotxt&,nx,ny)
IF bigfoot=FALSE THEN
@setpos(fsotxt&,10,by)
@setbuttbh(fsotxt&,618,ny)
ELSE
@setpos(fsotxt&,10,by)
@setbuttbh(fsotxt&,917,ny)
ENDIF
@readpos(fsexit&)
IF bigfoot=FALSE THEN
@setpos(fsexit&,576,by)
ELSE
@setpos(fsexit&,874,by)
ENDIF
IF EXIST(wfil$) AND wfil$<>"" THEN
a$="MUSICBOX-DATEI -->"+wfil$
IF LEN(a$)>50 THEN
a$="..."+RIGHT$(a$,47)
ENDIF
a$=a$+CHR$(0)
ELSE
a$=CHR$(0)
ENDIF
@textfeld(fsotxt&,a$,1)
@hidetree2(fsins&,TRUE)
@hidetree2(fsdel&,FALSE)
@hidetree2(fsordner&,TRUE)
@hidetree2(fsadd&,TRUE)
@hidetree2(fsload&,FALSE)
@hidetree2(fssave&,FALSE)
@flagbutton(fsexit&,1031)
@flagbutton(fsok&,0)
@hidetree2(fsok&,TRUE)
@hidetree(fsnew&,TRUE,fselbox&)
ELSE
fsmplay=FALSE
fsz=0
fsz2=0
IF wurload=TRUE THEN
wurload=FALSE
ENDIF
@fselslidset
@readpos(fsotxt&)
@buttbh(fsotxt&,nx,ny)
IF bigfoot=FALSE THEN
@setpos(fsotxt&,184,by)
@setbuttbh(fsotxt&,444,ny)
ELSE
@setpos(fsotxt&,222,by)
@setbuttbh(fsotxt&,705,ny)
ENDIF
@readpos(fsexit&)
IF bigfoot=FALSE THEN
@setpos(fsexit&,520,by)
ELSE
@setpos(fsexit&,810,by)
ENDIF
IF nfil$<>"" THEN
@textfeld(fsotxt&,nfil$,1)
ENDIF
@hidetree2(fsins&,FALSE)
@hidetree2(fsdel&,TRUE)
@hidetree2(fsordner&,FALSE)
@hidetree2(fsadd&,FALSE)
@hidetree2(fsload&,TRUE)
@hidetree2(fsnew&,FALSE)
@flagbutton(fsexit&,1029)
@flagbutton(fsok&,1031)
@hidetree2(fsok&,FALSE)
@hidetree(fssave&,TRUE,fselbox&)
ENDIF
@clearfsel
@getsel2
'        nfk=0
ENDIF
IF obj=fsload& AND buttflag<>8 THEN
@fileselect(lfw$+"*."+mbox$,"SMP16."+mbox$,"LOAD MUSICBOX:")
IF pret<>0 AND pbutt=1 THEN
IF EXIST(fil$) THEN
OPEN "I",#1,fil$
INPUT #1,v$                  ! Versionskontrolle
INPUT #1,wurl
FOR n=1 TO wurl
INPUT #1,mbank$(n)
INPUT #1,mbank2$(n)
NEXT n
CLOSE #1
wfil$=fil$
a$="MUSICBOX-DATEI -->"+wfil$
IF LEN(a$)>50 THEN
a$="..."+RIGHT$(a$,47)
ENDIF
a$=a$+CHR$(0)
@textfeld(fsotxt&,a$,1)
IF wurl<lmax4 THEN
FOR n=wurl+1 TO lmax4
mbank$(n)=""
mbank2$(n)=""
NEXT n
ENDIF
fsz=0
fsz2=0
@mboxslidset
@clearfsel
@getsel2
ENDIF
ENDIF
PAUSE 3
@setbutton(fsload&,0)
ENDIF
IF obj=fssave& AND buttflag<>8 THEN
IF wurl>0 THEN
@fileselect(lfw$+"*."+mbox$,"SMP16."+mbox$,"SAVE MUSICBOX:")
IF pret<>0 AND pbutt=1 THEN
OPEN "O",#1,fil$
PRINT #1,"STARTRACK-MUSICBOX V1.0"           ! Versionskontrolle
PRINT #1,wurl
FOR i=1 TO wurl
PRINT #1,mbank$(i)
PRINT #1,mbank2$(i)
NEXT i
CLOSE #1
wfil$=fil$
a$="MUSICBOX-DATEI -->"+wfil$
IF LEN(a$)>50 THEN
a$="..."+RIGHT$(a$,47)
ENDIF
a$=a$+CHR$(0)
@textfeld(fsotxt&,a$,1)
ENDIF
ENDIF
PAUSE 3
@setbutton(fssave&,0)
ENDIF
IF obj=fsclf& THEN
IF fsmplay=FALSE THEN
@alerts(20)
IF g=1 THEN
IF dbank$(fsz+nfk)<>"" AND nfk<>0 THEN
dfil$=dbank2$(fsz+nfk)
@headart2(dfil$)
IF sfileart<>0 THEN
IF EXIST(dfil$) AND dfil$<>"" THEN
KILL dfil$
ENDIF
dfil2$=LEFT$(dfil$,INSTR(dfil$,"."))+"INF"
IF EXIST(dfil2$) AND dfil$<>"" THEN
KILL dfil2$
ENDIF
dfil2$=LEFT$(dfil$,INSTR(dfil$,"."))+"PBF"
IF EXIST(dfil2$) AND dfil$<>"" THEN
KILL dfil2$
ENDIF
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@clearfsel
fsz=0
fsz2=0
@getsel6
@getsel5
@fselslidset
@getsel2
ENDIF
ENDIF
ENDIF
ELSE
@alerts(21)
IF g=1 THEN
FOR i=1 TO wurl
mbank$(i)=""
mbank2$(i)=""
NEXT i
wurl=0
fsz=0
fsz2=0
@mboxslidset
@clearfsel
@getsel2
wfil$=""
a$=CHR$(0)
@textfeld(fsotxt&,a$,1)
ENDIF
ENDIF
PAUSE 3
@setbutton(fsclf&,0)
ENDIF
IF obj=fswait& OR obj=fsplay& OR obj=fslplay& THEN
IF nr=fsel& AND (obj=fswait& AND pwait=FALSE) THEN
pwait=TRUE
ENDIF
fsobj=obj
IF fsmplay=FALSE THEN
IF dbank$(actfsel)<>"" AND nfk<>0 THEN
vfil$=dbank2$(actfsel)
ELSE
vfil$=""
ENDIF
IF EXIST(vfil$) AND vfil$<>"" THEN
over=0
l=0
fil2$=fil$
fil$=vfil$
@tstfile
playpos=head
anspiel=10*hz*mbit        ! 10 Sekunden anzuspielende Sektoren
handle=GEMDOS(61,L:VARPTR(vfil$),0)
IF handle>0 THEN
IF sectors>anspiel AND fsobj=fslplay& THEN
sectors=anspiel
ENDIF
@maschrufb5
~GEMDOS(62,handle)
ENDIF
fil$=fil2$
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(fsobj,0)
ENDIF
ENDIF
IF fsmplay=TRUE THEN
jz=0
fsz=0
fsz2=0
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@clearfsel
@getsel2
FOR iz=1 TO wurl
IF mbank$(iz)<>"" THEN
vfil$=mbank2$(iz)
ELSE
vfil$=""
ENDIF
IF EXIST(vfil$) AND vfil$<>"" THEN
INC jz
IF jz=1 THEN
@setbutton(fsbut1&,1)
ENDIF
IF jz=2 THEN
@setbutton(fsbut1&,0)
@setbutton(fsbut2&,1)
ENDIF
IF jz=3 THEN
@setbutton(fsbut2&,0)
@setbutton(fsbut3&,1)
ENDIF
IF jz=4 THEN
@setbutton(fsbut3&,0)
@setbutton(fsbut4&,1)
ENDIF
IF jz=5 THEN
@setbutton(fsbut4&,0)
@setbutton(fsbut5&,1)
ENDIF
IF jz=6 THEN
@setbutton(fsbut5&,0)
@setbutton(fsbut6&,1)
ENDIF
IF jz=7 THEN
@setbutton(fsbut6&,0)
@setbutton(fsbut7&,1)
ENDIF
IF jz=8 THEN
@setbutton(fsbut7&,0)
@setbutton(fsbut8&,1)
ENDIF
IF jz=9 THEN
@setbutton(fsbut8&,0)
@setbutton(fsbut9&,1)
ENDIF
IF jz=10 THEN
@setbutton(fsbut9&,0)
@setbutton(fsbut10&,1)
ENDIF
IF jz=11 THEN
@setbutton(fsbut10&,0)
@setbutton(fsbut11&,1)
ENDIF
IF jz=12 THEN
@setbutton(fsbut11&,0)
@setbutton(fsbut12&,1)
ENDIF
IF jz=13 THEN
@setbutton(fsbut12&,0)
@setbutton(fsbut13&,1)
ENDIF
IF jz=14 THEN
@setbutton(fsbut13&,0)
@setbutton(fsbut14&,1)
ENDIF
IF jz>14 THEN
IF iz<wurl THEN
INC fsz
@slidedwn2(fsslide&,fssldbut&,fsmax,fstep,fsplus,fsz2,slflg)
@clearfsel
@getsel2
@setbutton(fsbut14&,1)
ELSE
INC fsz
@setbutton(fsbut14&,0)
@setbutton(fsbut15&,1)
ENDIF
ENDIF
over=0
l=0
fil2$=fil$
fil$=vfil$
@tstfile
playpos=head
anspiel=10*hz*mbit        ! 10 Sekunden anzuspielende Sektoren
handle=GEMDOS(61,L:VARPTR(vfil$),0)
IF handle>0 THEN
IF sectors>anspiel AND fsobj=fslplay& THEN
sectors=anspiel
ENDIF
@maschrufb5
~GEMDOS(62,handle)
ENDIF
fil$=fil2$
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
EXIT IF fsbreak=TRUE
NEXT iz
fsbreak=FALSE
a$=SPACE$(11)+CHR$(0)
@textfeld(fstime&,a$,1)
fsz=0
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@clearfsel
@getsel2
ENDIF
@setbutton(fsobj,0)
ENDIF
IF obj=fsnew& AND buttflag<>8 THEN
OPEN "O",#1,fsel$
CLOSE #1
@setbutton(fsnew&,0)
fsmplay=FALSE
@setbutton(fsmatic&,0)
@clearfsel
fsz=0
fsz2=0
@getsel6
@getsel5
@fselslidset
@getsel2
ENDIF
IF obj=fsadd& AND buttflag<>8 THEN
IF EXIST(fsel$)=FALSE THEN
OPEN "O",#1,fsel$
CLOSE #1
ENDIF
OPEN "U",#1,fsel$
a=LOF(#1)
SEEK #1,a
PRINT #1,ordner$+"*.*"
CLOSE #1
@setbutton(fsadd&,0)
fsmplay=FALSE
@setbutton(fsmatic&,0)
@clearfsel
fsz=0
fsz2=0
@getsel6
@getsel5
@fselslidset
@getsel2
ENDIF
IF obj=fsordner& AND buttflag<>8 THEN
fsmplay=FALSE
@setbutton(fsmatic&,0)
@fileselect(op$+"*."+ext$,"","PATH:")
@setbutton(obj,0)
IF pret<>0 AND pbutt=1 THEN
op$=ordner$
ENDIF
ENDIF
IF obj=fssldup& THEN
IF fsz2>0 THEN
@slideup2(fsslide&,fssldbut&,fsmax,fsplus,fsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@fscalc
@getsel2
ENDIF
ENDIF
@setbutton(fssldup&,0)
ENDIF
IF obj=fsslddwn& THEN
IF fsz2+0.00001<(fsmax-fstep) THEN
@slidedwn2(fsslide&,fssldbut&,fsmax,fstep,fsplus,fsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@fscalc
@getsel2
ENDIF
ENDIF
@setbutton(fsslddwn&,0)
ENDIF
IF fsmplay=FALSE THEN
@ntstbut
IF n>0 THEN
actfsel=fsz+n
@getsel3
nfk=n
mfsz=fsz+nfk
ENDIF
ELSE
@ntstbut
IF n>0 THEN
@setbutton(obj,0)
ENDIF
ENDIF
IF obj=fsstop& OR obj=fsend& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=fsexit& OR obj=fsok& OR nfk<>0
IF flist>=nfk THEN
IF nfk<>0 THEN
IF dbank$(nfk)="" THEN
@setbutton(obj,0)
@getsel3
nfk=0
ENDIF
ENDIF
ELSE
@setbutton(obj,0)
ENDIF
IF nfk=0 AND obj=fsok& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=fsexit& OR (nfk<>0 AND obj=fsok& AND mfsz<=flist)
IF obj<>0 THEN
@setbutton(obj,0)
ENDIF
IF nfk2<>0 THEN
@setbutton(nfk2,0)
ENDIF
IF fsmplay=FALSE AND obj=fsok& AND dbank$(nfk)<>"" AND nfk<>0 THEN
fil$=dbank2$(fsz+nfk)
nam$=dbank$(fsz+nfk)
a=INSTR(fil$,nam$)
ordner$=LEFT$(fil$,a-1)
pret=1
pbutt=1
ELSE
pret=0
pbutt=0
ENDIF
@rsc_back(nr)
@digout(FALSE)
nr=vornr
obj=0
'  op$=vop$
'  nam$=vnam$
'  fil$=vfil$
RETURN
'
> PROCEDURE searchcom(v)
LOCAL a,i2,i3,a$,a2$,b$,c$,src$
IF trkcom$(v)="" THEN
b$=trkpath$(v)
b$=LEFT$(b$,INSTR(b$,"."))+"INF"+CHR$(0)
IF EXIST(b$)=TRUE THEN
OPEN "I",#2,b$
@loadloops(FALSE)
c$=""
src$=""
REPEAT
INPUT #2,a$
c$=c$+a$
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
c$=c$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
REPEAT
INPUT #2,a$
src$=src$+a$
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
src$=src$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
CLOSE #2
a$=""
IF c$<>"" AND c$<>CHR$(0) THEN
IF RIGHT$(c$,1)=CHR$(0) THEN
c$=LEFT$(c$,LEN(c$)-1)
ENDIF
a$=c$
ENDIF
IF src$<>"" AND src$<>CHR$(0) THEN
IF RIGHT$(src$,1)=CHR$(0) THEN
src$=LEFT$(src$,LEN(src$)-1)
ENDIF
IF LEN(a$)>0 THEN
a$=a$+","
ENDIF
a$=a$+src$
ENDIF
IF LEN(a$)>60 THEN
a$=LEFT$(a$,60)
ENDIF
trkcom$(v)=a$
ENDIF
ENDIF
RETURN
'
> PROCEDURE tfsgetsel1
LOCAL i,fz,i3
ERASE trktnr()
DIM trktnr(tflist)     ! Nummer in der Fileliste
fz=0
IF sabc=FALSE THEN
FOR i=1 TO trkvmax
a=trkpnt(i)
IF a<>0 THEN
REPEAT
IF trkfn$(a)<>"" AND trkch(a)<>0 THEN
INC fz
trktnr(fz)=a
a=trknext(a)
ENDIF
UNTIL a=0 OR trkch(a)=0 OR a>tflist
ENDIF
NEXT i
ELSE
'
'
ENDIF
tflist=fz
FOR i=1 TO tflist
i3=trktnr(i)
@searchcom(i3)
NEXT i
RETURN
'
> PROCEDURE tfsgetsel2
LOCAL i,j,gl,i3
IF tflist>0 THEN
j=tfsz+1
IF j+14>tflist THEN
j=tflist-14
ENDIF
IF j<1 THEN
j=1
ENDIF
i3=tfsz
gl=j+14
IF tflist<(j+14) THEN
gl=tflist-j+1
ENDIF
IF gl<1 THEN
gl=1
ENDIF
FOR i=j TO gl
IF i<=tflist THEN
i3=trktnr(i)
b$=trkfn$(i3)+CHR$(0)
IF LEN(b$)>13 THEN
b$=LEFT$(b$,12)+CHR$(0)
ENDIF
IF i=j THEN
@textfeld(fsbut1&,b$,1)
ENDIF
IF i=j+1 THEN
@textfeld(fsbut2&,b$,1)
ENDIF
IF i=j+2 THEN
@textfeld(fsbut3&,b$,1)
ENDIF
IF i=j+3 THEN
@textfeld(fsbut4&,b$,1)
ENDIF
IF i=j+4 THEN
@textfeld(fsbut5&,b$,1)
ENDIF
IF i=j+5 THEN
@textfeld(fsbut6&,b$,1)
ENDIF
IF i=j+6 THEN
@textfeld(fsbut7&,b$,1)
ENDIF
IF i=j+7 THEN
@textfeld(fsbut8&,b$,1)
ENDIF
IF i=j+8 THEN
@textfeld(fsbut9&,b$,1)
ENDIF
IF i=j+9 THEN
@textfeld(fsbut10&,b$,1)
ENDIF
IF i=j+10 THEN
@textfeld(fsbut11&,b$,1)
ENDIF
IF i=j+11 THEN
@textfeld(fsbut12&,b$,1)
ENDIF
IF i=j+12 THEN
@textfeld(fsbut13&,b$,1)
ENDIF
IF i=j+13 THEN
@textfeld(fsbut14&,b$,1)
ENDIF
IF i=j+14 THEN
@textfeld(fsbut15&,b$,1)
ENDIF
'
a$=trkcom$(i3)
a2$="000"+STR$(trkch(i3))
a$="T"+RIGHT$(a2$,3)+" "+a$
IF bigfoot=FALSE THEN
nfstl=60
ELSE
nfstl=98
ENDIF
IF LEN(a$)>nfstl THEN
a$=LEFT$(a$,nfstl)
ENDIF
a$=a$+CHR$(0)
IF i=j THEN
@textfeld(fstxt1&,a$,1)
ENDIF
IF i=j+1 THEN
@textfeld(fstxt2&,a$,1)
ENDIF
IF i=j+2 THEN
@textfeld(fstxt3&,a$,1)
ENDIF
IF i=j+3 THEN
@textfeld(fstxt4&,a$,1)
ENDIF
IF i=j+4 THEN
@textfeld(fstxt5&,a$,1)
ENDIF
IF i=j+5 THEN
@textfeld(fstxt6&,a$,1)
ENDIF
IF i=j+6 THEN
@textfeld(fstxt7&,a$,1)
ENDIF
IF i=j+7 THEN
@textfeld(fstxt8&,a$,1)
ENDIF
IF i=j+8 THEN
@textfeld(fstxt9&,a$,1)
ENDIF
IF i=j+9 THEN
@textfeld(fstxt10&,a$,1)
ENDIF
IF i=j+10 THEN
@textfeld(fstxt11&,a$,1)
ENDIF
IF i=j+11 THEN
@textfeld(fstxt12&,a$,1)
ENDIF
IF i=j+12 THEN
@textfeld(fstxt13&,a$,1)
ENDIF
IF i=j+13 THEN
@textfeld(fstxt14&,a$,1)
ENDIF
IF i=j+14 THEN
@textfeld(fstxt15&,a$,1)
ENDIF
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE tfsgetsel3
LOCAL i3
IF tnfk<>0 AND tnfk2<>0 AND obj<>tnfk2 THEN
@setbutton(tnfk2,0)
ENDIF
IF (tnfk+tfsz)>tflist THEN
@setbutton(obj,0)
tnfk=0
ENDIF
IF obj=tnfk2 AND tnfk<>0 THEN
IF (tnfk+tfsz)<=tflist THEN
i3=trktnr(tnfk+tfsz)
IF trkch(i3)<>0 THEN
@setbutton(obj,1)
ENDIF
ENDIF
ENDIF
tnfk2=obj
RETURN
'
> PROCEDURE tfsgetsel4
IF (tfso2+tfsz)<=tflist THEN
@trkcomin
tnfk2=tfso2
tmfsz2=tfsz+tnfk2
ELSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE tfsgetsel5
IF (tfso+tfsz)<=tflist THEN
@tfsgetsel3
tnfk=tfso
tmfsz=tfsz+tnfk
ELSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE tfscalc
LOCAL a
tfsz=tflist/tfsmax*tfsz2
IF tfsz2>tfsmax-tfstep THEN
tfsz2=tfsmax-tfstep
@setslide2(fsslide&,fssldbut&,tfsmax,tfsz2,tfstep)
ENDIF
IF tfsz>(tflist-14) THEN
tfsz=tflist-15
ENDIF
IF tfsz<0 THEN
tfsz=0
ENDIF
tfsz=ROUND(tfsz)
IF tmfsz<>0 THEN
a=tmfsz-tfsz
IF a>=1 AND a<=15 THEN
IF a=1 THEN
obj=fsbut1&
ENDIF
IF a=2 THEN
obj=fsbut2&
ENDIF
IF a=3 THEN
obj=fsbut3&
ENDIF
IF a=4 THEN
obj=fsbut4&
ENDIF
IF a=5 THEN
obj=fsbut5&
ENDIF
IF a=6 THEN
obj=fsbut6&
ENDIF
IF a=7 THEN
obj=fsbut7&
ENDIF
IF a=8 THEN
obj=fsbut8&
ENDIF
IF a=9 THEN
obj=fsbut9&
ENDIF
IF a=10 THEN
obj=fsbut10&
ENDIF
IF a=11 THEN
obj=fsbut11&
ENDIF
IF a=12 THEN
obj=fsbut12&
ENDIF
IF a=13 THEN
obj=fsbut13&
ENDIF
IF a=14 THEN
obj=fsbut14&
ENDIF
IF a=15 THEN
obj=fsbut15&
ENDIF
@setbutton(obj,1)
tnfk=a
tmfsz=tfsz+tnfk
tnfk2=obj
ENDIF
ENDIF
RETURN
'
> PROCEDURE tfsearch
LOCAL j
vop$=op$
vnam$=nam$
vfil$=fil$
tfobj=obj
IF trkz>0 THEN
vornr=nr
nr=fsel&
tfselm=TRUE
~@xrsrc_gaddr(0,nr,zu%)
tnfk=0
tfsz=0
tfsz2=0
@hidetree2(fstime&,TRUE)
@hidetree2(fsins&,TRUE)
@hidetree2(fsmatic&,TRUE)
@hidetree2(fsdel&,TRUE)
@hidetree2(fsload&,TRUE)
@hidetree2(fssave&,TRUE)
@hidetree2(fsclf&,TRUE)
@hidetree2(fsend&,TRUE)
@hidetree2(fswait&,TRUE)
@hidetree2(fsstop&,TRUE)
@hidetree2(fsplay&,TRUE)
@hidetree2(fslplay&,TRUE)
@hidetree2(fsordner&,TRUE)
@hidetree2(fsadd&,TRUE)
@hidetree2(fsnew&,TRUE)
@hidetree2(fsotxt&,TRUE)
@hidetree2(tfsabc&,FALSE)
@hidetree2(tfsearch&,FALSE)
@hidetree2(fsok&,TRUE)
@flagbutton(fstxt1&,1089)
@flagbutton(fstxt2&,1089)
@flagbutton(fstxt3&,1089)
@flagbutton(fstxt4&,1089)
@flagbutton(fstxt5&,1089)
@flagbutton(fstxt6&,1089)
@flagbutton(fstxt7&,1089)
@flagbutton(fstxt8&,1089)
@flagbutton(fstxt9&,1089)
@flagbutton(fstxt10&,1089)
@flagbutton(fstxt11&,1089)
@flagbutton(fstxt12&,1089)
@flagbutton(fstxt13&,1089)
@flagbutton(fstxt14&,1089)
@flagbutton(fstxt15&,1089)
@flagbutton(fsexit&,1029)
@flagbutton(fsok&,0)
@flagbutton(tfsearch&,1031)
IF maxcol<>2 THEN
@textcolor(fsel&,fstxt1&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt2&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt3&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt4&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt5&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt6&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt7&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt8&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt9&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt10&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt11&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt12&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt13&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt14&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt15&,1,4,3)  !text,rahmen,fill
ENDIF
@readpos(fsexit&)
IF bigfoot=FALSE THEN
@setpos(fsexit&,496,by)
ELSE
@setpos(fsexit&,786,by)
ENDIF
@rsc_draw(nr,0)
tflist=trkz
'
@slidelen(fsslide&,fssldbut&,v,tfsbr)
tmfsz=0
tfsl=15                         ! Anzahl der lines
tflist2=tflist
IF tflist2<tfsl THEN
tflist2=tfsl
ENDIF
tfbbut=INT(tfsbr/tflist2*tfsl)   ! Buttonbreite
tfsmax=tfsbr                     ! Breite des Sliders
tfstep=tfsmax/tflist2*tfsl       ! Schrittweite des Sliders
tfsplus=tfsmax/tflist2           ! Einzelschritt
@slideinit(fsslide&,fssldbut&,tfsmax,tfbbut,tfsz)
@setslide(fsslide&,fssldbut&,tfsmax,tfbbut,tfsz)
@markhlp
@clearfsel
@tfsgetsel1
@tfsgetsel2
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
@readbutton(obj)
IF obj=fshelp& THEN
@helptxt("TRACK-SEARCH")
ENDIF
IF obj=fssldup& THEN
IF tfsz2>0 THEN
@slideup2(fsslide&,fssldbut&,tfsmax,tfsplus,tfsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@tfscalc
@tfsgetsel2
ENDIF
ENDIF
@setbutton(fssldup&,0)
ENDIF
IF obj=fsslddwn& THEN
@slidedwn2(fsslide&,fssldbut&,tfsmax,tfstep,tfsplus,tfsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@tfscalc
@tfsgetsel2
ENDIF
@setbutton(fsslddwn&,0)
ENDIF
IF obj=tfsabc& THEN
@tfselabc
ENDIF
IF obj=fsbut1& THEN
tfso=1
@tfsgetsel5
ENDIF
IF obj=fsbut2& THEN
tfso=2
@tfsgetsel5
ENDIF
IF obj=fsbut3& THEN
tfso=3
@tfsgetsel5
ENDIF
IF obj=fsbut4& THEN
tfso=4
@tfsgetsel5
ENDIF
IF obj=fsbut5& THEN
tfso=5
@tfsgetsel5
ENDIF
IF obj=fsbut6& THEN
tfso=6
@tfsgetsel5
ENDIF
IF obj=fsbut7& THEN
tfso=7
@tfsgetsel5
ENDIF
IF obj=fsbut8& THEN
tfso=8
@tfsgetsel5
ENDIF
IF obj=fsbut9& THEN
tfso=9
@tfsgetsel5
ENDIF
IF obj=fsbut10& THEN
tfso=10
@tfsgetsel5
ENDIF
IF obj=fsbut11& THEN
tfso=11
@tfsgetsel5
ENDIF
IF obj=fsbut12& THEN
tfso=12
@tfsgetsel5
ENDIF
IF obj=fsbut13& THEN
tfso=13
@tfsgetsel5
ENDIF
IF obj=fsbut14& THEN
tfso=14
@tfsgetsel5
ENDIF
IF obj=fsbut15& THEN
tfso=15
@tfsgetsel5
ENDIF
IF obj=fstxt1& THEN
tfso2=1
@tfsgetsel4
ENDIF
IF obj=fstxt2& THEN
tfso2=2
@tfsgetsel4
ENDIF
IF obj=fstxt3& THEN
tfso2=3
@tfsgetsel4
ENDIF
IF obj=fstxt4& THEN
tfso2=4
@tfsgetsel4
ENDIF
IF obj=fstxt5& THEN
tfso2=5
@tfsgetsel4
ENDIF
IF obj=fstxt6& THEN
tfso2=6
@tfsgetsel4
ENDIF
IF obj=fstxt7& THEN
tfso2=7
@tfsgetsel4
ENDIF
IF obj=fstxt8& THEN
tfso2=8
@tfsgetsel4
ENDIF
IF obj=fstxt9& THEN
tfso2=9
@tfsgetsel4
ENDIF
IF obj=fstxt10& THEN
tfso2=10
@tfsgetsel4
ENDIF
IF obj=fstxt11& THEN
tfso2=11
@tfsgetsel4
ENDIF
IF obj=fstxt12& THEN
tfso2=12
@tfsgetsel4
ENDIF
IF obj=fstxt13& THEN
tfso2=13
@tfsgetsel4
ENDIF
IF obj=fstxt14& THEN
tfso2=14
@tfsgetsel4
ENDIF
IF obj=fstxt15& THEN
tfso2=15
@tfsgetsel4
ENDIF
UNTIL obj=fsexit& OR obj=tfsearch& OR tnfk<>0
IF tnfk=0 AND obj=fsearch& THEN
@setbutton(obj,0)
ENDIF
IF obj=tfsearch& AND NOT (tnfk<>0 AND tmfsz<=tflist) THEN
@setbutton(tfsearch&,0)
ENDIF
UNTIL obj=fsexit& OR (tnfk<>0 AND obj=tfsearch& AND tmfsz<=tflist)
IF obj=tfsearch& THEN
@makesearch
ENDIF
IF obj<>0 THEN
@setbutton(obj,0)
ENDIF
IF tnfk2<>0 THEN
@setbutton(tnfk2,0)
ENDIF
@hidetree2(fstime&,FALSE)
@hidetree2(fsins&,FALSE)
@hidetree2(fsmatic&,FALSE)
@hidetree2(fsdel&,FALSE)
@hidetree2(fsload&,FALSE)
@hidetree2(fssave&,FALSE)
@hidetree2(fsclf&,FALSE)
@hidetree2(fsend&,FALSE)
@hidetree2(fswait&,FALSE)
@hidetree2(fsstop&,FALSE)
@hidetree2(fsplay&,FALSE)
@hidetree2(fslplay&,FALSE)
@hidetree2(fsordner&,FALSE)
@hidetree2(fsadd&,FALSE)
@hidetree2(fsnew&,FALSE)
@hidetree2(fsotxt&,FALSE)
@hidetree2(tfsabc&,TRUE)
@hidetree2(tfsearch&,TRUE)
@hidetree2(fsok&,FALSE)
@readpos(fsexit&)
IF bigfoot=FALSE THEN
@setpos(fsexit&,520,by)
ELSE
@setpos(fsexit&,810,by)
ENDIF
@rsc_back(nr)
nr=vornr
@wischwasch
IF obj=tfsearch& THEN
@makesearch2
ENDIF
ENDIF
@setbutton(tfobj,0)
obj=0
op$=vop$
nam$=vnam$
fil$=vfil$
tfselm=FALSE
RETURN
'
> PROCEDURE trkcomin
LOCAL to,a,am$,i3
to=tfso2+tfsz
mrkobj=obj
vorvornr=vornr
vornr=nr
@rsc_back(nr)
@wischwasch
nr=trkcomin&
@rsc_draw(nr,0)
@wischwasch
@markhlp
i3=trktnr(to)
a$=trkcom$(i3)
IF LEN(a$)>60 THEN
a$=LEFT$(a$,60)+CHR$(0)
ENDIF
a$=a$+CHR$(0)
@editfeld(trkctxin&,a$)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>trkctxin&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=trkchlp& THEN
@helptxt("TRACK-KOMMENTAR")
ENDIF
UNTIL obj=trkcexit& OR obj=trkcok&
IF obj=trkcok& THEN
timedraw=TRUE
editread(trkctxin&)
a=INSTR(a$,CHR$(0))
IF a>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
IF LEN(a$)>60 THEN
a$=LEFT$(a$,60)
ENDIF
trkcom$(i3)=a$
ENDIF
@setbutton(obj,0)
@restaura2
@rsc_draw(nr,0)
IF obj=trkcok& THEN
a$=trkcom$(i3)+CHR$(0)
@textfeld(mrkobj,a$,1)
ENDIF
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE tfselabc
IF sabc=FALSE THEN
sabc=TRUE
ELSE
sabc=FALSE
ENDIF
RETURN
'
> PROCEDURE restaura
.| Ruft auf  : restaura3,restaura4
.| Aufruf in : button-2,fade_it-2,smpkhlp-2,smpmhlp-2,smpihlp-2,zoomhelp-1
.|     smpl-2,smpr-2,edhandler2-1,rubbermax-1,zoomcalc-1,do_smpedit-3
.|     trash-1,negate-1,lrchange-1,smpplay-1,record3-2,
'  @rsc_back(nr)
@restaura3
@restaura4
RETURN
'
> PROCEDURE blkrestaura
.| Glob. Var.: nr#,smpedit&,winh#
.| Ruft auf  : restaura3,restaura4
.| Aufruf in : normalize-1,smpcut-1,resample-1,conmix-1,mono-1,negate-1
.|     lrchange-1,
LOCAL bnr
nr=smpedit&
IF BTST(winh,smpedit&)=TRUE THEN
@editselect
@restaura3
@restaura4
ENDIF
nr=blkfunc&
@editselect
@restaura3
@restaura4
RETURN
'
> PROCEDURE restaura2
.| Glob. Var.: nr#,vornr#,winh#
.| Ruft auf  : rsc_back
.| Aufruf in : smptime-1,movefrag-1,smpsave-1,sampleinf-1,arrsmpr-1
.|     arrdelay-1,arrmname-1,virtual-1,abackup-1,makeaback-1,time_edit-1
.|     make-1,setupdat-1,midi-1,do_dsp-1,
@rsc_back(nr)
nr=vornr
@wischwasch
IF BTST(winh,nr)=TRUE THEN
'    @restaura3
'    @restaura4
ENDIF
RETURN
'
> PROCEDURE restaura2b
.| Glob. Var.: nr#
.| Ruft auf  : rsc_back
.| Aufruf in : do_main-1,fade-1,do_arrange-1,do_trakker-1,do_blkf-1
.|     do_info-1,do_loop-1,do_peak-1,
@rsc_back(nr)
@wischwasch
RETURN
'
> PROCEDURE restaura3
.| Glob. Var.: nr#,smp16&,i#
.| Ruft auf  : rsc_redraw_obj
.| Aufruf in : restaura-1,blkrestaura-2,sampleinf-1,
IF nr=smp16& THEN
i=7
ELSE
i=5
ENDIF
@wischwasch
@rsc_redraw_obj(nr,0)
@wischwasch
RETURN
'
> PROCEDURE restaura4
.| Glob. Var.: nr#,smpedit&,cs#,ce#,sblock#,smppmark&,sloop#,smploop&
.| Ruft auf  : curve,markprod3,setbutton
.| Aufruf in : smpsave-1,restaura-1,blkrestaura-2,smpload-1,
IF nr=smpedit& THEN
@curve(cs,ce)
@markprod3
@getcurve
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF sloop=0 THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
ENDIF
@wischwasch
RETURN
'
> PROCEDURE restaura4b
IF nr=smpedit& THEN
@curve(cs,ce)
@markprod3b
@getcurve
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF sloop=0 THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
ENDIF
@wischwasch
RETURN
'
> PROCEDURE restaura5
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF sloop=0 THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
RETURN
'
> PROCEDURE smpload
.| Glob. Var.: mrkobj#,memlmrk#,meml#,secmrk#,sec#,anfloadx#,smplen#,abz#
.|     vmem#,lready#,savexit&,smpnam$,pathda#,nr#,smpedit&,cs#,ce#,extclock#
.|     hz#,a$,popups&,rate32&,rate&,rate44&,rate48&,smpload&
.| Ruft auf  : ldhlp,fnamwrite,curve,restaura4,textfeld,adlow,admid,adhigh
.|     setbutton
.| Aufruf in : drop2-1,do_smpedit-1,
IF ldtrk3=FALSE THEN
mrkobj=0
memlmrk=meml
secmrk=sec
@ldhlp
IF anfloadx<>0 AND anfloadx<>-1 AND (smplen-abz)<=vmem AND lready=1 AND mrkobj<>savexit& THEN
IF smpnam$<>"" AND pathda=TRUE THEN
@fnamwrite
IF nr=smpedit& THEN
IF edclr=TRUE AND virtex=FALSE THEN
@restaura3
@restaura4b
ENDIF
ENDIF
@fliphz
@fliphz2
ENDIF
ELSE
IF pathda=FALSE THEN
IF nr=smpedit& THEN
IF edclr=TRUE AND virtex=FALSE THEN
@restaura3
@restaura4b
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF nr=smpedit& THEN
IF neufsel=FALSE THEN
@setbutton(smpload&,0)
ELSE
@setbutton(smpdbank&,0)
ENDIF
ENDIF
edclr=FALSE
virtex=FALSE
RETURN
'
> PROCEDURE marksearch
.| Glob. Var.: markfull#,loopz#,markfre#
.| Felder    : loops#(),loope#()
.| Aufruf in : findblock-1,sampleinf-2,
LOCAL ex,i
markfull=FALSE
ex=FALSE
FOR i=1 TO loopz
IF ((loops%(i,1)=0 AND loops%(i,2)=0 AND loops%(i,3)=0 AND loops%(i,4)=0) OR (loops%(i,1)=-1 AND loops%(i,2)=-1 AND loops%(i,3)=-1 AND loops%(i,4)=-1)) AND ex=FALSE THEN
markfre=i
ex=TRUE
ENDIF
EXIT IF ex=TRUE
NEXT i
IF ex=FALSE THEN
markfre=1
markfull=TRUE
ENDIF
RETURN
'
> PROCEDURE blkltest
.| Glob. Var.: bpos#,master#,bstart#,loopz#,dist#,ce#,cs#,blks#,conc#,meml#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp
.| Aufruf in : ldhlp-1,conspace-1,coninsert-1,
@markhlp
bpos=0
IF sms=0 THEN
bstart=0
ENDIF
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
bstart=loops%(sms,sms2)
ENDIF
dist=ce-cs
IF blks=1 THEN
bpos=bstart
ENDIF
'
conc=0
IF sms>0 AND sms<=loopz AND sms2<>0 AND loops%(sms,1)<>-1 THEN
conc=loops%(sms,1)
ENDIF
'
'  conc=bstart
bstart=bstart+meml
bstart=INT(bstart/mbit)*mbit
RETURN
'
> PROCEDURE fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
.| Glob. Var.: pret#,pbutt#
.| Ruft auf  : ain
.| Aufruf in : fileselect-1,
LPOKE ADDRIN,fs_iinpath%
LPOKE ADDRIN+4,fs_iinsel%
LPOKE ADDRIN+8,fs_iinlabel%
@ain(91,0,2,3,0)
pret=GINTOUT(0)
pbutt=GINTOUT(1)
RETURN
'
> PROCEDURE ain(g0%,g2%,g4%,g6%,g8%)
.| Aufruf in : fsel_exinput-1,
DPOKE GCONTRL,g0%
DPOKE GCONTRL+2,g2%
DPOKE GCONTRL+4,g4%
DPOKE GCONTRL+6,g6%
DPOKE GCONTRL+8,g8%
GEMSYS
RETURN
'
> PROCEDURE fileselect(a$,b$,c$)
.| Glob. Var.: fs_iinpath%,fs_iinsel%,fs_iinlabel%,a#,ordner$,nam$,fil$
.| Ruft auf  : fsel_exinput
.| Aufruf in : fadesave-1,fadeload-1,smpsave-1,newfsel-3,ldhlp-1,trakload-1
.|     hardfs-1,arrload-1,arrsave-1,make-1,fseldef-1,coninsert-1,smpplay-1
.|     record3-1,
~GRAF_MOUSE(256,0)                              ! Hidem
'  ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
a$=a$+CHR$(0)+SPACE$(100)
fs_iinpath%=VARPTR(a$)
b$=b$+CHR$(0)+SPACE$(100)
fs_iinsel%=VARPTR(b$)
c$=c$+CHR$(0)+SPACE$(100)
fs_iinlabel%=VARPTR(c$)
@fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
a=INSTR(a$,CHR$(0))
a$=LEFT$(a$,a-1)
a=INSTR(b$,CHR$(0))
b$=LEFT$(b$,a-1)
a=RINSTR(a$,"\")
IF LEN(a$)=0 THEN
ordner$=""
ELSE
ordner$=LEFT$(a$,a)
ENDIF
IF LEN(b$)=0 THEN
nam$=""
fil$=""
ELSE
nam$=b$
fil$=ordner$+b$
ENDIF
IF nr=fsel& THEN
@rsc_back(nr)
@rsc_draw(nr,0)
ENDIF
'  @rsc_put(ab,rscx&(nr),rscy&(nr),1)
'  @rsc_redraw_obj(nr,0)
@wischwasch
RETURN
'
> PROCEDURE markset
.| Glob. Var.: markfre#,sms#,sme#,ah#,ah2#,nr#,smpedit&,t$,loopz#
.| Felder    : loope#(),loops#()
.| Ruft auf  : selblksbut,selblkebut,markhlp6,markhlp3
.| Aufruf in : sampleinf-1,
LOCAL j
IF markfre=i THEN
sms=i
loops%(sms,1)=ah2
loops%(sms,2)=ah
IF nr=smpedit& THEN
@edmarkset(sms)
FOR j=1 TO 4
@marktextsel(j)
@markhlp6(loops%(sms,j))
NEXT j
FOR j=1 TO 4
@markhlp3(sms,j,loops%(sms,j))
NEXT j
ENDIF
ENDIF
RETURN
'
> PROCEDURE ldhztest
.| Glob. Var.: extclock#,per#,hz#,nr#,smp16&,a$,popups&,ad32&,rate2&,ad44&
.|     ad48&,retime#,hzm#,sblock#,sret#,smpedit&,fileart#,smppmark&
.| Ruft auf  : textfeld,adlow,admid,adhigh,setbutton
.| Aufruf in : ldhlp-6,ldhead-1,
hz=per
@fliphz
@fliphz2
IF per<>8000 AND per<>11000 AND per<>12000 AND per<>16000 AND per<>17000 AND per<>22000 AND per<>24000 AND per<>33000 AND per<>66000 AND per<>128 AND per<>192 AND per<>256 AND per<>384 AND per<>32000 AND per<>44100 AND per<>48000 THEN
IF per<>88200 AND per<>96000 THEN
retime=1
per=INT(per/100)*100
hz=per
hzm=hz
ENDIF
ENDIF
'  sblock=0
'  sret=0
IF nr=smpedit& AND (fileart=5 OR fileart=4) THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE writehzm
.| Glob. Var.: retime#,hz#,hzm#,p$,nr#,smpedit&,smprate&,smp16&
.| Ruft auf  : textfeld,deladbutt
.| Aufruf in : ldready-1,
IF retime=1 THEN
hz=hzm
p$=STR$(hzm/1000)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
IF nr=smp16& THEN
@fliphz
ENDIF
ELSE
p$="    "+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE sdload
.| Glob. Var.: loded#,ea#,eb#,ret#,hdl#,al$,head#,datx#,samlen#,mdat%,hbuf#
.|     a#,ar$,g#,ec#,fil$
.| Ruft auf  : maschinit37,maschruf37
.| Aufruf in : ldhlp-2,
loded=FALSE
IF ea=TRUE AND eb=TRUE THEN
ret=0
hdl=GEMDOS(61,L:VARPTR(al$),0)
~GEMDOS(66,L:head,hdl,0)
@maschruf37(datx,datx+samlen,mdat%+2048,mdat%+hbuf-mbit,hdl,ret)
a=GEMDOS(62,hdl)
IF ret=(datx+samlen) THEN
ret=0
hdl=GEMDOS(61,L:VARPTR(ar$),0)
~GEMDOS(66,L:head,hdl,0)
@maschruf37(datx+2,datx+samlen+2,mdat%+2048,mdat%+hbuf-mbit,hdl,ret)
~GEMDOS(62,hdl)
IF ret<>datx+samlen+2 THEN
@alerts(22)
loded=FALSE
ELSE
loded=TRUE
IF ec=FALSE THEN
a=INSTR(fil$,".")
fil$=LEFT$(fil$,a-2)+RIGHT$(fil$,LEN(fil$)-a+1)
ENDIF
ENDIF
ELSE
loded=FALSE
@alerts(22)
ENDIF
ELSE
@alerts(23)
loded=FALSE
ENDIF
RETURN
'
> PROCEDURE blkupdate
LOCAL j
IF nr=smpedit& THEN
@makehz
@sethertz
FOR j=1 TO 4
IF loops%(sms,j)<>-1 THEN
@marktextsel(j)
IF memc=0 OR cached=FALSE OR drawnew2=TRUE THEN
@markhlp6(loops%(sms,j))
ENDIF
ENDIF
NEXT j
ENDIF
RETURN
'
> PROCEDURE findblock
.| Glob. Var.: sa#,se#,ah2#,bpos#,ah#,vmem#,sret#,a#,sblock#,markfre#
.|     markfull#,sms#,sme#,nr#,smpedit&,loopz#
.| Felder    : loope#(),loops#()
.| Ruft auf  : marksearch,markhlp3
.| Aufruf in : ldhlp-1,sampleinf-1,
LOCAL a
ah4=se2
ah3=sa2
ah2=se
ah=sa
IF ah2<>-1 THEN
ah2=se+bpos
IF ah2>vmem THEN
ah2=vmem
ENDIF
ENDIF
IF ah<>-1 THEN
ah=sa+bpos
IF ah>vmem THEN
ah=vmem
ENDIF
ENDIF
IF ah=vmem AND ah2=vmem THEN
ah2=-1
ah=-1
ENDIF
IF ah3<>-1 THEN
ah3=sa2+bpos
IF ah3>vmem THEN
ah3=vmem
ENDIF
ENDIF
IF ah4<>-1 THEN
ah4=se2+bpos
IF ah4>vmem THEN
ah4=vmem
ENDIF
ENDIF
IF ah2<ah AND ah2<>-1 AND ah<>-1 THEN
sret=1                ! RÅckwÑrts-Loop
a=ah2
ah2=ah
ah=a
ENDIF
sblock=1
IF blks=0 THEN
sms=1
ENDIF
loops%(markfre,1)=ah
loops%(markfre,2)=ah2
loops%(markfre,3)=ah3
loops%(markfre,4)=ah4
edmtxt$(markfre)=ah$
'  IF nr=smpedit& THEN
'  @markhlp3(markfre,1,loops%(markfre,1))
'  @markhlp3(markfre,2,loops%(markfre,2))
'  @markhlp3(markfre,3,loops%(markfre,3))
'  @markhlp3(markfre,4,loops%(markfre,4))
' ENDIF
RETURN
'
> PROCEDURE ldready
.| Glob. Var.: sms#,loopz#,sme#,cached#,loded#,lz#,path$,fil$,smpnam$,bnam$
.| Ruft auf  : selblksbut,selblkebut,writehzm
.| Aufruf in : ldhlp-7,
IF sms>0 AND sms<=loopz THEN
@edmarkset(sms)
ENDIF
cached=FALSE
loded=TRUE
lz=1
path$=fil$
smpnam$=bnam$
@writehzm
RETURN
'
> PROCEDURE fileart
head=0
fileart=0
abz=DPEEK(datx)
abz2=LPEEK(datx)
IF abz=&HF07E THEN
head=20   ! HeaderlÑnge fÅr S16-Files
fileart=1
IF RIGHT$(fil$,4)=".S16" THEN
@setbitrate16
ENDIF
IF RIGHT$(fil$,4)=".S24" THEN
@setbitrate24
ENDIF
ENDIF
IF abz2=&H32424954 THEN
head=128   ! HeaderlÑnge fÅr AVR-Files
fileart=2
ENDIF
IF abz2=&H52494646 THEN
head=44   ! HeaderlÑnge fÅr WAV-Files
fileart=3
ENDIF
IF abz2=&H2E736E64 THEN
head=28   ! HeaderlÑnge fÅr AU und SND-Files
fileart=4
ENDIF
abz=head
IF abz2=&H538000C THEN
head=1336 ! HeaderlÑnge fÅr SD-Files
fileart=5
IF virtld=FALSE THEN
ln=ln*2
ENDIF
abz=head*2+8
ENDIF
IF abz2=&HF07E0001 THEN
head=296 ! HeaderlÑnge fÅr Avalon SMP-Files
fileart=6
IF virtld=FALSE THEN
ln=ln*2
ENDIF
abz=head*2+8
ENDIF
IF abz2=&H464F524D THEN
head=54+458   ! HeaderlÑnge fÅr AIFF-Files
fileart=7
ENDIF
RETURN
'
> PROCEDURE fileart2
IF fileart=6 THEN
SEEK #1,LOF(#1)-head
ENDIF
BGET #1,datx,head
IF fileart=6 THEN
SEEK #1,20
ENDIF
RETURN
'
> PROCEDURE setpeakblks
pkdb=ROUND(db16)                ! dB-Auflîsung
pkt=pkdb/LOG10(65535)
'
pkg0=ROUND(10^((pkdb-48)/pkt)/2)   ! BinÑr-Grenzen
pkg1=ROUND(10^((pkdb-24)/pkt)/2)
pkg2=ROUND(10^((pkdb-12)/pkt)/2)
pkg3=ROUND(10^((pkdb-8)/pkt)/2)
pkg4=ROUND(10^((pkdb-6)/pkt)/2)
pkg5=ROUND(10^((pkdb-4)/pkt)/2)
pkg6=ROUND(10^((pkdb-3)/pkt)/2)
pkg7=ROUND(10^((pkdb-2)/pkt)/2)
pkg8=ROUND(10^((pkdb-1)/pkt)/2)
pkg9=ROUND(10^((pkdb-0)/pkt)/2)
pkdb0=ROUND(pkt*LOG10(pkg0*2))     ! dB-Grenzen
pkdb1=ROUND(pkt*LOG10(pkg1*2))
pkdb2=ROUND(pkt*LOG10(pkg2*2))
pkdb3=ROUND(pkt*LOG10(pkg3*2))
pkdb4=ROUND(pkt*LOG10(pkg4*2))
pkdb5=ROUND(pkt*LOG10(pkg5*2))
pkdb6=ROUND(pkt*LOG10(pkg6*2))
pkdb7=ROUND(pkt*LOG10(pkg7*2))
pkdb8=ROUND(pkt*LOG10(pkg8*2))
pkdb9=ROUND(pkt*LOG10(pkg9*2))
RETURN
'
> PROCEDURE setbitrate16
dig24=FALSE
mbit=4
aufloes=db16       ! dB-Aufloesung der Wandler (16Bit)
IF demo=FALSE THEN
~XBIOS(xbs,28,0)
ENDIF
IF rscda=TRUE THEN
IF nr=smpedit& THEN
@textfeld(resolu&,"16 BIT"+CHR$(0),1)
ELSE
@textfeld2(smpedit&,resolu&,"16 BIT"+CHR$(0),1)
ENDIF
ENDIF
IF ext$="S16" OR ext$="S24" THEN
ext$="S16"
ENDIF
IF ext2$="S16" OR ext2$="S24" THEN
ext2$="S16"
ENDIF
RETURN
'
> PROCEDURE setbitrate24
dig24=TRUE
mbit=6
aufloes=db24       ! dB-Aufloesung der Wandler (16Bit)
IF demo=FALSE THEN
~XBIOS(xbs,28,1)
ENDIF
IF rscda=TRUE THEN
IF nr=smpedit& THEN
@textfeld(resolu&,"24 BIT"+CHR$(0),1)
ELSE
@textfeld2(smpedit&,resolu&,"24 BIT"+CHR$(0),1)
ENDIF
ENDIF
IF ext$="S16" OR ext$="S24" THEN
ext$="S24"
ENDIF
IF ext2$="S16" OR ext2$="S24" THEN
ext2$="S24"
ENDIF
RETURN
'
> PROCEDURE ldhlp
.| Glob. Var.: loded#,inf#,virtual#,rett#,virt$,virt2$,virtld#,blockld#
.|     mrkobj#,obj#,savexit&,retime#,shlp#,lready#,cs#,ce#,vmem#,head#,x#,y#
.|     w#,h#,neufsel#,op$,ext$,pathda#,fil$,pret#,pbutt#,datx#,mdat%,ln#
.|     mlen#,blks#,anfloadx#,meml#,mt#,bstart#,memh#,fileart#,abz#,abz2#
.|     ln2#,lded#,danf#,vfileart#,vhead#,vhbldstrt#,hbldlen#,a#,tst1#,per#
.|     samlen#,ec#,al$,ar$,ea#,eb#,bnam$,nam$,smplen#,sblock#,j#,sa#,se#,nr#
.|     smpedit&,smppmark&,okmark#,sms#,sme#,vlmin#,lmin#,vlma#,lma#,tst2#
.|     dazu#,tst3#,tst4#,tst5#,tst6#,dmagic#,ov#,la#,sret#,ah#,bpos#,ah2#
.|     x2#,y2#,ldlen#,perm#,x3#,y3#,x4#,y4#,hz#,hzm#,b#,l#,smrk#,big#
.|     virtcurve#,maxcwert#,profln#,profhz#,vtst#,mbs#,vorln#,lz#,hard&
.|     vmeml#,vmemh#,hrd#,vce#,vcs#,virtex#,g#,lmax3#,vmbs#,zoomp#
.| Felder    : bloops#(),bloope#(),mblocks#(),mblocke#(),mblockp$()
.| Ruft auf  : infhol,blklfrag,maschinit,newfsel,fileselect,busy_mouse
.|     blkltest,markdel,clsed,markhlp,ldhztest,sampleinf,findblock,setbutton
.|     sdload,maschinit38,maschruf38,ldready,maschinit28,maschruf28,makehz
.|     maschruf,ldhead,virtual,ldhlp,hardproof,infrett,fnamwrite,zslidecalc
.| Aufruf in : smpload-1,ldhlp-2,
lsret=sret
loded=FALSE
inf=FALSE
@infhol
IF virtual=FALSE AND rett=TRUE THEN
IF EXIST(virt$)=TRUE AND EXIST(virt2$)=TRUE THEN
KILL virt$
KILL virt2$
ENDIF
rett=FALSE
ENDIF
IF (virtld=TRUE AND (blockld=TRUE OR virtual=TRUE)) OR (virtld=FALSE AND blockld=FALSE AND virtual=FALSE) THEN
IF virtld=FALSE THEN
IF ldtrk=FALSE THEN
IF neufsel=FALSE THEN
@blklfrag
mrkobj=obj
ELSE
blks=0
ENDIF
ELSE
obj=savall&
mrkobj=obj
ENDIF
ENDIF
IF obj<>savexit& THEN
retime=0
shlp=0
lready=0
cs=0
ce=vmem
head=20   ! HeaderlÑnge fÅr S16-Files
x=100
y=100
w=400
h=400
IF virtld=FALSE THEN
IF ldtrk=FALSE THEN
IF neufsel=TRUE THEN
@newfsel
ELSE
@fileselect(op$+"*."+ext$,"","LOAD SAMPLE:")
ENDIF
ELSE
pbutt=1
pret=1
ENDIF
ENDIF
@busy_mouse
pathda=EXIST(fil$)
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pathda=TRUE AND pret<>0 AND pbutt=1 THEN
datx=mdat%
OPEN "I",#1,fil$
IF virtld=FALSE THEN
ln=LOF(#1)
viln=ln
ELSE
virtln=viln
ENDIF
BGET #1,datx,4
CLOSE #1
@blkltest
IF (virtld=FALSE AND (ln-head)<=mlen) OR blockld=TRUE THEN
IF blks=0 THEN
anfloadx=meml
mt=INT(mlen/mbit)*mbit
ELSE
anfloadx=bstart
mt=memh-bstart
ENDIF
ELSE
IF blks=0 OR virtual=TRUE THEN
anfloadx=meml
mt=INT(mlen/mbit)*mbit
ELSE
anfloadx=bstart
mt=memh-bstart
ENDIF
ENDIF
@fileart
ldhead=head
ldfileart=fileart
IF anfloadx<>0 AND anfloadx<>-1 AND (ln-abz)<=mt THEN
lready=1
ln2=ln
IF blks=0 AND virtld=FALSE AND virtual=FALSE THEN      ! virtld,virtual ist NEU !!!
@markdel
ELSE
blks=1    ! NEU
ENDIF
ln=ln2
datx=((INT(anfloadx/mbit))*mbit)+mbit
OPEN "I",#1,fil$
@fileart2
lded=1
IF blks=0 THEN
@clsed
ENDIF
danf=datx
IF blockld=TRUE AND virtld=TRUE THEN
fileart=vfileart
head=vhead
SEEK #1,vhbldstrt+head
ln=hbldlen
ENDIF
'
IF fileart=7 THEN                   ! AIFF-Format
@markhlp
a=datx
ldlen=LPEEK(danf+22)                          ! Sample Len in Worten
per=DPEEK(danf+30)     ! Sample-Rate
tst1=LPEEK(danf+8)     ! AIFF-Kennung
tst2=LPEEK(danf+12)    ! COMM-Kennung
tst3=DPEEK(danf+20)    ! Channels
tst4=LPEEK(danf+38)    ! SSND-Kennung
tst5=DPEEK(danf+26)    ! Bits
IF tst5=16 THEN
@setbitrate16
ENDIF
IF tst5=24 THEN
@setbitrate24
ENDIF
IF tst1=&H41494646 AND tst2=&H434F4D4D AND tst3=2 AND tst4=&H53534E44 AND (tst5=16 OR tst5=24) THEN
@ldhztest
sblock=0
sret=0
IF nr=smpedit& THEN
@setbutton(smppmark&,0)
ENDIF
okmark=0
sms=1
sms2=0
samlen=ln-head
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
vlmin=lmin
vlma=lma
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=6 THEN          ! Avalon SMP-Format
@markhlp
a=datx
tst1=DPEEK(danf+76)    ! Bits
IF tst1=16 THEN
per=LPEEK(danf+72)     ! Sample-Rate
@ldhztest
samlen=LPEEK(danf+92)*mbit ! datasize
ln=samlen
bloops%(7,1)=LPEEK(danf+32)
bloops%(7,2)=LPEEK(danf+64)
bloops%(6,1)=LPEEK(danf+28)
bloops%(6,2)=LPEEK(danf+60)
bloops%(5,1)=LPEEK(danf+24)
bloops%(5,2)=LPEEK(danf+56)
bloops%(4,1)=LPEEK(danf+20)
bloops%(4,2)=LPEEK(danf+52)
bloops%(3,1)=LPEEK(danf+16)
bloops%(3,2)=LPEEK(danf+48)
bloops%(2,1)=LPEEK(danf+12)
bloops%(2,2)=LPEEK(danf+44)
bloops%(1,1)=LPEEK(danf+8)
bloops%(1,2)=LPEEK(danf+40)
ec=FALSE
a=RINSTR(fil$,".")
al$=LEFT$(fil$,a-2)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
a=RINSTR(fil$,".")
ar$=LEFT$(fil$,a-2)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ea=EXIST(al$)
eb=EXIST(ar$)
IF ea=FALSE OR eb=FALSE THEN
IF EXIST(fil$)=TRUE THEN
al$=fil$
ar$=fil$
ea=TRUE
eb=TRUE
ec=TRUE
ENDIF
ENDIF
bnam$=nam$
smplen=ln
IF ec=FALSE THEN
a=RINSTR(nam$,".")
bnam$=LEFT$(nam$,a-2)+RIGHT$(nam$,LEN(nam$)-a+1)
ENDIF
head=20
@sampleinf
IF inf=TRUE THEN
sblock=0
FOR j=1 TO 7
IF bloops%(j,1)<>-1 THEN
sa=bloops%(j,1)*mbit
ELSE
sa=-1
ENDIF
IF bloops%(j,2)<>-1 THEN
se=bloops%(j,2)*mbit
ELSE
se=-1
ENDIF
sa2=-1
se2=-1
ah$=""
markfre=j
@findblock
NEXT j
FOR j=8 TO loopz
loops%(j,1)=-1
loops%(j,2)=-1
loops%(j,3)=-1
loops%(j,4)=-1
NEXT j
sms=1
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
IF sblock=0 THEN
okmark=0
sms=1
sms2=0
ENDIF
vlmin=lmin
vlma=lma
CLOSE #1
@sdload
@maschruf38(datx,datx+samlen)
@ldready
ELSE
CLOSE #1
ENDIF
ENDIF
ENDIF
'
IF fileart=5 THEN          ! SD-Format
@markhlp
a=datx
per=LPEEK(danf+1020)     ! Sample-Rate
@ldhztest
samlen=LPEEK(danf+148)*2 ! datasize
okmark=0
sms=1
sms2=0
ln=samlen
ec=FALSE
a=INSTR(fil$,".")
al$=LEFT$(fil$,a-2)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
a=INSTR(fil$,".")
ar$=LEFT$(fil$,a-2)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ea=EXIST(al$)
eb=EXIST(ar$)
IF ea=FALSE OR eb=FALSE THEN
IF EXIST(fil$)=TRUE THEN
al$=fil$
ar$=fil$
ea=TRUE
eb=TRUE
ec=TRUE
ENDIF
ENDIF
bnam$=nam$
IF ec=FALSE THEN
a=INSTR(nam$,".")
bnam$=LEFT$(nam$,a-2)+RIGHT$(nam$,LEN(nam$)-a+1)
ENDIF
smplen=ln
@sampleinf
IF inf=TRUE THEN
vlmin=lmin
vlma=lma
CLOSE #1
@sdload
@ldready
ELSE
CLOSE #1
ENDIF
ENDIF
'
IF fileart=4 THEN        ! AU-Format
@markhlp
a=datx
tst1=LPEEK(danf+12)    ! dataformat
tst2=LPEEK(danf+20)    ! channelcount
IF tst1=3 AND tst2=2 THEN
per=LPEEK(danf+16)    ! Sample-Rate
@ldhztest
samlen=LPEEK(danf+8)        ! datasize
okmark=0
sms=1
sms2=0
dazu=LPEEK(danf+4)-28       !datalocation
IF dazu>0 THEN
BGET #1,datx,dazu
ENDIF
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
vlmin=0
vlma=0
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=3 THEN        ! WAV-Format
@markhlp
a=datx
tst1=LPEEK(danf+8)     ! "WAVE"
tst2=LPEEK(danf+12)    ! "fmt "
tst3=PEEK(danf+20)     ! format
tst4=PEEK(danf+22)     ! channels
tst5=PEEK(danf+32)     ! align
tst6=PEEK(danf+34)     ! bps
IF tst6=16 THEN
@setbitrate16
ENDIF
IF tst6=24 THEN
@setbitrate24
ENDIF
IF tst1=&H57415645 AND tst2=&H666D7420 AND tst3=1 AND tst4=2 AND tst5=4 AND (tst6=16 OR tst6=24) THEN
per=PEEK(danf+24)+256*PEEK(danf+25)    ! Sample-Rate
@ldhztest
dmagic=&H64617461
IF LPEEK(danf+36)=dmagic THEN
samlen=PEEK(danf+40)+256*PEEK(danf+41)+65536*PEEK(danf+42)+&H1000000*PEEK(danf+43)
ov=danf+36
ELSE
ov=40
REPEAT
dazu=PEEK(danf+ov)+256*PEEK(danf+ov+1)+65536*PEEK(danf+ov+2)+&H1000000*PEEK(danf+ov+3)
head=head+dazu+8
ov=4
IF ln>=head THEN
BGET #1,datx,dazu+8
IF LPEEK(danf+dazu)=dmagic THEN
samlen=PEEK(danf+dazu+4)+256*PEEK(danf+dazu+5)+65536*PEEK(danf+dazu+6)+&H1000000*PEEK(danf+dazu+7)
ENDIF
ENDIF
UNTIL LPEEK(danf+dazu)=dmagic OR ln<head
ov=danf+dazu
ENDIF
okmark=0
sms=1
sms2=0
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
IF LPEEK(ov)=dmagic THEN
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
vlmin=0
vlma=0
BGET #1,datx,samlen
@maschruf28(datx,samlen)
@ldready
ENDIF
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=2 THEN        ! AVR-Format
@markhlp
a=datx
tst1=DPEEK(danf+12)    ! mode
tst2=DPEEK(danf+14)    ! resolution
IF tst2=16 THEN
@setbitrate16
ENDIF
IF tst2=24 THEN
@setbitrate24
ENDIF
tst3=DPEEK(danf+16)    ! sign
IF tst1=&HFFFF AND (tst2=16 OR tst2=24) AND tst3=&HFFFF THEN
per=DPEEK(danf+24)    ! Sample-Rate
@ldhztest
la=DPEEK(danf+18)                           ! Loop ?
sblock=0
sret=0
IF la=&HFFFF THEN
sblock=1
ENDIF
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
samlen=LPEEK(danf+26)*2
IF sblock=1 THEN
lmin=LPEEK(danf+30)*2                          ! Sustain Loop-Start
lma=LPEEK(danf+34)*2                           ! Sustain Loop-End
IF lma<lmin THEN
sret=1                ! RÅckwÑrts-Loop
a=lmin
lmin=lma
lma=a
ENDIF
ah=lmin+bpos
ah=INT(ah)
ah2=lma+bpos
ah2=INT(ah2)
IF ah>vmem THEN
ah=vmem
ENDIF
IF ah2>vmem THEN
ah2=vmem
ENDIF
ELSE
okmark=0
sms=1
sms2=0
ENDIF
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
vlmin=lmin
vlma=lma
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=1 THEN                   ! S16-Format
IF RIGHT$(fil$,4)=".S16" THEN
@setbitrate16
ENDIF
IF RIGHT$(fil$,4)=".S24" THEN
@setbitrate24
ENDIF
@markhlp
a=datx
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
x2=DPEEK(danf+10)                          ! Sample Len in Worten
y2=PEEK(danf+12)                           ! Sample Len in Worten
ldlen=(x2*256+y2)*2
per=INT(10^9/(x*65536+y))
perm=INT(per/100)*100
per=INT(perm)
@ldhztest
la=PEEK(danf+19)                           ! Loop-Art
sblock=1
IF la=0 THEN
sret=0
ENDIF
IF la=1 THEN
sret=1
ENDIF
IF la=&H7F THEN
sblock=0
ENDIF
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
IF sblock=1 THEN
x3=PEEK(danf+13)                           ! Sustain Loop-Start
y3=DPEEK(danf+14)                          ! Sustain Loop-Start
lmin=x3*65536+y3
x4=DPEEK(danf+16)                          ! Sustain Loop-End
y4=PEEK(danf+18)                           ! Sustain Loop-End
lma=x4*256+y4
ah=lmin+bpos
ah=INT(ah)
ah2=lma+bpos
ah2=INT(ah2)
IF ah>vmem THEN
ah=vmem
ENDIF
IF ah2>vmem THEN
ah2=vmem
ENDIF
ELSE
okmark=0
sms=1
sms2=0
ENDIF
samlen=ln-head
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
vlmin=lmin
vlma=lma
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ENDIF
'
IF fileart=0 THEN              ! Rohdaten-Format
samlen=ln-head
bnam$=nam$
smplen=samlen
@makehz
per=hz
@sampleinf
IF inf=TRUE THEN
vlmin=0
vlma=0
BGET #1,datx+head,samlen
@ldready
a=datx
okmark=0
sms=1
sms2=0
hzm=hz
ENDIF
CLOSE #1
ENDIF
IF inf=TRUE THEN
a=datx
IF blks=0 THEN
b=meml
l=memh-meml
shlp=1
smrk=meml+(ln-head)
smrk=INT(smrk/mbit)*mbit
ELSE
shlp=0
b=bstart
l=memh-bstart
ENDIF
IF big=0 THEN
@maschruf1
ENDIF
IF vmem<=mlen AND (virtual=TRUE OR blockld=TRUE) THEN
virtual=FALSE
blockld=FALSE
virtld=FALSE
virtcurve=FALSE
maxcwert=0
ce=mlen
cs=0
vmem=INT(mlen/mbit)*mbit
ENDIF
IF virtual=FALSE AND blockld=FALSE THEN
profln=ln
profhz=hz
ENDIF
ENDIF
ELSE
vhead=head
vfileart=fileart
vtst=TRUE
bnam$=nam$
smplen=ln
per=0
@ldhead
IF per=0 THEN
@makehz
per=hz
ENDIF
@sampleinf
vtst=FALSE
IF inf=TRUE THEN
@virtual
IF blockld=TRUE THEN
IF blks=0 THEN
mbs=0
ENDIF
ln=mt-mbit
obj=mrkobj
virtld=TRUE
@ldhlp
virtld=FALSE
vorln=ln
lz=1
vmem=INT(mlen/mbit)*mbit
ENDIF
IF virtual=TRUE THEN
mbs=0
IF nr=smpedit& THEN
@setbutton(hard&,1)
ENDIF
vmem=ln-head
vmeml=0
vmemh=mt
hrd=1
@hardproof
ln=mt
obj=mrkobj
'              blks=0        ! NEU
virtld=TRUE
@ldhlp
virtld=FALSE
IF blks=0 THEN
@markdel      ! NEU
@clsed        ! NEU
ENDIF
ln=vmem
vce=0
vcs=0
lz=1
ENDIF
IF virtex=TRUE THEN
@infrett
ENDIF
ENDIF
ENDIF
IF inf=FALSE THEN
@infrett
ENDIF
@fnamwrite
ENDIF
ENDIF
ELSE
@alerts(24)
ENDIF
obj=0
blockld=FALSE
IF loded=TRUE AND virtual=FALSE THEN
INC mbs
IF blks=1 THEN
mblocks(mbs)=bstart-meml
mblocke(mbs)=bstart+samlen-meml
ELSE
mbs=1
mblocks(mbs)=0
mblocke(mbs)=samlen
ENDIF
mblockp$(mbs)=fil$
IF mbs>lmax3 THEN
mbs=1
ENDIF
vmbs=mbs
ENDIF
IF loded=TRUE THEN
zoomp=0
@zslidecalc
ENDIF
IF inf=FALSE THEN
@infrett
ENDIF
IF sret<>lsret THEN
IF BTST(winh,loop&)=TRUE THEN
lnr=nr
nr=loop&
@editselect
IF nr=loop& THEN
@loopbut(lsret,0)
@loopbut(sret,1)
ENDIF
nr=lnr
@editselect
ENDIF
ENDIF
RETURN
'
> PROCEDURE infrett
.| Glob. Var.: per#,vper#,path$,vpath$,smpnam$,vsmpnam$,smplen#,vsmplen#
.|     mrkdatum$,vmrkdatum$,retime#,vretime#,ordner$,vordner$,cs#,vorcs#,ce#
.|     vorce#,i#,loopz#,bloopz#,sblock#,vsblock#,lz#,vlz#,mbs#,vmbs#,sms#
.|     vsms#,sme#,vsme#,master#,vmaster#,zoomp#,vzoomp#,srollp#,vscrollp#
.|     sloop#,vsloop#,mamidi#,vmamidi#,loded#
.| Felder    : loops#(),vloops#(),loope#(),vloope#(),bloops#(),vbloops#()
.|     bloope#(),vbloope#()
.| Ruft auf  : makehz
.| Aufruf in : ldhlp-3,sampleinf-1,
dig24=vdig24
IF dig24=FALSE THEN
@setbitrate16
ELSE
@setbitrate24
ENDIF
per=vper
path$=vpath$
smpnam$=vsmpnam$
smplen=vsmplen
mrkdatum$=vmrkdatum$
retime=vretime
ordner$=vordner$
IF retime=1 THEN
@makehz
ENDIF
cs=vorcs
ce=vorce
FOR i=1 TO loopz
loops%(i,1)=vloops%(i,1)
loops%(i,2)=vloops%(i,2)
NEXT i
FOR i=1 TO bloopz
bloops%(i,1)=vbloops%(i,1)
bloops%(i,2)=vbloops%(i,2)
NEXT i
sblock=vsblock
lz=vlz
mbs=vmbs
sms=vsms
sms2=vsms2
zoomp=vzoomp
srollp=vscrollp
sloop=vsloop
mamidi=vmamidi
loded=FALSE
RETURN
'
> PROCEDURE infhol
.| Glob. Var.: vper#,per#,vpath$,path$,vsmpnam$,smpnam$,vsmplen#,smplen#
.|     vordner$,ordner$,vmrkdatum$,mrkdatum$,vretime#,retime#,vorcs#,cs#
.|     vorce#,ce#,i#,loopz#,bloopz#,vsblock#,sblock#,vsloop#,sloop#,vmamidi#
.|     mamidi#,vlz#,lz#,vmbs#,mbs#,vsms#,sms#,vsme#,sme#,vmaster#,master#
.|     vzoomp#,zoomp#,vsrollp#,scrollp#
.| Felder    : vloops#(),loops#(),vloope#(),loope#(),vbloops#(),bloops#()
.|     vbloope#(),bloope#()
.| Aufruf in : smpsave-1,ldhlp-1,record4-1,
vdig24=dig24
vper=per
vpath$=path$
vsmpnam$=smpnam$
vsmplen=smplen
vordner$=ordner$
vmrkdatum$=mrkdatum$
vretime=retime
vorcs=cs
vorce=ce
FOR i=1 TO loopz
vloops%(i,1)=loops%(i,1)
vloops%(i,2)=loops%(i,2)
NEXT i
FOR i=1 TO bloopz
vbloops%(i,1)=bloops%(i,1)
vbloops%(i,2)=bloops%(i,2)
NEXT i
vsblock=sblock
vsloop=sloop
vmamidi=mamidi
vlz=lz
vmbs=mbs
vsms=sms
vsms2=sms2
vzoomp=zoomp
vsrollp=scrollp
RETURN
'
> PROCEDURE makedatum
.| Glob. Var.: mrkdatum$
.| Aufruf in : smpsave-1,smpinfbutt-1,record4-1,
LOCAL d$
d$=DATE$
mrkdatum$=LEFT$(d$,LEN(d$)-4)+RIGHT$(d$,2)+"  "+LEFT$(TIME$,5)+CHR$(0)
RETURN
'
> PROCEDURE smpinfbutt
.| Glob. Var.: obj#,bnam$,smpnam$,fil$,path$,mbs#,virtual#,smplen#,vmem#
.|     per#,hz#,infbutt#
.| Ruft auf  : setbutton,makedatum,makehz,sampleinf
.| Aufruf in : do_smpedit-1,
LOCAL d$
@setbutton(obj,0)
bnam$=smpnam$
fil$=path$
IF mbs=0 AND virtual=FALSE THEN
smplen=vmem
@makedatum
@makehz
per=hz
ENDIF
infbutt=TRUE
@sampleinf
infbutt=FALSE
RETURN
'
> PROCEDURE loadloops(ldloop)
LOCAL i
INPUT #2,v$              !  "STARTRACK-INF V1.0"  Versionskontrolle
iv=0
IF v$="STARTRACK-INF V1.0" THEN
iv=1
ENDIF
IF v$="STARTRACK-INF V1.1" THEN
iv=1.1
ENDIF
IF v$="STARTRACK-INF V1.2" THEN
iv=1.2
ENDIF
IF iv=0 THEN
CLOSE #2
OPEN "I",#2,b$
ENDIF
IF iv=0 THEN
FOR i=1 TO bloopz
INPUT #2,bloops%(i,1)
INPUT #2,bloops%(i,2)
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
NEXT i
FOR i=bloopz+1 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
NEXT i
ENDIF
IF iv=1.2 AND ldloop=TRUE THEN
@inftexts
IF ldloop=TRUE THEN
comm$=src1$
src$=src2$
ENDIF
ENDIF
IF (iv=1 OR iv=1.1) OR (iv=1.2 AND ldloop=TRUE) THEN
IF iv=1.1 OR iv=1.2 THEN
INPUT #2,mloopz
IF mloopz>loopz THEN
mloopz=loopz
ENDIF
ELSE
mloopz=100
IF loopz>mloopz THEN
FOR i=mloopz+1 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
ENDIF
ENDIF
FOR i=1 TO mloopz
INPUT #2,bloops%(i,1)
INPUT #2,bloops%(i,2)
INPUT #2,bloops%(i,3)
INPUT #2,bloops%(i,4)
c$=""
REPEAT
INPUT #2,a$
IF a$<>CHR$(0) THEN
c$=c$+a$
ENDIF
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
c$=c$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
vedmtxt$(i)=c$
NEXT i
IF (loopz>mloopz AND loopz>100) OR iv=1.1 THEN
FOR i=100 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
ENDIF
ENDIF
RETURN
'
> PROCEDURE sampleinf
.| Glob. Var.: virtld#,vornr#,nr#,smpinf&,infbutt#,sinfcomm&,sinfsrc&,isave#
.|     sinfname&,bnam$,smplen#,per#,sinflen&,sinfrate&,fil$,mdat2%,mrkdatum$
.|     sinfdate&,fileart#,i#,bloopz#,lma#,vtst#,sblock#,lmin#,c$,src$,b$
.|     ordner$,inf$,j#,markfull#,sa#,se#,scr$,sinfsus1&,sinfsus2&,sinfrel1&
.|     sinfrel2&,sinfl1&,sinfl2&,sinfl3&,sinfl4&,sinfl5&,sinfl6&,sinfl7&
.|     sinfl8&,sinfl9&,sinfl10&,sinfl11&,sinfl12&,l#,hz#,xlmin#,xlma#,obj#
.|     popup&,zu%,zuadr#,edit_obj&,buttadr#,but#,objadr#,objflag#,sinhelp&
.|     sinfexit&,sinfok&,inf#,head#,mlen#,blockld#,blks#,meml#,memh#
.|     commtxt$,srctxt$,infname$
.| Felder    : bloops#(),bloope#(),loops#(),loope#()
.| Ruft auf  : rsc_draw,editfeld,markhlp,textfeld,marksearch,findblock
.|     markset,blocklook,markhlp7,rsc_do,xrsrc_gaddr,mousek,helptxt
.|     busy_mouse,maschinit9,maschruf9,infrett,editread,setbutton,restaura2
.|     rsc_back,restaura3
.| Aufruf in : smpsave-1,ldhlp-8,smpinfbutt-1,record4-1,
LOCAL a,b,t,d,m,day,a$,f$,vcs,vce,vln,t$,d$,exi
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
edclr=FALSE
IF virtld=FALSE THEN
IF ldtrk2=FALSE THEN
vornr=nr
nr=smpinf&
IF infbutt=TRUE THEN
@rsc_draw(nr,0)    ! sollte 5 sein
ELSE
@rsc_draw(nr,0)
ENDIF
@editfeld(sinfcomm&,CHR$(0))
@editfeld(sinfsrc&,CHR$(0))
@markhlp
ENDIF
IF isave=FALSE THEN
IF ldtrk2=FALSE THEN
a$=bnam$+CHR$(0)
IF LEN(a$)>33 THEN
a$=RIGHT$(a$,33)+CHR$(0)
ENDIF
@textfeld(sinfname&,a$,1)
hsec=INT(smplen/per/mbit)*100
htimeset
a$=STR$(INT(smplen/mbit))+" samples = "+a$
IF LEN(a$)>33 THEN
a$=STR$(INT(smplen/mbit))+"/"+STR$(INT(smplen/per/mbit*1000)/1000)+CHR$(0)
ENDIF
IF LEN(a$)>33 THEN
a$=STR$(INT(smplen/mbit))+" samples"+CHR$(0)
ENDIF
IF LEN(a$)>33 THEN
a$=RIGHT$(a$,33)+CHR$(0)
ENDIF
@textfeld(sinflen&,a$,1)
a$=STR$(INT(per/100)/10)+" KHz"+CHR$(0)
@textfeld(sinfrate&,a$,1)
ENDIF
IF infbutt=FALSE THEN
f$=fil$+CHR$(0)
a=GEMDOS(61,L:VARPTR(f$),0)
IF a>=0 THEN
~GEMDOS(87,L:mdat2%,a,0)
b=GEMDOS(62,a)
t=DPEEK(mdat2%)
d=DPEEK(mdat2%+2)
day=(d AND 31)
d=(d AND (65535-31))
d=SHR(d,5)
m=(d AND 15)
d=80+SHR(d,4)
IF d>99 THEN
d=d-100
ENDIF
d$=RIGHT$("0"+STR$(d),2)
a$=STR$(day)+"."+STR$(m)+"."+d$
t=SHR(t,5)
d=(t AND 63)
d$=RIGHT$("0"+STR$(d),2)
t=SHR(t,6)
t$=RIGHT$("0"+STR$(t),2)
a$=a$+"  "+t$+":"+d$+CHR$(0)
mrkdatum$=a$
IF ldtrk2=FALSE THEN
@textfeld(sinfdate&,a$,1)
ENDIF
ELSE
IF ldtrk2=FALSE THEN
a$=CHR$(0)
@textfeld(sinfdate&,a$,1)
ENDIF
ENDIF
ELSE
IF ldtrk2=FALSE THEN
@textfeld(sinfdate&,mrkdatum$,1)
ENDIF
ENDIF
IF infbutt=FALSE THEN
IF fileart<>6 THEN
FOR i=1 TO bloopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
NEXT i
IF lma>0 AND vtst=FALSE AND sblock=1 THEN
bloops%(1,1)=INT(lmin/mbit)
bloops%(1,2)=INT(lma/mbit)
ENDIF
ENDIF
comm$=""
src$=""
a=RINSTR(bnam$,".")
b$=ordner$+LEFT$(bnam$,a)+inf$
exi=FALSE
IF EXIST(b$)=TRUE THEN
exi=TRUE
OPEN "I",#2,b$
@loadloops(TRUE)
IF (iv=1 OR iv=1.1) THEN
@inftexts
ENDIF
comm$=src1$
src$=src2$
IF fileart<>6 THEN
IF iv=0 THEN
a=bloopz
ELSE
a=loopz
ENDIF
FOR j=1 TO a
IF blks=0 THEN
markfre=j
ELSE
markfre=j+sms
ENDIF
IF bloops%(j,1)<>-1 THEN
sa=bloops%(j,1)*mbit
ELSE
sa=-1
ENDIF
IF bloops%(j,2)<>-1 THEN
se=bloops%(j,2)*mbit
ELSE
se=-1
ENDIF
IF bloops%(j,3)<>-1 THEN
sa2=bloops%(j,3)*mbit
ELSE
sa2=-1
ENDIF
IF bloops%(j,4)<>-1 THEN
se2=bloops%(j,4)*mbit
ELSE
se2=-1
ENDIF
ah$=vedmtxt$(j)
@findblock
EXIT IF markfre=loopz
NEXT j
'
IF loopz>a THEN
FOR j=a+1 TO loopz
loops%(j,1)=-1
loops%(j,2)=-1
loops%(j,3)=-1
loops%(j,4)=-1
NEXT j
ENDIF
'
IF blks=0 THEN
sms=1
ENDIF
IF nr=smpedit& THEN
@markhlp3(markfre,1,loops%(sms,1))
@markhlp3(markfre,2,loops%(sms,2))
@markhlp3(markfre,3,loops%(sms,3))
@markhlp3(markfre,4,loops%(sms,4))
ENDIF
ENDIF
CLOSE #2
ELSE
IF (fileart=1 OR fileart=2) AND sblock=1 THEN
@marksearch
@markset
ENDIF
ENDIF
ENDIF
IF ldtrk2=FALSE THEN
IF bloops%(1,1)<>-1 THEN
@textfeld(sinfsus1&,STR$(bloops%(1,1))+CHR$(0),1)
ELSE
@textfeld(sinfsus1&,CHR$(0),1)
ENDIF
IF bloops%(1,2)<>-1 THEN
@textfeld(sinfsus2&,STR$(bloops%(1,2))+CHR$(0),1)
ELSE
@textfeld(sinfsus2&,CHR$(0),1)
ENDIF
IF fileart=6 OR exi=TRUE OR infbutt=TRUE THEN
IF exi=TRUE OR (infbutt=TRUE AND EXIST(b$)=TRUE) THEN
@editfeld(sinfcomm&,comm$+CHR$(0))
@editfeld(sinfsrc&,src$+CHR$(0))
ELSE
@editfeld(sinfcomm&,CHR$(0))
@editfeld(sinfsrc&,CHR$(0))
ENDIF
IF bloops%(1,3)<>-1 THEN
@textfeld(sinfrel1&,STR$(bloops%(1,3))+CHR$(0),1)
ELSE
@textfeld(sinfrel1&,CHR$(0),1)
ENDIF
IF bloops%(1,4)<>-1 THEN
@textfeld(sinfrel2&,STR$(bloops%(1,4))+CHR$(0),1)
ELSE
@textfeld(sinfrel2&,CHR$(0),1)
ENDIF
IF bloops%(2,1)<>-1 THEN
@textfeld(sinfl1&,STR$(bloops%(2,1))+CHR$(0),1)
ELSE
@textfeld(sinfl1&,CHR$(0),1)
ENDIF
IF bloops%(2,2)<>-1 THEN
@textfeld(sinfl2&,STR$(bloops%(2,2))+CHR$(0),1)
ELSE
@textfeld(sinfl2&,CHR$(0),1)
ENDIF
IF bloops%(3,1)<>-1 THEN
@textfeld(sinfl3&,STR$(bloops%(3,1))+CHR$(0),1)
ELSE
@textfeld(sinfl3&,CHR$(0),1)
ENDIF
IF bloops%(3,2)<>-1 THEN
@textfeld(sinfl4&,STR$(bloops%(3,2))+CHR$(0),1)
ELSE
@textfeld(sinfl4&,CHR$(0),1)
ENDIF
IF bloops%(4,1)<>-1 THEN
@textfeld(sinfl5&,STR$(bloops%(4,1))+CHR$(0),1)
ELSE
@textfeld(sinfl5&,CHR$(0),1)
ENDIF
IF bloops%(4,2)<>-1 THEN
@textfeld(sinfl6&,STR$(bloops%(4,2))+CHR$(0),1)
ELSE
@textfeld(sinfl6&,CHR$(0),1)
ENDIF
IF bloops%(5,1)<>-1 THEN
@textfeld(sinfl7&,STR$(bloops%(5,1))+CHR$(0),1)
ELSE
@textfeld(sinfl7&,CHR$(0),1)
ENDIF
IF bloops%(5,2)<>-1 THEN
@textfeld(sinfl8&,STR$(bloops%(5,2))+CHR$(0),1)
ELSE
@textfeld(sinfl8&,CHR$(0),1)
ENDIF
IF bloops%(6,1)<>-1 THEN
@textfeld(sinfl9&,STR$(bloops%(6,1))+CHR$(0),1)
ELSE
@textfeld(sinfl9&,CHR$(0),1)
ENDIF
IF bloops%(6,2)<>-1 THEN
@textfeld(sinfl10&,STR$(bloops%(6,2))+CHR$(0),1)
ELSE
@textfeld(sinfl10&,CHR$(0),1)
ENDIF
IF bloops%(7,1)<>-1 THEN
@textfeld(sinfl11&,STR$(bloops%(7,1))+CHR$(0),1)
ELSE
@textfeld(sinfl11&,CHR$(0),1)
ENDIF
IF bloops%(7,2)<>-1 THEN
@textfeld(sinfl12&,STR$(bloops%(7,2))+CHR$(0),1)
ELSE
@textfeld(sinfl12&,CHR$(0),1)
ENDIF
ELSE
@editfeld(sinfcomm&,CHR$(0))
@editfeld(sinfsrc&,CHR$(0))
@textfeld(sinfrel1&,CHR$(0),1)
@textfeld(sinfrel2&,CHR$(0),1)
@textfeld(sinfl1&,CHR$(0),1)
@textfeld(sinfl2&,CHR$(0),1)
@textfeld(sinfl3&,CHR$(0),1)
@textfeld(sinfl4&,CHR$(0),1)
@textfeld(sinfl5&,CHR$(0),1)
@textfeld(sinfl6&,CHR$(0),1)
@textfeld(sinfl7&,CHR$(0),1)
@textfeld(sinfl8&,CHR$(0),1)
@textfeld(sinfl9&,CHR$(0),1)
@textfeld(sinfl10&,CHR$(0),1)
@textfeld(sinfl11&,CHR$(0),1)
@textfeld(sinfl12&,CHR$(0),1)
ENDIF
ENDIF
ELSE
@blocklook
d$=DATE$
d$=LEFT$(d$,LEN(d$)-4)+RIGHT$(d$,2)
IF ldtrk2=FALSE THEN
a$=bnam$+CHR$(0)
IF LEN(a$)>33 THEN
a$=RIGHT$(a$,33)+CHR$(0)
ENDIF
@textfeld(sinfname&,a$,1)
hsec=INT(l/hz/mbit)*100
@htimeset
a$=STR$(INT(l/mbit))+" samples = "+a$
IF LEN(a$)>33 THEN
a$=STR$(INT(l/mbit))+"/"+STR$(INT(l/hz/mbit*1000)/1000)+CHR$(0)
ENDIF
IF LEN(a$)>33 THEN
a$=STR$(INT(l/mbit))+" samples"+CHR$(0)
ENDIF
IF LEN(a$)>33 THEN
a$=RIGHT$(a$,33)+CHR$(0)
ENDIF
@textfeld(sinflen&,a$+CHR$(0),1)
@textfeld(sinfrate&,STR$(INT(hz/100)/10)+" kHz"+CHR$(0),1)
@textfeld(sinfdate&,d$+"  "+LEFT$(TIME$,5)+CHR$(0),1)
ENDIF
'
IF virtual=TRUE THEN
@editfeld(sinfcomm&,comm$+CHR$(0))
@editfeld(sinfsrc&,src$+CHR$(0))
ENDIF
'
IF sblock=1 THEN
xlmin=lmin
xlma=lma
@markhlp7
'        bloops%(1,1)=INT(lmin/mbit)
'        bloops%(1,2)=INT(lma/mbit)
IF ldtrk2=FALSE THEN
@textfeld(sinfsus1&,STR$(bloops%(1,1))+CHR$(0),1)
@textfeld(sinfsus2&,STR$(bloops%(1,2))+CHR$(0),1)
ENDIF
lmin=xlmin
lma=xlma
ELSE
FOR i=1 TO bloopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
IF ldtrk2=FALSE THEN
@textfeld(sinfsus1&,CHR$(0),1)
@textfeld(sinfsus2&,CHR$(0),1)
ENDIF
ENDIF
IF ldtrk2=FALSE THEN
a=RINSTR(fil$,".")
b$=LEFT$(fil$,a)+inf$
@textfeld(sinfrel1&,CHR$(0),1)
@textfeld(sinfrel2&,CHR$(0),1)
IF loops%(2,1)<>-1 THEN
@textfeld(sinfl1&,STR$(INT(loops%(2,1)/mbit))+CHR$(0),1)
ELSE
@textfeld(sinfl1&,CHR$(0),1)
ENDIF
IF loops%(2,2)<>-1 THEN
@textfeld(sinfl2&,STR$(INT(loops%(2,2)/mbit))+CHR$(0),1)
ELSE
@textfeld(sinfl2&,CHR$(0),1)
ENDIF
IF loops%(3,1)<>-1 THEN
@textfeld(sinfl3&,STR$(INT(loops%(3,1)/mbit))+CHR$(0),1)
ELSE
@textfeld(sinfl3&,CHR$(0),1)
ENDIF
IF loops%(3,2)<>-1 THEN
@textfeld(sinfl4&,STR$(INT(loops%(3,2)/mbit))+CHR$(0),1)
ELSE
@textfeld(sinfl4&,CHR$(0),1)
ENDIF
IF loops%(4,1)<>-1 THEN
@textfeld(sinfl5&,STR$(INT(loops%(4,1)/mbit))+CHR$(0),1)
ELSE
@textfeld(sinfl5&,CHR$(0),1)
ENDIF
IF loops%(4,2)<>-1 THEN
@textfeld(sinfl6&,STR$(INT(loops%(4,2)/mbit))+CHR$(0),1)
ELSE
@textfeld(sinfl6&,CHR$(0),1)
ENDIF
IF loops%(5,1)<>-1 THEN
@textfeld(sinfl7&,STR$(INT(loops%(5,1)/mbit))+CHR$(0),1)
ELSE
@textfeld(sinfl7&,CHR$(0),1)
ENDIF
IF loops%(5,2)<>-1 THEN
@textfeld(sinfl8&,STR$(INT(loops%(5,2)/mbit))+CHR$(0),1)
ELSE
@textfeld(sinfl8&,CHR$(0),1)
ENDIF
@textfeld(sinfl9&,CHR$(0),1)
@textfeld(sinfl10&,CHR$(0),1)
@textfeld(sinfl11&,CHR$(0),1)
@textfeld(sinfl12&,CHR$(0),1)
ENDIF
ENDIF
IF ldtrk2=FALSE THEN
REPEAT
REPEAT
obj=@rsc_do(nr,obj,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>sinfcomm& AND obj<>sinfsrc&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=sinfhelp& THEN
@helptxt("SAMPLE-INFO")
ENDIF
UNTIL obj=sinfexit& OR obj=sinfok&
IF obj=sinfok& THEN
edclr=TRUE
inf=TRUE
IF infbutt=FALSE THEN
@busy_mouse
ENDIF
IF ((virtld=FALSE AND (smplen-head)<=mlen) OR blockld=TRUE) AND blks=0 AND infbutt=FALSE AND isave=FALSE THEN
@maschruf9(meml,memh)
ENDIF
ELSE
inf=FALSE
IF infbutt=FALSE THEN
b$=""
infname$=""
comm$=""
src$=""
@infrett
ENDIF
ENDIF
ENDIF
ELSE
inf=TRUE
ENDIF
IF ldtrk2=FALSE THEN
IF (isave=TRUE OR infbutt=TRUE) AND inf=TRUE THEN
@editread(sinfcomm&)
commtxt$=a$+CHR$(0)
@editread(sinfsrc&)
srctxt$=a$+CHR$(0)
infname$=b$
@infchange
ENDIF
IF virtld=FALSE THEN
@setbutton(obj,0)
ENDIF
IF infbutt=TRUE THEN
@restaura2
ELSE
IF virtld=FALSE THEN
@rsc_back(nr)
nr=vornr
IF edclr=TRUE THEN
'        @restaura3
ENDIF
ENDIF
ENDIF
ENDIF
IF ldtrk2=TRUE THEN
inf=TRUE
ENDIF
IF inf=TRUE AND virtld=TRUE THEN
edclr=TRUE
ENDIF
obj=0
RETURN
'
> PROCEDURE infsave
.| Glob. Var.: blks#,meml#,blksa#,blkse#,infname$,sector#,loopz#,bloopz#
.|     commtxt$,srctxt$
.| Felder    : loops#(),loope#()
.| Ruft auf  : nomem
.| Aufruf in : smpsave-1,record4-1,
LOCAL m,m2,a,b,i
IF blks=0 THEN
m=0
m2=meml
ELSE
m=blksa-meml
m2=blkse-meml
ENDIF
a=ASC(LEFT$(infname$,1))-64
IF DFREE(a)>sector THEN
OPEN "O",#2,infname$
PRINT #2,"STARTRACK-INF V1.2"           ! Versionskontrolle
PRINT #2,commtxt$
PRINT #2,srctxt$
PRINT #2,loopz
FOR i=1 TO loopz
b=INT((loops%(i,1)-m)/mbit)
IF b<0 OR b>m2 THEN
b=-1
ENDIF
PRINT #2,b
b=INT((loops%(i,2)-m)/mbit)
IF b<0 OR b>m2 THEN
b=-1
ENDIF
PRINT #2,b
b=INT((loops%(i,3)-m)/mbit)
IF b<0 OR b>m2 THEN
b=-1
ENDIF
PRINT #2,b
b=INT((loops%(i,4)-m)/mbit)
IF b<0 OR b>m2 THEN
b=-1
ENDIF
PRINT #2,b
PRINT #2,edmtxt$(i)+CHR$(0)
NEXT i
CLOSE #2
keym=FALSE
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE infload
a=RINSTR(fil$,".")
b$=LEFT$(fil$,a)+inf$
infname$=b$
IF EXIST(infname$) THEN
OPEN "I",#2,b$
'
INPUT #2,v$              !  "STARTRACK-INF V1.0"  Versionskontrolle
iv=0
IF v$="STARTRACK-INF V1.0" THEN
iv=1
ENDIF
IF v$="STARTRACK-INF V1.1" THEN
iv=1.1
ENDIF
IF v$="STARTRACK-INF V1.2" THEN
iv=1.2
ENDIF
IF iv=0 THEN
CLOSE #2
OPEN "I",#2,b$
ENDIF
IF iv=0 THEN
FOR i=1 TO bloopz
INPUT #2,bloops%(i,1)
INPUT #2,bloops%(i,2)
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
NEXT i
FOR i=bloopz+1 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
NEXT i
ENDIF
IF iv=1.2 THEN
@inftexts
ENDIF
IF iv=1 OR iv=1.1 OR iv=1.2 THEN
IF iv=1.1 THEN
INPUT #2,mloopz
IF mloopz>loopz THEN
mloopz=loopz
ENDIF
ELSE
mloopz=100
IF loopz>100 THEN
FOR i=101 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
ENDIF
ENDIF
FOR i=1 TO mloopz
INPUT #2,bloops%(i,1)
INPUT #2,bloops%(i,2)
INPUT #2,bloops%(i,3)
INPUT #2,bloops%(i,4)
c$=""
REPEAT
INPUT #2,a$
IF a$<>CHR$(0) THEN
c$=c$+a$
ENDIF
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
c$=c$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
vedmtxt$(i)=c$
NEXT i
ENDIF
IF iv=1 OR iv=1.1 THEN
@inftexts
ENDIF
CLOSE #2
ENDIF
keym=FALSE
RETURN
'
> PROCEDURE inftexts
src1$=""
REPEAT
INPUT #2,a$
IF a$<>CHR$(0) THEN
src1$=src1$+a$
ENDIF
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
src1$=src1$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
src2$=""
REPEAT
INPUT #2,a$
IF a$<>CHR$(0) THEN
src2$=src2$+a$
ENDIF
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
src2$=src2$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
RETURN
'
> PROCEDURE infsave2
IF keym=TRUE THEN
FOR i=kms+1 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
@alerts(62)
IF g=1 THEN
@infsave3
ENDIF
'    sms=1
'    sms2=0
'    vsms=0
FOR i=1 TO kms
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
IF nr=smpedit& THEN
a$=STR$(sms)+CHR$(0)
@textfeld(edmnr&,a$,1)
@setslide(edmslide&,edmbut&,loopz,5,vsms)
'      @markhlp3(sms,sms2,bloops%(sms,sms2))
'      @edmarkdel
ENDIF
ENDIF
RETURN
'
> PROCEDURE infsave3
LOCAL m,m2,a,b,i
a=ASC(LEFT$(infname$,1))-64
IF DFREE(a)>sector THEN
OPEN "O",#2,infname$
PRINT #2,"STARTRACK-INF V1.2"           ! Versionskontrolle
IF hdr=TRUE THEN
PRINT #2,vcomm$
PRINT #2,vsrc$
PRINT #2,loopz
FOR i=1 TO loopz
b=INT(bloops%(i,1)/mbit)
PRINT #2,b
b=INT(bloops%(i,2)/mbit)
PRINT #2,b
b=INT(bloops%(i,3)/mbit)
PRINT #2,b
b=INT(bloops%(i,4)/mbit)
PRINT #2,b
PRINT #2,vedmtxt$(i)+CHR$(0)
NEXT i
ELSE
PRINT #2,comm$
PRINT #2,src$
PRINT #2,loopz
IF virtual=FALSE THEN
FOR i=1 TO loopz
b=INT(bloops%(i,1)/mbit)
PRINT #2,b
b=INT(bloops%(i,2)/mbit)
PRINT #2,b
b=INT(bloops%(i,3)/mbit)
PRINT #2,b
b=INT(bloops%(i,4)/mbit)
PRINT #2,b
PRINT #2,edmtxt$(i)+CHR$(0)
NEXT i
ELSE
FOR i=1 TO loopz
b=INT(loops%(i,1)/mbit)
PRINT #2,b
b=INT(loops%(i,2)/mbit)
PRINT #2,b
b=INT(loops%(i,3)/mbit)
PRINT #2,b
b=INT(loops%(i,4)/mbit)
PRINT #2,b
PRINT #2,edmtxt$(i)+CHR$(0)
NEXT i
ENDIF
ENDIF
CLOSE #2
keym=FALSE
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE infchange
LOCAL a
IF infbutt=TRUE THEN
vblks=blks
blks=0
IF EXIST(fil$) THEN
a=INSTR(fil$,".")
IF a>0 THEN
IF LEFT$(fil$,a)=LEFT$(infname$,a) THEN
IF hdp=FALSE THEN
comm$=commtxt$
src$=srctxt$
ELSE
srctxt$=vsrc$
commtxt$=vcomm$
FOR i=1 TO loopz
edmtxt$(i)=vedmtxt$(i)
NEXT i
ENDIF
@infsave
ENDIF
ENDIF
ENDIF
blks=vblks
kms=0
ENDIF
RETURN
'
> PROCEDURE ldhead
.| Glob. Var.: datx#,mdat%,fil$,f#,abz#,abz2#,head#,fileart#,danf#,tst1#
.|     per#,vhz#,tst2#,tst3#,tst4#,tst5#,tst6#,x#,y#,hz#
.| Ruft auf  : makehz,ldhztest
.| Aufruf in : ldhlp-1,trakload-1,hardfs-1,
head=0
tbmin=0
tbmax=0
tblock=0
datx=mdat%
OPEN "I",#1,fil$
f=LOF(#1)
BGET #1,datx,4
abz=DPEEK(datx)
abz2=LPEEK(datx)
IF abz=&HF07E THEN
head=20   ! HeaderlÑnge fÅr S16-Files
fileart=1
ENDIF
IF abz2=&H32424954 THEN
head=128   ! HeaderlÑnge fÅr AVR-Files
fileart=2
ENDIF
IF abz2=&H52494646 THEN
head=44   ! HeaderlÑnge fÅr WAV-Files
fileart=3
ENDIF
IF abz2=&H2E736E64 THEN
head=28   ! HeaderlÑnge fÅr AU und SND-Files
fileart=4
ENDIF
IF abz2=&H538000C THEN
head=1336 ! HeaderlÑnge fÅr SD-Files
fileart=5
ENDIF
IF abz2=&HF07E0001 THEN
head=296 ! HeaderlÑnge fÅr Avalon SMP-Files
fileart=6
ENDIF
IF abz2=&H464F524D THEN
head=54+458 ! HeaderlÑnge fÅr AIFF-Files
fileart=7
ENDIF
IF head>4 THEN
IF fileart<>6 THEN
BGET #1,datx+4,head-4
ELSE
SEEK #1,LOF(#1)-head
BGET #1,datx,head
ENDIF
ENDIF
CLOSE #1
danf=datx
IF fileart=7 THEN        ! AIFF-Format
tst1=LPEEK(danf+8)     ! AIFF-Kennung
tst2=LPEEK(danf+12)    ! COMM-Kennung
tst3=DPEEK(danf+20)    ! Channels
tst4=LPEEK(danf+38)    ! SSND-Kennung
tst5=DPEEK(danf+26)    ! Bits
IF tst5=16 THEN
@setbitrate16
ENDIF
IF tst5=24 THEN
@setbitrate24
ENDIF
'
IF tst1=&H41494646 AND tst2=&H434F4D4D AND tst3=2 AND tst4=&H53534E44 AND (tst5=16 OR tst5=24) THEN
per=DPEEK(danf+30)     ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=6 THEN        ! Avalon SMP-Format
tst1=DPEEK(danf+76)    ! Bits
IF tst1=16 THEN
per=LPEEK(danf+72)     ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=5 THEN        ! SD-Format
per=LPEEK(danf+1020)   ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
IF fileart=4 THEN        ! AU-Format
tst1=LPEEK(danf+12)    ! dataformat
tst2=LPEEK(danf+20)    ! channelcount
IF tst1=3 AND tst2=2 THEN
per=LPEEK(danf+16)    ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=3 THEN        ! WAV-Format
tst1=LPEEK(danf+8)     ! "WAVE"
tst2=LPEEK(danf+12)    ! "fmt "
tst3=PEEK(danf+20)     ! format
tst4=PEEK(danf+22)     ! channels
tst5=PEEK(danf+32)     ! align
tst6=PEEK(danf+34)     ! bps
IF tst6=16 THEN
@setbitrate16
ENDIF
IF tst6=24 THEN
@setbitrate24
ENDIF
IF tst1=&H57415645 AND tst2=&H666D7420 AND tst3=1 AND tst4=2 AND tst5=4 AND (tst6=16 OR tst6=24) THEN
per=PEEK(danf+24)+256*PEEK(danf+25)    ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=2 THEN        ! AVR-Format
tst1=DPEEK(danf+12)    ! mode
tst2=DPEEK(danf+14)    ! resolution
IF tst2=16 THEN
@setbitrate16
ENDIF
IF tst2=24 THEN
@setbitrate24
ENDIF
tst3=DPEEK(danf+16)    ! sign
IF tst1=&HFFFF AND (tst2=16 OR tst2=24) AND tst3=&HFFFF THEN
per=DPEEK(danf+24)    ! Sample-Rate
la=DPEEK(danf+18)                           ! Loop ?
IF la=&HFFFF THEN
tblock=1
tbmin=LPEEK(danf+30)*2                          ! Sustain Loop-Start
tbmax=LPEEK(danf+34)*2                           ! Sustain Loop-End
ENDIF
ENDIF
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=INT(per/100)*100
ENDIF
vhz=per
ENDIF
IF fileart=1 THEN                   ! S16-Format
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
la=PEEK(danf+19)                          ! Loop-Art
IF la<>&H7F THEN
tblock=1
x3=PEEK(danf+13)                           ! Sustain Loop-Start
y3=DPEEK(danf+14)                          ! Sustain Loop-Start
tbmin=x3*65536+y3
x4=DPEEK(danf+16)                          ! Sustain Loop-End
y4=PEEK(danf+18)                           ! Sustain Loop-End
tbmax=x4*256+y4
ENDIF
IF x=0 AND y=0 THEN
@makehz
per=hz
ELSE
per=INT(10^9/(x*65536+y))
per=INT(per/100)*100
ENDIF
per=INT(per)
IF per<>32000 AND per<>44100 AND per<>48000 THEN
@ldhztest
ENDIF
vhz=per
ENDIF
IF fileart=0 THEN
vhz=INT(hz/100)*100
ENDIF
RETURN
'
> PROCEDURE clsed
.| Glob. Var.: nr#,smpedit&,smptsa&,smptsb&,smptsc&,smptsd&,smptse&
.|     smptsava&,smptea&,smpteb&,smptec&,smpted&,smptee&,smptsavb&,hacksa&
.|     hacksb&,hacksc&,hacksd&,hackse&,hackss&,hackea&,hackeb&,hackec&
.|     hacked&,hackee&,hackes&,smpsta&,smpstb&,smpstc&,smpstd&,smpste&
.|     smpsavl&,smpea&,smpeb&,smpec&,smped&,smpee&,smpsavr&,sms#,sme#
.|     master#,sblock#,smppmark&,sloop#,smploop&,a$,popups&,smpmark&,mover&
.|     smark#
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : ldhlp-2,smpedit-2,trash-2,memtovirt-1,memtovirt2-1,record2-1,
LOCAL hac$,mem$
mem$=SPACE$(14)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(edmtxt&,mem$,1)
@textfeld(edmtims&,mem$,1)
@textfeld(edmtime&,mem$,1)
@textfeld(edmtimi&,mem$,1)
@textfeld(edmtimr&,mem$,1)
@setbutton(edmbuts&,0)
@setbutton(edmbute&,0)
@setbutton(edmbuti&,0)
@setbutton(edmbutr&,0)
ENDIF
sms=1
sms2=0
sblock=0
blks=0
IF nr=smpedit& THEN
@setbutton(smppmark&,0)
IF sloop=1 THEN
@setbutton(smploop&,1)
ELSE
@setbutton(smploop&,0)
ENDIF
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
ENDIF
smark=3
RETURN
'
> PROCEDURE curvetest(cs,ce)
.| Glob. Var.: zoomstop#
.| Aufruf in : zoomhelp-1,smpr-1,
zoomstop=FALSE
LOCAL xm,len,stp,bs
xm=617
len=ce-cs
stp=(INT(len/xm))
stp=(INT((stp+1)/mbit)*mbit)
bs=0
IF stp=0 THEN
stp=mbit
IF len>xm*mbit THEN
bs=len/xm/mbit
ELSE
bs=xm*mbit/len
ENDIF
ENDIF
IF bs>7 THEN
zoomstop=TRUE
ENDIF
RETURN
'
> PROCEDURE writeyproz
.| Glob. Var.: max#,yzoom#,wyzoom#,rubmax#,rp0&,lp0&,lp20&,lm20&,rp20&,rm20&
.|     lp40&,lm40&,rp40&,rm40&,lp60&,lm60&,rp60&,rm60&,lp80&,lm80&,rp80&
.|     rm80&,byzoom#
.| Ruft auf  : textfeld
.| Aufruf in : rubbermax-1,curve-2,smpedit-1,
LOCAL a,m,b$
IF max=0 OR (yzoom=FALSE AND wyzoom=FALSE) THEN
m=32767
ELSE
m=max
ENDIF
IF wyzoom=TRUE THEN
m=rubmax
ENDIF
a=100/32767*m
b$=" 0-"+CHR$(0)
@textfeld(rp0&,b$,1)
@textfeld(lp0&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*2))+"-",3)+CHR$(0)
@textfeld(lp20&,b$,1)
@textfeld(lm20&,b$,1)
@textfeld(rp20&,b$,1)
@textfeld(rm20&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*4))+"-",3)+CHR$(0)
@textfeld(lp40&,b$,1)
@textfeld(lm40&,b$,1)
@textfeld(rp40&,b$,1)
@textfeld(rm40&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*6))+"-",3)+CHR$(0)
@textfeld(lp60&,b$,1)
@textfeld(lm60&,b$,1)
@textfeld(rp60&,b$,1)
@textfeld(rm60&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*8))+"-",3)+CHR$(0)
@textfeld(lp80&,b$,1)
@textfeld(lm80&,b$,1)
@textfeld(rp80&,b$,1)
@textfeld(rm80&,b$,1)
b$=RIGHT$("  "+STR$(INT(a)),3)+CHR$(0)
@textfeld(lr100&,b$,1)
byzoom=yzoom
RETURN
'
> PROCEDURE getcurve
ym1=ay&+41+8          ! Y-Locator erste Box
ym2=ym2+ym1+3         ! Y-Locator zweite Box
LOCAL x,y,b,h
IF nr=smpedit& THEN
IF windcache=TRUE THEN
@windowtest
@markhlp
IF bigfoot=FALSE THEN
x=ax&+23-1          ! X-Locator
y=ay&+41-8          ! Y-Locator erste Box
b=xm+3              ! Breite der Box
h=ym*2+24              ! Hîhe der Box
ELSE
@calc_editboxes1
x=ax&+24-1          ! X-Locator
y=ay&+41            ! Y-Locator erste Box
b=xm+16              ! Breite der Box
h=ym*2+19           ! Hîhe der Box
ENDIF
lmcurv=b*h*planes&/8
~GRAF_MOUSE(256,0)                              ! Hidem
IF shading=FALSE THEN
IF firstnc=0 THEN
memc=@rsc_get(x,y,b,h)
firstnc=1
ELSE
memc=@rsc_get2(x,y,b,h,memc)
ENDIF
ENDIF
IF ((x+b)>xwidth OR (y+h)>ywidth) THEN
drawnew2=TRUE
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
drawnew2=TRUE
cached=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE putcsize
IF bigfoot=FALSE THEN
x=ax&+23-1          ! X-Locator
y=ay&+41-8          ! Y-Locator erste Box
b=xm+3              ! Breite der Box
h=ym*2+24              ! Hîhe der Box
ELSE
'    @calc_editboxes1
x=ax&+24-1          ! X-Locator
y=ay&+41          ! Y-Locator erste Box
b=xm+16              ! Breite der Box
h=ym*2+19              ! Hîhe der Box
ENDIF
IF nr=smpedit& THEN
IF (x+b)>xwidth OR (y+h)>ywidth THEN
drawnew2=TRUE
ELSE
IF drawnew2=TRUE THEN
credraw=TRUE
@curve(cs,ce)
@blkupdate
credraw=FALSE
@getcurve
ENDIF
drawnew2=FALSE
ENDIF
ELSE
drawnew2=FALSE
ENDIF
RETURN
'
> PROCEDURE putcurve
LOCAL x,y,b,h
IF nr=smpedit& THEN
IF windcache=TRUE THEN
@windowtest
@markhlp
@putcsize
IF (x1+b1)>=x AND x1<=x+b AND (y1+h1)>=y AND y1<=y+h THEN
mx=x1
my=y1
mx1=x1-x
my1=y1-y
IF x1<x THEN
mx1=0
mx=x
ENDIF
IF y1<y THEN
my1=0
my=y
ENDIF
mb1=b1
mh1=h1
IF x1<x THEN
mb1=(x1+b1)-x
ENDIF
IF y1<y THEN
mh1=(y1+h1)-y
ENDIF
IF mb1>b THEN
mb1=b
ENDIF
IF mh1>h THEN
mh1=h
ENDIF
IF mx+mb1>x+b THEN
mb1=(x+b)-mx
ENDIF
IF my+mh1>y+h THEN
mh1=(y+h)-my
ENDIF
'
IF mx+mb1>xwidth THEN
mb1=xwidth-mx
ENDIF
IF my+mh1>ywidth THEN
mh1=ywidth-my
ENDIF
IF mx>=x AND my>=y AND mx1>=0 AND my1>=0 AND mb1>0 AND mh1>0 THEN
IF shading=FALSE THEN
~GRAF_MOUSE(256,0)                              ! Hidem
@rsc_putblock(memc,mx,my,mx1,my1,mb1,mh1)
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
ENDIF
ELSE
drawnew2=TRUE
cached=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE curve(cs,ce)
@windowtest
@markhlp
IF bigfoot=FALSE THEN
cxd=ax&+23          ! X-Locator
ym1=ay&+41          ! Y-Locator erste Box
ym2=ay&+129         ! Y-Locator zweite Box
ELSE
cxd=ax&+24+8          ! X-Locator
'    ym1=ay&+41+8          ! Y-Locator erste Box
'    ym2=ay&+253+8         ! Y-Locator zweite Box
@calc_editboxes2
ENDIF
xmc=xm              ! Breite der Box
ymc=ym              ! Hîhe der Box
mtrak=FALSE
trc=0               ! Tracker-Cache-ZÑhler
IF tcach(trc)=TRUE AND trkmax(trc)>0 THEN
max=trkmax(trc)
ELSE
max=32767
trkmax(trc)=max
ENDIF
IF trkmemr=TRUE AND cached=FALSE THEN
@getmem
trkmemr=FALSE
ENDIF
IF shading=FALSE THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
@undercurve(cs,ce,0,xmc,xmc)
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
'
tcach(trc)=TRUE
IF trkmem(1)=0 THEN
trkmem(1)=trkmem(0)+xmc*8
ENDIF
RETURN
'
> PROCEDURE mcurve(cs,ce,xmc,ymc,cxd,ym1,ym2,tcs,tce,glen)
LOCAL vvirtual
@windowtest
@markhlp
'  cs    ! Anfang-Samples
'  ce    ! Ende Samples
'  xmc   ! Breite der Box
'  ymc   ! Hîhe der Box
'  cxd   ! X-Locator
'  ym1   ! Y-Locator erste Box
'  ym2   ! Y-Locator zweite Box
'  tcs   ! Darstellungsanfang
'  tce   ! Darstellungsende
'  glen  ! gesamtzahl der zu berechnenden Pixel
mtrak=TRUE
vvirtual=virtual
virtual=FALSE
IF tcach(trc)=TRUE AND trkmax(trc)>0 THEN
max=trkmax(trc)
ELSE
max=32767
trkmax(trc)=max
ENDIF
IF shading=FALSE THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
@undercurve(cs,ce,tcs,tce,glen)
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
virtual=vvirtual
RETURN
'
> PROCEDURE undercurve(cs,ce,ccs,cce,ccg)
.| Glob. Var.: zoomstop#,grids#,maxcol#,xd#,ym1#,xm#,ym#,ym2#,mbs#,col#,ax#
.|     bx#,yline#,virtcurve#,virtual#,maxcwert#,mlen#,vce#,vcs#,cached#,wa#
.|     vmem#,wb#,stp#,j#,m1#,m2#,m3#,m4#,cwertep1#,cwertep2#,cwertem1#
.|     cwertem2#,max#,max2#,ldlen#,mrkp$,virtpath$,meml#,yd#,sline#,bs#,ci#
.|     am#,y2#,yzoom#,aa#,wyzoom#,rubmax#,aam#
.| Felder    : mblocks#(),mblocke#(),cachep1#(),cachep2#(),cachem1#()
.|     cachem2#()
.| Ruft auf  : markhlp,maschinit31,maschruf31,writeyproz,drawcurve,markhlp3
.| Aufruf in : message-2,restaura4-1,smpload-2,smpedit-1,time_edit-1
.|     record2-1,
LOCAL c$,s,e,l,y,len,adr,i,a,z,m,k,d,xdi,ydi
zoomstop=FALSE
GRAPHMODE 1
'
' COLORS: 0=weiss,1=schwarz,2=rot,3=grÅn,4=blau,5=cyan,6=gelb,7=magenta,8=hellgrau
'         9=dunkelgrau,10=dunkelrot,11=dunkelgrÅn,12=dunkelblau,13=dunkelcyan,14=dunkelgelb,15=dunkelmagenta
'
IF grids=1 AND mtrak=FALSE THEN
IF maxcol<=2 THEN
DEFFILL 0,1,8
ELSE
DEFFILL 9,1,9
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX cxd+1,ym1,cxd+xmc,ym1+ymc
PBOX cxd+1,ym2,cxd+xmc,ym2+ymc
IF mbs>0 THEN
col=1
FOR i=1 TO mbs
INC col
ax=mblocks(i)
bx=mblocke(i)
IF (ce-cs)>0 AND (bx-ax)>0 THEN
IF ax<cs AND bx>cs THEN
ax=cs
ENDIF
IF bx>ce AND ax>=cs AND ax<=ce THEN
bx=ce
ENDIF
IF ax>=cs AND ax<=ce AND bx>=cs AND bx<=ce AND (ce-cs)>0 AND (bx-ax)>0 THEN
ax=ax-cs
ax=ax/(ce-cs)*xmc
bx=bx-cs
bx=bx/(ce-cs)*xmc
IF maxcol<=2 THEN
DEFFILL 1,3,col
IF col=13 THEN
col=1
ENDIF
ELSE
IF col=8 THEN
col=10
ENDIF
IF col=16 THEN
col=2
ENDIF
DEFFILL col,1,8
ENDIF
PBOX cxd+ax+1,ym1,cxd+bx,ym1+ymc
PBOX cxd+ax+1,ym2,cxd+bx,ym2+ymc
ENDIF
ENDIF
NEXT i
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
IF yline=TRUE AND mtrak=FALSE THEN
~GRAF_MOUSE(256,0)                              ! Hidem
DEFLINE 2
GRAPHMODE 3
IF bigfoot=FALSE THEN
LINE cxd+1,ym1+6,cxd+xmc,ym1+6
LINE cxd+1,ym1+6+8,cxd+xmc,ym1+6+8
LINE cxd+1,ym1+6+8*2,cxd+xmc,ym1+6+8*2
LINE cxd+1,ym1+6+8*3,cxd+xmc,ym1+6+8*3
LINE cxd+1,ym1+6+8*5,cxd+xmc,ym1+6+8*5
LINE cxd+1,ym1+6+8*6,cxd+xmc,ym1+6+8*6
LINE cxd+1,ym1+6+8*7,cxd+xmc,ym1+6+8*7
LINE cxd+1,ym1+6+8*8,cxd+xmc,ym1+6+8*8
LINE cxd+1,ym2+6,cxd+xmc,ym2+6
LINE cxd+1,ym2+6+8,cxd+xmc,ym2+6+8
LINE cxd+1,ym2+6+8*2,cxd+xmc,ym2+6+8*2
LINE cxd+1,ym2+6+8*3,cxd+xmc,ym2+6+8*3
LINE cxd+1,ym2+6+8*5,cxd+xmc,ym2+6+8*5
LINE cxd+1,ym2+6+8*6,cxd+xmc,ym2+6+8*6
LINE cxd+1,ym2+6+8*7,cxd+xmc,ym2+6+8*7
LINE cxd+1,ym2+6+8*8,cxd+xmc,ym2+6+8*8
ELSE
q=(ym+3)/10
'
LINE cxd+1,ym1-1+q,cxd+xmc,ym1-1+q
LINE cxd+1,ym1-1+q*2,cxd+xmc,ym1-1+q*2
LINE cxd+1,ym1-1+q*3,cxd+xmc,ym1-1+q*3
LINE cxd+1,ym1-1+q*4,cxd+xmc,ym1-1+q*4
LINE cxd+1,ym1-1+q*6,cxd+xmc,ym1-1+q*6
LINE cxd+1,ym1-1+q*7,cxd+xmc,ym1-1+q*7
LINE cxd+1,ym1-1+q*8,cxd+xmc,ym1-1+q*8
LINE cxd+1,ym1-1+q*9,cxd+xmc,ym1-1+q*9
LINE cxd+1,ym2-1+q,cxd+xmc,ym2-1+q
LINE cxd+1,ym2-1+q*2,cxd+xmc,ym2-1+q*2
LINE cxd+1,ym2-1+q*3,cxd+xmc,ym2-1+q*3
LINE cxd+1,ym2-1+q*4,cxd+xmc,ym2-1+q*4
LINE cxd+1,ym2-1+q*6,cxd+xmc,ym2-1+q*6
LINE cxd+1,ym2-1+q*7,cxd+xmc,ym2-1+q*7
LINE cxd+1,ym2-1+q*8,cxd+xmc,ym2-1+q*8
LINE cxd+1,ym2-1+q*9,cxd+xmc,ym2-1+q*9
ENDIF
GRAPHMODE 1
DEFLINE 1
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
virtcurve=FALSE
IF virtual=TRUE AND maxcwert>0 THEN
IF ce-cs>mlen THEN
IF pbufda=TRUE THEN
IF cached=FALSE THEN
@makepbuf
vce=0
vcs=0
virtcurve=TRUE
cached=TRUE
wa=0
IF ce>0 THEN
wb=maxcwert
ELSE
wb=0
ENDIF
wa=INT(wa)
wb=INT(wb)
stp=(wb-wa)/ccg
j=0
max=0
i=wa+1
'
tma=trkmem(trc)
IF trc=0 AND trkg(trc)<>(ccg+1) AND trkz>0 THEN
glen=ccg+1
@trksprint
ENDIF
trkg(trc)=ccg+1
' Reihenfolge des Caches: p1,m1,p2,m2 jeweils Word-Grîûe
'
REPEAT
INC j
IF j<=ccg THEN
a=LPEEK(cwertep1+INT(i)*4)
IF max<a AND a>0 THEN
max=a
ENDIF
DPOKE tma+(j-1)*8,a
a=LPEEK(cwertep2+INT(i)*4)
IF max<a AND a>0 THEN
max=a
ENDIF
DPOKE tma+(j-1)*8+4,a
a=LPEEK(cwertem1+INT(i)*4)
IF max<a AND a>0 THEN
max=a
ENDIF
DPOKE tma+(j-1)*8+2,a
a=LPEEK(cwertem2+INT(i)*4)
IF max<a AND a>0 THEN
max=a
ENDIF
DPOKE tma+(j-1)*8+6,a
ENDIF
i=i+stp
UNTIL i>=wb
trkmax(trc)=max
ENDIF
ENDIF
ELSE
IF cs<vcs OR ce>vce OR vce=0 THEN
IF cs<vcs THEN
IF mlen>ce-cs AND ce-mlen>=0 THEN
ldlen=mlen
ELSE
ldlen=ce-cs
ENDIF
virtcurve=FALSE
cached=FALSE
vce=ce
vcs=ce-ldlen
IF vcs=0 THEN
ldlen=mlen
vce=mlen
ENDIF
OPEN "I",#1,virtpath$
'          OPEN "I",#1,mrkp$    ! falsch ?
SEEK #1,vcs+head
ELSE
IF mlen>ce-cs AND vmem-cs>=mlen THEN
ldlen=mlen
ELSE
ldlen=ce-cs
ENDIF
IF cs+ldlen>vmem THEN
ldlen=vmem-cs
ENDIF
virtcurve=FALSE
cached=FALSE
vcs=cs
vce=cs+ldlen
OPEN "I",#1,virtpath$
SEEK #1,cs+head
ENDIF
BGET #1,meml,ldlen
CLOSE #1
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
xdi=cxd+1   ! X-Locator fÅr Mittellinien
ydi=ym1+ymc/2   ! Mittellinie erste Box
ydi2=ym2+ymc/2  ! Mittellinie zweite Box
len=ce-cs
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~WIND_UPDATE(3)                                    ! BEG_UPDATE
LINE xdi-1,ydi,xdi+xmc,ydi
LINE xdi-1,ydi2,xdi+xmc,ydi2
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~WIND_UPDATE(2)                                    ! BEG_UPDATE
stp=(INT(len/ccg))
stp=(INT((stp+1)/mbit)*mbit)
COLOR 0
l=xdi
y=ydi
IF virtcurve=FALSE THEN
IF stp=0 THEN
stp=len/ccg
ENDIF
adr=meml
ELSE
adr=0
ENDIF
COLOR 1
IF cached=FALSE THEN
ci=0
max=0
tma=trkmem(trc)
IF trc=0 AND trkg(trc)<>(ccg+1) AND trkz>0 THEN
glen=ccg+1
@trksprint
ENDIF
trkg(trc)=ccg+1
FOR v=adr+cs TO adr+ce-stp STEP stp
i=INT(v/mbit)*mbit
@maschruf31
IF max<a AND a>0 THEN
max=a
ENDIF
IF max<am AND am>0 THEN
max=am
ENDIF
INC ci
IF ci<=ccg THEN
DPOKE tma+(ci-1)*8,a
ENDIF
IF ci<=ccg THEN
DPOKE tma+(ci-1)*8+2,am
ENDIF
NEXT v
ci=0
l=xdi
FOR v=adr+cs TO adr+ce-stp STEP stp
i=INT(v/mbit)*mbit+(mbit/2)
@maschruf31
IF max<a AND a>0 THEN
max=a
ENDIF
IF max<am AND am>0 THEN
max=am
ENDIF
INC ci
IF ci<=ccg THEN
DPOKE tma+(ci-1)*8+4,a
ENDIF
IF ci<=ccg THEN
DPOKE tma+(ci-1)*8+6,am
ENDIF
NEXT v
trkmax(trc)=max
cached=TRUE
ENDIF
@buildcurve
~GRAF_MOUSE(257,0)                              ! Showm
RETURN
'
> PROCEDURE buildcurve
istp=1
cstp=1
IF INT((ce-cs)/mbit)<=xmc THEN
IF vertline=TRUE AND linkdot=FALSE AND spacefill=FALSE THEN
istp=(4/stp)
cstp=xmc/(xmc/istp)
ENDIF
IF vertline=TRUE AND linkdot=TRUE AND spacefill=FALSE THEN
istp2=(4/stp)
cstp2=xmc/(xmc/istp2)
ENDIF
ENDIF
IF mtrak=FALSE THEN
@writeyproz
ENDIF
l=xdi
l2=l
y2=y
tma=trkmem(trc)
FOR i=ccs TO cce STEP istp
ir=INT(i)
IF l<=(xmc+xdi) THEN
a=DPEEK(tma+ir*8)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aa=INT(a/max*ymc/2)
ELSE
aa=INT(a/32767*ymc/2)
ENDIF
IF wyzoom=TRUE THEN
aa=INT(a/rubmax*ymc/2)
IF aa>ymc/2 THEN
aa=ymc/2
ENDIF
ENDIF
ELSE
aa=0
ENDIF
a=ydi-aa
am=DPEEK(tma+ir*8+2)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aam=INT(am/max*ymc/2)
ELSE
aam=INT(am/32767*ymc/2)
ENDIF
IF wyzoom=TRUE THEN
aam=INT(am/rubmax*ymc/2)
'
'
'   fehlerhaftes dragging
'
'
'
IF aam>ymc/2 THEN
aam=ymc/2
ENDIF
ENDIF
ELSE
aam=0
ENDIF
am=aam+ydi
IF INT((ce-cs)/mbit)<=xmc THEN
IF linkdot=TRUE AND spacefill=FALSE THEN
IF l>=xdi+cstp THEN
IF a<>ydi THEN
LINE l-cstp,y2,l,a
y2=a
ELSE
LINE l-cstp,y2,l,am
y2=am
ENDIF
ELSE
IF a<>ydi THEN
'              LINE l,y2,l,a
y2=a
ELSE
'              LINE l,y2,l,am
y2=am
ENDIF
ENDIF
IF vertline=TRUE THEN
REPEAT
IF l2<l THEN
l2=l2+cstp2
ENDIF
UNTIL l2>=l
IF INT(l2)=l THEN
LINE l2,a,l2,am
ENDIF
ENDIF
ELSE
LINE l,a,l,am
ENDIF
ELSE
LINE l,a,l,am
ENDIF
ENDIF
l=l+cstp
NEXT i
l=xdi
l2=l
y=ydi2
y2=y
FOR i=ccs TO cce STEP istp
ir=INT(i)
IF l<=(xmc+xdi) THEN
a=DPEEK(tma+ir*8+4)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aa=INT(a/max*ymc/2)
ELSE
aa=INT(a/32767*ymc/2)
ENDIF
IF wyzoom=TRUE THEN
aa=INT(a/rubmax*ymc/2)
IF aa>ymc/2 THEN
aa=ymc/2
ENDIF
ENDIF
ELSE
aa=0
ENDIF
a=ydi2-aa
am=DPEEK(tma+ir*8+6)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aam=INT(am/max*ymc/2)
ELSE
aam=INT(am/32767*ymc/2)
ENDIF
IF wyzoom=TRUE THEN
aam=INT(am/rubmax*ymc/2)
IF aam>ymc/2 THEN
aam=ymc/2
ENDIF
ENDIF
ELSE
aam=0
ENDIF
am=aam+ydi2
IF INT((ce-cs)/mbit)<=xmc THEN
IF linkdot=TRUE AND spacefill=FALSE THEN
IF l>=xdi+cstp THEN
IF a<>ydi2 THEN
LINE l-cstp,y2,l,a
y2=a
ELSE
LINE l-cstp,y2,l,am
y2=am
ENDIF
ELSE
IF a<>ydi2 THEN
'              LINE l,y2,l,a
y2=a
ELSE
'              LINE l,y2,l,am
y2=am
ENDIF
ENDIF
IF vertline=TRUE THEN
REPEAT
IF l2<l THEN
l2=l2+cstp2
ENDIF
UNTIL l2>=l
IF INT(l2)=l THEN
LINE l2,a,l2,am
ENDIF
ENDIF
ELSE
LINE l,a,l,am
ENDIF
ELSE
LINE l,a,l,am
ENDIF
ENDIF
l=l+cstp
NEXT i
IF mtrak=FALSE AND cupdate=FALSE THEN
@markhlp3(9998,0,cs)
@markhlp3(9999,0,ce)
ENDIF
RETURN
'
> PROCEDURE adjustresmp
.| Glob. Var.: adjrsmp#,adjresmp#
.| Aufruf in : resample-1,
IF adjresmp=FALSE THEN
adjresmp=TRUE
IF aretime=1 THEN
retime=aretime
ENDIF
ELSE
adjresmp=FALSE
aretime=retime
retime=0
ENDIF
@resmptxt
RETURN
'
> PROCEDURE resmptxt
.| Glob. Var.: sblock#,len#,mlen#,resorig#,resoth#,c2#,c1#,a$,resmplen&,hz#
.|     resmpsec&,resmpfac&
.| Ruft auf  : textfeld
.| Aufruf in : resample-6,
@editread(restxt&)
resorig=VAL(a$)
IF LEN(a$)=3 THEN
resorig=resorig/10
ENDIF
IF resorig>0 THEN
IF sblock=0 THEN
IF virtual=FALSE THEN
len=INT(mlen/resorig*resoth/mbit)
ELSE
len=INT(vmem/resorig*resoth/mbit)
ENDIF
ELSE
len=INT((c2-c1)/resorig*resoth/mbit)
ENDIF
ELSE
len=0
ENDIF
a$=STR$(len)+" samples"+CHR$(0)
@textfeld(resmplen&,a$,1)
len=INT(len/hz*1000)/1000
IF adjresmp=FALSE THEN
hsec=INT(len*100)
ELSE
hsec=INT(len/resoth*resorig*100)
ENDIF
@htimeset
a$="TIME "+a$
'  a$=STR$(len)+" sec"+CHR$(0)
@textfeld(resmpsec&,a$,1)
IF resorig>0 THEN
len=((resoth/resorig)*100)
ELSE
len=0
ENDIF
len=INT(len+1.0E-07)/100
a$="Factor "+STR$(len)+CHR$(0)
@textfeld(resmpfac&,a$,1)
RETURN
'
> PROCEDURE resample
.| Glob. Var.: makecurve#,vorvornr#,vornr#,nr#,resample&,resorig#,hz#,db$
.|     restxt&,resoth#,resother&,sblock#,c2#,c1#,sms#,sme#,adjresmp#
.|     adjresmp&,obj#,popup&,zu%,zuadr#,edit_obj&,resl1&,resl2&,resl3&
.|     resr1&,resr2&,resr3&,res32&,res44&,res48&,helprsmp&,resok&,resexit&
.|     noresok#,a$,i#,a#,g#,resmp&
.| Ruft auf  : makehz,rsc_draw,markhlp,editfeld,textfeld,blocklook,resmptxt
.|     setbutton,rsc_do,xrsrc_gaddr,resl,resr,adjustresmp,resoth32,resoth44
.|     resoth48,helptxt,editread,makeresmp,rsc_back,blkrestaura
.| Aufruf in : do_blkf-1,
makecurve=0
vorvornr=vornr
vornr=nr
nr=resample&
@makehz
@rsc_draw(nr,0)
@markhlp
resorig=INT(hz/100)
db$=RIGHT$("000"+STR$(resorig),3)+CHR$(0)
resorig=resorig/10
@editfeld(restxt&,db$)
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
IF adjresmp=TRUE THEN
@setbutton(adjresmp&,1)
ELSE
@setbutton(adjresmp&,0)
ENDIF
@blocklook
IF sblock=0 OR (sblock=1 AND c2>c1 AND sms<>0 AND c2>0) THEN
@resmptxt
IF adjresmp=TRUE THEN
@setbutton(adjresmp&,1)
ELSE
@setbutton(adjresmp&,0)
ENDIF
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>restxt&
edit_obj&=0
IF obj=resl1& OR obj=resl2& OR obj=resl3& OR obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@setbutton(obj,0)
ENDIF
IF obj=resl1& OR obj=resl2& OR obj=resl3& THEN
@resl
@resmptxt
ENDIF
IF obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@resr
@resmptxt
ENDIF
IF obj=adjresmp& THEN
@adjustresmp
ENDIF
IF obj=res32& THEN
@resoth32
@resmptxt
ENDIF
IF obj=res44& THEN
@resoth44
@resmptxt
ENDIF
IF obj=res48& THEN
@resoth48
@resmptxt
ENDIF
IF obj=helprsmp& THEN
@helptxt("RESAMPLING")
ENDIF
UNTIL obj=resok& OR obj=resexit&
IF obj=resok& THEN
@resmptxt
noresok=FALSE
ENDIF
IF (resorig<=0 AND obj=resok&) THEN
@alerts(39)
@setbutton(resok&,0)
ELSE
@setbutton(obj,0)
ENDIF
UNTIL (obj=resok& AND noresok=FALSE AND resorig>0) OR obj=resexit&
@rsc_back(nr)
IF obj=resok& AND noresok=FALSE THEN
nr=smpedit&
@editselect
@makeresmp
ENDIF
ELSE
@rsc_back(nr)
@alerts(25)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
nr=resample&
edit_obj&=0
nr=blkfunc&
@blkrestaura
IF nr=blkfunc& THEN
@setbutton(resmp&,0)
ENDIF
vornr=vorvornr
obj=0
RETURN
'
> PROCEDURE arrnrset
.| Glob. Var.: mrkch#,ch#,mrknote#,note#,arrnr1&,pbz#,arrnr2&,arrnr3&
.|     arrnr4&,arrherr#,arrm1&,arrm2&,arrm3&,arrm4&,realtime#,vhz#,flen#
.|     arrloop1&,arrch1&,arrnote1&,arrtri1&,arrsmpr1&,arrloop2&,arrch2&
.|     arrnote2&,arrtri2&,arrsmpr2&,arrloop3&,arrch3&,arrnote3&,arrtri3&
.|     arrsmpr3&,arrloop4&,arrch4&,arrnote4&,arrtri4&,arrsmpr4&,hsec#,a1$,a$
.|     a3$,a2$,sectpos#,pat$,midiwort#,ch$,m$,tri#,l#,a4#,a4$,hardst1&
.|     harde1&,spur1&,hardlen1&,db$,nr#,arrmem1&,hardst2&,harde2&,spur2&
.|     hardlen2&,arrmem2&,hardst3&,harde3&,spur3&,hardlen3&,arrmem3&
.|     hardst4&,harde4&,spur4&,hardlen4&,arrmem4&
.| Felder    : arrsrate#(),arrpath$(),arrend#(),arrstrt#(),arrtri#()
.|     arrlen#(),arrfn$(),arrmidi#(),arrloop#()
.| Ruft auf  : textfeld,setbutton,htimeset,midinote,rsc_tristate2
.| Aufruf in : button-2,arranger-1,do_arrange-2,arrsmpr-1,realtime-2
.|     dragging2-1,arrtristate-1,arrdel-1,arrinsert-1,arrdelete-1
.|     arrdelay-1,hardstrt-1,hardend-1,hardfs-1,arrload-1,
'
' akkuberechnung muû geÑndert werden wegen unterschiedlichen Sampleraten !!!
'
LOCAL p$,i,akku,z,ap$
mrkch=ch
mrknote=note
@textfeld(arrnr1&,RIGHT$("  "+STR$(pbz+1),3)+CHR$(0),1)
@textfeld(arrnr2&,RIGHT$("  "+STR$(pbz+2),3)+CHR$(0),1)
@textfeld(arrnr3&,RIGHT$("  "+STR$(pbz+3),3)+CHR$(0),1)
@textfeld(arrnr4&,RIGHT$("  "+STR$(pbz+4),3)+CHR$(0),1)
IF arrherr=pbz+1 THEN
@setbutton(arrm1&,1)
ELSE
@setbutton(arrm1&,0)
ENDIF
IF arrherr=pbz+2 THEN
@setbutton(arrm2&,1)
ELSE
@setbutton(arrm2&,0)
ENDIF
IF arrherr=pbz+3 THEN
@setbutton(arrm3&,1)
ELSE
@setbutton(arrm3&,0)
ENDIF
IF arrherr=pbz+4 THEN
@setbutton(arrm4&,1)
ELSE
@setbutton(arrm4&,0)
ENDIF
akku=0
FOR z=1 TO 4
ap$=arrpath$(pbz+z)
IF ap$="MEMORY" THEN
sectpos=arrstrt(pbz+z)
vhz=arrsrate(pbz+z)
IF vhz=0 THEN
vhz=44100
ENDIF
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a1$=a$
sectpos=arrend(pbz+z)
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a2$=a$
IF realtime=FALSE THEN
sectpos=arrlen(pbz+z)
ELSE
sectpos=arrend(pbz+z)-arrstrt(pbz+z)
IF sectpos<0 THEN
sectpos=0
ENDIF
ENDIF
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a3$=a$
IF arrend(pbz+z)-arrstrt(pbz+z)>=0 THEN
IF arrtri(pbz+z)=2 THEN
akku=akku+(arrend(pbz+z)-arrstrt(pbz+z))*2
ELSE
akku=akku+(arrend(pbz+z)-arrstrt(pbz+z))
ENDIF
ENDIF
ELSE
sectpos=arrstrt(pbz+z)
vhz=arrsrate(pbz+z)
IF vhz=0 THEN
vhz=44100
ENDIF
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a1$=a$
sectpos=arrend(pbz+z)
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a2$=a$
IF realtime=FALSE THEN
sectpos=arrlen(pbz+z)
ELSE
sectpos=arrend(pbz+z)-arrstrt(pbz+z)
IF sectpos<0 THEN
sectpos=0
ENDIF
ENDIF
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a3$=a$
IF arrend(pbz+z)-arrstrt(pbz+z)>=0 THEN
IF arrtri(pbz+z)=2 THEN
akku=akku+(arrend(pbz+z)-arrstrt(pbz+z))*2
ELSE
akku=akku+(arrend(pbz+z)-arrstrt(pbz+z))
ENDIF
ENDIF
ENDIF
pat$=LEFT$(arrfn$(pbz+z)+SPACE$(12),12)
midiwort=arrmidi(pbz+z)
note=(midiwort AND 255)
ch=INT(midiwort/256)+1
ch$=RIGHT$(" "+STR$(ch),2)+CHR$(0)
@midinote
p$=arrpath$(pbz+z)
IF pat$="            " THEN
m$=" "+CHR$(0)
ENDIF
IF p$="MEMORY" THEN
m$="M"+CHR$(0)
ENDIF
IF p$<>"MEMORY" AND pat$<>"            " THEN
m$="H"+CHR$(0)
ENDIF
tri=arrtri(pbz+z)
l=arrloop(pbz+z)
a4=INT(arrsrate(pbz+z)/100)/10
IF a4>0 THEN
a4$=LEFT$(STR$(a4)+SPACE$(4),4)+CHR$(0)
ELSE
a4$=SPACE$(4)+CHR$(0)
ENDIF
IF z=1 THEN
@textfeld(hardst1&,a1$,1)
@textfeld(harde1&,a2$,1)
@textfeld(spur1&,pat$,1)
@textfeld(hardlen1&,a3$,1)
@textfeld(arrch1&,ch$,1)
@textfeld(arrnote1&,db$,1)
@setbutton(arrch1&,0)
@setbutton(arrnote1&,0)
@setbutton(arrloop1&,l)
@setbutton(arrtri1&,0)
@setbutton(arrsmpr1&,0)
@textfeld(arrsmpr1&,a4$,1)
@rsc_tristate2(nr,arrtri1&)
@textfeld(arrmem1&,m$,1)
ENDIF
IF z=2 THEN
@textfeld(hardst2&,a1$,1)
@textfeld(harde2&,a2$,1)
@textfeld(spur2&,pat$,1)
@textfeld(hardlen2&,a3$,1)
@textfeld(arrch2&,ch$,1)
@textfeld(arrnote2&,db$,1)
@setbutton(arrch2&,0)
@setbutton(arrnote2&,0)
@setbutton(arrloop2&,l)
@setbutton(arrtri2&,0)
@setbutton(arrsmpr2&,0)
@textfeld(arrsmpr2&,a4$,1)
@rsc_tristate2(nr,arrtri2&)
@textfeld(arrmem2&,m$,1)
ENDIF
IF z=3 THEN
@textfeld(hardst3&,a1$,1)
@textfeld(harde3&,a2$,1)
@textfeld(spur3&,pat$,1)
@textfeld(hardlen3&,a3$,1)
@textfeld(arrch3&,ch$,1)
@textfeld(arrnote3&,db$,1)
@setbutton(arrch3&,0)
@setbutton(arrnote3&,0)
@setbutton(arrloop3&,l)
@setbutton(arrtri3&,0)
@setbutton(arrsmpr3&,0)
@textfeld(arrsmpr3&,a4$,1)
@rsc_tristate2(nr,arrtri3&)
@textfeld(arrmem3&,m$,1)
ENDIF
IF z=4 THEN
@textfeld(hardst4&,a1$,1)
@textfeld(harde4&,a2$,1)
@textfeld(spur4&,pat$,1)
@textfeld(hardlen4&,a3$,1)
@textfeld(arrch4&,ch$,1)
@textfeld(arrnote4&,db$,1)
@setbutton(arrch4&,0)
@setbutton(arrnote4&,0)
@setbutton(arrloop4&,l)
@setbutton(arrtri4&,0)
@setbutton(arrsmpr4&,0)
@textfeld(arrsmpr4&,a4$,1)
@rsc_tristate2(nr,arrtri4&)
@textfeld(arrmem4&,m$,1)
ENDIF
NEXT z
ch=mrkch
note=mrknote
RETURN
'
> PROCEDURE scrollinit
LOCAL a,steps,len
scstep=1
steps=4
scslc=1   ! Schrittweite
IF ((INT(vmem/mbit)*mbit)-INT((ce-cs)/mbit)*mbit)>0 THEN
scmax=(vmem-(ce-cs))/((ce-cs)/steps)
IF scmax>INT(scmax) THEN
scmax=scmax+1
scmax=INT(scmax)
IF scmax=1 THEN
scmax=2
ENDIF
scteil=(vmem-(ce-cs))/(scmax-1)
ENDIF
@slidelen2(scrlslde&,scrolbut&,tolen)
scstep=(tolen/scmax)
IF scstep<10 THEN
scstep=10
ENDIF
scmax=tolen+1
scteil=(vmem-(ce-cs))/(scmax-1-scstep)
ELSE
scmax=1
scteil=0
@slidelen2(scrlslde&,scrolbut&,scstep)
ENDIF
IF scmax=2 AND cs>0 AND (INT(ce/mbit)*mbit)<(INT(vmem/mbit)*mbit) THEN
scmax=3
scteil=(vmem-(ce-cs))/(scmax-1-scstep)
ENDIF
@slideinit2(scrlslde&,scrolbut&,scstep)
IF scteil>0 THEN
scrollp=INT(cs/scteil)
IF scrollp=0 AND cs>0 THEN
scrollp=1
ENDIF
ELSE
scrollp=0
ENDIF
RETURN
'
> PROCEDURE slideinit2(slidename&,slbutname&,step)    ! variable Buttonbreite
LOCAL b,h,scst
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
DPOKE (zu%+24*slbutname&+20),step   ! Breite des Schiebers anpassen
ELSE
DPOKE (zu%+24*slbutname&+22),step   ! Hîhe des Schiebers anpassen
ENDIF
pos=0                                       ! Position des Schiebers
RETURN
'
> PROCEDURE setslide2(slidename&,slbutname&,max,pos,step)
LOCAL b,h,poswert
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF max>1 THEN
poswert=1000/(max-1)*pos
ELSE
poswert=0
ENDIF
IF b>h OR b=tbkurz THEN
sx=(poswert*b/1000)
IF sx+step>max THEN
sx=max-step
ENDIF
IF sx<0 THEN
sx=0
ENDIF
DPOKE zu%+24*slbutname&+16,sx              ! X-Position einstellen
ELSE
sy=(poswert*h/1000)
IF sy+step>max THEN
sy=max-step
ENDIF
DPOKE zu%+24*slbutname&+18,sy              ! Y-Position einstellen
IF sy<0 THEN
sy=0
ENDIF
ENDIF
@windowtest
IF shading=FALSE AND notopen=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,slidename&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE slideupdate2(slidename&,slbutname&,saxy,max,mx,my,slc,VAR pos,flg)
LOCAL b,h,pbb,pbla,pbl,a
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
a=FALSE
IF b>h OR b=tbkurz THEN
pbb=DPEEK(zu%+24*slidename&+16)+saxy       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF mx>(pbb+pbla+pbl/2) THEN
@slidedwn2(slidename&,slbutname&,max,slc,slc,pos,a)
ENDIF
IF mx<(pbb+pbla-pbl/2) THEN
@slideup2(slidename&,slbutname&,max,slc,pos,a)
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+saxy    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF my>(pbb+pbla+pbl/2) THEN
@slidedwn2(slidename&,slbutname&,max,slc,slc,pos,a)
ENDIF
IF my<(pbb+pbla-pbl/2) THEN
@slideup2(slidename&,slbutname&,max,slc,pos,a)
ENDIF
ENDIF
flg=a
RETURN
'
> PROCEDURE slideup2(slidename&,slbutname&,max,slc,VAR pos,flg)
LOCAL p,a,sl
p=pos
sl=slc
IF p-sl<0 AND sl>1 THEN
sl=p
ENDIF
IF p-sl>=0 THEN
p=p-sl
@setslide2(slidename&,slbutname&,max,p,slc)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slidedwn2(slidename&,slbutname&,max,step,slc,VAR pos,flg)
LOCAL p,a,sl,st2
p=pos
sl=slc
IF p>=max-sl AND sl>1 THEN
sl=max-p-1
ENDIF
IF p<(max-step) THEN
p=p+sl
@setslide2(slidename&,slbutname&,max,p,slc)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE sliding2(slidename&,slbutname&,max,step,VAR pos,flg)
LOCAL b,h,slwert,p,a
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,0)
ELSE
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,1)
ENDIF
p=INT((max-step-1)/1000*slwert)
IF p<>pos THEN
@setslide2(slidename&,slbutname&,max,p,step)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE sliding3(slidename&,slbutname&,max,step,VAR pos,flg)
LOCAL b,h,slwert,p,a
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,0)
ELSE
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,1)
ENDIF
p=(max-step)/1000*slwert
IF p<>pos THEN
@setslide2(slidename&,slbutname&,max,p,step)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slidelen2(slidename&,slbutname&,VAR len)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : virtual-1,scrollinit-1,
LOCAL b,h
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
len=b
ELSE
len=h
ENDIF
RETURN
'
> PROCEDURE slideinit(slidename&,slbutname&,max,bg,VAR pos)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : newfsel-1,arranger-1,trakker-2,virtual-1,scrollinit-1
.|     setup2-1,
LOCAL b,h,pbl
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
pbl=INT(b/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+20),pbl         ! Breite des Schiebers anpassen
ELSE
pbl=INT(h/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+22),pbl         ! Hîhe des Schiebers anpassen
ENDIF
pos=0                                       ! Position des Schiebers
RETURN
'
> PROCEDURE setbuttgr(slidename&,slbutname&,max,bg)
LOCAL b,h,pbl
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
pbl=INT(b/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+20),pbl         ! Breite des Schiebers anpassen
ELSE
pbl=INT(h/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+22),pbl         ! Hîhe des Schiebers anpassen
ENDIF
RETURN
'
> PROCEDURE slidelen(slidename&,slbutname&,VAR len,leno)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : virtual-1,scrollinit-1,
LOCAL b,h
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
leno=b
len=b-DPEEK(zu%+24*slbutname&+20)   ! Breite des Schiebers in Pixeln
ELSE
leno=h
len=h-DPEEK(zu%+24*slbutname&+22)   ! Hîhe des Schiebers in Pixeln
ENDIF
RETURN
'
> PROCEDURE setslide(slidename&,slbutname&,max,bg,pos)
.| Glob. Var.: nr#,zu%,xwidth#,ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : button-4,rubbermax-1,newfsel-7,slideup-1,slidedwn-1
.|     sliding-1,arranger-1,trakker-2,virtual-1,getmem-2,zslidecalc-1
.|     smpedit-2,do_smpedit-6,time_edit-1,
LOCAL b,h,pbl,poswert
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF max>1 THEN
poswert=1000/(max-1)*pos
ELSE
poswert=0
ENDIF
IF b>h OR b=tbkurz THEN
pbl=INT(b/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
SUB b,pbl
DPOKE zu%+24*slbutname&+16,poswert*b/1000              ! X-Position einstellen
ELSE
pbl=INT(h/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
SUB h,pbl
DPOKE zu%+24*slbutname&+18,poswert*h/1000              ! Y-Position einstellen
ENDIF
@windowtest
IF shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,slidename&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE slideup(slidename&,slbutname&,max,slc,bg,VAR pos,flg)
.| Ruft auf  : setslide
.| Aufruf in : newfsel-1,slideupdate-2,do_arrange-1,do_trakker-2,virtual-1
.|     do_smpedit-2,
LOCAL p,a,sl
p=pos
sl=slc
IF p-sl<0 AND sl>1 THEN
sl=p
ENDIF
IF p-sl>=0 THEN
p=p-sl
@setslide(slidename&,slbutname&,max,bg,p)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slidedwn(slidename&,slbutname&,max,slc,bg,VAR pos,flg)
.| Ruft auf  : setslide
.| Aufruf in : newfsel-1,slideupdate-2,do_arrange-1,do_trakker-2,virtual-1
.|     do_smpedit-2,
LOCAL p,a,sl
p=pos
sl=slc
IF p>=max-sl AND sl>1 THEN
sl=max-p-1
ENDIF
IF p<(max-sl) THEN
p=p+sl
@setslide(slidename&,slbutname&,max,bg,p)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slideupdate(slidename&,slbutname&,saxy,max,mx,my,slc,bg,VAR pos,flg)
.| Glob. Var.: nr#,zu%,ax&,ay&
.| Ruft auf  : markhlp,xrsrc_gaddr,slidedwn,slideup
.| Aufruf in : button-7,
LOCAL b,h,pbb,pbla,pbl,a
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
a=FALSE
IF b>h OR b=tbkurz THEN
pbb=DPEEK(zu%+24*slidename&+16)+saxy       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF mx>(pbb+pbla+pbl/2) THEN
@slidedwn(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
IF mx<(pbb+pbla-pbl/2) THEN
@slideup(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+saxy    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF my>(pbb+pbla+pbl/2) THEN
@slidedwn(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
IF my<(pbb+pbla-pbl/2) THEN
@slideup(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
ENDIF
flg=a
RETURN
'
> PROCEDURE slidelr(slidename&,slbutname&,max,mx,my,pos,VAR slidr)
.| Glob. Var.: nr#,zu%,ax&,ay&
.| Ruft auf  : markhlp,xrsrc_gaddr
.| Aufruf in : button-1,
LOCAL b,h,pbb,pbla,pbl
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
pbb=DPEEK(zu%+24*slidename&+16)+ax&+24       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF pos<(max-1) AND mx>(pbb+pbla+pbl/2) THEN
slidr=TRUE
ENDIF
IF pos>0 AND mx<(pbb+pbla-pbl/2) THEN
slidr=FALSE
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+ay&-33    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF pos<(max-1) AND my>(pbb+pbla+pbl/2) THEN
slidr=TRUE
ENDIF
IF pos>0 AND my<(pbb+pbla-pbl/2) THEN
slidr=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE sliding(slidename&,slbutname&,max,bg,VAR pos,flg)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr,setslide
.| Aufruf in : button-7,
LOCAL b,h,slwert,p,a
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,0)
ELSE
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,1)
ENDIF
p=INT((max-1)/1000*slwert)
IF p<>pos THEN
@setslide(slidename&,slbutname&,max,bg,p)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE buttbh(name&,VAR lenx,leny)
~@xrsrc_gaddr(0,nr,zu%)
lenx=DPEEK(zu%+24*name&+20)         ! Breite des Buttons in Pixeln
leny=DPEEK(zu%+24*name&+22)         ! Hîhe des Buttons in Pixeln
RETURN
'
> PROCEDURE setbuttbh(name&,lx,ly)
~@xrsrc_gaddr(0,nr,zu%)
DPOKE (zu%+24*name&+20),lx         ! Breite des Buttons in Pixeln
DPOKE (zu%+24*name&+22),ly         ! Hîhe des Buttons in Pixeln
RETURN
'
> PROCEDURE arranger
.| Glob. Var.: obj#,winh#,arranger&,rsc_window&,vornr#,nr#,vormidiwort#
.|     midiwort#,vorch#,ch#,vornote#,note#,hz#,arrz#,merkclip#,spring#,drag#
.|     arrherr#,hardopen#,playstop#,slmax#,lmax2#,arrslide&,arrslbut&,pbz#
.|     menuda#,realtime#,arreal&,a$,playlen&,tri#,l#,arrloop1&,arrtri1&
.|     arrloop2&,arrtri2&,arrloop3&,arrtri3&,arrloop4&,arrtri4&,playname&
.|     arrange&,g#,smpedit&,edit_obj&,idx&
.| Felder    : arrtri#(),arrloop#()
.| Ruft auf  : makehz,slideinit,rsc_draw,rsc_menu_ienable,setbutton,textfeld
.|     rsc_tristate2,setslide,arrnrset,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
LOCAL vy
obj=0
IF BTST(winh,arranger&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=arranger&
winh=BSET(winh,nr)
vormidiwort=midiwort
vorch=ch
vornote=note
merkhz=hz
@makehz
arrz=0
spring=FALSE
arrherr=0
hardopen=FALSE
playstop=0
slmax=lmax2
@slideinit(arrslide&,arrslbut&,slmax,5,pbz)
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
tri=arrtri(1)
l=arrloop(1)
@setbutton(arrloop1&,l)
@rsc_tristate2(nr,arrtri1&)
tri=arrtri(2)
l=arrloop(2)
@setbutton(arrloop2&,l)
@rsc_tristate2(nr,arrtri2&)
tri=arrtri(3)
l=arrloop(3)
@setbutton(arrloop3&,l)
@rsc_tristate2(nr,arrtri3&)
tri=arrtri(4)
l=arrloop(4)
@setbutton(arrloop4&,l)
@rsc_tristate2(nr,arrtri4&)
@setslide(arrslide&,arrslbut&,slmax,5,pbz)
@arrnrset
@textfeld(playname&,"            "+CHR$(0),1)
IF realtime=TRUE THEN
@setbutton(arreal&,1)
ELSE
@setbutton(arreal&,0)
ENDIF
ELSE
@setbutton(arrange&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=arranger&
IF vornr=smpedit& THEN
@setbutton2(arrange&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
IF adrag=TRUE AND arrcwert>0 AND arrcwert<=lmax2 THEN
IF arrpath$(arrcwert)="" THEN
adrag=FALSE
@setbutton(arrclip&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE arrsethz
.| Glob. Var.: vhz#,pbz#,arrz#
.| Felder    : arrsrate#()
.| Ruft auf  : swtosrate,analog,digout
.| Aufruf in : mforw-1,mbackw-1,
vhz=arrsrate(pbz+arrz)
IF vhz=0 THEN
vhz=44100
ENDIF
@swtosrate(vhz)
@analog
@digout(TRUE)
RETURN
'
> PROCEDURE do_arrange
.| Glob. Var.: obj#,smpplay2&,over#,arrclip&,pause&,stop&,forward&,rewind&
.|     smprplay&,smpauto3&,hrdmrk#,hrd#,smpstrt3&,recplay&,hardmerg&
.|     arrload&,arrsave&,hardfs1&,hardfs2&,hardfs3&,hardfs4&,arrch1&,arrch2&
.|     arrch3&,arrch4&,arrnote1&,arrnote2&,arrnote3&,arrnote4&,arrsmpr1&
.|     arrsmpr2&,arrsmpr3&,arrsmpr4&,hardstrt&,hardend&,arrplay&,slideup&
.|     arrslide&,arrslbut&,slmax#,pbz#,slflg#,slidedwn&,arrmidi&,arrtri1&
.|     arrtri2&,arrtri3&,arrtri4&,arrdel1&,arrdel2&,arrdel3&,arrdel4&
.|     arrloop1&,arrloop2&,arrloop3&,arrloop4&,arrm1&,arrm2&,arrm3&,arrm4&
.|     arrstrt&,arrend&,arrhelp&,arreal&,arrins&,arrdel&,arrdelay&,arrexit&
.|     winh#,arranger&,vornr#,smpedit&,arrange&,hz#,merkhz#,midiwort#
.|     vormidiwort#,ch#,vorch#,note#,vornote#
.| Ruft auf  : mforw,setbutton,dragging2,mpause,mstop,mbackw,smpauto
.|     smpstart,recplay,make,arrload,arrsave,hardfs,arrmidi,arrsmpr,hardstrt
.|     hardend,arrplay,slideup,arrnrset,slidedwn,arrmidplay,arrtristate
.|     arrdel,arrloop,arrtowork,arrstrt,arrend,helptxt,realtime,arrinsert
.|     arrdelete,arrdelay,restaura2b,swtosrate
.| Aufruf in : windows-1,
IF obj=smpplay2& THEN
over=0
@mforw
@setbutton(smpplay2&,0)
ENDIF
IF obj=arrtrash& THEN
@arrkill
ENDIF
IF obj=arrclip& THEN
@arrdragclip
ENDIF
IF obj=arreal& THEN
@realarr
ENDIF
IF obj=pause& THEN
@mpause
ENDIF
IF obj=stop& THEN
@mstop
ENDIF
IF obj=arrplay1& OR obj=arrplay2& OR obj=arrplay3& OR obj=arrplay4& THEN
@arrplay
ENDIF
IF obj=arrblk& THEN
@arrblkset
ENDIF
IF obj=forward& THEN
IF XBIOS(xbs,1)=&H71273800 AND oldplay=FALSE THEN
over=mbit*2
ELSE
over=mbit*3
ENDIF
@mforw
@setbutton(forward&,0)
ENDIF
IF obj=rewind& THEN
IF XBIOS(xbs,1)=&H71273800 AND oldplay=FALSE THEN
over=-mbit*4
ELSE
over=-mbit*5
ENDIF
@mbackw
@setbutton(rewind&,0)
ENDIF
IF obj=smprplay& THEN
over=-mbit*2
@mbackw
@setbutton(smprplay&,0)
ENDIF
IF obj=smpauto3& THEN
hrdmrk=hrd
hrd=1
@smpauto
hrd=hrdmrk
ENDIF
IF obj=smpstrt3& THEN
hrdmrk=hrd
hrd=1
@smpstart
hrd=hrdmrk
ENDIF
IF obj=recplay& THEN
@recplay
ENDIF
IF obj=arrload& THEN
@arrload
ENDIF
IF obj=arrsave& THEN
@arrsave
ENDIF
IF obj=hardfs1& OR obj=hardfs2& OR obj=hardfs3& OR obj=hardfs4& THEN
@hardfs
ENDIF
IF obj=arrch1& OR obj=arrch2& OR obj=arrch3& OR obj=arrch4& OR obj=arrnote1& OR obj=arrnote2& OR obj=arrnote3& OR obj=arrnote4& THEN
amidibut=obj
@arrmidi
@setbutton(amidibut,0)
ENDIF
IF obj=arrsmpr1& OR obj=arrsmpr2& OR obj=arrsmpr3& OR obj=arrsmpr4& THEN
@arrsmpr
ENDIF
IF obj=hardstrt& THEN
@hardstrt
ENDIF
IF obj=hardend& THEN
@hardend
ENDIF
IF obj=slideup& THEN
@slideup(arrslide&,arrslbut&,slmax-3,1,5,pbz,slflg)
IF slflg=TRUE THEN
@arrnrset
ENDIF
@setbutton(slideup&,0)
ENDIF
IF obj=slidedwn& THEN
@slidedwn(arrslide&,arrslbut&,slmax-3,1,5,pbz,slflg)
IF slflg=TRUE THEN
@arrnrset
ENDIF
@setbutton(slidedwn&,0)
ENDIF
IF obj=arrmidi& THEN
@arrmidplay
ENDIF
IF obj=arrtri1& OR obj=arrtri2& OR obj=arrtri3& OR obj=arrtri4& THEN
@arrtristate
ENDIF
IF obj=arrdel1& OR obj=arrdel2& OR obj=arrdel3& OR obj=arrdel4& THEN
@arrdel
ENDIF
IF obj=arrloop1& OR obj=arrloop2& OR obj=arrloop3& OR obj=arrloop4& THEN
@arrloop
ENDIF
IF obj=arrm1& OR obj=arrm2& OR obj=arrm3& OR obj=arrm4& THEN
@arrtowork
ENDIF
IF obj=arrstrt& THEN
@arrstrt
ENDIF
IF obj=arrend& THEN
@arrend
ENDIF
IF obj=arrhelp& THEN
@helptxt("ARRANGER")
ENDIF
IF obj=arrins& THEN
@arrinsdrt
ENDIF
IF obj=arrdel& THEN
@arrdelete
ENDIF
IF obj=arrexit& OR obj=9999 THEN
@setbutton(arrexit&,0)
winh=BCLR(winh,arranger&)
vornr=smpedit&
@restaura2b
obj=0
@setbutton(arrange&,0)
GRAPHMODE 3
IF hz<>merkhz THEN
hz=merkhz
@swtosrate(hz)
ENDIF
midiwort=vormidiwort
ch=vorch
note=vornote
obj=0
ENDIF
obj=0
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE arrkill
LOCAL g,i
@alerts(26)
IF g=1 THEN
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
sectors=0
sectpos=0
sectall=0
ENDIF
FOR i=1 TO lmax2
arrfn$(i)=""
arrpath$(i)=""
arrstrt(i)=0
arrend(i)=0
arrlen(i)=0
arrloop(i)=0
arrtri(i)=0
arrsrate(i)=0
NEXT i
pbz=0
arrz=0
arrherr=0
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
@arrnrset
adrag=FALSE
@setbutton(arrclip&,0)
@setbutton(arrm1&,0)
@setbutton(arrm2&,0)
@setbutton(arrm3&,0)
@setbutton(arrm4&,0)
ENDIF
@setbutton(arrtrash&,0)
RETURN
'
> PROCEDURE arrplay
LOCAL z,aobj
IF obj=arrplay1& THEN
z=1
ENDIF
IF obj=arrplay2& THEN
z=2
ENDIF
IF obj=arrplay3& THEN
z=3
ENDIF
IF obj=arrplay4& THEN
z=4
ENDIF
aobj=obj
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF arrpath$(pbz+z)<>"MEMORY" AND arrpath$(pbz+z)<>"" THEN
pat$=arrpath$(pbz+z)
IF EXIST(pat$)=TRUE THEN
vhz=arrsrate(pbz+z)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pa$=pat$+CHR$(0)
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
sectors=arrend(pbz+z)-arrstrt(pbz+z)
sectall=sectors
sectpos=arrstrt(pbz+z)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=LEFT$(pat$+SPACE$(12),12)+CHR$(0)
hardopen=TRUE
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
a$=LEFT$(arrfn$(pbz+z)+SPACE$(12),12)
@textfeld(playname&,a$,1)
ENDIF
ENDIF
over=0
mstop=0
IF arrpath$(pbz+z)<>"" AND pa$<>"" THEN
@arrsethz
IF playstop=2 AND hardopen=TRUE THEN
hardopen=TRUE
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
IF sectall>sectpos THEN
l=0
playpos=sectpos
IF over<>0 THEN
oldplay=TRUE
ENDIF
adder=over
@maschrufb5
IF over<>0 THEN
oldplay=FALSE
ENDIF
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
playpos=sectpos
l=0
playpos=sectpos
IF over<>0 THEN
oldplay=TRUE
ENDIF
adder=over
@maschrufb5
IF over<>0 THEN
oldplay=FALSE
ENDIF
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
IF vhz>0 THEN
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
ENDIF
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
@setbutton(aobj,0)
z=arrherr-pbz
IF z>0 THEN
SELECT z
CASE 1
obj=arrm1&
CASE 2
obj=arrm2&
CASE 3
obj=arrm3&
CASE 4
obj=arrm4&
ENDSELECT
@arrtowork
ENDIF
obj=0
@digout(FALSE)
RETURN
'
> PROCEDURE spurbutt
LOCAL i,a
a$=STR$(trkvz+1)+CHR$(0)
@textfeld(trakk1&,a$,1)
a$=STR$(trkvz+2)+CHR$(0)
@textfeld(trakk2&,a$,1)
a$=STR$(trkvz+3)+CHR$(0)
@textfeld(trakk3&,a$,1)
a$=STR$(trkvz+4)+CHR$(0)
@textfeld(trakk4&,a$,1)
@setbutton(trakk1&,0)
@setbutton(trakk2&,0)
@setbutton(trakk3&,0)
@setbutton(trakk4&,0)
IF trakact=trkvz+1 THEN
@setbutton(trakk1&,1)
ENDIF
IF trakact=trkvz+2 THEN
@setbutton(trakk2&,1)
ENDIF
IF trakact=trkvz+3 THEN
@setbutton(trakk3&,1)
ENDIF
IF trakact=trkvz+4 THEN
@setbutton(trakk4&,1)
ENDIF
IF tvideo=FALSE THEN
@setbutton(curve&,0)
ELSE
@setbutton(curve&,1)
ENDIF
@setbutton(trk4&,0)
@setbutton(trk8&,0)
@setbutton(trk12&,0)
@setbutton(trk16&,0)
IF spuren=2 THEN
@setbutton(trk4&,1)
ENDIF
IF spuren=4 THEN
@setbutton(trk8&,1)
ENDIF
IF spuren=6 THEN
@setbutton(trk12&,1)
ENDIF
IF spuren=8 THEN
@setbutton(trk16&,1)
ENDIF
@spuren(spuren*2)
a$=STR$(trklev(1+trkvz))+CHR$(0)
@textfeld(trklevt1&,a$,1)
a$=STR$(trklev(2+trkvz))+CHR$(0)
@textfeld(trklevt2&,a$,1)
a$=STR$(trklev(3+trkvz))+CHR$(0)
@textfeld(trklevt3&,a$,1)
a$=STR$(trklev(4+trkvz))+CHR$(0)
@textfeld(trklevt4&,a$,1)
a=trkpan(1+trkvz)
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(a))+CHR$(0)
@textfeld(pantxt1&,a$,1)
a=trkpan(2+trkvz)
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(a))+CHR$(0)
@textfeld(pantxt2&,a$,1)
a=trkpan(3+trkvz)
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(a))+CHR$(0)
@textfeld(pantxt3&,a$,1)
a=trkpan(4+trkvz)
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(a))+CHR$(0)
@textfeld(pantxt4&,a$,1)
a$=trktxt$(1+trkvz)+CHR$(0)
@textfeld(trktxt1&,a$,1)
a$=trktxt$(2+trkvz)+CHR$(0)
@textfeld(trktxt2&,a$,1)
a$=trktxt$(3+trkvz)+CHR$(0)
@textfeld(trktxt3&,a$,1)
a$=trktxt$(4+trkvz)+CHR$(0)
@textfeld(trktxt4&,a$,1)
IF trkmute(1+trkvz)=TRUE THEN
@setbutton(trkmute1&,1)
ELSE
@setbutton(trkmute1&,0)
ENDIF
IF trkmute(2+trkvz)=TRUE THEN
@setbutton(trkmute2&,1)
ELSE
@setbutton(trkmute2&,0)
ENDIF
IF trkmute(3+trkvz)=TRUE THEN
@setbutton(trkmute3&,1)
ELSE
@setbutton(trkmute3&,0)
ENDIF
IF trkmute(4+trkvz)=TRUE THEN
@setbutton(trkmute4&,1)
ELSE
@setbutton(trkmute4&,0)
ENDIF
IF trkstereo(1+trkvz)=TRUE THEN
@setbutton(trksolo1&,1)
ELSE
@setbutton(trksolo1&,0)
ENDIF
IF trkstereo(2+trkvz)=TRUE THEN
@setbutton(trksolo2&,1)
ELSE
@setbutton(trksolo2&,0)
ENDIF
IF trkstereo(3+trkvz)=TRUE THEN
@setbutton(trksolo3&,1)
ELSE
@setbutton(trksolo3&,0)
ENDIF
IF trkstereo(4+trkvz)=TRUE THEN
@setbutton(trksolo4&,1)
ELSE
@setbutton(trksolo4&,0)
ENDIF
@setbutton(trkact1&,0)
@setbutton(trkact2&,0)
@setbutton(trkact3&,0)
@setbutton(trkact4&,0)
FOR i=1 TO maxspur
IF trkwahl(i)=trkvz+1 THEN
@setbutton(trkact1&,1)
ENDIF
IF trkwahl(i)=trkvz+2 THEN
@setbutton(trkact2&,1)
ENDIF
IF trkwahl(i)=trkvz+3 THEN
@setbutton(trkact3&,1)
ENDIF
IF trkwahl(i)=trkvz+4 THEN
@setbutton(trkact4&,1)
ENDIF
NEXT i
RETURN
'
> PROCEDURE trakvolinit
~@xrsrc_gaddr(0,nr,zu%)
tvmax=DPEEK(zu%+24*trkvbox&+22)                  ! Hîhe der Balancebox in Pixeln
tvmax=INT((tvmax-15))
balinmax2=tvmax
IF vol2<128+64 THEN
vp=tvmax-(vol2/5.7)
ELSE
vp=tvmax/127*(255-vol2)
ENDIF
DPOKE (zu%+24*trkvol&+18),vp                     ! Vertikalposition des Track-Volume-Sliders verÑndern
@windowtest
IF shading=FALSE THEN
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,trkvbox&,9,0,0,xwidth,ywidth)     ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE trakker
.| Glob. Var.: winh#,trakker&,rsc_window&,vornr#,nr#,hz#,arrz#,merkclip#
.|     spring#,drag#,arrherr#,hardopen#,playstop#,tmax#,lmax2#,tymax#
.|     trakslid&,trakxbut&,trakkz#,trkvslid&,trakybut&,trakkyz#,menuda#,a$
.|     tri#,l#,px#,zu%,traknam1&,a#,trak&,g#,smpedit&,edit_obj&,idx&
.| Felder    : arrtri#(),arrloop#()
.| Ruft auf  : makehz,slideinit,rsc_draw,rsc_menu_ienable,setslide,timeline
.|     setbutton,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
LOCAL vy
IF BTST(winh,trakker&)=FALSE THEN
IF startup=TRUE THEN
nr=smpedit&
@editselect
@rettmem
@killedit
ENDIF
IF rsc_window&<7 THEN
vornr=nr
nr=trakker&
winh=BSET(winh,nr)
@makehz
thz=hz
@swtosrate(thz)
merkhz=hz
oldplay=TRUE
tpkblk=77/9                         ! Einteilungs-Blockgroesse
tpkrot=8                            ! roter Bereich in Pixeln
tpksix=tpkrot+4*tpkblk                ! -6db-Bereich
IF bigfoot=FALSE THEN
trxstp=54 ! Pixelabstand pro Zeiteinheits-Teilung der X-Achse
ELSE
@calc_trakboxes
ENDIF
@buttbh(trkbx1&,mxb,trhb)
IF bigfoot=FALSE THEN
trhb=trhb-2
ELSE
trhb=trhb-1
ENDIF
trhd=3   ! y-Leerraum zur nÑchsten Box
trht=8    ! Texthîhe
trhc=INT((trhb-trht)/2)  ! Hîhe der curves
@readpos(trakedbx&)
trhs=by
trhs=trhs-28
dix=mxb-16
@buttbh(trakbox2&,dig,v)
dig=dig-mxb-1
arrz=0
spring=FALSE
arrherr=0
hardopen=FALSE
playstop=0
@timeinit
tymax=8       ! maximale zoomstufe
@slidelen(trakslid&,trakxbut&,v,tscmax)
tscstep=tscmax/tmax
tscplus=tscstep/14
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@slideinit(zoomslid&,zoomxbut&,tymax,5,vtrakkyz)
@slideinit(spurslid&,spurybut&,trkvmax,5,trkvz)
IF bigfoot=FALSE THEN
@hidetree2(trkslot&,FALSE)
@hidetree2(trkslot2&,FALSE)
@hidetree2(timeline&,FALSE)
@hidetree2(timelin2&,FALSE)
ENDIF
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
a$="XX:XX:XX XX"+CHR$(0)
tri=arrtri(1)
l=arrloop(1)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz,tscstep)
@setslide(zoomslid&,zoomxbut&,tymax,5,trakkyz)
@setslide(spurslid&,spurybut&,trkvmax,5,trkvz)
@markhlp
trmode=1
ntrmode=1
@setbutton(tblksel&,1)
'
@spurbutt
'
px=xd+32
a=0
@timeline
@trakvolinit
IF clipart=0 AND trdrag=FALSE AND tdrag=FALSE THEN
@setbutton(trakclip&,0)
ELSE
@setbutton(trakclip&,1)
ENDIF
IF tplaystart<>-1 THEN
hsec=INT(tplaystart/thz/mbit*100)
@htimeset
@textfeld(tpstrt&,a$,1)
ENDIF
IF tplayend<>-1 THEN
hsec=INT(tplayend/thz/mbit*100)
@htimeset
@textfeld(tpend&,a$,1)
ENDIF
@gettrak
ELSE
@setbutton(trak&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=trakker&
IF vornr=smpedit& THEN
@setbutton2(trak&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
@wischwasch
@trakvolinit
ENDIF
RETURN
'
> PROCEDURE showtrak  ! debug-code fÅr tracks
LOCAL w,is,a$
DEFFILL 0
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
PBOX 24,16,350,32+5*8
IF credraw=FALSE THEN
CLIP OFF
ENDIF
DEFFILL 1
a$=STR$(trkp)+","+STR$(trkz)
DEFTEXT 1,0,0,4
TEXT 32,24,a$
FOR is=1 TO 4
a$=""
w=trkpnt(is)
a$=a$+STR$(w)
IF w<>0 AND trkch(w)<>is THEN
@alerts(51)
ENDIF
IF w<>0 THEN
REPEAT
w=trknext(w)
IF w<>0 AND trkch(w)<>is THEN
@alerts(51)
ENDIF
a$=a$+","+STR$(w)
UNTIL w=0
ENDIF
TEXT 32,32+is*8,a$
NEXT is
drawnew=TRUE
@setbutton(obj,0)
RETURN
'
> PROCEDURE spuren(usetrk)
IF usetrk=4 THEN
spuren=2
IF matrix=TRUE THEN
pch4=TRUE
pmo8=FALSE
pch16=FALSE
matrixplay=TRUE
ELSE
pch4=FALSE
pmo8=FALSE
pch16=FALSE
matrixplay=FALSE
ENDIF
ENDIF
IF usetrk=8 THEN
spuren=4
IF matrix=TRUE THEN
pmo8=TRUE
pch4=FALSE
pch16=FALSE
IF mixdsp=TRUE THEN
matrixplay=FALSE
ELSE
matrixplay=TRUE
ENDIF
ELSE
pch4=FALSE
pmo8=FALSE
pch16=FALSE
matrixplay=FALSE
ENDIF
ENDIF
IF usetrk=12 THEN
spuren=6
matrixplay=FALSE
pch16=FALSE
pmo8=FALSE
pch4=FALSE
ENDIF
IF usetrk=16 THEN
spuren=8
IF matrix=TRUE THEN
IF mixdsp=TRUE THEN
matrixplay=FALSE
ELSE
matrixplay=TRUE
ENDIF
pch4=FALSE
pmo8=TRUE
pch16=TRUE
ELSE
pch4=FALSE
pmo8=FALSE
pch16=FALSE
matrixplay=FALSE
ENDIF
ENDIF
spurz=spuren*2
RETURN
'
> PROCEDURE do_trakker
.| Glob. Var.: obj#,smpplay3&,over#,trakclip&,pause2&,stop2&,forward2&
.|     rewind2&,smprpla2&,trakstrt&,trakend&,trakload&,trakanf&,trakfull&
.|     trakhelp&,trakplay&,traknam1&,trakk1&,trakk2&,trakk3&,trakk4&,trakk5&
.|     trakk6&,trakk7&,trakk8&,smpauto4&,hrdmrk#,hrd#,smpstrt4&,recplay2&
.|     hrdmerg2&,traksave&,trakxl&,trakslid&,trakxbut&,tmax#,trakkz#,slflg#
.|     trakxr&,trkslido&,trkvslid&,trakybut&,tymax#,trakkyz#,trkslidu&
.|     traktri&,trakdel&,trakloop&,trakins&,arrdel&,trakexit&,winh#,trakker&
.|     vornr#,smpedit&,trak&,hz#,merkhz#
.| Ruft auf  : trakforw,setbutton,trkpause,trkstop,trkbackw,trkstrt,trkend
.|     trakload,trkanf,trkfull,helptxt,trkplay,trktowork,trakknr,slideup
.|     timeline,slidedwn,restaura2b,swtosrate
.| Aufruf in : windows-1,
IF obj=smpplay3& THEN
hz=thz
over=0
@trakforw
@setbutton(smpplay3&,0)
ENDIF
IF obj=trakclip& THEN
@trkdragclip
IF clipart=0 OR (tdrag=FALSE AND trdrag=FALSE) THEN
@setbutton(trakclip&,0)
ELSE
@setbutton(trakclip&,1)
ENDIF
obj=0
ENDIF
IF obj=pause2& THEN
@trkpause
ENDIF
IF obj=stop2& THEN
@trkstop
ENDIF
IF obj=tnamcom& THEN
@tnamcom
ENDIF
IF obj=forward2& THEN
hz=thz
over=mbit*2
@trakforw
@setbutton(forward2&,0)
ENDIF
IF obj=rewind2& THEN
hz=thz
over=-mbit*4
@trkbackw
@setbutton(rewind2&,0)
ENDIF
IF obj=smprpla2& THEN
hz=thz
over=-mbit*2
@trkbackw
@setbutton(smprpla2&,0)
ENDIF
IF obj=hlpedit3& THEN
@tfsearch
obj=0
IF timedraw=TRUE AND tncom=TRUE THEN
@timeline
ENDIF
timedraw=FALSE
ENDIF
IF obj=trkblk& THEN
@trakblk
ENDIF
IF obj=trkdel& THEN
@trakclr
ENDIF
IF obj=tblkplay& THEN
trakblkplay
ENDIF
IF obj=curve& THEN
@trakcurve
ENDIF
IF obj=trksolo& THEN
@traksolo
ENDIF
IF obj=trkcopy& THEN
@trakcopy
ENDIF
IF obj=traklall& THEN
@trkloadall
ENDIF
IF obj=traksall& THEN
@trksaveall
ENDIF
IF obj=killtrak& THEN
@killtrak
ENDIF
IF obj=trakstrt& THEN
@trkstrt
ENDIF
IF obj=trakend& THEN
@trkend
ENDIF
IF obj=trksmpte& THEN
@trksmpte_edit
ENDIF
IF obj=trakload& THEN
@trakload
ENDIF
IF obj=trakanf& THEN
@trkanf
ENDIF
IF obj=trakfull& THEN
@trkfull
ENDIF
'
IF obj=tblksel& THEN
ntrmode=1
@tmarkmode
ENDIF
IF obj=tblkmove& THEN
ntrmode=2
@tmarkmode
ENDIF
IF obj=tblkcopy& THEN
ntrmode=3
@tmarkmode
ENDIF
IF obj=tblkdrag& THEN
ntrmode=4
@tmarkmode
ENDIF
IF obj=tblkedit& THEN
ntrmode=5
@tmarkmode
ENDIF
IF obj=tblksnap& THEN
ntrmode=6
@tmarkmode
ENDIF
IF obj=tblkcut& THEN
ntrmode=7
@tmarkmode
ENDIF
IF obj=tblkvol& THEN
ntrmode=8
@tmarkmode
ENDIF
'
IF obj=trakhelp& THEN
@helptxt("TRAKKER")
'    @showtrak
ENDIF
IF obj=trk4& THEN
@spuren(4)
ENDIF
IF obj=trk8& THEN
@spuren(8)
ENDIF
IF obj=trk12& THEN
@spuren(12)
ENDIF
IF obj=trk16& THEN
@spuren(16)
ENDIF
IF obj=trakplay& THEN
hz=thz
@trkplay
ENDIF
IF obj=trkvol& THEN
~@xrsrc_gaddr(1,obj,zu2%)
DEFMOUSE mf
topy=y
REPEAT
@mouse(x,y,k)
IF topy<>y THEN
topy=y
tpy=y-yd-24-275+32+5
IF bigfoot=TRUE THEN
tpy=tpy-265
ENDIF
IF tpy>=0 AND tpy<tvmax THEN
IF tpy>tvmax/2 THEN
vol2=INT((tvmax-tpy)/tvmax*255)/2*3
ELSE
vol2=INT(255-(tpy/tvmax*127))
ENDIF
@balwrite2(vol2,volinbal2,balinmax2)                             ! Ausgang auf 0 db stellen
trkvolume=tpy
DPOKE (zu%+24*trkvol&+18),trkvolume              ! Vertikalposition des Track-Volume-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,trkvbox&,9,0,0,xwidth,ywidth)     ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
ENDIF
UNTIL k=0
IF peakrd=FALSE THEN
balmake=FALSE
DEFMOUSE 0
ENDIF
obj=0
ENDIF
IF obj=trakk1& OR obj=trakk2& OR obj=trakk3& OR obj=trakk4& THEN
@trakknr
ENDIF
IF obj=strtl& OR obj=strtr& THEN
@juststart
ENDIF
IF obj=lend& OR obj=rend& THEN
@justend
ENDIF
IF obj=ltime& OR obj=rtime& THEN
@justtime
ENDIF
IF obj=tpsl& OR obj=tpsr& THEN
@justpstart
ENDIF
IF obj=tpel& OR obj=tper& THEN
@justpend
ENDIF
IF obj=tpstrt& THEN
@edtpstart
ENDIF
IF obj=tpend& THEN
@edtpend
ENDIF
IF obj=trkmute1& OR obj=trkmute2& OR obj=trkmute3& OR obj=trkmute4& THEN
@trkmute
ENDIF
IF obj=trkact1& OR obj=trkact2& OR obj=trkact3& OR obj=trkact4& THEN
@trkwahl
ENDIF
IF obj=trktxt1& OR obj=trktxt2& OR obj=trktxt3& OR obj=trktxt4& THEN
@trktext
ENDIF
IF obj=trksolo1& OR obj=trksolo2& OR obj=trksolo3& OR obj=trksolo4& THEN
@trkstereo
ENDIF
IF obj=trklevo1& OR obj=trklevo2& OR obj=trklevo3& OR obj=trklevo4& THEN
@trklevelup
ENDIF
IF obj=trklevu1& OR obj=trklevu2& OR obj=trklevu3& OR obj=trklevu4& THEN
@trkleveldown
ENDIF
IF obj=panl1& OR obj=panl2& OR obj=panl3& OR obj=panl4& THEN
@trkpanleft
ENDIF
IF obj=panr1& OR obj=panr2& OR obj=panr3& OR obj=panr4& THEN
@trkpanright
ENDIF
IF obj=smpauto4& THEN
wisch=TRUE
hrdmrk=hrd
hrd=1
@smpauto
hrd=hrdmrk
wisch=FALSE
ENDIF
IF obj=smpstrt4& THEN
wisch=TRUE
hrdmrk=hrd
hrd=1
@smpstart
hrd=hrdmrk
wisch=FALSE
ENDIF
IF obj=recplay2& THEN
'      @recplay
ENDIF
IF obj=hrdmerg2& THEN
@downmix
ENDIF
IF obj=traksave& THEN
'     @arrsave
ENDIF
'
IF obj=trakxl& THEN
IF trakkz2>0 THEN
@killpmark2
IF trakkz2>(tscmax-tscstep) THEN
trakkz2=tscmax-tscstep
ENDIF
@slideup2(trakslid&,trakxbut&,tscmax,tscplus,trakkz2,slflg)
@timeinit2
@timeinit3
IF slflg=TRUE THEN
@timeline
ENDIF
ENDIF
@setbutton(trakxl&,0)
ENDIF
'
IF obj=trakxr& THEN
@killpmark2
@slidedwn2(trakslid&,trakxbut&,tscmax,tscstep,tscplus,trakkz2,slflg)
@timeinit2
@timeinit3
IF slflg=TRUE THEN
@timeline
ENDIF
@setbutton(trakxr&,0)
ENDIF
'
IF obj=spuro& THEN
@slideup(spurslid&,spurybut&,trkvmax-4,1,5,trkvz,slflg)
IF slflg=TRUE THEN
@spurbutt
@timeline
ENDIF
@setbutton(spuro&,0)
ENDIF
'
IF obj=spuru& THEN
@slidedwn(spurslid&,spurybut&,trkvmax-4,1,5,trkvz,slflg)
IF slflg=TRUE THEN
@spurbutt
@timeline
ENDIF
@setbutton(spuru&,0)
ENDIF
'
IF obj=zoomxl& THEN
@killpmark2
@delcache
@slideup(zoomslid&,zoomxbut&,tymax,1,5,trakkyz,slflg)
IF slflg=TRUE THEN
@timeinit6
trakkz=0
trakkz2=0
tmax=trkztop
@timeinit
@timeinit3
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
@timeline
ENDIF
@setbutton(zoomxl&,0)
ENDIF
IF obj=zoomxr& THEN
@killpmark2
@delcache
@slidedwn(zoomslid&,zoomxbut&,tymax,1,5,trakkyz,slflg)
IF slflg=TRUE THEN
@timeinit6
trakkz=0
trakkz2=0
tmax=trkztop
@timeinit
@timeinit3
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
@timeline
ENDIF
@setbutton(zoomxr&,0)
ENDIF
IF obj=traktri& THEN
'      @arrtristate
ENDIF
IF obj=trakdel& THEN
@trakdel
ENDIF
IF obj=trakloop& THEN
'      @arrloop
ENDIF
IF obj=trakins& THEN
'      @arrinsert
ENDIF
IF obj=arrdel& THEN
'      @arrdelete
ENDIF
IF drawnew=TRUE AND @mousek=0 AND nr=trakker& THEN
drawnew=FALSE
@wischwasch
@gettrak
ENDIF
IF obj=trakexit& OR obj=9999 THEN
@deltrktxt
oldplay=FALSE
@setbutton(trakexit&,0)
winh=BCLR(winh,trakker&)
vornr=smpedit&
@restaura2b
nr=smpedit&
@editselect
@killedit
@getmem
obj=0
@setbutton(trak&,0)
GRAPHMODE 3
IF hz<>merkhz THEN
hz=merkhz
@swtosrate(hz)
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
RETURN
'
> PROCEDURE trkgotime
LOCAL vtmax
IF trkp>0 AND trkch(trkp)<>0 THEN
vornr=nr
nr=record&
a$="TIME-JUMP"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
@rsc_draw(nr,0)
@markhlp
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld(recfree&,a$,1)
m=tplaystart
dt=INT(toffs2/10)
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("TIME-JUMP")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
v=INT(dt*10/tv)
trakkz=INT(v/trktf)
trakkr=v-(trakkz*trktf)
trakkz2=trakkz*tscstep+tscplus*trakkr
toffs=(dt*trktf*trakkz)+dt*trakkr
toffs2=(trakkz*tv*trktf)+tv*trakkr
toffs3=tv*trktf
vtmax=1+INT((toffs2+toffs3)/toffs3)
IF tmax<vtmax THEN
tmax=vtmax
ENDIF
tscstep=tscmax/tmax
tscplus=tscstep/trktf
trakkz2=trakkz*tscstep+tscplus*trakkr
@setbuttgr(trakslid&,trakxbut&,tmax,5)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
@timeline
ENDIF
ENDIF
obj=0
RETURN
'
> PROCEDURE calc_trkalltime
LOCAL a,a2,a3
trkall=0
FOR a=1 TO trkvmax    ! Startpositionen anpassen fÅr Play-Startposition>0
a2=trkpnt(a)
IF a2<>0 THEN
REPEAT
a3=trktime(a2)+trkend(a2)-trkstrt(a2)
IF a3>trkall THEN
trkall=a3
ENDIF
a2=trknext(a2)
UNTIL a2=0
ENDIF
NEXT a
hsec=INT(trkall/thz/mbit*100)
@htimeset
@textfeld(trksize&,a$,1)
RETURN
'
> PROCEDURE gettrak
LOCAL x,y,b,h
IF nr=trakker& THEN
IF windcache=TRUE THEN
@windowtest
@markhlp
IF bigfoot=FALSE THEN
x=ax&+61           ! X-Locator
y=ay&+31           ! Y-Locator erste Box
b=540              ! Breite der Box
h=208              ! Hîhe der Box
ELSE
@calc_trakboxes
x=ax&+107          ! X-Locator
y=ay&+29+8         ! Y-Locator erste Box
b=trboxl+5         ! Breite der Box    war 844
h=trboxh+27        ! Hîhe der Box      war 470
ENDIF
lmtrak=b*h*planes&/8
~GRAF_MOUSE(256,0)                              ! Hidem
IF shading=FALSE THEN
IF firsttrak=0 THEN
memtrak=@rsc_get(x,y,b,h)
firsttrak=1
ELSE
memtrak=@rsc_get2(x,y,b,h,memtrak)
ENDIF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
IF ((x+b)>xwidth OR (y+h)>ywidth) THEN
drawnew4=TRUE
ENDIF
tcached=TRUE    ! neu seit 13.6.98
ELSE
drawnew4=TRUE
tcached=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE puttrsize
IF bigfoot=FALSE THEN
x=ax&+61           ! X-Locator
y=ay&+31           ! Y-Locator erste Box
b=540              ! Breite der Box
h=208              ! Hîhe der Box
ELSE
'    @calc_trakboxes
x=ax&+107          ! X-Locator
y=ay&+29+8         ! Y-Locator erste Box
b=trboxl+5         ! Breite der Box    war 844
h=trboxh+27        ! Hîhe der Box      war 470
ENDIF
IF nr=trakker& THEN
IF (x+b)>xwidth OR (y+h)>ywidth THEN
drawnew4=TRUE
ELSE
IF drawnew4=TRUE THEN
credraw=TRUE
@timeline
credraw=FALSE
@gettrak
ENDIF
drawnew4=FALSE
ENDIF
ELSE
drawnew4=FALSE
ENDIF
RETURN
'
> PROCEDURE puttrak
LOCAL x,y,b,h
IF nr=trakker& THEN
IF windcache=TRUE THEN
@windowtest
@markhlp
IF bigfoot=FALSE THEN
x=ax&+61           ! X-Locator
y=ay&+31           ! Y-Locator erste Box
b=540              ! Breite der Box
h=208              ! Hîhe der Box
ELSE
'      @calc_trakboxes
x=ax&+107          ! X-Locator
y=ay&+29+8         ! Y-Locator erste Box
b=trboxl+5         ! Breite der Box    war 844
h=trboxh+27        ! Hîhe der Box      war 470
ENDIF
IF (x1+b1)>=x AND x1<=x+b AND (y1+h1)>=y AND y1<=y+h THEN
mx=x1
my=y1
mx1=x1-x
my1=y1-y
IF x1<x THEN
mx1=0
mx=x
ENDIF
IF y1<y THEN
my1=0
my=y
ENDIF
mb1=b1
mh1=h1
IF x1<x THEN
mb1=(x1+b1)-x
ENDIF
IF y1<y THEN
mh1=(y1+h1)-y
ENDIF
IF mb1>b THEN
mb1=b
ENDIF
IF mh1>h THEN
mh1=h
ENDIF
IF mx+mb1>x+b THEN
mb1=(x+b)-mx
ENDIF
IF my+mh1>y+h THEN
mh1=(y+h)-my
ENDIF
'
IF mx+mb1>xwidth THEN
mb1=xwidth-mx
ENDIF
IF my+mh1>ywidth THEN
mh1=ywidth-my
ENDIF
IF mx>=x AND my>=y AND mx1>=0 AND my1>=0 AND mb1>0 AND mh1>0 THEN
IF shading=FALSE THEN
~GRAF_MOUSE(256,0)                              ! Hidem
@rsc_putblock(memtrak,mx,my,mx1,my1,mb1,mh1)
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
ENDIF
ELSE
drawnew4=TRUE
tcached=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE tnamcom
IF tncom=FALSE THEN
tncom=TRUE
ELSE
tncom=FALSE
ENDIF
@timeline
RETURN
'
> PROCEDURE trakclr
LOCAL tci
@alerts(31)
IF g=1 THEN
tci=trakact
IF trkcwert=tci AND clipart=1 AND trdrag=TRUE THEN
@setbutton(trakclip&,0)
trdrag=FALSE
clipart=0
trkcart=0
ENDIF
@deltrktxt
tch=tci
REPEAT
atrkp=trkpnt(tci)
IF merkclip=atrkp AND clipart=2 AND tdrag=TRUE THEN
@setbutton(trakclip&,0)
tdrag=FALSE
clipart=0
ENDIF
@trakdelvor
UNTIL trkpnt(tci)=0
@timeline
atrkp=trkp
ENDIF
@setbutton(trkdel&,0)
RETURN
'
> PROCEDURE trakblkplay
IF hardopen=TRUE THEN
pa$=trkpath$(trkp)+CHR$(0)
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
@digout(TRUE)
vsectors=sectors
sectors=trkend(trkp)-trkstrt(trkp)
sectpos=trkstrt(trkp)
playpos=sectpos
adder=0
hz=thz
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
@maschrufb5
@digout(FALSE)
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
sectors=vsectors
ENDIF
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE trakblk
IF hardopen=TRUE THEN
a=RINSTR(tblkin$,".")
b$=LEFT$(tblkin$,a)+inf$
IF EXIST(b$) THEN
OPEN "I",#2,b$
@loadloops(TRUE)
CLOSE #2
@edmfind
IF edmfind=TRUE THEN
IF bloops%(edsms,1)<>-1 AND bloops%(edsms,2)<>-1 THEN
trkstrt(trkp)=bloops%(edsms,1)*mbit
trkend(trkp)=bloops%(edsms,2)*mbit
sectpos=trkstrt(trkp)
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(trakstrt&,a$,1)
hsec=INT(trkend(trkp)/thz/mbit*100)
@htimeset
@textfeld(trakend&,a$,1)
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz/mbit*100)
@htimeset
@textfeld(trakdur&,a$,1)
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
@timeline
ENDIF
ENDIF
ELSE
@alerts(27)
@setbutton(obj,0)
ENDIF
ELSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE trakcurve
IF tvideo=FALSE THEN
tvideo=TRUE
@timeline
ELSE
tvideo=FALSE
@delcache
@timeline
ENDIF
RETURN
'
> PROCEDURE traksolo
IF tsolo=FALSE THEN
tsolo=TRUE
ELSE
tsolo=FALSE
ENDIF
RETURN
'
> PROCEDURE trakcopy
IF hardopen=TRUE THEN
IF trkz<lmax3 THEN
@oldtrkbox
otrkp=trkp
IF trkz>0 THEN
f=0
REPEAT
INC f
UNTIL f=trkz OR trkch(f)=0
IF trkch(f)=0 THEN
trkp=f
ELSE
INC trkz
trkp=trkz
ENDIF
ELSE
INC trkz
trkp=trkz
ENDIF
vtrkp=trkp
atrkp=trkp   ! aktuelles File
'
trkch(trkp)=trkch(otrkp)
trkfn$(trkp)=trkfn$(otrkp)
trkcom$(trkp)=""
trkpath$(trkp)=trkpath$(otrkp)
@searchcom(trkp)
trkstrt(trkp)=trkstrt(otrkp)
trkend(trkp)=trkend(otrkp)
trksrate(trkp)=trksrate(otrkp)
trktri(trkp)=trktri(otrkp)
trkloop(trkp)=trkloop(otrkp)
trklen(trkp)=trklen(otrkp)
'
a=trknext(otrkp)
IF a>0 THEN
trkvor(a)=trkp
ENDIF
trknext(trkp)=a
trknext(otrkp)=trkp
trkvor(trkp)=otrkp
'
trktime(trkp)=trktime(otrkp)+(trkend(otrkp)-trkstrt(otrkp))
trkmem(trkp)=0
trkg(trkp)=0
tcach(trkp)=FALSE
@trkbutcalc2
@trkbutcalc1
@trkbutdraw
'      @timeline
@opentrk
ELSE
@alerts(28)
ENDIF
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE trklevelup
LOCAL i,a,b
IF obj=trklevo1& THEN
i=1+trkvz
b=trklevt1&
ENDIF
IF obj=trklevo2& THEN
i=2+trkvz
b=trklevt2&
ENDIF
IF obj=trklevo3& THEN
i=3+trkvz
b=trklevt3&
ENDIF
IF obj=trklevo4& THEN
i=4+trkvz
b=trklevt4&
ENDIF
a=trklev(i)
IF a<200 THEN
INC a
trklev(i)=a
a$=STR$(trklev(i))+CHR$(0)
@textfeld(b,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE trkleveldown
LOCAL i,a,b
IF obj=trklevu1& THEN
i=1+trkvz
b=trklevt1&
ENDIF
IF obj=trklevu2& THEN
i=2+trkvz
b=trklevt2&
ENDIF
IF obj=trklevu3& THEN
i=3+trkvz
b=trklevt3&
ENDIF
IF obj=trklevu4& THEN
i=4+trkvz
b=trklevt4&
ENDIF
a=trklev(i)
IF a>0 THEN
DEC a
trklev(i)=a
a$=STR$(trklev(i))+CHR$(0)
@textfeld(b,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE trkpanleft
LOCAL i,a,b
IF obj=panl1& THEN
i=1+trkvz
b=pantxt1&
ENDIF
IF obj=panl2& THEN
i=2+trkvz
b=pantxt2&
ENDIF
IF obj=panl3& THEN
i=3+trkvz
b=pantxt3&
ENDIF
IF obj=panl4& THEN
i=4+trkvz
b=pantxt4&
ENDIF
a=trkpan(i)
IF a>-50 THEN
DEC a
trkpan(i)=a
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(trkpan(i)))+CHR$(0)
@textfeld(b,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE trkpanright
LOCAL i,a,b
IF obj=panr1& THEN
i=1+trkvz
b=pantxt1&
ENDIF
IF obj=panr2& THEN
i=2+trkvz
b=pantxt2&
ENDIF
IF obj=panr3& THEN
i=3+trkvz
b=pantxt3&
ENDIF
IF obj=panr4& THEN
i=4+trkvz
b=pantxt4&
ENDIF
a=trkpan(i)
IF a<50 THEN
INC a
trkpan(i)=a
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(trkpan(i)))+CHR$(0)
@textfeld(b,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE juststart
LOCAL a,b
b=INT(thz/100)*mbit
IF hardopen=TRUE THEN
a=trkstrt(trkp)
IF obj=strtl& THEN
a=a-b
IF a<0 THEN
a=0
ENDIF
ELSE
a=a+b
IF a>trklen(trkp) THEN
a=trklen(trkp)
ENDIF
ENDIF
trkstrt(trkp)=a
hsec=INT(a/thz/mbit*100)
@htimeset
@textfeld(trakstrt&,a$,1)
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz/mbit*100)
@htimeset
@textfeld(trakdur&,a$,1)
just=TRUE
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE justend
LOCAL a,b
b=INT(thz/100)*mbit
IF hardopen=TRUE THEN
a=trkend(trkp)
IF obj=lend& THEN
a=a-b
IF a<0 THEN
a=0
ENDIF
ELSE
a=a+b
IF a>trklen(trkp) THEN
a=trklen(trkp)
ENDIF
ENDIF
trkend(trkp)=a
hsec=INT(a/thz/mbit*100)
@htimeset
@textfeld(trakend&,a$,1)
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz/mbit*100)
@htimeset
@textfeld(trakdur&,a$,1)
just=TRUE
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE justtime
LOCAL a,b
b=INT(thz/100)*mbit
IF hardopen=TRUE THEN
a=trktime(trkp)
IF obj=ltime& THEN
a=a-b
IF a<0 THEN
a=0
ENDIF
ELSE
a=a+b
ENDIF
trktime(trkp)=a
hsec=INT(a/thz/mbit*100)
@htimeset
@textfeld(trksmpte&,a$,1)
just=TRUE
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE justpstart
LOCAL a,b
IF tplaystart=-1 THEN
a=0
t$="s"
@pmarkhlp(a)
ELSE
b=INT(thz/100)*mbit
a=tplaystart
IF obj=tpsl& THEN
a=a-b
IF a<0 THEN
a=0
ENDIF
ELSE
a=a+b
ENDIF
IF a<>tplaystart THEN
t$="s"
@pmarkdel(tplaystart)
@pmarkhlp(a)
ENDIF
ENDIF
tplaystart=a
hsec=INT(a/thz/mbit*100)
@htimeset
@textfeld(tpstrt&,a$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE justpend
LOCAL a,b
IF tplayend=-1 THEN
a=0
t$="e"
@pmarkhlp(a)
ELSE
b=INT(thz/100)*mbit
a=tplayend
IF obj=tpel& THEN
a=a-b
IF a<0 THEN
a=0
ENDIF
ELSE
a=a+b
ENDIF
IF a<>tplayend THEN
t$="e"
@pmarkdel(tplayend)
@pmarkhlp(a)
ENDIF
ENDIF
tplayend=a
hsec=INT(a/thz/mbit*100)
@htimeset
@textfeld(tpend&,a$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE edtpstart
LOCAL m
IF tplaystart=-1 THEN
t$="s"
tplaystart=0
@pmarkhlp(tplaystart)
hsec=INT(tplaystart/thz/mbit*100)
@htimeset
@textfeld(tpstrt&,a$,1)
@setbutton(tpstrt&,0)
ELSE
vornr=nr
nr=record&
a$="PLAY-START"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
@rsc_draw(nr,0)
@markhlp
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld(recfree&,a$,1)
m=tplaystart
dt=INT(tplaystart/thz/mbit*100)
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("PLAY-START")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
tplaystart=INT(dt/100*thz)*mbit
hsec=INT(tplaystart/thz/mbit*100)
@htimeset
@textfeld(tpstrt&,a$,1)
ENDIF
@setbutton(tpstrt&,0)
obj=0
IF m<>tplaystart THEN
t$="s"
@pmarkdel(m)
@pmarkhlp(tplaystart)
ENDIF
ENDIF
RETURN
'
> PROCEDURE edtpend
LOCAL m
IF tplayend=-1 THEN
t$="e"
tplayend=0
@pmarkhlp(tplayend)
hsec=INT(tplayend/thz/mbit*100)
@htimeset
@textfeld(tpend&,a$,1)
@setbutton(tpend&,0)
ELSE
vornr=nr
nr=record&
a$="PLAY-END"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
@rsc_draw(nr,0)
@markhlp
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld(recfree&,a$,1)
m=tplayend
dt=INT(tplayend/thz/mbit*100)
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("PLAY-END")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
tplayend=INT(dt/100*thz)*mbit
hsec=INT(tplayend/thz/mbit*100)
@htimeset
@textfeld(tpend&,a$,1)
ENDIF
@setbutton(tpend&,0)
obj=0
IF m<>tplayend THEN
t$="e"
@pmarkdel(m)
@pmarkhlp(tplayend)
ENDIF
ENDIF
RETURN
'
> PROCEDURE trkmute
IF obj=trkmute1& THEN
i=1+trkvz
ENDIF
IF obj=trkmute2& THEN
i=2+trkvz
ENDIF
IF obj=trkmute3& THEN
i=3+trkvz
ENDIF
IF obj=trkmute4& THEN
i=4+trkvz
ENDIF
IF trkmute(i)=FALSE THEN
trkmute(i)=TRUE
@setbutton(obj,1)
ELSE
trkmute(i)=FALSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE trkstereo
IF obj=trksolo1& THEN
i=1+trkvz
ENDIF
IF obj=trksolo2& THEN
i=2+trkvz
ENDIF
IF obj=trksolo3& THEN
i=3+trkvz
ENDIF
IF obj=trksolo4& THEN
i=4+trkvz
ENDIF
IF trkstereo(i)=FALSE THEN
trkstereo(i)=TRUE
@setbutton(obj,1)
ELSE
trkstereo(i)=FALSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE trkwahl
LOCAL j,i,g,i2
IF obj=trkact1& THEN
i=1+trkvz
ENDIF
IF obj=trkact2& THEN
i=2+trkvz
ENDIF
IF obj=trkact3& THEN
i=3+trkvz
ENDIF
IF obj=trkact4& THEN
i=4+trkvz
ENDIF
j=0
REPEAT
INC j
UNTIL j=maxspur OR trkwahl(j)=i
IF trkwahl(j)=i THEN
FOR i2=j TO maxspur-1
trkwahl(i2)=trkwahl(i2+1)
NEXT i2
trkwahl(maxspur)=0
@setbutton(obj,0)
ELSE
j=0
REPEAT
INC j
UNTIL j=maxspur OR trkwahl(j)=0
IF trkwahl(j)=0 THEN
trkwahl(j)=i
@setbutton(obj,1)
ELSE
@alerts(29)
@setbutton(obj,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE delcache
LOCAL i
IF trkz>0 THEN
FOR i=1 TO trkz
trkmem(i)=0
tcach(i)=FALSE
trkg(i)=0
NEXT i
ENDIF
RETURN
'
> PROCEDURE trkloadall
LOCAL bb,a$,ia,i,a,b,v$,c$,d$
@fileselect(op$+"*."+trkf$,"","LOAD ARRANGEMENT:")
IF EXIST(fil$) AND pret<>0 AND pbutt=1 THEN
a$=fil$
IF LEN(a$)>50 THEN
a$=RIGHT$(a$,50)
ENDIF
a$=a$+CHR$(0)
@textfeld(trakinfo&,a$,1)
FOR i=0 TO 8
trkpnt(i)=0
NEXT i
FOR i=1 TO lmax3
trkch(i)=0
trkcom$(i)=""
tcach(i)=FALSE
trkmem(i)=0
trkmax(i)=0
trkg(i)=0
NEXT i
OPEN "I",#1,fil$
INPUT #1,v$ ! Versionskontrolle
INPUT #1,trkz
INPUT #1,trkp
INPUT #1,trakkz
INPUT #1,trakkyz
INPUT #1,spuren
INPUT #1,tvideo
INPUT #1,trakact
INPUT #1,imaxspur
INPUT #1,itrkvmax
INPUT #1,itrkz
FOR i=1 TO imaxspur
INPUT #1,trkwahl(i)
NEXT i
FOR i=1 TO itrkvmax
INPUT #1,trkpnt(i)
INPUT #1,trklev(i)
INPUT #1,trkmute(i)
INPUT #1,trkstereo(i)
INPUT #1,trktxt$(i)
NEXT i
FOR i=1 TO itrkz
INPUT #1,trkfn$(i)
INPUT #1,trkpath$(i)
'
c$=""
REPEAT
INPUT #1,d$
c$=c$+d$
IF d$<>"" AND RIGHT$(d$,1)<>CHR$(0) THEN
c$=c$+","
ENDIF
UNTIL d$="" OR RIGHT$(d$,1)=CHR$(0)
trkcom$(i)=LEFT$(c$,LEN(c$)-1)
@searchcom(i)
INPUT #1,trkch(i)
INPUT #1,trktime(i)
INPUT #1,trkvor(i)
INPUT #1,trknext(i)
INPUT #1,trkstrt(i)
INPUT #1,trkend(i)
INPUT #1,trklen(i)
INPUT #1,trksrate(i)
trksrate(i)=thz
INPUT #1,trkloop(i)
INPUT #1,trktri(i)
NEXT i
CLOSE #1
ENDIF
IF trkz>0 THEN
ia=0
REPEAT
INC ia
UNTIL trkch(ia)>0 OR ia=trkz
IF trkch(ia)>0 THEN
tlafil$=trkpath$(ia)
a=RINSTR(tlafil$,"\")
tlafil$=LEFT$(tlafil$,a)
ELSE
tlafil$=op$
ENDIF
FOR ia=1 TO trkz
IF EXIST(trkpath$(ia))=FALSE AND trkch(ia)>0 THEN
trkpath$(ia)=tlafil$+trkfn$(ia)+CHR$(0)
IF EXIST(tlafil$+trkfn$(ia))=FALSE THEN
'
IF ia>1 THEN
ib=0
REPEAT
INC ib
UNTIL ib=ia OR (trkfn$(ib)=trkfn$(ia) AND trkch(ib)<>0)
IF trkfn$(ib)=trkfn$(ia) AND ib<>ia THEN
IF EXIST(trkpath$(ib))=TRUE THEN
trkpath$(ia)=trkpath$(ib)
fil$=trkpath$(ia)
ENDIF
ELSE
@fileselect(trkpath$(ia),trkfn$(ia),"FIND SAMPLE:")
ENDIF
ELSE
@fileselect(trkpath$(ia),trkfn$(ia),"FIND SAMPLE:")
ENDIF
'
ELSE
fil$=trkpath$(ia)
ENDIF
IF EXIST(fil$) AND pret<>0 AND pbutt=1 THEN
IF INSTR(fil$,CHR$(0))=FALSE THEN
fil$=fil$+CHR$(0)
ENDIF
trkpath$(ia)=fil$
a=RINSTR(fil$,"\")
tlafil$=LEFT$(fil$,a)
a$=RIGHT$(fil$,LEN(fil$)-a)
IF INSTR(a$,CHR$(0))<>0 THEN
a$=LEFT$(a$,LEN(a$)-1)
ENDIF
trkfn$(ia)=a$
ELSE
a$=trkpath$(ia)
bb=RINSTR(a$,CHR$(0))
IF bb>0 THEN
a$=LEFT$(a$,bb-1)
ENDIF
IF LEN(a$)>30 THEN
a$=RIGHT$(a$,30)
ENDIF
alrt$=a$
@alerts(30)
a=trkvor(ia)
IF a=0 THEN
trkpnt(trkch(ia))=0
ENDIF
b=trknext(ia)
IF a>0 THEN
trknext(a)=b
ENDIF
IF b>0 THEN
trkvor(b)=a
IF a=0 THEN
trkpnt(trkch(b))=b
ENDIF
ENDIF
trkch(ia)=0
trkfn$(ia)=""
trkcom$(ia)=""
trkpath$(ia)=""
trktime(ia)=0
trkvor(ia)=0
trknext(ia)=0
trkstrt(ia)=0
trkend(ia)=0
trklen(ia)=0
trksrate(ia)=0
trkloop(ia)=0
trktri(ia)=0
IF ia=trkz THEN
REPEAT
DEC trkz
UNTIL trkch(trkz)>0 OR trkz=0
ENDIF
ENDIF
ENDIF
NEXT ia
ENDIF
@setbutton(traklall&,0)
trakkz=0
trakkz2=0
'
toptime=0
IF trkz>0 THEN
FOR i=1 TO trkz
a=trktime(i)+(trkend(i)-trkstrt(i))
IF a>toptime THEN
toptime=trktime(i)+(trkend(i)-trkstrt(i))
ENDIF
NEXT i
ENDIF
@timeinit
IF toptime=0 THEN
trkztop=10
ELSE
trkztop=INT(toptime/mbit/thz*1000/toffs3)+1
ENDIF
IF trkztop<10 THEN
trkztop=10
ENDIF
@timeinit5
@timeinit
trakkz=0
trakkz2=0
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@setslide(trakslid&,trakxbut&,tmax,5,trakkz)
@setslide(zoomslid&,zoomxbut&,tymax,5,trakkyz)
trkvz=0
@slideinit(spurslid&,spurybut&,trkvmax,5,trkvz)
@setslide(spurslid&,spurybut&,trkvmax,5,trkvz)
@spurbutt
@timeline
atrkp=trkp
tdrag=FALSE
trdrag=FALSE
clipart=0
trkcart=0
@setbutton(trakclip&,0)
@killpmark
RETURN
'
> PROCEDURE trksaveall
@fileselect(op$+"*."+trkf$,"","SAVE ARRANGEMENT:")
IF LEN(fil$)>0 THEN
IF INSTR(fil$,".")=0 THEN
fil$=fil$+"."+trkf$
ENDIF
IF pret<>0 AND pbutt=1 THEN
IF RIGHT$(fil$,3)=trkf$ THEN
a$=fil$
IF LEN(a$)>50 THEN
a$=RIGHT$(a$,50)
ENDIF
a$=a$+CHR$(0)
@textfeld(trakinfo&,a$,1)
OPEN "O",#1,fil$
PRINT #1,"STARTRACK-TRK V1.0"           ! Versionskontrolle
PRINT #1,trkz
PRINT #1,trkp
PRINT #1,trakkz
PRINT #1,trakkyz
PRINT #1,spuren
PRINT #1,tvideo
PRINT #1,trakact
PRINT #1,maxspur
PRINT #1,trkvmax
PRINT #1,trkz
FOR i=1 TO maxspur
PRINT #1,trkwahl(i)
NEXT i
FOR i=1 TO trkvmax
PRINT #1,trkpnt(i)
PRINT #1,trklev(i)
PRINT #1,trkmute(i)
PRINT #1,trkstereo(i)
PRINT #1,trktxt$(i)
NEXT i
FOR i=1 TO trkz
PRINT #1,trkfn$(i)
PRINT #1,trkpath$(i)
PRINT #1,trkcom$(i)+CHR$(0)
PRINT #1,trkch(i)
PRINT #1,trktime(i)
PRINT #1,trkvor(i)
PRINT #1,trknext(i)
PRINT #1,trkstrt(i)
PRINT #1,trkend(i)
PRINT #1,trklen(i)
PRINT #1,trksrate(i)
PRINT #1,trkloop(i)
PRINT #1,trktri(i)
NEXT i
CLOSE #1
ENDIF
ENDIF
ENDIF
@setbutton(traksall&,0)
RETURN
'
> PROCEDURE killtrak
LOCAL i,a$,g
@alerts(61)
IF g=1 THEN
trkztop=10
toptime=0
a$=SPACE$(50)+CHR$(0)
@textfeld(trakinfo&,a$,1)
@deltrktxt
FOR i=1 TO lmax3
trkch(i)=0
trkmax(i)=0
trkcom$(i)=""
NEXT i
FOR i=1 TO trkz
trknext(i)=0
trkstrt(i)=0
trkend(i)=0
trklen(i)=0
trkfn$(i)=""
trkpath$(i)=""
trktime(i)=0
trkvor(i)=0
NEXT i
FOR i=1 TO maxspur
trkwahl(i)=0
aktpos(i)=0
thandle(i)=0
NEXT i
FOR i=1 TO trkvmax
trkpnt(i)=0
trklev(i)=100
trkmute(i)=0
trkstereo(i)=TRUE
trktxt$(i)="-----"
NEXT i
trakact=1
trkp=0
trkz=0
atrkp=0
@timeinit4
trkvz=0
@slideinit(spurslid&,spurybut&,trkvmax,5,trkvz)
@setslide(spurslid&,spurybut&,trkvmax,5,trkvz)
@spurbutt
@timeline
obj=0
tdrag=FALSE
trdrag=FALSE
clipart=0
trkcart=0
@killpmark
@setbutton(trakclip&,0)
ENDIF
@setbutton(killtrak&,0)
RETURN
'
> PROCEDURE trksmpte_edit
IF trkp>0 AND trkch(trkp)<>0 THEN
vornr=nr
nr=record&
a$="SMPTE-TIME"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
@rsc_draw(nr,0)
@markhlp
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld(recfree&,a$,1)
m=tplaystart
dt=INT(trktime(atrkp)/thz/mbit*100)
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("SMPTE-TIME")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
trktime(atrkp)=INT(dt/100*thz)*mbit
hsec=INT(trktime(atrkp)/thz/mbit*100)
@htimeset
@textfeld(trksmpte&,a$,1)
'
@calc_trkalltime
v=trktime(atrkp)+trkend(atrkp)-trkstrt(atrkp)
v=INT(v/thz/mbit*1000)
vtmax=1+INT((v+toffs3)/toffs3)
IF tmax<vtmax THEN
tmax=vtmax
tscstep=tscmax/tmax
tscplus=tscstep/trktf
trakkz2=trakkz*tscstep+tscplus*trakkr
@setbuttgr(trakslid&,trakxbut&,tmax,5)
ENDIF
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
'
@timeline
ENDIF
ENDIF
@setbutton(trksmpte&,0)
obj=0
RETURN
'
> PROCEDURE timeinit
trktf=10
IF trakkyz=0 THEN
dt=50
tv=50
b$="ms"
ENDIF
IF trakkyz=1 THEN
dt=100
tv=100
b$="ms"
ENDIF
IF trakkyz=2 THEN
dt=500
tv=500
b$="ms"
ENDIF
IF trakkyz=3 THEN
dt=1
tv=1000
b$="s"
ENDIF
IF trakkyz=4 THEN
dt=5
tv=5000
b$="s"
ENDIF
IF trakkyz=5 THEN
dt=10
tv=10000
b$="s"
ENDIF
IF trakkyz=6 THEN
dt=1
tv=1000*60
b$="m"
ENDIF
IF trakkyz=7 THEN
dt=5
tv=1000*60*5
b$="m"
ENDIF
IF trakkyz=8 THEN
dt=10
tv=1000*60*10
b$="m"
ENDIF
toffs=dt*trktf*trakkz
toffs2=tv*trktf*trakkz
toffs3=tv*trktf
IF tmax<10 THEN
tmax=10
ENDIF
tscstep=tscmax/tmax
tscplus=tscstep/trktf
RETURN
'
> PROCEDURE timeinit2
LOCAL a,a2
IF trakkz2=0 THEN
a=0
ELSE
a2=((tscmax-tscstep)/trakkz2)
IF a2=0 THEN
a2=1
ENDIF
a=(tmax-1)/a2
ENDIF
trakkz=INT(a+0.001)
IF trakkz>(tmax-1) THEN
trakkz=tmax-1
ENDIF
trakkr=ROUND((a-trakkz)*trktf)
IF trakkr<0 THEN
trakkr=0
ENDIF
toffs=(dt*trktf*trakkz)+dt*trakkr
toffs2=(trakkz*tv*trktf)+tv*trakkr
toffs3=tv*trktf
' PRINT trakkz,trakkr
RETURN
'
> PROCEDURE timeinit3
IF trakkz=(tmax-1) THEN
INC tmax
@timeinit
@timeinit2
trakkz2=trakkz*tscstep
@setbuttgr(trakslid&,trakxbut&,tmax,5)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
ENDIF
RETURN
'
> PROCEDURE timeinit4
trakkz=0
trakkr=0
trakkz2=0
trkztop=10
tmax=trkztop
@timeinit
@timeinit3
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
RETURN
'
> PROCEDURE timeinit5
tmax=trkztop
@timeinit
trakkz=0
trakkz2=0
trakkr=0
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@setslide(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
RETURN
'
> PROCEDURE timeinit6
@timeinit
IF toptime=0 THEN
trkztop=10
ELSE
trkztop=INT(toptime/mbit/thz*1000/toffs3)+1
ENDIF
IF trkztop<10 THEN
trkztop=10
ENDIF
RETURN
'
> PROCEDURE makesearch
LOCAL a,v
trkp=trktnr(tmfsz)
atrkp=trkp
vtrkp=trkp
a=trktime(trkp)
v=INT(a/thz/mbit*1000/tv)
trakkz=INT(v/trktf)
trakkr=v-(trakkz*trktf)
trakkz2=trakkz*tscstep+tscplus*trakkr
toffs=(dt*trktf*trakkz)+dt*trakkr
toffs2=(trakkz*tv*trktf)+tv*trakkr
toffs3=tv*trktf
trakact=trkch(trkp)
trkvz=trakact-1
RETURN
'
> PROCEDURE makesearch2
@spurbutt
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
@setslide(spurslid&,spurybut&,trkvmax,5,trkvz)
@timeline
@opentrk
RETURN
'
> PROCEDURE trak_timetxt
LOCAL i
IF bigfoot=TRUE THEN
@markhlp
ttxlin=ax&+dix+32
FOR i=0 TO 10
IF maxcol=2 THEN
COLOR 1
ELSE
COLOR 0
ENDIF
LINE ttxlin+trxstp*i,ay&+53,ttxlin+trxstp*i,ay&+57
NEXT i
ENDIF
IF trakkyz>5 THEN
IF bigfoot=FALSE THEN
sp=9
sp2=91
t$=LEFT$(STR$(toffs)+b$+SPACE$(sp),sp)
t$=t$+LEFT$(STR$(toffs+dt)+b$+SPACE$(sp),sp)
t$=t$+LEFT$(STR$(toffs+dt*2)+b$+SPACE$(sp),sp)
t$=t$+LEFT$(STR$(toffs+dt*3)+b$+SPACE$(sp),sp)
t$=t$+LEFT$(STR$(toffs+dt*4)+b$+SPACE$(sp),sp)
t$=t$+LEFT$(STR$(toffs+dt*5)+b$+SPACE$(sp),sp)
t$=t$+LEFT$(STR$(toffs+dt*6)+b$+SPACE$(sp),sp)
t$=t$+LEFT$(STR$(toffs+dt*7)+b$+SPACE$(sp),sp)
t$=t$+LEFT$(STR$(toffs+dt*8)+b$+SPACE$(sp),sp)
t$=t$+LEFT$(STR$(toffs+dt*9)+b$+SPACE$(sp),sp)
t$=t$+CHR$(0)
sl$="|"+SPACE$(sp-1)
sl$=sl$+sl$+sl$+sl$+sl$+sl$+sl$+sl$+sl$+sl$
IF LEN(sl$)>sp2 THEN
sl$=LEFT$(sl$,sp2)
ENDIF
sl$=sl$+CHR$(0)
ELSE
sp=11
t$=STR$(toffs)+b$
@bigtext3(ttxlin+trxstp*0,ay&+53,1,t$,0,0)
t$=STR$(toffs+dt)+b$
@bigtext3(ttxlin+trxstp*1,ay&+53,1,t$,0,6)
t$=STR$(toffs+dt*2)+b$
@bigtext3(ttxlin+trxstp*2,ay&+53,1,t$,0,0)
t$=STR$(toffs+dt*3)+b$
@bigtext3(ttxlin+trxstp*3,ay&+53,1,t$,0,6)
t$=STR$(toffs+dt*4)+b$
@bigtext3(ttxlin+trxstp*4,ay&+53,1,t$,0,0)
t$=STR$(toffs+dt*5)+b$
@bigtext3(ttxlin+trxstp*5,ay&+53,1,t$,0,6)
t$=STR$(toffs+dt*6)+b$
@bigtext3(ttxlin+trxstp*6,ay&+53,1,t$,0,0)
t$=STR$(toffs+dt*7)+b$
@bigtext3(ttxlin+trxstp*7,ay&+53,1,t$,0,6)
t$=STR$(toffs+dt*8)+b$
@bigtext3(ttxlin+trxstp*8,ay&+53,1,t$,0,0)
t$=STR$(toffs+dt*9)+b$
@bigtext3(ttxlin+trxstp*9,ay&+53,1,t$,0,6)
t$=STR$(toffs+dt*10)+b$
@bigtext3(ttxlin+trxstp*10,ay&+53,1,t$,0,0)
ENDIF
ELSE
IF bigfoot=FALSE THEN
hsec=toffs2/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(sp*2),sp*2)
hsec=(toffs2+(tv*2))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=t$+LEFT$(a$+SPACE$(sp*2),sp*2)
hsec=(toffs2+(tv*4))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=t$+LEFT$(a$+SPACE$(sp*2),sp*2)
hsec=(toffs2+(tv*6))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=t$+LEFT$(a$+SPACE$(sp*2),sp*2)
hsec=(toffs2+(tv*8))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=t$+LEFT$(a$+SPACE$(sp*2),sp*2)
t$=t$+CHR$(0)
sl$="|"+SPACE$(sp*2-1)
sl$=sl$+sl$+sl$+sl$+sl$+sl$
IF LEN(sl$)>sp2 THEN
sl$=LEFT$(sl$,sp2)
ENDIF
sl$=sl$+CHR$(0)
ELSE
hsec=toffs2/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*0,ay&+53,2,t$,1,0)
hsec=(toffs2+(tv*1))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*1,ay&+53,2,t$,1,6)
hsec=(toffs2+(tv*2))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*2,ay&+53,2,t$,1,0)
hsec=(toffs2+(tv*3))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*3,ay&+53,2,t$,1,6)
hsec=(toffs2+(tv*4))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*4,ay&+53,2,t$,1,0)
hsec=(toffs2+(tv*5))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*5,ay&+53,2,t$,1,6)
hsec=(toffs2+(tv*6))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*6,ay&+53,2,t$,1,0)
hsec=(toffs2+(tv*7))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*7,ay&+53,2,t$,1,6)
hsec=(toffs2+(tv*8))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*8,ay&+53,2,t$,1,0)
hsec=(toffs2+(tv*9))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*9,ay&+53,2,t$,1,6)
hsec=(toffs2+(tv*10))/10
@htimeset                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*10,ay&+53,2,t$,1,0)
ENDIF
ENDIF
IF bigfoot=FALSE THEN
@textfeld(trkslot&,sl$,1)
@textfeld(timeline&,t$,1)
ENDIF
RETURN
'
> PROCEDURE timeline
.| Glob. Var.: nr#,zu%,traknam1&,trakbox2&,xwidth#,ywidth#,trakkyz#,dt#,tv#
.|     b$,toffs#,trakkz#,toffs2#,a$,timeline&,vtrkp#,trkp#,trkz#,notrk#,t#
.|     trkc#,dv#,dv2#,trkbut#,d#,flen#
.| Felder    : trkch#(),trktime#(),trkend#(),trkstrt#(),trkfn$(),trksrate#()
.|     trkpnt#(),trknext#()
.| Ruft auf  : xrsrc_gaddr,hidetree2,textfeld,trkbutcalc2,trkbutcalc1
.|     hidetree
.| Aufruf in : button-4,trakker-1,do_trakker-4,
LOCAL i,j,t,d,dv,dv2,t$,sl$
IF nr=trakker& THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
@windowtest
ENDIF
IF cupdate=FALSE AND shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,trakbox2&,9,0,0,xwidth,ywidth)     ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
~@xrsrc_gaddr(0,nr,zu%)
@timeinit
@timeinit2
@trak_timetxt
vtrkp=trkp
IF trkz>0 THEN
@calc_trkalltime
FOR i=trkvz+1 TO trkvz+4
notrk=FALSE
t=0
trkc=0
REPEAT
INC t
IF trkch(t)=i AND trkvor(t)=0 THEN
INC trkc
ENDIF
UNTIL t=trkz OR (trkch(t)=i AND trkvor(t)=0)
IF trkch(t)=i THEN
dv=trktime(t)
dv2=trkend(t)-trkstrt(t)
d=dv2                   ! Auflîsung in ms
trkp=t
REPEAT
extrk=FALSE
@trkbutcalc2
@trkbutcalc1
IF extrk=TRUE OR notrk=TRUE THEN
trkp=trknext(trkp)
ENDIF
UNTIL trkp=0 OR notrk=FALSE OR trkz=trkp
IF notrk=FALSE THEN
IF trkc=1 THEN
'            trkpnt(i)=t
ENDIF
@trkbutdraw     ! neu
ELSE
trkc=0
ENDIF
notrk=FALSE
IF trknext(t)<>0 THEN
REPEAT
t=trknext(t)
INC trkc
dv=trktime(t)
dv2=trkend(t)-trkstrt(t)
d=dv2                  ! Auflîsung in ms
trkp=t
REPEAT
extrk=FALSE
@trkbutcalc2
@trkbutcalc1
IF extrk=TRUE OR notrk=TRUE THEN
trkp=trknext(trkp)
ENDIF
UNTIL trkp=0 OR notrk=FALSE OR trkz=trkp
IF notrk=FALSE THEN
IF trkc=1 THEN
'                trkpnt(i)=t
ENDIF
@trkbutdraw     ! neu
ELSE
trkc=0
ENDIF
notrk=FALSE
UNTIL trknext(t)=0 OR trktime(t)>=((toffs2+toffs3)*(thz/1000)*mbit)
ENDIF
ENDIF
NEXT i
ENDIF
trkp=vtrkp
IF trkmem(trkp)=0 AND trkch(trkp)=0 THEN  ! letzter teil ab and neu
trkp=trkz
vtrkp=trkp
ENDIF
@tplaymark
IF credraw=FALSE THEN
CLIP OFF
ENDIF
@gettrak
ENDIF
RETURN
'
> PROCEDURE tractdraw
'  PRINT atrkp
@pmarkhlp2
IF trkp<>0 THEN
IF trkpath$(trkp)<>"MEMORY" AND trkpath$(trkp)<>"" THEN
sectpos=trkstrt(trkp)
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(trakstrt&,a$,1)
s=trkend(trkp)
hsec=INT(s/thz/mbit*100)
@htimeset
@textfeld(trakend&,a$,1)
hsec=INT((trkend(trkp)-sectpos)/thz/mbit*100)
@htimeset
@textfeld(trakdur&,a$,1)
s=trklen(trkp)
hsec=INT(s/thz/mbit*100)
@htimeset
@textfeld(traklen&,a$,1)
hsec=INT(trktime(trkp)/thz/mbit*100)
@htimeset
@textfeld(trksmpte&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE trakbutset(bs)
LOCAL t
IF trakact=1+trkvz THEN
t=trakk1&
ENDIF
IF trakact=2+trkvz THEN
t=trakk2&
ENDIF
IF trakact=3+trkvz THEN
t=trakk3&
ENDIF
IF trakact=4+trkvz THEN
t=trakk4&
ENDIF
@setbutton(t,bs)
RETURN
'
> PROCEDURE trakknr
.| Glob. Var.: trakact#,trakk1&,trakk2&,trakk3&,trakk4&,trakk5&,trakk6&
.|     trakk7&,trakk8&,obj#
.| Ruft auf  : setbutton
.| Aufruf in : do_trakker-1,
LOCAL t,tobj
IF obj=trakk1& THEN
t=1+trkvz
ENDIF
IF obj=trakk2& THEN
t=2+trkvz
ENDIF
IF obj=trakk3& THEN
t=3+trkvz
ENDIF
IF obj=trakk4& THEN
t=4+trkvz
ENDIF
tobj=obj
IF trakact<>0 THEN
IF trakact=t THEN
@trkdragin
ELSE
@trakbutset(0)
ENDIF
ENDIF
trakact=t
@setbutton(tobj,1)
RETURN
'
> PROCEDURE alltrakcopy(otc,ntc)
LOCAL az,atcex,mtrkp
az=0
mtrkp=0
atcex=FALSE
REPEAT
IF az=0 THEN
otrkp=trkpnt(otc)
ELSE
otrkp=trknext(otrkp)
ENDIF
INC az
IF otrkp<>0 THEN
IF trkz<lmax3 THEN
@oldtrkbox
'    otrkp=trkp
IF trkz>0 THEN
f=0
REPEAT
INC f
UNTIL f=trkz OR trkch(f)=0
IF trkch(f)=0 THEN
trkp=f
ELSE
INC trkz
trkp=trkz
ENDIF
ELSE
INC trkz
trkp=trkz
ENDIF
vtrkp=trkp
atrkp=trkp   ! aktuelles File
IF az=1 THEN
trkpnt(ntc)=trkp
ENDIF
trkch(trkp)=ntc
trkfn$(trkp)=trkfn$(otrkp)
trkcom$(trkp)=trkcom$(otrkp)
trkpath$(trkp)=trkpath$(otrkp)
'    @searchcom(trkp)
trkstrt(trkp)=trkstrt(otrkp)
trkend(trkp)=trkend(otrkp)
trksrate(trkp)=trksrate(otrkp)
trktri(trkp)=trktri(otrkp)
trkloop(trkp)=trkloop(otrkp)
trklen(trkp)=trklen(otrkp)
trktime(trkp)=trktime(otrkp)
trkmem(trkp)=0
trkg(trkp)=0
tcach(trkp)=FALSE
IF trkvor(otrkp)=0 THEN
trkvor(trkp)=0
ENDIF
IF trknext(otrkp)=0 THEN
trknext(trkp)=0
atcex=TRUE
ENDIF
'
IF mtrkp<>0 THEN
trknext(mtrkp)=trkp
trkvor(trkp)=mtrkp
ENDIF
mtrkp=trkp
'
@trkbutcalc2
@trkbutcalc1
@trkbutdraw
'      @timeline
ELSE
@alerts(28)
atcex=TRUE
ENDIF
ENDIF
UNTIL atcex=TRUE
@opentrk
RETURN
'
> PROCEDURE trakload
notrk=FALSE
IF trakact<>0 THEN
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(traktime&,a$,1)
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF neufsel=TRUE THEN
@newfsel
ELSE
@fileselect(op$+"*."+ext$,"","LOAD TRACK-FILE:")
ENDIF
IF EXIST(fil$) THEN
@busy_mouse
@ldhead
tblkin$=fil$
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
sectors=f
sectall=sectors
sectpos=0
hardopen=TRUE
hsec=INT(sectall/thz/mbit*100)
@htimeset
@textfeld(traklen&,a$+CHR$(0),1)
a4$=LEFT$(STR$(INT(thz/100)/10)+SPACE$(4),4)+CHR$(0)
a$=nam$+CHR$(0)
IF trkz<lmax3 THEN
@oldtrkbox
IF trkz>0 THEN
f=0
REPEAT
INC f
UNTIL f=trkz OR trkmem(f)=0
IF trkmem(f)=0 THEN
trkp=f
ELSE
INC trkz
trkp=trkz
ENDIF
ELSE
INC trkz
trkp=trkz
ENDIF
vtrkp=trkp
atrkp=trkp   ! aktuelles File
dv=0
dv2=0
IF trkpnt(trakact)=0 THEN
trkpnt(trakact)=trkp
ENDIF
t=trkpnt(trakact)
IF trkch(t)=trakact THEN
t2=t
REPEAT
t2=trknext(t2)
IF t2<>0 THEN
t=t2
ENDIF
dv=trktime(t)
dv2=trkend(t)-trkstrt(t)
UNTIL (trkch(t)=trakact AND trknext(t)=0)
ENDIF
IF trkch(t)=trakact AND trknext(t)=0 THEN
trknext(t)=trkp
trkvor(trkp)=t
ENDIF
butnam$=a$
a$="*"+CHR$(0)  ! Startobj
@textfeld(trakname&,nam$+CHR$(0),1)
tl=72
d=dv2                    ! Auflîsung in ms
trktime(trkp)=dv+d
trksrate(trkp)=thz
trkpath$(trkp)=fil$+CHR$(0)
trkfn$(trkp)=nam$
trkcom$(trkp)=""
@searchcom(trkp)
trklen(trkp)=sectall
trkch(trkp)=trakact
@trkbutcalc2
@trkbutcalc1
@trkbutdraw
@opentrk
ELSE
@alerts(28)
ENDIF
ENDIF
ELSE
@alerts(32)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE traksethz
.| Glob. Var.: vhz#,trkp#
.| Felder    : trksrate#()
.| Ruft auf  : swtosrate,analog,digout
.| Aufruf in : trakforw-1,trkbackw-1,
'  thz=trksrate(trkp)
'  IF thz=0 THEN
'  thz=44100
' ENDIF
'  @swtosrate(thz)
@analog
@digout(TRUE)
RETURN
'
> PROCEDURE normplay1
vpmo8=pmo8
vpch16=pch16
vpch4=pch4
pmo8=FALSE
pch16=FALSE
pch4=FALSE
RETURN
'
> PROCEDURE normplay2
pmo8=vpmo8
pch16=vpch16
pch4=vpch4
RETURN
'
> PROCEDURE trakforw
.| Glob. Var.: trkp#,pa$,vhz#,playstop#,hardopen#,handle#,sectall#,sectpos#
.|     sectors#,l#,playpos#,flen#,back%,hsec#,traktime&,a$,nr#
.| Felder    : trkpath$(),trksrate#()
.| Ruft auf  : traksethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_trakker-2,
@normplay1
IF trkpath$(trkp)<>"" AND pa$<>"" THEN
'    @traksethz
'    vhz=trksrate(trkp)
IF playstop=2 AND hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
@analog
@digout(TRUE)
'        @swtosrate(vhz)
IF sectall>sectpos THEN
sectors=sectall-sectpos
l=0
playpos=sectpos
adder=over
hz=thz
@maschrufb5
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
ENDIF
@digout(FALSE)
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
IF handle>0 THEN
@analog
@digout(TRUE)
'          @swtosrate(vhz)
playpos=sectpos
sectors=sectall-sectpos
l=0
playpos=sectpos
adder=over
hz=thz
@maschrufb5
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
@digout(FALSE)
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
IF thz>0 THEN
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
ENDIF
@normplay2
RETURN
'
> PROCEDURE trkbackw
.| Glob. Var.: trkp#,pa$,vhz#,playstop#,hardopen#,sectpos#,sectors#,l#
.|     playpos#,flen#,back%,handle#,sectall#,hsec#,traktime&,a$,nr#
.| Felder    : trkpath$(),trksrate#()
.| Ruft auf  : traksethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_trakker-2,
@normplay1
IF trkpath$(trkp)<>"" AND pa$<>"" THEN
'    @traksethz
'    vhz=trksrate(trkp)
IF playstop=2 AND hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
@analog
@digout(TRUE)
'      @swtosrate(vhz)
IF sectpos>0 THEN
sectors=sectpos
l=0
playpos=sectpos
adder=over
hz=thz
@maschrufb5
IF sectpos>0 THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
ENDIF
@digout(FALSE)
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF sectpos=0 THEN
sectpos=sectall
ENDIF
playpos=sectpos
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
IF handle>0 THEN
@analog
@digout(TRUE)
'          @swtosrate(vhz)
sectors=sectpos
l=0
playpos=sectpos
hz=thz
@maschrufb5
IF sectpos>0 THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
@digout(FALSE)
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
@normplay2
RETURN
'
> PROCEDURE trkpause
.| Glob. Var.: pause2&
.| Ruft auf  : setbutton
.| Aufruf in : do_trakker-1,
IF XBIOS(xbs,1)=&H71273800 AND intplay=TRUE THEN
IF mpause2=FALSE THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
mpause2=TRUE
ELSE
IF demo=FALSE THEN
@write_int(1)
ENDIF
mpause2=FALSE
ENDIF
ELSE
@setbutton(pause2&,0)
ENDIF
RETURN
'
> PROCEDURE trkstop
.| Glob. Var.: handle#,playstop#,hardopen#,a$,trakname&,stop2&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : do_trakker-1,
~GEMDOS(62,handle)
'  playstop=1
'  handle=0
'  hardopen=FALSE
'  a$=SPACE$(12)
'  @textfeld(trakname&,a$,1)
IF XBIOS(xbs,1)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
intplay=FALSE
ENDIF
REPEAT
UNTIL @mousek=0
PAUSE 3
@setbutton(stop2&,0)
@setbutton(tblkplay&,0)
RETURN
'
> PROCEDURE trkstrt
.| Glob. Var.: trkp#,sectpos#,hsec#,flen#,vhz#,trakstrt&,a$
.| Felder    : trkstrt#()
.| Ruft auf  : htimeset,textfeld,setbutton,trkbutcalc1
.| Aufruf in : do_trakker-1,
IF trkp>0 AND trkch(trkp)<>0 THEN
trkstrt(trkp)=sectpos
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(trakstrt&,a$,1)
IF sectpos>trkend(trkp) THEN
trkend(trkp)=sectpos
@textfeld(trakend&,a$,1)
ENDIF
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz/mbit*100)
@htimeset
@textfeld(trakdur&,a$,1)
@setbutton(trakstrt&,0)
@trkbutcalc1
'  @trkbutdraw
@timeline
ELSE
@setbutton(trakstrt&,0)
ENDIF
RETURN
'
> PROCEDURE trakdelvor
LOCAL i,j,len
IF tch<>trkch(atrkp) AND atrkp<>0 THEN
trkpnt(tch)=0
atrkp=0
@alerts(51)
ENDIF
IF atrkp<>0 AND tch=trkch(atrkp) THEN
IF atrkp<trkz THEN
a=trkmem(atrkp)
b=trkmem(atrkp)+trkg(atrkp)*8
IF a>0 AND b>0 THEN
dtrc=b-a
topmem=trkmem(trkz)+trkg(trkz)*8
len=topmem-dtrc-trkmem(0)
IF len>0 THEN
BMOVE b,a,len
ENDIF
FOR i=atrkp+1 TO trkz
IF trkmem(i)>0 THEN
trkmem(i)=(trkmem(i)-dtrc)
ENDIF
NEXT i
ENDIF
ENDIF
IF trkvor(atrkp)=0 THEN
a=trknext(atrkp)
trkpnt(trkch(atrkp))=a
ENDIF
trkch(atrkp)=0
trktime(atrkp)=0
trkmax(atrkp)=0
trkmem(atrkp)=0
trkg(atrkp)=0
tcach(atrkp)=0
trkfn$(atrkp)=""
trkcom$(atrkp)=""
trkpath$(atrkp)=""
trkstrt(atrkp)=0
trkend(atrkp)=0
trksrate(atrkp)=0
trktri(atrkp)=0
trkloop(atrkp)=0
trklen(atrkp)=0
trktime(atrkp)=0
a=trkvor(atrkp)
b=trknext(atrkp)
IF a<>0 THEN
trknext(a)=b
ENDIF
IF b<>0 THEN
trkvor(b)=a
ENDIF
trknext(atrkp)=0
trkvor(atrkp)=0
trkch(atrkp)=0
IF atrkp=trkz THEN
REPEAT
DEC trkz
UNTIL trkch(trkz)>0 OR trkz=0
ENDIF
ENDIF
RETURN
'
> PROCEDURE deltrktxt
a$=SPACE$(12)+CHR$(0)
@textfeld(trakname&,a$,1)
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(trakstrt&,a$,1)
@textfeld(trakend&,a$,1)
@textfeld(trakdur&,a$,1)
@textfeld(traklen&,a$,1)
@textfeld(trksmpte&,a$,1)
hsec=0
@htimeset
@textfeld(traktime&,a$,1)
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
RETURN
'
> PROCEDURE trakdel
LOCAL a$
IF trkch(atrkp)=trkcwert AND trdrag=TRUE AND clipart=1 THEN
IF trkpnt(trkcwert)<>0 THEN
IF trknext(trkpnt(trkcwert))=0 THEN
@setbutton(trakclip&,0)
trdrag=FALSE
clipart=0
trkcart=0
ENDIF
ENDIF
ENDIF
IF atrkp=merkclip AND tdrag=TRUE AND clipart=2 THEN
@setbutton(trakclip&,0)
tdrag=FALSE
clipart=0
ENDIF
@deltrktxt
IF atrkp<>0 THEN
tch=trkch(atrkp)
@trakdelvor
ENDIF
IF atrkp<>0 THEN
@timeline
atrkp=trkp
ENDIF
@setbutton(trakdel&,0)
RETURN
'
> PROCEDURE trkbutcalc1    ! Breite
.| Glob. Var.: a#,trkp#,b#,c#,flen#,tv#,d#,toffs2#,px#,nr#,zu%,trkbut#
.|     trakbox2&,xwidth#,ywidth#,notrk#
.| Felder    : trkstrt#(),trkend#(),trksrate#(),trktime#(),trknext#()
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : timeline-2,trkstrt-1,trkend-1,
IF trkp>0 AND trkch(trkp)<>0 THEN
@markhlp
a=trkstrt(trkp)
b=trkend(trkp)
c=b-a
IF c<1 THEN
c=1
ENDIF
c=INT((c/thz/mbit*1000))
d=trktime(trkp)/thz/mbit*1000
IF toffs2>0 THEN
d=d-toffs2
ENDIF
IF d<0 THEN
IF d+c>=0 THEN
c=c+d
d=0
ENDIF
ENDIF
c=INT((c*trxstp/tv))
IF c<6 THEN   ! vorher 72
c=6
ENDIF
IF d>=0 THEN
d=INT((d/tv*trxstp))
ENDIF
IF c<=0 THEN
extrk=TRUE
ENDIF
IF d<=dig AND d>=0 AND c>0 AND trkp<>0 AND extrk=FALSE THEN
~@xrsrc_gaddr(0,nr,zu%)
IF c+d>dig THEN
c=dig-d
ENDIF
'    DPOKE (zu%+24*trkbut+20),c                         ! Breite des Objekts verÑndern
tr_b=c
'    ~WIND_UPDATE(1)                                    ! BEG_UPDATE
'    ~OBJC_DRAW(zu%,trakbox2&,9,0,0,xwidth,ywidth)     ! neu zeichnen
'    ~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
notrk=TRUE
ENDIF
ENDIF
RETURN
'
> PROCEDURE trkbutcalc2    ! X-Position
IF trkp>0 AND trkch(trkp)<>0 THEN
@markhlp
d=trktime(trkp)/thz/mbit*1000
IF toffs2>0 THEN
d=d-toffs2
ENDIF
a=trkstrt(trkp)
b=trkend(trkp)
c=b-a
c=INT((c/thz/mbit*1000))
IF d<0 THEN
IF d+c>=0 THEN
d=0
ENDIF
ENDIF
c=INT((c*trxstp/tv))
IF c<6 THEN   ! vorher 72
c=6
ENDIF
d=INT(d*trxstp/tv)
IF d<0 THEN
extrk=TRUE
ENDIF
IF d<=dig AND d>=0 AND c>0 AND trkp<>0 AND extrk=FALSE THEN
~@xrsrc_gaddr(0,nr,zu%)
IF c+d+tl>dig THEN
c=dig-d
ENDIF
'    DPOKE (zu%+24*(trkbut)+16),d                       ! X-Position des Objekts verÑndern
tr_x=d
ELSE
notrk=TRUE
ENDIF
ENDIF
RETURN
'
> PROCEDURE tcvorclr
LOCAL i,i2,a,b
FOR i=1 TO trc-1
IF tcach(i)=TRUE AND trkg(i)>0 THEN
z=z+trkg(i)*8
a=trkmem(i)+trkg(i)*8
b=trkmem(i)
IF a>0 AND b>0 AND (topmem-a)<>0 THEN
BMOVE a,b,topmem-a
topmem=topmem-(a-b)
ENDIF
tcach(i)=FALSE
trkg(i)=0
IF i<trkz THEN
FOR i2=i+1 TO trkz
IF trkmem(i2)>0 THEN
trkmem(i2)=trkmem(i2)-(a-b)   ! Datenverschiebung
ENDIF
NEXT i2
ENDIF
ENDIF
EXIT IF z>dtr
NEXT i
RETURN
'
> PROCEDURE tcnachclr
LOCAL i,i2,a,b
FOR i=trc+1 TO trkz
IF tcach(i)=TRUE AND trkg(i)>0 THEN
z=z+trkg(i)*8
a=trkmem(i)+trkg(i)*8
b=trkmem(i)
IF a>0 AND b>0 AND (topmem-a)<>0 THEN
BMOVE a,b,topmem-a
topmem=topmem-(a-b)
ENDIF
tcach(i)=FALSE
trkg(i)=0
IF i<trkz THEN
FOR i2=i+1 TO trkz
IF trkmem(i2)>0 THEN
trkmem(i2)=trkmem(i2)-(a-b)   ! Datenverschiebung
ENDIF
NEXT i2
ENDIF
ENDIF
EXIT IF z>dtr
NEXT i
RETURN
'
> PROCEDURE tcachclr
LOCAL g
z=0
dtr=(glen*8)-(trkg(trc)*8)
IF trkz>1 THEN
IF trc>1 THEN
@tcvorclr
IF z<=dtr THEN
@tcnachclr
ENDIF
ELSE
@tcnachclr
ENDIF
IF z>dtr THEN
notrkmem=FALSE
@trksprint
ELSE
@alerts(33)
ENDIF
ENDIF
RETURN
'
> PROCEDURE trksprint
LOCAL tm,i,a
IF trc=0 AND trkz>0 THEN
dtrc=(glen*8)-(trkg(trc)*8)
tm=trkz+1
REPEAT
DEC tm
UNTIL trkmem(tm)>0
topmem=trkmem(tm)+trkg(tm)*8
IF (topmem-trkmem(0)+dtrc)>tmlen THEN
notrkmem=TRUE
tcach(trc)=0
ELSE
notrkmem=FALSE
ENDIF
IF notrkmem=FALSE THEN
FOR i=trc+1 TO trkz
IF trkmem(i)>0 THEN
trkmem(i)=trkmem(i)+dtrc   ! Datenverschiebung
ENDIF
NEXT i
a=trkmem(trc)+trkg(trc)*8
IF a>0 AND dtrc<>0 AND (topmem-a)>0 THEN
BMOVE a,a+dtrc,topmem-a
ENDIF
ENDIF
ENDIF
IF cached=FALSE THEN
IF trc>0 THEN
trc2=trc
REPEAT
DEC trc2
trkmem(trc)=trkmem(trc2)+trkg(trc2)*8
UNTIL trkmem(trc)<>0
IF trc<trkz THEN
dtrc=(glen*8)-(trkg(trc)*8)
tm=trkz+1
REPEAT
DEC tm
UNTIL trkmem(tm)>0
topmem=trkmem(tm)+trkg(tm)*8
IF (topmem-trkmem(0)+dtrc)>tmlen THEN
notrkmem=TRUE
tcach(trc)=0
ELSE
notrkmem=FALSE
ENDIF
IF notrkmem=FALSE THEN
FOR i=trc+1 TO trkz
IF trkmem(i)>0 THEN
trkmem(i)=trkmem(i)+dtrc   ! Datenverschiebung
ENDIF
NEXT i
a=trkmem(trc)+trkg(trc)*8
IF a>0 AND dtrc<>0 AND (topmem-a)>0 THEN
BMOVE a,a+dtrc,topmem-a
ENDIF
'          PRINT "(trkp,trkz,topmem,a,e,l):",trc,trkz,topmem,a,a+dtrc,topmem-a
ENDIF
ELSE
IF ((trkmem(trkz)+glen*8)-trkmem(0))>tmlen THEN
notrkmem=TRUE
tcach(trc)=0
ELSE
notrkmem=FALSE
ENDIF
ENDIF
ENDIF
ENDIF
IF notrkmem=TRUE THEN
@tcachclr
ENDIF
RETURN
'
> PROCEDURE trkbutdraw
LOCAL i,a,b,c,h,a2,a3,tx,ty,l,ss,tcs,tce,txtl
trknocach=FALSE
@markhlp
GRAPHMODE 1
DEFLINE 1
IF trkmem(vtrkp)=0 AND trkch(vtrkp)=0 THEN    ! letzter Teil ab and neu
vtrkp=trkz
ENDIF
IF trkch(trkp)>0 AND trkp>0 THEN
IF maxcol=2 THEN
DEFFILL 0,1,0
ELSE
DEFFILL 8,1,8
ENDIF
IF trkp=vtrkp THEN
IF maxcol=2 THEN
DEFLINE 4
COLOR 1
ELSE
COLOR 2
ENDIF
IF hardopen=FALSE THEN
@opentrk2
ENDIF
ELSE
COLOR 1
ENDIF
tx=tr_x+dix
ty=(trkch(trkp)-trkvz-1)*(trhb+trhd)+trhs
trkx(trkp)=tx
trkb(trkp)=tr_b
tx=tx+xd
ty=ty+yd
IF tncom=FALSE THEN
a$=trkfn$(trkp)
ELSE
IF trkcom$(trkp)<>"" THEN
a$=trkcom$(trkp)
ELSE
a$=trkfn$(trkp)
ENDIF
ENDIF
IF trkch(trkp)>0 AND trkp>0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
PBOX tx,ty,tx+tr_b,ty+trhb
BOX tx,ty,tx+tr_b,ty+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
DEFLINE 1
l=trkend(trkp)-trkstrt(trkp)
a=trkstrt(trkp)
b=trkend(trkp)
c=b-a
c=INT((c/thz/mbit*1000))
glen=INT((c*trxstp/tv))+1              ! Gesamt-Pixelzahl
ss=trktime(trkp)/mbit/thz*1000
tcs=0
IF ss<toffs2 THEN
tcs=INT((toffs2-ss)/tv*trxstp)                 ! Startpixel
ENDIF
tce=tcs+tr_b-1                   ! Endpixel
IF glen>4 AND tvideo=TRUE THEN
trc=trkp
vcached=cached
IF trc>0 THEN
IF trkg(trc)<>glen OR glen=0 THEN
tcach(trc)=FALSE
ENDIF
cached=tcach(trc)
ELSE
cached=FALSE
ENDIF
@trksprint
IF cached=FALSE THEN
fil$=trkpath$(trkp)
s=RINSTR(fil$,".")
c$=LEFT$(fil$,s)+peak$+CHR$(0)
pbfyes=EXIST(c$)
IF l<=mlen THEN
IF pbfyes=TRUE AND (l/mbit/512)>glen AND glen>0 THEN
@pbfcaching
ELSE
IF (l/mbit/512)>(glen*2) AND glen>0 THEN
@pbfcaching
ELSE
b$=trkpath$(trkp)
b=VARPTR(b$)
h=GEMDOS(61,L:b,0)
a=GEMDOS(66,L:trkstrt(trkp),h,0)
a2=GEMDOS(63,h,L:l,L:meml)
a3=GEMDOS(62,h)
ENDIF
ENDIF
ELSE
IF (l/mbit/512)>glen THEN
@pbfcaching
ELSE
a=trkstrt(trkp)+(l/glen*tcs)
b=trkstrt(trkp)+(l/glen*tce)
a=INT(a/mbit)*mbit
b=INT(b/mbit)*mbit
c=b-a
IF c<mlen THEN
b$=trkpath$(trkp)
i=VARPTR(b$)
h=GEMDOS(61,L:i,0)
v=GEMDOS(66,L:a,h,0)
a2=GEMDOS(63,h,L:c,L:meml)
a3=GEMDOS(62,h)
l=c
tce=tce-tcs
tcs=0
vglen=glen
glen=tce
trknocach=TRUE
trkg(trkp)=glen
ELSE
@pbfcaching
ENDIF
ENDIF
ENDIF
ENDIF
@mcurve(0,l,tr_b-2,trhc-2,tx+1,ty+trht,ty+trhc+trht,tcs,tce,glen-1)
IF trknocach=FALSE THEN
tcach(trc)=cached
cached=vcached
ELSE
trkg(trkp)=vglen
cached=FALSE
glen=0
@trksprint
tcach(trc)=FALSE
trkg(trc)=0
ENDIF
ENDIF
IF trkch(trkp)>0 AND trkp>0 THEN
txtl=INT((tr_b-2)/8)
IF txtl>0 THEN
IF LEN(a$)>txtl THEN
a$=LEFT$(a$,txtl)
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
COLOR 1
GRAPHMODE 1
DEFTEXT 1,0,0,6
TEXT tx+1,ty+7,a$
LINE tx+1,ty+9,tx+1+LEN(a$)*8,ty+9
LINE tx+1+LEN(a$)*8,ty+9,tx+1+LEN(a$)*8,ty+1
DEFTEXT 1,0,0,4
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE openpbf
OPEN "I",#2,c$
pbuf=LOF(#2)
CLOSE #2
nopeakmem=FALSE
IF peakmemda=TRUE THEN
~MFREE(peakmem%)
ENDIF
peakmem%=@malloc(pbuf,1)     ! Peak-Buffer
IF peakmem%<=0 THEN
nopeakmem=TRUE
ELSE
peakmemda=TRUE
ENDIF
RETURN
'
> PROCEDURE workpbf
LOCAL adr,s1,s2,m,c,c2,stp,z,vi,j,i,i2
IF mlen>=pbuf AND nopeakmem=FALSE AND pbuf>0 THEN
pbm$=c$+CHR$(0)
tma=trkmem(trkp)
a=trkstrt(trkp)
b=trkend(trkp)
IF a=0 THEN
s1=a
ELSE
s1=INT(pbuf/(trklen(trkp)/a))
s1=INT(s1/8)*8
ENDIF
IF b=trklen(trkp) THEN
s2=pbuf
ELSE
s2=INT(pbuf/(trklen(trkp)/b))
s2=INT(s2/8)*8
ENDIF
m=s2-s1
IF pmemisda=FALSE THEN
handle=GEMDOS(61,L:VARPTR(pbm$),0)
~GEMDOS(66,L:s1,handle,0)     ! SEEK
~GEMDOS(63,handle,L:m,L:peakmem%)
~GEMDOS(62,handle)
ENDIF
s1=s1+peakmem%
s2=s2+peakmem%
c=(b-a)/mbit/thz*1000
c2=INT((c*trxstp/tv))              ! Gesamt-Pixelzahl
IF c2>0 THEN
stp=(s2-s1)/c2
ELSE
stp=0
ENDIF
IF stp<=0 THEN
stp=8
ENDIF
pbufda=FALSE
cached=TRUE
werte=c2
z=0
IF werte>0 THEN
vi=peakmem%
max=0
FOR j=1 TO werte
@busy_mouse
i=INT(vi/8)*8           !neu
i2=INT((vi+stp)/8)*8           !neu
IF i2=i THEN
i2=i+8
ENDIF
adr=XBIOS(xbs,301,L:i,L:i2)
a=DPEEK(adr)
am=DPEEK(adr+2)
IF a>max THEN
max=a
ENDIF
IF am>max THEN
max=am
ENDIF
DPOKE (tma+z*8+4),a
DPOKE (tma+z*8+6),am
a=DPEEK(adr+4)
am=DPEEK(adr+6)
IF a>max THEN
max=a
ENDIF
IF am>max THEN
max=am
ENDIF
DPOKE (tma+z*8),a
DPOKE (tma+z*8+2),am
vi=vi+stp
INC z
NEXT j
trkmax(trkp)=max
tcach(trkp)=TRUE
trkg(trkp)=werte+1
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
RETURN
'
> PROCEDURE pbfcaching
IF pbfyes=TRUE THEN
pmemisda=FALSE
@openpbf
@workpbf
ELSE
@makepbf
IF nomem=FALSE THEN
@workpbf
pmemisda=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE makepbf
LOCAL m2,l,z,m,bw,v,handle,anf,anf2,fg
fg=2048
IF dig24=TRUE THEN
fg=3072
ENDIF
nopeakmem=FALSE
'  head=20
z=head
OPEN "I",#6,fil$
l=LOF(#6)
CLOSE #6
pbuf=INT(l/(fg/8))
pbuf=pbuf+sector
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>(pbuf+sector) THEN
IF peakmemda=TRUE THEN
~MFREE(peakmem%)
ENDIF
peakmem%=@malloc(pbuf,1)     ! Peak-Buffer
IF peakmem%<=0 THEN
nopeakmem=TRUE
ELSE
peakmemda=TRUE
ENDIF
IF nopeakmem=FALSE THEN
anf=peakmem%
anf2=anf
a$=fil$+CHR$(0)
handle=GEMDOS(61,L:VARPTR(a$),0)
m2=INT(mlen/fg)*fg
v=GEMDOS(66,L:z,handle,0)     ! SEEK
REPEAT
@busy_mouse
IF (l-m2)>=0 THEN
m=m2
ELSE
m=l
ENDIF
bw=GEMDOS(63,handle,L:m,L:meml)
l=l-m
i=meml
stp=fg
'
IF fileart=3 THEN
@maschruf28(meml,m)
ENDIF
'
FOR j=meml TO meml+m STEP fg
i=j
@maschruf31
DPOKE anf2,a
DPOKE anf2+2,am
i=j+mbit/2
@maschruf31
DPOKE anf2+4,a
DPOKE anf2+6,am
anf2=anf2+8
NEXT j
UNTIL l=0
~GEMDOS(62,handle)
s=RINSTR(fil$,".")
b$=LEFT$(fil$,s)+peak$+CHR$(0)
handle=GEMDOS(60,L:VARPTR(b$),0)
m=anf2-anf
bw=GEMDOS(64,handle,L:m,L:anf)
~GEMDOS(62,handle)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pbuf=m
pmemisda=TRUE
ENDIF
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE oldtrkbox
LOCAL a,b,vcx,vcy,vcb
IF trkp>0 AND trkch(trkp)>0 THEN                  ! rote Umrandung vom vorherigen Kasten entfernen
vcx=xd+trkx(trkp)
vcy=yd+(trkch(trkp)-trkvz-1)*(trhb+trhd)+trhs
vcb=trkb(trkp)
a=trktime(trkp)/mbit/thz*1000
b=a+((trkend(trkp)-trkstrt(trkp))/mbit/thz*1000)
IF a<(toffs2+toffs3) AND b>toffs2 AND trkch(trkp)>trkvz AND trkch(trkp)<(trkvz+5) THEN
GRAPHMODE 1
COLOR 1
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
BOX vcx,vcy,vcx+vcb,vcy+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
RETURN
'
> PROCEDURE searchtrak
LOCAL a,b
@markhlp
@mouse(x,y,v)
tfound=FALSE
IF x>=xd+dix AND x<=xd+dix+dig AND y>=yd+trhs AND y<=yd+trhs+4*(trhb+trhd) THEN
FOR i=1 TO trkz
cx=xd+trkx(i)
cy=yd+(trkch(i)-trkvz-1)*(trhb+trhd)+trhs
cb=trkb(i)
a=trktime(i)/mbit/thz*1000
b=a+((trkend(i)-trkstrt(i))/mbit/thz*1000)
IF x>=cx AND x<=cx+cb AND y>=cy AND y<=cy+trhb AND trkch(i)>0 AND a<(toffs2+toffs3) AND b>toffs2 THEN
tfound=TRUE
ENDIF
EXIT IF tfound=TRUE
NEXT i
IF tfound=TRUE THEN
@oldtrkbox
trkp=i
IF maxcol=2 THEN                                  ! ab hier rote Umrandung fÅr neuen Kasten zeichnen
COLOR 1
DEFLINE 4
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
BOX cx,cy,cx+cb,cy+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
DEFLINE 1
ELSE
COLOR 2
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
BOX cx,cy,cx+cb,cy+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
COLOR 1
@gettrak
ENDIF
ENDIF
RETURN
'
> PROCEDURE trakmoving
LOCAL k,x,v,v2,b,t,a,tf,cv,vx,vmx,xxx,vmy,y2,vy,cyw,xmaxx,c,c2,tstat4,ddd,l
ddd=0
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
~GRAF_MKSTATE(x,v,k,v2)
IF (x>=cx AND x<=cx+cb AND v>=cy AND v<=cy+trhb) THEN
GRAPHMODE 1
~GRAF_MOUSE(256,0)                              ! Hidem
trm2=@rsc_get(cx,cy,cb+1,trhb+1)         ! leere Box
trm1=@rsc_get(cx,cy,cb+1,trhb+1)           ! trm1=Kurveninhalt
IF maxcol=2 THEN
DEFFILL 0,1,0
ELSE
DEFFILL smpblkcol,1,smpblkcol
ENDIF
COLOR 1
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
PBOX cx,cy,cx+cb,cy+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
GRAPHMODE 3
trm2=@rsc_get2(cx,cy,cb+1,trhb+1,trm2)         ! leere Box
@rsc_put(trm1,cx,cy,1)                            ! Kurveninhalt neuzeichnen
@mouse(x,v,k)
vmx=x
vx=x
xxx=cx
vmy=y
vcyw=trkch(atrkp)-trkvz
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
vy=y2
vy2=y
cv=trktime(atrkp)
REPEAT
@mouse(x,y,k)
IF x>xwidth-40 THEN
x=xwidth-40
ENDIF
cyw=trkch(atrkp)-trkvz+INT((y-vmy)/10)
IF cyw<1 THEN
cyw=1
ENDIF
IF cyw>4 THEN
cyw=4
ENDIF
xmaxx=xd+dig+dix
IF (x>=xd+dix AND x<=xmaxx) THEN
IF x<>vx OR cyw<>vcyw THEN
b=x-vmx
c=INT(cv+(tv*(192/trxstp*thz/48000)*b))    ! Start-Position in msec
c=INT(c/mbit)*mbit
c2=trktime(atrkp)
IF c>=0 THEN
IF c2<>c THEN
trktime(atrkp)=c
hsec=INT(trktime(atrkp)/thz/mbit*100)
@htimeset
@textfeld(trksmpte&,a$,1)
ENDIF
IF cyw<>vcyw THEN
vcyw=cyw
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
ENDIF
vxxx=cx+(vx-vmx)
IF vxxx<xd+dix THEN
vxxx=xd+dix
ENDIF
@rsc_put(trm2,vxxx,vy,1)            ! vorher geretteten Inhalt an alte Position zeichnen
xxx=cx+(x-vmx)
bbb=cb+1
xs=0
IF xxx+bbb>xmaxx THEN
bbb=xmaxx-xxx
ENDIF
IF xxx<(xd+dix) THEN
xs=(xd+dix)-xxx
bbb=(cb+1)-xs
xxx=xd+dix
ENDIF
trm2=@rsc_get2(xxx,y2,bbb,trhb+1,trm2)   ! Inhalt der neuen Position retten
@rsc_put2(trm1,xxx,y2,1,xs,bbb)                     ! Inhalt Kurve neuzeichnen
vx=x
vy=y2
vy2=y
ELSE
IF c<0 THEN
c=0
ENDIF
ENDIF
ENDIF
ENDIF
UNTIL k=0
@rsc_put(trm2,xxx,vy,1)
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
a=trkvor(atrkp)
b=trknext(atrkp)
c=trkch(atrkp)
IF a>0 THEN
trknext(a)=b
ENDIF
IF b>0 THEN
trkvor(b)=a
ENDIF
trknext(atrkp)=0
trkvor(atrkp)=0
trkch(atrkp)=vcyw+trkvz
t=0
tf=FALSE
REPEAT
INC t
UNTIL t=trkz OR (trkch(t)=(vcyw+trkvz) AND trkvor(t)=0 AND t<>atrkp)
IF (trkch(t)=(vcyw+trkvz) AND trkvor(t)=0 AND t<>atrkp) THEN
trkpnt(vcyw+trkvz)=t
tf=TRUE
ENDIF
IF tf=FALSE THEN
t=atrkp
trkpnt(vcyw+trkvz)=t
ENDIF
IF a=0 AND c<>(vcyw+trkvz) THEN
trkpnt(c)=b   ! neu
ENDIF
REPEAT
a=trktime(t)
IF a<=trktime(atrkp) THEN
vt=t
t=trknext(t)
ENDIF
UNTIL a>trktime(atrkp) OR t=0
IF t=0 THEN
IF vt<>atrkp THEN
trknext(vt)=atrkp
trkvor(atrkp)=vt
ENDIF
trknext(atrkp)=0
ELSE
a=trkvor(t)
trkvor(atrkp)=a
trknext(atrkp)=t
IF a>0 THEN
trknext(a)=atrkp
ENDIF
trkvor(t)=atrkp
ENDIF
IF trkvor(atrkp)=0 THEN
trkpnt(vcyw+trkvz)=atrkp    ! neu
ENDIF
IF v4=1 OR v4=2 THEN
IF v4=2 THEN
gs=trkvor(atrkp)
IF gs>0 THEN
gs=trktime(gs)+trkend(gs)-trkstrt(gs)
ENDIF
trktime(atrkp)=gs
ELSE
ge=trknext(atrkp)
IF ge>0 THEN
ge=trktime(ge)-(trkend(atrkp)-trkstrt(atrkp))
trktime(atrkp)=ge
ENDIF
ENDIF
REPEAT
UNTIL @mousek=0
ENDIF
@timeline
~MFREE(trm2)
~MFREE(trm1)
@drawbutton(trakclip&)
ENDIF
RETURN
'
> PROCEDURE trakcopydrag
LOCAL k,x,v,v2,b,t,a,tf,cv,vx,vmx,xxx,vmy,y2,vy,cyw,xmaxx,c,c2
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
~GRAF_MKSTATE(x,v,k,v2)
IF (x>=cx AND x<=cx+cb AND v>=cy AND v<=cy+trhb) THEN
GRAPHMODE 1
~GRAF_MOUSE(256,0)                              ! Hidem
trm2=@rsc_get(cx,cy,cb+1,trhb+1)         ! leere Box
trm1=@rsc_get(cx,cy,cb+1,trhb+1)           ! trm1=Kurveninhalt
@rsc_put(trm2,cx,cy,1)
@mouse(x,v,k)
vmx=x
vx=x
xxx=cx
vmy=y
vcyw=trkch(atrkp)-trkvz
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
vy=y2
vy2=y
cv=trktime(atrkp)
tdragm=FALSE
REPEAT
@mouse(x,y,k)
IF x>xwidth-40 THEN
x=xwidth-40
ENDIF
cyw=trkch(atrkp)-trkvz+INT((y-vmy)/10)
IF cyw<1 THEN
cyw=1
ENDIF
IF cyw>4 THEN
cyw=4
ENDIF
xmaxx=xd+dig+dix
IF (x>=xd+dix AND x<=xmaxx) THEN
IF x<>vx OR cyw<>vcyw THEN
b=x-vmx
c=INT(cv+(tv*(192/trxstp*thz/48000)*b))    ! Start-Position in msec
c=INT(c/mbit)*mbit
c2=trktime(atrkp)
IF c>=0 THEN
IF c2<>c THEN
trktime(atrkp)=c
hsec=INT(trktime(atrkp)/thz/mbit*100)
@htimeset
@textfeld(trksmpte&,a$,1)
ENDIF
IF cyw<>vcyw THEN
vcyw=cyw
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
ENDIF
vxxx=cx+(vx-vmx)
IF vxxx<xd+dix THEN
vxxx=xd+dix
ENDIF
@rsc_put(trm2,vxxx,vy,1)            ! vorher geretteten Inhalt an alte Position zeichnen
xxx=cx+(x-vmx)
bbb=cb+1
xs=0
IF xxx+bbb>xmaxx THEN
bbb=xmaxx-xxx
ENDIF
IF xxx<(xd+dix) THEN
xs=(xd+dix)-xxx
bbb=(cb+1)-xs
xxx=xd+dix
ENDIF
trm2=@rsc_get2(xxx,y2,bbb,trhb+1,trm2)   ! Inhalt der neuen Position retten
@rsc_put2(trm1,xxx,y2,1,xs,bbb)                     ! Inhalt Kurve neuzeichnen
vx=x
vy=y2
vy2=y
ELSE
IF c<0 THEN
c=0
ENDIF
ENDIF
ENDIF
ENDIF
UNTIL k=0
@rsc_put(trm2,xxx,vy,1)
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
@trakmove
IF notrkmov=FALSE THEN
trktime(otrkp)=cv
IF trkpnt(vcyw+trkvz)=0 AND trkvor(atrkp)=0 THEN
trkpnt(vcyw+trkvz)=atrkp
ENDIF
t=trkpnt(vcyw+trkvz)
ELSE
trktime(atrkp)=cv
ENDIF
IF notrkmov=FALSE THEN
REPEAT
a=trktime(t)
IF a<=trktime(atrkp) THEN
vt=t
t=trknext(t)
ENDIF
UNTIL a>trktime(atrkp) OR t=0
IF t=0 THEN
IF vt<>atrkp THEN
trknext(vt)=atrkp
trkvor(atrkp)=vt
ENDIF
trknext(atrkp)=0
ELSE
a=trkvor(t)
trkvor(atrkp)=a
trknext(atrkp)=t
IF a>0 THEN
trknext(a)=atrkp
ENDIF
trkvor(t)=atrkp
ENDIF
ENDIF
IF trkvor(atrkp)=0 THEN
trkpnt(vcyw+trkvz)=atrkp    ! neu
ENDIF
@timeline
~MFREE(trm2)
~MFREE(trm1)
@drawbutton(trakclip&)
ENDIF
RETURN
'
> PROCEDURE trakdrag
LOCAL k,x,v,v2,b,t,a,tf,cv,vx,vmx,xxx,vmy,y2,vy,cyw,xmaxx,c,c2,tstat4,ddd,l
vtdrag=tdrag
IF tdrag2=TRUE THEN
cb=rcb
trhb=rtrhb
cx=rcx
cy=rcy
ENDIF
IF tdrag=FALSE AND trdrag=FALSE THEN
clipart=0
trkcart=0
ENDIF
ddd=0
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
~GRAF_MKSTATE(x,v,k,v4)
IF tdrag=FALSE THEN
tdrag2=FALSE
ENDIF
IF (x>=cx AND x<=cx+cb AND v>=cy AND v<=cy+trhb) OR tdrag2=TRUE THEN
trg2=@rsc_get(cx,cy,cb+1,trhb+1)         ! leere Box
GRAPHMODE 1
~GRAF_MOUSE(256,0)                              ! Hidem
IF tdrag2=FALSE THEN
IF tdbz1=0 THEN
trg1=@rsc_get(cx,cy,cb+1,trhb+1)           ! trg1=Kurveninhalt
trgb1=@rsc_get(cx,cy,cb+1,trhb+1)           ! trg1=Kurveninhalt
tdbz1=1
rcb=cb
rtrhb=trhb
rcx=cx
rcy=cy
ELSE
~MFREE(trg1)
trg1=@rsc_get(cx,cy,cb+1,trhb+1)           ! trg1=Kurveninhalt
ENDIF
ENDIF
trg2=@rsc_get2(cx,cy,cb+1,trhb+1,trg2)         ! leere Box
IF tdrag2=FALSE THEN
@rsc_put(trg2,cx,cy,1)
ENDIF
@mouse(x,v,k)
IF tdrag2=TRUE THEN
vmx=xd+dix+5
cx=vmx-5
ELSE
vmx=x
ENDIF
vx=x
xxx=cx
vmy=y
vcyw=trkch(atrkp)-trkvz
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
vy=y2
vy2=y
IF tdrag2=TRUE THEN
cv=(toffs2/1000*thz*mbit)
tcv2=trktime(atrkp)
ELSE
cv=trktime(atrkp)
ENDIF
tdragm=FALSE
REPEAT
@mouse(x,y,k)
IF x>xwidth-40 THEN
x=xwidth-40
ENDIF
IF tdrag2=TRUE THEN
cyw=1+INT((y-vmy)/10)
ELSE
cyw=trkch(atrkp)-trkvz+INT((y-vmy)/10)
ENDIF
IF tdrag2=TRUE THEN     ! drag2=TRUE bedeutet CLIP-Dragging
tstat4=FALSE           ! tstat4=FALSE bedeutet Rasterung
IF cyw<1 THEN
cyw=1
tstat4=TRUE
ENDIF
IF cyw>4 THEN
cyw=4
ENDIF
ELSE
tstat4=TRUE
ENDIF
xmaxx=xd+dig+dix
IF (x>=xd+dix AND x<=xmaxx) THEN
IF (x<>vx OR (cyw<>vcyw AND tstat4=FALSE) OR (y<>vy2 AND tstat4=TRUE)) THEN
b=x-vmx
c=INT(cv+(tv*(192/trxstp*thz/48000)*b))    ! Start-Position in msec
c=INT(c/mbit)*mbit
c2=trktime(atrkp)
IF c>=0 THEN
IF c2<>c AND tdrag2=TRUE THEN
trktime(atrkp)=c
hsec=INT(trktime(atrkp)/thz/mbit*100)
@htimeset
@textfeld(trksmpte&,a$,1)
ENDIF
IF cyw<>vcyw OR tstat4=TRUE THEN
vcyw=cyw
IF tstat4=TRUE THEN
vcyw=-1
y2=yd+y-vmy+32
IF y2<(yd-20) THEN
y2=yd-20
ENDIF
ELSE
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
ENDIF
ENDIF
vxxx=cx+(vx-vmx)
IF vxxx<xd+dix THEN
vxxx=xd+dix
ENDIF
IF (ddd>0 AND tdrag2=TRUE) OR tdrag2=FALSE THEN
@rsc_put(trg2,vxxx,vy,1)            ! vorher geretteten Inhalt an alte Position zeichnen
ENDIF
IF tdrag2=TRUE THEN
ddd=1
ENDIF
xxx=cx+(x-vmx)
bbb=cb+1
xs=0
IF xxx+bbb>xmaxx THEN
bbb=xmaxx-xxx
ENDIF
IF xxx<(xd+dix) THEN
xs=(xd+dix)-xxx
bbb=(cb+1)-xs
xxx=xd+dix
ENDIF
trg2=@rsc_get2(xxx,y2,bbb,trhb+1,trg2)   ! Inhalt der neuen Position retten
@rsc_put2(trg1,xxx,y2,1,xs,bbb)                     ! Inhalt Kurve neuzeichnen
vx=x
vy=y2
vy2=y
ELSE
IF c<0 THEN
c=0
ENDIF
ENDIF
IF tstat4=TRUE AND tdrag2=FALSE THEN
fobj=OBJC_FIND(zu%,0,10,xxx,y2)
IF fobj=trakclip& THEN
@readbutton(trakclip&)
IF trkp<>0 THEN
IF clipart=0 AND buttflag=0 THEN
@setbutton(trakclip&,1)
ENDIF
IF clipart<>0 AND buttflag=1 AND tdragm=FALSE THEN
@setbutton(trakclip&,0)
PAUSE 2
@setbutton(trakclip&,1)
ENDIF
tdragm=TRUE
ENDIF
ENDIF
IF fobj<>trakclip& AND tdragm=TRUE THEN
tdragm=FALSE
@readbutton(trakclip&)
IF clipart=0 AND buttflag<>0 THEN
@setbutton(trakclip&,0)
ENDIF
IF clipart<>0 AND buttflag<>1 THEN
@setbutton(trakclip&,1)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
UNTIL k=0
@rsc_put(trg2,xxx,vy,1)
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
IF tstat4=TRUE AND tdrag2=FALSE THEN
trktime(atrkp)=cv
IF fobj=trakclip& AND tdragm=TRUE THEN
@setbutton(trakclip&,0)
FOR i=0 TO 2
PAUSE 2
@setbutton(trakclip&,0)
PAUSE 2
@setbutton(trakclip&,1)
NEXT i
merkclip=atrkp
clipart=2
trkcart=5
dvt=cx
ENDIF
IF tdragm=TRUE THEN
tdrag=TRUE
trdrag=FALSE
trdrag2=FALSE
ENDIF
ENDIF
IF tstat4=FALSE AND tdrag2=TRUE THEN
@trakmove
IF notrkmov=FALSE THEN
trktime(otrkp)=tcv2
IF trkpnt(vcyw+trkvz)=0 AND trkvor(atrkp)=0 THEN
trkpnt(vcyw+trkvz)=atrkp
ENDIF
t=trkpnt(vcyw+trkvz)
REPEAT
a=trktime(t)
IF a<=trktime(atrkp) THEN
vt=t
t=trknext(t)
ENDIF
UNTIL a>trktime(atrkp) OR t=0
IF t=0 THEN
IF vt<>atrkp THEN
trknext(vt)=atrkp
trkvor(atrkp)=vt
ENDIF
trknext(atrkp)=0
ELSE
a=trkvor(t)
trkvor(atrkp)=a
trknext(atrkp)=t
IF a>0 THEN
trknext(a)=atrkp
ENDIF
trkvor(t)=atrkp
ENDIF
IF trkvor(atrkp)=0 THEN
trkpnt(vcyw+trkvz)=atrkp    ! neu
ENDIF
ELSE
trktime(atrkp)=cv
ENDIF
ENDIF
IF tstat4=TRUE AND tdrag2=TRUE THEN
trktime(atrkp)=tcv2
ENDIF
@timeline
IF tstat4=TRUE AND tdrag2=FALSE AND fobj=trakclip& AND tdragm=TRUE THEN
l=@rsc_len(cb+1,trhb+1)
IF tdbz1=1 THEN
~MFREE(trgb1)
trgb1=@rsc_get(cx,cy,cb+1,trhb+1)         ! richtige Box -> retten
rcb=cb
rtrhb=trhb
rcx=cx
rcy=cy
i2=trg1
FOR i=trgb1 TO trgb1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
ELSE
'      tdrag=TRUE
'      trdrag=FALSE
'      trdrag2=FALSE
cb=rcb
trhb=rtrhb
cx=rcx
cy=rcy
l=@rsc_len(cb+1,trhb+1)
IF tdbz1=1 THEN
~MFREE(trg1)
trg1=@rsc_get(cx,cy,cb+1,trhb+1)         ! falsche Box -> zurÅckholen
i2=trgb1
FOR i=trg1 TO trg1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
ENDIF
~MFREE(trg2)
@drawbutton(trakclip&)
ENDIF
RETURN
'
> PROCEDURE trakmove
notrkmov=FALSE
IF trkz<lmax3 THEN
otrkp=atrkp
@oldtrkbox
IF trkz>0 THEN
f=0
REPEAT
INC f
UNTIL f=trkz OR trkch(f)=0
IF trkch(f)=0 THEN
trkp=f
ELSE
INC trkz
trkp=trkz
ENDIF
ELSE
INC trkz
trkp=trkz
ENDIF
vtrkp=trkp
atrkp=trkp   ! aktuelles File
'
trkch(trkp)=vcyw+trkvz
trkfn$(trkp)=trkfn$(otrkp)
trkcom$(trkp)=""
trkpath$(trkp)=trkpath$(otrkp)
@searchcom(trkp)
trkstrt(trkp)=trkstrt(otrkp)
trkend(trkp)=trkend(otrkp)
trksrate(trkp)=trksrate(otrkp)
trktri(trkp)=trktri(otrkp)
trkloop(trkp)=trkloop(otrkp)
trklen(trkp)=trklen(otrkp)
trktime(trkp)=trktime(otrkp)
trkmem(trkp)=0
trkg(trkp)=0
tcach(trkp)=FALSE
'    @trkbutcalc2
'    @trkbutcalc1
'    @trkbutdraw
@opentrk
ELSE
@alerts(28)
notrkmov=TRUE
ENDIF
RETURN
'
> PROCEDURE trkend
.| Glob. Var.: trkp#,sectpos#,hsec#,flen#,vhz#,trakend&,a$
.| Felder    : trkend#()
.| Ruft auf  : htimeset,textfeld,setbutton,trkbutcalc1
.| Aufruf in : do_trakker-1,
IF trkp>0 AND trkch(trkp)<>0 THEN
trkend(trkp)=sectpos
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(trakend&,a$,1)
IF sectpos<trkstrt(trkp) THEN
trkstrt(trkp)=sectpos
@textfeld(trakstrt&,a$,1)
ENDIF
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz/mbit*100)
@htimeset
@textfeld(trakdur&,a$,1)
@setbutton(trakend&,0)
@trkbutcalc1
'  @textfeld(trkbut,butnam$,1)
'  @trkbutdraw
@timeline
ELSE
@setbutton(trakend&,0)
ENDIF
RETURN
'
> PROCEDURE trkanf
.| Glob. Var.: handle#,pa$,sectpos#,hsec#,flen#,vhz#,traktime&,a$,playpos#
.|     g#,trakanf&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_trakker-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=0
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
playpos=sectpos
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=0
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
IF handle<0 THEN
@alerts(34)
handle=0
ENDIF
@setbutton(trakanf&,0)
RETURN
'
> PROCEDURE trkfull
.| Glob. Var.: handle#,pa$,sectpos#,sectall#,hsec#,flen#,vhz#,traktime&,a$
.|     playpos#,g#,trakfull&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_trakker-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=sectall
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
playpos=sectpos
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=sectall
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
IF handle<0 THEN
@alerts(34)
handle=0
ENDIF
@setbutton(trakfull&,0)
RETURN
'
> PROCEDURE opentrk
atrkp=trkp   ! aktuelles File
@opentrk2
RETURN
'
> PROCEDURE opentrk2
.| Glob. Var.: t#,lmax3#,a#,toffs2#,j#,b#,trkp#,hardopen#,handle#,playstop#
.|     pat$,vhz#,pa$,f#,sectors#,flen#,sectall#,sectpos#,hsec#,trakstrt&,a$
.|     s#,trakend&,traklen&,trksmpte&,g#,g2#,traktime&,trakname&
.| Felder    : trkch#(),trkpnt#(),trknext#(),trkpath$(),trksrate#()
.|     trkstrt#(),trkend#(),trklen#(),trktime#(),trkfn$()
.| Ruft auf  : htimeset,textfeld
.| Aufruf in : trakload-1,trktowork-1,
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF trkpath$(trkp)<>"MEMORY" AND trkpath$(trkp)<>"" THEN
pat$=trkpath$(trkp)
tblkin$=pat$
'    vhz=trksrate(trkp)
'    hz=vhz
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pa$=pat$+CHR$(0)
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
sectors=f
sectall=sectors
sectpos=trkstrt(trkp)
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(trakstrt&,a$,1)
s=trkend(trkp)
hsec=INT(s/thz/mbit*100)
@htimeset
@textfeld(trakend&,a$,1)
hsec=INT((trkend(trkp)-sectpos)/thz/mbit*100)
@htimeset
@textfeld(trakdur&,a$,1)
s=trklen(trkp)
hsec=INT(s/thz/mbit*100)
@htimeset
@textfeld(traklen&,a$,1)
hsec=INT(trktime(trkp)/thz/mbit*100)
@htimeset
@textfeld(trksmpte&,a$,1)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=LEFT$(pat$+SPACE$(12),12)+CHR$(0)
hardopen=TRUE
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
a$=LEFT$(trkfn$(trkp)+SPACE$(12),12)
@textfeld(trakname&,a$,1)
ENDIF
RETURN
'
> PROCEDURE arrsmpr
.| Glob. Var.: obj#,arrsmpr1&,arrsmpr2&,arrsmpr3&,arrsmpr4&,pbz#,mrkobj#
.|     vorvornr#,vornr#,nr#,resample&,zu%,versatz#,a$,string#,rsmptxt1&,it#
.|     rsmptxt2&,resorig#,db$,restxt&,resoth#,resother&,popup&,zuadr#,x#,y#
.|     v3#,buttadr#,but#,resl1&,resl2&,resl3&,resr1&,resr2&,resr3&,objadr#
.|     objflag#,res32&,res44&,res48&,helprsmp&,resok&,resexit&,noresok#,a#
.|     edit_obj&
.| Felder    : arrpath$(),arrsrate#()
.| Ruft auf  : xrsrc_gaddr,rsc_draw,editfeld,textfeld,rsc_do,mouse,setbutton
.|     resl,resr,resoth32,resoth44,resoth48,helptxt,editread,restaura2
.|     arrnrset
.| Aufruf in : do_arrange-1,
LOCAL i,j
IF obj=arrsmpr1& THEN
i=1
ENDIF
IF obj=arrsmpr2& THEN
i=2
ENDIF
IF obj=arrsmpr3& THEN
i=3
ENDIF
IF obj=arrsmpr4& THEN
i=4
ENDIF
IF arrpath$(pbz+i)<>"" THEN
mrkobj=obj
vorvornr=vornr
vornr=nr
'    @rsc_back(nr)
nr=resample&
~@xrsrc_gaddr(0,resample&,zu%)
zuadr=zu%
versatz=1
a$="SAMPLERATE"
string=LPEEK(LPEEK(zu%+24*rsmptxt1&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
a$=" NEW RATE "
string=LPEEK(LPEEK(zu%+24*rsmptxt2&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
@hidetree2(adjresmp&,TRUE)
@hidetree2(resmpsec&,TRUE)
@hidetree2(resmplen&,TRUE)
@hidetree2(resmpfac&,TRUE)
@rsc_draw(nr,0)
resorig=INT(arrsrate(pbz+i)/100)
db$=RIGHT$("000"+STR$(resorig),3)+CHR$(0)
@editfeld(restxt&,db$)
resoth=44.1
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1 AND obj<>restxt&
edit_obj&=0
IF obj=resl1& OR obj=resl2& OR obj=resl3& OR obj=resr1& OR obj=resr2& OR obj=resr3& THEN
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=resl1& OR obj=resl2& OR obj=resl3& THEN
@resl
ENDIF
IF obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@resr
ENDIF
IF obj=res32& THEN
@resoth32
ENDIF
IF obj=res44& THEN
@resoth44
ENDIF
IF obj=res48& THEN
@resoth48
ENDIF
IF obj=helprsmp& THEN
@helptxt("ARRANGE-SAMPLERATE")
ENDIF
UNTIL obj=resok& OR obj=resexit&
IF obj=resok& THEN
@editread(resother&)
noresok=FALSE
ENDIF
@setbutton(obj,0)
UNTIL (obj=resok& AND noresok=FALSE) OR obj=resexit&
IF obj=resok& AND noresok=FALSE THEN
resoth=VAL(a$)*1000
arrsrate(pbz+i)=resoth
ENDIF
@hidetree2(adjresmp&,FALSE)
@hidetree2(resmpsec&,FALSE)
@hidetree2(resmplen&,FALSE)
@hidetree2(resmpfac&,FALSE)
@restaura2
~@xrsrc_gaddr(0,resample&,zu%)
a$="RESAMPLING"
string=LPEEK(LPEEK(zu%+24*rsmptxt1&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
a$="CONVERT TO"
string=LPEEK(LPEEK(zu%+24*rsmptxt2&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
vornr=vorvornr
@setbutton(mrkobj,0)
@arrnrset
ELSE
@setbutton(obj,0)
ENDIF
obj=0
edit_obj&=0
RETURN
'
> PROCEDURE arrstrt
.| Glob. Var.: handle#,pa$,sectpos#,hsec#,flen#,vhz#,playlen&,a$,playpos#,g#
.|     arrstrt&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_arrange-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=0
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
playpos=sectpos
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=0
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
IF handle<0 THEN
@alerts(34)
handle=0
ENDIF
@setbutton(arrstrt&,0)
RETURN
'
> PROCEDURE arrend
.| Glob. Var.: handle#,pa$,sectpos#,sectall#,hsec#,flen#,vhz#,playlen&,a$
.|     playpos#,g#,arrend&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_arrange-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=sectall
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
playpos=sectpos
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=sectall
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
IF handle<0 THEN
@alerts(34)
handle=0
ENDIF
@setbutton(arrend&,0)
RETURN
'
> PROCEDURE dragxygrenz(xd1,xd2,yd1,yd2,bd,hd)
IF v<xd+xd1 THEN
v=xd+xd1
ENDIF
IF v>xd+xd2 THEN
v=xd+xd2
ENDIF
IF v2<yd+yd1 THEN
v2=yd+yd1
ENDIF
IF v2>yd+yd2 THEN
v2=yd+yd2
ENDIF
IF v>xwidth-bd THEN
v=xwidth-bd
ENDIF
IF v2>ywidth-hd THEN
v2=ywidth-hd
ENDIF
IF v<bd THEN
v=bd
ENDIF
IF v2<hd THEN
v2=hd
ENDIF
RETURN
'
> PROCEDURE arrblkset
IF hardopen=TRUE THEN
IF arrpath$(pbz+hardtype)<>"MEMORY" AND arrpath$(pbz+hardtype)<>"" THEN
pat$=arrpath$(pbz+hardtype)
IF EXIST(pat$)=TRUE THEN
tblkin$=pat$
a=RINSTR(tblkin$,".")
b$=LEFT$(tblkin$,a)+inf$
IF EXIST(b$) THEN
OPEN "I",#2,b$
@loadloops(TRUE)
CLOSE #2
@edmfind
IF edmfind=TRUE THEN
IF bloops%(edsms,1)<>-1 AND bloops%(edsms,2)<>-1 THEN
sectpos=bloops%(edsms,2)*mbit
@hardend
sectpos=bloops%(edsms,1)*mbit
@hardstrt
ENDIF
ENDIF
ELSE
@alerts(27)
@setbutton(obj,0)
ENDIF
ENDIF
ENDIF
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE arrtowork
.| Glob. Var.: spring#,obj#,arrm1&,hardtype#,arrherr#,pbz#,arrm2&,arrm3&
.|     arrm4&,hardopen#,handle#,playstop#,pat$,vhz#,arrz#,pa$,f#,sectors#
.|     flen#,sectall#,sectpos#,g#,g2#,hsec#,playlen&,a$,playname&
.| Felder    : arrpath$(),arrsrate#(),arrstrt#(),arrfn$()
.| Ruft auf  : dragging1,htimeset,textfeld
.| Aufruf in : do_arrange-1,dragging2-1,
IF obj=arrm1& THEN
hardtype=1
arrherr=pbz+1
ENDIF
IF obj=arrm2& THEN
hardtype=2
arrherr=pbz+2
ENDIF
IF obj=arrm3& THEN
hardtype=3
arrherr=pbz+3
ENDIF
IF obj=arrm4& THEN
hardtype=4
arrherr=pbz+4
ENDIF
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF arrpath$(pbz+hardtype)<>"MEMORY" AND arrpath$(pbz+hardtype)<>"" THEN
pat$=arrpath$(pbz+hardtype)
IF EXIST(pat$)=TRUE THEN
vhz=arrsrate(pbz+hardtype)
arrz=hardtype
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pa$=pat$+CHR$(0)
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
sectors=f
sectall=sectors
sectpos=arrstrt(pbz+hardtype)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=LEFT$(pat$+SPACE$(12),12)+CHR$(0)
hardopen=TRUE
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
a$=LEFT$(arrfn$(pbz+hardtype)+SPACE$(12),12)
@textfeld(playname&,a$,1)
ENDIF
ENDIF
IF spring=FALSE THEN
@arrdragin
ENDIF
RETURN
'
> PROCEDURE copytoarr
.| Glob. Var.: lmax2#,sms#,sme#,virtual#,c1#,c2#,flen#,vmem#,path$,hz#
.|     sloop#,sret#,smpnam$,i$,coptotxt&,g#,coptoarr&
.| Felder    : arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrpath$()
.|     arrsrate#(),arrloop#(),arrtri#()
.| Ruft auf  : blocklook,textfeld,rsc_alert,setbutton
.| Aufruf in : do_smpedit-1,
LOCAL i
i=0
REPEAT
INC i
UNTIL i=lmax2 OR arrfn$(i)=""
IF arrfn$(i)="" THEN
@blocklook
IF sms<>0 THEN
IF virtual=FALSE THEN
arrstrt(i)=c1
arrend(i)=c2
arrlen(i)=c2-c1
arrpath$(i)="MEMORY"
ELSE
arrstrt(i)=c1
arrend(i)=c2
arrlen(i)=vmem
arrpath$(i)=path$
ENDIF
arrsrate(i)=hz
arrloop(i)=sloop
arrtri(i)=sret
IF smpnam$<>"" THEN
arrfn$(i)=smpnam$
ELSE
arrfn$(i)="MEMORY"
ENDIF
i$=RIGHT$("  "+STR$(i),3)+CHR$(0)
'      @textfeld(coptotxt&,i$,1)
ELSE
@alerts(16)
ENDIF
ELSE
@alerts(28)
ENDIF
'  @setbutton(coptoarr&,0)
RETURN
'
> PROCEDURE arrtristate
.| Glob. Var.: obj#,arrtri1&,z#,arrtri2&,arrtri3&,arrtri4&,tri#,pbz#,nr#
.|     realtime#
.| Felder    : arrtri#()
.| Ruft auf  : rsc_tristate,mousek,arrnrset
.| Aufruf in : do_arrange-1,
IF obj=arrtri1& THEN
z=1
ENDIF
IF obj=arrtri2& THEN
z=2
ENDIF
IF obj=arrtri3& THEN
z=3
ENDIF
IF obj=arrtri4& THEN
z=4
ENDIF
tri=arrtri(pbz+z)
@rsc_tristate(nr,obj)
REPEAT
UNTIL @mousek=0
arrtri(pbz+z)=tri
RETURN
'
> PROCEDURE arrmidi
.| Glob. Var.: mrkch#,ch#,mrknote#,note#,obj#,arrnote1&,arrch1&,arrmz#
.|     arrnote2&,arrch2&,arrnote3&,arrch3&,arrnote4&,arrch4&,z#,pbz#,ch$
.|     midiwort#,db$
.| Felder    : arrmidi#()
.| Ruft auf  : midi,textfeld
.| Aufruf in : do_arrange-1,
mrkch=ch
mrknote=note
IF obj=arrnote1& OR obj=arrch1& THEN
arrmz=1
ENDIF
IF obj=arrnote2& OR obj=arrch2& THEN
arrmz=2
ENDIF
IF obj=arrnote3& OR obj=arrch3& THEN
arrmz=3
ENDIF
IF obj=arrnote4& OR obj=arrch4& THEN
arrmz=4
ENDIF
z=arrmidi(pbz+arrmz)
note=(z AND 255)
ch=INT(z/256)+1
@midi
ch$=RIGHT$(" "+STR$(ch),2)+CHR$(0)
arrmidi(pbz+arrmz)=midiwort
IF arrmz=1 THEN
@textfeld(arrch1&,ch$,1)
@textfeld(arrnote1&,db$,1)
ENDIF
IF arrmz=2 THEN
@textfeld(arrch2&,ch$,1)
@textfeld(arrnote2&,db$,1)
ENDIF
IF arrmz=3 THEN
@textfeld(arrch3&,ch$,1)
@textfeld(arrnote3&,db$,1)
ENDIF
IF arrmz=4 THEN
@textfeld(arrch4&,ch$,1)
@textfeld(arrnote4&,db$,1)
ENDIF
ch=mrkch
note=mrknote
RETURN
'
> PROCEDURE arrmidplay
.| Glob. Var.: a#,meml#,b#,memh#,sret#,c#,adm#,ad#,arrmidi&
.| Ruft auf  : wait,analog,maschruf18b,digin,digital,setbutton
.| Aufruf in : do_arrange-1,
@wait
a=meml
b=memh
IF sret=1 THEN
c=a
a=b-mbit
b=c
ENDIF
adm=ad
IF adm=0 THEN
@analog
ENDIF
IF (sret=0 OR sret=2) AND a<b THEN
@maschruf18b
@digin
ENDIF
IF sret=1 AND a>b THEN
@maschruf18b
@digin
ENDIF
IF adm=0 THEN
@digital
ENDIF
@setbutton(arrmidi&,0)
RETURN
'
> PROCEDURE arrdel
.| Glob. Var.: obj#,arrdel1&,arrdel2&,arrdel3&,arrdel4&,pbz#,a$,a2$,a3$,a4$
.|     tri#,arrsmpr1&,arrch1&,arrnote1&,arrtri1&,arrmem1&,spur1&,hardst1&
.|     harde1&,hardlen1&,arrloop1&,nr#,arrsmpr2&,arrch2&,arrnote2&,arrtri2&
.|     arrmem2&,spur2&,hardst2&,harde2&,hardlen2&,arrloop2&,arrsmpr3&
.|     arrch3&,arrnote3&,arrtri3&,arrmem3&,spur3&,hardst3&,harde3&,hardlen3&
.|     arrloop3&,arrsmpr4&,arrch4&,arrnote4&,arrtri4&,arrmem4&,spur4&
.|     hardst4&,harde4&,hardlen4&,arrloop4&,realtime#
.| Felder    : arrfn$(),arrpath$(),arrstrt#(),arrend#(),arrlen#(),arrloop#()
.|     arrtri#(),arrsrate#()
.| Ruft auf  : textfeld,setbutton,rsc_tristate2,arrnrset
.| Aufruf in : do_arrange-1,
LOCAL z,i
IF obj=arrdel1& THEN
z=1
ENDIF
IF obj=arrdel2& THEN
z=2
ENDIF
IF obj=arrdel3& THEN
z=3
ENDIF
IF obj=arrdel4& THEN
z=4
ENDIF
IF arrherr=pbz+z THEN
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
sectors=0
sectpos=0
sectall=0
ENDIF
ENDIF
arrfn$(pbz+z)=""
arrpath$(pbz+z)=""
arrstrt(pbz+z)=0
arrend(pbz+z)=0
arrlen(pbz+z)=0
arrloop(pbz+z)=0
arrtri(pbz+z)=0
arrsrate(pbz+z)=0
IF arrherr=pbz+z THEN
arrherr=0
ENDIF
hsec=0
@htimeset
a2$=a$
a$="            "+CHR$(0)
a3$=" "+CHR$(0)
a4$=SPACE$(4)+CHR$(0)
tri=0
IF z=1 THEN
@textfeld(arrsmpr1&,a4$,1)
@setbutton(arrch1&,0)
@setbutton(arrnote1&,0)
@setbutton(arrtri1&,0)
@textfeld(arrmem1&,a3$,1)
@textfeld(spur1&,a$,1)
@textfeld(hardst1&,a2$,1)
@textfeld(harde1&,a2$,1)
@textfeld(hardlen1&,a2$,1)
@setbutton(arrloop1&,0)
@rsc_tristate2(nr,arrtri1&)
ENDIF
IF z=2 THEN
@textfeld(arrsmpr2&,a4$,1)
@setbutton(arrch2&,0)
@setbutton(arrnote2&,0)
@setbutton(arrtri2&,0)
@textfeld(arrmem2&,a3$,1)
@textfeld(spur2&,a$,1)
@textfeld(hardst2&,a2$,1)
@textfeld(harde2&,a2$,1)
@textfeld(hardlen2&,a2$,1)
@setbutton(arrloop2&,0)
@rsc_tristate2(nr,arrtri2&)
ENDIF
IF z=3 THEN
@textfeld(arrsmpr3&,a4$,1)
@setbutton(arrch3&,0)
@setbutton(arrnote3&,0)
@setbutton(arrtri3&,0)
@textfeld(arrmem3&,a3$,1)
@textfeld(spur3&,a$,1)
@textfeld(hardst3&,a2$,1)
@textfeld(harde3&,a2$,1)
@textfeld(hardlen3&,a2$,1)
@setbutton(arrloop3&,0)
@rsc_tristate2(nr,arrtri3&)
ENDIF
IF z=4 THEN
@textfeld(arrsmpr4&,a4$,1)
@setbutton(arrch4&,0)
@setbutton(arrnote4&,0)
@setbutton(arrtri4&,0)
@textfeld(arrmem4&,a3$,1)
@textfeld(spur4&,a$,1)
@textfeld(hardst4&,a2$,1)
@textfeld(harde4&,a2$,1)
@textfeld(hardlen4&,a2$,1)
@setbutton(arrloop4&,0)
@rsc_tristate2(nr,arrtri4&)
ENDIF
i=arrherr-pbz
IF i>0 AND i<5 AND arrherr<>0 THEN
SELECT i
CASE 1
@setbutton(arrm1&,1)
CASE 2
@setbutton(arrm2&,1)
CASE 3
@setbutton(arrm3&,1)
CASE 4
@setbutton(arrm4&,1)
ENDSELECT
ENDIF
@setbutton(obj,0)
IF adrag=TRUE AND arrcwert>0 AND arrcwert<=lmax2 THEN
IF arrpath$(arrcwert)="" THEN
adrag=FALSE
@setbutton(arrclip&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE arrinsdrt
.| Glob. Var.: arrherr#,lmax2#,arrins&
.| Felder    : arrpath$(),arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#()
.| Ruft auf  : busy_mouse,arrnrset,hardwahl,setbutton
.| Aufruf in : do_arrange-1,
LOCAL s,i,a1,a2,g
IF arrherr<>0 THEN
s=arrherr
a1=0
a2=0
IF s<lmax2 THEN
i=lmax2+1
@busy_mouse
REPEAT
DEC i
UNTIL arrpath$(i)<>"" OR i=s
IF arrpath$(i)<>"" THEN
a2=i
ENDIF
IF a2=0 THEN
@alerts(35)
ENDIF
IF a2=lmax2 THEN
@alerts(36)
ENDIF
IF a2<>0 AND a2<>lmax2 THEN
i=s-1
REPEAT
INC i
UNTIL arrpath$(i)<>"" OR i=lmax2
IF arrpath$(i)<>"" THEN
a1=i
ENDIF
FOR i=a2 TO a1 STEP -1
arrpath$(i+1)=arrpath$(i)
arrfn$(i+1)=arrfn$(i)
arrstrt(i+1)=arrstrt(i)
arrend(i+1)=arrend(i)
arrlen(i+1)=arrlen(i)
arrmidi(i+1)=arrmidi(i)
arrloop(i+1)=arrloop(i)
arrtri(i+1)=arrtri(i)
arrsrate(i+1)=arrsrate(i)
NEXT i
arrpath$(a1)=""
arrfn$(a1)=""
arrstrt(a1)=0
arrend(a1)=0
arrlen(a1)=0
arrmidi(a1)=0
arrloop(a1)=0
arrtri(a1)=0
arrsrate(a1)=0
@arrnrset
ENDIF
ENDIF
ELSE
@hardwahl
ENDIF
@setbutton(arrins&,0)
IF adrag=TRUE AND arrcwert>0 AND arrcwert<=lmax2 THEN
IF arrpath$(arrcwert)="" THEN
adrag=FALSE
@setbutton(arrclip&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE arrdelete
.| Glob. Var.: arrherr#,lmax2#,arrdel&
.| Felder    : arrpath$(),arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#()
.| Ruft auf  : busy_mouse,arrnrset,hardwahl,setbutton
.| Aufruf in : do_arrange-1,
LOCAL s,i,a1,a2
IF arrherr<>0 THEN
s=arrherr
a1=0
a2=0
arrpath$(s)=""
arrfn$(s)=""
arrstrt(s)=0
arrend(s)=0
arrlen(s)=0
arrmidi(s)=0
arrloop(s)=0
arrtri(s)=0
arrsrate(s)=0
IF s<lmax2 THEN
i=s
@busy_mouse
REPEAT
INC i
UNTIL arrpath$(i)<>"" OR i=lmax2
IF arrpath$(i)<>"" THEN
a1=i
ENDIF
IF a1<>0 THEN
i=lmax2+1
REPEAT
DEC i
UNTIL arrpath$(i)<>"" OR i=1
IF arrpath$(i)<>"" THEN
a2=i
ENDIF
FOR i=a1 TO a2
arrpath$(i-1)=arrpath$(i)
arrfn$(i-1)=arrfn$(i)
arrstrt(i-1)=arrstrt(i)
arrend(i-1)=arrend(i)
arrlen(i-1)=arrlen(i)
arrmidi(i-1)=arrmidi(i)
arrloop(i-1)=arrloop(i)
arrtri(i-1)=arrtri(i)
arrsrate(i-1)=arrsrate(i)
NEXT i
arrpath$(a2)=""
arrfn$(a2)=""
arrstrt(a2)=0
arrend(a2)=0
arrlen(a2)=0
arrmidi(a2)=0
arrloop(a2)=0
arrtri(a2)=0
arrsrate(a2)=0
ENDIF
ENDIF
@arrnrset
ELSE
@hardwahl
ENDIF
@setbutton(arrdel&,0)
IF adrag=TRUE AND arrcwert>0 AND arrcwert<=lmax2 THEN
IF arrpath$(arrcwert)="" THEN
adrag=FALSE
@setbutton(arrclip&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE hardwahl
.| Aufruf in : arrinsert-1,arrdelete-1,arrdelay-1,
LOCAL g
@alerts(38)
RETURN
'
> PROCEDURE trktext
LOCAL to,a
IF obj=trktxt1& THEN
to=1
ENDIF
IF obj=trktxt2& THEN
to=2
ENDIF
IF obj=trktxt3& THEN
to=3
ENDIF
IF obj=trktxt4& THEN
to=4
ENDIF
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=trknamin&
@rsc_draw(nr,0)
@markhlp
a$=trktxt$(trkvz+to)+CHR$(0)
IF LEN(a$)>6 THEN
a$=LEFT$(a$,5)+CHR$(0)
ENDIF
@editfeld(trktxtin&,a$)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>trktxtin&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=trktxhlp& THEN
@helptxt("TRACK-NAME")
ENDIF
UNTIL obj=trktxex& OR obj=trktxok&
IF obj=trktxok& THEN
editread(trktxtin&)
a=INSTR(a$,CHR$(0))
IF a>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
trktxt$(trkvz+to)=a$
ENDIF
@setbutton(obj,0)
@restaura2
IF obj=trktxok& THEN
a$=trktxt$(trkvz+to)+CHR$(0)
@textfeld(mrkobj,a$,1)
ENDIF
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE arrmname
.| Glob. Var.: mrkobj#,obj#,vorvornr#,vornr#,nr#,arrmname&,pbz#,hardtype#,a$
.|     mp$,a#,memname&,popup&,zu%,zuadr#,x#,y#,v3#,edit_obj&,buttadr#,but#
.|     objadr#,objflag#,amhelp&,amexit&,amok&,spur1&,spur2&,spur3&,spur4&
.| Felder    : arrfn$()
.| Ruft auf  : rsc_draw,markhlp,editfeld,rsc_do,xrsrc_gaddr,mouse,helptxt
.|     editread,setbutton,restaura2,textfeld
.| Aufruf in : trakload-1,hardfs-1,
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=arrmname&
@rsc_draw(nr,0)
@markhlp
IF arrfn$(pbz+hardtype)="MEMORY" THEN
a$=mp$+CHR$(0)
a=INSTR(a$,".")
IF a>1 THEN
a$=LEFT$(a$,a-1)+CHR$(0)
ENDIF
ELSE
a$=arrfn$(pbz+hardtype)+CHR$(0)
ENDIF
IF LEN(a$)>12 THEN
a$=LEFT$(a$,12)
ENDIF
@editfeld(memname&,a$)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1 AND obj<>memname&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=amhelp& THEN
@helptxt("ARRANGE-NAME")
ENDIF
UNTIL obj=amexit& OR obj=amok&
IF obj=amok& THEN
editread(memname&)
arrfn$(pbz+hardtype)=a$
ENDIF
@setbutton(obj,0)
@restaura2
IF obj=amok& THEN
a$=LEFT$(arrfn$(pbz+hardtype)+"            ",12)+CHR$(0)
IF hardtype=1 THEN
@textfeld(spur1&,a$,1)
ENDIF
IF hardtype=2 THEN
@textfeld(spur2&,a$,1)
ENDIF
IF hardtype=3 THEN
@textfeld(spur3&,a$,1)
ENDIF
IF hardtype=4 THEN
@textfeld(spur4&,a$,1)
ENDIF
ENDIF
obj=mrkobj
vornr=vorvornr
RETURN
'
> PROCEDURE arrloop
.| Glob. Var.: obj#,arrloop1&,z#,arrloop2&,arrloop3&,arrloop4&,pbz#
.| Felder    : arrloop#()
.| Aufruf in : do_arrange-1,
IF obj=arrloop1& THEN
z=1
ENDIF
IF obj=arrloop2& THEN
z=2
ENDIF
IF obj=arrloop3& THEN
z=3
ENDIF
IF obj=arrloop4& THEN
z=4
ENDIF
IF arrloop(pbz+z)=0 THEN
arrloop(pbz+z)=1
ELSE
arrloop(pbz+z)=0
ENDIF
RETURN
'
> PROCEDURE wait
.| Aufruf in : trkplay-1,arrmidplay-1,arrplay-1,smpplay-1,smpauto-2
.|     smpstart-1,
LOCAL v,v2,v3,v4
REPEAT
~WIND_UPDATE(3)
~GRAF_MKSTATE(v,v2,v3,v4)
~WIND_UPDATE(2)
REPEAT
IF INP?(2)=TRUE THEN
~INP(2)
ENDIF
IF INP?(3)=TRUE THEN
~INP(3)
ENDIF
IF INP?(1)=TRUE THEN
~INP(1)
ENDIF
UNTIL INP?(2)=FALSE AND INP?(1)=FALSE AND INP?(3)=FALSE
UNTIL v3=0 AND v4=0
RETURN
'
> PROCEDURE swtosrate(swhz)
.| Glob. Var.: extclock#
.| Ruft auf  : adlow,admid,adhigh
.| Aufruf in : maschruf18b-3,arrsethz-1,do_arrange-1,do_trakker-1
.|     traksethz-1,trakforw-2,trkbackw-2,trkplay-3,arrplay-3,mforw-2
.|     mbackw-2,make-1,
LOCAL holdhz
holdhz=hz
hz=swhz
@fliphz
@fliphz2
hz=holdhz
RETURN
'
> PROCEDURE hardstrt
.| Glob. Var.: pbz#,arrz#,sectpos#,realtime#,hsec#,flen#,vhz#,hardtype#
.|     hardopen#,hardst1&,a$,hardst2&,hardst3&,hardst4&,hardstrt&
.| Felder    : arrstrt#()
.| Ruft auf  : htimeset,textfeld,arrnrset,setbutton
.| Aufruf in : do_arrange-1,
LOCAL z
z=arrherr-pbz
arrstrt(arrherr)=sectpos
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a2$=a$
IF realtime=FALSE THEN
hsec=INT(arrlen(arrherr)/vhz/mbit*100)
ELSE
hsec=INT((arrend(arrherr)-arrstrt(arrherr))/vhz/mbit*100)
IF hsec<0 THEN
hsec=0
ENDIF
ENDIF
@htimeset
IF z=1 AND hardopen=TRUE THEN
@textfeld(hardst1&,a2$,1)
@textfeld(hardlen1&,a$,1)
ENDIF
IF z=2 AND hardopen=TRUE THEN
@textfeld(hardst2&,a2$,1)
@textfeld(hardlen2&,a$,1)
ENDIF
IF z=3 AND hardopen=TRUE THEN
@textfeld(hardst3&,a2$,1)
@textfeld(hardlen3&,a$,1)
ENDIF
IF z=4 AND hardopen=TRUE THEN
@textfeld(hardst4&,a2$,1)
@textfeld(hardlen4&,a$,1)
ENDIF
@setbutton(hardstrt&,0)
RETURN
'
> PROCEDURE hardend
.| Glob. Var.: pbz#,arrz#,sectpos#,realtime#,hsec#,flen#,vhz#,hardtype#
.|     hardopen#,harde1&,a$,harde2&,harde3&,harde4&,hardend&
.| Felder    : arrend#()
.| Ruft auf  : htimeset,textfeld,arrnrset,setbutton
.| Aufruf in : do_arrange-1,
LOCAL z
z=arrherr-pbz
arrend(arrherr)=sectpos
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a2$=a$
IF realtime=FALSE THEN
hsec=INT(arrlen(arrherr)/vhz/mbit*100)
ELSE
hsec=INT((arrend(arrherr)-arrstrt(arrherr))/vhz/mbit*100)
IF hsec<0 THEN
hsec=0
ENDIF
ENDIF
@htimeset
IF z=1 AND hardopen=TRUE THEN
@textfeld(harde1&,a2$,1)
@textfeld(hardlen1&,a$,1)
ENDIF
IF z=2 AND hardopen=TRUE THEN
@textfeld(harde2&,a2$,1)
@textfeld(hardlen2&,a$,1)
ENDIF
IF z=3 AND hardopen=TRUE THEN
@textfeld(harde3&,a2$,1)
@textfeld(hardlen3&,a$,1)
ENDIF
IF z=4 AND hardopen=TRUE THEN
@textfeld(harde4&,a2$,1)
@textfeld(hardlen4&,a$,1)
ENDIF
@setbutton(hardend&,0)
RETURN
'
> PROCEDURE hardfs
.| Glob. Var.: obj#,hardfs1&,hardtype#,hardfs2&,hardfs3&,hardfs4&,pbz#,a$
.|     playlen&,arrherr#,hardopen#,handle#,playstop#,op$,ext$,fil$,nr#
.|     sectors#,f#,flen#,sectall#,sectpos#,hsec#,vhz#,mz$,a4$,spur1&,nam$
.|     hardlen1&,arrmem1&,arrsmpr1&,spur2&,hardlen2&,arrmem2&,arrsmpr2&
.|     spur3&,hardlen3&,arrmem3&,arrsmpr3&,spur4&,hardlen4&,arrmem4&
.|     arrsmpr4&,arrz#,pat$,pa$,playname&
.| Felder    : arrpath$(),arrfn$(),arrlen#(),arrsrate#()
.| Ruft auf  : textfeld,fileselect,rsc_redraw_obj,busy_mouse,ldhead,htimeset
.|     arrnrset,arrmname,setbutton
.| Aufruf in : do_arrange-1,
IF obj=hardfs1& THEN
hardtype=1
ENDIF
IF obj=hardfs2& THEN
hardtype=2
ENDIF
IF obj=hardfs3& THEN
hardtype=3
ENDIF
IF obj=hardfs4& THEN
hardtype=4
ENDIF
IF arrpath$(pbz+hardtype)="" THEN
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
IF obj=hardfs1& THEN
arrherr=pbz+1
ENDIF
IF obj=hardfs2& THEN
arrherr=pbz+2
ENDIF
IF obj=hardfs3& THEN
arrherr=pbz+3
ENDIF
IF obj=hardfs4& THEN
arrherr=pbz+4
ENDIF
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
@fileselect(op$+"*."+ext$,"","ARRANGE-FILE:")
IF EXIST(fil$) THEN
@busy_mouse
@ldhead
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
sectors=f
sectall=sectors
sectpos=0
hardopen=TRUE
IF realtime=FALSE THEN
hsec=INT(sectall/vhz/mbit*100)
ELSE
hsec=0
ENDIF
@htimeset
mz$="H"+CHR$(0)
a4$=LEFT$(STR$(INT(vhz/100)/10)+SPACE$(4),4)+CHR$(0)
IF obj=hardfs1& THEN
@textfeld(spur1&,nam$+CHR$(0),1)
@textfeld(hardlen1&,a$,1)
@textfeld(arrmem1&,mz$,1)
@textfeld(arrsmpr1&,a4$,1)
ENDIF
IF obj=hardfs2& THEN
@textfeld(spur2&,nam$+CHR$(0),1)
@textfeld(hardlen2&,a$,1)
@textfeld(arrmem2&,mz$,1)
@textfeld(arrsmpr2&,a4$,1)
ENDIF
IF obj=hardfs3& THEN
@textfeld(spur3&,nam$+CHR$(0),1)
@textfeld(hardlen3&,a$,1)
@textfeld(arrmem3&,mz$,1)
@textfeld(arrsmpr3&,a4$,1)
ENDIF
IF obj=hardfs4& THEN
@textfeld(spur4&,nam$+CHR$(0),1)
@textfeld(hardlen4&,a$,1)
@textfeld(arrmem4&,mz$,1)
@textfeld(arrsmpr4&,a4$,1)
ENDIF
arrz=hardtype
pat$=fil$
pa$=pat$+CHR$(0)
arrpath$(pbz+arrz)=fil$+CHR$(0)
arrfn$(pbz+arrz)=nam$
arrlen(pbz+arrz)=sectall
arrsrate(pbz+arrz)=vhz
a$=LEFT$(nam$+SPACE$(12),12)
@textfeld(playname&,a$,1)
@arrnrset
ENDIF
ELSE
@arrmname
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE virtual
.| Glob. Var.: vornr#,nr#,virtual&,vslider&,vslbut&,lslide#,lslideo#,hbg#
.|     hbz#,a$,mt#,vblkmlen&,smplen#,vblkvlen&,vhbldstrt#,tedart#,vseconds&
.|     vsamples&,virtwfile#,virtwork&,virtdir&,obj#,popup&,zu%,zuadr#
.|     vblkstrt&,edit_obj&,next_obj&,buttadr#,but#,objadr#,objflag#,x#,y#
.|     v3#,virthelp&,vlslide&,slflg#,vrslide&,vtedart#,notedok#,virtplay&
.|     handle#,fil$,playpos#,sectors#,hbldlen#,flen#,over#,l#,virtbloc&
.|     virtno&,virtok&,virtex#,blockld#,virtual#
.| Ruft auf  : slidelen,slideinit,rsc_draw,setslide,blockcalc,textfeld
.|     blkart,setbutton,rsc_do,xrsrc_gaddr,mouse,helptxt,slideup,slidedwn
.|     blkproof,maschinit5,digout,maschruf5,restaura2
.| Aufruf in : ldhlp-1,
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
vvtedart=tedart
IF ldtrk=FALSE THEN
vornr=nr
nr=virtual&
@slidelen(vslider&,vslbut&,v,lslide)
hbreit=(lslide/smplen*mt)            ! Einteilungsanzahl
@slideinit2(vslider&,vslbut&,hbreit)
@setslide2(vslider&,vslbut&,lslide,hbz,hbreit)
@rsc_draw(nr,7)
@blockcalc
a$=LEFT$("MEM "+STR$(INT(mt/mbit))+SPACE$(10),14)
@textfeld(vblkmlen&,a$,1)
a$=LEFT$("LEN "+STR$(INT(smplen/mbit))+SPACE$(10),14)
@textfeld(vblkvlen&,a$,1)
ENDIF
vhbldstrt=0
tedart=1
IF ldtrk=FALSE THEN
@blkart
IF tedart=0 THEN
@setbutton(vseconds&,1)
@setbutton(vsamples&,0)
ELSE
@setbutton(vsamples&,1)
@setbutton(vseconds&,0)
ENDIF
IF virtwfile=TRUE THEN
@setbutton(virtwork&,1)
@setbutton(virtdir&,0)
ELSE
@setbutton(virtwork&,0)
@setbutton(virtdir&,1)
ENDIF
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>vblkstrt&
edit_obj&=0
next_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=virthelp& THEN
@helptxt("VIRTUAL")
ENDIF
IF obj=virtwork& THEN
virtwfile=TRUE
ENDIF
IF obj=virtdir& THEN
virtwfile=FALSE
ENDIF
IF obj=vlslide& THEN
@slideup2(vslider&,vslbut&,lslide,1,hbz,slflg)
IF slflg=TRUE THEN
vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
@blkart
ENDIF
@setbutton(vlslide&,0)
ENDIF
IF obj=vrslide& THEN
@slidedwn2(vslider&,vslbut&,lslide,hbreit,1,hbz,slflg)
IF slflg=TRUE THEN
vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
@blkart
ENDIF
@setbutton(vrslide&,0)
ENDIF
IF obj=vsamples& THEN
vtedart=1
IF vtedart<>tedart THEN
@blkproof
IF notedok=FALSE THEN
tedart=vtedart
@blkart
ELSE
@setbutton(vseconds&,1)
@setbutton(vsamples&,0)
ENDIF
ENDIF
ENDIF
IF obj=vseconds& THEN
vtedart=0
IF vtedart<>tedart THEN
@blkproof
IF notedok=FALSE THEN
tedart=vtedart
@blkart
ELSE
@setbutton(vseconds&,0)
@setbutton(vsamples&,1)
ENDIF
ENDIF
ENDIF
IF obj=virtplay& THEN
@blkproof
@blockcalc
a$=fil$+CHR$(0)
handle=GEMDOS(61,L:VARPTR(a$),0)
IF handle>0 THEN
playpos=vhbldstrt
sectors=hbldlen
over=0
@digout(TRUE)
l=0
@maschrufb5
@digout(FALSE)
~GEMDOS(62,handle)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
@setbutton(virtplay&,0)
ENDIF
IF obj=virtstop& THEN
@setbutton(virtstop&,0)
ENDIF
UNTIL obj=virtbloc& OR obj=virtno& OR obj=virtok&
ENDIF
virtex=FALSE
tedart=vvtedart
IF ldtrk=FALSE THEN
IF obj=virtbloc& THEN
blockld=FALSE
@blkproof
@blockcalc
mt=hbldlen
ELSE
blockld=FALSE
ENDIF
IF obj=virtok& THEN
virtual=TRUE
ELSE
virtual=FALSE
ENDIF
IF obj=virtno& THEN
virtex=TRUE
ENDIF
PAUSE 3
@setbutton(obj,0)
@restaura2
@wischwasch
ELSE
virtual=TRUE
ENDIF
obj=0
RETURN
'
> PROCEDURE blkart
.| Glob. Var.: tedart#,u#,vhbldstrt#,hz#,a$,vblkstrt&
.| Ruft auf  : editfeld
.| Aufruf in : button-2,virtual-5,
IF tedart=0 THEN
u=vhbldstrt/(hz*mbit)
a$=STR$(u)
ELSE
u=INT(vhbldstrt/mbit)
a$=STR$(u)
ENDIF
IF LEN(a$)>8 THEN
a$=LEFT$(a$,8)
ENDIF
a$=a$+CHR$(0)
@editfeld(vblkstrt&,a$)
RETURN
'
> PROCEDURE blkproof
.| Glob. Var.: vblkstrt&,notedok#,a$,i#,a#,vhbldstrt#,tedart#,hz#,smplen#,g#
.|     blockld#
.| Ruft auf  : editread
.| Aufruf in : virtual-4,
@editread(vblkstrt&)
notedok=FALSE
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF (a<48 OR a>57) AND a<>46 THEN
notedok=TRUE
ENDIF
IF (i=1 OR i=8) AND a=46 THEN
notedok=TRUE
ENDIF
NEXT i
ELSE
notedok=TRUE
ENDIF
IF notedok=FALSE THEN
vhbldstrt=VAL(a$)
IF tedart=0 THEN
vhbldstrt=vhbldstrt*hz*mbit
ELSE
vhbldstrt=vhbldstrt*mbit
ENDIF
vhbldstrt=INT(vhbldstrt/mbit)*mbit
IF vhbldstrt<0 OR vhbldstrt>smplen THEN
notedok=TRUE
@alerts(39)
ENDIF
ENDIF
IF notedok=FALSE THEN
blockld=TRUE
ENDIF
RETURN
'
> PROCEDURE blockcalc
.| Glob. Var.: hbldlen#,mt#,vhbldstrt#,smplen#,hbg#,hbz#
.| Aufruf in : virtual-3,
hbldlen=INT(mt/mbit)*mbit
IF vhbldstrt=0 THEN
vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
ENDIF
IF vhbldstrt+hbldlen>smplen THEN
hbldlen=smplen-vhbldstrt
ENDIF
RETURN
'
> PROCEDURE hardproof
.| Glob. Var.: fil$
.| Ruft auf  : rettmem,hardproof2
.| Aufruf in : ldhlp-1,
IF EXIST(fil$)=TRUE THEN
@rettmem
@hardproof2
ENDIF
RETURN
'
> PROCEDURE makepbuf
LOCAL glen,s1,s2,z,i,j,a,am,ia,ib,adr
IF cs=0 THEN
s1=peakmem%
ELSE
s1=INT(peakmem%+(pbuf/(vmem/cs)))
s1=INT(s1/mbit)*mbit
ENDIF
IF ce=vmem THEN
s2=peakmem%+pbuf
ELSE
s2=INT(peakmem%+(pbuf/(vmem/ce)))
s2=INT(s2/mbit)*mbit
ENDIF
stp=(s2-s1)/xm
IF stp=0 THEN
stp=8
ENDIF
z=INT((s2-s1)/stp+stp)
pbufda=TRUE
IF cwerte1>0 THEN
~MFREE(cwert)
ENDIF
cwerte1=@malloc((z+xm)*16,1)
IF cwerte1>0 THEN
cwert=cwerte1
cwertep1=INT((cwerte1+2)/2)*2
cwertep2=cwerte1+((z+xm)*4)
cwertem1=cwerte1+((z+xm)*8)
cwertem2=cwerte1+((z+xm)*12)
werte=INT((s2-s1)/stp)
z=0
IF werte>0 THEN
glen=werte*stp
IF cs=0 THEN
i=peakmem%
ELSE
i=s1
ENDIF
FOR j=1 TO werte
ia=INT(i/8)*8           !neu
ib=INT((i+stp)/8)*8     !neu
adr=XBIOS(xbs,301,L:ia,L:ib)
@busy_mouse
INC z
a=DPEEK(adr+4)
am=DPEEK(adr+6)
LPOKE (cwertep1+z*4),a
LPOKE (cwertem1+z*4),am
a=DPEEK(adr)
am=DPEEK(adr+2)
LPOKE (cwertep2+z*4),a
LPOKE (cwertem2+z*4),am
i=i+stp
NEXT j
maxcwert=z
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE hardproof2
.| Glob. Var.: fil$,virtpath$,virtln#,stp#,mlen#,xm#,cwerte1#,cwert#
.|     cwertep1#,cwertep2#,cwertem1#,cwertem2#,i#,meml#,werte#,a#,am#
.|     maxcwert#,g#,virtual#,virtcurve#
.| Ruft auf  : busy_mouse,maschinit31,maschruf31,trash
.| Aufruf in : hardproof-1,memtovirt-1,memtovirt2-1,
LOCAL j,z,hl,glen,dh
pbufda=FALSE
IF EXIST(fil$)=TRUE THEN
'
virtpath$=fil$
s=RINSTR(fil$,".")
a$=LEFT$(fil$,s)+peak$+CHR$(0)
IF EXIST(a$)=TRUE THEN
OPEN "I",#2,a$
pbuf=LOF(#2)
CLOSE #2
nopeakmem=FALSE
IF peakmemda=TRUE THEN
~MFREE(peakmem%)
ENDIF
peakmem%=@malloc(pbuf,1)     ! Peak-Buffer
IF peakmem%<=0 THEN
nopeakmem=TRUE
ELSE
peakmemda=TRUE
ENDIF
IF mlen>=pbuf AND nopeakmem=FALSE AND pbuf>0 THEN
pbm$=a$
BLOAD pbm$,peakmem%
@makepbuf
ENDIF
ELSE
nomem=FALSE
@makepbf
IF nomem=FALSE THEN
@makepbuf
ENDIF
ENDIF
'
IF pbufda=FALSE THEN
@busy_mouse
virtpath$=fil$
OPEN "I",#1,fil$
virtln=LOF(#1)
hl=virtln-2
stp=(INT(mlen/xm))
stp=(INT((stp+1)/mbit)*mbit)
z=INT(hl/stp+stp)
IF cwerte1>0 THEN
~MFREE(cwert)
ENDIF
cwerte1=@malloc((z+xm)*16,1)
IF cwerte1>0 THEN
cwert=cwerte1
cwertep1=INT((cwerte1+2)/2)*2
cwertep2=cwerte1+((z+xm)*4)
cwertem1=cwerte1+((z+xm)*8)
cwertem2=cwerte1+((z+xm)*12)
z=0
REPEAT
i=meml
IF hl<=mlen
glen=hl
ELSE
glen=mlen
ENDIF
werte=INT(glen/stp)
IF werte>0 THEN
glen=werte*stp
hl=hl-glen
BGET #1,meml,glen
FOR j=1 TO werte
@maschruf31
@busy_mouse
INC z
LPOKE (cwertep1+z*4),a
LPOKE (cwertem1+z*4),am
i=i+2
@maschruf31
LPOKE (cwertep2+z*4),a
LPOKE (cwertem2+z*4),am
i=i-2
i=i+stp
NEXT j
ENDIF
UNTIL hl<stp
CLOSE #1
maxcwert=z
ELSE
virtual=FALSE
virtcurve=FALSE
@trash
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE hardproof3
.| Glob. Var.: fil$,virtln#
.| Aufruf in : fade_it-1,smpcut-2,virtmove-1,virtcopy-1,virtins-1,mono-1
.|     negate-1,lrchange-1,makenorm-1,makeresmp-1,
OPEN "I",#1,fil$
virtln=LOF(#1)
CLOSE #1
RETURN
'
> PROCEDURE wischwasch
LOCAL xevnt&,key&,xflags&,xtim&,mx&,my&,mb&,shift&,c
IF rscda=TRUE THEN
IF rsc_handle%(nr)<1000                             ! Fenster Dialog ?
xflags&=&X110000                                      ! ...zus. MESSAGE-Events
xtim&=4   ! EVENT-TIMER in msec
REPEAT
xevnt&=EVNT_MULTI(xflags&,2,1,1,0,0,0,0,0,0,0,0,0,0,0,xtim&,mx&,my&,mb&,shift&,key&,c)
IF BTST(xevnt&,4) THEN
@message
ENDIF
UNTIL BTST(xevnt&,4)=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE meldung_on(m$)
@wischwasch
meldnr=nr
nr=meldung&
cupdate=TRUE
@textfeld2(meldung&,meldtxt&,m$,1)
cupdate=FALSE
@rsc_draw(nr,5)
RETURN
'
> PROCEDURE meldung_off
@rsc_back(nr)
nr=meldnr
@wischwasch
RETURN
'
> PROCEDURE rettmem
.| Glob. Var.: profhz#,hz#,smpnam$,path$,lfw$,a#,virt2$,sector#,vsmpnam$
.|     vpath$,vsmplen#,vhz#,vsblock#,vsloop#,vmamidi#,vsms#,vsme#,vmaster#
.|     vper#,vmrkdatum$,vretime#,vordner$,vorcs#,vorce#,vlz#,vzoomp#
.|     vscrollp#,i#,loopz#,bloopz#,vlmin#,vlma#,vmbs#,virt$,mlen#,meml#
.| Felder    : vloops#(),vloope#(),vbloops#(),vbloope#(),mblocks#()
.|     mblocke#(),mblockp$()
.| Ruft auf  : busy_mouse,nomem
.| Aufruf in : smpkhlp-1,smpmhlp-5,smpihlp-1,hardproof-1,arrload-1
.|     coninsert-1,
IF ldtrk=FALSE THEN
@busy_mouse
IF profhz=0 AND hz<>0 THEN
profhz=hz
ENDIF
IF profhz=0 THEN
profhz=44100
ENDIF
IF smpnam$="" THEN
IF dig24=FALSE THEN
smpnam$="MEMORY.S16"
ELSE
smpnam$="MEMORY.S24"
ENDIF
ENDIF
IF path$="" THEN
path$=lfw$+smpnam$
ENDIF
a=ASC(LEFT$(virt2$,1))-64
@makehz
vhz=hz
IF virt2$=virtm2$ THEN
@alerts(41)
ELSE
@alerts(40)
IF g=1 THEN
virtm2$=virt2$
ENDIF
ENDIF
IF g=1 THEN
IF DFREE(a)>sector THEN
rettfound=TRUE
@alerts2(1)
@meldung_on(m$)
OPEN "O",#4,virt2$
PRINT #4,vsmpnam$
PRINT #4,vpath$
PRINT #4,vsmplen
PRINT #4,vhz
PRINT #4,vsblock
PRINT #4,vsloop
PRINT #4,vmamidi
PRINT #4,vsms
PRINT #4,vsms2
PRINT #4,vper
PRINT #4,vmrkdatum$
PRINT #4,vretime
PRINT #4,vordner$
PRINT #4,vorcs
PRINT #4,vorce
PRINT #4,vlz
PRINT #4,vzoomp
PRINT #4,vscrollp
FOR i=1 TO loopz
PRINT #4,vloops%(i,1)
NEXT i
FOR i=1 TO loopz
PRINT #4,vloops%(i,2)
NEXT i
FOR i=1 TO bloopz
PRINT #4,vbloops%(i,1)
PRINT #4,vbloops%(i,2)
NEXT i
PRINT #4,vlmin
PRINT #4,vlma
PRINT #4,vmbs
IF vmbs>0 THEN
FOR i=1 TO vmbs
PRINT #4,mblocks(i)
PRINT #4,mblocke(i)
PRINT #4,mblockp$(i)
NEXT i
ENDIF
CLOSE #4
a=ASC(LEFT$(virt$,1))-64
IF DFREE(a)>=mlen THEN
BSAVE virt$,meml,mlen
ELSE
@nomem
rettfound=FALSE
ENDIF
@meldung_off
ELSE
@nomem
rettfound=FALSE
ENDIF
ELSE
rettfound=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE getmem
.| Glob. Var.: virt2$,smpnam$,path$,smplen#,hz#,sblock#,sloop#,mamidi#,sms#
.|     sme#,master#,per#,mrkdatum$,retime#,ordner$,cs#,ce#,lz#,zoomp#
.|     scrollp#,i#,loopz#,bloopz#,vlmin#,vlma#,mbs#,zomslide&,zoombutt&
.|     zmax#,scrlslde&,scrolbut&,scmax#,virt$,meml#,cached#
.| Felder    : loops#(),loope#(),bloops#(),bloope#(),mblocks#(),mblocke#()
.|     mblockp$()
.| Ruft auf  : zslidecalc,scrollinit,setslide
.| Aufruf in : trash-2,
LOCAL a
IF EXIST(virt2$)=TRUE AND rettfound=TRUE THEN
@alerts2(2)
@meldung_on(m$)
OPEN "I",#8,virt2$
INPUT #8,smpnam$
INPUT #8,path$
INPUT #8,smplen
INPUT #8,hz
INPUT #8,sblock
INPUT #8,sloop
INPUT #8,mamidi
INPUT #8,sms
INPUT #8,sms2
INPUT #8,per
INPUT #8,mrkdatum$
INPUT #8,retime
INPUT #8,ordner$
INPUT #8,cs
INPUT #8,ce
INPUT #8,lz
INPUT #8,zoomp
INPUT #8,scrollp
FOR i=1 TO loopz
INPUT #8,loops%(i,1)
NEXT i
FOR i=1 TO loopz
INPUT #8,loops%(i,2)
NEXT i
FOR i=1 TO bloopz
INPUT #8,bloops%(i,1)
INPUT #8,bloops%(i,2)
NEXT i
INPUT #8,vlmin
INPUT #8,vlma
INPUT #8,mbs
IF mbs>0 THEN
FOR i=1 TO mbs
INPUT #8,mblocks(i)
INPUT #8,mblocke(i)
INPUT #8,mblockp$(i)
NEXT i
ENDIF
CLOSE #8
'    KILL virt2$
IF EXIST(virt$)=TRUE THEN
OPEN "I",#8,virt$
a=LOF(#8)
BGET #8,meml,a
CLOSE #8
'      KILL virt$
cached=FALSE
ENDIF
@meldung_off
IF trkmemr=FALSE THEN
@zslidecalc
@scrollinit
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
ENDIF
ENDIF
IF pbufda=TRUE THEN
pbufda=FALSE
ENDIF
RETURN
'
> PROCEDURE arrload
.| Glob. Var.: arrup$,lfw$,fil$,pret#,pbutt#,rett#,lmax2#,smpnam$,path$
.|     smplen#,hz#,sblock#,sloop#,sms#,sme#,master#,loopz#,mbs#,mlen#,meml#
.|     cached#,pbz#,arrz#,a$,playlen&,arrload&,obj#
.| Felder    : arrfn$(),arrpath$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#(),loops#(),loope#(),mblocks#()
.|     mblocke#(),mblockp$()
.| Ruft auf  : fileselect,rettmem,busy_mouse,textfeld,arrnrset,setbutton
.| Aufruf in : do_arrange-1,
LOCAL i,a,b,p$,g
g=RINSTR(arrup$,"\")
@fileselect(lfw$+"*."+RIGHT$(arrup$,3),RIGHT$(arrup$,LEN(arrup$)-g),"ARRANGE-LOAD:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
IF EXIST(fil$) THEN
@rettmem
rett=TRUE
@busy_mouse
OPEN "I",#5,fil$
FOR i=1 TO lmax2
INPUT #5,arrfn$(i)
INPUT #5,arrpath$(i)
INPUT #5,arrstrt(i)
INPUT #5,arrend(i)
INPUT #5,arrlen(i)
INPUT #5,arrmidi(i)
INPUT #5,arrloop(i)
INPUT #5,arrtri(i)
INPUT #5,arrsrate(i)
NEXT i
INPUT #5,smpnam$
INPUT #5,path$
INPUT #5,smplen
INPUT #5,hz
INPUT #5,sblock
INPUT #5,sloop
INPUT #5,sms
INPUT #5,sms2
INPUT #5,blabla           ! Reserve
FOR i=1 TO loopz
INPUT #5,loops%(i,1)
NEXT i
FOR i=1 TO loopz
INPUT #5,loops%(i,2)
NEXT i
INPUT #5,mbs
IF mbs>0 THEN
FOR i=1 TO mbs
INPUT #5,mblocks(i)
INPUT #5,mblocke(i)
INPUT #5,mblockp$(i)
NEXT i
ENDIF
CLOSE #5
IF mbs>0 THEN
FOR i=1 TO mbs
IF EXIST(mblockp$(i))=TRUE THEN
IF mblocke(i)<=mlen THEN
OPEN "I",#5,mblockp$(i)
a=mblocke(i)-mblocks(i)
b=LOF(#5)
IF a>b THEN
a=b
ENDIF
BGET #5,meml+mblocks(i),a
CLOSE #5
ENDIF
ENDIF
NEXT i
cached=FALSE
ENDIF
pbz=0
arrz=0
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
@arrnrset
adrag=FALSE
@setbutton(arrclip&,0)
ENDIF
ENDIF
@setbutton(arrload&,0)
obj=0
RETURN
'
> PROCEDURE arrsteil
.| Glob. Var.: i#,lmax2#,smpnam$,path$,smplen#,profhz#,sblock#,sloop#,sms#
.|     sme#,master#,loopz#,mbs#
.| Felder    : arrfn$(),arrpath$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#(),loops#(),loope#(),mblocks#()
.|     mblocke#(),mblockp$()
.| Aufruf in : arrsave-1,makeaback-1,
FOR i=1 TO lmax2
PRINT #5,arrfn$(i)
PRINT #5,arrpath$(i)
PRINT #5,arrstrt(i)
PRINT #5,arrend(i)
PRINT #5,arrlen(i)
PRINT #5,arrmidi(i)
PRINT #5,arrloop(i)
PRINT #5,arrtri(i)
PRINT #5,arrsrate(i)
NEXT i
PRINT #5,smpnam$
PRINT #5,path$
PRINT #5,smplen
PRINT #5,profhz
PRINT #5,sblock
PRINT #5,sloop
PRINT #5,sms
PRINT #5,sms2
PRINT #5,blabla            ! Reserve
FOR i=1 TO loopz
PRINT #5,loops%(i,1)
NEXT i
FOR i=1 TO loopz
PRINT #5,loops%(i,2)
NEXT i
PRINT #5,mbs
IF mbs>0 THEN
FOR i=1 TO mbs
PRINT #5,mblocks(i)
PRINT #5,mblocke(i)
PRINT #5,mblockp$(i)
NEXT i
ENDIF
RETURN
'
> PROCEDURE arrsave
.| Glob. Var.: virtual#,mbs#,arrup$,lfw$,fil$,pret#,pbutt#,a#,sector#
.|     arrsave&
.| Ruft auf  : busy_mouse,fileselect,arrsteil,nomem,setbutton
.| Aufruf in : do_arrange-1,
LOCAL p$,g,g2
@busy_mouse
IF virtual=TRUE THEN
mbs=0
ENDIF
g=RINSTR(arrup$,"\")
@fileselect(lfw$+"*."+RIGHT$(arrup$,3),RIGHT$(arrup$,LEN(arrup$)-g),"ARRANGE-SAVE:")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+RIGHT$(arrup$,4)
ELSE
IF RIGHT$(fil$,4)<>RIGHT$(arrup$,4) THEN
fil$=LEFT$(fil$,g2)+RIGHT$(arrup$,3)
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=sector THEN
OPEN "O",#5,fil$
@arrsteil
CLOSE #5
ELSE
@nomem
ENDIF
ENDIF
@setbutton(arrsave&,0)
RETURN
'
> PROCEDURE recplay
.| Glob. Var.: recplay&
.| Ruft auf  : setbutton
.| Aufruf in : do_arrange-1,
@setbutton(recplay&,0)
RETURN
'
> PROCEDURE mpause
.| Glob. Var.: pause&
.| Ruft auf  : setbutton
.| Aufruf in : do_arrange-1,
IF XBIOS(xbs,1)=&H71273800 AND intplay=TRUE THEN
IF mpause=FALSE THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
mpause=TRUE
ELSE
IF demo=FALSE THEN
@write_int(1)
ENDIF
mpause=FALSE
ENDIF
ELSE
@setbutton(pause&,0)
ENDIF
RETURN
'
> PROCEDURE mstop
.| Glob. Var.: handle#,playstop#,hardopen#,a$,playname&,stop&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : do_arrange-1,
~GEMDOS(62,handle)
IF XBIOS(xbs,1)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
intplay=FALSE
ELSE
playstop=1
@mstop2
ENDIF
REPEAT
UNTIL @mousek=0
PAUSE 3
@digout(FALSE)
@setbutton(stop&,0)
RETURN
'
> PROCEDURE mstop2
handle=0
hardopen=FALSE
a$=SPACE$(12)
@textfeld(playname&,a$,1)
IF XBIOS(xbs,1)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
@digout(FALSE)
intplay=FALSE
ENDIF
RETURN
'
> PROCEDURE mforw
.| Glob. Var.: pbz#,arrz#,pa$,playstop#,hardopen#,handle#,vhz#,sectall#
.|     sectpos#,sectors#,l#,playpos#,flen#,back%,hsec#,playlen&,a$,nr#
.| Felder    : arrpath$()
.| Ruft auf  : arrsethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_arrange-2,
mstop=0
IF arrpath$(pbz+arrz)<>"" AND pa$<>"" THEN
@arrsethz
IF playstop=2 AND hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
IF sectall>sectpos THEN
sectors=sectall-sectpos
l=0
playpos=sectpos
IF over<>0 THEN
oldplay=TRUE
ENDIF
adder=over
@maschrufb5
IF over<>0 THEN
oldplay=FALSE
ENDIF
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
playpos=sectpos
sectors=sectall-sectpos
l=0
playpos=sectpos
IF over<>0 THEN
oldplay=TRUE
ENDIF
adder=over
@maschrufb5
IF over<>0 THEN
oldplay=FALSE
ENDIF
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
IF vhz>0 THEN
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
ENDIF
@digout(FALSE)
RETURN
'
> PROCEDURE mbackw
.| Glob. Var.: pbz#,arrz#,pa$,playstop#,hardopen#,vhz#,sectpos#,sectors#,l#
.|     playpos#,flen#,back%,handle#,sectall#,hsec#,playlen&,a$,nr#
.| Felder    : arrpath$()
.| Ruft auf  : arrsethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_arrange-2,
mstop=0
adder=over
'  IF over<>-mbit*2 THEN
oldplay=TRUE
' ENDIF
IF arrpath$(pbz+arrz)<>"" AND pa$<>"" THEN
@arrsethz
IF playstop=2 AND hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
@digout(TRUE)
@swtosrate(vhz)
IF sectpos>0 THEN
sectors=sectpos
l=0
playpos=sectpos
@maschrufb5
IF sectpos>0 THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF sectpos=0 THEN
sectpos=sectall
ENDIF
playpos=sectpos
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
sectors=sectpos
l=0
playpos=sectpos
@maschrufb5
IF sectpos>0 THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
IF over<>-mbit*2 THEN
oldplay=FALSE
ENDIF
@digout(FALSE)
RETURN
'
> PROCEDURE htimeset
LOCAL a,b,h$
hh=INT(hsec/100/60/60)
hrest=hsec-(hh*100*60*60)
hm=INT(hrest/100/60)
hrest=hrest-(hm*100*60)
hs=INT(hrest/100)
hms=hrest-(hs*100)
IF hh<10 THEN
a$=CHR$(16)+CHR$(hh+16)+":"
ELSE
h$=STR$(hh)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=CHR$(a)+CHR$(b)+":"
ENDIF
IF hm<10 THEN
a$=a$+CHR$(16)+CHR$(hm+16)+":"
ELSE
h$=STR$(hm)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=a$+CHR$(a)+CHR$(b)+":"
ENDIF
IF hs<10 THEN
a$=a$+CHR$(16)+CHR$(hs+16)+" "
ELSE
h$=STR$(hs)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=a$+CHR$(a)+CHR$(b)+" "
ENDIF
IF hms<10 THEN
a$=a$+CHR$(16)+CHR$(hms+16)+CHR$(0)
ELSE
h$=STR$(hms)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=a$+CHR$(a)+CHR$(b)+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE htimeset2
.| Glob. Var.: hh#,hsec#,hrest#,hm#,hs#,hms#,a$
.| Aufruf in : maschruf2-1,maschruf3-2,maschruf3b-2,maschruf5-1
.|     maschruf5c-1,maschruf8b-2,arrnrset-9,trakload-1,trakforw-2
.|     trkbackw-2,trkstrt-1,trkend-1,trkanf-2,trkfull-2,trkplay-13
.|     opentrk-5,arrstrt-2,arrend-2,arrtowork-1,arrplay-13,hardstrt-1
.|     hardend-1,hardfs-1,mforw-2,mbackw-2,
hh=INT(hsec/100/60/60)
hrest=hsec-(hh*100*60*60)
hm=INT(hrest/100/60)
hrest=hrest-(hm*100*60)
hs=INT(hrest/100)
hms=hrest-(hs*100)
IF hh<10 THEN
a$="0"+STR$(hh)+":"
ab$="0"+STR$(hh)
ELSE
a$=STR$(hh)+":"
ab$=STR$(hh)
ENDIF
IF hm<10 THEN
a$=a$+"0"+STR$(hm)+":"
ab$=ab$+"0"+STR$(hm)
ELSE
a$=a$+STR$(hm)+":"
ab$=ab$+STR$(hm)
ENDIF
IF hs<10 THEN
a$=a$+"0"+STR$(hs)+" "
ab$=ab$+"0"+STR$(hs)
ELSE
a$=a$+STR$(hs)+" "
ab$=ab$+STR$(hs)
ENDIF
IF hms<10 THEN
a$=a$+"0"+STR$(hms)+CHR$(0)
ab$=ab$+"0"+STR$(hms)+CHR$(0)
ELSE
a$=a$+STR$(hms)+CHR$(0)
ab$=ab$+STR$(hms)+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE zoomcalc
.| Glob. Var.: xm#,vmem#,zmax#,zoomp#,ce#,cs#,nr#,smpedit&,scrolm#,cached#
.| Ruft auf  : makepnt,restaura
.| Aufruf in : button-2,do_smpedit-2,
LOCAL grenz,stufen,dazu
grenz=xm/2
stufen=LOG(vmem-grenz)/zmax
dazu=INT((EXP(stufen*(zmax-zoomp))+grenz)/mbit)*mbit
ce=INT((cs+dazu)/mbit)*mbit
IF ce>vmem THEN
cs=INT((vmem-dazu)/mbit)*mbit
ce=vmem
ENDIF
IF cs<0 THEN
cs=0
ENDIF
IF nr=smpedit& THEN
@makepnt
ENDIF
scrolm=ce-cs
cached=FALSE
@restaura
RETURN
'
> PROCEDURE zslidecalc
.| Glob. Var.: xm#,vmem#,zmax#,ce#,cs#,zoomp#,nr#,smpedit&,zomslide&
.|     zoombutt&,a$
.| Ruft auf  : setslide,textbutt,makepnt
.| Aufruf in : zoomhelp-1,smpl-1,smpr-1,rubbermax-1,ldhlp-1,getmem-1
.|     smpedit-1,do_smpedit-2,trash-1,
LOCAL grenz,stufen
grenz=xm/2
IF vmem-grenz>0 THEN
stufen=LOG(vmem-grenz)/zmax
IF ((ce-cs)-grenz)>0 THEN
zoomp=zmax-ROUND((LOG((ce-cs)-grenz))/stufen)
ELSE
zoomp=zmax-1
ENDIF
ELSE
zoomp=0
ENDIF
IF zoomp>zmax-1 THEN
zoomp=zmax-1
ENDIF
IF nr=smpedit& THEN
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@makepnt
ENDIF
RETURN
'
> PROCEDURE maketime
.| Glob. Var.: uhr#,tim$,nr#,smpedit&,clock&,aback#,btim$,btime#
.| Ruft auf  : textfeld,makeaback
.| Aufruf in : rsc_do-1,windows-1,smpedit-1,markhandler-1,
LOCAL a,b,c,d,ha1
'
@markhlp
GRAPHMODE 1
'
IF uhr=TRUE THEN
IF tim$<>TIME$ THEN
tim$=TIME$
IF nr=smpedit& THEN
@textfeld(clock&,TIME$,1)
ENDIF
IF aback=TRUE THEN
a=VAL(MID$(tim$,4,2))
b=VAL(MID$(btim$,4,2))
c=VAL(RIGHT$(tim$,2))
d=VAL(RIGHT$(btim$,2))
IF a<b THEN
a=a+60
ENDIF
IF c<d THEN
c=c+60
b=b+1
ENDIF
b=a-b
c=c-d
IF (b*60+c)>=btime*60 THEN
@makeaback
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE makepnt
.| Glob. Var.: nr#,smpedit&,pnt#,ce#,cs#,xm#,pntc#,a$,pntprsmp&
.| Ruft auf  : textfeld
.| Aufruf in : zoomcalc-1,zslidecalc-1,smpedit-1,do_smpedit-2,
IF nr=smpedit& THEN
pnt=INT((ce-cs)/mbit)
IF pnt>0 THEN
IF pnt<=xm THEN
pntc=xm/pnt
pntc=INT(pntc*10)/10
a$=STR$(pntc)
IF LEN(a$)>7 THEN
a$=LEFT$(a$,7)
ENDIF
a$=a$+":1"
ELSE
pntc=INT(pnt/xm)
a$="1:"+STR$(pntc)
IF LEN(a$)>9 THEN
a$=LEFT$(a$,9)
ENDIF
ENDIF
a$=a$+CHR$(0)
@textfeld(pntprsmp&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE abackup
.| Glob. Var.: vornr#,nr#,abackup&,winh#,menuda#,a$,btime#,abacktxt&,aback#
.|     aback&,abacknam#,abacknam&,vbtime#,vaback#,vaback2#,vabacknam#,obj#
.|     popup&,zu%,zuadr#,buttadr#,but#,objadr#,objflag#,abackhlp&,abackr1&
.|     abackr2&,abackl1&,abackl2&,abackex&,abackok&,tim$,btim$,clock&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,textfeld,setbutton,rsc_do
.|     xrsrc_gaddr,mousek,helptxt,setaback,abacknam,abackr,abackl,restaura2
.| Aufruf in : do_smpedit-1,
vornr=nr
nr=abackup&
IF BTST(winh,nr)=FALSE THEN
@rsc_draw(nr,0)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
a$=RIGHT$("00"+STR$(btime),2)+CHR$(0)
@textfeld(abacktxt&,a$,1)
IF aback=TRUE THEN
@setbutton(aback&,1)
ELSE
@setbutton(aback&,0)
ENDIF
IF abacknam=TRUE THEN
@setbutton(abacknam&,1)
ELSE
@setbutton(abacknam&,0)
ENDIF
vbtime=btime
vaback=aback
vaback2=aback
vabacknam=abacknam
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=abackhlp& THEN
@helptxt("BACKUP")
ENDIF
IF obj=aback& THEN
@setaback
ENDIF
IF obj=abacknam& THEN
@abacknam
ENDIF
IF obj=abackr1& OR obj=abackr2& THEN
@abackr
ENDIF
IF obj=abackl1& OR obj=abackl2& THEN
@abackl
ENDIF
UNTIL obj=abackex& OR obj=abackok&
@setbutton(obj,0)
IF obj=abackex& THEN
btime=vbtime
aback=vaback
abacknam=vabacknam
ELSE
tim$=TIME$
btim$=TIME$
aback=vaback2
ENDIF
winh=BCLR(winh,abackup&)
@restaura2
IF aback=FALSE THEN
@setbutton(clock&,0)
ELSE
@setbutton(clock&,1)
ENDIF
obj=0
RETURN
'
> PROCEDURE setaback
.| Glob. Var.: vaback2#
.| Aufruf in : abackup-1,
IF vaback2=FALSE THEN
vaback2=TRUE
ELSE
vaback2=FALSE
ENDIF
RETURN
'
> PROCEDURE abacknam
.| Glob. Var.: abacknam#
.| Aufruf in : abackup-1,
IF abacknam=FALSE THEN
abacknam=TRUE
ELSE
abacknam=FALSE
ENDIF
RETURN
'
> PROCEDURE abackr
.| Glob. Var.: obj#,abackr1&,x#,btime#,a$,abacktxt&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : abackup-1,
IF obj=abackr1& THEN
x=1
ELSE
x=5
ENDIF
IF btime<(61-x) THEN
btime=btime+x
a$=RIGHT$("00"+STR$(btime),2)+CHR$(0)
@textfeld(abacktxt&,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE abackl
.| Glob. Var.: obj#,abackl1&,x#,btime#,a$,abacktxt&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : abackup-1,
IF obj=abackl1& THEN
x=1
ELSE
x=5
ENDIF
IF btime>x THEN
btime=btime-x
a$=RIGHT$("00"+STR$(btime),2)+CHR$(0)
@textfeld(abacktxt&,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE write(w$,zeile)
.| Glob. Var.: xd#,yd#
.| Ruft auf  : markhlp
.| Aufruf in : makeaback-4,
LOCAL ready,v
ready=FALSE
REPEAT
'    IF mrkhandle=mrkhandle2 THEN
'    v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
'    IF v<>0 AND kenn=mrkhandle2 THEN
@markhlp
~GRAF_MOUSE(256,0)                              ! Hidem
~WIND_UPDATE(1)                                    ! BEG_UPDATE
GRAPHMODE 2
DEFTEXT 1,0,0,4
TEXT xd+10,yd+24+zeile*8,w$
GRAPHMODE 1
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~GRAF_MOUSE(257,0)                              ! Showm
ready=TRUE
'  ENDIF
'  ENDIF
UNTIL ready=TRUE
drawnew=TRUE
RETURN
'
> PROCEDURE makeaback
.| Glob. Var.: mrkobj#,obj#,vvorvornr#,vorvornr#,vornr#,nr#,inftxt&,winh#
.|     menuda#,btim$,mbs#,path$,ext2$,abacknam#,a$,lfw$,aback$,virtual#,a#
.|     mlen#,meml#,arp$,aback2$,sector#
.| Felder    : mblockp$()
.| Ruft auf  : rsc_draw,rsc_menu_ienable,write,arrsteil,restaura2
.| Aufruf in : maketime-1,
LOCAL b$
mrkobj=obj
vvorvornr=vorvornr
vorvornr=vornr
vornr=nr
nr=inftxt&
IF BTST(winh,nr)=FALSE THEN
@rsc_draw(nr,5)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
btim$=TIME$
IF mbs>0 THEN
b$=mblockp$(mbs)
ELSE
b$=path$
ENDIF
IF b$="" OR INSTR(b$,":")=0 OR INSTR(b$,"\")=0 THEN
b$="MEMORY."+ext2$
ENDIF
IF abacknam=TRUE THEN
a$=b$
IF EXIST(a$)=FALSE THEN
a$=lfw$+aback$
ENDIF
ELSE
a$=lfw$+aback$
ENDIF
IF virtual=FALSE THEN
a=ASC(LEFT$(a$,1))-64
IF DFREE(a)>=mlen THEN
b$=a$
IF LEN(b$)>40 THEN
b$="..."+RIGHT$(b$,40-3)
ENDIF
@write("MEM-Backup:   "+b$,5)
IF abacknam=TRUE AND EXIST(a$)=TRUE THEN
OPEN "U",#5,a$
ELSE
OPEN "O",#5,a$
ENDIF
BPUT #5,meml,mlen
CLOSE #5
ELSE
@alerts3(1)
PAUSE 50
ENDIF
ENDIF
IF abacknam=TRUE THEN
a$=arp$
IF a$="" THEN
a$=aback2$
ENDIF
IF EXIST(a$)=FALSE THEN
a$=aback2$
ENDIF
ELSE
a$=aback2$
ENDIF
a=ASC(LEFT$(a$,1))-64
IF DFREE(a)>=sector THEN
b$=a$
IF LEN(b$)>40 THEN
b$="..."+RIGHT$(b$,40-3)
ENDIF
@write("ARR-Backup:   "+b$,6)
IF abacknam=TRUE AND EXIST(a$)=TRUE THEN
OPEN "U",#5,a$
ELSE
OPEN "O",#5,a$
ENDIF
@arrsteil
CLOSE #5
ELSE
@alerts3(2)
PAUSE 50
ENDIF
winh=BCLR(winh,inftxt&)
@restaura2
obj=0
vornr=vorvornr
vorvornr=vvorvornr
RETURN
'
> PROCEDURE sethertz
.| Glob. Var.: extclock#,nr#,smpedit&,hz#,a$,popups&,rate32&,rate&,rate44&
.|     rate48&,smp16&,ad32&,rate2&,ad44&,ad48&
.| Ruft auf  : textfeld,adlow,admid,adhigh,fliphz
.| Aufruf in : edhandler3-3,smpedit-1,setupdat-1,setup2-1,smpauto-1
.|     smpstart-1,edhandler-3,
@fliphz
@fliphz2
RETURN
'
> PROCEDURE smpedit
.| Glob. Var.: nr#,smpedit&,obj#,menuda#,winh#,freez#,i#,info&,blkfunc&
.|     smp16&,peak&,arranger&,trakker&,loop&,editfade&,cs#,ce#,vmem#,lz#
.|     ldlen#,cutp#,blks#,fadericht#,admrk#,ad#,max#,zomslide&,zoombutt&
.|     zmax#,zoomp#,scrlslde&,scrolbut&,scmax#,scrollp#,a$,aback#,clock&
.|     freemem&,popups&,smpmark&,mover&,ch#,note#,midiwort#,min$,min#
.|     mintext&,mamidi#,midi&,sms#,sme#,okmark#,lded#,datx#,sblock#
.|     smppmark&,mrcs#,mrce#,mrzoom#,mrscroll#,away#,gohome#
.| Ruft auf  : rsc_menu_ienable,setup,info,blkfunc,main,peak,arranger
.|     trakker,loopwahl,fade,rsc_draw,setup2,winbuttset,zslidecalc
.|     scrollinit,writeyproz,makepnt,setslide,textbutt,markhlp,setbutton
.|     textfeld,markhlp3,makehz,sethertz,markdel,clsed,fnamwrite,curve
.|     markprod3,maketime,windows
.| Aufruf in : HAUPTPROGRAMM-1,
nr=smpedit&
obj=0
@setup
@initplugins
IF away=FALSE THEN
winh=BSET(winh,nr)
'
sms=1   ! vorlÑufig
'
IF freez=TRUE THEN
FOR i=31 TO 0 STEP -1
obj=0
IF BTST(winh,i)=TRUE AND i<>smpedit& THEN
IF i=info& THEN
winh=BCLR(winh,i)
@info
ENDIF
IF i=smp16& THEN
winh=BCLR(winh,i)
@main
ENDIF
IF i=blkfunc& THEN
winh=BCLR(winh,i)
@blkfunc
ENDIF
IF i=peak& THEN
winh=BCLR(winh,i)
@peak
ENDIF
IF i=arranger& THEN
winh=BCLR(winh,i)
@arranger
ENDIF
IF i=trakker& THEN
winh=BCLR(winh,i)
@trakker
ENDIF
IF i=loop& THEN
winh=BCLR(winh,i)
@loopwahl
ENDIF
IF i=dspedit& THEN
winh=BCLR(winh,i)
@dspwahl
ENDIF
IF i=editfade& THEN
winh=BCLR(winh,i)
@fade
ENDIF
IF i=wmode& THEN
winh=BCLR(winh,i)
@workmode
ENDIF
ENDIF
NEXT i
ENDIF
nr=smpedit&
IF nosetload=FALSE AND prgversion>=1.2 THEN          ! Versionskontrolle
notopen=TRUE
@calc_editsize
notopen=FALSE
ENDIF
@rsc_draw(nr,7)
windowda=TRUE
smpedda=TRUE
'
IF public=TRUE THEN
'      @rsc_state(rsc_menu&,ddhost&,3,TRUE)
'      @rsc_state(rsc_menu&,ddmix&,3,TRUE)
~@xrsrc_gaddr(0,dropdown&,zu%)
~OBJC_DELETE(zu%,ddhost&-1)
~OBJC_DELETE(zu%,ddhost&)
~OBJC_DELETE(zu%,ddmix&)
@dropentrys(ddsetup&-1,9)
ENDIF
'
@setup2
@write_int(0)
@winbuttset
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
'
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
'
cs=0
ce=vmem
lz=1
ldlen=0
cutp=0
blks=0
admrk=ad
startup=TRUE
@zslidecalc
@scrollinit
max=32767
@writeyproz
@makepnt
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
'
@slideinit(edmslide&,edmbut&,loopz,5,vsms)
@setslide(edmslide&,edmbut&,loopz,5,vsms)
@edmarkset(vsms+1)
'
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@markhlp
IF aback=TRUE THEN
@setbutton(clock&,1)
ENDIF
a$="FRE "+STR$(FRE())+CHR$(0)
@textfeld(freemem&,a$,1)
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
@markhlp3(9998,0,cs)
@markhlp3(9999,0,ce)
midiwort=(ch-1)*256+note
@makehz
@sethertz
@minwrite
@sourcein
IF mamidi=0 THEN
@setbutton(midi&,0)
ELSE
@setbutton(midi&,1)
ENDIF
IF dig24=FALSE THEN
@textfeld(resolu&,"16 BIT"+CHR$(0),1)
ELSE
@textfeld(resolu&,"24 BIT"+CHR$(0),1)
ENDIF
markmode=1
nmarkmode=1
@setbutton(swmark&,1)
IF sms<>0 THEN
okmark=1
ENDIF
@markdel
@clsed
IF lded=0 AND okmark=0 THEN
'    @markdel
'    @clsed
ELSE
IF DPEEK(datx)=&HF07E OR okmark=1 THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ELSE
'      @markdel
'      @clsed
ENDIF
@fnamwrite
ENDIF
@curve(cs,ce)
IF (lded=1 AND DPEEK(datx)=&HF07E) OR okmark=1 THEN
@markprod3
ENDIF
@getcurve
@maketime
mrcs=cs
mrce=ce
mrzoom=zoomp
mrscroll=scrollp
IF away=FALSE THEN
@windows
ENDIF
ELSE
@goodbye
ENDIF
RETURN
'
> PROCEDURE edmarkdel
LOCAL j
IF sms2<>0 THEN
FOR j=1 TO 4
IF loops%(sms,j)<>-1 THEN
@markhlp8(sms,j,loops%(sms,j))
ENDIF
NEXT j
ENDIF
FOR j=1 TO 4
@selblkstxt(j,CHR$(0))
NEXT j
@textfeld(edmtxt&,CHR$(0),1)
IF sms2<>0 THEN
@selblkshak(sms2,0)
ELSE
@setbutton(edmbuts&,0)
@setbutton(edmbute&,0)
@setbutton(edmbuti&,0)
@setbutton(edmbutr&,0)
ENDIF
RETURN
'
> PROCEDURE edmarksearch
LOCAL j,j2
j2=0
IF sms<>0 THEN
FOR j=4 TO 1 STEP -1    ! muû wieder auf 4 statt 2
IF loops%(sms,j)<>-1 THEN
j2=j
ENDIF
NEXT j
ENDIF
sms2=j2
@selblkshak(sms2,1)
RETURN
'
> PROCEDURE edslidemove(i)
@makehz
@sethertz
@edmarkdel
sms=i
@edmarksearch
@edmarkset(i)
RETURN
'
> PROCEDURE edmarkset(i)
LOCAL j
@makehz
@sethertz
'  @edmarkdel
sms=i
a$=STR$(sms)+CHR$(0)
@textfeld(edmnr&,a$,1)
a$=edmtxt$(sms)+CHR$(0)
@textfeld(edmtxt&,a$,1)
vsms=sms-1
@setslide(edmslide&,edmbut&,loopz,5,vsms)
'  @edmarksearch
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
FOR j=1 TO 4
IF loops%(sms,j)<>-1 THEN
@marktextsel(j)
@markhlp6(loops%(sms,j))
@markhlp3(sms,j,loops%(sms,j))
ENDIF
NEXT j
ENDIF
RETURN
'
> PROCEDURE edmarkset2(o,i,i2)
LOCAL j,j2
IF loops%(i,i2)<>-1 AND i2<>0 THEN
@markhlp8(i,i2,o)
ENDIF
IF i2<>sms2 AND sms2<>0 THEN
@selblkshak(sms2,0)
@selblkshak(i2,1)
ENDIF
sms2=i2
IF i>0 AND i<=loopz AND i2<>0 THEN
IF loops%(i,i2)<>-1 THEN
@marktextsel(i2)
@markhlp6(loops%(i,i2))
@markhlp3(i,i2,loops%(i,i2))
ENDIF
ENDIF
RETURN
'
> PROCEDURE edmtextin
LOCAL a
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=mrktxtin&
@rsc_draw(nr,0)
@wischwasch
@markhlp
a$=edmtxt$(sms)
IF LEN(a$)>30 THEN
a$=LEFT$(a$,30)+CHR$(0)
ENDIF
a$=a$+CHR$(0)
@editfeld(mtex&,a$)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>mtex&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=mtexhelp& THEN
@helptxt("MARKER-TEXT")
ENDIF
UNTIL obj=mtexex& OR obj=mtexok&
IF obj=mtexok& THEN
editread(mtex&)
a=INSTR(a$,CHR$(0))
IF a>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
IF LEN(a$)>30 THEN
a$=LEFT$(a$,30)
ENDIF
edmtxt$(sms)=a$
ENDIF
@setbutton(obj,0)
@restaura2
IF obj=mtexok& THEN
a$=edmtxt$(sms)+CHR$(0)
@textfeld(mrkobj,a$,1)
ENDIF
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE edmftim(a)
IF tedart=0 THEN
IF vornr=trakker& THEN
sc=a/thz
ENDIF
IF vornr=arranger& THEN
sc=a/vhz
ENDIF
ELSE
sc=INT(a)
ENDIF
a$=STR$(sc)
a$=LEFT$(a$+SPACE$(9),9)+CHR$(0)
RETURN
'
> PROCEDURE edmfsetnr(i)
a$=STR$(i)+CHR$(0)
@textfeld(mrkfnr&,a$,1)
IF bloops%(i,1)<>-1 THEN
@edmftim(bloops%(i,1))
ELSE
a$=CHR$(0)
ENDIF
@textfeld(mrkftims&,a$,1)
IF bloops%(i,2)<>-1 THEN
@edmftim(bloops%(i,2))
ELSE
a$=CHR$(0)
ENDIF
@textfeld(mrkftime&,a$,1)
IF bloops%(i,3)<>-1 THEN
@edmftim(bloops%(i,3))
ELSE
a$=CHR$(0)
ENDIF
@textfeld(mrkftimi&,a$,1)
IF bloops%(i,4)<>-1 THEN
@edmftim(bloops%(i,4))
ELSE
a$=CHR$(0)
ENDIF
@textfeld(mrkftimr&,a$,1)
a$=vedmtxt$(i)+CHR$(0)
@textfeld(mrkftxt&,a$,1)
RETURN
'
> PROCEDURE mrkfslidemove(i)
@makehz
@sethertz
edsms=i
@edmfsetnr(i)
RETURN
'
> PROCEDURE edmfind
LOCAL a
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=mrkfind&
@rsc_draw(nr,0)
@wischwasch
@markhlp
@slideinit(mrkfslid&,mrkfbut&,loopz,5,vedsms)
@setslide(mrkfslid&,mrkfbut&,loopz,5,vedsms)
edsms=1
@edmfsetnr(edsms)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=mrkfhelp& THEN
@helptxt("MARKER-WAHL")
ENDIF
IF obj=mrkfup& THEN
@slideup(mrkfslid&,mrkfbut&,loopz,1,5,vedsms,slflg)
IF slflg=TRUE THEN
@mrkfslidemove(vedsms+1)
ENDIF
@setbutton(mrkfup&,0)
ENDIF
IF obj=mrkfdown& THEN
@slidedwn(mrkfslid&,mrkfbut&,loopz,1,5,vedsms,slflg)
IF slflg=TRUE THEN
@mrkfslidemove(vedsms+1)
ENDIF
@setbutton(mrkfdown&,0)
ENDIF
UNTIL obj=mrkfex& OR obj=mrkfok&
@setbutton(obj,0)
@restaura2
IF obj=mrkfok& THEN
edmfind=TRUE
ELSE
edmfind=FALSE
ENDIF
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE indrag(sobj,dobj,dobj2,masterbox,xtd,ytd,txb,tyb,clipnr,eda,VAR dragart,dragvar)
LOCAL z,bx,by,tdragm
tdragm=FALSE
mobj2=sobj
@markhlp
xd=ax&
yd=ay&
~@xrsrc_gaddr(0,nr,zu%)
@readpos(sobj)
GRAPHMODE 3
@mouse(vmp,vmp2,v3)
vm=vmp
vm2=vmp2
~GRAF_MOUSE(256,0)                              ! Hidem
@buttbh(masterbox,mxb,myb)
ag=@rsc_get2(xd+bx+xtd,yd+by+ytd,txb,tyb,eda)
ag2=@rsc_get(xd+bx+xtd,yd+by+ytd,txb,tyb)
@rsc_put(ag2,xd+bx+xtd,yd+by+ytd,1)
REPEAT
@mouse(v,v2,k)
@dragxygrenz(0,mxb-txb,0,myb-tyb,txb,tyb)
IF k=1 AND (v<>vm OR v2<>vm2) THEN
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
ag2=@rsc_get2(xd+bx+xtd+(v-vmp),yd+by+ytd+(v2-vmp2),txb,tyb,ag2)
@rsc_put(ag,xd+bx+xtd+(v-vmp),yd+by+ytd+(v2-vmp2),1)
vm=v
vm2=v2
ENDIF
fobj=OBJC_FIND(zu%,0,10,v,v2)
IF fobj=dobj OR fobj=dobj2 THEN
@readbutton(fobj)
IF dragart=0 AND buttflag=0 THEN
@setbutton(fobj,1)
ENDIF
IF dragart<>0 AND buttflag=1 AND tdragm=FALSE THEN
@setbutton(fobj,0)
PAUSE 4
@setbutton(fobj,1)
ENDIF
tdragm=TRUE
mdobj=fobj
ENDIF
IF fobj<>dobj AND fobj<>dobj2 AND tdragm=TRUE THEN
tdragm=FALSE
@readbutton(mdobj)
IF dragart=0 AND buttflag<>0 THEN
@setbutton(mdobj,0)
ENDIF
IF dragart<>0 AND buttflag<>1 THEN
@setbutton(mdobj,1)
ENDIF
ENDIF
UNTIL k=0
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
~GRAF_MOUSE(257,0)                              ! Showm
IF (fobj=dobj OR fobj=dobj2) AND tdragm=TRUE THEN
@setbutton(fobj,0)
FOR i=0 TO 2
PAUSE 2
@setbutton(fobj,0)
PAUSE 2
@setbutton(fobj,1)
NEXT i
dragart=clipnr
ENDIF
GRAPHMODE 3
IF tdragm=TRUE THEN
dragvar=TRUE
ENDIF
~MFREE(ag2)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE dragdestok
dragdok=FALSE
IF nr=smpedit& THEN
IF dobj=edmnr& AND edcart=1 THEN
dragdok=TRUE
ENDIF
IF (dobj=edmbuts& OR dobj=edmbute& OR dobj=edmbuti& OR dobj=edmbutr&) AND edcart>1 THEN
dragdok=TRUE
ENDIF
ENDIF
IF nr=arranger& THEN
IF ((dobj=arrm1& AND arrcok1=TRUE) OR (dobj=arrm2& AND arrcok2=TRUE) OR (dobj=arrm3& AND arrcok3=TRUE) OR (dobj=arrm4& AND arrcok4=TRUE)) AND arrcart<>0 THEN
dragdok=TRUE
ENDIF
ENDIF
IF nr=trakker& THEN
IF ((dobj=trakk1& AND trkcok1=TRUE) OR (dobj=trakk2& AND trkcok2=TRUE) OR (dobj=trakk3& AND trkcok3=TRUE) OR (dobj=trakk4& AND trkcok4=TRUE)) AND trkcart<>0 THEN
dragdok=TRUE
ENDIF
ENDIF
RETURN
'
> PROCEDURE dragdestdel
IF nr=smpedit& AND edcart>1 AND edcart<6 THEN
@setbutton(edmbuts&,0)
@setbutton(edmbute&,0)
@setbutton(edmbuti&,0)
@setbutton(edmbutr&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(arrm1&,0)
@setbutton(arrm2&,0)
@setbutton(arrm3&,0)
@setbutton(arrm4&,0)
ENDIF
IF nr=trakker& THEN
@setbutton(trakk1&,0)
@setbutton(trakk2&,0)
@setbutton(trakk3&,0)
@setbutton(trakk4&,0)
ENDIF
RETURN
'
> PROCEDURE outdrag(sobj,masterbox,xtd,ytd,txb,tyb,dragart,eda,VAR dragvar)
LOCAL z,bx,by
IF dragart<>0 THEN
@markhlp
tdrag2=FALSE
xd=ax&
yd=ay&
~@xrsrc_gaddr(0,nr,zu%)
@readpos(sobj)
GRAPHMODE 3
@mouse(vmp,vmp2,v3)
vm=vmp
vm2=vmp2
~GRAF_MOUSE(256,0)                              ! Hidem
@buttbh(masterbox,mxb,myb)
ag2=@rsc_get(xd+bx+xtd,yd+by+ytd,txb,tyb)
@rsc_put(ag2,xd+bx+xtd,yd+by+ytd,1)
REPEAT
@mouse(v,v2,k)
@dragxygrenz(0,mxb-txb,0,myb-tyb,txb,tyb)
IF k=1 AND (v<>vm OR v2<>vm2) THEN
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
ag2=@rsc_get2(xd+bx+xtd+(v-vmp),yd+by+ytd+(v2-vmp2),txb,tyb,ag2)
@rsc_put(eda,xd+bx+xtd+(v-vmp),yd+by+ytd+(v2-vmp2),1)
vm=v
vm2=v2
ENDIF
dobj=OBJC_FIND(zu%,0,10,v,v2)
@dragdestok
IF dragdok=TRUE THEN
@readbutton(dobj)
IF buttflag=0 THEN
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
@setbutton(dobj,1)
ag2=@rsc_get2(xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),txb,tyb,ag2)
tdrag2=TRUE
mobj=dobj
ENDIF
ENDIF
IF dragdok=FALSE AND tdrag2=TRUE THEN
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
@setbutton(mobj,0)
@dragdestdel
ag2=@rsc_get2(xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),txb,tyb,ag2)
@rsc_put(eda,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
tdrag2=FALSE
ENDIF
UNTIL k=0
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
~GRAF_MOUSE(257,0)                              ! Showm
IF tdrag2=TRUE THEN
@setbutton(mobj2,0)
@setbutton(mobj,1)
FOR i=0 TO 2
PAUSE 2
@setbutton(mobj,0)
PAUSE 2
@setbutton(mobj,1)
NEXT i
dragvar=TRUE
ENDIF
GRAPHMODE 3
ENDIF
~MFREE(ag2)
GRAPHMODE 1
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE dragedm
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by
dmobj=obj
'  edcart=0
'  edcart2=0
@readpos(editbox&)
drmx=bx
drmy=by
@readpos(editbox3&)
drmx=drmx+bx+1
drmy=drmy+by-35
@buttbh(dmobj,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
z=0
IF dmobj=edmnr& THEN
z=1
ENDIF
IF dmobj=edmbuts& THEN
z=2
ENDIF
IF dmobj=edmbute& THEN
z=3
ENDIF
IF dmobj=edmbuti& THEN
z=4
ENDIF
IF dmobj=edmbutr& THEN
z=5
ENDIF
IF z>1 AND z<6 THEN
@readpos(edmbox&)
drmx=drmx+bx
drmy=drmy+by
ENDIF
edcart2=1
IF z=1 THEN
IF edaz1=0 THEN
@readpos(dmobj)
eda1=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
edab1=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
eda=eda1
edaz1=1
ELSE
eda=eda1
ENDIF
ENDIF
IF z>1 AND z<6 THEN
IF edaz2=0 THEN
@readpos(dmobj)
eda2=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
edab2=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
eda=eda2
edaz2=1
ELSE
eda=eda2
ENDIF
ENDIF
vedcart=edcart
vidrag=idrag
IF idrag=FALSE THEN
edcart=0
ENDIF
idrag=FALSE
@indrag(dmobj,flyer&,trash&,editbox7&,drmx,drmy,drtxb,drtyb,z,eda,edcart,idrag)
IF fobj=flyer& THEN
IF edcart<>0 AND idrag=TRUE THEN
edcwert=sms
ENDIF
IF edcart=1 AND idrag=TRUE THEN
edcwertx1=loops%(sms,1)
edcwertx2=loops%(sms,2)
edcwertx3=loops%(sms,3)
edcwertx4=loops%(sms,4)
edcwertx$=edmtxt$(sms)
ENDIF
IF edcart>1 AND edcart<6 AND idrag=TRUE THEN
edcwert2=loops%(sms,edcart-1)
ENDIF
IF edcart>1 AND edcart<6 THEN
@setbutton(dmobj,1)
ENDIF
ENDIF
IF fobj=trash& THEN
IF edcart=1 AND idrag=TRUE THEN
@markhlp
@edmarkdel
FOR j=1 TO 4
loops%(sms,j)=-1
NEXT j
edmtxt$(sms)=""
ENDIF
IF edcart>1 AND edcart<6 AND idrag=TRUE THEN
o=loops%(sms,edcart-1)
@markhlp
loops%(sms,edcart-1)=-1
@markhlp8(sms,edcart-1,o)
@selblkshak(edcart-1,0)
@edmarksearch
ENDIF
edcart=vedcart
@setbutton(trash&,0)
idrag=FALSE
ENDIF
IF edcart=1 OR dmobj=edmnr& THEN
@setbutton(edmnr&,0)
ENDIF
IF idrag=FALSE AND vidrag=TRUE THEN                  ! zurÅckholen
idrag=TRUE
IF edaz1=1 AND edcart=1 THEN
@buttbh(edmnr&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=edab1
FOR i=eda1 TO eda1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
IF edaz2=1 AND edcart>1 AND edcart<6 THEN
@buttbh(edmbuts&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=edab2
FOR i=eda2 TO eda2+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
ELSE                                            ! retten
IF edaz1=1 AND edcart=1 THEN
@buttbh(edmnr&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=eda1
FOR i=edab1 TO edab1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
IF edaz2=1 AND edcart>1 AND edcart<6 THEN
@buttbh(edmbuts&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=eda2
FOR i=edab2 TO edab2+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
ENDIF
edcart2=0
@markhlp
@drawbutton(flyer&)
@setbutton(trash&,0)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE clipdel
edcart=0
edcart2=0
edcart3=0
idrag=FALSE
@setbutton(flyer&,0)
RETURN
'
> PROCEDURE dragedclip
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by,o
IF ((edcart=1 AND edaz1=1) OR (edcart>1 AND edcart<6 AND edaz2=1)) AND idrag=TRUE THEN
dmobj=obj
@readpos(editbox&)
drmx=bx
drmy=by
IF edcart=1 THEN
@buttbh(edmnr&,drtxb,drtyb)
ENDIF
IF edcart>1 AND edcart<6 THEN
drmy=drmy-25
@buttbh(edmbuts&,drtxb,drtyb)
SELECT sms2
CASE 1
@setbutton(edmbuts&,0)
CASE 2
@setbutton(edmbute&,0)
CASE 3
@setbutton(edmbuti&,0)
CASE 4
@setbutton(edmbutr&,0)
ENDSELECT
ENDIF
drtxb=drtxb+3
drtyb=drtyb+2
idrag2=FALSE
edcart3=1
IF edcart=1 THEN
eda=eda1
ENDIF
IF edcart>1 AND edcart<6 THEN
eda=eda2
ENDIF
@outdrag(flyer&,editbox7&,drmx,drmy,drtxb,drtyb,edcart,eda,idrag2)
@markhlp
IF edcart=0 AND dmobj=flyer& AND idrag=FALSE THEN
@setbutton(flyer&,0)
ENDIF
IF edcart>1 AND edcart<6 THEN
@setbutton(edmbuts&,0)
@setbutton(edmbute&,0)
@setbutton(edmbuti&,0)
@setbutton(edmbutr&,0)
ENDIF
IF edcart=1 AND idrag2=TRUE THEN
@makehz
@sethertz
@edmarkdel
loops%(sms,1)=edcwertx1
loops%(sms,2)=edcwertx2
loops%(sms,3)=edcwertx3
loops%(sms,4)=edcwertx4
edmtxt$(sms)=edcwertx$
@edmarksearch
@edmarkset(sms)
@setbutton(edmnr&,0)
ENDIF
IF edcart>1 AND edcart<6 AND idrag2=TRUE THEN
@makehz
@sethertz
IF dobj=edmbuts& THEN
sms2=1
ENDIF
IF dobj=edmbute& THEN
sms2=2
ENDIF
IF dobj=edmbuti& THEN
sms2=3
ENDIF
IF dobj=edmbutr& THEN
sms2=4
ENDIF
o=loops%(sms,sms2)
@markhlp
loops%(sms,sms2)=edcwert2
@edmarkset2(o,sms,sms2)
ENDIF
IF edcart>1 AND edcart<6 THEN
SELECT sms2
CASE 1
@setbutton(edmbuts&,1)
CASE 2
@setbutton(edmbute&,1)
CASE 3
@setbutton(edmbuti&,1)
CASE 4
@setbutton(edmbutr&,1)
ENDSELECT
ENDIF
edcart3=0
@markhlp
ELSE
@setbutton(obj,0)
ENDIF
@drawbutton(flyer&)
@setbutton(trash&,0)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE arrdragin
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by
IF arrpath$(arrherr)<>"" THEN
dmobj=obj
@readpos(arrbox3&)
drmx=bx+1
drmy=by-35
@buttbh(dmobj,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
z=0
IF dmobj=arrm1& THEN
z=1
ENDIF
IF dmobj=arrm2& THEN
z=2
ENDIF
IF dmobj=arrm3& THEN
z=3
ENDIF
IF dmobj=arrm4& THEN
z=4
ENDIF
arrcart2=1
IF bbarrz1=0 THEN
@readpos(dmobj)
bbarr1=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
eda=bbarr1
bbarrz1=1
ELSE
eda=bbarr1
ENDIF
vadrag=adrag
IF adrag=FALSE THEN
arrcart=0
ENDIF
adrag=FALSE
'
@indrag(dmobj,arrclip&,arrclip&,arrbox&,drmx,drmy,drtxb,drtyb,z,eda,arrcart,adrag)
'
IF fobj=arrclip& THEN
IF arrcart<>0 AND adrag=TRUE THEN
arrcwert=arrherr
arrcwert2$=arrfn$(arrherr)
arrcwert3$=arrpath$(arrherr)
arrcwert4=arrstrt(arrherr)
arrcwert5=arrend(arrherr)
arrcwert6=arrlen(arrherr)
'      arrcwert7=arrmidi(arrherr)
arrcwert8=arrloop(arrherr)
arrcwert9=arrtri(arrherr)
arrcwert10=arrsrate(arrherr)
ENDIF
ENDIF
'
IF adrag=FALSE AND vadrag=TRUE THEN
adrag=TRUE
ENDIF
arrcart2=0
@markhlp
ENDIF
@drawbutton(arrclip&)
'
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE arrdragclip
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by,o,a
IF arrcart<>0 AND adrag=TRUE AND bbarrz1=1 AND arrpath$(arrcwert)<>"" THEN
dmobj=obj
drmx=0
drmy=-32
@buttbh(arrm1&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
adrag2=FALSE
arrcart3=1
eda=bbarr1
IF arrpath$(pbz+1)="" THEN
arrcok1=TRUE
ELSE
arrcok1=FALSE
ENDIF
IF arrpath$(pbz+2)="" THEN
arrcok2=TRUE
ELSE
arrcok2=FALSE
ENDIF
IF arrpath$(pbz+3)="" THEN
arrcok3=TRUE
ELSE
arrcok3=FALSE
ENDIF
IF arrpath$(pbz+4)="" THEN
arrcok4=TRUE
ELSE
arrcok4=FALSE
ENDIF
@setbutton(arrm1&,0)
@setbutton(arrm2&,0)
@setbutton(arrm3&,0)
@setbutton(arrm4&,0)
@outdrag(arrclip&,arrbox&,drmx,drmy,drtxb,drtyb,arrcart,eda,adrag2)
IF arrcart=0 AND dmobj=arrclip& AND adrag=FALSE THEN
@setbutton(arrclip&,0)
ENDIF
IF arrcart<>0 AND adrag2=TRUE THEN
IF dobj=arrm1& THEN
z=1
ENDIF
IF dobj=arrm2& THEN
z=2
ENDIF
IF dobj=arrm3& THEN
z=3
ENDIF
IF dobj=arrm4& THEN
z=4
ENDIF
arrfn$(pbz+z)=arrcwert2$
arrpath$(pbz+z)=arrcwert3$
arrstrt(pbz+z)=arrcwert4
arrend(pbz+z)=arrcwert5
arrlen(pbz+z)=arrcwert6
'      arrmidi(pbz+z)=arrcwert7
arrloop(pbz+z)=arrcwert8
arrtri(pbz+z)=arrcwert9
arrsrate(pbz+z)=arrcwert10
obj=mobj
'      @setbutton(arrclip&,0)
spring=TRUE
@markhlp
obj=dobj
@arrtowork
spring=FALSE
@arrnrset
obj=0
ENDIF
arrcart3=0
@markhlp
a=arrherr-pbz
SELECT a
CASE 1
@setbutton(arrm1&,1)
CASE 2
@setbutton(arrm2&,1)
CASE 3
@setbutton(arrm3&,1)
CASE 4
@setbutton(arrm4&,1)
ENDSELECT
ELSE
'    adrag=FALSE
@setbutton(obj,0)
ENDIF
@drawbutton(arrclip&)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE trkdragin
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by,i,i2,l
IF trkpnt(trakact)<>0 THEN
dmobj=obj
@readpos(trakbox2&)
drmx=bx+1
drmy=by-35
z=0
IF dmobj=trakk1& THEN
z=1
tbxd=trkbx1&
ENDIF
IF dmobj=trakk2& THEN
z=2
tbxd=trkbx2&
ENDIF
IF dmobj=trakk3& THEN
z=3
tbxd=trkbx3&
ENDIF
IF dmobj=trakk4& THEN
z=4
tbxd=trkbx4&
ENDIF
@readpos(tbxd)
drmx=drmx+bx
drmy=drmy+by
@buttbh(dmobj,drtxb,drtyb)
drtxb=drtxb+2
drtyb=drtyb+2
trkcart2=1
IF bbtrkz1=0 THEN
@readpos(dmobj)
bbtrk1=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
bbtrkb1=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
eda=bbtrk1
bbtrkz1=1
ELSE
eda=bbtrk1
ENDIF
vtrdrag=trdrag
IF trdrag=FALSE AND tdrag=FALSE THEN
trkcart=0
ENDIF
trdrag=FALSE
'
@indrag(dmobj,trakclip&,trakclip&,trakbox&,drmx,drmy,drtxb,drtyb,z,eda,trkcart,trdrag)
'
IF fobj=trakclip& THEN
IF trkcart<>0 AND trdrag=TRUE THEN
tdrag=FALSE
tdrag2=FALSE
trkcwert=trakact
clipart=1
ENDIF
ENDIF
IF trdrag=FALSE AND vtrdrag=TRUE THEN
trdrag=TRUE
tdrag=FALSE
tdrag2=FALSE
@buttbh(trakk1&,drtxb,drtyb)
drtxb=drtxb+2
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=bbtrkb1
FOR i=bbtrk1 TO bbtrk1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ELSE
@buttbh(trakk1&,drtxb,drtyb)
drtxb=drtxb+2
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=bbtrk1
FOR i=bbtrkb1 TO bbtrkb1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
trkcart2=0
@markhlp
ENDIF
@drawbutton(trakclip&)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE trkdragclip
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by,o
IF clipart=1 THEN
IF trkcart<>0 AND trdrag=TRUE AND bbtrkz1=1 AND trkpnt(trkcwert)<>0 THEN
dmobj=obj
@readpos(trakbox3&)
drmx=bx+1
drmy=by-35
@buttbh(trakk1&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
trdrag2=FALSE
trkcart3=1
eda=bbtrk1
IF trkpnt(trkvz+1)=0 THEN
trkcok1=TRUE
ELSE
trkcok1=FALSE
ENDIF
IF trkpnt(trkvz+2)=0 THEN
trkcok2=TRUE
ELSE
trkcok2=FALSE
ENDIF
IF trkpnt(trkvz+3)=0 THEN
trkcok3=TRUE
ELSE
trkcok3=FALSE
ENDIF
IF trkpnt(trkvz+4)=0 THEN
trkcok4=TRUE
ELSE
trkcok4=FALSE
ENDIF
@setbutton(trakk1&,0)
@setbutton(trakk2&,0)
@setbutton(trakk3&,0)
@setbutton(trakk4&,0)
@outdrag(trakclip&,trakbox&,drmx,drmy,drtxb,drtyb,trkcart,eda,trdrag2)
IF trkcart=0 AND dmobj=trakclip& AND trdrag=FALSE AND tdrag=FALSE THEN
@setbutton(trakclip&,0)
ENDIF
IF trkcart<>0 AND trdrag2=TRUE THEN
IF dobj=trakk1& THEN
z=1
ENDIF
IF dobj=trakk2& THEN
z=2
ENDIF
IF dobj=trakk3& THEN
z=3
ENDIF
IF dobj=trakk4& THEN
z=4
ENDIF
trakact=trkvz+z
@markhlp
@alltrakcopy(trkcwert,trakact)
obj=dobj
'        @setbutton(trakclip&,0)
obj=0
ENDIF
trkcart3=0
@markhlp
ELSE
'    trdrag=FALSE
'        @setbutton(trakclip&,0)
ENDIF
@trakbutset(1)
ENDIF
IF clipart=2 AND tdrag=TRUE THEN
tdrag2=TRUE
atrkp=merkclip
@trakdrag
tdrag2=FALSE
ENDIF
@drawbutton(trakclip&)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE do_smpedit
.| Glob. Var.: smpedit&,zu%,buttadr#,obj#,but#,rate&,digana#,a$,popups&
.|     smppopup&,popup&,mover&,popmark&,smpl1&,smpl2&,smpl3&,smpr1&,smpr2&
.|     smpr3&,objflag#,zuadr#,smpcblk&,pixzoom&,ce#,cs#,xm#,vmem#,zomslide&
.|     zoombutt&,zmax#,zoomp#,scrlslde&,scrolbut&,scmax#,scrollp#,cached#
.|     zooml&,slflg#,zoomr&,lscroll&,scslc#,scteil#,scrolm#,rscroll&,a#
.|     swdsp&,smplen&,smpsec&,blocfunc&,smpfile&,clock&,trak&,smpanf&
.|     smpend&,smpmid&,smpload&,smpsta&,smpstb&,smpstc&,smpstd&,smpste&
.|     smpea&,smpeb&,smpec&,smped&,smpee&,smpsave&,smpplay&,smppmark&
.|     smploop&,peaksw2&,hard&,virtual#,blkstore&,loopart&,loopauto&,edmidi&
.|     edfade&,midi&,smpsavl&,smpsavr&,smpauto2&,smpstrt2&,monitor&,arrange&
.|     setuper&,edsmp16&,infoicon&,trash&,coptoarr&,smptsa&,smptsb&,smptsc&
.|     smptsd&,smptse&,smptsava&,smptea&,smpteb&,smptec&,smpted&,smptee&
.|     smptsavb&,cstxt&,cetxt&,smpedhlp&,smpexit&,mrce#,mrcs#,mrzoom#
.|     mrscroll#
.| Ruft auf  : xrsrc_gaddr,textfeld,adlow,fnamwrite,admid,adhigh,ext32l
.|     ext44l,ext48l,ext32h,ext44h,ext48h,ext256,ext384,smpmark,smpzoom
.|     smpscrol,smpkopie,smpmove,smpinsert,smpmerge,makefade,setbutton,smpl
.|     smpr,smpcblkplay,zslidecalc,setslide,makepnt,scrollinit,restaura
.|     slideup,textbutt,zoomcalc,slidedwn,dspwahl,smplen,smpsec,blkfunc
.|     smpinfbutt,abackup,trakker,smpanf,smpend,smpmid,smpload,smpstx,smpex
.|     smpsave,smpplay,smppmark,smploop,peak,harddisk,blkstore,loopwahl
.|     loopauto,midi,fade,machmidi,smpsts,smpes,smpauto,smpstart,monitor
.|     arranger,setupdat,main,info,trash,copytoarr,time_edit,helptxt
.| Aufruf in : windows-1,
~@xrsrc_gaddr(0,smpedit&,zu%)
buttadr=zu%+24*obj
but=(DPEEK(buttadr+6)) AND 255
IF but=22 THEN
IF obj=rate& AND digana=TRUE THEN
@testsrate
IF (retime=0 OR (retime=1 AND tstsr=FALSE)) THEN
a$=@rsc_text$(popups&,smppopup&+popup&)
@textfeld(obj,a$,1)
IF popup&<>0 THEN
IF popup&=1 THEN
@adlow
@fnamwrite
ENDIF
IF popup&=2 THEN
@admid
@fnamwrite
ENDIF
IF popup&=3 THEN
@adhigh
@fnamwrite
ENDIF
IF popup&=4 THEN
@admid96
@fnamwrite
ENDIF
IF popup&=5 THEN
@adhigh96
@fnamwrite
ENDIF
IF popup&=6 THEN
@ad8
@fnamwrite
ENDIF
IF popup&=7 THEN
@ad11
@fnamwrite
ENDIF
IF popup&=8 THEN
@ad12
@fnamwrite
ENDIF
IF popup&=9 THEN
@ad16
@fnamwrite
ENDIF
IF popup&=10 THEN
@ad17
@fnamwrite
ENDIF
IF popup&=11 THEN
@ad22
@fnamwrite
ENDIF
IF popup&=12 THEN
@ad24
@fnamwrite
ENDIF
IF popup&=13 THEN
@ad33
@fnamwrite
ENDIF
IF popup&=14 THEN
@adexth2
@fnamwrite
ENDIF
IF popup&=15 THEN
@adextl2
@fnamwrite
ENDIF
IF popup&=16 THEN
@adexth1
@fnamwrite
ENDIF
IF popup&=17 THEN
@adextl1
@fnamwrite
ENDIF
IF popup&=18 THEN
@addiv
@fnamwrite
ENDIF
@kickstart
obj=0
ENDIF
ENDIF
ENDIF
IF obj=mover& THEN
a$=@rsc_text$(popups&,popmark&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@smpmark
ENDIF
IF popup&=2 THEN
@smpzoom
ENDIF
IF popup&=3 THEN
@smpscrol
ENDIF
IF popup&=4 THEN
@smpkopie
ENDIF
IF popup&=5 THEN
@smpmove
ENDIF
IF popup&=6 THEN
@smpinsert
ENDIF
IF popup&=7 THEN
@smpmerge
ENDIF
IF popup&=8 THEN
@makefade
ENDIF
obj=0
ENDIF
ENDIF
IF nr=smpedit& AND obj=smpexit& THEN
leaveprog=TRUE
ENDIF
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& OR obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@setbutton(obj,1)
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
@smpl
ENDIF
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@smpr
ENDIF
IF obj=smpcblk& THEN
@smpcblkplay
@setbutton(smpcblk&,0)
ENDIF
IF obj=disk& THEN
@diskmenu
ENDIF
IF obj=pixzoom& THEN
ce=cs+(xm*mbit)-1
IF ce>vmem THEN
ce=INT(vmem/mbit)*mbit
cs=ce-(xm*mbit)+1
ENDIF
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
@scrollinit
@setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
@setbutton(pixzoom&,0)
cached=FALSE
@restaura
ENDIF
IF obj=zooml& THEN
@slideup(zomslide&,zoombutt&,zmax,1,16,zoomp,slflg)
IF slflg=TRUE THEN
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@zoomcalc
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
ENDIF
@setbutton(zooml&,0)
ENDIF
IF obj=zoomr& THEN
@slidedwn(zomslide&,zoombutt&,zmax,1,16,zoomp,slflg)
IF slflg=TRUE THEN
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@zoomcalc
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
ENDIF
@setbutton(zoomr&,0)
ENDIF
IF obj=lscroll& THEN
sdif=(ce-cs)/scmax
sdif=sdif/(scteil/(ce-cs))
IF sdif>1 THEN
sdif=1
ENDIF
@slideup2(scrlslde&,scrolbut&,scmax,sdif,scrollp,slflg)
IF slflg=TRUE THEN
scrolm=ce-cs
cs=scrollp*scteil
ce=scrolm+scrollp*scteil
cs=INT(cs/mbit)*mbit
ce=INT(ce/mbit)*mbit
cached=FALSE
@restaura
ENDIF
@setbutton(lscroll&,0)
ENDIF
IF obj=rscroll& THEN
sdif=(ce-cs)/scmax
sdif=sdif/(scteil/(ce-cs))
IF sdif>1 THEN
sdif=1
ENDIF
'    PRINT scrollp
@slidedwn2(scrlslde&,scrolbut&,scmax,scstep,sdif,scrollp,slflg)
IF slflg=TRUE THEN
scrolm=ce-cs
a=scrolm+scrollp*scteil
IF a<=vmem THEN
ce=a
cs=scrollp*scteil
ELSE
cs=vmem-scrolm
ce=vmem
ENDIF
cs=INT(cs/mbit)*mbit
ce=INT(ce/mbit)*mbit
cached=FALSE
@restaura
ENDIF
@setbutton(rscroll&,0)
ENDIF
IF obj=edmup& THEN
@slideup(edmslide&,edmbut&,loopz,1,5,vsms,slflg)
IF slflg=TRUE THEN
@edslidemove(vsms+1)
ENDIF
@setbutton(edmup&,0)
ENDIF
IF obj=edmdown& THEN
@slidedwn(edmslide&,edmbut&,loopz,1,5,vsms,slflg)
IF slflg=TRUE THEN
@edslidemove(vsms+1)
ENDIF
@setbutton(edmdown&,0)
ENDIF
IF obj=edmtxt& THEN
@edmtextin
ENDIF
IF obj=edmnr& THEN
k=@mousek
IF k=1 THEN
@dragedm
ELSE
@marknrinp
ENDIF
ENDIF
'
IF obj=swmark& THEN
nmarkmode=1
@setmarkmode
ENDIF
IF obj=swblk& THEN
nmarkmode=2
@setmarkmode
ENDIF
IF obj=scrubs& THEN
nmarkmode=3
@setmarkmode
ENDIF
IF obj=swsearch& THEN
nmarkmode=4
@setmarkmode
ENDIF
IF obj=swyzoom& THEN
nmarkmode=5
@setmarkmode
ENDIF
IF obj=swclick& THEN
nmarkmode=6
@setmarkmode
ENDIF
IF obj=swdraw& THEN
nmarkmode=7
@setmarkmode
ENDIF
'
IF obj=swdsp& THEN
@setbutton(obj,1)
@dspwahl
ENDIF
IF obj=smplen& THEN
@smplen
ENDIF
IF obj=smpsec& THEN
@smpsec
ENDIF
IF obj=blocfunc& THEN
@setbutton(obj,1)
@blkfunc
ENDIF
IF obj=smpfile& THEN
@smpinfbutt
ENDIF
IF obj=clock& THEN
@abackup
ENDIF
IF obj=trak& THEN
@setbutton(obj,1)
@trakker
ENDIF
IF obj=flyer& THEN
@dragedclip
ENDIF
IF obj=smpanf& THEN
@smpanf
ENDIF
IF obj=smpend& THEN
@smpend
ENDIF
IF obj=smpmid& THEN
@smpmid
ENDIF
IF obj=smpload& THEN
@smpload
ENDIF
IF obj=smpdbank& THEN
vneufsel=neufsel
neufsel=TRUE
@smpload
neufsel=vneufsel
ENDIF
IF obj=edmbuts& THEN
@smpstx(sms,1)
@dragedm
ENDIF
IF obj=edmbute& THEN
@smpstx(sms,2)
@dragedm
ENDIF
IF obj=edmbuti& THEN
@smpstx(sms,3)
@dragedm
ENDIF
IF obj=edmbutr& THEN
@smpstx(sms,4)
@dragedm
ENDIF
IF obj=smpsave& THEN
@smpsave
ENDIF
IF obj=smpplay& OR (obj=smpwait& AND pwait=FALSE) THEN
IF obj=smpwait& THEN
pwait=TRUE
ENDIF
@smpplay
ENDIF
IF obj=smppmark& THEN
@smppmark
ENDIF
IF obj=smploop& THEN
@smploop
ENDIF
IF obj=peaksw2& THEN
@setbutton(obj,1)
@peak
ENDIF
IF obj=hard& THEN
IF virtual=FALSE THEN
@harddisk
ELSE
@setbutton(hard&,1)
ENDIF
ENDIF
IF obj=blkstore& THEN
@blkstore
ENDIF
IF obj=loopart& THEN
@setbutton(obj,1)
@loopwahl
ENDIF
IF obj=loopauto& THEN
@loopauto
ENDIF
IF obj=edmidi& THEN
@setbutton(obj,1)
@midi
ENDIF
IF obj=edfade& THEN
@setbutton(obj,1)
@fade
ENDIF
IF obj=midi& THEN
@machmidi
ENDIF
IF obj=smpauto2& THEN
@smpauto
ENDIF
IF obj=smpstrt2& THEN
@smpstart
ENDIF
IF obj=wmodes& THEN
@setbutton(obj,1)
@workmode
ENDIF
IF obj=recplay3& THEN
@smpstart
ENDIF
IF obj=arrange& THEN
@setbutton(obj,1)
@arranger
ENDIF
IF obj=setuper& THEN
@setupdat
ENDIF
IF obj=edsmp16& THEN
@setbutton(obj,1)
@main
ENDIF
IF obj=infoicon& THEN
@setbutton(obj,1)
@info
ENDIF
IF obj=trash& THEN
@trash
ENDIF
IF obj=coptoarr& THEN
'    @copytoarr
ENDIF
IF obj=edmtims& OR obj=edmtime& OR obj=edmtimi& OR obj=edmtimr& OR obj=cstxt& OR obj=cetxt& THEN
@time_edit
@setbutton(obj,0)
ENDIF
IF obj=smpedhlp& THEN
@helptxt("EDITOR")
ENDIF
IF obj=smpstop& THEN
@setbutton(smpstop&,0)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj<>smpexit& OR nr<>smpedit& THEN
'    obj=0
but=0
popup&=0
ENDIF
IF nr=smpedit& AND (ce-cs)<>(mrce-mrcs) AND obj<>smpexit& AND mrzoom=zoomp THEN
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
ENDIF
IF nr=smpedit& AND ce<>mrce OR cs<>mrcs AND mrscroll=scrollp THEN
@scrollinit
@setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
mrscroll=scrollp
ENDIF
IF nr=smpedit& AND obj=smpexit& THEN
cached=FALSE
@setbutton(smpexit&,0)
ENDIF
IF drawnew=TRUE THEN
drawnew=FALSE
@getcurve
ENDIF
RETURN
'
> PROCEDURE setmarkmode
@getmarkmode
@setbutton(omark,0)
markmode=nmarkmode
@setbutton(obj,1)
RETURN
'
> PROCEDURE getmarkmode
IF markmode=1 THEN
omark=swmark&
ENDIF
IF markmode=2 THEN
omark=swblk&
ENDIF
IF markmode=3 THEN
omark=scrubs&
ENDIF
IF markmode=4 THEN
omark=swsearch&
ENDIF
IF markmode=5 THEN
omark=swyzoom&
ENDIF
IF markmode=6 THEN
omark=swclick&
ENDIF
IF markmode=7 THEN
omark=swdraw&
ENDIF
RETURN
'
> PROCEDURE gettrmode
IF trmode=1 THEN
otmark=tblksel&
ENDIF
IF trmode=2 THEN
otmark=tblkmove&
ENDIF
IF trmode=3 THEN
otmark=tblkcopy&
ENDIF
IF trmode=4 THEN
otmark=tblkdrag&
ENDIF
IF trmode=5 THEN
otmark=tblkedit&
ENDIF
IF trmode=6 THEN
otmark=tblksnap&
ENDIF
IF trmode=7 THEN
otmark=tblkcut&
ENDIF
IF trmode=8 THEN
otmark=tblkvol&
ENDIF
RETURN
'
> PROCEDURE tmarkmode
@gettrmode
@setbutton(otmark,0)
trmode=ntrmode
@setbutton(obj,1)
RETURN
'
> PROCEDURE diskmenu
LOCAL pathda,g
mrkobj=obj
vorvornr=vornr
vornr=nr
IF neufsel=TRUE THEN
@newfsel
ELSE
@fileselect(op$+"*."+ext$,"","FIND:")
ENDIF
pathda=EXIST(fil$)
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pathda=TRUE AND pret<>0 AND pbutt=1 THEN
nr=disked&
@rsc_draw(nr,0)
@markhlp
REPEAT
UNTIL @mousek=0
a$=nam$+CHR$(0)
@textfeld(dskedtxt&,a$,1)
@editfeld(dskedit&,CHR$(0))
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1 AND obj<>dskedtxt&
edit_obj&=0
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=dskill& THEN
@headart2(fil$)
IF sfileart<>0 THEN
IF EXIST(fil$) AND fil$<>"" THEN
KILL fil$
dfil2$=LEFT$(fil$,INSTR(fil$,"."))+"INF"
IF EXIST(dfil2$) AND fil$<>"" THEN
KILL dfil2$
ENDIF
dfil2$=LEFT$(fil$,INSTR(fil$,"."))+"PBF"
IF EXIST(dfil2$) AND fil$<>"" THEN
KILL dfil2$
ENDIF
ENDIF
ENDIF
ENDIF
IF obj=dskren& THEN
@editread(dskedit&)
IF a$<>"" THEN
a$=a$+"."+RIGHT$(fil$,(LEN(fil$)-INSTR(fil$,".")))
ofil$=fil$
fil$=ordner$+a$
@headart2(fil$)
IF sfileart<>0 THEN
IF EXIST(ofil$) AND ofil$<>"" THEN
NAME ofil$ AS fil$
ENDIF
dfil2$=LEFT$(ofil$,INSTR(ofil$,"."))+"INF"
dfil3$=LEFT$(fil$,INSTR(fil$,"."))+"INF"
IF EXIST(dfil2$) AND dfil2$<>"" THEN
NAME dfil2$ AS dfil3$
ENDIF
dfil2$=LEFT$(ofil$,INSTR(ofil$,"."))+"PBF"
dfil3$=LEFT$(fil$,INSTR(fil$,"."))+"PBF"
IF EXIST(dfil2$) AND dfil2$<>"" THEN
NAME dfil2$ AS dfil3$
ENDIF
ENDIF
fil$=ofil$
ELSE
@alerts(42)
ENDIF
ENDIF
IF obj=dskedhlp& THEN
@helptxt("DISK-FUNKTIONEN")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=dskedex& OR obj=dskill& OR obj=dskren& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=dskedex& OR obj=dskill& OR obj=dskren&
@restaura2
ENDIF
obj=mrkobj
IF nr=smpedit& THEN
@setbutton(obj,0)
ENDIF
vornr=vorvornr
RETURN
'
> PROCEDURE time_edit
LOCAL notedok,robj,o,mrkobj,vorvornr,vornr
mrkobj=obj
vorvornr=vornr
vornr=nr
IF tedart=1 THEN
nr=timeed&
ELSE
a$="MARKER-TIME"+CHR$(0)
nr=record&
@textfeld2(record&,timemeld&,a$,1)
ENDIF
@rsc_draw(nr,0)
@markhlp
@makehz
t=0
IF obj=edmtims& THEN
t=1
ENDIF
IF obj=edmtime& THEN
t=2
ENDIF
IF obj=edmtimi& THEN
t=3
ENDIF
IF obj=edmtimr& THEN
t=4
ENDIF
IF t<>0 AND sms>0 AND sms<=loopz THEN
s=loops%(sms,t)
o=s
ENDIF
IF obj=cstxt& THEN
s=cs
t=98
ENDIF
IF obj=cetxt& THEN
s=ce
t=99
ENDIF
IF s=-1 THEN
s=0
ENDIF
IF tedart=1 THEN
@tedart
REPEAT
UNTIL @mousek=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1 AND obj<>tedtxt&
edit_obj&=0
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=tedhelp& THEN
@helptxt("EDIT-SAMPLES")
ENDIF
IF obj=tedok& THEN
@tedproof
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=tedexit& OR obj=tedok& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=tedexit& OR (obj=tedok& AND notedok=FALSE)
ELSE
u=INT(s/hz/mbit*100)
mmax=INT(vmem/hz/mbit*100)
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld(recfree&,a$,1)
REPEAT
REPEAT
@timeinp(mmax,u)
IF obj=rechelp& THEN
@helptxt("EDIT-SAMPLETIME")
ENDIF
UNTIL obj<>rechelp&
edit_obj&=0
IF obj=recok& THEN
s=u/100*hz*mbit
s=INT(s/mbit)*mbit
notedok=FALSE
IF s<0 OR s>vmem THEN
notedok=TRUE
@setbutton(obj,0)
@alerts(39)
ENDIF
ENDIF
UNTIL obj=recexit& OR (obj=recok& AND notedok=FALSE)
ENDIF
IF (obj=tedok& AND tedart=1) OR (obj=recok& AND tedart=0) THEN
IF t>0 AND t<5 AND sms>0 AND sms<=loopz THEN
loops%(sms,t)=s
ENDIF
IF t=98 THEN
cs=s
cached=FALSE
ENDIF
IF t=99 THEN
ce=s
cached=FALSE
ENDIF
ENDIF
@restaura2
IF ((obj=tedok& AND tedart=1) OR (obj=recok& AND tedart=0)) AND t>0 AND t<5 THEN
@edmarkset2(o,sms,t)
ENDIF
obj=mrkobj
IF nr=smpedit& THEN
@setbutton(obj,0)
ENDIF
vornr=vorvornr
IF (t=98 OR t=99) AND nr=smpedit& THEN
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
mrscroll=scrollp
@restaura
ENDIF
RETURN
'
> PROCEDURE tedart
.| Glob. Var.: tedart#,u#,s#,hz#,a$,tedtxt&
.| Ruft auf  : editfeld
.| Aufruf in : time_edit-3,
u=INT(s/mbit)
a$=RIGHT$("0000000000"+STR$(u),10)
a$=a$+CHR$(0)
@editfeld(tedtxt&,a$)
RETURN
'
> PROCEDURE tedproof
.| Glob. Var.: tedtxt&,notedok#,a$,i#,a#,s#,tedart#,hz#,vmem#,g#
.| Ruft auf  : editread
.| Aufruf in : time_edit-3,
@editread(tedtxt&)
notedok=FALSE
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF (a<48 OR a>57) AND a<>46 THEN
notedok=TRUE
ENDIF
IF (i=1 OR i=8) AND a=46 THEN
notedok=TRUE
ENDIF
NEXT i
ELSE
notedok=TRUE
ENDIF
IF notedok=FALSE THEN
s=VAL(a$)
s=s*mbit
s=INT(s/mbit)*mbit
IF s<0 OR s>vmem THEN
notedok=TRUE
@setbutton(obj,0)
@alerts(39)
ENDIF
ENDIF
RETURN
'
> PROCEDURE make                  ! von mehreren Samples die Sampleraten umrechnen und zu einem File zusammenfÅgen
.| Glob. Var.: mrkobj#,obj#,vorvornr#,vornr#,nr#,arrmake&,make$,maketxt&,hz#
.|     a$,popups&,make32&,makerate&,make44&,make48&,popup&,smpedit&,zu%
.|     zuadr#,buttadr#,but#,objflag#,makefsel&,op$,ext$,vext$,fil$,pret#
.|     pbutt#,nam$,makehelp&,makeok&,makexit&,i#,lmax2#,flen#,okay#,a2#
.|     virt$,mlen#,meml#,vln#,anf#,bytes#,len#,start#,virtp$,virtfile$
.| Felder    : arrpath$(),arrend#(),arrstrt#(),arrtri#(),arrsrate#()
.| Ruft auf  : rsc_draw,markhlp,makehz,textfeld,swtosrate,mousek,rsc_do
.|     xrsrc_gaddr,adlow,admid,adhigh,fileselect,rsc_back,helptxt,setbutton
.|     busy_mouse,arr_resmp,maschinit29,maschruf29,maschinit9,maschruf9
.|     nomem,restaura2
.| Aufruf in : do_arrange-1,
LOCAL mhz,nomem,a,b,c,d,e,mrkhz,vm
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=arrmake&
@rsc_draw(nr,0)
@markhlp
@makehz
make$="             "
@textfeld(maketxt&,make$,1)
mhz=2
IF hz=32000 THEN
a$=@rsc_text$(popups&,make32&)
@textfeld(makerate&,a$,1)
mhz=1
ENDIF
IF hz=44100 THEN
a$=@rsc_text$(popups&,make44&)
@textfeld(makerate&,a$,1)
mhz=2
ENDIF
IF hz=48000 THEN
a$=@rsc_text$(popups&,make48&)
@textfeld(makerate&,a$,1)
mhz=3
ENDIF
@swtosrate(hz)
REPEAT
UNTIL @mousek=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
IF obj=makerate& THEN
a$=@rsc_text$(popups&,popmake&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
mhz=1
@adlow
ENDIF
IF popup&=2 THEN
mhz=2
@admid
ENDIF
IF popup&=3 THEN
mhz=3
@adhigh
ENDIF
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=makefsel& THEN
@fileselect(op$+"*."+ext$,"","MAKEFILE:")
vext$=ext$
IF vext$="*" THEN
IF dig24=FALSE THEN
vext$="S16"
ELSE
vext$="S24"
ENDIF
ENDIF
IF RINSTR(fil$,".")=0 THEN
fil$=fil$+"."+vext$
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 THEN
@textfeld(maketxt&,nam$+CHR$(0),1)
ENDIF
ENDIF
IF obj=makehelp& THEN
@helptxt("MAKE")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=makeok& OR obj=makexit& OR obj=makefsel& OR obj=makehelp& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=makexit& OR (obj=makeok& AND fil$<>"" AND nam$<>"")
IF obj=makeok& THEN
IF mhz=1 THEN
mhz=32000
ENDIF
IF mhz=2 THEN
mhz=44100
ENDIF
IF mhz=3 THEN
mhz=48000
ENDIF
b=0
nomem=FALSE
@busy_mouse
FOR i=1 TO lmax2
e=0
IF arrpath$(i)<>"" AND arrpath$(i)<>"MEMORY" THEN
e=(arrend(i)-arrstrt(i))
IF arrtri(i)=2 THEN
e=e+(arrend(i)-arrstrt(i))
ENDIF
nomem=TRUE
ENDIF
IF arrpath$(i)="MEMORY" THEN
e=(arrend(i)-arrstrt(i))
IF arrtri(i)=2 THEN
e=e+(arrend(i)-arrstrt(i))
ENDIF
ENDIF
IF arrsrate(i)<>mhz AND arrpath$(i)<>"" THEN
nomem=TRUE
mrkhz=arrsrate(i)
e=e/mrkhz*mhz
ENDIF
b=b+e
NEXT i
@busy_mouse
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=b THEN
okay=TRUE
ENDIF
IF nomem=TRUE AND okay=TRUE THEN
a2=ASC(LEFT$(virt$,1))-64
c=mlen
IF a=a2 THEN
c=mlen+b
ENDIF
IF DFREE(a2)>=c THEN
okay=TRUE
ELSE
okay=FALSE
ENDIF
BSAVE virt$,meml,mlen
ENDIF
IF okay=TRUE THEN
OPEN "O",#1,fil$
FOR i=1 TO lmax2
@busy_mouse
a$=arrpath$(i)
'
IF a$<>"" AND a$<>"MEMORY" THEN
OPEN "I",#2,a$
IF arrtri(i)=0 OR arrtri(i)=2 THEN
vln=(arrend(i)-arrstrt(i))
anf=arrstrt(i)
SEEK #2,anf
bytes=INT(mlen/mbit)*mbit
IF arrsrate(i)<>mhz THEN
@arr_resmp
ELSE
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #2,meml,bytes
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #2,meml,vln
BPUT #1,meml,vln
ENDIF
ENDIF
ENDIF
IF arrtri(i)=1 OR arrtri(i)=2 THEN
vln=(arrend(i)-arrstrt(i))
bytes=INT(mlen/(mbit*2))*mbit
len=bytes
start=arrend(i)
IF arrsrate(i)<>mhz THEN
CLOSE #1
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=vln THEN
virtp$=CHR$(a+64)+":\"+virtfile$
OPEN "O",#1,virtp$
ELSE
okay=FALSE
ENDIF
ENDIF
IF okay=TRUE THEN
REPEAT
IF vln<len THEN
len=vln
ENDIF
start=start-len
SEEK #2,start
BGET #2,meml,len
@maschruf29(meml,meml+len)
BPUT #1,meml+len,len
vln=vln-len
UNTIL vln<1
IF arrsrate(i)<>mhz THEN
CLOSE #1
CLOSE #2
OPEN "U",#1,fil$
SEEK #1,LOF(#1)
OPEN "I",#2,virtp$
vln=LOF(#2)
anf=0
bytes=INT(mlen/mbit)*mbit
@arr_resmp
ENDIF
ENDIF
ENDIF
CLOSE #2
IF arrsrate(i)<>mhz AND (arrtri(i)=1 OR arrtri(i)=2) AND okay=TRUE THEN
KILL virtp$
ENDIF
ENDIF
'
IF a$="MEMORY" THEN
IF arrtri(i)=0 OR arrtri(i)=2 THEN
a$=virt$
OPEN "I",#2,a$
len=LOF(#2)
vln=(arrend(i)-arrstrt(i))
vln=INT(vln/mbit)*mbit
anf=arrstrt(i)
SEEK #2,anf
bytes=INT(mlen/mbit)*mbit
IF arrsrate(i)<>mhz THEN
@arr_resmp
ELSE
IF nomem=TRUE THEN
SEEK #2,0
BGET #2,meml,len
ENDIF
BPUT #1,meml+arrstrt(i),vln
ENDIF
CLOSE #2
ENDIF
IF arrtri(i)=1 OR arrtri(i)=2 THEN
OPEN "I",#2,virt$
vln=(arrend(i)-arrstrt(i))
bytes=INT(mlen/(mbit*2))*mbit
start=arrend(i)
'
IF arrsrate(i)<>mhz THEN
CLOSE #1
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=vln THEN
virtp$=CHR$(a+64)+":\"+virtfile$
OPEN "O",#1,virtp$
ELSE
okay=FALSE
ENDIF
ENDIF
IF okay=TRUE THEN
REPEAT
IF vln<bytes THEN
bytes=vln
ENDIF
start=start-bytes
SEEK #2,start
BGET #2,meml,bytes
@maschruf29(meml,meml+bytes)
BPUT #1,meml+bytes,bytes
vln=vln-bytes
UNTIL vln<1
IF arrsrate(i)<>mhz THEN
CLOSE #1
CLOSE #2
OPEN "U",#1,fil$
SEEK #1,LOF(#1)
OPEN "I",#2,virtp$
vln=LOF(#2)
anf=0
bytes=INT(mlen/mbit)*mbit
@arr_resmp
ENDIF
ENDIF
CLOSE #2
IF arrsrate(i)<>mhz AND (arrtri(i)=1 OR arrtri(i)=2) AND okay=TRUE THEN
KILL virtp$
ENDIF
ENDIF
ENDIF
'
NEXT i
CLOSE #1
IF nomem=TRUE AND EXIST(virt$)=TRUE THEN
BLOAD virt$,meml
KILL virt$
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF okay=FALSE AND obj<>makexit& THEN
@nomem
ENDIF
ENDIF
@restaura2
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE arr_resmp
.| Glob. Var.: f#,mhz#,e#,i#,bedarf#,okay#,drittel#,memh#,meml#,a#,fil$,vln#
.|     seekz#,anf#,bytes#,mlen#,b#,c#,d#,back%
.| Felder    : arrsrate#()
.| Ruft auf  : maschinit16,maschruf16
.| Aufruf in : make-4,
f=INT(mhz/100)
e=INT(arrsrate(i)/100)
bedarf=f/e
okay=FALSE
drittel=(memh-meml)/(e+f)*e
drittel=INT(drittel/mbit)*mbit
IF drittel>=mbit*4 THEN
drittel=drittel-(mbit*2)
ENDIF
a=ASC(LEFT$(fil$,1))-64
IF DFREE(a)>=vln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
seekz=anf
REPEAT
IF vln>=bytes THEN
IF bedarf<=1 THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=drittel
ENDIF
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
SEEK #2,seekz
IF bytes>3 THEN
BGET #2,meml,bytes
a=meml
b=meml+bytes
IF bedarf<=1 THEN
c=meml
ELSE
c=meml+bytes
ENDIF
d=memh
@maschruf16(a,b,c,d,e,f)
back%=INT(back%/mbit)*mbit
BPUT #1,c,back%-c
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
ENDIF
RETURN
'
> PROCEDURE info
.| Glob. Var.: winh#,info&,rsc_window&,vornr#,nr#,menuda#,infoicon&,g#
.|     smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,markhlp,setbutton,setbutton2
.|     rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,info&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=info&
IF infobinv=FALSE THEN
@setbild(infobild&,0)
infobinv=TRUE
ELSE
@setbild(infobild&,0)    ! war ,1
infobinv=FALSE
ENDIF
@setcopyright
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
ELSE
@setbutton(infoicon&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=info&
IF vornr=smpedit& THEN
@setbutton2(infoicon&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE icondraw
IF BTST(winh,icon&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=icon&
@rsc_draw(nr,0)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
ENDIF
ELSE
vornr=nr
nr=icon&
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE setcopyright
IF XBIOS(xbs,1)=&H71273800 THEN
a=XBIOS(xbs,2)
a$=""
REPEAT
b=PEEK(a)
IF b<>0 THEN
a$=a$+CHR$(b)
ENDIF
INC a
UNTIL b=0
IF LEN(drvtyp$)>15 THEN
drvtyp$=LEFT$(drvtyp$,15)
ENDIF
a$=drvtyp$+"-AUDIODRIVER "+a$+CHR$(0)
@textfeld2(info&,cpyrdrv&,a$,1)
a$="STARTRACK "+starversion$+" BY SWE,S.WILHELM"+CHR$(0)
@textfeld2(info&,cpyright&,a$,1)
ENDIF
RETURN
'
> PROCEDURE do_info
.| Glob. Var.: obj#,zu%,objflag#,helpinfo&,infoexit&,winh#,info&,nr#
.|     smpedit&,infoicon&
.| Ruft auf  : xrsrc_gaddr,helptxt,setbutton,restaura2b
.| Aufruf in : windows-1,
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zu%+8)
IF obj=helpinfo& THEN
@helptxt("PROGRAMM-INFO")
ENDIF
IF obj=infoexit& OR obj=9999 THEN
@nonstop4
winh=BCLR(winh,info&)
@setbutton(infoexit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(infoicon&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE nonstop1
nonhz=hz
IF demo=FALSE THEN
vfil$=nonstop$+CHR$(0)
IF EXIST(vfil$) THEN
nonstop=TRUE
nofound=FALSE
playpos=0
over=0
l=0
fil2$=fil$
fil$=vfil$
tmin=0
head=0
@tstfile
nper=per
handle=GEMDOS(61,L:VARPTR(vfil$),0)
IF handle=0 THEN
nonstop=FALSE
ELSE
playpos=head+tmin
sectors=tmax-tmin
g=8
mb=sectors
'
nonstm=@malloc(sectors,0)         ! Buffer fÅr Tracker-Caches
'
IF nonstm>0 THEN
endcount=sectors-playpos
v=GEMDOS(66,L:playpos,handle,0)     ! SEEK
bw=GEMDOS(63,handle,L:sectors,L:nonstm)
ELSE
nonstop=FALSE
ENDIF
ENDIF
ELSE
nonstop=FALSE
nofound=TRUE
ENDIF
ELSE
nonstop=FALSE
ENDIF
RETURN
'
> PROCEDURE nonstop2
IF intplay=FALSE AND nofound=FALSE AND nonstop=FALSE THEN
@nonstop1
ENDIF
IF intplay=FALSE AND nonstop=TRUE THEN
@nonstop3
ENDIF
RETURN
'
> PROCEDURE nonstop3
LOCAL p,b$,g
' HARDDISK-PLAY second generation fÅr "nonstop"
'
IF demo=FALSE AND sectors>0 THEN
IF XBIOS(xbs,1)=&H71273800 THEN
vdig24=dig24
@setbitrate16
nbypmode=bypmode
hz=nper
@fliphz2
@analog
@digout(TRUE)
recback=XBIOS(xbs,122,0,L:nonstm,L:nonstm+sectors,L:0,0,1)
@write_int(1)
intplay=TRUE
peakint=FALSE
peakexit=recback+8    ! Break-Flag
~XBIOS(xbs,150)
ENDIF
ENDIF
RETURN
'
> PROCEDURE nonstop4
IF nonstop=TRUE THEN
intplay=FALSE
@write_int(0)
hz=nonhz
@fliphz2
@digout(nbypmode)
~GEMDOS(62,handle)
fil$=fil2$
@digout(FALSE)
~MFREE(nonstm)
nonstm=0
nofound=FALSE
nonstop=FALSE
dig24=vdig24
IF dig24=FALSE THEN
@setbitrate16
ELSE
@setbitrate24
ENDIF
ENDIF
RETURN
'
> PROCEDURE rebuild
.| Glob. Var.: nr#,smpedit&,extclock#,hz#,a$,popups&,rate32&,rate&,rate44&
.|     rate48&,sloop#,smploop&,sblock#,smppmark&,mamidi#,midi&,sms#,sme#
.| Ruft auf  : fnamwrite,textfeld,adlow,admid,adhigh,fliphz,setbutton
.|     selblksbut,selblkebut
.| Aufruf in : trash-2,
@fnamwrite
IF nr=smpedit& THEN
@fliphz
@fliphz2
IF sloop=0 THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF mamidi=0 THEN
@setbutton(midi&,0)
ELSE
@setbutton(midi&,1)
ENDIF
@edmarkset(sms)
ENDIF
RETURN
'
> PROCEDURE trashvirt
op$=rop$
virtual=FALSE
virtcurve=FALSE
virtld=FALSE
blockld=FALSE
cached=FALSE
@markhlp
maxcwert=0
ce=mlen
cs=0
vmem=INT(mlen-1)
@infmemkill
'
IF rettfound=FALSE THEN
@maschruf9(meml,memh)   ! Delete Memory
ENDIF
'
@markdel
@clsed
@busy_mouse
IF ldtrk=FALSE THEN
@getmem
ENDIF
IF hz=0 THEN
@makehz
ENDIF
IF smplen=0 THEN
smplen=mlen
ENDIF
IF path$="" OR INSTR(path$,":")=0 OR INSTR(path$,"\")=0 THEN
smpnam$="MEMORY."+ext2$
path$=lfw$+smpnam$
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
hrd=0
IF nr=smpedit& THEN
@setbutton(hard&,0)
ENDIF
@rebuild
RETURN
'
> PROCEDURE infmemkill
LOCAL i,j
commtxt$=CHR$(0)
srctxt$=CHR$(0)
infname$=""
b$=""
IF dig24=FALSE THEN
fil$=s$+"MEMORY.S16"
bnam$="MEMORY.S16"
ELSE
fil$=s$+"MEMORY.S24"
bnam$="MEMORY.S24"
ENDIF
nam$=bnam$
loded=FALSE
vpath$=fil$
path$=vpath$
vsmpnam$=bnam$
smpnam$=vsmpnam$
vordner$=s$
ordner$=s$
comm$=""
src$=""
FOR i=1 TO bloopz
FOR j=1 TO 4
bloops%(i,j)=-1
vbloops%(i,j)=-1
NEXT j
NEXT i
RETURN
'
> PROCEDURE trash
.| Glob. Var.: mbs#,zoomp#,v#,v2#,v3#,v4#,virtual#,g#,op$,rop$,virtcurve#
.|     virtld#,blockld#,cached#,maxcwert#,ce#,mlen#,cs#,vmem#,hz#,smplen#
.|     path$,smpnam$,ext2$,lfw$,hrd#,nr#,smpedit&,hard&,rett#,meml#,memh#,i#
.|     lmax2#,lz#,trash&
.| Felder    : arrpath$(),arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrloop#()
.|     arrtri#()
.| Ruft auf  : smph3,markhlp,markdel,clsed,busy_mouse,getmem,makehz
.|     setbutton,rebuild,blocklook,maschinit9,maschruf9,zslidecalc,restaura
.| Aufruf in : hardproof2-1,do_smpedit-1,
LOCAL g
IF ldtrk3=FALSE THEN
mbs=0
zoomp=0
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4=1 OR v4=2 THEN   ! linke oder rechte Shift
@smph3
ENDIF
IF v4=0 THEN
IF virtual=TRUE THEN
@alerts(43)
IF g=1 THEN
@trashvirt
ENDIF
ELSE
IF rett=TRUE THEN
@alerts(44)
ELSE
@alerts(45)
ENDIF
IF g=1 THEN
@infmemkill
cached=FALSE
@markhlp
@blocklook
@maschruf9(meml,memh)   ! Delete Memory
@markdel
@clsed
FOR i=1 TO lmax2
IF arrpath$(i)="MEMORY" THEN
arrfn$(i)=""
arrpath$(i)=""
arrstrt(i)=0
arrend(i)=0
arrlen(i)=0
arrloop(i)=0
arrtri(i)=0
ENDIF
NEXT i
ENDIF
IF rett=TRUE AND g=1 THEN
rett=FALSE
@busy_mouse
@getmem
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF g=1 THEN
@rebuild
ENDIF
ENDIF
lz=1
zoomp=0
IF g=1 THEN
@zslidecalc
@restaura
ENDIF
ENDIF
ENDIF
@setbutton(trash&,0)
RETURN
'
> PROCEDURE sourcein
IF dspw=0 THEN
@dspoff
ENDIF
IF dspw=1 THEN
@dspin
ENDIF
IF dspw=2 THEN
@dspout
ENDIF
IF digsource=0 THEN
@opto
ENDIF
IF digsource=1 THEN
@coax
ENDIF
IF digsource=3 THEN
@aesebu
ENDIF
IF empha=FALSE THEN
@emphoff
ENDIF
IF empha=TRUE THEN
@emphon
ENDIF
IF scmsw=0 THEN
@scmsno
ENDIF
IF scmsw=1 THEN
@scmsone
ENDIF
IF scmsw=2 THEN
@scmsfree
ENDIF
IF proffm=FALSE THEN
proffm=TRUE
@consumer
ENDIF
IF proffm=TRUE THEN
proffm=FALSE
@profess
ENDIF
IF bridge=FALSE THEN
bridge=TRUE
ELSE
bridge=FALSE
ENDIF
@digibridge
bfadericht=fadericht
IF fadewin=0 THEN
@infade
@fadelinear
ENDIF
IF fadewin=1 THEN
@infade
@fadesquare
ENDIF
IF fadewin=2 THEN
@infade
@fadexp
ENDIF
IF fadewin=3 THEN
@infade
@fadesqrt
ENDIF
IF fadewin=4 THEN
@infade
@fadelog
ENDIF
IF fadewout=0 THEN
@ausfade
@fadelinear
ENDIF
IF fadewout=1 THEN
@ausfade
@fadesquare
ENDIF
IF fadewout=2 THEN
@ausfade
@fadexp
ENDIF
IF fadewout=3 THEN
@ausfade
@fadesqrt
ENDIF
IF fadewout=4 THEN
@ausfade
@fadelog
ENDIF
fadericht=bfadericht
IF fadericht=0 THEN
@infade
ELSE
@ausfade
ENDIF
IF ad=0 THEN
@digital
ELSE
@analog
ENDIF
RETURN
'
> PROCEDURE setupdat
.| Glob. Var.: vornr#,nr#,setup&,obj#,popup&,zu%,zuadr#,x#,y#,v3#,lenmall&
.|     edit_obj&,buttadr#,but#,objadr#,objflag#,timeset&,setshow&,posy&
.|     vertline&,frec&,zerosnap&,zoomy&,linkdot&,freeze&,spacefil&,menuset&
.|     sync&,extclock#,fseldef&,secl&,secr&,flip&,dreide&,grid&,sram&
.|     mallmax&,recl&,recr&,tresl&,tresr&,setsave&,setload&,wavset&,avrset&
.|     sndset&,auset&,smpset&,allset&,sdset&,sets16&,sethelp&,setexit&
.|     setok&,a$,memmx#,digana#,vdigana#,op$,vop$,fastrec#,vfastrec#,menuda#
.|     vmenuda#,flen#,vflen#,sramda#,vsramda#,min#,vmin#,mallmax#,vmallmax#
.|     th#,vth#,dreidim#,vdreidim#,grids#,vgrid#,ext$,vext$,flipp#,vflipp#
.|     uhr#,vuhr#,show#,vshow#,yline#,vyline#,vertline#,vvertline#,linkdot#
.|     vlinkdot#,spacefill#,vspacefill#,zsnap#,vzsnap#,yzoom#,vyzoom#,freez#
.|     vfreez#,smpedit&,setuper&,clock&,showxy&,stl#
.| Ruft auf  : rsc_draw,markhlp,setdat,rsc_do,xrsrc_gaddr,mouse,timeset
.|     showset,setyline,vertline,fastrec,zerosnap,yautozoom,linkdot,freeze
.|     spacefill,menuset,sync,fseldef,secbutt,flipp,dreide,grid,sram,mallmax
.|     recbutt,tresbutt,setsave,setload,extender,helptxt,editread,setbutton
.|     restaura2,textfeld,smpfree,write_reglow,makehz,sethertz
.| Aufruf in : drop2-1,do_smpedit-1,
vornr=nr
nr=setup&
@rsc_draw(nr,0)
@markhlp
@setdat
vemula2=emula
vneufsel=neufsel
vvol=vol
vvol2=vol2
vvolinbal=volinbal
vvolinbal2=volinbal2
vbalinmax=balinmax
vad=ad
vhz=hz
vdigsource=digsource
vproffm=proffm
vscmsw=scmsw
vempha=empha
vbridge=bridge
vdspw=dspw
vnote=note
vch=ch
vfadewin=fadewin
vfadewout=fadewout
vfadericht=fadericht
vspc=spc
vnorma=norma
vdb=db
vresoth=resoth
vadjresmp=adjresmp
vdeltime=deltime
vrealtime=realtime
'
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1 AND obj<>lenmall&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF but=22 THEN
IF obj=setform& AND digana=TRUE THEN
a$=@rsc_text$(popups&,popform&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
IF dig24=FALSE THEN
vext$="S16"
ELSE
vext$="S24"
ENDIF
ENDIF
IF popup&=2 THEN
vext$="WAV"
ENDIF
IF popup&=3 THEN
vext$="AVR"
ENDIF
IF popup&=4 THEN
vext$="AIF"
ENDIF
IF popup&=5 THEN
vext$="SND"
ENDIF
IF popup&=6 THEN
vext$="SD"
ENDIF
IF popup&=7 THEN
vext$="AU"
ENDIF
IF popup&=8 THEN
vext$="SMP"
ENDIF
IF popup&=9 THEN
vext$="*"
ENDIF
ENDIF
ENDIF
IF obj=timeset& THEN
@timeset
ENDIF
IF obj=viewset& THEN
@viewset
ENDIF
IF obj=setshow& THEN
@showset
ENDIF
IF obj=emulset& THEN
@emulset
ENDIF
IF obj=posy& THEN
@setyline
ENDIF
IF obj=vertline& THEN
@vertline
ENDIF
IF obj=frec& THEN
@fastrec
ENDIF
IF obj=zerosnap& THEN
@zerosnap
ENDIF
IF obj=zoomy& THEN
@yautozoom
ENDIF
IF obj=linkdot& THEN
@linkdot
ENDIF
IF obj=freeze& THEN
@freeze
ENDIF
IF obj=spacefil& THEN
@spacefill
ENDIF
IF obj=menuset& THEN
@menuset
ENDIF
IF obj=sync& THEN
IF extclock=FALSE THEN
@sync
ENDIF
ENDIF
IF obj=fseldef& THEN
@fseldef
ENDIF
IF obj=secl& OR obj=secr& THEN
@secbutt
ENDIF
IF obj=flip& THEN
@flipp
ENDIF
IF obj=dreide& THEN
@dreide
ENDIF
IF obj=grid& THEN
@grid
ENDIF
'    IF obj=sram& THEN
'    @sram
'  ENDIF
IF obj=nfsbut& THEN
@fselwahl
ENDIF
IF obj=mallmax& THEN
@mallmax
ENDIF
IF obj=recl& OR obj=recr& THEN
@recbutt
ENDIF
IF obj=tresl& OR obj=tresr& THEN
@tresbutt
ENDIF
IF obj=setsave& THEN
@setsave
ENDIF
IF obj=setload& THEN
@setload
@setdat
ENDIF
IF obj=sethelp& THEN
@helptxt("SETUP")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
UNTIL obj=setexit& OR obj=setok&
IF obj=setexit& THEN
vol=vvol
vol2=vvol2
volinbal=vvolinbal
volinbal2=vvolinbal2
balinmax=vbalinmax
ad=vad
hz=vhz
digsource=vdigsource
proffm=vproffm
scmsw=vscmsw
empha=vempha
bridge=vbridge
dspw=vdspw
note=vnote
ch=vch
fadewin=vfadewin
fadewout=vfadewout
fadericht=vfadericht
spc=vspc
norma=vnorma
db=vdb
resoth=vresoth
adjresmp=vadjresmp
realtime=vrealtime
deltime=vdeltime
@sourcein
ENDIF
IF obj=setok& THEN
@editread(lenmall&)
memmx=INT(1024*VAL(a$))
digana=vdigana
op$=vop$
fastrec=vfastrec
menuda=vmenuda
flen=vflen
sramda=vsramda
min=vmin
rtime=min*60*100
mallmax=vmallmax
th=vth
dreidim=vdreidim
grids=vgrid
ext$=vext$
flipp=vflipp
uhr=vuhr
tedart=vtedart
show=vshow
emula=vemula
yline=vyline
vertline=vvertline
linkdot=vlinkdot
spacefill=vspacefill
zsnap=vzsnap
yzoom=vyzoom
freez=vfreez
neufsel=vneufsel
IF vemula2<>emula THEN
@emulset2
ENDIF
ENDIF
IF extclock=TRUE THEN
digana=TRUE
ENDIF
@setbutton(obj,0)
@restaura2
obj=0
IF nr=smpedit& THEN
@setbutton(setuper&,0)
@textfeld(clock&,SPACE$(8)+CHR$(0),1)
@textfeld(showxy&,SPACE$(13)+CHR$(0),1)
@smpfree
@minwrite
ENDIF
IF digana=FALSE AND demo=FALSE THEN
~XBIOS(xbs,20,ad)         ! Analog oder Digitaleingang benutzen
~XBIOS(xbs,21,digsource)  ! Opto,Koax oder AESEBU benutzen
~XBIOS(xbs,23,0)          ! Taktrate=spdif
ENDIF
@makehz
@sethertz
RETURN
'
> PROCEDURE setload
.| Glob. Var.: setup$,vol#,memmx#,digana#,op$,flen#,sramda#,min#,mallmax#
.|     th#,dreidim#,grids#,ext$,flipp#,uhr#,show#,aback#,abacknam#,btime#
.|     yline#,vertline#,linkdot#,spacefill#,zsnap#,yzoom#,fastrec#,menuda#
.|     freez#,winh#,ctree#,i#,lfw$,back#,backnam#,rop$,obj#,setload&,nr#
.|     setup&
.| Felder    : rx#(),ry#()
.| Ruft auf  : busy_mouse,fadeset,setbutton
.| Aufruf in : HAUPTPROGRAMM-1,setupdat-1,
newmem=FALSE
IF EXIST(setup$) THEN
@busy_mouse
OPEN "I",#1,setup$
INPUT #1,setv$              !  "STARTRACK-SETUP V1.0"  Versionskontrolle
IF MID$(setv$,LEN(setv$)-3,1)="V" THEN
prgversion=VAL(RIGHT$(setv$,3))
ELSE
prgversion=0
ENDIF
INPUT #1,language
INPUT #1,vol
INPUT #1,vol2
INPUT #1,volinbal
INPUT #1,volinbal2
INPUT #1,balinmax
INPUT #1,ad
INPUT #1,hz
INPUT #1,digsource
INPUT #1,proffm
INPUT #1,scmsw
INPUT #1,empha
INPUT #1,bridge
INPUT #1,dspw
INPUT #1,note
INPUT #1,ch
INPUT #1,fadewin
INPUT #1,fadewout
INPUT #1,fadericht
INPUT #1,tedart
INPUT #1,spc
INPUT #1,norma
INPUT #1,db
INPUT #1,resoth
INPUT #1,adjresmp
INPUT #1,realtime
INPUT #1,deltime
INPUT #1,memmx
INPUT #1,digana
INPUT #1,op$
INPUT #1,flen
INPUT #1,sramda
INPUT #1,min
INPUT #1,mallmax
INPUT #1,th
INPUT #1,dreidim
INPUT #1,grids
INPUT #1,ext$
INPUT #1,flipp
INPUT #1,uhr
INPUT #1,show
INPUT #1,aback
INPUT #1,abacknam
INPUT #1,btime
INPUT #1,yline
INPUT #1,vertline
INPUT #1,linkdot
INPUT #1,spacefill
INPUT #1,zsnap
INPUT #1,yzoom
INPUT #1,fastrec
INPUT #1,menuda
INPUT #1,freez
INPUT #1,winh
INPUT #1,neufsel
'
IF prgversion>=1.1 THEN          ! Versionskontrolle
INPUT #1,adat
INPUT #1,fmclk
INPUT #1,bigram
INPUT #1,dig24
INPUT #1,mod96
INPUT #1,rch4
INPUT #1,rmo8
INPUT #1,matrix
INPUT #1,mixdsp
INPUT #1,synchertz
INPUT #1,pcg
INPUT #1,emula
INPUT #1,mtc
INPUT #1,sendsmpte
INPUT #1,framez
INPUT #1,smptestrt
ENDIF
IF prgversion<1.2 THEN          ! Versionskontrolle
INPUT #1,ctree
FOR i=0 TO ctree
INPUT #1,rx(i)
INPUT #1,ry(i)
NEXT i
ELSE
FOR i=0 TO 31
rx(i)=0
ry(i)=0
rb(i)=0
rh(i)=0
NEXT i
INPUT #1,rx(smpedit&)
INPUT #1,ry(smpedit&)
INPUT #1,rx(info&)
INPUT #1,ry(info&)
INPUT #1,rx(smp16&)
INPUT #1,ry(smp16&)
INPUT #1,rx(blkfunc&)
INPUT #1,ry(blkfunc&)
INPUT #1,rx(peak&)
INPUT #1,ry(peak&)
INPUT #1,rx(arranger&)
INPUT #1,ry(arranger&)
INPUT #1,rx(trakker&)
INPUT #1,ry(trakker&)
INPUT #1,rx(loop&)
INPUT #1,ry(loop&)
INPUT #1,rx(dspedit&)
INPUT #1,ry(dspedit&)
INPUT #1,rx(editfade&)
INPUT #1,ry(editfade&)
INPUT #1,rx(wmode&)
INPUT #1,ry(wmode&)
INPUT #1,rx(plugin&)
INPUT #1,ry(plugin&)
FOR i=12 TO 31
INPUT #1,v
INPUT #1,v
NEXT i
INPUT #1,rb(smpedit&)
INPUT #1,rh(smpedit&)
INPUT #1,rb(info&)
INPUT #1,rh(info&)
INPUT #1,rb(smp16&)
INPUT #1,rh(smp16&)
INPUT #1,rb(blkfunc&)
INPUT #1,rh(blkfunc&)
INPUT #1,rb(peak&)
INPUT #1,rh(peak&)
INPUT #1,rb(arranger&)
INPUT #1,rh(arranger&)
INPUT #1,rb(trakker&)
INPUT #1,rh(trakker&)
INPUT #1,rb(loop&)
INPUT #1,rh(loop&)
INPUT #1,rb(dspedit&)
INPUT #1,rh(dspedit&)
INPUT #1,rb(editfade&)
INPUT #1,rh(editfade&)
INPUT #1,rb(wmode&)
INPUT #1,rh(wmode&)
INPUT #1,rb(plugin&)
INPUT #1,rh(plugin&)
FOR i=12 TO 31
INPUT #1,v
INPUT #1,v
NEXT i
ENDIF
INPUT #1,hpath$
CLOSE #1
nosetload=FALSE
ELSE
FOR i=0 TO 31
rx(i)=rscx&(i)
ry(i)=rscy&(i)
rb(i)=rscw&(i)
rh(i)=rsch&(i)
NEXT i
prgversion=0
nosetload=TRUE
language=1             ! Sprache: 1=deutsch, 2=englisch
neufsel=FALSE          ! neuen older alten Fileselektor benutzen ?
digsource=0            ! Digitalanschluû-Art
proffm=0               ! Consumer/Profi-Mode
scmsw=0                ! SCMS-Copymanagement
emphw=0                ! Emphasis
bridge=0               ! Digitalkonvertierung umgehen
dspw=0                 ! DSP none/in/out
note=0                 ! Midi-Note
ch=0                   ! Midi-Kanal
fadewin=0              ! Fader-Art Einblendung
fadewout=0             ! Fader-Art Ausblendung
fadericht=0            ! Fader-Richtung
tedart=0               ! Art der Zeitangabe in Samples oder Sekunden
aback=0                ! Auto-Backup
abacknam=0             ! Original-Filenamen fÅr Auto-Backup
hz=44100               ! Sample-Rate
vol=128+64             ! volume-control A/D
vol2=128+64            ! volume-control D/A
balinmax=24            ! halbe Breite des Balance-Reglers
volinbal=0             ! Stellung des A/D-Balance-Reglers
volinbal2=0            ! Stellung des D/A-Balance-Reglers
ad=1                   ! Analog-Eingang benutzen
memmx=&H80000          ! Wenn mallmax=FALSE,dann memmx-Speicher anfordern
newmem=-1
digana=TRUE            ! wenn TRUE, dann DIGITAL->ANALOG-Umschaltung bei Wiedergabe
op$=lfw$               ! Default-Zugriffspfad
flen=&H4000            ! SektorlÑnge
sramda=FALSE           ! wenn TRUE, dann SRAM vorhanden
min=4                  ! RECORD-Aufnahmezeit in Minuten
rtime=min*60*100
mallmax=FALSE          ! TRUE, wenn maximalen Speicher anfordern
th=257                 ! Schwelle fÅr AUTO-RECORD
dreidim=1              ! 3D-OberflÑche
grids=1                ! Hintergrundmuster fÅr Wellenfenster
IF dig24=FALSE THEN
ext$="S16"             ! Fileextender fÅr Soundfiles
ELSE
ext$="S24"             ! Fileextender fÅr Soundfiles
ENDIF
flipp=TRUE             ! Einstellung fÅr Copy/move-Auswahlleiste
uhr=TRUE               ! Uhrzeitanzeige
show=TRUE              ! Anzeige der Position in Samples
back=FALSE             ! Auto-Backup
backnam=FALSE          ! Original-Filenamen fÅr Auto-Backup
btime=5                ! Backup-Zeitlimit
yline=TRUE             ! Vertikale Markierung im Wellenfenster
vertline=TRUE          ! Darstellung der Samples als Pegel
linkdot=TRUE           ! Verbindung der Samples durch Linie
spacefill=TRUE         ! FÅllung der Samples
zsnap=TRUE             ! Suchen von Nullpunkten
yzoom=FALSE            ! Autozoom fÅr Samples
fastrec=TRUE           ! Geschwindigkeitsanpassung fÅr langsame /schnelle Systeme
menuda=TRUE            ! MenÅzeile
freez=TRUE             ! Fensterpositionen merken und Fenster automatisch îffnen
spc=3                  ! Space-Time
norma=1                ! Normalize Adjust/Auto
db=-6                  ! Normalize-Wert -6dB
resoth=48              ! Resampling-Wert 48kHz
adjresmp=FALSE         ! Adjust resample-rate
realtime=FALSE         ! Echtzeit fÅr Arranger
deltime=60             ! Zeitverzîgerung fÅr Arranger
'
adat=FALSE
fmclk=FALSE
bigram=FALSE
dig24=FALSE
mbit=4
mod96=FALSE
rch4=FALSE
rmo8=FALSE
matrix=TRUE
mixdsp=FALSE
synchertz=24576000
pcg=FALSE
emula=FALSE            ! Falcon TOS-Emulation
mtc=FALSE              ! Midi-Timecode Synchronize
sendsmpte=FALSE        ! MTC-Code senden ja/nein
framez=25              ! SMPTE-Frames
smptestrt=0            ! Startoffset SMPTE
'
winh=0
hpath$=op$+"1STGUIDE.IDX"  ! Pfad des Helpfile-Systems
ENDIF
IF dig24=FALSE THEN
mbit=4
aufloes=db16
ELSE
mbit=6
aufloes=db24
ENDIF
IF spacefill=FALSE AND vertline=FALSE AND linkdot=FALSE THEN
spacefill=TRUE
ENDIF
@fadeset
@emulset2
@mtcsetup
rop$=op$
IF pcg=TRUE THEN
a=INT(synchertz/512)
@setpcg(a)
ENDIF
IF obj=setload& AND nr=setup& THEN
@balwrite(vol,volinbal,balinmax)
@balwrite2(vol2,volinbal2,balinmax)
@setbutton(obj,0)
@sourcein
ENDIF
rtime=min*60*100
RETURN
'
> PROCEDURE setdat
.| Glob. Var.: extclock#,digana#,vmenuda#,menuda#,vfastrec#,fastrec#
.|     vdigana#,vop$,op$,vflen#,flen#,vsramda#,sramda#,vmin#,min#,vmallmax#
.|     mallmax#,vth#,th#,vdreidim#,dreidim#,vgrid#,grids#,vext$,ext$,vflipp#
.|     flipp#,vuhr#,uhr#,vshow#,show#,vyline#,yline#,vvertline#,vertline#
.|     vlinkdot#,linkdot#,vspacefill#,spacefill#,vzsnap#,zsnap#,vyzoom#
.|     yzoom#,vfreez#,freez#,oop$,a#,fseltxt&,f$,seclen&,recm&,tdb#,aufloes#
.|     tdb$,tresdb&,sdset&,avrset&,sndset&,auset&,smpset&,sets16&,wavset&
.|     allset&,sync&,dreide&,frec&,posy&,menuset&,zoomy&,grid&,freeze&,sram&
.|     flip&,setshow&,zerosnap&,timeset&,linkdot&,vertline&,spacefil&
.|     mallmax&,a$,memmx#,lenmall&
.| Ruft auf  : textfeld,setbutton,editfeld
.| Aufruf in : setupdat-2,
~GRAF_MOUSE(256,0)                              ! Hidem
IF extclock=TRUE THEN
digana=TRUE
ENDIF
vneufsel=neufsel
vmenuda=menuda
vfastrec=fastrec
vdigana=digana
vop$=op$
vflen=flen
vsramda=sramda
vmin=min
vmallmax=mallmax
vth=th
vdreidim=dreidim
vgrid=grids
vext$=ext$
vflipp=flipp
vtedart=tedart
vuhr=uhr
vshow=show
vemula=emula
vyline=yline
vvertline=vertline
vlinkdot=linkdot
vspacefill=spacefill
vzsnap=zsnap
vyzoom=yzoom
vfreez=freez
IF LEN(op$)>57 THEN
oop$=RIGHT$(op$,57)
a=INSTR(oop$,"\")
oop$=RIGHT$(oop$,LEN(oop$)-(a-1))
ELSE
oop$=op$
ENDIF
@textfeld(fseltxt&,oop$+CHR$(0),1)
f$=RIGHT$(SPACE$(5)+STR$(flen),5)+CHR$(0)
@textfeld(seclen&,f$,1)
f$=RIGHT$(SPACE$(5)+STR$(min),5)+CHR$(0)
@textfeld(recm&,f$,1)
tdb=th
IF dig24=TRUE THEN
tdb=SHL(tdb,8)
ENDIF
tdb=20*LOG10(tdb*2)
tdb=tdb-aufloes
tdb=INT(tdb*1000)/1000
tdb$=STR$(tdb)+CHR$(0)
@textfeld(tresdb&,tdb$,1)
IF ext$="SD" THEN
a$=@rsc_text$(popups&,setsd&)
ENDIF
IF ext$="AVR" THEN
a$=@rsc_text$(popups&,setavr&)
ENDIF
IF ext$="AIF" THEN
a$=@rsc_text$(popups&,setaif&)
ENDIF
IF ext$="SND" THEN
a$=@rsc_text$(popups&,setsnd&)
ENDIF
IF ext$="AU" THEN
a$=@rsc_text$(popups&,setau&)
ENDIF
IF ext$="SMP" THEN
a$=@rsc_text$(popups&,setsmp&)
ENDIF
IF ext$="S16" OR ext$="S24" THEN
a$=@rsc_text$(popups&,sets16&)
ENDIF
IF ext$="WAV" THEN
a$=@rsc_text$(popups&,setwav&)
ENDIF
IF ext$="*" THEN
a$=@rsc_text$(popups&,setall&)
ENDIF
@textfeld(setform&,a$,1)
IF digana=FALSE THEN
IF extclock=TRUE THEN
@setbutton(sync&,9)
ELSE
@setbutton(sync&,1)
ENDIF
ELSE
IF extclock=TRUE THEN
@setbutton(sync&,8)
ELSE
@setbutton(sync&,0)
ENDIF
ENDIF
IF tedart=1 THEN
@setbutton(viewset&,1)
ELSE
@setbutton(viewset&,0)
ENDIF
IF dreidim=1 THEN
@setbutton(dreide&,1)
ELSE
@setbutton(dreide&,0)
ENDIF
IF fastrec=FALSE THEN
@setbutton(frec&,0)
ELSE
@setbutton(frec&,1)
ENDIF
IF yline=TRUE THEN
@setbutton(posy&,1)
ELSE
@setbutton(posy&,0)
ENDIF
IF menuda=TRUE THEN
@setbutton(menuset&,1)
ELSE
@setbutton(menuset&,0)
ENDIF
IF yzoom=TRUE THEN
@setbutton(zoomy&,1)
ELSE
@setbutton(zoomy&,0)
ENDIF
IF grids=1 THEN
@setbutton(grid&,1)
ELSE
@setbutton(grid&,0)
ENDIF
IF freez=TRUE THEN
@setbutton(freeze&,1)
ELSE
@setbutton(freeze&,0)
ENDIF
'  IF sramda=TRUE THEN
'  @setbutton(sram&,1)
' ELSE
'  @setbutton(sram&,0)
' ENDIF
IF neufsel=TRUE THEN
@setbutton(nfsbut&,1)
ELSE
@setbutton(nfsbut&,0)
ENDIF
IF flipp=TRUE THEN
@setbutton(flip&,1)
ELSE
@setbutton(flip&,0)
ENDIF
IF show=TRUE THEN
@setbutton(setshow&,1)
ELSE
@setbutton(setshow&,0)
ENDIF
IF emula=TRUE THEN
@setbutton(emulset&,1)
ELSE
@setbutton(emulset&,0)
ENDIF
IF zsnap=TRUE THEN
@setbutton(zerosnap&,1)
ELSE
@setbutton(zerosnap&,0)
ENDIF
IF uhr=TRUE THEN
@setbutton(timeset&,1)
ELSE
@setbutton(timeset&,0)
ENDIF
IF linkdot=TRUE THEN
@setbutton(linkdot&,1)
ELSE
@setbutton(linkdot&,0)
ENDIF
IF vertline=TRUE THEN
@setbutton(vertline&,1)
ELSE
@setbutton(vertline&,0)
ENDIF
IF spacefill=TRUE THEN
@setbutton(spacefil&,1)
ELSE
@setbutton(spacefil&,0)
ENDIF
IF mallmax=FALSE THEN
@setbutton(mallmax&,1)
ELSE
@setbutton(mallmax&,0)
ENDIF
a$=STR$(INT(memmx/1024))+CHR$(0)
@editfeld(lenmall&,a$)
~GRAF_MOUSE(257,0)                              ! Hidem
RETURN
'
> PROCEDURE setsave
.| Glob. Var.: lenmall&,a$,memmx#,a#,setup$,vfreez#,winh#,sector#,vol#
.|     vdigana#,vop$,vflen#,vsramda#,vmin#,vmallmax#,vth#,vdreidim#,vgrid#
.|     vext$,vflipp#,vuhr#,vshow#,aback#,abacknam#,btime#,vyline#,vvertline#
.|     vlinkdot#,vspacefill#,vzsnap#,vyzoom#,vfastrec#,vmenuda#,btree#,i#
.|     obj#
.| Felder    : rscx&(),rscy&()
.| Ruft auf  : busy_mouse,editread,nomem,setbutton
.| Aufruf in : setupdat-1,
@busy_mouse
@editread(lenmall&)
memmx=INT(1024*VAL(a$))
a=ASC(LEFT$(setup$,1))-64
IF vfreez=FALSE THEN
winh=0
ENDIF
IF DFREE(a)>=sector THEN
OPEN "O",#1,setup$
PRINT #1,"STARTRACK-SETUP V1.2"           ! Versionskontrolle
PRINT #1,language
PRINT #1,vvol
PRINT #1,vvol2
PRINT #1,vvolinbal
PRINT #1,vvolinbal2
PRINT #1,vbalinmax
PRINT #1,vad
PRINT #1,vhz
PRINT #1,vdigsource
PRINT #1,vproffm
PRINT #1,vscmsw
PRINT #1,vempha
PRINT #1,vbridge
PRINT #1,vdspw
PRINT #1,vnote
PRINT #1,vch
PRINT #1,vfadewin
PRINT #1,vfadewout
PRINT #1,vfadericht
PRINT #1,vtedart
PRINT #1,vspc
PRINT #1,vnorma
PRINT #1,vdb
PRINT #1,vresoth
PRINT #1,vadjresmp
PRINT #1,vrealtime
PRINT #1,vdeltime
PRINT #1,memmx
PRINT #1,vdigana
PRINT #1,vop$
PRINT #1,vflen
PRINT #1,vsramda
PRINT #1,vmin
PRINT #1,vmallmax
PRINT #1,vth
PRINT #1,vdreidim
PRINT #1,vgrid
PRINT #1,vext$
PRINT #1,vflipp
PRINT #1,vuhr
PRINT #1,vshow
PRINT #1,aback
PRINT #1,abacknam
PRINT #1,btime
PRINT #1,vyline
PRINT #1,vvertline
PRINT #1,vlinkdot
PRINT #1,vspacefill
PRINT #1,vzsnap
PRINT #1,vyzoom
PRINT #1,vfastrec
PRINT #1,vmenuda
PRINT #1,vfreez
IF vfreez=FALSE THEN
PRINT #1,0
ELSE
PRINT #1,winh
ENDIF
PRINT #1,vneufsel
PRINT #1,adat
PRINT #1,fmclk
PRINT #1,bigram
PRINT #1,dig24
PRINT #1,mod96
PRINT #1,rch4
PRINT #1,rmo8
PRINT #1,matrix
PRINT #1,mixdsp
PRINT #1,synchertz
PRINT #1,pcg
PRINT #1,vemula
PRINT #1,mtc
PRINT #1,sendsmpte
PRINT #1,framez
PRINT #1,smptestrt
PRINT #1,btree
FOR i=0 TO 31
PRINT #1,rscx&(i)
PRINT #1,rscy&(i)
NEXT i
FOR i=0 TO 31
PRINT #1,rscw&(i)
PRINT #1,rsch&(i)
NEXT i
PRINT #1,hpath$
CLOSE #1
ELSE
@nomem
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE menuset
.| Glob. Var.: vmenuda#
.| Aufruf in : setupdat-1,
IF vmenuda=TRUE THEN
vmenuda=FALSE
ELSE
vmenuda=TRUE
ENDIF
RETURN
'
> PROCEDURE freeze
.| Glob. Var.: vfreez#
.| Aufruf in : setupdat-1,
IF vfreez=TRUE THEN
vfreez=FALSE
ELSE
vfreez=TRUE
ENDIF
RETURN
'
> PROCEDURE fastrec
.| Glob. Var.: vfastrec#
.| Aufruf in : setupdat-1,
IF vfastrec=TRUE THEN
vfastrec=FALSE
ELSE
vfastrec=TRUE
ENDIF
RETURN
'
> PROCEDURE yautozoom
.| Glob. Var.: vyzoom#
.| Aufruf in : setupdat-1,
IF vyzoom=TRUE THEN
vyzoom=FALSE
ELSE
vyzoom=TRUE
ENDIF
RETURN
'
> PROCEDURE setyline
.| Glob. Var.: vyline#
.| Aufruf in : setupdat-1,
IF vyline=TRUE THEN
vyline=FALSE
ELSE
vyline=TRUE
ENDIF
RETURN
'
> PROCEDURE zerosnap
.| Glob. Var.: vzsnap#
.| Aufruf in : setupdat-1,
IF vzsnap=TRUE THEN
vzsnap=FALSE
ELSE
vzsnap=TRUE
ENDIF
RETURN
'
> PROCEDURE vertline
.| Glob. Var.: vvertline#,vspacefill#,vlinkdot#,spacefil&
.| Ruft auf  : setbutton
.| Aufruf in : setupdat-1,
IF vvertline=TRUE THEN
vvertline=FALSE
ELSE
vvertline=TRUE
ENDIF
IF vspacefill=FALSE AND vvertline=FALSE AND vlinkdot=FALSE THEN
vspacefill=TRUE
@setbutton(spacefil&,1)
ENDIF
RETURN
'
> PROCEDURE linkdot
.| Glob. Var.: vlinkdot#,vspacefill#,vvertline#,spacefil&
.| Ruft auf  : setbutton
.| Aufruf in : setupdat-1,
IF vlinkdot=TRUE THEN
vlinkdot=FALSE
ELSE
vlinkdot=TRUE
ENDIF
IF vspacefill=FALSE AND vvertline=FALSE AND vlinkdot=FALSE THEN
vspacefill=TRUE
@setbutton(spacefil&,1)
ENDIF
RETURN
'
> PROCEDURE spacefill
.| Glob. Var.: vspacefill#,vvertline#,vlinkdot#,spacefil&
.| Ruft auf  : setbutton
.| Aufruf in : setupdat-1,
IF vspacefill=TRUE THEN
vspacefill=FALSE
ELSE
vspacefill=TRUE
ENDIF
IF vspacefill=FALSE AND vvertline=FALSE AND vlinkdot=FALSE THEN
vspacefill=TRUE
@setbutton(spacefil&,1)
ENDIF
RETURN
'
> PROCEDURE sync
.| Glob. Var.: vdigana#
.| Aufruf in : setupdat-1,
IF vdigana=TRUE THEN
vdigana=FALSE
ELSE
vdigana=TRUE
ENDIF
RETURN
'
> PROCEDURE viewset
IF vtedart=1 THEN
vtedart=0
ELSE
vtedart=1
ENDIF
RETURN
'
> PROCEDURE dreide
.| Glob. Var.: vdreidim#
.| Aufruf in : setupdat-1,
IF vdreidim=1 THEN
vdreidim=0
ELSE
vdreidim=1
ENDIF
RETURN
'
> PROCEDURE realarr
IF realtime=TRUE THEN
realtime=FALSE
ELSE
realtime=TRUE
ENDIF
@arrnrset
RETURN
'
> PROCEDURE grid
.| Glob. Var.: vgrid#
.| Aufruf in : setupdat-1,
IF vgrid=1 THEN
vgrid=0
ELSE
vgrid=1
ENDIF
RETURN
'
> PROCEDURE fseldef
.| Glob. Var.: ab#,nr#,vop$,ext$,ordner$,pret#,pbutt#,a#,fseltxt&,obj#
.| Felder    : rscx&(),rscy&(),rscw&(),rsch&()
.| Ruft auf  : rsc_get,fileselect,rsc_put,busy_mouse,textfeld,setbutton
.| Aufruf in : setupdat-1,
~GRAF_MOUSE(256,0)                              ! Hidem
abfsel=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
@fileselect(vop$+"*."+ext$,"","PATH:")
@rsc_put(abfsel,rscx&(nr),rscy&(nr),1)
@busy_mouse
~MFREE(abfsel)
IF ordner$<>"" AND pret<>0 AND pbutt=1 THEN
IF LEN(ordner$)>57 THEN
ordner$=RIGHT$(ordner$,57)
a=INSTR(ordner$,"\")
ordner$=RIGHT$(ordner$,LEN(ordner$)-(a-1))
ENDIF
@textfeld(fseltxt&,ordner$+CHR$(0),1)
vop$=ordner$
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE secbutt
.| Glob. Var.: obj#,secl&,vflen#,secr&,f$,seclen&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : setupdat-1,
IF obj=secl& AND vflen>511 THEN
vflen=vflen/2
ENDIF
IF obj=secr& AND vflen<65536 THEN
vflen=vflen*2
ENDIF
f$=RIGHT$(SPACE$(5)+STR$(vflen),5)+CHR$(0)
@textfeld(seclen&,f$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE flipp
.| Glob. Var.: vflipp#
.| Aufruf in : setupdat-1,
IF vflipp=FALSE THEN
vflipp=TRUE
ELSE
vflipp=FALSE
ENDIF
RETURN
'
> PROCEDURE showset
.| Glob. Var.: vshow#
.| Aufruf in : setupdat-1,
IF vshow=FALSE THEN
vshow=TRUE
ELSE
vshow=FALSE
ENDIF
RETURN
'
> PROCEDURE emulset
IF vemula=FALSE THEN
vemula=TRUE
ELSE
vemula=FALSE
ENDIF
RETURN
'
> PROCEDURE emulset2
IF demo=FALSE THEN
IF emula=TRUE THEN
~XBIOS(xbs,160,1)
ELSE
~XBIOS(xbs,160,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE timeset
.| Glob. Var.: vuhr#
.| Aufruf in : setupdat-1,
IF vuhr=FALSE THEN
vuhr=TRUE
ELSE
vuhr=FALSE
ENDIF
RETURN
'
> PROCEDURE flipptest
.| Glob. Var.: flipp#,smark#,nr#,smpedit&,a$,popups&,smpmark&,mover&
.| Ruft auf  : textfeld
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,edhandler2-2,
IF flipp=TRUE AND smark<>3 THEN
smark=3
IF nr=smpedit& THEN
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE sram
.| Glob. Var.: vsramda#
.| Aufruf in : setupdat-1,
IF vsramda=FALSE THEN
vsramda=TRUE
ELSE
vsramda=FALSE
ENDIF
RETURN
'
> PROCEDURE fselwahl
IF vneufsel=FALSE THEN
vneufsel=TRUE
ELSE
vneufsel=FALSE
ENDIF
RETURN
'
> PROCEDURE recbutt
.| Glob. Var.: obj#,recl&,vmin#,recr&,f$,recm&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : setupdat-1,
IF obj=recl& AND vmin>1 THEN
DEC vmin
ENDIF
IF obj=recr& AND vmin<100 THEN
INC vmin
ENDIF
f$=RIGHT$(SPACE$(5)+STR$(vmin),5)+CHR$(0)
@textfeld(recm&,f$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE mallmax
.| Glob. Var.: vmallmax#
.| Aufruf in : setupdat-1,
IF vmallmax=TRUE THEN
vmallmax=FALSE
ELSE
vmallmax=TRUE
ENDIF
RETURN
'
> PROCEDURE tresbutt
.| Glob. Var.: obj#,tresl&,vth#,tresr&,tdb#,aufloes#,tdb$,tresdb&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : setupdat-1,
IF obj=tresl& AND vth>199 THEN
vth=vth-100
ENDIF
IF obj=tresr& AND vth<32668 THEN
vth=vth+100
ENDIF
tdb=vth
tdb=20*LOG10(tdb*2)
tdb=tdb-96.32
tdb=INT(tdb*1000)/1000
tdb$=STR$(tdb)+CHR$(0)
@textfeld(tresdb&,tdb$,1)
setbutton(obj,0)
RETURN
'
> PROCEDURE timecorr
.| Glob. Var.: i#,loopz#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp3
.| Aufruf in : do_blkf-1,
LOCAL j
FOR j=1 TO 4
IF loops%(sms,j)<>-1 THEN
@markhlp3(sms,j,loops%(sms,j))
ENDIF
NEXT j
RETURN
'
> PROCEDURE markdel
.| Glob. Var.: smplen#,vmem#,i#,loopz#,smark#,nr#,smpedit&,a$,popups&
.|     smpmark&,mover&,master#
.| Felder    : loops#(),loope#()
.| Ruft auf  : textfeld,fnamwrite
.| Aufruf in : ldhlp-2,smpedit-2,trash-2,memtovirt-1,memtovirt2-1,record2-1,
LOCAL i,j
smplen=vmem
retime=0
aretime=0
FOR i=1 TO loopz
FOR j=1 TO 4
loops%(i,j)=-1
NEXT j
edmtxt$(i)=""
NEXT i
smark=3
IF nr=smpedit& THEN
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
ENDIF
sms=0
sms2=0
@fnamwrite
@clipdel
RETURN
'
> PROCEDURE smpstx(i,i2)
sms2=i2
@marktextsel(i2)
sms=i
IF loops%(i,i2)=-1 THEN
@markhlp
loops%(i,i2)=0
@markhlp2
@markhlp3(i,sms2,loops%(i,i2))
ELSE
@markhlp4(loops%(i,i2))
ENDIF
RETURN
'
> PROCEDURE smph1
.| Glob. Var.: master#,loopz#,x#
.| Felder    : loops#(),loope#()
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-2,smpr-2,edhandler2-1,
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
x=loops%(sms,sms2)
ENDIF
RETURN
'
> PROCEDURE smph3
.| Glob. Var.: master#,loopz#,sms#,a#,sme#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp8,selblkshak,textfeld,selblksbut,selblkehak,selblkebut
.|     testsme,testsms,smpstx,smpex,smpsts,smpes
.| Aufruf in : trash-1,
LOCAL j
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
@markhlp8(sms,sms2,loops%(sms,sms2))
loops%(sms,sms2)=-1
sms2=0
ENDIF
sms=0
@testsms
IF sms>0 AND sms<=loopz THEN
FOR j=1 TO 4
@smpstx(sms,j)
NEXT j
@edmarkset(sms)
ENDIF
RETURN
'
> PROCEDURE testsms
.| Glob. Var.: i#,loopz#,master#
.| Felder    : loops#()
.| Aufruf in : smph3-2,
FOR i=loopz TO 1 STEP -1
IF loops%(i,1)<>-1 THEN
sms=i
ENDIF
NEXT i
RETURN
'
> PROCEDURE markhlp4(bx)
.| Glob. Var.: cs#,ce#,xm#,xd#,stay1#,stay2#,t$
.| Aufruf in : smpstx-1,smpsts-1,smpex-1,smpes-1,
LOCAL cx
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE cx+xd,stay1,cx+xd,stay2
LINE cx+xd,stay1,cx+xd,stay2
DEFTEXT 1,0,0,4
TEXT cx+xd-2,stay1-1,t$
TEXT cx+xd-2,stay1-1,t$
IF credraw=FALSE THEN
CLIP OFF
ENDIF
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
ENDIF
RETURN
'
> PROCEDURE markhlp6(bx)
.| Glob. Var.: cs#,ce#,xm#,xd#,stay1#,stay2#,t$
.| Ruft auf  : markhlp
.| Aufruf in : markprod3-4,edhandler2-1,markset-2,
LOCAL cx
@markhlp
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE cx+xd,stay1,cx+xd,stay2
DEFTEXT 1,0,0,4
TEXT cx+xd-2,stay1-1,t$
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
ENDIF
RETURN
'
> PROCEDURE setadatp
IF demo=FALSE THEN
~XBIOS(&H8A,0,7)
~XBIOS(&H8A,2,7) ! fÅr ADAT-Play den GPIO auf 111 setzen
ENDIF
RETURN
'
> PROCEDURE setadatr
IF demo=FALSE THEN
~XBIOS(&H8A,0,7)
~XBIOS(&H8A,2,5) ! fÅr ADAT-Rec den GPIO auf 101 setzen
ENDIF
RETURN
'
> PROCEDURE pcgsetup
a=INT(synchertz/512)
@setpcg(a)
a$=STR$(a)
IF LEN(a$)>5 THEN
a$=RIGHT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@editfeld(syncsrte&,a$)
RETURN
'
> PROCEDURE setpcg(chz)  ! chz=764-96000 Hz (mehr mîglich, aber nicht empfohlen)
~XBIOS(&H8A,0,7)
~XBIOS(&H8A,2,0) ! fÅr ADAT-Play den GPIO auf 111 setzen
'
pcgout=FALSE
ref=12.5*1000^2
'
@clockcalc(ref,chz)
'
IF pcgout=TRUE THEN
CLS
PRINT "f_vco","(50-150 MHz)",freqvco
PRINT "mux","(0-7)",mux
PRINT "P","(4-130)",p
PRINT "Q","(3-129)",q
PRINT
PRINT "sampleraten-wunsch:",chz
PRINT "tatsÑchliche samplerate:",freqhz
ENDIF
'
@progword(p,1,mux,q,index)
@sendcontrol(&X1111000000101)
@sendprotocol(pw)
@sendcontrol(&X1111000000000)
RETURN
'
> PROCEDURE clockcalc(freqref,chz)
freqout=chz*512
freqvco=freqout
mux=0
WHILE freqvco<(50*1000^2) AND mux<7
INC mux
freqvco=freqout*2^mux
WEND
faktor=freqvco/(freqref*2)
pv=3
p=3
q=3
REPEAT
INC pv
qv=INT(pv/faktor)
IF qv<3 THEN
qv=3
ENDIF
IF qv>129 THEN
qv=129
ENDIF
IF (ABS((pv/qv)-faktor))<=(ABS((p/q)-faktor)) THEN
p=pv
q=qv
ENDIF
INC qv
IF qv>129 THEN
qv=129
ENDIF
IF (ABS((pv/qv)-faktor))<=(ABS((p/q)-faktor)) THEN
p=pv
q=qv
ENDIF
UNTIL pv=130
ppm=INT((1000^2)*ABS((p/q)-faktor))
freqout=INT(2*freqref*(p/q))
pcgfreq=INT(freqout/(2^mux))
freqhz=INT(pcgfreq/512)
index=0
IF freqout>80*1000^2 THEN
index=&X1000
ENDIF
RETURN
'
> PROCEDURE progword(p,duty,mux,q,index)
pw=index+(q-2)*&X10000+mux*&X100000000000+duty*&X100000000000000+(p-3)*&X1000000000000000
RETURN
'
> PROCEDURE sendcontrol(cwv)
FOR i=0 TO 13
bit=(cwv AND 1)
cwv=SHR(cwv,1)
@sendbit(bit)
NEXT i
RETURN
'
> PROCEDURE sendprotocol(pwv)
j=0
FOR i=0 TO 21
bit=(1 AND pwv)
pwv=SHR(pwv,1)
IF bit=1 THEN
INC j
ELSE
j=0
ENDIF
@sendbit(bit)
IF j=3 THEN
@sendbit(0)
j=0
ENDIF
NEXT i
RETURN
'
> PROCEDURE sendbit(sbit)
LOCAL v,i
v=8
v=BSET(v,2) ! set ADAT-bit
IF sbit=0 THEN
v=BCLR(v,1)
~XBIOS(&H8A,2,v)
ELSE
v=BSET(v,1)
~XBIOS(&H8A,2,v)
ENDIF
'  FOR i=0 TO 100
' NEXT i
v=BSET(v,0)
~XBIOS(&H8A,2,v)
v=BCLR(v,0)
~XBIOS(&H8A,2,v)
RETURN
'
> PROCEDURE setup2
.| Glob. Var.: vnr#,nr#,mrkhandle#,mrkhandle2#,v1#,v2#,v3#,stl#,sth#,std#
.|     zomslide&,zoombutt&,zmax#,zoomp#
.| Ruft auf  : makehz,fnamwrite,sethertz,write_reglow,write_reghigh
.|     write_dsp,slideinit,analog
.| Aufruf in : smpedit-1,
vnr=nr
@makehz
~WIND_GET(mrkhandle,10,mrkhandle2,v1,v2,v3)
@fnamwrite
@sethertz
IF demo=FALSE THEN
~XBIOS(xbs,26,0)          ! recordmode=normal
~XBIOS(xbs,27,0)          ! playmode=normal
~XBIOS(xbs,20,ad)         ! Analog oder Digitaleingang benutzen
~XBIOS(xbs,21,digsource)  ! Opto,Koax oder AESEBU benutzen
~XBIOS(xbs,23,clk)        ! Taktrate wÑhlen
~XBIOS(xbs,25,0)          ! Switch to Bypass-Output
@kickstart
IF dig24=FALSE THEN
~XBIOS(xbs,28,0)
ELSE
~XBIOS(xbs,28,1)
ENDIF
ENDIF
'  @write_dsp(std)
@slideinit(zomslide&,zoombutt&,zmax,16,zoomp)
@sourcein
'
IF demo=FALSE THEN
~XBIOS(&H8B,0,0,0,clk,1)
~XBIOS(&H8B,1,0,0,clk,1)
~XBIOS(&H8B,2,0,0,clk,1)
~XBIOS(&H8B,3,0,0,clk,1)
@setadatp
ENDIF
@setsync
IF newmem=TRUE THEN
memmx=&H800000         ! Wenn mallmax=FALSE,dann memmx-Speicher anfordern
ENDIF
RETURN
'
> PROCEDURE conmix
.| Glob. Var.: obj#
.| Ruft auf  : blkrestaura,setbutton
.| Aufruf in : do_blkf-1,
@blkrestaura
@setbutton(obj,0)
RETURN
'
> PROCEDURE conspace
@markhlp
vorvornr=vornr
cvobj=obj
oldspc=spc
vornr=nr
nr=record&
a$="SPACE-TIME"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
@rsc_draw(nr,0)
@markhlp
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld(recfree&,a$,1)
spc=0
REPEAT
@timeinp(mmax,spc)
IF obj=rechelp& THEN
@helptxt("SPACE-TIME")
ENDIF
UNTIL obj<>rechelp&
IF obj=recok& THEN
@rsc_back(nr)
IF sblock=1 THEN
@blkltest
ELSE
IF virtual=TRUE THEN
conc=virtln
ELSE
conc=mlen
ENDIF
ENDIF
@makehz
df=spc*hz/100*mbit
IF virtual=FALSE THEN
nr=smpedit&
@editselect
inspace=TRUE
@coninsert
inspace=FALSE
ELSE
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
a=ASC(LEFT$(virtpath$,1))-64
IF virtwfile=FALSE AND conc=virtln AND df>0 THEN
IF DFREE(a)>=df THEN
OPEN "U",#1,virtpath$
a=RINSTR(virtpath$,"\")
SEEK #1,virtln
bytes=INT(mlen/mbit)*mbit
vln=INT(df/mbit)*mbit
IF df>mlen THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+df)
ENDIF
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
IF (virtwfile=TRUE OR (conc<virtln AND virtwfile=FALSE)) AND df>0 THEN
nr=smpedit&
@editselect
inspace=TRUE
@coninsert
inspace=FALSE
ELSE
cached=FALSE
makevirt2=TRUE
@editselect
@memtovirt
@blkrestaura
ENDIF
ENDIF
ELSE
spc=oldspc
@rsc_back(nr)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
nr=blkfunc&
IF nr=blkfunc& THEN
@setbutton(cvobj,0)
ENDIF
obj=0
RETURN
'
> PROCEDURE coninsert
.| Glob. Var.: vobj#,obj#,makevirt#,makevirt2#,inspace#,op$,ext$,mp$,nr#
.|     fil$,pbutt#,df#,sblock#,virtual#,conc#,virtln#,mlen#,loopz#,meml#
.|     vln#,cached#,a#,path$,workf$,workfile$,lfw$,dazu#,bytes#,mbytes#
.|     smpnam$,mbs#,smpedit&,hard&,virtpath$,virtwfile#,virtp$,virtfile$
.|     memh#
.| Felder    : loops#(),loope#()
.| Ruft auf  : fileselect,rsc_redraw_obj,blkltest,maschinit9,maschruf9
.|     setbutton,rettmem,nomem,busy_mouse,memtovirt
.| Aufruf in : do_blkf-1,conspace-2,
LOCAL okay,okay2
vobj=obj
makevirt=FALSE
makevirt2=FALSE
okay=FALSE
okay2=FALSE
IF inspace=FALSE THEN
@fileselect(op$+"*."+ext$,mp$,"INSERT:")
IF EXIST(fil$) AND pbutt=1 THEN
@headart2(fil$)
OPEN "I",#1,fil$
df=LOF(#1)-head
CLOSE #1
okay2=TRUE
ELSE
okay2=FALSE
ENDIF
IF sblock=1 THEN
@blkltest
conc=loops%(sms,1)
ELSE
IF virtual=TRUE THEN
conc=virtln
ELSE
conc=mlen
ENDIF
ENDIF
ELSE
okay2=TRUE
ENDIF
IF virtual=FALSE AND okay2=TRUE AND df>0 THEN
IF sblock=1 AND conc+df<=mlen AND loops%(sms,1)>=0 AND loops%(sms,2)>0 AND loops%(sms,2)-loops%(sms,1)>0 AND (loops%(sms,2)+df)<=mlen THEN
IF conc<loops%(sms,2) THEN
BMOVE meml+conc,meml+conc+df,memh-(meml+conc+df)
loops%(sms,2)=loops%(sms,2)+df
loops%(sms,1)=loops%(sms,1)+df
ENDIF
vln=INT(df/mbit)*mbit
conc=INT(conc/mbit)*mbit
IF inspace=FALSE THEN
OPEN "I",#1,fil$
@busy_mouse
IF vln>3 THEN
SEEK #1,head
BGET #1,meml+conc,vln
ENDIF
@busy_mouse
CLOSE #1
ELSE
@maschruf9(meml+conc,meml+conc+vln)
ENDIF
cached=FALSE
ELSE
a=RINSTR(path$,"\")
IF a>0 THEN
workf$=LEFT$(path$,a)+workfile$
ELSE
workf$=lfw$+workfile$
ENDIF
a=ASC(LEFT$(workf$,1))-64
vln=INT(df/mbit)*mbit
df=vln
IF loops%(sms,1)>=0 AND sblock=1 THEN
dazu=INT(loops%(sms,1)/mbit)*mbit
ELSE
'        dazu=0
dazu=mlen
ENDIF
IF loops%(sms,2)>=0 AND loops%(sms,2)<=mlen AND sblock=1 THEN
bytes=(INT(loops%(sms,2)/mbit)*mbit)-dazu
ELSE
bytes=mlen-dazu
ENDIF
mbytes=bytes+dazu
'      conc=conc-dazu
IF conc<0 THEN
conc=0
ENDIF
IF conc>bytes THEN
'        conc=bytes
ENDIF
IF DFREE(a)>=mlen+vln THEN
@busy_mouse
OPEN "O",#1,workf$
'
'
'
'
BPUT #1,meml,bytes+dazu
'        PRINT "1:";workf$,bytes+dazu,mlen
CLOSE #1
virtual=TRUE
path$=workf$
smpnam$=workfile$
mbs=0
IF nr=smpedit& THEN
@setbutton(hard&,1)
ENDIF
makevirt=TRUE
conc=INT(conc/mbit)*mbit
virtln=bytes+conc
okay2=TRUE
virtpath$=workf$
'        @rettmem
ELSE
@nomem
ENDIF
ENDIF
ENDIF
IF virtual=TRUE AND okay2=TRUE THEN
'
origpath$=virtpath$
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
@busy_mouse
KILL dcach$
ENDIF
ENDIF
'
a=ASC(LEFT$(virtpath$,1))-64
IF virtwfile=FALSE AND conc=virtln AND df>0 AND inspace=FALSE THEN
IF DFREE(a)>=df THEN
OPEN "U",#1,virtpath$
a=RINSTR(virtpath$,"\")
OPEN "I",#2,fil$
SEEK #1,virtln
SEEK #2,head
bytes=INT(mlen/mbit)*mbit
vln=INT(df/mbit)*mbit
makevirt2=TRUE
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #2,meml,bytes
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
CLOSE #1
CLOSE #2
ELSE
@nomem
makevirt2=FALSE
makevirt=FALSE
ENDIF
ELSE
IF DFREE(a)>=(virtln+df) AND df>0 THEN
OPEN "I",#1,virtpath$
'
'
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
'
'
'
'
IF inspace=FALSE THEN
OPEN "I",#3,fil$
SEEK #3,head
ENDIF
IF conc>0 AND conc<=virtln THEN
bytes=INT(mlen/mbit)*mbit
vln=INT(conc/mbit)*mbit
'          PRINT "2:";virtpath$,vln
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
ENDIF
IF inspace=TRUE THEN
IF df>mlen THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+df)
ENDIF
ENDIF
bytes=INT(mlen/mbit)*mbit
vln=INT(df/mbit)*mbit
'        PRINT "3:";fil$,vln
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF inspace=FALSE THEN
BGET #3,meml,bytes
ENDIF
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
IF conc<virtln THEN
bytes=INT(mlen/mbit)*mbit
vln=INT((virtln-conc)/mbit)*mbit
'          PRINT "4:";virtpath$,vln
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
ENDIF
CLOSE #1
CLOSE #2
IF inspace=FALSE THEN
CLOSE #3
ENDIF
IF virtwfile=FALSE THEN
@busy_mouse
KILL virtpath$
RENAME virtp$ AS virtpath$
makevirt2=TRUE
ENDIF
ELSE
@nomem
makevirt2=FALSE
makevirt=FALSE
ENDIF
ENDIF
nr=smpedit&
@editselect
@memtovirt
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@blkrestaura
@setbutton(vobj,0)
RETURN
'
> PROCEDURE memtovirt
.| Glob. Var.: makevirt#,makevirt2#,makevirt3#,path$,workf$,a#,smpnam$,vmem#
.|     mbytes#,df#,vmeml#,vmemh#,mlen#,hrd#,cached#,virtcurve#,vvv#,smplen#
.|     meml#,memh#,virtual#,blks#,vce#,vcs#,lz#,nr#,smpedit&,hard&,cs#,ce#
.| Ruft auf  : hardproof2,maschinit9,maschruf9,markdel,clsed,fnamwrite
.|     setbutton
.| Aufruf in : coninsert-1,
IF makevirt=TRUE OR makevirt2=TRUE OR makevirt3=TRUE THEN
IF makevirt=TRUE OR makevirt3=TRUE THEN
path$=workf$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
vmem=mbytes+df
ELSE
vmem=vmem+df
ENDIF
virtln=vmem
vmeml=0
vmemh=mlen
hrd=1
cached=FALSE
virtcurve=FALSE
IF vmem>mlen THEN
fil$=virtpath$
@hardproof2
vvv=TRUE
smplen=vmem
ELSE
IF vmem<mlen THEN
@maschruf9(meml+vmem,memh)
ENDIF
IF makevirt=TRUE OR makevirt3=TRUE THEN
BLOAD workf$,meml
KILL workf$
ELSE
BLOAD path$,meml
ENDIF
vvv=FALSE
virtual=FALSE
cached=FALSE
smplen=vmem
vmem=mlen
cs=0
ce=vmem
ENDIF
blks=0
vce=0
vcs=0
lz=1
IF makevirt3=FALSE THEN
'     @rsc_back(nr)
'      nr=vornr
'    @rsc_draw(nr,5)
ENDIF
@markdel
@clsed
path$=workf$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@fnamwrite
IF nr=smpedit& THEN
IF vvv=TRUE THEN
@setbutton(hard&,1)
hrd=1
ELSE
@setbutton(hard&,0)
hrd=0
ENDIF
ENDIF
cs=0
ce=vmem
ELSE
cached=FALSE
ENDIF
makevirt=FALSE
makevirt2=FALSE
makevirt3=FALSE
RETURN
'
> PROCEDURE memtovirt2
.| Glob. Var.: vmeml#,vmemh#,mlen#,cached#,virtcurve#,vmem#,vvv#,smplen#
.|     meml#,memh#,makevirt#,makevirt3#,workf$,virtual#,blks#,vce#,vcs#,lz#
.|     nr#,vornr#,noblkdel#,smpedit&,hard&,hrd#,cs#,ce#
.| Ruft auf  : hardproof2,maschinit9,maschruf9,rsc_back,rsc_draw,markdel
.|     clsed,fnamwrite,setbutton
.| Aufruf in : fade_it-1,smpkhlp-1,smpmhlp-2,smpihlp-1,smpcut-2,virtmove-1
.|     virtcopy-1,virtins-1,mono-1,negate-1,lrchange-1,makenorm-1
.|     makeresmp-1,
backvtom=FALSE
vmeml=0
vmemh=mlen
cached=FALSE
virtcurve=FALSE
IF vmem>mlen THEN
@hardproof2
vvv=TRUE
smplen=vmem
ELSE
IF vmem<mlen THEN
@maschruf9(meml+vmem,memh)
ENDIF
IF makevirt=TRUE OR makevirt3=TRUE THEN
BLOAD workf$,meml
KILL workf$
ELSE
OPEN "I",#1,path$
smplen=LOF(#1)-head
SEEK #1,head
BGET #1,meml,smplen
CLOSE #1
'      BLOAD path$,meml
ENDIF
vvv=FALSE
virtual=FALSE
cached=FALSE
vmem=mlen
cs=0
ce=vmem
ENDIF
blks=0
vce=0
vcs=0
lz=1
IF makevirt3=FALSE THEN
nr=smpedit&
@editselect
ENDIF
IF noblkdel=FALSE THEN
@markdel
@clsed
ENDIF
@fnamwrite
IF nr=smpedit& THEN
IF vvv=TRUE THEN
@setbutton(hard&,1)
hrd=1
ELSE
@setbutton(hard&,0)
hrd=0
ENDIF
ENDIF
cs=0
ce=vmem
makevirt3=FALSE
RETURN
'
> PROCEDURE makesmpte(position)
LOCAL fz,h,m,s,ms
IF sendsmpte=TRUE THEN
fz=framez
ms=INT(position/hz/mbit*fz)
IF sendsmpte=TRUE AND ms<>omspos THEN
omspos=ms
h=INT(ms/(fz*60*60))
ms=ms-h*fz*60*60
m=INT(ms/(fz*60))
ms=ms-m*fz*60
s=INT(ms/fz)
ms=ms-s*fz
'
msl=(ms AND 15)
msh=INT(ms/16)+&H10
sl=(s AND 15)+&H20
sh=INT(s/16)+&H30
ml=(m AND 15)+&H40
mh=INT(m/16)+&H50
hl=(h AND 15)+&H60
hh=INT(h/16)+&H70
'
OUT 3,&HF1
OUT 3,msl
OUT 3,&HF1
OUT 3,msh
OUT 3,&HF1
OUT 3,sl
OUT 3,&HF1
OUT 3,sh
OUT 3,&HF1
OUT 3,ml
OUT 3,&HF1
OUT 3,mh
OUT 3,&HF1
OUT 3,hl
OUT 3,&HF1
OUT 3,hh
ENDIF
ENDIF
RETURN
'
> PROCEDURE workmode
LOCAL a$,ms,h,m,s,fz,a1$,a2$,a3$,a4$
IF BTST(winh,wmode&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=wmode&
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
ELSE
@setbutton(wmodes&,0)
@alerts(11)
ENDIF
a$=STR$(synchertz)+CHR$(0)
@editfeld(synchz&,a$)
a$=STR$(INT(synchertz/512))
IF LEN(a$)>5 THEN
a$=RIGHT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@editfeld(syncsrte&,a$)
'
fz=framez
ms=smptestrt
h=INT(ms/(fz*60*60))
ms=ms-h*fz*60*60
m=INT(ms/(fz*60))
ms=ms-m*fz*60
s=INT(ms/fz)
ms=ms-s*fz
a1$=STR$(h)
IF LEN(a1$)<2 THEN
a1$="0"+a1$
ENDIF
a2$=STR$(m)
IF LEN(a2$)<2 THEN
a2$="0"+a2$
ENDIF
a3$=STR$(s)
IF LEN(a3$)<2 THEN
a3$="0"+a3$
ENDIF
a4$=STR$(ms)
IF LEN(a4$)<2 THEN
a4$="0"+a4$
ENDIF
a$=a1$+a2$+a3$+a4$+CHR$(0)
@editfeld(smpteset&,a$)
'
IF pcg=TRUE THEN
@setbutton(syncpcg&,1)
ELSE
@setbutton(syncpcg&,0)
ENDIF
IF mtc=TRUE THEN
@setbutton(syncmtc&,1)
ELSE
@setbutton(syncmtc&,0)
ENDIF
IF sendsmpte=TRUE THEN
@setbutton(syncxmit&,1)
ELSE
@setbutton(syncxmit&,0)
ENDIF
IF adat=TRUE THEN
@setbutton(syncadat&,1)
ELSE
@setbutton(syncadat&,0)
ENDIF
IF fmclk=TRUE THEN
@setbutton(clkfalc&,1)
ELSE
@setbutton(clkfalc&,0)
ENDIF
IF framez=24 THEN
@setbutton(frame25&,0)
@setbutton(frame30&,0)
@setbutton(frame24&,1)
ENDIF
IF framez=25 THEN
@setbutton(frame24&,0)
@setbutton(frame30&,0)
@setbutton(frame25&,1)
ENDIF
IF framez=30 THEN
@setbutton(frame24&,0)
@setbutton(frame25&,0)
@setbutton(frame30&,1)
ENDIF
IF bigram=FALSE THEN
@setbutton(ramhi&,0)
@setbutton(ramlo&,1)
ELSE
@setbutton(ramlo&,0)
@setbutton(ramhi&,1)
ENDIF
IF dig24=FALSE THEN
@setbutton(mast24&,0)
@setbutton(mast16&,1)
ELSE
@setbutton(mast16&,0)
@setbutton(mast24&,1)
ENDIF
IF rch4=FALSE AND rmo8=FALSE THEN
@setbutton(recm4&,0)
@setbutton(recm8&,0)
@setbutton(recm2&,1)
ENDIF
IF rch4=TRUE AND rmo8=FALSE THEN
@setbutton(recm2&,0)
@setbutton(recm8&,0)
@setbutton(recm4&,1)
ENDIF
IF rch4=FALSE AND rmo8=TRUE THEN
@setbutton(recm2&,0)
@setbutton(recm4&,0)
@setbutton(recm8&,1)
ENDIF
IF matrix=FALSE THEN
@setbutton(mixdma&,0)
@setbutton(mixdsp&,0)
@setbutton(mixcpu&,1)
ENDIF
IF matrix=TRUE AND mixdsp=FALSE THEN
@setbutton(mixdsp&,0)
@setbutton(mixcpu&,0)
@setbutton(mixdma&,1)
ENDIF
IF matrix=TRUE AND mixdsp=TRUE THEN
@setbutton(mixcpu&,0)
@setbutton(mixdma&,0)
@setbutton(mixdsp&,1)
ENDIF
ELSE
vornr=nr
nr=wmode&
IF vornr=smpedit& THEN
@setbutton2(wmode&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE setsync
LOCAL b1$,b24,b3$,b4$
adat0$=" EXT     "
IF adat=TRUE THEN
masterclk=24576000
@adextl2
ELSE
masterclk=synchertz
ENDIF
b1$=STR$(INT(masterclk/76800)/10)
b2$=STR$(INT(masterclk/51200)/10)
b3$=STR$(INT(masterclk/38400)/10)
b4$=STR$(INT(masterclk/25600)/10)
IF INSTR(b1$,".")=0 THEN
b1$=b1$+".0"
ENDIF
IF INSTR(b2$,".")=0 THEN
b2$=b2$+".0"
ENDIF
IF INSTR(b3$,".")=0 THEN
b3$=b3$+".0"
ENDIF
IF INSTR(b4$,".")=0 THEN
b4$=b4$+".0"
ENDIF
IF LEN(b1$)<4 THEN
b1$=" "+b1$
ENDIF
IF LEN(b2$)<4 THEN
b2$=" "+b2$
ENDIF
IF LEN(b3$)<4 THEN
b3$=" "+b3$
ENDIF
IF LEN(b4$)<4 THEN
b4$=" "+b4$
ENDIF
adat1$=" ADAT  48 "
adat2$="   ADAT  48  "
IF adat=TRUE THEN
@stringfeld(popups&,adextl2&,adat1$+CHR$(0),1)
@stringfeld(popups&,ratextl2&,adat2$+CHR$(0),1)
ELSE
@stringfeld(popups&,adextl2&,adat0$+CHR$(0),1)
@stringfeld(popups&,ratextl2&,adat0$+" kHz"+CHR$(0),1)
@stringfeld(popups&,adextl2&,b2$+CHR$(0),6)
@stringfeld(popups&,ratextl2&,b2$+CHR$(0),6)
ENDIF
@stringfeld(popups&,adexth2&,b1$+CHR$(0),6)
@stringfeld(popups&,adexth1&,b3$+CHR$(0),6)
@stringfeld(popups&,adextl1&,b4$+CHR$(0),6)
@stringfeld(popups&,ratexth2&,b1$+CHR$(0),6)
@stringfeld(popups&,ratexth1&,b3$+CHR$(0),6)
@stringfeld(popups&,ratextl1&,b4$+CHR$(0),6)
RETURN
'
> PROCEDURE do_workmode
LOCAL fz,h,m,s,ms
@editread(synchz&)
IF obj<>synchz& AND obj<>smpteset& AND obj<>syncsrte THEN
edit_obj&=0
ENDIF
IF synchertz<>VAL(a$) THEN
synchertz=VAL(a$)
@setsync
ENDIF
'
@editread(smpteset&)
IF LEN(a$)=8 THEN
fz=framez
h=VAL(LEFT$(a$,2))
m=VAL(MID$(a$,3,2))
s=VAL(MID$(a$,5,2))
ms=VAL(MID$(a$,7,2))
smptestrt=h*fz*60*60+m*fz*60+s*fz+ms
ENDIF
'
IF obj=frame24& THEN
@setbutton(frame25&,0)
@setbutton(frame30&,0)
@setbutton(frame24&,1)
framez=24
ENDIF
IF obj=frame25& THEN
@setbutton(frame24&,0)
@setbutton(frame30&,0)
@setbutton(frame25&,1)
framez=25
ENDIF
IF obj=frame30& THEN
@setbutton(frame24&,0)
@setbutton(frame25&,0)
@setbutton(frame30&,1)
framez=30
ENDIF
IF obj=wmhelp& THEN
@helptxt("WORKMODE")
ENDIF
IF obj=syncalc& THEN
@editread(syncsrte&)
a=VAL(a$)
@setpcg(a)
synchertz=pcgfreq
a$=STR$(synchertz)+CHR$(0)
@editfeld(synchz&,a$)
a$=STR$(INT(pcgfreq/512))
IF LEN(a$)>5 THEN
a$=RIGHT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@editfeld(syncsrte&,a$)
@setsync
@setbutton(obj,0)
ENDIF
IF obj=syncadat& THEN
IF adat=TRUE THEN
adat=FALSE
@setsync
ELSE
adat=TRUE
@setsync
ENDIF
ENDIF
IF obj=syncpcg& THEN
IF pcg=FALSE THEN
pcg=TRUE
ELSE
pcg=FALSE
ENDIF
@pcgsetup
ENDIF
IF obj=syncmtc& THEN
IF mtc=FALSE THEN
mtc=TRUE
ELSE
mtc=FALSE
ENDIF
@mtcsetup
ENDIF
IF obj=syncxmit& THEN
IF sendsmpte=FALSE THEN
sendsmpte=TRUE
ELSE
sendsmpte=FALSE
ENDIF
ENDIF
IF obj=clkfalc& THEN
IF fmclk=FALSE THEN
fmclk=TRUE
clkmode=3
ELSE
fmclk=FALSE
clkmode=2
ENDIF
IF clkmode=1 THEN
cdivz=60
ENDIF
IF clkmode=2 THEN
cdivz=38
ENDIF
IF clkmode=3 THEN
cdivz=14
ENDIF
IF cdivz<cdivsms THEN
cdivsms=cdivz
ENDIF
ENDIF
IF obj=ramhi& THEN
bigram=TRUE
ENDIF
IF obj=ramlo& THEN
bigram=FALSE
ENDIF
IF obj=mast24& THEN
@setbitrate24
ENDIF
IF obj=mast16& THEN
@setbitrate16
ENDIF
IF obj=recm2& THEN
rch4=FALSE
rmo8=FALSE
ENDIF
IF obj=recm4& THEN
rch4=TRUE
rmo8=FALSE
ENDIF
IF obj=recm8& THEN
rch4=FALSE
rmo8=TRUE
ENDIF
IF obj=mixcpu& THEN
matrix=FALSE
mixdsp=FALSE
ENDIF
IF obj=mixdma& THEN
matrix=TRUE
mixdsp=FALSE
ENDIF
IF obj=mixdsp& THEN
matrix=TRUE
mixdsp=TRUE
ENDIF
IF obj=wmexit& OR obj=9999 THEN
winh=BCLR(winh,wmode&)
@setbutton(wmexit&,0)
@restaura2b
obj=0
@fliphz
IF ext>0 THEN
IF cdivsms=-1 THEN
cdivsms=1
ENDIF
@addiv3
@addiv2
@fliphz2
ENDIF
IF adat=TRUE THEN
@setsync
ENDIF
IF nr=smpedit& THEN
@setbutton(wmodes&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE monitor
.| Glob. Var.: p#,mdat%,nr#,smpedit&,monitor&
.| Ruft auf  : digout,maschinit6,maschruf6,setbutton
.| Aufruf in : drop2-1,do_smpedit-1,do_peak-1,
'
p=mdat%
POKE p,7
POKE p+1,4
~XBIOS(25,1,L:p)
@digout(TRUE)
@maschruf6
@digout(FALSE)
PAUSE 20
p=mdat%
POKE p,7
POKE p+1,0
~XBIOS(25,1,L:p)
IF nr=smpedit& THEN
'    @setbutton(monitor&,0)
ENDIF
RETURN
'
> PROCEDURE mtcsetup
IF demo=FALSE THEN
IF mtc=TRUE THEN
~XBIOS(xbs,161)
~XBIOS(xbs,162,1)
ELSE
~XBIOS(xbs,162,0)
~XBIOS(xbs,161)
ENDIF
ENDIF
RETURN
'
> PROCEDURE mono
.| Glob. Var.: virtual#,sblock#,meml#,memh#,mcs#,mce#,mono&,obj#,bytes#
.|     mlen#,virtwfile#,virtpath$,virtln#,virtp$,virtfile$,c1#,c2#,seekz#
.|     path$,smpnam$,vmem#,noblkdel#
.| Ruft auf  : maschinit17,maschruf17,blocklook,setbutton,busy_mouse
.|     hardproof3,memtovhrt2,nomem,blkrestaura
.| Aufruf in : do_blkf-1,
LOCAL okay,a,vln,okay2
okay2=FALSE
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf17(meml,memh)
ELSE
@blocklook
@maschruf17(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
'    @restaura
okay2=TRUE
@setbutton(mono&,0)
obj=0
ELSE
bytes=INT(mlen/mbit)*mbit
okay=FALSE
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
IF sblock=1 THEN
@blocklook
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
seekz=0
vln=c1
IF virtwfile=FALSE THEN
SEEK #1,seekz
ELSE
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
vln=c2-c1
seekz=c1
ELSE
vln=virtln
seekz=0
ENDIF
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschruf17(meml,meml+bytes)
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 AND virtwfile=TRUE THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
IF sblock=1 AND virtwfile=TRUE THEN
seekz=c2
vln=virtln-c2
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
nr=smpedit&
@editselect
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
ENDIF
@blkrestaura
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(mono&,0)
obj=0
RETURN
'
> PROCEDURE negate
.| Glob. Var.: virtual#,sblock#,meml#,memh#,mcs#,mce#,negate&,obj#,bytes#
.|     mlen#,virtwfile#,virtpath$,virtln#,virtp$,virtfile$,c1#,c2#,seekz#
.|     path$,smpnam$,vmem#,noblkdel#
.| Ruft auf  : maschinit34,maschruf34,blocklook,restaura,setbutton
.|     busy_mouse,hardproof3,memtovirt2,nomem,blkrestaura
.| Aufruf in : do_blkf-1,
LOCAL okay,a,vln,okay2
okay2=FALSE
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf34(meml,memh)
ELSE
@blocklook
@maschruf34(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@restaura
okay2=TRUE
@setbutton(negate&,0)
obj=0
ELSE
bytes=INT(mlen/mbit)*mbit
okay=FALSE
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
IF sblock=1 THEN
@blocklook
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
seekz=0
vln=c1
IF virtwfile=FALSE THEN
SEEK #1,seekz
ELSE
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
vln=c2-c1
seekz=c1
ELSE
vln=virtln
seekz=0
ENDIF
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschruf34(meml,meml+bytes)
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 AND virtwfile=TRUE THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
IF sblock=1 AND virtwfile=TRUE THEN
seekz=c2
vln=virtln-c2
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
nr=smpedit&
@editselect
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
ENDIF
@blkrestaura
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(negate&,0)
obj=0
RETURN
'
> PROCEDURE lrchange
.| Glob. Var.: virtual#,sblock#,meml#,memh#,mcs#,mce#,lrchange&,obj#,bytes#
.|     mlen#,virtwfile#,virtpath$,virtln#,virtp$,virtfile$,c1#,c2#,seekz#
.|     path$,smpnam$,vmem#,noblkdel#
.| Ruft auf  : maschinit35,maschruf35,blocklook,restaura,setbutton
.|     busy_mouse,hardproof3,memtovirt2,nomem,blkrestaura
.| Aufruf in : do_blkf-1,
LOCAL okay,a,vln,okay2
okay2=FALSE
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf35(meml,memh)
ELSE
@blocklook
@maschruf35(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@restaura
okay2=TRUE
@setbutton(lrchange&,0)
obj=0
ELSE
bytes=INT(mlen/mbit)*mbit
okay=FALSE
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
IF sblock=1 THEN
@blocklook
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
seekz=0
vln=c1
IF virtwfile=FALSE THEN
SEEK #1,seekz
ELSE
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
vln=c2-c1
seekz=c1
ELSE
vln=virtln
seekz=0
ENDIF
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschruf35(meml,meml+bytes)
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 AND virtwfile=TRUE THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
IF sblock=1 AND virtwfile=TRUE THEN
seekz=c2
vln=virtln-c2
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
nr=smpedit&
@editselect
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
ENDIF
@blkrestaura
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(lrchange&,0)
obj=0
RETURN
'
> PROCEDURE harddisk
.| Glob. Var.: hrd#
.| Aufruf in : do_smpedit-1,
IF hrd=0 THEN
hrd=1
@setbutton(obj,1)
ELSE
hrd=0
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE midi
.| Glob. Var.: vornr#,nr#,midiedit&,db$,ch#,chtxt&,obj#,popup&,zu%,zuadr#,x#
.|     y#,v3#,but#,midicup&,midicdwn&,midinup&,midindwn&,midioup&,midiodwn&
.|     helpmidi&,midiok&,smpedit&,edmidi&
.| Ruft auf  : rsc_draw,markhlp,textfeld,makenote,rsc_do,xrsrc_gaddr,mouse
.|     channelup,channeldown,noteup,notedown,oktup,oktdown,helptxt,setbutton
.|     restaura2
.| Aufruf in : drop2-1,arrmidi-1,do_smpedit-1,
vornr=nr
nr=midiedit&
@rsc_draw(nr,0)
@markhlp
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(1,obj,zu%)
IF obj=midicup& THEN
@channelup
ENDIF
IF obj=midicdwn& THEN
@channeldown
ENDIF
IF obj=midinup& THEN
@noteup
ENDIF
IF obj=midindwn& THEN
@notedown
ENDIF
IF obj=midioup& THEN
@oktup
ENDIF
IF obj=midiodwn& THEN
@oktdown
ENDIF
IF obj=helpmidi& THEN
@helptxt("MIDI")
ENDIF
IF obj<>0 AND obj<>helpmidi& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=midiok&
@setbutton(obj,0)
@restaura2
obj=0
IF nr=smpedit& THEN
@setbutton(edmidi&,0)
ENDIF
RETURN
'
> PROCEDURE makefade
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=8
RETURN
'
> PROCEDURE channelup
.| Glob. Var.: ch#,db$,chtxt&
.| Ruft auf  : textfeld,makenote
.| Aufruf in : midi-1,
IF ch<16 THEN
ch=ch+1
ENDIF
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
RETURN
'
> PROCEDURE channeldown
.| Glob. Var.: ch#,db$,chtxt&
.| Ruft auf  : textfeld,makenote
.| Aufruf in : midi-1,
IF ch>1 THEN
ch=ch-1
ENDIF
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
RETURN
'
> PROCEDURE makenote
.| Glob. Var.: notetxt&,db$,midiwort#,ch#,note#
.| Ruft auf  : midinote,textfeld
.| Aufruf in : midi-1,channelup-1,channeldown-1,notedown-1,noteup-1
.|     oktdown-1,oktup-1,
@midinote
@textfeld(notetxt&,db$,1)
midiwort=(ch-1)*256+note
RETURN
'
> PROCEDURE midinote
.| Glob. Var.: o#,note#,n#,db$
.| Aufruf in : arrnrset-1,makenote-1,
o=INT(note/12)
n=note-o*12
IF n=0 THEN
IF o<3 THEN
db$="C "
ELSE
db$="c "
ENDIF
ENDIF
IF n=1 THEN
IF o<3 THEN
db$="C#"
ELSE
db$="c#"
ENDIF
ENDIF
IF n=2 THEN
IF o<3 THEN
db$="D "
ELSE
db$="d "
ENDIF
ENDIF
IF n=3 THEN
IF o<3 THEN
db$="D#"
ELSE
db$="d#"
ENDIF
ENDIF
IF n=4 THEN
IF o<3 THEN
db$="E "
ELSE
db$="e "
ENDIF
ENDIF
IF n=5 THEN
IF o<3 THEN
db$="F "
ELSE
db$="f "
ENDIF
ENDIF
IF n=6 THEN
IF o<3 THEN
db$="F#"
ELSE
db$="f#"
ENDIF
ENDIF
IF n=7 THEN
IF o<3 THEN
db$="G "
ELSE
db$="g "
ENDIF
ENDIF
IF n=8 THEN
IF o<3 THEN
db$="G#"
ELSE
db$="g#"
ENDIF
ENDIF
IF n=9 THEN
IF o<3 THEN
db$="A "
ELSE
db$="a "
ENDIF
ENDIF
IF n=10 THEN
IF o<3 THEN
db$="A#"
ELSE
db$="a#"
ENDIF
ENDIF
IF n=11 THEN
IF o<3 THEN
db$="B "
ELSE
db$="b "
ENDIF
ENDIF
IF o=0 THEN
db$=db$+"3"
ENDIF
IF o=1 THEN
db$=db$+"2"
ENDIF
IF o=2 THEN
db$=db$+"1"
ENDIF
IF o=3 THEN
db$=db$+"0"
ENDIF
IF o=4 THEN
db$=db$+"1"
ENDIF
IF o=5 THEN
db$=db$+"2"
ENDIF
IF o=6 THEN
db$=db$+"3"
ENDIF
IF o=7 THEN
db$=db$+"4"
ENDIF
IF o=8 THEN
db$=db$+"5"
ENDIF
IF o=9 THEN
db$=db$+"6"
ENDIF
IF o=10 THEN
db$=db$+"7"
ENDIF
db$=db$+CHR$(0)
RETURN
'
> PROCEDURE notedown
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf hn : midi-1,
IF note>0 THEN
note=note-1
ENDIF
@makenote
RETURN
'
> PROCEDURE noteup
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf in : midi-1,
IF note<127 THEN
note=note+1
ENDIF
@makenote
RETURN
'
> PROCEDURE oktdown
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf in : midi-1,
IF (note-12)>=0 THEN
note=note-12
ENDIF
@makenote
RETURN
'
> PROCEDURE oktup
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf in : midi-1,
IF (note+12)<=127 THEN
note=note+12
ENDIF
@makenote
RETURN
'
> PROCEDURE machmidi
.| Glob. Var.: mamidi#
.| Aufruf in : do_smpedit-1,
IF mamidi=0 THEN
mamidi=1
ELSE
mamidi=0
ENDIF
RETURN
'
> PROCEDURE loopbut(i,j)
IF i=0 THEN
@setbutton(forw&,j)
ENDIF
IF i=1 THEN
@setbutton(backw&,j)
ENDIF
IF i=2 THEN
@setbutton(cross&,j)
ENDIF
RETURN
'
> PROCEDURE loopwahl
.| Glob. Var.: winh#,loop&,rsc_window&,vornr#,nr#,menuda#,sret#,forw&,backw&
.|     cross&,loopart&,g#,smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,markhlp,setbutton,setbutton2
.|     rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,loop&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=loop&
@rsc_draw(nr,7)
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
@loopbut(0,0)
@loopbut(1,0)
@loopbut(2,0)
@loopbut(sret,1)
ELSE
@setbutton(loopart&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=loop&
IF vornr=smpedit& THEN
@setbutton2(loopart&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_loop
.| Glob. Var.: obj#,helploop&,forw&,backw&,cross&,loopexit&,winh#,loop&,nr#
.|     smpedit&,loopart&
.| Ruft auf  : helptxt,loopfor,loopret,loopcross,setbutton,restaura2b
.| Aufruf in : windows-1,
IF obj=helploop& THEN
@helptxt("LOOPS")
ENDIF
IF obj=forw& THEN
@loopfor
ENDIF
IF obj=backw& THEN
@loopret
ENDIF
IF obj=cross& THEN
@loopcross
ENDIF
IF obj=loopexit& OR obj=9999 THEN
winh=BCLR(winh,loop&)
@setbutton(loopexit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(loopart&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE marknrinp
LOCAL mn$,a,vsmsok
vsmsok=FALSE
vornr=nr
nr=marknumb&
@rsc_draw(nr,0)
@markhlp
mn$=STR$(sms)+CHR$(0)
@textfeld(mnumtxt&,mn$,1)
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1 AND obj<>mnumtxt&
edit_obj&=0
~@xrsrc_gaddr(1,obj,zu%)
IF obj=mnumhelp& THEN
@helptxt("MIDI")
ENDIF
IF obj<>0 AND obj<>mnumhelp& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=mnumok& OR obj=mnumexit&
@setbutton(obj,0)
IF obj=mnumok& THEN
@editread(mnumtxt&)
a=VAL(a$)
IF a>0 AND a<=loopz THEN
vsms=a
vsmsok=TRUE
ENDIF
ENDIF
@restaura2
IF vsmsok=TRUE THEN
@edslidemove(vsms)
ENDIF
obj=0
IF nr=smpedit& THEN
@setbutton(edmnr&,0)
ENDIF
RETURN
'
> PROCEDURE dspwahl
.| Glob. Var.: winh#,dspedit&,rsc_window&,vorvornr#,vornr#,nr#,menuda#
.|     swdsp&,g#
.| Ruft auf  : rsc_draw,markhlp,rsc_menu_ienable,setbutton
.| Aufruf in : drop2-1,do_main-1,do_smpedit-1,
IF BTST(winh,dspedit&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=dspedit&
@rsc_draw(nr,7)
@markhlp
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
winh=BSET(winh,nr)
ELSE
@setbutton(swdsp&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=dspedit&
IF vornr=smpedit& THEN
@setbutton2(swdsp&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_dsp
.| Glob. Var.: obj#,dspload&,dspsave&,dsphall&,dspecho&,dspret&,dspeq&
.|     helpdsp&,dspexit&,winh#,dspedit&,vornr#,vorvornr#,nr#,smpedit&,swdsp&
.| Ruft auf  : setbutton,helptxt,restaura2
.| Aufruf in : windows-1,
IF obj=dspload& THEN
@dsp_lodload
@setbutton(dspload&,0)
ENDIF
IF obj=dspsave& THEN
PAUSE 2
@setbutton(dspsave&,0)
ENDIF
IF obj=dsphall& THEN
@dsphall
@setbutton(dsphall&,0)
ENDIF
IF obj=dspecho& THEN
IF bigram=FALSE THEN
@dspecho
ELSE
@dsplecho
ENDIF
@setbutton(dspecho&,0)
ENDIF
IF obj=dsppass& THEN
@dspbypass              ! war passthru
@setbutton(dsppass&,0)
ENDIF
IF obj=dspflang& THEN
@dspflanger
@setbutton(dspflang&,0)
ENDIF
IF obj=dspband& THEN
PAUSE 2
@setbutton(dspband&,0)
ENDIF
IF obj=dsphigh& THEN
PAUSE 2
@setbutton(dsphigh&,0)
ENDIF
IF obj=dsplow& THEN
@dsplow
@setbutton(dsplow&,0)
ENDIF
IF obj=dspeq& THEN
PAUSE 2
@setbutton(dspeq&,0)
ENDIF
IF obj=dsppink& THEN
@dsp_pink
@setbutton(dsppink&,0)
ENDIF
IF obj=dspchor& THEN
PAUSE 2
@dspchorus
@setbutton(dspchor&,0)
ENDIF
IF obj=helpdsp& THEN
@helptxt("DSP")
ENDIF
IF obj=dspexit& OR obj=9999 THEN
winh=BCLR(winh,dspedit&)
@setbutton(dspexit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(swdsp&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE dspecho
@dsp_boot
~XBIOS(xbs,500)
RETURN
'
> PROCEDURE dsplecho
@dsp_boot
~XBIOS(xbs,501)
RETURN
'
> PROCEDURE dsphall
@dsp_boot
~XBIOS(xbs,502)
RETURN
'
> PROCEDURE dsplow
@dsp_boot
~XBIOS(xbs,503)
RETURN
'
> PROCEDURE dspflanger
@dsp_boot
~XBIOS(xbs,504)
RETURN
'
> PROCEDURE dspchorus
@dsp_boot
~XBIOS(xbs,505)
RETURN
'
> PROCEDURE dsp_pink
@dsp_boot
~XBIOS(xbs,506)
RETURN
'
> PROCEDURE dspbypass
@dsp_boot
~XBIOS(xbs,507)
RETURN
'
> PROCEDURE dsprec2     ! stereo-hosttransfer mit 8K-Buffer (fÅr dspuse)
@dsp_boot
~XBIOS(xbs,508)
RETURN
'
> PROCEDURE dsprec4     ! stereo-hosttransfer mit 1K-Buffer (fÅr 4channel record)
@dsp_boot
~XBIOS(xbs,509)
RETURN
'
> PROCEDURE dspplay2    ! stereo-hosttransfer (fÅr 4channel play und dspuse)
@dsp_boot
~XBIOS(xbs,510)
RETURN
'
> PROCEDURE dspplay4    ! hosttransfer 4 channels and mix to stereo
@dsp_boot
~XBIOS(xbs,511)
RETURN
'
> PROCEDURE dspplay8    ! hosttransfer 8 channels and mix to stereo
@dsp_boot
~XBIOS(xbs,512)
RETURN
'
> PROCEDURE dspmix8     ! ssi-transfer and mix all 8 channels to 7/8
@dsp_boot
~XBIOS(xbs,513)
RETURN
'
> PROCEDURE dspeffmix8  ! ssi-transfer,hall on 1/2 and mix all 8 channels to 7/8
@dsp_boot
~XBIOS(xbs,514)
RETURN
'
> PROCEDURE dsp_boot               ! fuer DSP56001 und DSP56002 ohne PLL (40Mhz)
LOCAL a,xx,i
'
' Bootstrap-Programm
' this is the patched SLOADER  named "SLOADER3.ASM"
'
IF demo=FALSE THEN
IF bigram=FALSE THEN
~XBIOS(xbs,70,0)
ELSE
~XBIOS(xbs,70,1)
ENDIF
~XBIOS(xbs,72,15)
ENDIF
'
timeout=FALSE
break=FALSE
'
'  @fifodel
@dspreset
~XBIOS(xbs,74)            ! DSP-Clear
RETURN
'
> PROCEDURE dsp_lodload
LOCAL ability,f,buffer
'
' Host-LOD-File-Loader to Host by Bootstrap-Loading from DSP56001
' Load a LOD-File in the DSP and Start it at P:0
'
'
@fileselect("D:\SAMPLER\SAMPLE.16\DSP\*.LOD","","LOAD LOD-FILE to DSP:")
IF fil$<>"" THEN
IF EXIST(fil$)=TRUE THEN
@dsp_boot
~XBIOS(105)  ! unlock
~XBIOS(104)  ! lock
'
' Transfer LOD-File to HI-Interface
'
ability=XBIOS(113)  ! ability
f=VARPTR(fil$)
buffer=MALLOC(65535)
FOR i=0 TO 100
~XBIOS(108,L:f,ability,L:buffer)  ! dsp_loadprog
PAUSE 100
NEXT i
ENDIF
ENDIF
RETURN
'
> PROCEDURE loopauto
.| Aufruf in : do_smpedit-1,
'  @setbutton(loopauto&,0)
RETURN
'
> PROCEDURE loopfor
.| Glob. Var.: sret#
.| Aufruf in : do_loop-1,
sret=0
RETURN
'
> PROCEDURE loopret
.| Glob. Var.: sret#
.| Aufruf in : do_loop-1,
sret=1
RETURN
'
> PROCEDURE loopcross
.| Glob. Var.: sret#
.| Aufruf in : do_loop-1,
sret=2
RETURN
'
> PROCEDURE normadj
.| Glob. Var.: grenz#,db#,aufloes#
.| Ruft auf  : makenorm
.| Aufruf in : normalize-1,
grenz=(db+aufloes)/20
grenz=10^grenz
grenz=grenz/2
IF dig24=FALSE THEN
IF grenz>&H7FFF THEN
grenz=&H7FFF
ENDIF
ELSE
IF grenz>&H7FFFFF THEN
grenz=&H7FFFFF
ENDIF
ENDIF
grenz=INT(grenz)
@makenorm
RETURN
'
> PROCEDURE normauto
.| Glob. Var.: db#,grenz#
.| Ruft auf  : makenorm
.| Aufruf in : normalize-1,
db=0
IF dig24=FALSE THEN
grenz=&H7FFF
ELSE
grenz=&H7FFFFF
ENDIF
@makenorm
RETURN
'
> PROCEDURE makenorm
.| Glob. Var.: virtual#,sblock#,meml#,b#,memh#,mcs#,mce#,c2#,c1#,sms#,sme#
.|     ce#,xm#,grenz#,back%,makecurve#,virtln#,bytes#,mlen#,virtwfile#
.|     virtpath$,virtp$,virtfile$,seekz#,path$,smpnam$,vmem#,noblkdel#
.| Ruft auf  : maschinit13,blocklook,maschruf13,hardproof3,memtovirt2,nomem
.| Aufruf in : normadj-1,normauto-1,
LOCAL okay,a,vln
IF virtual=FALSE THEN
IF sblock=0 THEN
a=meml
b=memh
ELSE
@blocklook
a=mcs
b=mce
ENDIF
IF sblock=0 OR (sblock=1 AND c2>c1 AND mce<>0 AND sms<>0 AND ce<>0 AND xm>0) THEN
@maschruf13(a,b,grenz,back%)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
makecurve=1
ENDIF
ELSE
a=meml
b=memh
vln=virtln
bytes=INT(mlen/mbit)*mbit
okay=FALSE
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
seekz=0
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
@maschruf13(meml,meml+bytes,grenz,back%)
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
makecurve=1
ELSE
@nomem
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
RETURN
'
> PROCEDURE normtest
.| Glob. Var.: virtual#,sblock#,meml#,memh#,mcs#,mce#,back%,db#,aufloes#
.|     vln#,virtln#,bhold#,bytes#,virtpath$,mlen#,db$,normdb&
.| Ruft auf  : maschinit12,maschruf12,blocklook,textfeld
.| Aufruf in : normalize-1,
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf12(meml,memh)
ELSE
@blocklook
@maschruf12(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF back%>0 THEN
mdb=2*back%
mdb=20*LOG10(mdb)
mdb=mdb-aufloes
mdb=INT(mdb*100)/100
ELSE
back%=0
mdb=-aufloes
ENDIF
ELSE
vln=virtln
bhold=0
bytes=0
OPEN "I",#1,virtpath$
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschruf12(meml,meml+bytes)
ENDIF
vln=vln-bytes
IF back%>bhold THEN
bhold=back%
ENDIF
UNTIL vln<4
CLOSE #1
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF bhold>0 THEN
mdb=2*bhold
mdb=20*LOG10(mdb)
mdb=mdb-aufloes
mdb=INT(mdb*100)/100
ELSE
bhold=0
mdb=-aufloes
ENDIF
back%=bhold
ENDIF
db$=STR$(mdb)+CHR$(0)
@textfeld(maxdb&,db$,1)
RETURN
'
> PROCEDURE norml
.| Glob. Var.: norma#,auflh#,aufloes#,dbx#,db#,obj#,norml1&,nz#,norml2&
.|     norml3&,db$,normdb&
.| Ruft auf  : textfeld
.| Aufruf in : normalize-1,
IF norma=0 THEN
auflh=INT(0-(aufloes*100))
dbx=INT(db*100)
IF obj=norml1& THEN
nz=2
ENDIF
IF obj=norml2& THEN
nz=20
ENDIF
IF obj=norml3& THEN
nz=400
ENDIF
dbx=dbx-nz
IF dbx>=auflh THEN
db=INT(dbx)/100
ENDIF
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
ENDIF
RETURN
'
> PROCEDURE normr
.| Glob. Var.: norma#,dbx#,db#,obj#,normr1&,nz#,normr2&,normr3&,t#,db$
.|     normdb&
.| Ruft auf  : textfeld
.| Aufruf in : normalize-1,
IF norma=0 THEN
dbx=INT(db*100)
IF obj=normr1& THEN
nz=2
ENDIF
IF obj=normr2& THEN
nz=20
ENDIF
IF obj=normr3& THEN
nz=400
ENDIF
t=1
dbx=dbx+nz
IF t>dbx THEN
db=INT(dbx)/100
ENDIF
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
ENDIF
RETURN
'
> PROCEDURE resl
.| Glob. Var.: obj#,resl1&,nz#,resl2&,resl3&,t#,resoth#,db$,resother&
.| Ruft auf  : textfeld
.| Aufruf in : resample-1,arrsmpr-1,
IF obj=resl1& THEN
nz=0.1
ENDIF
IF obj=resl2& THEN
nz=1
ENDIF
IF obj=resl3& THEN
nz=5
ENDIF
t=5
IF (resoth-nz)>=t THEN
resoth=resoth-nz
ENDIF
resoth=INT(resoth*10)/10
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
RETURN
'
> PROCEDURE resr
.| Glob. Var.: obj#,resr1&,nz#,resr2&,resr3&,t#,resoth#,db$,resother&
.| Ruft auf  : textfeld
.| Aufruf in : resample-1,arrsmpr-1,
IF obj=resr1& THEN
nz=0.1
ENDIF
IF obj=resr2& THEN
nz=1
ENDIF
IF obj=resr3& THEN
nz=5
ENDIF
t=96
IF (resoth+nz)<=t THEN
resoth=resoth+nz
ENDIF
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
RETURN
'
> PROCEDURE resoth32
.| Glob. Var.: resoth#,db$,resother&,res32&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : resample-1,arrsmpr-1,
resoth=32
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
@setbutton(res32&,0)
RETURN
'
> PROCEDURE resoth44
.| Glob. Var.: resoth#,db$,resother&,res44&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : resample-1,arrsmpr-1,
resoth=44.1
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
@setbutton(res44&,0)
RETURN
'
> PROCEDURE resoth48
.| Glob. Var.: resoth#,db$,resother&,res48&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : resample-1,arrsmpr-1,
resoth=48
db$=STR$(resoth)+CHR$(0)
@textfeld(resother&,db$,1)
@setbutton(res48&,0)
RETURN
'
> PROCEDURE resmptovirt(va,vb)
bedarfw=(vb-va)*bedarf
bedarfw=(INT(bedarfw/mbit)*mbit)+mbit+head
IF DFREE(a)>=bedarfw THEN
a=RINSTR(path$,"\")
IF a>0 THEN
workf$=LEFT$(path$,a)+workfile$
ELSE
workf$=lfw$+workfile$
ENDIF
@busy_mouse
OPEN "O",#1,workf$
'
'
BPUT #1,va,vb-va
'        PRINT "1:";workf$,bytes+dazu,vb-va
CLOSE #1
virtual=TRUE
'
path$=workf$
smpnam$=workfile$
'    mbs=0
IF nr=smpedit& THEN
@setbutton(hard&,1)
ENDIF
makevirt=TRUE
virtln=vb-va
virtpath$=workf$
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE makeresmp
.| Glob. Var.: e#,resorig#,f#,resoth#,bedarf#,virtual#,sblock#,a#,meml#,b#
.|     memh#,c#,d#,back%,adjresmp#,hz#,hzm#,retime#,makecurve#,drittel#
.|     ldlen#,mcs#,mce#,virtln#,bytes#,mlen#,virtpath$,virtp$,virtfile$
.|     seekz#,seekz2#,virtwfile#,path$,smpnam$,vmem#
.| Ruft auf  : maschinit16,maschruf16,maschinit9,maschruf9,maschinit10
.|     maschruf10,blocklook,hardproof3,memtovirt2,nomem
.| Aufruf in : resample-1,
LOCAL okay,vln
e=INT(resorig*10)
f=INT(resoth*10)
bedarf=f/e
IF virtual=FALSE THEN
IF sblock=0 THEN
IF bedarf<=1 THEN
a=meml
b=memh
c=meml
d=memh
@maschruf16(a,b,c,d,e,f)
IF back%<memh AND back%>meml THEN
@maschruf9(back%,memh-mbit)
ENDIF
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
ELSE
'        go to virtual
'
@resmptovirt(meml,memh)
'
ENDIF
ELSE
@blocklook
a=mcs
b=mce
drittel=(memh-meml)/(mce-mcs)
'
'     IF loops%(sms,2)<>-1 THEN
'      le=(c2-c1)*bedarf+c1
'      le=INT(le/mbit)*mbit
'      loops%(sms,2)=le
'     ENDIF
'
IF bedarf<=1 THEN
c=mcs
d=mce
@maschruf16(a,b,c,d,e,f)
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
IF back%<mce AND back%>mcs THEN
@maschruf9(back%,mce)
ENDIF
ELSE
IF mce+mbit<memh AND drittel>=bedarf THEN
c=mce
d=memh-mbit
@maschruf16(a,b,c,d,e,f)
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
@maschruf10(c,d,mcs,memh-mbit)
b=INT((d-c)/mbit)*mbit
@maschruf9(mcs+b,d)
ELSE
'
@resmptovirt(mcs,mce)
'
'          @alerts(46)
ENDIF
ENDIF
ENDIF
ENDIF
IF virtual=TRUE THEN
vln=virtln
bytes=INT(mlen/mbit)*mbit
okay=FALSE
drittel=(memh-meml)/(e+f)*e
drittel=INT(drittel/mbit)*mbit
IF drittel>=mbit*4 THEN
drittel=drittel-mbit*2
ENDIF
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
a=ASC(LEFT$(virtpath$,1))-64
IF DFREE(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
IF okay=TRUE THEN
seekz=0
seekz2=0
IF head>0 THEN
BGET #1,meml,head
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
@headmake3
ENDIF
BPUT #2,meml,head
vln=vln-head
ENDIF
REPEAT
IF vln+head>=bytes THEN
IF bedarf<=1 THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=drittel
ENDIF
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
a=meml
b=meml+bytes
IF bedarf<=1 THEN
c=meml
ELSE
c=meml+bytes
ENDIF
d=memh
@maschruf16(a,b,c,d,e,f)
back%=INT(back%/mbit)*mbit
BPUT #2,c,back%-c
ENDIF
vln=vln-bytes
seekz=seekz+bytes
seekz2=seekz2+(back%-c)
UNTIL vln<4
CLOSE #1
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
fil$=path$
@hardproof3
vmem=INT(virtln/mbit)*mbit
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
ELSE
hz=resorig*1000
retime=0
makecurve=0
ENDIF
ELSE
@nomem
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE nomem
.| Glob. Var.: g#,nomem#
.| Aufruf in : fade_it-1,fadesave-1,smpkhlp-1,smpmhlp-9,smpihlp-2,smpcut-1
.|     virtmove-1,virtcopy-1,virtins-1,putpix-1,edhandler2-1,sdsave-2
.|     smpsave-4,infsave-1,rettmem-2,arrsave-1,make-1,setsave-1,conspace-1
.|     coninsert-3,mono-1,negate-1,lrchange-1,makenorm-1,makeresmp-1,
@alerts(47)
nomem=TRUE
RETURN
'
> PROCEDURE nomem2
@alerts(3)
RETURN
'
> PROCEDURE makevoldb(vdb)
.| Glob. Var.: vol#,a$
.| Aufruf in : peak-1,do_peak-1,
LOCAL v
IF vdb<128+64 THEN
v=32-(vdb/3*2)
ELSE
v=32/127*(255-vdb)
ENDIF
v=(vdb-(128+64))/2
a$=STR$(v)
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
a=v
RETURN
'
> PROCEDURE peakvar
distx=10
disty=30+wymax
wy=1
wx=31
distx2=distx+72
wymax=peaksize
px=volinbal
RETURN
'
> PROCEDURE volinit
@windowtest
IF vio=TRUE THEN
@setbutton(volinout&,1)
~@xrsrc_gaddr(0,nr,zu%)
pymax=DPEEK(zu%+24*volbox&+22)                    ! Hîhe der Volumebox in Pixeln
pymax=pymax-31+6
IF vol2<192 THEN
vp=LOG10(192-vol2)
vp=pymax-ROUND((192-vp/LOG10(192)*192)/3*2/256*pymax)
ELSE
vp=vol2-192
IF vp=0 THEN
vp=pymax/2
ELSE
vp=ROUND(pymax/2-(LOG10(vp)/LOG10(63.5)/2*pymax))
ENDIF
ENDIF
DPOKE (zu%+24*volume&+18),vp+4                      ! Volume-Slider positionieren
IF shading=FALSE THEN
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~OBJC_DRAW(zu%,volbox&,9,0,0,xwidth,ywidth)       ! neu zeichnen
~WIND_UPDATE(0)                                   ! BEG_UPDATE
ENDIF
px=volinbal2
DPOKE (zu%+24*balance&+16),px+pxmax+5              ! Horizontalposition des Balance-Sliders verÑndern
IF shading=FALSE THEN
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
IF mute2=FALSE THEN
@balwrite2(vol2,px,pxmax)                             ! Ausgang auf 0 db stellen
ENDIF
@makevoldb(vol2)
@textfeld(peakdb&,a$,1)
@makevoldb(lbal)
b=a
@makevoldb(rbal)
a$=STR$(ABS(b-a))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
ELSE
@setbutton(volinout&,0)
~@xrsrc_gaddr(0,nr,zu%)
pymax=DPEEK(zu%+24*volbox&+22)                    ! Hîhe der Volumebox in Pixeln
pymax=pymax-31+6
IF vol<192 THEN
vp=LOG10(192-vol)
vp=pymax-ROUND((192-vp/LOG10(192)*192)/3*2/256*pymax)
ELSE
vp=vol-192
IF vp=0 THEN
vp=pymax/2
ELSE
vp=ROUND(pymax/2-(LOG10(vp)/LOG10(63.5)/2*pymax))
ENDIF
ENDIF
DPOKE (zu%+24*volume&+18),vp+4                      ! Volume-Slider positionieren
IF shading=FALSE THEN
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~OBJC_DRAW(zu%,volbox&,9,0,0,xwidth,ywidth)       ! neu zeichnen
~WIND_UPDATE(0)                                   ! BEG_UPDATE
ENDIF
px=volinbal
DPOKE (zu%+24*balance&+16),px+pxmax+5              ! Horizontalposition des Balance-Sliders verÑndern
IF shading=FALSE THEN
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
IF mute1=FALSE THEN
@balwrite(vol,px,pxmax)
ENDIF
@makevoldb(vol)
@textfeld(peakdb&,a$,1)
@makevoldb(lbal)
b=a
@makevoldb(rbal)
a$=STR$(ABS(b-a))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
ENDIF
RETURN
'
> PROCEDURE volinout
IF vio=FALSE THEN
vio=TRUE
ELSE
vio=FALSE
ENDIF
@mutecontrol
@volinit
RETURN
'
> PROCEDURE peak
.| Glob. Var.: winh#,peak&,rsc_window&,vornr#,nr#,distx#,distx2#,disty#,wx#
.|     wy#,wymax#,peakint#,vpl#,pl#,vpr#,pr#,zu%,vol#,peakdb&,a$,pymax#
.|     volbox&,vp#,volume&,xwidth#,ywidth#,mute#,peaksw2&,g#,smpedit&
.|     edit_obj&,idx&
.| Ruft auf  : rsc_draw,markhlp,peakread,xrsrc_gaddr,fifodel,volwrite
.|     makevoldb,textfeld,setbutton,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
slowpeak2=TIMER
IF BTST(winh,peak&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=peak&
'
wpl=0   ! peakhold left
wpr=0   ! peakhold right
'
@buttbh(plmax&,v,peaksize)
DEC peaksize
pkblk=(peaksize+3)/9                  ! Einteilungs-Blockgroesse
pkrot=pkblk-2                      ! roter Bereich in Pixeln
pksix=pkrot+4*pkblk                ! -6db-Bereich
'
IF adat=TRUE OR rch8=TRUE THEN
@hidetree2(peakch1&,FALSE)
@hidetree2(peakch2&,FALSE)
@hidetree2(peakch3&,FALSE)
@hidetree2(peakch4&,FALSE)
ELSE
@hidetree2(peakch1&,TRUE)
@hidetree2(peakch2&,TRUE)
@hidetree2(peakch3&,TRUE)
@hidetree2(peakch4&,TRUE)
ENDIF
@rsc_draw(nr,7)
IF adat=TRUE OR rch8=TRUE THEN
IF rchmo=0 THEN
@setbutton(peakch1&,1)
ENDIF
IF rchmo=1 THEN
@setbutton(peakch2&,1)
ENDIF
IF rchmo=2 THEN
@setbutton(peakch3&,1)
ENDIF
IF rchmo=3 THEN
@setbutton(peakch4&,1)
ENDIF
ENDIF
xbmagic=XBIOS(xbs,1)
winh=BSET(winh,nr)
@markhlp
@bigtext2
GRAPHMODE 1
DEFLINE 1
prt=-1
plt=-1
prw=FALSE
plw=FALSE
'      @setbutton(peakl&,0)
'     @setbutton(peakr&,0)
@peakvar
'
psec=3       ! AbschwÑchwert-Verzîgerung in 100tel Sekunden
'
peakint=FALSE
@peakread
vpl=pl
vpr=pr
~@xrsrc_gaddr(0,nr,zu%)
'      @fifodel
pxmax=DPEEK(zu%+24*balbox&+20)                    ! Breite der Balancebox in Pixeln
pxmax=INT((pxmax-25)/2)
balinmax=pxmax
mute1=FALSE
mute2=FALSE
IF nr=peak& THEN
@textfeld(recerror&,"0"+CHR$(0),1)
@textfeld(recpeaks&,"0"+CHR$(0),1)
@textfeld(peakname&,CHR$(0),1)
ENDIF
@volinit
ELSE
@setbutton(peaksw2&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=peak&
IF vornr=smpedit& THEN
@setbutton2(peaksw2&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
@wischwasch
@volinit
@bigtext2
ENDIF
IF nr=peak& THEN
IF hrd=1 THEN
@setbutton(hardpeak&,1)
ELSE
@setbutton(hardpeak&,0)
ENDIF
@mutecontrol
ENDIF
RETURN
'
> PROCEDURE mutecontrol
IF vio=FALSE THEN
IF mute1=FALSE THEN
@setbutton(peakmute&,0)
ELSE
@setbutton(peakmute&,1)
ENDIF
ELSE
IF mute2=FALSE THEN
@setbutton(peakmute&,0)
ELSE
@setbutton(peakmute&,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE deselchmo
IF rchmo=0 THEN
@setbutton(peakch1&,0)
ENDIF
IF rchmo=1 THEN
@setbutton(peakch2&,0)
ENDIF
IF rchmo=2 THEN
@setbutton(peakch3&,0)
ENDIF
IF rchmo=3 THEN
@setbutton(peakch4&,0)
ENDIF
RETURN
'
> PROCEDURE do_peak
.| Glob. Var.: peakint#,peak&,zu%,obj#,smpautop&,smpstrtp&,monitorp&
.|     peakmute&,mute#,vol#,volume&,zu2%,opy#,noppause#,x#,y#,k#,py#,yd#
.|     pymax#,peakdb&,a$,volbox&,xwidth#,ywidth#,peakexit&,winh#,nr#
.|     smpedit&,peaksw2&
.| Ruft auf  : xrsrc_gaddr,markhlp,smpauto,smpstart,monitor,volwrite
.|     setbutton,mousey,peakwert,mouse,makevoldb,textfeld,peakread,mousek
.|     restaura2b
.| Aufruf in : windows-1,
peakint=FALSE
~@xrsrc_gaddr(0,peak&,zu%)
GRAPHMODE 1
DEFLINE 1
peakrd=FALSE
IF obj=smpautop& THEN
@setbutton(obj,1)
'    nr=smpedit&
'    @rsc_redraw_obj(nr,0)
@markhlp
peakrd=TRUE
@smpauto
peakrd=FALSE
peakint=FALSE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF obj=peakhelp& THEN
@readbutton(obj)
@setbutton(obj,(buttflag AND &HFFFE)+1)
@helptxt("PEAKMETER")
ENDIF
IF obj=smpstrtp& THEN
@setbutton(obj,1)
'    nr=smpedit&
'    @rsc_redraw_obj(nr,0)
@markhlp
peakrd=TRUE
@smpstart
peakrd=FALSE
peakint=FALSE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF obj=playpeak& OR obj=peakwait& THEN
IF hrd=1 THEN
@setbutton(obj,1)
IF obj=peakwait& THEN
pwait=TRUE
ENDIF
@smpplay
@setbutton(obj,0)
peakint=FALSE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
IF obj=peakch1& THEN
@deselchmo
@setbutton(peakch1&,1)
rchmo=0
ENDIF
IF obj=peakch2& THEN
@deselchmo
@setbutton(peakch2&,1)
rchmo=1
ENDIF
IF obj=peakch3& THEN
@deselchmo
@setbutton(peakch3&,1)
rchmo=2
ENDIF
IF obj=peakch4& THEN
@deselchmo
@setbutton(peakch4&,1)
rchmo=3
ENDIF
IF obj=hardpeak& THEN
IF virtual=FALSE THEN
@harddisk
ELSE
@setbutton(hardpeak&,1)
ENDIF
ENDIF
@peakwork
IF obj=9999 OR obj=peakexit& THEN
IF XBIOS(xbs,1)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
peakint=FALSE
ENDIF
@setbutton(peakexit&,0)
winh=BCLR(winh,peak&)
@restaura2b
IF nr=smpedit& THEN
@setbutton(peaksw2&,0)
IF hrd=1 THEN
@setbutton(hard&,1)
ELSE
@setbutton(hard&,0)
ENDIF
ENDIF
ENDIF
obj=0
peakmrk=nr
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE peakwork
LOCAL mf
mf=4
IF obj=volinout& AND viomake=FALSE AND volmake=FALSE AND balmake=FALSE THEN
viomake=TRUE
@volinout
IF peakrd=FALSE THEN
viomake=FALSE
REPEAT
UNTIL @mousek=0
ENDIF
obj=0
ENDIF
IF obj=peakmute& AND mutemake=FALSE AND volmake=FALSE AND balmake=FALSE THEN
mutemake=TRUE
IF vio=FALSE THEN
IF mute1=FALSE THEN
mute1=TRUE
ELSE
mute1=FALSE
ENDIF
ELSE
IF mute2=FALSE THEN
mute2=TRUE
ELSE
mute2=FALSE
ENDIF
ENDIF
IF vio=FALSE THEN
IF mute1=TRUE THEN
@setbutton(peakmute&,1)
@volwrite(0,0)
ELSE
@setbutton(peakmute&,0)
@balwrite(vol,volinbal,pxmax)
ENDIF
ELSE
IF mute2=TRUE THEN
@setbutton(peakmute&,1)
@volwrite2(0,0)
ELSE
@setbutton(peakmute&,0)
@balwrite2(vol2,volinbal2,pxmax)
ENDIF
ENDIF
IF peakrd=FALSE THEN
mutemake=FALSE
REPEAT
UNTIL @mousek=0
ENDIF
obj=0
ENDIF
IF obj=balzero& AND zeromake=FALSE AND volmake=FALSE AND balmake=FALSE THEN
zeromake=TRUE
@setbutton(balzero&,1)
px=0
IF vio=FALSE THEN
volinbal=0
ELSE
volinbal2=0
ENDIF
DPOKE (zu%+24*balance&+16),px+pxmax+5            ! Horizontalposition des Balance-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
IF vio=FALSE THEN
IF mute1=FALSE THEN
@balwrite(vol,px,pxmax)
ENDIF
ELSE
IF mute2=FALSE THEN
@balwrite2(vol2,px,pxmax)
ENDIF
ENDIF
@makevoldb(lbal)
b=a
@makevoldb(rbal)
a$=STR$(ABS(b-a))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
IF peakrd=FALSE THEN
zeromake=FALSE
REPEAT
UNTIL @mousek=0
@setbutton(balzero&,0)
ENDIF
obj=0
ENDIF
IF ((obj=balance& OR balmake=TRUE) AND volmake=FALSE) OR (balmake=TRUE AND pshift2=TRUE) THEN
~@xrsrc_gaddr(1,obj,zu2%)
REPEAT
@mouse(x,y,k)
IF k=1 AND balmake=FALSE THEN
balmake=TRUE
DEFMOUSE mf
opx=x
ENDIF
IF opx<>x THEN
opx=x
pxv=x-xd-153+8
IF ABS(pxv)<=pxmax THEN
px=pxv
IF vio=FALSE THEN
volinbal=px
IF mute1=FALSE THEN
@balwrite(vol,px,pxmax)
ENDIF
ELSE
volinbal2=px
IF mute2=FALSE THEN
@balwrite2(vol2,px,pxmax)
ENDIF
ENDIF
@makevoldb(lbal)
b=a
@makevoldb(rbal)
a$=STR$(ABS(b-a))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
DPOKE (zu%+24*balance&+16),px+pxmax+5            ! Horizontalposition des Balance-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
ENDIF
IF peakrd=FALSE THEN
@peakread
ENDIF
UNTIL peakrd=TRUE OR (peakrd=FALSE AND k=0)
IF peakrd=FALSE THEN
balmake=FALSE
DEFMOUSE 0
ENDIF
obj=0
ENDIF
IF ((obj=volume& OR volmake=TRUE) AND balmake=FALSE) OR (volmake=TRUE AND pshift2=TRUE) THEN
~@xrsrc_gaddr(1,obj,zu2%)
REPEAT
~GRAF_MKSTATE(x,y,k,pshift)
IF pshift<>0 THEN
balmake=TRUE
opx=x
pshift2=TRUE
ENDIF
IF k=1 AND volmake=FALSE THEN
volmake=TRUE
DEFMOUSE mf
opy=y
ENDIF
IF opy<>y THEN
opy=y
IF bigtxt=FALSE THEN
py=y-yd-peaksize+176
ELSE
py=y-yd-peaksize+280
ENDIF
IF py<=pymax AND py>=0 THEN
IF vio=FALSE THEN
IF py>=INT(pymax/2) THEN
vol=((pymax-py)/pymax*256)/2*3
lmax=192/LOG10(192)
vol=(192-vol)/lmax
IF vol>0.1 THEN
vol=ROUND(192-10^vol)
ELSE
vol=192
ENDIF
ELSE
vol=(pymax/2-py)/pymax*127
lmax=63.5/LOG10(63.5)
vol=(vol/lmax)
IF vol>0.1 THEN
vol=ROUND(192+10^vol)
ELSE
vol=192
ENDIF
ENDIF
IF mute1=FALSE THEN
@balwrite(vol,volinbal,pxmax)
ENDIF
@makevoldb(vol)
ELSE
IF py>=INT(pymax/2) THEN
vol2=((pymax-py)/pymax*256)/2*3
lmax=192/LOG10(192)
vol2=(192-vol2)/lmax
IF vol2>0.1 THEN
vol2=ROUND(192-10^vol2)
ELSE
vol2=192
ENDIF
ELSE
vol2=(pymax/2-py)/pymax*127
lmax=63.5/LOG10(63.5)
vol2=(vol2/lmax)
IF vol2>0.1 THEN
vol2=ROUND(192+10^vol2)
ELSE
vol2=192
ENDIF
ENDIF
IF mute2=FALSE THEN
@balwrite2(vol2,volinbal2,pxmax)                             ! Ausgang auf db einstellen
ENDIF
@makevoldb(vol2)
ENDIF
@textfeld(peakdb&,a$,1)
DPOKE (zu%+24*volume&+18),py+4                   ! Hîhenposition des Volume-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,volbox&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
ENDIF
IF peakrd=FALSE THEN
@peakread
ENDIF
UNTIL peakrd=TRUE OR (peakrd=FALSE AND k=0)
IF peakrd=FALSE THEN
volmake=FALSE
DEFMOUSE 0
ENDIF
obj=0
ENDIF
IF k=0 AND pshift2=TRUE THEN
pshift2=FALSE
ENDIF
RETURN
'
> PROCEDURE peakwert
.| Glob. Var.: demo#,scb%,sth#,sdb%,recfifolen#,seb%,adr#,sfb%,peakint#
.|     peakret#,back3%,pl#,pr#,wymax#,rwert#,pr2#,pl2#,gr1#,gr2#,n#
.| Ruft auf  : mousek,read_smp
.| Aufruf in : maschruf4b-1,do_peak-1,peakread-2,
IF demo=FALSE AND falcon=FALSE THEN
IF xbmagic=&H71273800 THEN
scb%=sth
sdb%=recfifolen/8-1
seb%=adr+&H60
sfb%=adr+&H100-1
IF peakint=FALSE THEN
peakint=TRUE
peakret=XBIOS(xbs,120)
@write_int(2)
ENDIF
REPEAT
back3%=LPEEK(peakret+8)
UNTIL back3%=1 OR @mousek<>0
pl=DPEEK(peakret)
pr=DPEEK(peakret+2)
@peakfound
~XBIOS(xbs,150)
IF pl>32766 THEN
@setbutton(peakl&,1)
plt=TIMER
plw=TRUE
ENDIF
IF pr>32766 THEN
@setbutton(peakr&,1)
prt=TIMER
prw=TRUE
ENDIF
IF (TIMER-plt)>100 AND plw=TRUE THEN
plw=FALSE
@setbutton(peakl&,0)
ENDIF
IF (TIMER-prt)>100 AND prw=TRUE THEN
prw=FALSE
@setbutton(peakr&,0)
ENDIF
@peakdbcalc(pkblk)
ELSE
REPEAT
@read_smp
pr=rwert
UNTIL (pr AND 256)=0
REPEAT
REPEAT
@read_smp
pr=rwert
UNTIL (pr AND 256)=256
@read_smp
pr2=rwert
UNTIL (pr2 AND 256)=256
REPEAT
REPEAT
@read_smp
pl=rwert
UNTIL (pl AND 256)=0
@read_smp
pl2=rwert
UNTIL (pl2 AND 256)=0
pr=(pr AND 255)*256+(pr2 AND 255)
pl=(pl AND 255)*256+(pl2 AND 255)
IF pr>32767 THEN
pr=ABS(pr-65536)
ENDIF
IF pl>32767 THEN
pl=ABS(pl-65536)
ENDIF
pr=pr/32767*wymax
pl=pl/32767*wymax
ENDIF
ELSE
INC pr
INC pl
IF pr>gr1 THEN
pr=0
gr1=INT(RND(1)*wymax)
ENDIF
IF pl>gr2 THEN
pl=0
gr2=INT(RND(1)*wymax)
ENDIF
FOR n=0 TO 300
NEXT n
ENDIF
RETURN
'
> PROCEDURE peakdbcalc(mpkblk)
pl2=pl
IF pl2<=pkg0 THEN
'        db=-96..-48
pl=0
ENDIF
IF pl2>pkg0 AND pl2<=pkg1 THEN
'        db=-48..-24
pkdba=ROUND(pkt*LOG10(pl*2))
pl=ROUND(mpkblk/(pkdb1-pkdb0)*(pkdba-pkdb0))
ENDIF
IF pl2>pkg1 AND pl2<=pkg2 THEN
'        db=-24..-12
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk+ROUND(mpkblk/(pkdb2-pkdb1)*(pkdba-pkdb1))
ENDIF
IF pl2>pkg2 AND pl2<=pkg3 THEN
'        db=-12..-8
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*2+ROUND(mpkblk/(pkdb3-pkdb2)*(pkdba-pkdb2))
ENDIF
IF pl2>pkg3 AND pl2<=pkg4 THEN
'        db=-8..-6
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*3+ROUND(mpkblk/(pkdb4-pkdb3)*(pkdba-pkdb3))
ENDIF
IF pl2>pkg4 AND pl2<=pkg5 THEN
'        db=-6..-4
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*4+ROUND(mpkblk/(pkdb5-pkdb4)*(pkdba-pkdb4))
ENDIF
IF pl2>pkg5 AND pl2<=pkg6 THEN
'        db=-4..-3
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*5+ROUND(mpkblk/(pkdb6-pkdb5)*(pkdba-pkdb5))
ENDIF
IF pl2>pkg6 AND pl2<=pkg7 THEN
'        db=-3..-2
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*6+ROUND(mpkblk/(pkdb7-pkdb6)*(pkdba-pkdb6))
ENDIF
IF pl2>pkg7 AND pl2<=pkg8 THEN
'        db=-2..-1
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*7+ROUND(mpkblk/(pkdb8-pkdb7)*(pkdba-pkdb7))
ENDIF
IF pl2>pkg8 THEN
'        db=-1..0
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*8+ROUND((mpkblk-1)/(pkdb9-pkdb8)*(pkdba-pkdb8))
ENDIF
'
pr2=pr
IF pr2<=pkg0 THEN
'        db=-96..-48
pr=0
ENDIF
IF pr2>pkg0 AND pr2<=pkg1 THEN
'        db=-48..-24
pkdba=ROUND(pkt*LOG10(pr*2))
pr=ROUND(mpkblk/(pkdb1-pkdb0)*(pkdba-pkdb0))
ENDIF
IF pr2>pkg1 AND pr2<=pkg2 THEN
'        db=-24..-12
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk+ROUND(mpkblk/(pkdb2-pkdb1)*(pkdba-pkdb1))
ENDIF
IF pr2>pkg2 AND pr2<=pkg3 THEN
'        db=-12..-8
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*2+ROUND(mpkblk/(pkdb3-pkdb2)*(pkdba-pkdb2))
ENDIF
IF pr2>pkg3 AND pr2<=pkg4 THEN
'        db=-8..-6
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*3+ROUND(mpkblk/(pkdb4-pkdb3)*(pkdba-pkdb3))
ENDIF
IF pr2>pkg4 AND pr2<=pkg5 THEN
'        db=-6..-4
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*4+ROUND(mpkblk/(pkdb5-pkdb4)*(pkdba-pkdb4))
ENDIF
IF pr2>pkg5 AND pr2<=pkg6 THEN
'        db=-4..-3
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*5+ROUND(mpkblk/(pkdb6-pkdb5)*(pkdba-pkdb5))
ENDIF
IF pr2>pkg6 AND pr2<=pkg7 THEN
'        db=-3..-2
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*6+ROUND(mpkblk/(pkdb7-pkdb6)*(pkdba-pkdb6))
ENDIF
IF pr2>pkg7 AND pr2<=pkg8 THEN
'        db=-2..-1
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*7+ROUND(mpkblk/(pkdb8-pkdb7)*(pkdba-pkdb7))
ENDIF
IF pr2>pkg8 THEN
'        db=-1..0
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*8+ROUND((mpkblk-1)/(pkdb9-pkdb8)*(pkdba-pkdb8))
ENDIF
RETURN
'
> PROCEDURE peakread
.| Glob. Var.: nr#,peak&,pl#,pr#
.| Ruft auf  : peakwert,fifodel,peakread2
.| Aufruf in : rsc_do-1,peak-1,do_peak-1,
LOCAL i,a,b,t,t2,nov,nov2
psec=3      ! AbschwÑchwert-Verzîgerung in 100tel Sekunden
GRAPHMODE 1
DEFLINE 1
IF nr=peak& THEN
IF xbmagic=&H71273800 THEN
@peakwert
ELSE
a=0
b=0
FOR i=0 TO 19
IF peakrd=FALSE THEN
'          @fifodel
ENDIF
@peakwert
IF pl>a THEN
a=pl
ENDIF
IF pr>b THEN
b=pr
ENDIF
NEXT i
pl=a
pr=b
ENDIF
ENDIF
@peakread2
RETURN
'
> PROCEDURE peakread2
.| Glob. Var.: nr#,peak&,t#,t2#,vpl#,pl#,nov#,wymax#,vpr#,pr#,nov2#,erlaub#
.|     ax&,distx#,ay&,disty#,wy#,wx#,plm#,maxcol#,noppause#,distx2#,prm#
.| Ruft auf  : markhlp
.| Aufruf in : peakread-1,peakrec-1,
LOCAL x,y,k,v
fstyle=2
ffill=5
@windowtest
@peakvar
IF mywindow=TRUE THEN
IF nr=peak& THEN
slowpeak=INT((TIMER-slowpeak2)/2)
vrl=vpl-pl
vrr=vpr-pr
IF vrl>pschwell THEN
pl=vpl
ENDIF
IF vrr>pschwell THEN
pr=vpr
ENDIF
IF slowpeak>psec THEN    ! ums langsamer zu machen !
slowpeak2=TIMER
IF vrl>0 THEN
pl=vpl*prest
ENDIF
IF vrr>0 THEN
pr=vpr*prest
ENDIF
ENDIF
erlaub=TRUE
IF erlaub=TRUE AND shading=FALSE THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
@markhlp
'
IF hardcursor=FALSE THEN
~GRAF_MKSTATE(x,y,k,v4)
IF x>=ax&+distx-16 AND x<=ax&+distx2+wx+8 AND y<=ay&+disty+8 AND y>=ay&+disty-wymax-16 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
ENDIF
ENDIF
'
IF pl>wpl THEN
wpl=pl
ELSE
INC wplz
IF wplz>100 THEN
DEFFILL 0,1,0
PBOX ax&+distx,ay&+disty-wpl,ax&+distx+wx,ay&+disty-wpl+1
wplz=0
wpl=0
ENDIF
ENDIF
IF vpl>pl THEN
DEFFILL 0,1,0
IF INT(vpl)=INT(wpl) THEN
PBOX ax&+distx,ay&+disty-pl,ax&+distx+wx,ay&+disty-vpl+1
ELSE
PBOX ax&+distx,ay&+disty-pl,ax&+distx+wx,ay&+disty-vpl
ENDIF
ENDIF
IF pl<wymax-pksix THEN
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx,ay&+disty,ax&+distx+wx,ay&+disty-pl
ENDIF
IF pl>=wymax-pksix AND pl<wymax-pkrot THEN
plm=pl-(wymax-pksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx,ay&+disty,ax&+distx+wx,ay&+disty-(pl-plm)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL bred,1,bred
ENDIF
PBOX ax&+distx,ay&+disty-(pl-plm),ax&+distx+wx,ay&+disty-pl
ENDIF
IF pl>=wymax-pkrot THEN
plm=pl-(wymax-pkrot)
plm2=pl-(wymax-pksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx,ay&+disty,ax&+distx+wx,ay&+disty-(pl-plm2)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL bred,1,bred
ENDIF
PBOX ax&+distx,ay&+disty-(pl-plm2),ax&+distx+wx,ay&+disty-(pl-plm)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL red,1,red
ENDIF
PBOX ax&+distx,ay&+disty-(pl-plm),ax&+distx+wx,ay&+disty-pl
ENDIF
IF pr>wpr THEN
wpr=pr
ELSE
INC wprz
IF wprz>100 THEN
DEFFILL 0,1,0
PBOX ax&+distx2,ay&+disty-wpr,ax&+distx2+wx,ay&+disty-wpr+1
wprz=0
wpr=0
ENDIF
ENDIF
IF vpr>pr THEN
DEFFILL 0,1,0
IF INT(vpr)=INT(wpr) THEN
PBOX ax&+distx2,ay&+disty-pr,ax&+distx2+wx,ay&+disty-vpr+1
ELSE
PBOX ax&+distx2,ay&+disty-pr,ax&+distx2+wx,ay&+disty-vpr
ENDIF
ENDIF
IF pr<wymax-pksix THEN
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx2,ay&+disty,ax&+distx2+wx,ay&+disty-pr
ENDIF
IF pr>=wymax-pksix AND pr<wymax-pkrot THEN
prm=pr-(wymax-pksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx2,ay&+disty,ax&+distx2+wx,ay&+disty-(pr-prm)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL bred,1,bred
ENDIF
PBOX ax&+distx2,ay&+disty-(pr-prm),ax&+distx2+wx,ay&+disty-pr
ENDIF
IF pr>=wymax-pkrot THEN
prm=pr-(wymax-pkrot)
prm2=pr-(wymax-pksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx2,ay&+disty,ax&+distx2+wx,ay&+disty-(pr-prm2)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL bred,1,bred
ENDIF
PBOX ax&+distx2,ay&+disty-(pr-prm2),ax&+distx2+wx,ay&+disty-(pr-prm)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL red,1,red
ENDIF
PBOX ax&+distx2,ay&+disty-(pr-prm),ax&+distx2+wx,ay&+disty-pr
ENDIF
'
IF hardcursor=FALSE THEN
IF x>=ax&+distx-16 AND x<=ax&+distx2+wx+8 AND y<=ay&+disty+8 AND y>=ay&+disty-wymax-16 THEN
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
ENDIF
'
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
vpl=pl
vpr=pr
ENDIF
ENDIF
RETURN
'
> PROCEDURE peakrec
.| Glob. Var.: nr#,peak&,pl#,peakret#,pr#,wymax#
.| Ruft auf  : peakread2
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,
LOCAL i,a,b,t,t2,nov,nov2
GRAPHMODE 1
DEFLINE 1
IF nr=peak& THEN
IF XBIOS(xbs,1)=&H71273800 THEN
~@xrsrc_gaddr(0,nr,zu%)
@mouse(x,y,k)
IF k=1 THEN
obj=OBJC_FIND(zu%,0,6,x,y)
IF obj<>0 OR volmake=TRUE OR balmake=TRUE THEN
peakrd=TRUE
@peakwork
peakrd=FALSE
ENDIF
ELSE
IF zeromake=TRUE AND k=0 THEN
@setbutton(balzero&,0)
zeromake=FALSE
ENDIF
IF mutemake=TRUE AND k=0 THEN
mutemake=FALSE
ENDIF
IF viomake=TRUE AND k=0 THEN
viomake=FALSE
ENDIF
IF volmake=TRUE THEN
volmake=FALSE
DEFMOUSE 0
ENDIF
IF balmake=TRUE THEN
balmake=FALSE
DEFMOUSE 0
ENDIF
ENDIF
ENDIF
@peakrec2
ENDIF
RETURN
'
> PROCEDURE peakfound
IF pl>32766 THEN
@setbutton(peakl&,1)
plt=TIMER
plw=TRUE
IF ad=1 THEN
INC peaks2
ENDIF
ENDIF
IF pr>32766 THEN
@setbutton(peakr&,1)
prt=TIMER
prw=TRUE
IF ad=1 THEN
INC peaks2
ENDIF
ENDIF
RETURN
'
> PROCEDURE peakrec2
psec=3      ! AbschwÑchwert-Verzîgerung in 100tel Sekunden
IF demo=FALSE THEN
pl=DPEEK(peakret)
pr=DPEEK(peakret+2)
ENDIF
@peakfound
IF (TIMER-plt)>100 AND plw=TRUE THEN
plw=FALSE
@setbutton(peakl&,0)
ENDIF
IF (TIMER-prt)>100 AND prw=TRUE THEN
prw=FALSE
@setbutton(peakr&,0)
ENDIF
@peakdbcalc(pkblk)
@peakread2
RETURN
'
> PROCEDURE peakrec3
@windowtest
IF bigfoot=FALSE THEN
distx=545
disty=352
wymax=76
distx2=distx+7
ELSE
distx=794
disty=616+8
wymax=76
distx2=distx+8
ENDIF
wy=4
blue=4
green=3+8
red=2
psec=10      ! AbschwÑchwert-Verzîgerung in 100tel Sekunden
IF demo=FALSE AND shading=FALSE THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
pl=DPEEK(peakret)
pr=DPEEK(peakret+2)
~XBIOS(xbs,150)
IF pl>32766 THEN
IF maxcol=2 THEN
DEFFILL 1,2,4
ELSE
DEFFILL red,1,red
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-wymax-3,ax&+distx+wy,ay&+disty-wymax-6
~GRAF_MOUSE(257,0)                              ! Hidem
plt=TIMER
plw=TRUE
ENDIF
IF pr>32766 THEN
IF maxcol=2 THEN
DEFFILL 1,2,4
ELSE
DEFFILL red,1,red
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-wymax-3,ax&+distx2+wy,ay&+disty-wymax-6
~GRAF_MOUSE(257,0)                              ! Hidem
prt=TIMER
prw=TRUE
ENDIF
IF (TIMER-plt)>100 AND plw=TRUE THEN
plw=FALSE
DEFFILL 0,0,0
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-wymax-3,ax&+distx+wy,ay&+disty-wymax-6
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF (TIMER-prt)>100 AND prw=TRUE THEN
prw=FALSE
DEFFILL 0,0,0
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-wymax-3,ax&+distx2+wy,ay&+disty-wymax-6
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
'  pr=pr/32767*wymax
'  pl=pl/32767*wymax
@peakdbcalc(tpkblk)
@peakread3
RETURN
'
> PROCEDURE peakread3
fstyle=1
ffill=5
@windowtest
IF mywindow=TRUE THEN
IF nr=trakker& THEN
slowpeak=INT((TIMER-slowpeak2)/2)
vrl=vpl-pl
vrr=vpr-pr
IF vrl>pschwell THEN
pl=vpl
ENDIF
IF vrr>pschwell THEN
pr=vpr
ENDIF
IF slowpeak>psec THEN    ! ums langsamer zu machen !
slowpeak2=TIMER
IF vrl>t2 THEN
pl=vpl*prest
ENDIF
IF vrr>t2 THEN
pr=vpr*prest
ENDIF
ENDIF
erlaub=TRUE
IF erlaub=TRUE AND shading=FALSE THEN
@markhlp
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
IF pl>wpl THEN
wpl=pl
ELSE
INC wplz
IF wplz>100 THEN
DEFFILL 0,1,0
PBOX ax&+distx,ay&+disty-wpl,ax&+distx+wy,ay&+disty-wpl+1
wplz=0
wpl=0
ENDIF
ENDIF
IF vpl>pl THEN
DEFFILL 0,1,0
~GRAF_MOUSE(256,0)                              ! Hidem
IF INT(vpl)=INT(wpl) THEN
PBOX ax&+distx,ay&+disty-pl,ax&+distx+wy,ay&+disty-vpl+1
ELSE
PBOX ax&+distx,ay&+disty-pl,ax&+distx+wy,ay&+disty-vpl
ENDIF
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pl<wymax-tpksix THEN
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty,ax&+distx+wy,ay&+disty-pl
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pl>=wymax-tpksix AND pl<wymax-tpkrot THEN
plm=pl-(wymax-tpksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty,ax&+distx+wy,ay&+disty-(pl-plm)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL bred,1,bred
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-(pl-plm),ax&+distx+wy,ay&+disty-pl
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pl>=wymax-tpkrot THEN
plm=pl-(wymax-tpkrot)
plm2=pl-(wymax-tpksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty,ax&+distx+wy,ay&+disty-(pl-plm2)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL bred,1,bred
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-(pl-plm2),ax&+distx+wy,ay&+disty-(pl-plm)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL red,1,red
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-(pl-plm),ax&+distx+wy,ay&+disty-pl
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pr>wpr THEN
wpr=pr
ELSE
INC wprz
IF wprz>100 THEN
DEFFILL 0,1,0
PBOX ax&+distx2,ay&+disty-wpr,ax&+distx2+wy,ay&+disty-wpr+1
wprz=0
wpr=0
ENDIF
ENDIF
IF vpr>pr THEN
DEFFILL 0,1,0
~GRAF_MOUSE(256,0)                              ! Hidem
IF INT(vpr)=INT(wpr) THEN
PBOX ax&+distx2,ay&+disty-pr,ax&+distx2+wy,ay&+disty-vpr+1
ELSE
PBOX ax&+distx2,ay&+disty-pr,ax&+distx2+wy,ay&+disty-vpr
ENDIF
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pr<wymax-tpksix THEN
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty,ax&+distx2+wy,ay&+disty-pr
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pr>=wymax-tpksix AND pr<wymax-tpkrot THEN
prm=pr-(wymax-tpksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty,ax&+distx2+wy,ay&+disty-(pr-prm)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL bred,1,bred
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-(pr-prm),ax&+distx2+wy,ay&+disty-pr
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pr>=wymax-tpkrot THEN
prm=pr-(wymax-tpkrot)
prm2=pr-(wymax-tpksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty,ax&+distx2+wy,ay&+disty-(pr-prm2)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL bred,1,bred
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-(pr-prm2),ax&+distx2+wy,ay&+disty-(pr-prm)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL red,1,red
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-(pr-prm),ax&+distx2+wy,ay&+disty-pr
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
vpl=pl
vpr=pr
ENDIF
ENDIF
RETURN
'
> PROCEDURE peaktime
LOCAL t
IF demo=FALSE THEN
rfull2=LPEEK(peakfull)
ENDIF
t=peaktime
hsec2=INT((TIMER-t)/2)
IF INT(hsec2/mbit)<>INT(hsec/mbit) THEN    ! ums langsamer zu machen !
hsec=hsec2
@htimeset
IF nr=peak& THEN
@textfeld(peakpos&,a$,1)
IF rfull2<>rfull THEN
rfull=rfull2
b$=STR$(rfull)+CHR$(0)
@textfeld(recerror&,b$,1)
ENDIF
IF peaks2<>peaks THEN
peaks=peaks2
b$=STR$(peaks)+CHR$(0)
@textfeld(recpeaks&,b$,1)
ENDIF
ENDIF
ENDIF
~FRE(0)
RETURN
'
> PROCEDURE smpscrol
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=1
RETURN
'
> PROCEDURE smpzoom
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=2
RETURN
'
> PROCEDURE smpkopie
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=5
RETURN
'
> PROCEDURE smpmove
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=6
RETURN
'
> PROCEDURE smpinsert
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=4
RETURN
'
> PROCEDURE smpmerge
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=7
RETURN
'
> PROCEDURE smpmark
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=3
RETURN
'
> PROCEDURE springart(sa)
.| Glob. Var.: v4#,ce#,cs#,virtual#,back%,virtpath$,mlen#,maxx#,vln#,meml#
.| Ruft auf  : maschinit33,maschruf33,maschinit32,maschruf32,busy_mouse
.| Aufruf in : edhandler2-1,markhandler-1,
LOCAL seek,seek2,bytes
IF markmode=4 THEN
IF v4=1 OR v4=8 THEN
sa=sa+mbit
IF sa>ce THEN
sa=ce-mbit
ENDIF
ENDIF
IF v4=2 OR v4=4 THEN
sa=sa-mbit
IF sa<cs THEN
sa=cs+mbit
ENDIF
ENDIF
IF virtual=FALSE THEN
IF v4=1 THEN           ! rechte SHIFT
@maschruf33(sa,ce,0)
ENDIF
IF v4=2 THEN           ! linke SHIFT
@maschruf33(cs,sa,1)
ENDIF
IF v4=8 THEN           ! Alternate
@maschruf32(sa,ce,0)
ENDIF
IF v4=4 THEN           ! Control
@maschruf32(cs,sa,1)
ENDIF
ELSE
back%=-1
IF EXIST(virtpath$)=TRUE AND (v4=1 OR v4=2 OR v4=4 OR v4=8) THEN
OPEN "I",#1,virtpath$
bytes=INT(mlen/mbit)*mbit
IF bytes>50000 THEN
maxx=50000
ELSE
maxx=bytes
ENDIF
IF v4=1 OR v4=8 THEN         ! vorwÑrts
seek=sa
vln=ce-sa
ELSE                         ! rÅckwÑrts
seek=sa-maxx
IF seek<cs THEN
seek=cs
ENDIF
vln=sa-cs
ENDIF
vln=INT(vln/mbit)*mbit
seek=INT(seek/mbit)*mbit
seek2=seek
IF vln>0 THEN
REPEAT
@busy_mouse
SEEK #1,seek
seek2=seek
IF vln>=maxx THEN
bytes=maxx
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF v4=1 THEN
@maschruf33(0,bytes,0)
ENDIF
IF v4=2 THEN
@maschruf33(0,bytes,1)
ENDIF
IF v4=8 THEN
@maschruf32(0,bytes,0)
ENDIF
IF v4=4 THEN
@maschruf32(0,bytes,1)
ENDIF
ENDIF
vln=vln-bytes
IF v4=1 OR v4=8 THEN
seek=seek+bytes
ELSE
seek=seek-bytes
ENDIF
UNTIL vln<4 OR back%<>-1
IF back%<>-1 THEN
back%=seek2+back%
ENDIF
ENDIF
CLOSE #1
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE markhandler(VAR tx)
.| Glob. Var.: cs#,ce#,xm#,x#,xd#,y#,stay1#,stay2#,k#,f#,x3#,x2#,v2#,show#
.|     showdat#,tedart#,hz#,showbdat#,shw$,showxy&,zsnap#,v#,v3#,v4#,back%
.|     t$,obj#
.| Ruft auf  : mousek,mouse,maketime,textfeld,springart
.| Aufruf in : markprod2-4,
LOCAL ux,i,vtx,cvt,fm,mx
fm=0
vtx=tx
'  cvt=TIMER
IF vtx>=cs AND vtx<=ce AND (ce-cs)>0 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
IF x>ux+xd-2 AND x<ux+xd+2 AND y>=stay1 AND y<=stay2 THEN
k=@mousek
~GRAF_MOUSE(256,0)                              ! Hidem
IF k=1 THEN
COLOR smpwcol
GRAPHMODE 1
IF markmode<>2 THEN
FOR i=x-3 TO x+3
LINE i,stay1,i,stay1-5
NEXT i
ENDIF
drawnew=TRUE
GRAPHMODE 3
f=0
x3=-1
IF markmode=3 AND sms2<>0 AND loops%(sms,sms2)<>-1 THEN
scrubb2=FALSE
@digout(TRUE)
@write_int(0)
'
scrubbm=meml+loops%(sms,sms2)
IF virtual=TRUE THEN
scrubbm=scrubbm-vcs
ENDIF
'
scrubbz=loops%(sms,sms2)
IF scrubbm>=meml AND scrubbm<memh THEN
scrubb=XBIOS(xbs,307,L:scrubbm,L:hz)
@write_int(1)
scrubb2=TRUE
ENDIF
ENDIF
REPEAT
@mouse(x2,v2,k)
'
IF markmode=3 AND sms2<>0 AND loops%(sms,sms2)<>-1 THEN
'    IF TIMER-cvt>4 THEN
'   cvt=TIMER
'
scrubbm=meml+scrubdat*mbit
IF virtual=TRUE THEN
scrubbm=scrubbm-vcs
ENDIF
'
IF scrubbm>=meml AND scrubbm<memh AND scrubb2=TRUE AND (TIMER-sct)>2 THEN
LPOKE scrubb+8,scrubbm
sct=TIMER
ENDIF
' ENDIF
ENDIF
'
@maketime
IF x2>=xd AND x2<=(xm+xd) AND xm>0 AND ce>cs AND show=TRUE THEN
scrubdat=(INT((INT((ce-cs)/mbit))/xm*(x2-xd)))+INT(cs/mbit)
showdat=scrubdat
IF tedart=0 THEN
showdat=showdat/hz
ENDIF
IF showbdat<>showdat THEN
showbdat=showdat
IF tedart=1 THEN
a$=STR$(showdat)
@formatsmp
shw$=a$+CHR$(0)
ELSE
hsec=showdat*100
@htimeset
shw$=a$
ENDIF
IF LEN(shw$)>13 THEN
shw$=LEFT$(shw$,13)+CHR$(0)
ENDIF
@textfeld(showxy&,shw$,1)
ENDIF
ENDIF
'
IF x<>x2 THEN
INC f
ENDIF
x=x2
IF x>=xd AND x<=xm+xd AND x<>ux+xd AND x3<>x THEN
GRAPHMODE 3
IF fm=0 AND markmode=2 THEN
mx=ux
ENDIF
IF (fm>0 AND markmode=2) OR markmode<>2 THEN
COLOR 0
LINE ux+xd,stay1+1,ux+xd,stay2
ENDIF
fm=1
COLOR 1
IF markmode=2 THEN
PBOX mx+xd,stay1+1,ux+xd,stay2
ENDIF
vtx=INT(((ce-cs)/xm*(x-xd)+cs)/mbit)*mbit
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
x3=x
LINE ux+xd,stay1+1,ux+xd,stay2
GRAPHMODE 3
IF markmode=2 THEN
PBOX mx+xd,stay1+1,ux+xd,stay2
ENDIF
drawnew=TRUE
ENDIF
UNTIL k=0
IF markmode=2 THEN
COLOR 1
GRAPHMODE 3
PBOX mx+xd,stay1+1,ux+xd,stay2
COLOR 1
ENDIF
IF markmode=3 THEN
@write_int(0)
@digout(FALSE)
ENDIF
IF markmode=4 THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4<>0 THEN
@springart(vtx)
IF back%>=cs AND back%<=ce THEN
vtx=back%
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
GRAPHMODE 3
COLOR 0
LINE ux+xd,stay1+1,ux+xd,stay2
COLOR 1
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
x3=x
LINE ux+xd,stay1+1,ux+xd,stay2
GRAPHMODE 3
drawnew=TRUE
ENDIF
ENDIF
tx=vtx
COLOR 1
GRAPHMODE 3
DEFTEXT 1,0,0,4
TEXT ux+xd-2,stay1-1,t$
drawnew=TRUE
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
obj=0
RETURN
'
> PROCEDURE markhandl2(VAR tx)
.| Glob. Var.: x#,vmem#,cs#,ce#,xm#,xd#,stay1#,stay2#,t$
.| Aufruf in : smph2-4,
LOCAL ux,i,vtx
vtx=tx
IF x>=0 AND x<=vmem AND x>=cs AND x<=ce AND (ce-cs)>0 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
GRAPHMODE 3
COLOR 1
LINE ux+xd,stay1,ux+xd,stay2
COLOR smpwcol
GRAPHMODE 1
FOR i=ux-3 TO ux+3
LINE i+xd,stay1,i+xd,stay1-5
NEXT i
GRAPHMODE 1
COLOR 1
ux=x-cs
ux=INT(ux/(ce-cs)*xm)
GRAPHMODE 3
LINE ux+xd,stay1,ux+xd,stay2
DEFTEXT 1,0,0,4
TEXT ux+xd-2,stay1-1,t$
drawnew=TRUE
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
IF x>=0 AND x<=vmem AND (ce-cs)>0 THEN
tx=x
ENDIF
RETURN
'
> PROCEDURE blkstore
.| Glob. Var.: blks#
.| Aufruf in : do_smpedit-1,
IF blks=0 THEN
blks=1
ELSE
blks=0
ENDIF
RETURN
'
> PROCEDURE tstfile
LOCAL t3,t4
OPEN "I",#1,fil$
f=LOF(#1)
datx=mdat%
BGET #1,datx,4
@fileart
SEEK #1,0
@fileart2
CLOSE #1
danf=datx
'
IF fileart=1 THEN       ! S16
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
per=INT(10^9/(x*65536+y))
perm=INT(per/100)*100
per=INT(perm)
t3=PEEK(danf+13)                           ! Sustain Loop-Start
t4=DPEEK(danf+14)                          ! Sustain Loop-Start
tmin=t3*65536+t4
t3=DPEEK(danf+16)                          ! Sustain Loop-End
t4=PEEK(danf+18)                           ! Sustain Loop-End
tmax=t3*256+t4
head=20   ! HeaderlÑnge fÅr S16-Files
ENDIF
IF fileart=2 THEN        ! AVR
tst1=DPEEK(danf+12)    ! mode
tst2=DPEEK(danf+14)    ! resolution
IF tst2=16 THEN
@setbitrate16
ENDIF
IF tst2=24 THEN
@setbitrate24
ENDIF
tst3=DPEEK(danf+16)    ! sign
IF tst1=&HFFFF AND (tst2=16 OR tst2=24) AND tst3=&HFFFF THEN
per=DPEEK(danf+24)    ! Sample-Rate
ENDIF
head=128   ! HeaderlÑnge fÅr AVR-Files
ENDIF
IF fileart=3 THEN        ! WAV
tst1=LPEEK(danf+8)     ! "WAVE"
tst2=LPEEK(danf+12)    ! "fmt "
tst3=PEEK(danf+20)     ! format
tst4=PEEK(danf+22)     ! channels
tst5=PEEK(danf+32)     ! align
tst6=PEEK(danf+34)     ! bps
IF tst6=16 THEN
@setbitrate16
ENDIF
IF tst6=24 THEN
@setbitrate24
ENDIF
IF tst1=&H57415645 AND tst2=&H666D7420 AND tst3=1 AND tst4=2 AND tst5=4 AND (tst6=16 OR tst6=24) THEN
per=PEEK(danf+24)+256*PEEK(danf+25)    ! Sample-Rate
ENDIF
head=44   ! HeaderlÑnge fÅr AVR-Files
ENDIF
IF fileart=4 THEN        ! AU
tst1=LPEEK(danf+12)    ! dataformat
tst2=LPEEK(danf+20)    ! channelcount
IF tst1=3 AND tst2=2 THEN
per=LPEEK(danf+16)    ! Sample-Rate
ENDIF
head=28   ! HeaderlÑnge fÅr AVR-Files
ENDIF
IF fileart=5 THEN         ! SD
per=LPEEK(danf+1020)    ! Sample-Rate
head=1336 ! HeaderlÑnge fÅr SD-Files
ENDIF
IF fileart=6 THEN         ! SMP
tst1=DPEEK(danf+76)     ! Bits
IF tst1=16 THEN
per=LPEEK(danf+72)     ! Sample-Rate
ENDIF
head=296 ! HeaderlÑnge fÅr SD-Files
ENDIF
IF fileart=7 THEN        ! AIFF
tst1=LPEEK(danf+8)     ! AIFF-Kennung
tst2=LPEEK(danf+12)    ! COMM-Kennung
tst3=DPEEK(danf+20)    ! Channels
tst4=LPEEK(danf+38)    ! SSND-Kennung
tst5=DPEEK(danf+26)    ! Bits
IF tst5=16 THEN
@setbitrate16
ENDIF
IF tst5=24 THEN
@setbitrate24
ENDIF
IF tst1=&H41494646 AND tst2=&H434F4D4D AND tst3=2 AND tst4=&H53534E44 AND (tst5=16 OR tst5=24) THEN
per=DPEEK(danf+30)     ! Sample-Rate
ENDIF
head=54+458   ! HeaderlÑnge fÅr AIFF-Files
ENDIF
IF fileart<>0 THEN
@ldhztest
ENDIF
sectors=f
RETURN
'
> PROCEDURE sethdoffset
head=0
IF fileart=1 THEN
head=20
ENDIF
IF fileart=2 THEN
head=128
ENDIF
IF fileart=3 THEN
head=44
ENDIF
IF fileart=4 THEN
head=28
ENDIF
IF fileart=5 THEN
head=1336
ENDIF
IF fileart=6 THEN
head=20+296
ENDIF
IF fileart=7 THEN
head=54+458
ENDIF
RETURN
'
> PROCEDURE onlystart
IF c1>=0 AND c2=-1 THEN
c2=vmem
ENDIF
RETURN
'
> PROCEDURE smpplay
.| Glob. Var.: digana#,merkc#,hrd#,sblock#,mamidi#,a#,meml#,b#,memh#,sret#
.|     adder#,c#,l#,sloop#,adm#,ad#,nr#,smp16&,a$,popups&,analog&,input&
.|     digital&,smpedit&,smpplay&,virtual#,op$,ext$,pret#,pbutt#,fil$,f#
.|     sectors#,flen#,smpfile&,nam$,smplen&,mem$,s#,hz#,smpsec&,sec$,over#
.|     handle#,playpos#,cblk#,sms#,sme#,c1#,c2#,raus#,y#,v3#,demo#
.| Ruft auf  : edhandler3,wait,maschinit2,analog,textfeld,maschruf2
.|     maschruf18,digin,digital,setbutton,smppmhlp,fileselect,restaura
.|     memfeld,secfeld,digout,maschinit5b,blocklook,maschruf5c,maschruf18c
.|     maschinit5d,fnamwrite
.| Aufruf in : drop2-1,do_smpedit-1,smpcblkplay-1,
@markhlp
adm=ad
IF nr=peak& THEN
@write_int(0)
ENDIF
IF digana=FALSE THEN
merkc=-1
@edhandler3
ENDIF
@wait
IF hrd=0 THEN
'
IF falcon=TRUE THEN
demo=FALSE
ENDIF
'
IF sblock=0 THEN
a=meml
b=memh
IF sret=1 THEN
adder=0
c=a
a=b-mbit
b=c
l=sloop
ELSE
adder=0
l=sret+sloop
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,analog&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF (sret=0 OR sret=2) AND a<b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF sret=1 AND a>b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,digital&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
@setbutton(smpwait&,32)
ENDIF
IF nr=peak& THEN
@setbutton(playpeak&,32)
ENDIF
ELSE
@smppmhlp
ENDIF
'
IF falcon=TRUE THEN
demo=TRUE
ENDIF
'
ELSE
IF virtual=FALSE THEN
@fileselect(op$+"*."+ext$,"","PLAY:")
@restaura
ENDIF
IF (virtual=FALSE AND pret<>0 AND pbutt=1) OR virtual=TRUE THEN
IF EXIST(fil$) THEN
'
@infload
'
@tstfile
@sethdoffset
IF nr=smpedit& THEN
@textfeld(smpfile&,nam$+CHR$(0),1)
@memfeld(f,8)
@textfeld(smplen&,mem$,1)
s=f/(hz*mbit)
@secfeld(s,8)
@textfeld(smpsec&,sec$,1)
ENDIF
IF nr=peak& THEN
pknam$=nam$
@textfeld(peakname&,pknam$+CHR$(0),1)
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,analog&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
@digout(TRUE)
'        @maschinit5b
IF sret=0 OR sret=2 THEN
l=sret+sloop
over=0
adder=over
REPEAT
a$=fil$+CHR$(0)
handle=GEMDOS(61,L:VARPTR(a$),0)
IF handle>0 THEN
playpos=head
IF virtual=TRUE AND sblock=1 THEN
IF cblk=FALSE THEN
@blocklook
@onlystart
ENDIF
IF (sms<>0 AND c1<>-1 AND c2>0 AND c2>c1) OR cblk=TRUE THEN
sectors=(c2-c1)
playpos=c1+head
ENDIF
ENDIF
IF mamidi=0 THEN
@maschrufb5
ELSE
@maschruf18c
IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
l=sret+sloop+4
@maschruf5c
ENDIF
ENDIF
~GEMDOS(62,handle)
ENDIF
UNTIL mamidi=0 OR (mamidi=1 AND (v3=2 OR INP?(2)=TRUE))
ENDIF
IF sret=1 OR sret=2 THEN
l=sloop
over=-mbit*2
adder=over
REPEAT
a$=fil$+CHR$(0)
handle=GEMDOS(61,L:VARPTR(a$),0)
IF handle>0 THEN
IF virtual=TRUE AND sblock=1 THEN
IF cblk=FALSE THEN
@blocklook
@onlystart
ENDIF
IF (sms<>0 AND c1<>-1 AND c2>0 AND c2>c1) OR cblk=TRUE THEN
sectors=(c2-c1)
playpos=c2+head
ENDIF
ELSE
playpos=sectors
ENDIF
IF mamidi=0 THEN
@maschrufb5
ELSE
@maschruf18c
IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
l=sloop+4
@maschruf5c
ENDIF
ENDIF
~GEMDOS(62,handle)
ENDIF
UNTIL mamidi=0 OR (mamidi=1 AND (v3=2 OR INP?(2)=TRUE))
ENDIF
@maschinit5d
@fnamwrite
'
@infsave2
'
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
@setbutton(smpwait&,32)
ENDIF
IF nr=peak& THEN
@setbutton(playpeak&,32)
ENDIF
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,digital&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
@digout(FALSE)
RETURN
'
> PROCEDURE smpcblkplay
.| Glob. Var.: cs#,ce#,vmem#,a#,meml#,b#,c1#,c2#,vsblock#,sblock#,vmamidi#
.|     mamidi#,cblk#,ama#,amb#,memh#
.| Ruft auf  : smpplay
.| Aufruf in : do_smpedit-1,
IF cs>=0 AND ce<=vmem AND cs<ce THEN
cs=INT(cs/mbit)*mbit
ce=INT(ce/mbit)*mbit
a=meml+cs
b=meml+ce
a=INT(a/mbit)*mbit
b=INT(b/mbit)*mbit
c1=cs
c2=ce
vsblock=sblock
vmamidi=mamidi
sblock=1
mamidi=0
cblk=TRUE
ama=meml
amb=memh
@smpplay
cblk=FALSE
sblock=vsblock
mamidi=vmamidi
ENDIF
RETURN
'
> PROCEDURE smppmhlp
.| Glob. Var.: mamidi#,cblk#,l#,sloop#,lmin#,a#,lma#,b#,sms#,sme#,ama#,amb#
.|     xm#,stxnr#,sret#,adder#,c#,adm#,ad#,nr#,smp16&,a$,popups&,analog&
.|     input&,digital&,smpedit&,smpplay&
.| Ruft auf  : maschinit2,playblksearch,analog,textfeld,maschruf2,maschruf18
.|     digin,digital,setbutton
.| Aufruf in : smpplay-1,
IF cblk=FALSE THEN
@playblksearch
ENDIF
l=sloop
lmin=a
lma=b
IF (sms<>0 AND a>=ama AND b<=amb AND xm<>0 AND stxnr<>0) OR cblk=TRUE THEN
IF sret=1 THEN
adder=0
c=a
a=b-mbit
b=c
ELSE
adder=0
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,analog&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF (sret=0 OR sret=2) AND a<b THEN
l=l+sret
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF sret=1 AND a>b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,digital&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
IF nr=peak& THEN
@setbutton(playpeak&,32)
ENDIF
RETURN
'
> PROCEDURE playblksearch
.| Glob. Var.: a#,meml#,ama#,amb#,memh#,i#,loopz#,sms#,stxnr#,xm#,b#,sme#
.| Felder    : loops#(),loope#()
.| Aufruf in : smppmhlp-1,
a=meml
ama=a
amb=memh
stxnr2=loops%(sms,1)
IF xm>0 AND stxnr2>0 THEN
a=a+stxnr2
a=INT(a/mbit)*mbit
ENDIF
b=meml
stxnr=loops%(sms,2)
IF xm>0 AND stxnr>0 THEN
b=b+stxnr
b=INT(b/mbit)*mbit
b=b-mbit
ENDIF
IF xm>0 AND stxnr=-1 AND stxnr2>=0 THEN
b=memh
b=INT(b/mbit)*mbit
b=b-mbit
ENDIF
RETURN
'
> PROCEDURE smppmark
.| Glob. Var.: sblock#
.| Aufruf in : do_smpedit-1,
IF sblock=0 THEN
sblock=1
ELSE
sblock=0
ENDIF
RETURN
'
> PROCEDURE smploop
.| Glob. Var.: sloop#
.| Aufruf in : do_smpedit-1,
IF sloop=0 THEN
sloop=1
ELSE
sloop=0
ENDIF
RETURN
'
> PROCEDURE smpauto
.| Glob. Var.: autorec#,obj#,recok&,retime#,ldlen#,hrd#,blocks#,a#,meml#,l#
.|     mlen#,mcs#,mce#,sab%,sbb%,frag#,nofile#,ad#,hzc#,rwert#,sblock#,c2#
.|     c1#,sms#,sme#,ce#,xm#,nr#,smpedit&,smpauto2&,arranger&,smpauto3&
.| Ruft auf  : makehz2,sethertz,wait,smptime,maschinit3,blocklook,record3
.|     digout,smprate,maschruf4b,maschruf4,fifodel,maschruf3b,record4
.|     setbutton,record2
.| Aufruf in : drop2-1,do_arrange-1,do_smpedit-1,do_peak-1,
sectpos=0
ed_obj=obj
autorec=TRUE
@makehz2
@sethertz
@wait
retime=0
ldlen=0
IF hrd=0 THEN
IF blocks=0 THEN
a=meml
l=mlen
ELSE
@blocklook
a=mcs
l=mce-mcs
ENDIF
sab%=a
sbb%=a+l
ELSE
@record3
ENDIF
IF hrd=0 OR (hrd=1 AND obj=recok&) THEN
@digout(FALSE)
IF hrd=0 THEN
@alerts(48)
ENDIF
IF (hrd=1 AND nofile=0) THEN
frag=1
ENDIF
IF frag=2 THEN
@setbutton(ed_obj,0)
ENDIF
@wait
IF ad=0 THEN
@read_digsrate
hzc=rwert
ENDIF
IF frag=1 AND ((hrd=0 AND sblock=0) OR (hrd=0 AND sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND ce<>0 AND xm>0)) THEN
IF XBIOS(xbs,1)=&H71273800 THEN
@maschruf4b
ENDIF
ELSE
'      @fifodel
ENDIF
IF frag=1 AND ((hrd=0 AND sblock=0) OR (hrd=0 AND sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND ce<>0 AND xm>0)) THEN
@maschruf3b
ENDIF
IF hrd=1 THEN
@record4
ENDIF
IF nr=smpedit& THEN
@setbutton(smpauto2&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpauto3&,0)
ENDIF
@record2
ELSE
IF nr=smpedit& THEN
@setbutton(smpauto2&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpauto3&,0)
ENDIF
ENDIF
obj=0
edit_obj&=0
IF nr=smpedit& THEN
IF hrd=1 THEN
@setbutton(hard&,1)
ELSE
@setbutton(hard&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE smpstart
.| Glob. Var.: autorec#,obj#,recok&,ldlen#,hrd#,nr#,smpedit&,smpstrt2&
.|     arranger&,smpstrt3&
.| Ruft auf  : makehz2,sethertz,wait,smptime,fifodel,record,record3,record4
.|     setbutton,record2
.| Aufruf in : drop2-1,do_arrange-1,do_smpedit-1,do_peak-1,
sectpos=0
ed_obj=obj
autorec=FALSE
@makehz2
@sethertz
@wait
ldlen=0
'  @fifodel
IF hrd=0 THEN
@alerts(48)
IF frag=1 THEN
@record
ELSE
@setbutton(ed_obj,0)
ENDIF
ELSE
@record3
IF obj=recok& THEN
@record4
ENDIF
ENDIF
IF (hrd=0 AND frag=1) OR (hrd=1 AND obj=recok&) THEN
IF nr=smpedit& THEN
@setbutton(ed_obj,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpstrt3&,0)
ENDIF
IF hrd=0 THEN
@record2
ENDIF
ELSE
IF nr=smpedit& THEN
@setbutton(ed_obj,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpstrt3&,0)
ENDIF
ENDIF
obj=0
edit_obj&=0
IF nr=smpedit& THEN
IF hrd=1 THEN
@setbutton(hard&,1)
ELSE
@setbutton(hard&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE record
.| Glob. Var.: retime#,ldlen#,nr#,smpedit&,p$,smprate&,sblock#,a#,meml#,l#
.|     mlen#,mcs#,mce#,ad#,hzc#,rwert#,c2#,c1#,sms#,sme#,ce#,xm#
.| Ruft auf  : textfeld,maschinit3,blocklook,smprate,digout,maschruf3
.| Aufruf in : smpstart-1,
'
IF falcon=TRUE THEN
demo=FALSE
ENDIF
'
retime=0
ldlen=0
IF nr=smpedit& THEN
p$="    "+CHR$(0)
@textfeld(smprate&,p$,1)
ENDIF
IF nr=peak& THEN
pknam$=smpnam$
@textfeld(peakname&,pknam$+CHR$(0),1)
ENDIF
IF sblock=0 THEN
IF sms2<>0 AND nr=smpedit& THEN
@edmarkdel
ENDIF
@markdel
@clsed
ENDIF
IF sblock=0 THEN
a=meml
l=mlen
ELSE
@blocklook
a=mcs
l=mce-mcs
ENDIF
IF ad=0 THEN
@read_digsrate
hzc=rwert
ENDIF
IF sblock=0 OR (sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND ce<>0 AND xm>0) THEN
@digout(FALSE)
IF ed_obj=smpstrt2& OR ed_obj=smpstrtp& THEN
@maschruf3
ENDIF
IF ed_obj=recplay3& THEN
@maschruf7
ENDIF
ELSE
@setbutton(obj,0)
ENDIF
'
IF falcon=TRUE THEN
demo=TRUE
ENDIF
'
RETURN
'
> PROCEDURE record2
.| Glob. Var.: nr#,sblock#,smpnam$,ext2$,path$,lfw$,smplen#,vmem#,mbs#,i#
.|     bloopz#,lded#,smpedit&,cs#,ce#
.| Felder    : bloops#(),bloope#()
.| Ruft auf  : rsc_redraw_obj,markdel,clsed,fnamwrite,curve,markprod3
.| Aufruf in : smpauto-1,smpstart-1,
smpnam$="MEMORY."+ext2$
path$=lfw$+smpnam$
smplen=vmem
mbs=0
FOR i=1 TO bloopz
bloops%(i,1)=-1
bloops%(i,2)=-1
NEXT i
lded=0
@fnamwrite
IF nr=smpedit& THEN
@editredraw
ENDIF
RETURN
'
> PROCEDURE record3
.| Glob. Var.: retime#,ldlen#,nofile#,hrd#,op$,ext2$,nr#,fil$,pret#,pbutt#
.|     nam$,f#,min#,hz#,sectors#,flen#,smpedit&,smpfile&,smplen&,mem$,hsec#
.|     smpsec&,sec$,autorec#
.| Ruft auf  : fileselect,rsc_redraw_obj,textfeld,memfeld,secfeld,restaura
.| Aufruf in : smpauto-1,smpstart-1,
ext2$=ext$
IF ext2$="*" THEN
IF dig24=FALSE THEN
ext2$="S16"
ELSE
ext2$="S24"
ENDIF
ENDIF
retime=0
ldlen=0
nofile=0
IF hrd=1 THEN
rsmpnam$=smpnam$
rpath$=path$
rsmplen=smplen
rfil$=fil$
rnam$=nam$
rordner$=ordner$
@fileselect(op$+"*."+ext2$,"","RECORD:")
IF fil$="" OR pret=0 OR pbutt=0 THEN
nofile=1
ELSE
IF RIGHT$(fil$,1)="\" THEN
nofile=1
ENDIF
ENDIF
IF nofile=0 THEN
@smptime
ENDIF
IF nofile=0 AND obj=recok& THEN
IF INSTR(fil$,".")=0 THEN
fil$=fil$+"."+ext2$
ENDIF
IF INSTR(nam$,".")=0 THEN
nam$=nam$+"."+ext2$
ENDIF
fil$=fil$+CHR$(0)
f=INT(rtime/100*hz)*mbit
sectors=f
IF nr=smpedit& THEN
@textfeld(smpfile&,nam$+CHR$(0),1)
@memfeld(f,8)
@textfeld(smplen&,mem$,1)
IF rmo8=FALSE THEN
hsec=f/(hz*mbit)
ELSE
hsec=f/hz
ENDIF
@secfeld(hsec,8)
@textfeld(smpsec&,sec$,1)
ENDIF
IF nr=peak& THEN
pknam$=nam$
@textfeld(peakname&,pknam$+CHR$(0),1)
ENDIF
IF wisch=FALSE THEN
@restaura
ENDIF
ELSE
smpnam$=rsmpnam$
path$=rpath$
smplen=rsmplen
fil$=rfil$
nam$=rnam$
ordner$=rordner$
@setbutton(ed_obj,0)
IF autorec=FALSE AND wisch=FALSE THEN
@restaura
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE record4
.| Glob. Var.: mrkfastrec#,fastrec#,hrd#,nofile#,autorec#,isave#,bnam$,nam$
.|     fil$,l#,smplen#,inf#,path$,smpnam$,g#,mlen#
.| Ruft auf  : maschinit8,maschinit8b,infhol,sampleinf,makedatum,infsave
.|     maschruf8,maschruf8b,fnamwrite
.| Aufruf in : smpauto-1,smpstart-1,
mrkfastrec=fastrec
'  fastrec=FALSE   !   = FALSE wenn nur alte RECORD-Routine, wenn REM-Zeile dann Åber TURBO im Setup alt/neu wÑhlbar
'
IF hrd=1 THEN
IF nofile=0 THEN
IF hrd=1 THEN
@infhol
isave=TRUE
bnam$=nam$
IF EXIST(fil$)=TRUE THEN
OPEN "I",#1,fil$
l=LOF(#1)
smplen=INT(l/mbit)
CLOSE #1
ENDIF
@sampleinf
isave=FALSE
IF inf=TRUE THEN
path$=fil$
smpnam$=nam$
@makedatum
ELSE
IF virtual=TRUE AND EXIST(rfil$) THEN
smpnam$=rsmpnam$
path$=rpath$
smplen=rsmplen
fil$=rfil$
nam$=rnam$
ordner$=rordner$
ENDIF
ENDIF
ENDIF
IF inf=TRUE THEN
'
@markdel
@clsed
'
IF mtc=FALSE THEN
@alerts(49)
ENDIF
IF autorec=TRUE THEN
IF frag=1 AND hrd=1 AND nofile=0 THEN
IF XBIOS(xbs,1)=&H71273800 THEN
@maschruf4b
ENDIF
ELSE
'           @fifodel
ENDIF
ENDIF
@maschruf8c
@infsave
@infmemkill
IF nr=smpedit& THEN
@markdel
@clsed
'
@infmemkill             ! Das hier ist nîtig, weil durch HDR das samplemem Åberschrieben wird
cached=FALSE
@maschruf9(meml,memh)   ! Delete Memory
@restaura
'
ENDIF
IF virtual=TRUE AND EXIST(rfil$) THEN
smpnam$=rsmpnam$
path$=rpath$
smplen=rsmplen
fil$=rfil$
nam$=rnam$
ordner$=rordner$
ENDIF
ELSE
@setbutton(ed_obj,0)
ENDIF
ENDIF
smplen=mlen
@fnamwrite
ENDIF
autorec=FALSE
'
fastrec=mrkfastrec
RETURN
'
> PROCEDURE exit
.| Glob. Var.: cwerte1#,cwert#,merkfrei#,mdatf2#,mdatf#,big#,anfloadx#,virt$
.|     virt2$
.| Aufruf in : goodbye-1,
IF nonstm<>0 THEN
~MFREE(nonstm)
nonstm=0
ENDIF
IF memfade<>0 THEN
~MFREE(memfade)
ENDIF
IF memtrak<>0 THEN
~MFREE(memtrak)
ENDIF
IF memc<>0 THEN
~MFREE(memc)
ENDIF
IF nopeakmem=FALSE AND peakmemda=TRUE THEN
~MFREE(peakmem%)
ENDIF
IF cwerte1>0 THEN
~MFREE(cwert)
ENDIF
IF merkfrei>0 THEN
~MFREE(merkfrei)
ENDIF
IF mdatf2>0 THEN
~MFREE(mdatf2)
ENDIF
IF mdatf>0 THEN
~MFREE(mdatf)
ENDIF
IF big=0 AND anfloadx>0 THEN
~MFREE(anfloadx)
ENDIF
IF EXIST(virt$) THEN
KILL virt$
ENDIF
IF EXIST(virt2$) THEN
KILL virt2$
ENDIF
RETURN
'
> PROCEDURE fehler
.| Glob. Var.: g#
.| Ruft auf  : goodbye
.| Aufruf in : HAUPTPROGRAMM-1,
exerr=TRUE
@alerts(50)
exerr=FALSE
IF g=1 THEN
RESUME NEXT
ELSE
@goodbye
ENDIF
RETURN
'
'
' ENDE
