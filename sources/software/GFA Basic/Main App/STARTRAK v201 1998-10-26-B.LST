$m900000
$e$
'
public=TRUE                ! public or non-public
falconda=FALSE             ! Falcon-Emulation
'
' dspuse         ! Host-Port-öbertragung : DSP fÅr trkplay, play & record-Funktionen nutzen
'
' matrixplay     ! Wiedergabe Åber Matrix(TRUE) oder DSP(FALSE)
'
' pch4           ! 4Kanal-PlayMode
' pmo8           ! Play- 8Kanal-Mode nutzen (auch fÅr 16Ch-Mode)
' pch16          ! 16Kanal-PlayMode
'
xinit=FALSE
xload=FALSE
windowda=FALSE
smpwcol=4
smpblkcol=9
xbs=500                   ! my_xbios
ON ERROR GOSUB fehler
'
' ------------------------------------------------------------------------------
' -------STARTRAK.PRG   Sample-Editor & Midi-Player for VME-Atari's-------------
' ----------------------with VME StarTrack Audiocard 16/24Bit Harddisksampler---
' ------------------------First Release 22.8.1994-------------------------------
' ------------------------------------------------------------------------------
' -------------------V 2.01 - Revision 26.10.1998 ------------------------------
' ------------------------------------------------------------------------------
'
'
drvtyp$="STARTRACK"
'
'
compile=BYTE{ADD(BASEPAGE,256)}<>96
@changecr
'
'
'
' ------------------------------------------------------------------------------
' ------------------------STARTRACK-REGISTER------------------------------------
' ------------------------------------------------------------------------------
'
' READ  401h   Status Low                          Bit 0-2,7 -> MAGICVOL,MAGICXLR,MAGICDIGI,MAGICADDA
'
'                                 0  MAGICVOL    - 0=kein zweiter Volume-Controller fÅr Ausgang vorhanden
'                                                  1=zweiter Volume-Controller fÅr Ausgang vorhanden
'                                 1  MAGICXLR    - 0=keine XLR-Erweiterung vorhanden
'                                                  1=XLR-Erweiterung vorhanden
'                                 2  MAGICDIGI   - 0=keine digitalen Schnittstellen vorhanden
'                                                  1=digitale Schnittstellen vorhanden
'                                 6  MAGICHS96   - 0=keine 96KHz-Highsampling,Takt kommt von ICLK-Anschluss
'                                                  1=96KHz-Highsampling mîglich,interne Taktverdopplung des 18.432MHz-Taktes
'                                 7  MAGICADDA   - 0=keine A/D und D/A-Wandler vorhanden
'                                                  1=A/D und D/A-Wandler vorhanden
'
'
'
' WRITE 401h   Register Low  Bytewide              Bit0-7 -> SWAES,SWDIGIN,TAKT0,TAKT1,EXTAKT,EXTEX,EXTTF,EXTTW
'
'                                 0  SWAES       - 0=digitaler Eingang, 1=Analogeingang
'                                 1  SWDIGIN     - 0=optischer Digitaleingang, 1=koaxialer Digitaleingang
'                               2,3  TAKT0,TAKT1 - 0=Takt vom A/D & D/A, 1=32khz, 2=44.1khz, 3=48khz
'                                                  Wird ein externer Takt eingespeist bzw. der MCLK-Takt intern geteilt (EXTAKT=1)
'                                                  wird das Signal TAKT0 miûbraucht, um zwischen 256/384facher Teilung
'                                                  des Mastertaktes umzuschalten. Das Ergebnis sind die Samples/s
'                                                  TAKT0:  0=256facher Takt, 1=384facher Takt
'                                 4  EXTAKT      - 0=Original-MCLK-Takt (durch TAKT0 & TAKT1 bestimmt) nutzen
'                                                - 1=eigenen MCLK-Takt (durch EXTEX,EXTTF & EXTTW bestimmt) nutzen
'
'                                 folgende Register wirken nur in Verbindung mit EXTAKT=1:
'
'                                 5  EXTEX       - 0=internen MCLK-Takt fÅr Taktteiler nutzen (16.9344/24.576 MHz)
'                                                  1=extern Åber EXTMCLK zugefÅhrten MCLK fÅr Taktteiler nutzen
'                                 6  EXTTF       - 0=durch 2(bei EXTEX=0) geteilten Takt fÅr MCLK nutzen. Bei EXTEX=1 keine
'                                                    Teilung, MCLK wird direkt durch EXTCLK (external CLK-Input) erzeugt
'                                                - 1=durch 4(bei EXTEX=0) geteilten Takt fÅr MCLK nutzen. Bei EXTEX=1 Teilung
'                                                    des EXTCLK (external CLK-Input) durch 2 fÅr MCLK-Erzeugung
'                                 7  EXTTW       - 0=16.9344 MHz, 1=12.288MHz fÅr Taktteiler - nur in Verbindung mit EXTEX=0
'                                                    relevant
'
'
'
' READ  421h   Status Mid                          Bit0-2,7 -> ERR0,ERR1,ERR2,EMPH
'
'            wenn  SUBFR=0        0  ERR0        - Fehlercodes vom Digitaleingang
'            wenn  SUBFR=0        1  ERR1        - Fehlercodes vom Digitaleingang
'            wenn  SUBFR=0        2  ERR2        - Fehlercodes vom Digitaleingang
'                                                  Fehlercodes: 0=no error, 1=validity bit high, 2=confidence flag,
'                                                               3=slipped sample
'                                                               4=CRC-error, 5=parity-error, 6=Bi-Phase coding error, 7=no lock
'                                                               (siehe auch CS8412-Manual)
'
'            wenn  SUBFR=1        0  USE         - 0=Profi, 1=Consumer
'            wenn  SUBFR=1        1  AUDIO       - 0=DATA, 1=Audio
'            wenn  SUBFR=1        2  PROT        - 0=no Copy-prohibit - SCMS not active, 1=Copy prohibit - SCMS is active
'            wenn  SUBFR=1        7  EMPH        - 0=no emphasis, 1=emphasis is active
'
'
' READ  441h   Status High                         Bit0-2 -> FIFO-WRempty,FIFO-WRhalf,FIFO-WRfull
'                                                  Die Flags des Play-FIFOs
'                                 0  WRempty     - 0=FIFO leer, muû nachgefÅllt werden sonst Datenverlust
'                                 1  WRhalf      - 0=FIFO mehr als halb gefÅllt, 1=FIFO weniger/bis halb gefÅllt, lîst
'                                                  auch INT aus
'                                 2  WRfull      - 0=FIFO voll, weiterschreiben wird mit Datenverlust bestraft :-)
'
' WRITE 441h   Register High  Bytewide             Bit0-7 -> SWPROT,SWRES-FIFO,SWDIGOUT,SWSUBFR,PREEMPH,GENERA,CATEG0,CATEG1
'
'                                 0  SWPROT(C2)  - 0=SCMS-Copybit aktiv, 1=SCMS-Copybit entfernen - Digitalkopie erlaubt (Bit C2)
'                                                  Wenn SWPROT=1 ist und der Categorycode 11 (DAT) ist,
'                                                  hat das GENERA-Bit keine Bedeutung
'                                                  und der Kopierschutz ist vollstÑndig entfernt.
'                                                  Wenn SWPROT=0 ist und der Categorycode 11 (DAT) ist, und das
'                                                  GENERA-Bit 1 ist, dann kann nach der öberspielung noch einmal kopiert werden.
'                                                  Wenn SWPROT=1 ist und der Categorycode 00 (General) ist, und das
'                                                  GENERA-Bit 0 ist, dann
'                                                  kann nach der öberspielung nicht mehr digital Åberspielt werden (SCMS)
'                                 1  SWRES-FIFO  - 0=REC-FIFO-Reset deaktiviert, 1=REC-FIFO-Reset aktiv - muû manuell
'                                                  rÅckgesetzt werden
'                                 2  SWDIGOUT    - 0=D/A und DigitalausgÑnge geben Daten vom A/D bzw. Digitaleingang wieder
'                                                  1=D/A und DigitalausgÑnge geben Daten vom Play-FIFO wieder
'                                 3  SWSUBFR(SEL)- 0=Error information des Digitaleingangs (siehe Status Mid: ERR0,ERR1,ERR2)
'                                                  1=Channel status information des Digitaleingangs (siehe Status Mid: USE,
'                                                  AUDIO,PROT)
'
'                                                  Die folgenden Bits PREEMPH,CATEG0,CATEG1 & GENERA wirken nur bei
'                                                  Sampler-PLAY auf den
'                                                  Digitalausgang und nicht bei direkten DigitalÅberspielungen als SCMS-Dekoder
'                                 4  PREEMPH(C3) - 0=Preemphasis aus, 1=Preemphasis an, nur wirksam bei Digital-Ausgang (Bit C3)
'                                 5  GENERA(C15) - 0=no indication, einmal kopierbar 1=orginal/nicht kopierbar
'                                                  Das GENERA-Bit hat nur eine Bedeutung, wenn Digitalkopie erlaubt, also SWPROT=1
'                                                  und der Categorycode 00 ist, dann kann 1x kopiert werden
'                                 6  CATEG0(C8)  - Categorycode
'                                 7  CATEG1(C9)  - Categorycode
'                                                  00=General, 01=PCM encoder/decoder, 10=laser optical(CD,MD),
'                                                  11=magnetic tape(DAT,DCC)
'                                 Im Professional-Mode haben einige Leitungen andere Bedeutungen. Alle wichtigen Steuerleitungen
'                                 sind vorhanden um auch den Professional-Mode nutzen zu kînnen. Damit sind auch AES/EBU-
'                                 AnschlÅsse denkbar.'
'
'
' READ  461h   Status xHigh                        Bit0-2 -> FIFO-RDempty,FIFO-RDhalf,FIFO-RDfull
'                                                  Die Flags des Record-FIFOs
'                                 0  RDempty     - 0=FIFO leer, weiterlesen wird mit Zufallsdaten bestraft
'                                 1  RDhalf      - 0=FIFO mehr als halb gefÅllt, 1=FIFO weniger/bis halb gefÅllt,
'                                                  lîst auch INT aus
'                                 2  RDfull      - 0=FIFO voll, muû ausgelesen werden sonst Datenverlust
'
'
' WRITE 481h   DSP-Register  Bytewide              Bit0-7 -> DSPON,DSPIN,VOLCS1,VOLCLK,VOLDATAI(CKS wenn EXTAKT=1),
'                                                            VOLCS2,AESC24,AESC25
'
'                                 0  DSPON       - 0=DSP-Ausgang nicht im Signalweg
'                                                    Bearbeitung der Eingangsdaten Åber DSP-Eingang (digital-in oder A/D)
'                                                    ist mîglich
'                                                  1=DSP-Ausgang im Signalweg, Ausgabe der DSP-Daten im Record oder Play-Zweig
'                                 1  DSPIN       - 0=DSP-Ausgang einschleifen im Record-Zweig
'                                                  1=DSP-Ausgang einschleifen im Play-Zweig
'                                 2  VOLCS1      - /CS-Signal fÅr A/D Volume-Controller
'                                 3  VOLCLK      - Clock-Signal fÅr Volume-Controller um Volume-Daten 8Bit Stereo l/r einzutakten
'                                 4  VOLDATAI    - Dateneingang des Volume-Controllers
'                                 5  VOLCS2      - /CS-Signal fÅr D/A Volume-Controller
'                                 6  AESC24      - Zeigt die Samplerate des Digital-Eingangssignals an (dekodiert dafÅr das
'                                 7  AESC25        Eingangssignal)
'                                                  0=44.1khz, 2=48khz, 3=32khz
'
'
'
' WRITE 4C1h   AES-Register  Bytewide              Bit0,1,7 -> SWPROF,SWCOPY,SPEBU
'
'                                 0  SWPROF      - 0=Consumer-Mode und Transparent-Mode
'                                                  1=Professional-Mode
'                                 1  SWCOPY      - 0=SCMS-Kopierschutz im Kopiermodus vollstÑndig entfernen
'                                                  1=SCMS-Kopierschutz erlaubt im Kopiermodus nur eine Kopie, danach ist
'                                                    SCMS wieder drinn
'                                 2  SWMAL2      - 0=normalen externen Takt benutzen
'                                                  1=externen Takt verdoppeln fÅr HighSampling mit 96KHz
'                                                    (18.432x2 = 36.864 MHz / 384 = 96000KHz)
'                                 7  SPEBU       - 0=SP/DIF-AnschlÅsse nutzen
'                                                  1=AES/EBU-ProfianschlÅsse nutzen
'
'
' RD/WR 501h  DSP-ChipSelect  Bytewide
'
'                               0-7  DSP-DATA    - /CS fÅr den DSP. Der DSP hat 8 Hostregister von 501h-50Fh. Das spiegelt sich im
'                                                  Adreûbereich bis 17Fh. Die HI-Register ICR,CVR,ISR,IVR,RXH,RXM,RXL bzw.
'                                                  ICR,CVR,ISR,IVR,TXH,TXM,TXL sind hierÅber zu erreichen.
'
'
' WRITE 521h  DSPRES            0    DSP-RESET   - 0=/RESET fÅr den DSP, du muût das Register manuell auf 1 zurÅcksetzen
'
'
' RD/WR 541h  SMPTE             0-7  SMPTE-DATA  - Bereich fÅr optionalen SMPTE-Coder/Decoder
'
'
' RD/WR 581h  Interrupt-Freigabe  Bytewide         Bit 0,1 -> PLAY-INT,REC-INT
'
'                                                  Der Startrack-Sampler erzeugt getrennte Vektoren fÅr Aufnahme und Wiedergabe
'                                                  Soll eine Interruptgesteuerte Aufnahme/Wiedergabe gestartet werden muû dafÅr
'                                                  eine Interruptroutine geschrieben/installiert werden. Das ganze wird aber erst
'                                                  gestartet, wenn das zustÑndige INT-Register gesetzt wird.
'                                                  Die Aufnahme/Wiedergabe kann durch RÅcksetzen des zustÑndigen INT-Registers
'                                                  gestoppt werden.
'                                  0  PLAY-INT   - 0=kein Play-Interrupt, 1=PLAY-Interrupt aktiviert bzw. ausgelîst
'                                                  Vector Nr.122
'                                  1  REC-INT    - 0=kein Record-Interrupt, 1=Record-Interrupt aktiviert bzw. ausgelîst
'                                                  Vector Nr.123
'
'
' RD/WR 600h   Sample Read/Write  Wordwide
'
'                               0-8  FIFO        - Hier werden die Samples eingeschrieben oder ausgelesen, und zwar in
'                                                  8Bit-HÑppchen
'                                                  Beim Lesen (REC) mit einer Kennung im Bit8 die anzeigt, ob das Sample zum
'                                                  linken oder rechten Kanal gehîrt.
'                                                  Bit8=0 - Rechter Kanal
'                                                  Bit8=1 - Linker Kanal
'                                                  Beim Schreiben werden auch 8Bit-HÑppchen geschrieben, dabei zeigt Adreûleitung
'                                                  A1 an, ob der rechte oder linke Kanal Åbertragen wird.
'                                                  A1=0 - Rechter Kanal
'                                                  A1=1 - Linker Kanal
'                                                  Zuerst wird das Highbyte des 16Bit-Samples geschrieben/gelesen, und dann
'                                                  das Lowbyte.
'
'
'
'
' Sample-Editor zum STARTRACK-Sampler
'
' Bedienung aller wichtiger Parameter des 16Bit-Stereo-Samplers und Sample-Editor/Arranger
'
CLIP OFF
startup=FALSE
acc=({ADD(BASEPAGE,36)}=0)
INLINE m_busy%,592
m_adr%=m_busy%
xwidth=WORK_OUT(0)+1
ywidth=WORK_OUT(1)+1
bigfoot=FALSE
IF xwidth>=1024 AND ywidth>=768 THEN
  bigfoot=TRUE
ENDIF
@busy_mouse
gemvers=GEMDOS(48)     ! GEMDOS-Version >=&H1900 = Fastram-Malloc
'
' ------------------------------------------------------------------------------
' ------------------------RSC-VARIABLEN-----------------------------------------
' ------------------------------------------------------------------------------
'
maxcol=WORK_OUT(13)
'
IF maxcol<16 THEN
  maxcol=2
ENDIF
'
'
OPTION BASE 0
IF compile=FALSE THEN
  RESERVE 1000000
ENDIF
'
'
IF acc=TRUE THEN
  ap_id&=APPL_INIT()
  IF ap_id&
    me_id&=MENU_REGISTER(ap_id&,"  StarTrack")
    DO
      ~EVNT_MESAG(0)
      IF MENU(1)=40
        accx=TRUE
        GOTO start
      ende:
      ENDIF
    LOOP
  ENDIF
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------AUFLôSUNG ERFRAGEN------------------------------------
' ------------------------------------------------------------------------------
start:
IF xwidth<640 OR ywidth<400 THEN
  @alerts(1)
  IF accx=FALSE THEN
    END
  ELSE
    GOTO ende
  ENDIF
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------RSC LADEN---------------------------------------------
' ------------------------------------------------------------------------------
DEFMOUSE 0
KEYPAD 0                    ! wg KompatibilitÑt (normale Tastatureinstellung)
'
IF compile=TRUE THEN
  lfw$=CHR$(GEMDOS(25)+65)+":"+DIR$(0)+"\"       ! funktioniert als COMPILAT !
ELSE
  lfw$="D:\"
ENDIF
IF accx=TRUE THEN
  lfw$="C:\"
ENDIF
s$=lfw$
speak$="external"           ! Voreinstellung Sprache
nonstop$=s$+"NONSTOP.S16"   ! Name des Info-Sounds
setn$="STARTRK"             ! Name fÅr alle Setups die automatisch geladen werden
setup$=s$+setn$+".SET"      ! Name des Setup-Files
fsel$=s$+setn$+".SEL"       ! Name des Fileselector-Files
arrup$=s$+setn$+".ARR"      ! Name des Arrange-Files
part$=s$+setn$+".LFW"       ! Name des Partition-Files
fade$=s$+setn$+".FAD"       ! Name des Fader-Files
virt2$=s$+setn$+".FIX"      ! Name des Files zur Rettung von Marken/Loop/Midi/Block bei Wechsel zu virt. Bearbeitung
virt$=s$+setn$+".VIR"       ! Name des virtuellen Files fÅr Backup-Zwecke (Backup des Speicherinhalts)
aback2$=s$+"BACKUP.ARR"     ! Name des Backup-Arrange-files
inf$="INF"                  ! Extender fÅr INF-File
mbox$="BOX"                 ! Extender fÅr Musicbox-files
trkf$="TRK"                 ! Extender fÅr Tracker-Files
peak$="PBF"                 ! Extender fÅr Peakwerte-Files
plug$="PLG"                 ! Extender fÅr Plugins
dsprog$="LOD"               ! Extender fÅr DSP-Programme
dspar$="PAR"                ! Extender fÅr DSP-Parameter
plgcext$="PCG"              ! Extender fÅr Plugin-Configs
cueext$="CUE"               ! Extender fÅr Cuelist
cuecdw$="CDW"               ! Extender fÅr Extendos Gold CD-Writer
plgconf$="STARTRK.PCG"      ! Name des Plugin Configfiles fÅr Autoload
dspord$="DSP_PLUG\"         ! Name fÅr DSP-Plugin-Unterordner
cpuord$="CPU_PLUG\"         ! Name fÅr CPU-Plugin-Unterordner
'
@calc_resource
@changetreenumbs
DIM rx(btree)
DIM ry(btree)
DIM rb(btree)
DIM rh(btree)
@setload
IF speak$="external" THEN
  lng$=lfw$+"LANGUAGE.TXT"  ! Name des Fehlerfiles
ELSE
  lng$=lfw$+speak$
ENDIF
alertflag=FALSE
@alertload
IF alertflag=FALSE THEN
  ALERT 1,"No Languagefile found !",1,"EXIT",g
  IF accx=FALSE THEN
    END
  ELSE
    GOTO ende
  ENDIF
ENDIF
IF ext$="S16" OR ext$="S24" THEN
  IF dig24=FALSE THEN
    ext$="S16"
  ELSE
    ext$="S24"
  ENDIF
ENDIF
ext2$=ext$
IF ext2$="*" THEN
  IF dig24=FALSE THEN
    ext2$="S16"
  ELSE
    ext2$="S24"
  ENDIF
ENDIF
virtfile$="VIRTWORK."+ext2$  ! Name des Files fÅr virtuelle Bearbeitung von StÅcken, die lÑnger als Speicherplatz sind
workfile$="WORK."+ext2$      ! Name des Files, zur Auslagerung beim öbergang mem->virt, wenn ein StÅck grîûer als Speicher wird
aback$="BACKUP."+ext2$       ! Name des Backup-Samplefiles
@rsc_init
'
DIM f.base%(3)
DIM f.scalc%(3)
DIM f.init%(3)
xrok1=@xrsrc_init(1)
IF xrok1=TRUE THEN
  xrok2=@xrsrc_init(2)
  IF xrok2=TRUE THEN
    xrok3=@xrsrc_init(3)
    IF xrok3=FALSE THEN
      @rsc_exit
      @alerts(3)
      IF xinit=TRUE THEN
        @xrsrc_exit(2)      ! beendet xrsrc-Routinen
        @xrsrc_exit(1)      ! beendet xrsrc-Routinen
      ENDIF
      IF accx=FALSE THEN
        END
      ELSE
        GOTO ende
      ENDIF
    ELSE
      xinit=TRUE
    ENDIF
  ELSE
    @rsc_exit
    @alerts(3)
    IF xinit=TRUE THEN
      @xrsrc_exit(1)      ! beendet xrsrc-Routinen
    ENDIF
    IF accx=FALSE THEN
      END
    ELSE
      GOTO ende
    ENDIF
  ENDIF
ELSE
  @rsc_exit
  @alerts(3)
  IF accx=FALSE THEN
    END
  ELSE
    GOTO ende
  ENDIF
ENDIF
IF rsc_mtsk!=TRUE THEN
  ~MENU_REGISTER(ap_id&,"  VME_SMP16")
ENDIF
'
'
'
mtype=INT(C:rsc_cookie%(L:CVL("_MCH"))/&H10000)   ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
magicmac=INT(C:rsc_cookie%(L:CVL("MgMc")))        ! COOKIE-ABFRAGE MagicMac
magix=INT(C:rsc_cookie%(L:CVL("MagX")))           ! COOKIE-ABFRAGE MagiC
nova=INT(C:rsc_cookie%(L:CVL("NOVA")))            ! COOKIE-ABFRAGE Nova-Grafikkarte
pci=INT(C:rsc_cookie%(L:CVL("_PCI")))             ! COOKIE-ABFRAGE PCI
mch=INT(C:rsc_cookie%(L:CVL("_MCH")))             ! COOKIE-ABFRAGE Machine
snd=INT(C:rsc_cookie%(L:CVL("_SND")))             ! COOKIE-ABFRAGE Sound
vdo=INT(C:rsc_cookie%(L:CVL("_VDO")))             ! COOKIE-ABFRAGE Video
cpu=INT(C:rsc_cookie%(L:CVL("_CPU")))             ! COOKIE-ABFRAGE CPU
milan=INT(C:rsc_cookie%(L:CVL("_MIL")))           ! COOKIE-ABFRAGE Milan
autoicnfy=INT(C:rsc_cookie%(L:CVL("ALIC")))       ! COOKIE-ABFRAGE Alice (Automatic-Iconify)
falcon=FALSE
IF nova<>0 THEN
  hardcursor=TRUE
ENDIF
IF mtype=2 THEN
  vme=&HFEFF0000
ELSE
  vme=&HDF0000
ENDIF
adr=vme+&H401
starint=adr+&H280
s$=lfw$
IF EXIST(s$+rsc$)=FALSE THEN
  IF EXIST("C:\"+rsc$)=TRUE THEN
    s$="C:\"
  ENDIF
ENDIF
IF XBIOS(xbs,1)<>&H71273800 THEN
  @treiberload
ENDIF
IF (XBIOS(103)=3 AND snd=&H1F AND mch=&H30000 AND vdo=&H30000 AND XBIOS(xbs,10)=0 AND milan=0) OR magicmac<>0 OR falconda=TRUE THEN
  falcon=TRUE
  demo=TRUE
ELSE
  IF XBIOS(xbs,10)=0 THEN
    demo=TRUE
  ENDIF
ENDIF
IF falcon=TRUE THEN
  ~XBIOS(&H84,1)
  ~XBIOS(&H85,0,0)
  ~XBIOS(&H86,0)
  ~XBIOS(&H89,1,1)
  ~XBIOS(&H82,4,2)
  ~XBIOS(&H82,5,0)
  ~XBIOS(&H8B,3,8+4,0,1,1)
ENDIF
IF demo=FALSE THEN
  IF XBIOS(xbs,1)=&H71273800 THEN
    IF demo=FALSE THEN
      dspadr=LPEEK(XBIOS(xbs,13)+12)  ! DSP-Startadresse
    ELSE
      dspadr=0
    ENDIF
    IF BTST(XBIOS(xbs,12),5)=TRUE THEN
      dspda=TRUE
    ELSE
      dspda=FALSE
    ENDIF
  ENDIF
ENDIF
IF EXIST(s$+rsc$)=TRUE AND EXIST(s$+rsc2$)=TRUE AND EXIST(s$+rsc3$)=TRUE THEN
  @setup
  IF away=FALSE THEN
    IF menuda=FALSE THEN
      mensa=-1
    ELSE
      mensa=dropdown&
    ENDIF
    m1=@xrsrc_load(1,s$+rsc$)
    IF m1<>0 THEN
      m2=@xrsrc_load(2,s$+rsc2$)
      IF m2=0 THEN
        ~@xrsrc_free(1)      ! beendet xrsrc-Routinen
      ELSE
        m3=@xrsrc_load(3,s$+rsc3$)
        IF m3=0 THEN
          ~@xrsrc_free(2)      ! beendet xrsrc-Routinen
          ~@xrsrc_free(1)      ! beendet xrsrc-Routinen
        ENDIF
      ENDIF
    ENDIF
    IF m1=0 OR m2=0 OR m3=0 THEN
      @alerts(3)
      END
    ELSE
      rscda=@rsc_change(btree,popups&,mensa,btree)  ! File$,Trees,Popup,Menu,Alert
      xload=rscda
    ENDIF
  ENDIF
ELSE
  rscda=FALSE
ENDIF
'
'
IF away=FALSE THEN
  IF rscda=TRUE THEN ! File$,Trees,Popup,Menu,Alert
    @setcopyright
    @testcopyright
    @language
    @calc_window(smpedit&)
    @calc_window(info&)
    @calc_window(smp16&)
    @calc_window(blkfunc&)
    @calc_window(peak&)
    @calc_window(arranger&)
    @calc_window(trakker&)
    @calc_window(loop&)
    @calc_window(dspedit&)
    @calc_window(editfade&)
    @calc_window(wmode&)
    @calc_window(cuelist&)
    @change_colors
    @initplugins
    @dsp_pluginit
    @smpedit
    IF accx=FALSE THEN
      END
    ELSE
      GOTO ende
    ENDIF
  ELSE
    @alerts(2)
    GEMSYS 109                                        ! Nur ab GEM 1.04!
    @goodbye
    IF accx=TRUE THEN
      GOTO ende
    ENDIF
  ENDIF
ELSE
  @alerts(3)
  IF accx=FALSE THEN
    END
  ELSE
    GOTO ende
  ENDIF
ENDIF
IF accx=FALSE THEN
  END
ELSE
  GOTO ende
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------PROZEDUREN--------------------------------------------
' ------------------------------------------------------------------------------
'                 HardwareabhÑngiger Teil - Adressenzuordnung
' ------------------------------------------------------------------------------
'
> PROCEDURE kickstart
  IF demo=FALSE THEN
    @fifodel
    '  ~XBIOS(xbs,62)            ! Kickstart
  ENDIF
RETURN
'
> PROCEDURE write_int(a)
  LOCAL b
  IF a<>0 THEN
    intactive=TRUE
    IF nr=peak& AND pkreq<>0 THEN
      LPOKE pkreq+2,0
    ENDIF
  ELSE
    intactive=FALSE
  ENDIF
  IF demo=FALSE THEN
    IF a>0 THEN
      intnr=a
    ENDIF
    IF falcon=FALSE THEN
      ~XBIOS(xbs,54,a)
      IF a=0 THEN
        ~XBIOS(xbs,55,0)
      ENDIF
    ELSE
      b=0
      IF a=1 OR a=3 THEN
        b=b+1
      ENDIF
      IF a=2 OR a=3 THEN
        b=b+4
      ENDIF
      ~XBIOS(&H88,b)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE digerrorcode
  .| Glob. Var.: demo#,rwert#,adr#
  .| Aufruf in : edhandler-2,
  IF demo=FALSE THEN
    rwert=XBIOS(xbs,42)
  ELSE
    rwert=7
  ENDIF
RETURN
'
> PROCEDURE digstatcode
  IF demo=FALSE THEN
    rwert=XBIOS(xbs,41)
  ELSE
    rwert=15
  ENDIF
RETURN
'
> PROCEDURE read_smp
  .| Glob. Var.: demo#,rwert#,adr#
  .| Aufruf in : peakwert-5,
  IF demo=FALSE THEN
    rwert=XBIOS(xbs,52)
  ENDIF
RETURN
'
> PROCEDURE write_smp(a)
  IF demo=FALSE THEN
    ~XBIOS(xbs,53,a)
  ENDIF
RETURN
'
> PROCEDURE read_digsrate
  IF demo=FALSE THEN
    rwert=XBIOS(xbs,40)
  ELSE
    rwert=0
  ENDIF
RETURN
'
> PROCEDURE dspreset
  IF demo=FALSE THEN
    ~XBIOS(xbs,61)
  ELSE
    IF falcon=TRUE AND magicmac=0 THEN
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE volwrite(l,r)
  .| Ruft auf  : volcs,waitchip,voldatai,volclk
  .| Aufruf in : setup-1,peak-1,do_peak-3,
  IF falcon=FALSE THEN
    IF demo=FALSE THEN
      ~XBIOS(xbs,50,l,r)
    ENDIF
  ELSE
    IF l<192 THEN
      l=192
    ENDIF
    IF r<192 THEN
      r=192
    ENDIF
    l=(l AND &H3F)
    l=INT(l/4)*16
    r=(r AND &H3F)
    r=INT(r/4)*16
    ~XBIOS(&H82,2,l)
    ~XBIOS(&H82,3,r)
  ENDIF
RETURN
'
> PROCEDURE volwrite2(l,r)
  .| Ruft auf  : volcs,waitchip,voldatai,volclk
  IF falcon=FALSE THEN
    IF demo=FALSE THEN
      ~XBIOS(xbs,51,l,r)
    ENDIF
  ELSE
    IF l>191 THEN
      l=191
    ENDIF
    IF r>191 THEN
      r=191
    ENDIF
    l=(l AND &HBF)
    l=INT(l/12)
    l=(15-l)*16
    r=(r AND &HBF)
    r=INT(r/12)
    r=(15-r)*16
    ~XBIOS(&H82,0,l)
    ~XBIOS(&H82,1,r)
  ENDIF
RETURN
'
> PROCEDURE dspoff
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : do_main-1,
  dspw=0
  IF demo=FALSE THEN
    ~XBIOS(xbs,22,0)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,dspoff&)
    @textfeld(dsp&,a$,1)
  ENDIF
  IF nr=dspedit& THEN
    a$=@rsc_text$(popups&,dspoff&)
    @textfeld(dspflip&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE dspin
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : do_main-1,
  dspw=1
  IF demo=FALSE THEN
    ~XBIOS(xbs,22,1)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,dspin&)
    @textfeld(dsp&,a$,1)
  ENDIF
  IF nr=dspedit& THEN
    a$=@rsc_text$(popups&,dspin&)
    @textfeld(dspflip&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE dspout
  .| Glob. Var.: std#
  .| Ruft auf  : write_dsp
  .| Aufruf in : do_main-1,
  dspw=2
  IF demo=FALSE THEN
    ~XBIOS(xbs,22,2)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,dspout&)
    @textfeld(dsp&,a$,1)
  ENDIF
  IF nr=dspedit& THEN
    a$=@rsc_text$(popups&,dspout&)
    @textfeld(dspflip&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE scmsfree
  scmsw=2
  IF demo=FALSE THEN
    ~XBIOS(xbs,32,2)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,scmsfree&)
    @textfeld(protect&,a$,1)
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE scmsone
  scmsw=1
  IF demo=FALSE THEN
    ~XBIOS(xbs,32,1)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,scmsone&)
    @textfeld(protect&,a$,1)
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE scmsno
  scmsw=0
  IF demo=FALSE THEN
    ~XBIOS(xbs,32,0)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,scmsno&)
    @textfeld(protect&,a$,1)
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE opto
  .| Glob. Var.: stl#,ad#,clk#,nr#,smp16&,a$,popups&,opto&,source&
  .| Ruft auf  : write_reglow,textfeld
  .| Aufruf in : do_main-1,
  digsource=0
  IF demo=FALSE THEN
    IF ad=0 OR digana=FALSE THEN
      ~XBIOS(xbs,21,0)   ! Optoeingang wÑhlen
      ~XBIOS(xbs,23,0)   ! Takt vom Digitaleingang
    ELSE
      ~XBIOS(xbs,21,0)   ! Optoeingang wÑhlen
      ~XBIOS(xbs,23,clk) ! Taktrate wÑhlen
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,opto&)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE coax
  .| Glob. Var.: stl#,ad#,clk#,nr#,smp16&,a$,popups&,coax&,source&
  .| Ruft auf  : write_reglow,textfeld
  .| Aufruf in : do_main-1,
  digsource=1
  IF demo=FALSE THEN
    IF ad=0 OR digana=FALSE THEN
      ~XBIOS(xbs,21,1)   ! Koaxeingang wÑhlen
      ~XBIOS(xbs,23,0)   ! Takt vom Digitaleingang
    ELSE
      ~XBIOS(xbs,21,1)   ! Koaxeingang wÑhlen
      ~XBIOS(xbs,23,clk) ! Taktrate wÑhlen
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,coax&)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE aesebu
  .| Glob. Var.: stl#,ad#,clk#,nr#,smp16&,a$,popups&,coax&,source&
  .| Ruft auf  : write_reglow,textfeld
  .| Aufruf in : do_main-1,
  digsource=2
  IF demo=FALSE THEN
    IF ad=0 OR digana=FALSE THEN
      ~XBIOS(xbs,21,2)   ! AESEBUeingang wÑhlen
      ~XBIOS(xbs,23,0)   ! Takt vom Digitaleingang
    ELSE
      ~XBIOS(xbs,21,2)   ! AESEBUeingang wÑhlen
      ~XBIOS(xbs,23,clk) ! Taktrate wÑhlen
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,aesebu&)
    @textfeld(source&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE emphoff
  '  @highsampling(FALSE)
  IF demo=FALSE THEN
    ~XBIOS(xbs,33,0)
  ENDIF
  empha=FALSE
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,emphoff&)
    @textfeld(emphasis&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE emphon
  '  @highsampling(TRUE)
  IF demo=FALSE THEN
    ~XBIOS(xbs,33,1)
  ENDIF
  empha=TRUE
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,emphon&)
    @textfeld(emphasis&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE consumer
  IF demo=FALSE THEN
    ~XBIOS(xbs,30,0)
  ENDIF
  proffm=FALSE
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,consumer&)
    @textfeld(mode&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE profess
  proffm=TRUE
  IF demo=FALSE THEN
    ~XBIOS(xbs,30,1)
  ENDIF
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,profess&)
    @textfeld(mode&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE fifodel
  .| Glob. Var.: sth#
  .| Ruft auf  : write_reghigh
  .| Aufruf in : maschruf4-1,peak-1,peakread-1,smpauto-1,smpstart-1,
  IF demo=FALSE THEN
    ~XBIOS(xbs,60) ! Reset REC-Fifo
  ENDIF
RETURN
'
> PROCEDURE digibridge
  IF bridge=FALSE THEN
    bridge=TRUE
    IF demo=FALSE THEN
      ~XBIOS(xbs,31,1)
    ENDIF
    IF nr=smp16& THEN
      setbutton(bridge&,1)
    ENDIF
  ELSE
    bridge=FALSE
    IF demo=FALSE THEN
      ~XBIOS(xbs,31,0)
    ENDIF
    IF nr=smp16& THEN
      setbutton(bridge&,0)
    ENDIF
  ENDIF
  IF ad=0 THEN
    @digital
  ENDIF
RETURN
'
> PROCEDURE digin
  .| Glob. Var.: sth#
  .| Ruft auf  : write_reghigh
  .| Aufruf in : digout-1,arrmidplay-2,smpplay-2,smppmhlp-2,
  IF demo=FALSE THEN
    ~XBIOS(xbs,25,0) ! Switch to Bypass-Output
  ENDIF
RETURN
'
> PROCEDURE digout(swert!)
  .| Glob. Var.: sth#,extclock#,digana#,ad#,stl#,clk#
  .| Ruft auf  : write_reghigh,write_reglow,digital,digin,analog
  .| Aufruf in : maschruf2-1,maschinit2b-1,maschinit5b-1,maschruf18-1
  .|     maschruf18b-1,newfsel-4,arrsethz-1,traksethz-1,trakforw-4,trkbackw-4
  .|     trkplay-3,arrplay-3,virtual-2,mforw-4,mbackw-4,monitor-2,smpplay-2
  .|     smpauto-1,record-1,
  bypmode=swert!
  IF swert!=TRUE THEN
    IF demo=FALSE THEN
      ~XBIOS(xbs,25,1) ! Switch to PLAY-Output
    ENDIF
    IF digana=TRUE AND ad=1 THEN
      IF demo=FALSE THEN
        ~XBIOS(xbs,20,1)   ! Analogeingang benutzen
        ~XBIOS(xbs,23,clk) ! Taktrate wÑhlen
      ENDIF
    ENDIF
    IF digana=TRUE AND ad=0 THEN
      @digital
    ENDIF
  ENDIF
  IF swert!=FALSE THEN
    IF dspuse=TRUE THEN
      @dspbypass
    ENDIF
    @digin
    IF ad=1 THEN
      @analog
    ELSE
      @digital
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE highsampling(state)
  hsbit=state
  IF demo=FALSE THEN
    IF state=TRUE THEN
      ~XBIOS(xbs,24,1)
    ELSE
      ~XBIOS(xbs,24,0)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE proffhz                      ! Hier muû nachgearbeitet werden !   HZ !!
  IF demo=FALSE THEN
    IF ext=0 THEN
      IF hz=32000 THEN
        ~XBIOS(xbs,23,1)
      ENDIF
      IF hz=44100 THEN
        ~XBIOS(xbs,23,2)
      ENDIF
      IF hz=48000 THEN
        ~XBIOS(xbs,23,3)
      ENDIF
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE adlow
  hz=32000
  ext=0
  clk=1
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE admid
  hz=44100
  ext=0
  clk=2
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE adhigh
  hz=48000
  ext=0
  clk=3
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE admid96
  hz=88200
  ext=0
  clk=2
  mod96=TRUE
  @adctrl
RETURN
'
> PROCEDURE adhigh96
  hz=96000
  ext=0
  clk=3
  mod96=TRUE
  @adctrl
RETURN
'
> PROCEDURE ad8
  hz=8000
  ext=0
  clk=4
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad11
  hz=11025
  ext=0
  clk=5
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad12
  hz=12000
  ext=0
  clk=6
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad16
  hz=16000
  ext=0
  clk=7
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad17
  hz=16538
  ext=0
  clk=8
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad22
  hz=22050
  ext=0
  clk=9
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad24
  hz=24000
  ext=0
  clk=10
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE ad33
  hz=33075
  ext=0
  clk=11
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE adexth2
  hz=INT(masterclk/768)
  ext=768
  clk=12
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE adextl2
  hz=INT(masterclk/512)
  ext=512
  clk=13
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE adexth1
  hz=INT(masterclk/384)
  ext=384
  clk=14
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE adextl1
  hz=INT(masterclk/256)
  ext=256
  clk=15
  mod96=FALSE
  @adctrl
RETURN
'
> PROCEDURE addiv
  LOCAL a1
  IF fmclk=FALSE THEN
    clkmode=2
  ELSE
    clkmode=3
  ENDIF
  ~GRAF_MKSTATE(v,v2,v3,v4)        ! NEU !!!
  IF v4<>0 OR cdivsms=-1 THEN
    firstclk=FALSE
    IF cdivsms=-1 THEN
      cdivsms=1
    ENDIF
    mrkobj=obj
    vorvornr=vornr
    vornr=nr
    nr=clocks&
    vshading=shading
    shading=TRUE
    dopix=TRUE
    IF clkmode=1 THEN
      cdivz=60
    ENDIF
    IF clkmode=2 THEN
      cdivz=38
    ENDIF
    IF clkmode=3 THEN
      cdivz=14
    ENDIF
    IF cdivz<cdivsms THEN
      cdivsms=cdivz
    ENDIF
    @slideinit(clkslid&,clkbut&,cdivz,5,vcdivsms)
    vcdivsms=cdivsms-1
    @setslide(clkslid&,clkbut&,cdivz,5,vcdivsms)
    a$=STR$(masterclk)
    IF LEN(a$)>6 THEN
      a$=LEFT$(a$,LEN(a$)-6)+"."+RIGHT$(a$,6)
    ENDIF
    a$=a$+" MHz"+CHR$(0)
    @textfeld(clockm&,a$,1)
    j=0
    FOR i=1 TO 60 STEP 4
      INC j
      clkdiv(i,1)=INT(masterclk/256/j)
      clkdiv(i+1,1)=INT(masterclk/384/j)
      clkdiv(i+2,1)=INT(masterclk/512/j)
      clkdiv(i+3,1)=INT(masterclk/768/j)
    NEXT i
    @clocklook(cdivsms)
    dopix=FALSE
    shading=vshading
    @rsc_draw(nr,0)
    @markhlp
    REPEAT
      REPEAT
        REPEAT
          obj=@rsc_do(nr,0,popup&)
          ~@xrsrc_gaddr(0,nr,zu%)
          zuadr=zu%
          @mouse(x,y,v3)
        UNTIL obj<>0 AND obj<>-1
        buttadr=zuadr+24*obj
        but=DPEEK(buttadr+6) AND 255
      UNTIL but<>0
      '
      IF obj=clockhlp& THEN
      ENDIF
      IF obj=clkup& THEN
        @slideup(clkslid&,clkbut&,cdivz,1,5,vcdivsms,slflg)
        IF slflg=TRUE THEN
          @clocklook(vcdivsms+1)
        ENDIF
        @setbutton(clkup&,0)
      ENDIF
      IF obj=clkdown& THEN
        @slidedwn(clkslid&,clkbut&,cdivz,1,5,vcdivsms,slflg)
        IF slflg=TRUE THEN
          @clocklook(vcdivsms+1)
        ENDIF
        @setbutton(clkdown&,0)
      ENDIF
    UNTIL obj=clockex& OR obj=clockok& OR obj=clock3&
    @setbutton(obj,0)
    IF obj=clock3& AND maxcol=2 THEN
      PAUSE 5
      @setbutton(obj,1)
      PAUSE 5
      @setbutton(obj,0)
      PAUSE 5
      @setbutton(obj,1)
      PAUSE 5
      @setbutton(obj,0)
    ENDIF
    @restaura2
    IF obj=clockok& OR obj=clock3& THEN
      clkdfind=TRUE
      cdivsms=vcdivsms+1
      @addiv3
      @addiv2
      firstclk=TRUE
    ELSE
      clkdfind=FALSE
      IF firstclk=FALSE THEN
        cdivsms=-1
      ENDIF
      IF vornr<>resample& THEN
        @fliphz
      ENDIF
    ENDIF
    obj=mrkobj
    vornr=vorvornr
  ELSE
    @addiv2
  ENDIF
RETURN
'
> PROCEDURE addiv2
  LOCAL a1
  IF clkmode=1 THEN
    a1=cdivsms
  ENDIF
  IF clkmode=2 THEN
    a1=clkdiv(cdivsms,2)
  ENDIF
  IF clkmode=3 THEN
    a1=clkdiv(cdivsms,3)
  ENDIF
  IF nr=resample& OR vornr=resample& THEN
    resoth=INT(clkdiv(a1,1)/100)/10
  ELSE
    hz=INT(clkdiv(a1,1))
    ext=a1
    clk=16
    mod96=FALSE
    @adctrl
  ENDIF
RETURN
'
> PROCEDURE addiv3
  LOCAL a1
  IF clkmode=1 THEN
    a1=cdivsms
  ENDIF
  IF clkmode=2 THEN
    a1=clkdiv(cdivsms,2)
  ENDIF
  IF clkmode=3 THEN
    a1=clkdiv(cdivsms,3)
  ENDIF
  IF vornr=resample& THEN
    resoth=INT(clkdiv(a1,1))
    ndiv$=" DIV     "
    b1$=STR$(INT(resoth/100)/10)
    resoth=INT(resoth/100)/10
  ELSE
    hz=INT(clkdiv(a1,1))
    ndiv$=" DIV     "
    b1$=STR$(INT(hz/100)/10)
  ENDIF
  IF INSTR(b1$,".")=0 THEN
    b1$=b1$+".0"
  ENDIF
  IF LEN(b1$)<4 THEN
    b1$=" "+b1$
  ENDIF
  @stringfeld(popups&,addiv&,b1$+CHR$(0),6)
  @stringfeld(popups&,ratediv&,b1$+" kHz"+CHR$(0),6)
RETURN
'
> PROCEDURE clocklook(clook)
  LOCAL a,a$,a1,a2,a3,a4,a5
  IF clkmode=1 THEN
    a1=clook-2
    a2=clook-1
    a3=clook
    a4=clook+1
    a5=clook+2
  ENDIF
  IF clkmode=2 THEN
    IF (clook-2)>0 THEN
      a1=clkdiv(clook-2,2)
    ENDIF
    IF (clook-1)>0 THEN
      a2=clkdiv(clook-1,2)
    ENDIF
    a3=clkdiv(clook,2)
    IF (clook+1)<=cdivz THEN
      a4=clkdiv(clook+1,2)
    ENDIF
    IF (clook+2)<=cdivz THEN
      a5=clkdiv(clook+2,2)
    ENDIF
  ENDIF
  IF clkmode=3 THEN
    IF (clook-2)>0 THEN
      a1=clkdiv(clook-2,3)
    ENDIF
    IF (clook-1)>0 THEN
      a2=clkdiv(clook-1,3)
    ENDIF
    a3=clkdiv(clook,3)
    IF (clook+1)<=cdivz THEN
      a4=clkdiv(clook+1,3)
    ENDIF
    IF (clook+2)<=cdivz THEN
      a5=clkdiv(clook+2,3)
    ENDIF
  ENDIF
  IF clook<3 THEN
    a$=""
  ELSE
    a$=STR$(clkdiv(a1,1))+" Hz"
  ENDIF
  IF LEN(a$)<9 THEN
    a$=RIGHT$(SPACE$(9)+a$,9)
  ENDIF
  a$=a$+CHR$(0)
  @textfeld(clock1&,a$,1)
  IF clook<2 THEN
    a$=""
  ELSE
    a$=STR$(clkdiv(a2,1))+" Hz"
  ENDIF
  IF LEN(a$)<9 THEN
    a$=RIGHT$(SPACE$(9)+a$,9)
  ENDIF
  a$=a$+CHR$(0)
  @textfeld(clock2&,a$,1)
  a$=STR$(clkdiv(a3,1))+" Hz"
  IF LEN(a$)<9 THEN
    a$=RIGHT$(SPACE$(9)+a$,9)
  ENDIF
  a$=a$+CHR$(0)
  @textfeld(clock3&,a$,1)
  IF clook=cdivz THEN
    a$=""
  ELSE
    a$=STR$(clkdiv(a4,1))+" Hz"
  ENDIF
  IF LEN(a$)<9 THEN
    a$=RIGHT$(SPACE$(9)+a$,9)
  ENDIF
  a$=a$+CHR$(0)
  @textfeld(clock4&,a$,1)
  IF clook>(cdivz-2) THEN
    a$=""
  ELSE
    a$=STR$(clkdiv(a5,1))+" Hz"
  ENDIF
  IF LEN(a$)<9 THEN
    a$=RIGHT$(SPACE$(9)+a$,9)
  ENDIF
  a$=a$+CHR$(0)
  @textfeld(clock5&,a$,1)
RETURN
'
> PROCEDURE analog
  .| Glob. Var.: extclock#,stl#,digana#,clk#,ad#,nr#,smp16&,a$,popups&,analog&
  .|     input&
  .| Ruft auf  : write_reglow,textfeld,makehz
  .| Aufruf in : digout-1,adlow-1,admid-1,adhigh-1,do_main-1,arrsethz-1
  .|     traksethz-1,trkplay-1,arrmidplay-1,arrplay-1,setup2-1,smpplay-2
  .|     smppmhlp-1,
  LOCAL cdiv
  IF demo=FALSE THEN
    IF digana=TRUE THEN
      ~XBIOS(xbs,20,1)   ! Analogeingang benutzen
      ~XBIOS(xbs,23,clk) ! Taktrate wÑhlen
      '
      IF dspda=TRUE THEN
        IF ext=0 OR ext=256 OR ext=384 OR ext=512 OR ext=768 OR adat=TRUE THEN
          ~XBIOS(xbs,71,0)
        ELSE
          cdiv=INT((ext-1)/4)
          IF cdiv>0 THEN
            cdiv=cdiv+1
          ENDIF
          ~XBIOS(xbs,71,cdiv)
          cdiv2=16-(ext-INT((ext-1)/4)*4)
          ~XBIOS(xbs,23,cdiv2) ! Taktrate wÑhlen
        ENDIF
      ENDIF
      '
    ELSE
      ~XBIOS(xbs,20,1)   ! Analogeingang benutzen
      ~XBIOS(xbs,23,0)   ! Taktrate vom digitaleingang
    ENDIF
  ENDIF
  ad=1
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,analog&)
    @textfeld(input&,a$,1)
  ENDIF
  @makehz
  IF digana=FALSE THEN
    '    @digital
  ELSE
    '    @digout(TRUE)
  ENDIF
RETURN
'
> PROCEDURE digital
  .| Glob. Var.: extclock#,stl#,ad#,nr#,smp16&,a$,popups&,digital&,input&
  .| Ruft auf  : write_reglow,textfeld,makehz
  .| Aufruf in : digout-2,do_main-1,trkplay-1,arrmidplay-1,arrplay-1
  .|     smpplay-2,smppmhlp-1,
  IF demo=FALSE THEN
    ~XBIOS(xbs,20,0)   ! Digitaleingang benutzen
    ~XBIOS(xbs,23,0)   ! Taktrate vom digitaleingang
  ENDIF
  ad=0
  IF nr=smp16& THEN
    a$=@rsc_text$(popups&,digital&)
    @textfeld(input&,a$,1)
  ENDIF
  @makehz
RETURN
'
' ------------------------------------------------------------------------------
'          HardwareabhÑngiger Teil - Datenzugriff Register Write/Read
' ------------------------------------------------------------------------------
'
> PROCEDURE balwrite(volume,balance,balmax)
  LOCAL i,anfwert
  lbal=volume
  rbal=volume
  anfwert=4 ! maximal bis 9
  dev=anfwert/balmax
  IF balance>0 THEN
    lbal=INT(volume*LOG10(10-dev*balance))
  ENDIF
  IF balance<0 THEN
    rbal=INT(volume*LOG10(10-dev*ABS(balance)))
  ENDIF
  @volwrite(lbal,rbal)
RETURN
'
> PROCEDURE balwrite2(volume,balance,balmax)
  LOCAL i,anfwert
  lbal=volume
  rbal=volume
  anfwert=4 ! maximal bis 9
  dev=anfwert/balmax
  IF balance>0 THEN
    lbal=INT(volume*LOG10(10-dev*balance))
  ENDIF
  IF balance<0 THEN
    rbal=INT(volume*LOG10(10-dev*ABS(balance)))
  ENDIF
  @volwrite2(lbal,rbal)
RETURN
'
> PROCEDURE adctrl
  IF ad=0 THEN
    @digital
  ELSE
    @analog
  ENDIF
  @makehz
RETURN
'
> PROCEDURE makehz
  .| Glob. Var.: digana#,extclock#,clk#,hz#,hzc#,rwert#,ohz#,retime#,hzm#
  .| Ruft auf  : fliphz,read_statlow
  .| Aufruf in : adlow-1,admid-1,adhigh-1,ext32l-1,ext44l-1,ext48l-1,ext32h-1
  .|     ext44h-1,ext48h-1,ext256-1,ext384-1,analog-1,digital-1,smpsave-1
  .|     ldhlp-2,infrett-1,smpinfbutt-1,ldhead-1,resample-1,arranger-1
  .|     trakker-1,trkplay-1,arrplay-1,smpedit-1,time_edit-1,make-1,trash-1
  .|     setupdat-1,setup2-1,conspace-1,
  IF retime=1 THEN
    hz=hzm
  ENDIF
  IF digana=TRUE AND retime=0 THEN
    @fliphz
  ENDIF
  IF digana=FALSE THEN
    @read_digsrate
    hzc=rwert
    ohz=hz
    IF hzc=1 THEN
      hz=32000
    ENDIF
    IF hzc=2 THEN
      hz=44100
    ENDIF
    IF hzc=3 THEN
      hz=48000
    ENDIF
    IF digana=FALSE AND ohz<>hz THEN
      @fliphz
    ENDIF
  ENDIF
  IF hz<>256 AND hz<>384 AND hz<>512 AND hz<>768 THEN
    hz=@hzanalye(hz)
  ENDIF
  IF hz=0 THEN
    hz=44100
  ENDIF
RETURN
'
> PROCEDURE makehz2
  .| Glob. Var.: ad#,digana#,extclock#,clk#,hz#,hzc#,rwert#,ohz#,retime#,hzm#
  .| Ruft auf  : fliphz,read_statlow
  .| Aufruf in : smpauto-1,smpstart-1,
  IF retime=1 THEN
    hz=hzm
  ENDIF
  IF (ad=1 AND digana=TRUE AND retime=0) THEN
    @fliphz
  ENDIF
  IF ad=0 OR digana=FALSE THEN
    @read_digsrate
    hzc=rwert
    ohz=hz
    IF hzc=1 THEN
      hz=32000
    ENDIF
    IF hzc=2 THEN
      hz=44100
    ENDIF
    IF hzc=3 THEN
      hz=48000
    ENDIF
    IF digana=FALSE AND ohz<>hz THEN
      @fliphz
    ENDIF
  ENDIF
  IF hz<>256 AND hz<>384 AND hz<>512 AND hz<>768 THEN
    hz=@hzanalye(hz)
  ENDIF
RETURN
'
> PROCEDURE makehz3
  IF ad=0 THEN
    hzc=rwert
    ohz=hz
    IF hzc=1 THEN
      hz=32000
    ENDIF
    IF hzc=2 THEN
      hz=44100
    ENDIF
    IF hzc=3 THEN
      hz=48000
    ENDIF
    @fliphz
  ENDIF
  IF hz<>256 AND hz<>384 AND hz<>512 AND hz<>768 THEN
    hz=@hzanalye(hz)
  ENDIF
  IF hz=0 THEN
    hz=44100
  ENDIF
RETURN
'
> PROCEDURE fliphz
  .| Glob. Var.: nr#,smpedit&,extclock#,hz#,a$,popups&,rate32&,rate&,rate44&
  .|     rate48&,ext#,ext32l&,ext44l&,ext48l&,ext32h&,ext44h&,ext48h&
  .|     rateextl&,rateexth&,smp16&,ad32&,rate2&,ad44&,ad48&,adext32l&
  .|     adext44l&,adext48l&,adext32h&,adext44h&,adext48h&,adextl&,adexth&
  .| Ruft auf  : textfeld
  .| Aufruf in : makehz-2,makehz2-2,sethertz-1,rebuild-1,
  IF nr=smpedit& THEN
    IF edhz<>hz AND nofliphz=FALSE AND dopix=FALSE AND shading=FALSE AND bigfoot=TRUE THEN
      edhz=hz
      @edmarkdel
      tlupd=TRUE
    ENDIF
    IF ohz<>hz AND nofliphz=FALSE THEN
      @hztext
    ENDIF
    IF hz=32000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate32&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=44100 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate44&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=48000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate48&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=88200 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate88&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=96000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate96&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=8000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate8&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=11025 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate11&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=12000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate12&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=16000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate16&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=16538 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate17&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=22050 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate22&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=24000 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate24&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF hz=33075 AND ext=0 THEN
      a$=@rsc_text$(popups&,rate33&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext=768 THEN
      a$=@rsc_text$(popups&,ratexth2&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext=512 THEN
      a$=@rsc_text$(popups&,ratextl2&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext=384 THEN
      a$=@rsc_text$(popups&,ratexth1&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext=256 THEN
      a$=@rsc_text$(popups&,ratextl1&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF ext>0 AND ext<>256 AND ext<>384 AND ext<>512 AND ext<>768 THEN
      a$=@rsc_text$(popups&,ratediv&)
      @textfeld(rate&,a$,1)
    ENDIF
    IF tlupd=TRUE AND nofliphz=FALSE AND dopix=FALSE AND shading=FALSE AND bigfoot=TRUE THEN
      @windowtest
      IF mywindow=TRUE THEN
        tlupd=FALSE
        @restaura
      ENDIF
    ENDIF
  ENDIF
  IF nr=smp16& THEN
    IF hz=32000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad32&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=44100 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad44&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=48000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad48&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=88200 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad88&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=96000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad96&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=8000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad8&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=11025 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad11&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=12000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad12&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=16000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad16&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=16538 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad17&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=22050 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad22&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=24000 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad24&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF hz=33075 AND ext=0 THEN
      a$=@rsc_text$(popups&,ad33&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF ext=768 THEN
      a$=@rsc_text$(popups&,adexth2&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF ext=512 THEN
      a$=@rsc_text$(popups&,adextl2&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF ext=384 THEN
      a$=@rsc_text$(popups&,adexth1&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF ext=256 THEN
      a$=@rsc_text$(popups&,adextl1&)
      @textfeld(rate2&,a$,1)
    ENDIF
    IF ext>0 AND ext<>256 AND ext<>384 AND ext<>512 AND ext<>768 THEN
      a$=@rsc_text$(popups&,addiv&)
      @textfeld(rate2&,a$,1)
    ENDIF
  ENDIF
  IF digana=TRUE THEN
    IF ad=1 AND ext=0 THEN ! neu seit XBIOS-Umstrukturierung
      @proffhz
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE fliphz2
  IF digana=TRUE THEN
    IF hz=32000 AND ext=0 THEN
      @adlow
    ENDIF
    IF hz=44100 AND ext=0 THEN
      @admid
    ENDIF
    IF hz=48000 AND ext=0 THEN
      @adhigh
    ENDIF
    IF hz=88200 AND ext=0 THEN
      @admid96
    ENDIF
    IF hz=96000 AND ext=0 THEN
      @adhigh96
    ENDIF
    IF hz=8000 AND ext=0 THEN
      @ad8
    ENDIF
    IF hz=11025 AND ext=0 THEN
      @ad11
    ENDIF
    IF hz=12000 AND ext=0 THEN
      @ad12
    ENDIF
    IF hz=16000 AND ext=0 THEN
      @ad16
    ENDIF
    IF hz=16538 AND ext=0 THEN
      @ad17
    ENDIF
    IF hz=22050 AND ext=0 THEN
      @ad22
    ENDIF
    IF hz=24000 AND ext=0 THEN
      @ad24
    ENDIF
    IF hz=33075 AND ext=0 THEN
      @ad33
    ENDIF
    IF ext=768 THEN
      @adexth2
    ENDIF
    IF ext=512 THEN
      @adextl2
    ENDIF
    IF ext=384 THEN
      @adexth1
    ENDIF
    IF ext=256 THEN
      @adextl1
    ENDIF
    IF ext>0 AND ext<>256 AND ext<>384 AND ext<>512 AND ext<>768 THEN
      @addiv2
    ENDIF
    IF ad=1 THEN  ! neu seit XBIOS-Umstrukturierung
      @proffhz
    ENDIF
  ENDIF
RETURN
'
'
' ------------------------------------------------------------------------------
' ------------------------ASSEMBLER-ROUTINEN------------------------------------
' ------------------------------------------------------------------------------
'
> PROCEDURE maschruf2_midi
  .| Glob. Var.: sca%,adder#,sda%,l#,sfa%,midiwort#,wback%,back%,demo#,a#,saa%
  .|     sba%,sea%,sga%,sha%,back2%,mdat2%,sia%
  .| Aufruf in : maschruf18-1,maschruf18b-1,trkplay-1,arrplay-1,
  ' PLAY (fÅr Midiplay) - jedesmal aufrufen
  LOCAL bw
  IF demo=FALSE THEN
    @digout(TRUE)
  ENDIF
  back%=-1
  sca%=adder
  sda%=l+4
  sfa%=midiwort
  LPOKE wback%,0
  LPOKE wback%+4,0
  back%=-1
  IF demo=FALSE THEN
    IF XBIOS(xbs,1)=&H71273800 THEN
      bw=XBIOS(xbs,122,0,L:saa%,L:sba%,L:0,sca%,sda%,sfa%)
      @write_int(1)
      REPEAT
        back3%=LPEEK(bw+8)
      UNTIL back3%=1
      @write_int(0)
    ENDIF
  ELSE
    back%=0
    back2%=0
  ENDIF
RETURN
'
> PROCEDURE copyarrtomem
  LOCAL m1,m2,m,i,a$,h,pos,a1,a2,a3
  arrmem=0
  arrsize=0
  IF gemvers>=&H1900 THEN
    m1=@mxalloc(-1,1)  ! TT-RAM
    m2=@mxalloc(-1,0)  ! ST-RAM
  ELSE
    m1=MALLOC(-1)      ! ST-RAM
    m2=0
  ENDIF
  IF m1>m2 THEN
    arrsize=m1          ! grîûter freier Block
  ELSE
    arrsize=m2          ! grîûter freier Block
  ENDIF
  IF arrsize>0 THEN
    lastarr=0
    arrgetsize=0
    FOR i=1 TO lmax2
      IF arrpath$(i)<>"" THEN
        arrgetsize=arrgetsize+(arrend%(i)-arrstrt%(i))
      ENDIF
      IF arrgetsize<=arrsize THEN
        lastarr=i
      ELSE
        IF lastarr=0 THEN
          @alerts(67)
          arrleave=TRUE
        ELSE
          @alerts(66)
          arrleave=TRUE
        ENDIF
      ENDIF
      EXIT IF arrleave=TRUE
    NEXT i
    IF arrleave=TRUE AND lastarr>0 THEN
      IF g=1 THEN
        arrleave=FALSE
      ENDIF
    ENDIF
    IF arrleave=FALSE THEN
      IF arrsize>arrgetsize THEN
        arrsize=arrgetsize
      ENDIF
      IF arrsize>0 THEN
        arrmem=@malloc(arrsize,0)
        FOR i=1 TO lmax2
          arrpath%(i)=VARPTR(arrpath$(i))
        NEXT i
        arrmaxpos=0
        FOR i=1 TO lastarr
          @busy_mouse
          IF arrpath$(i)<>"" THEN
            arrl=arrend%(i)-arrstrt%(i)
            IF (arrl+arrmaxpos)<=arrsize THEN
              a$=arrpath$(i)+CHR$(0)
              handle=GEMDOS(61,L:VARPTR(a$),0)     ! open
              head=20
              h=head+arrstrt%(i)
              a1=GEMDOS(66,L:h,handle,0)           ! seek
              pos=arrmem+arrmaxpos
              a2=GEMDOS(63,handle,L:arrl,L:pos)    ! read
              a3=GEMDOS(62,handle)                 ! close
              arrmems%(i)=pos
              arrmeml%(i)=arrl
              arrmaxpos=arrmaxpos+arrl
            ENDIF
          ENDIF
          @busy_mouse
        NEXT i
      ENDIF
    ENDIF
  ELSE
    @alerts(3)
    arrleave=TRUE
  ENDIF
RETURN
'
> PROCEDURE killarrmem
  IF arrmem>0 THEN
    ~MFREE(arrmem)
    arrmem=0
  ENDIF
RETURN
'
> PROCEDURE maschruf18b
  .| Glob. Var.: lmax2#,n#,midiwort#,raus#,x#,y#,v#,v2#,v3#,v4#,xx#,xx2#,xx3#
  .|     ch#,note#,z#,vch#,vnote#,l#,saa%,meml#,sba%,adder#,yy#,demo#,vhz#,pa$
  .|     sectors#,handle#,playpos#,flen#,over#
  .| Felder    : midi#(),arrmidi#(),arrpath$(),arrloop#(),arrtri#(),arrstrt#()
  .|     arrend#(),arrsrate#()
  .| Ruft auf  : busy_mouse,digout,maschinit2b,maschinit5b,swtosrate
  .|     maschruf2c,maschruf5c,maschinit2d
  .| Aufruf in : arrmidplay-2,
  LOCAL i,j,m,p,b$,bw
  ' ARR-MIDIPLAY,ARR-MIDICROSSPLAY,ARR-MIDIBACKPLAY
  '
  @busy_mouse
  ~XBIOS(xbs,166,1) !  Midikey-Protokoll an
  ' a - sourceanf
  ' b - sourceende
  ' l - LÑnge
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  @digout(TRUE)
  '
  arrleave=FALSE
  @copyarrtomem
  '
  '
  IF lastarr>0 AND arrleave=FALSE AND arrsize>0 THEN
    FOR j=0 TO 15
      FOR i=0 TO 127
        midi&(j,i)=-1
      NEXT i
    NEXT j
    FOR i=1 TO lastarr
      IF arrpath$(i)<>"" THEN
        m=(arrmidi&(i) AND 255)
        n=INT(arrmidi&(i)/256)
        IF m>=0 AND m<128 AND n>=0 AND n<16 THEN
          midi&(n,m)=i
        ENDIF
      ENDIF
    NEXT i
    '
    vdig24=dig24
    omspos=-1
    @maus_note
    IF demo=FALSE THEN
      IF XBIOS(xbs,1)=&H71273800 THEN
        bw=XBIOS(xbs,168,lmax2,L:VARPTR(midi&(0,0)),L:VARPTR(arrpath%(0)),L:VARPTR(arrmems%(0)),L:VARPTR(arrmeml%(0)),L:VARPTR(arrsrate%(0)),L:VARPTR(arrloop!(0)),L:VARPTR(arrtri|(0)))
      ENDIF
    ELSE
      back%=0
    ENDIF
    '
    '
    '    CLS
    '
    '    PRINT "midicount:",PEEK(bw)
    '    PRINT "midioncount:",PEEK(bw+1)
    '    PRINT "midioffcount:",PEEK(bw+2)
    '    PRINT "vmidioncount:",PEEK(bw+3)
    '    PRINT "vmidioffcount:",PEEK(bw+4)
    '
    '
    '
    '
    '
    dig24=vdig24
    IF dig24=FALSE THEN
      @setbitrate16
    ELSE
      @setbitrate24
    ENDIF
  ENDIF
  '
  ~XBIOS(xbs,166,0) !  Midikey-Protokoll aus
  '
  @killarrmem
  '
RETURN
'
> PROCEDURE maschruf18
  .| Glob. Var.: saa%,a#,sba%,b#,sret#,adder#,l#,sloop#,raus#,x#,y#,v#,v2#,v3#
  .|     v4#,xx#,ch#,xx2#,note#,xx3#,yy#,demo#
  .| Ruft auf  : digout,maschinit2b,maschruf2c,maschinit2d
  .| Aufruf in : smpplay-2,smppmhlp-2,
  ' MIDI-PLAY,MIDI-BACKPLAY,MIDI-CROSSPLAY
  '
  ' a - sourceanf
  ' b - sourceende
  ' l - LÑnge
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  ~XBIOS(xbs,166,1) !  Midikey-Protokoll an
  @digout(TRUE)
  @maus_note
  saa%=a
  sba%=b
  adder=0
  REPEAT
    IF sret=2 THEN
      l=2
    ELSE
      l=0
    ENDIF
    IF sloop!=TRUE THEN
      l=l+1
    ENDIF
    raus=FALSE
    REPEAT
      x=INP?(3)
      y=INP?(2)
      ~GRAF_MKSTATE(v,v2,v3,v4)
      IF x=TRUE AND v3<>2 THEN
        xx=INP(3)
        IF xx=&H90+(ch-1) THEN
          REPEAT
            x=INP?(3)
            y=INP?(2)
            ~GRAF_MKSTATE(v,v2,v3,v4)
          UNTIL x=TRUE OR y=TRUE OR v3=2
          IF y=FALSE AND x=TRUE AND v3<>2 THEN
            xx2=INP(3)
            IF xx2=note AND v3<>2 THEN
              REPEAT
                x=INP?(3)
                y=INP?(2)
                ~GRAF_MKSTATE(v,v2,v3,v4)
              UNTIL x=TRUE OR y=TRUE OR v3=2
              IF y=FALSE AND x=TRUE AND v3<>2 THEN
                xx3=INP(3)
                IF xx=&H90+(ch-1) AND xx2=note AND xx3<>0 THEN
                  raus=TRUE
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      IF y=TRUE AND v3<>2 THEN
        yy=INP(2)
      ENDIF
      ~GRAF_MKSTATE(v,v2,v3,v4)
    UNTIL y=TRUE OR raus=TRUE OR v3=2
    IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
      @maschruf2_midi
    ENDIF
    ~GRAF_MKSTATE(v,v2,v3,v4)
  UNTIL v3=2 OR y=TRUE OR INP?(2)=TRUE
  ~XBIOS(xbs,166,0) !  Midikey-Protokoll aus
RETURN
'
> PROCEDURE maschruf5c
  .| Aufruf in : maschruf18b
  LOCAL p,b$,bw
  ' MIDI HD-PLAY
  '
  vdig24=dig24
  omspos=-1
  IF demo=FALSE THEN
    IF over<0 THEN
      sad%=mdat%+flen-mbit
    ENDIF
    scd%=handle
    sdd%=playpos            !playposition
    IF sectors<=1 THEN
      sectors=2
    ENDIF
    sed%=INT(sectors/mbit/playfifolen)            !sectors
    sfd%=over
    '
    sgd%=l+8
    '
    sid%=midiwort
    sfa%=fileart
    IF XBIOS(xbs,1)=&H71273800 THEN
      bw=XBIOS(xbs,125,L:sad%,L:sbd%,L:sed%,L:sdd%,scd%,sfa%,sfd%,sgd%,sid%)
      PAUSE 5
      IF pwait=FALSE THEN
        @write_int(1)
      ELSE
        intnr=1
        @pausewait
      ENDIF
      intplay=TRUE
      t=TIMER
      fxlen=flen/2
      b2=mbit*INT(playpos/mbit)
      IF nr=smpedit& AND virtual=TRUE AND sret=0 AND sloop!=FALSE THEN
        @intzeiger1(b2)
      ENDIF
      IF nr=smpedit& THEN
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      REPEAT
      UNTIL @mousek=0
      wleer=0
      REPEAT
        back%=LPEEK(bw+4)
        back2%=LPEEK(bw+28)
        back3%=LPEEK(bw+8)
        wleer2=LPEEK(bw+12)
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          IF nr=smpedit& THEN
            IF bigfoot=TRUE THEN
              IF flicker=TRUE THEN
                VSYNC
              ENDIF
              @textfeld(editime&,a$,1)
            ELSE
              @textfeld(smpsec&,a$,1)
            ENDIF
            IF wleer2<>wleer THEN
              wleer=wleer2
              b$=STR$(wleer)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            IF virtual=TRUE AND sret=0 AND sloop!=FALSE THEN
              b=b2+mbit*INT((back%*fxlen)/mbit)
              @intzeiger2(b)
            ENDIF
          ENDIF
          IF nr=trakker& THEN
            @edhandler5(tmbit)
          ENDIF
          IF nr=arranger& THEN
            @edhandler4
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
      UNTIL back3%=1 OR k=3 OR k=2
      intplay=FALSE
      @write_int(0)
      IF nr=smpedit& THEN
        IF virtual=TRUE AND sret=0 AND sloop!=FALSE THEN
          @intzeiger3
        ENDIF
        IF bigfoot=TRUE THEN
          hsec=0
          @htimeset
          @textfeld(editime&,a$,1)
        ELSE
          @textfeld(smpsec&,sec$,1)
        ENDIF
      ENDIF
    ENDIF
  ELSE
    back%=0
  ENDIF
  dig24=vdig24
  IF dig24=FALSE THEN
    @setbitrate16
  ELSE
    @setbitrate24
  ENDIF
RETURN
'
> PROCEDURE maschruf18c
  '
  ' Aufruf in : smpplay-2,
  '
  ' MIDI-WAIT for MIDI-HDPLAY
  '
  ' midiwort - HIGHByte=Channel   LOWByte=Note
  '
  midiwort=(ch-1)*256+note
  sda%=midiwort
  raus=FALSE
  @maus_note
  REPEAT
    x=INP?(3)
    y=INP?(2)
    ~GRAF_MKSTATE(v,v2,v3,v4)
    IF x=TRUE AND v3<>2 THEN
      xx=INP(3)
      IF xx=&H90+(ch-1) THEN
        REPEAT
          x=INP?(3)
          y=INP?(2)
          ~GRAF_MKSTATE(v,v2,v3,v4)
        UNTIL x=TRUE OR y=TRUE OR v3=2
        IF y=FALSE AND x=TRUE AND v3<>2 THEN
          xx2=INP(3)
          IF xx2=note AND v3<>2 THEN
            REPEAT
              x=INP?(3)
              y=INP?(2)
              ~GRAF_MKSTATE(v,v2,v3,v4)
            UNTIL x=TRUE OR y=TRUE OR v3=2
            IF y=FALSE AND x=TRUE AND v3<>2 THEN
              xx3=INP(3)
              IF xx=&H90+(ch-1) AND xx2=note AND xx3<>0 THEN
                raus=TRUE
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    IF y=TRUE AND v3<>2 THEN
      yy=INP(2)
    ENDIF
    ~GRAF_MKSTATE(v,v2,v3,v4)
  UNTIL y=TRUE OR raus=TRUE OR v3=2 OR INP?(2)=TRUE
RETURN
'
'
'
'
> PROCEDURE maschruf5d
  .| Aufruf in : maschruf18b
  LOCAL p,b$,bw
  ' HARDDISK-MIDI second generation
  '
  vdig24=dig24
  omspos=-1
  @busy_mouse
  IF demo=FALSE THEN
    IF over<0 THEN
      sad%=mdat%+flen-mbit
    ENDIF
    scd%=handle
    sdd%=playpos            !playposition
    IF sectors<=1 THEN
      sectors=2
    ENDIF
    sed%=sectors-10
    sfd%=over
    '
    sgd%=l+8
    '
    sid%=midiwort
    sfa%=fileart
    saa%=meml
    sba%=meml+sectors
    '
    handle=GEMDOS(61,L:VARPTR(pa$),0)
    a1=GEMDOS(66,L:sdd%,scd%,0)
    a2=GEMDOS(63,scd%,L:sed%,L:meml)
    a3=GEMDOS(62,scd%)
    '
    IF XBIOS(xbs,1)=&H71273800 THEN
      bw=XBIOS(xbs,122,0,L:saa%,L:sba%,L:0,sfd%,sgd%,sid%)
      IF pwait=FALSE THEN
        @write_int(1)
      ELSE
        intnr=1
        @pausewait
      ENDIF
      intplay=TRUE
      REPEAT
      UNTIL @mousek=0
      REPEAT
        back3%=LPEEK(bw+8)
        k=@mousek
        ~FRE(0)
      UNTIL back3%=1 OR k=3 OR k=2
      intplay=FALSE
      @write_int(0)
    ENDIF
  ELSE
    back%=0
  ENDIF
  dig24=vdig24
  IF dig24=FALSE THEN
    @setbitrate16
  ELSE
    @setbitrate24
  ENDIF
RETURN
'
> PROCEDURE maschruf1
  .| Glob. Var.: saa%,a#,sba%,b#,ena%,l#,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpsave-1,ldhlp-1,
  ' LOAD/SAVE
  '
  @busy_mouse
  saa%=a
  sba%=b
  ena%=l
  ~XBIOS(xbs,310,L:saa%,L:sba%,L:ena%)
RETURN
'
> PROCEDURE get_specialkeys
  ~GRAF_MKSTATE(x,v,prbut,prkey)
  v4=prkey
  k=prbut
  IF v4=0 THEN
    nokey=TRUE
  ELSE
    nokey=FALSE
  ENDIF
  IF (v4 AND 1)=0 THEN
    rshft=FALSE
  ELSE
    rshft=TRUE
  ENDIF
  IF (v4 AND 2)=0 THEN
    lshft=FALSE
  ELSE
    lshft=TRUE
  ENDIF
  IF (v4 AND 4)=0 THEN
    ctrlkey=FALSE
  ELSE
    ctrlkey=TRUE
  ENDIF
  IF (v4 AND 8)=0 THEN
    altkey=FALSE
  ELSE
    altkey=TRUE
  ENDIF
RETURN
'
> PROCEDURE keymarkers
  @get_specialkeys
  keym=TRUE
  IF fkms=FALSE AND ((lshft=FALSE AND rshft=FALSE) OR kms=0) THEN
    INC kms
  ENDIF
  IF kms<=loopz THEN
    IF hdr=FALSE AND hdp=FALSE THEN
      ksms2=sms2
      IF lshft=FALSE AND rshft=FALSE THEN
        sms2=1
      ELSE
        sms2=2
      ENDIF
      IF nr=smpedit& THEN
        IF ksms2<>sms2 AND ksms2<>0 THEN
          @selblkshak(ksms2,0)
        ENDIF
        @selblkshak(sms2,1)
      ENDIF
      IF nr=smpedit& AND sms=kms AND fkms=TRUE THEN
        @edmarkdel
      ENDIF
      loops%(kms,sms2)=point
      IF nr=smpedit& THEN
        IF kms=1 OR sms=kms THEN
          @edmarkset(kms)
        ELSE
          @edslidemove(kms)
        ENDIF
      ENDIF
      sms=kms
      IF nr=peak& THEN
        @htimeset
        a$=pknam$+" -> "+STR$(kms)+": "+a$
        @textfeld(peakname&,a$,1)
      ENDIF
    ELSE
      IF nr=smpedit& THEN
        @textfeld(edmtims&,CHR$(0),1)
        @textfeld(edmtime&,CHR$(0),1)
        @textfeld(edmtimi&,CHR$(0),1)
        @textfeld(edmtimr&,CHR$(0),1)
      ENDIF
      IF hdp=TRUE THEN
        IF virtual=FALSE THEN
          IF lshft=FALSE AND rshft=FALSE THEN
            kms2=1
          ELSE
            kms2=2
          ENDIF
          bloops%(kms,kms2)=point
          a$=STR$(kms)+CHR$(0)
          IF nr=smpedit& THEN
            @textfeld(edmnr&,a$,1)
          ENDIF
          IF nr=peak& THEN
            @htimeset
            a$=pknam$+" -> "+STR$(kms)+": "+a$
            @textfeld(peakname&,a$,1)
          ENDIF
          vkms=kms-1
          IF nr=smpedit& THEN
            @setslide(edmslide&,edmbut&,loopz,5,vkms)
            @markhlp3(kms,kms2,bloops%(kms,kms2))
          ENDIF
        ELSE
          sms=kms
          ksms2=sms2
          IF lshft=FALSE AND rshft=FALSE THEN
            sms2=1
          ELSE
            sms2=2
          ENDIF
          IF nr=smpedit& THEN
            IF ksms2<>sms2 AND ksms2<>0 THEN
              @selblkshak(ksms2,0)
            ENDIF
            @selblkshak(sms2,1)
          ENDIF
          loops%(sms,sms2)=point
          a$=STR$(sms)+CHR$(0)
          IF nr=smpedit& THEN
            @textfeld(edmnr&,a$,1)
          ENDIF
          IF nr=peak& THEN
            @htimeset
            a$=pknam$+" -> "+STR$(kms)+": "+a$
            @textfeld(peakname&,a$,1)
          ENDIF
          vsms=sms-1
          IF nr=smpedit& THEN
            @setslide(edmslide&,edmbut&,loopz,5,vsms)
            @markhlp3(sms,sms2,loops%(sms,sms2))
          ENDIF
        ENDIF
      ELSE
        IF lshft=FALSE AND rshft=FALSE THEN
          sms2=1
        ELSE
          sms2=2
        ENDIF
        sms=kms
        loops%(sms,sms2)=point
        a$=STR$(sms)+CHR$(0)
        IF nr=smpedit& THEN
          @textfeld(edmnr&,a$,1)
        ENDIF
        IF nr=peak& THEN
          @htimeset
          a$=pknam$+" -> "+STR$(kms)+": "+a$
          @textfeld(peakname&,a$,1)
        ENDIF
        vsms=sms-1
        IF nr=smpedit& THEN
          @setslide(edmslide&,edmbut&,loopz,5,vsms)
          @markhlp3(sms,sms2,loops%(sms,sms2))
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  fkms=FALSE
RETURN
'
> PROCEDURE show_timepos_mem
  IF nr=cuelist& THEN
    ctime2=INT((cuelst(1,4)+back4%))
    hsec=INT(ctime2/hz/mbit*100)
    @cuetime
  ELSE
    hsec=INT((back%-meml)/hz/mbit*100)
  ENDIF
  @htimeset
  hsec=hsec2
  IF nr=smpedit& THEN
    IF bigfoot=TRUE THEN
      IF flicker=TRUE THEN
        VSYNC
      ENDIF
      @textfeld(editime&,a$,1)
      IF bigtxt=FALSE THEN
        '        @textfeld3(peak&,peakpos&,a$,1)   ! Zeichnen in inaktives Fenster
      ENDIF
    ELSE
      @textfeld(smpsec&,a$,1)
    ENDIF
  ENDIF
  IF nr=cuelist& THEN
    IF flicker=TRUE THEN
      VSYNC
    ENDIF
    @textfeld(cuepos&,a$,1)
  ENDIF
  IF nr=peak& THEN
    IF bigtxt=FALSE THEN
      IF flicker=TRUE THEN
        VSYNC
      ENDIF
      @textfeld(peakpos&,a$,1)
    ELSE
      @bigtext(nr,a$,1)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE show_timepos_hd
  IF nr=cuelist& THEN
    ctime2=INT((cuelst(1,4)+back%))
    hsec=INT(ctime2/hz/mbit*100)
    @cuetime
  ELSE
    hsec=INT((playpos+back%)/hz/mbit*100)
  ENDIF
  @htimeset
  hsec=hsec2
  IF nr=smpedit& THEN
    IF bigfoot=TRUE THEN
      IF flicker=TRUE THEN
        VSYNC
      ENDIF
      @textfeld(editime&,a$,1)
    ELSE
      @textfeld(smpsec&,a$,1)
    ENDIF
  ENDIF
  IF nr=peak& THEN
    IF bigtxt=FALSE THEN
      IF flicker=TRUE THEN
        VSYNC
      ENDIF
      @textfeld(peakpos&,a$,1)
    ELSE
      @bigtext(nr,a$,1)
    ENDIF
  ENDIF
  IF nr=cuelist& THEN
    IF flicker=TRUE THEN
      VSYNC
    ENDIF
    @textfeld(cuepos&,a$,1)
  ENDIF
  IF nr=fsel& THEN
    IF flicker=TRUE THEN
      VSYNC
    ENDIF
    @textfeld(fstime&,a$,1)
  ENDIF
RETURN
'
> PROCEDURE maschruf2
  .| Glob. Var.: demo#,saa%,a#,sba%,b#,sca%,adder#,sda%,l#,sea%,playfifolen#
  .|     sfa%,midiwort#,sga%,adr#,sha%,wback%,sia%,mdat%,t#,meml#,nr#,smpedit&
  .|     back%,back2%,back3%,hsec2#,hsec#,smpsec&,a$,sec$,mdat2%
  .| Ruft auf  : busy_mouse,digout,intzeiger1,htimeset,textfeld,intzeiger2
  .|     mousek,intzeiger3
  .| Aufruf in : smpplay-2,smppmhlp-2,
  LOCAL p,b$
  @maus_player
  ' PLAY
  '
  exfill=FALSE
  omspos=-1
  IF (nr=cuelist& AND cntstrt=0) OR nr<>cuelist& THEN
    cntstrt=0
  ENDIF
  fkms=TRUE
  kms=sms
  IF dspuse=TRUE THEN
    @dspplay2
    '    PAUSE 20
  ENDIF
  '
  IF demo=FALSE THEN
    @digout(TRUE)
    saa%=a
    sba%=b
    IF dspuse=TRUE THEN
      v=b-a
      v=INT(v/&H2000)*&H2000
      b=a+v
      sba%=b
    ENDIF
    IF falcon=FALSE THEN
      sca%=adder
      sda%=l
      IF dspuse=FALSE THEN
        sea%=playfifolen/8-1
      ELSE
        sea%=&H800-1              ! war vorher &H1000-1
      ENDIF
      sfa%=midiwort
      sga%=adr+&H40
      sha%=adr+&H100
    ENDIF
    LPOKE wback%,0
    LPOKE wback%+4,0
    sia%=wback%
    IF XBIOS(xbs,1)=&H71273800 OR falcon=TRUE THEN
      back%=saa%
      back4%=cntstrt
      @show_timepos_mem
      IF nr=smpedit& THEN
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      IF nr=peak& THEN
        v=sba%-meml
        hsec=INT(v/hz/mbit*100)
        @htimeset
        IF bigtxt=FALSE THEN
          @textfeld(peakmax&,a$,1)
        ELSE
          @bigtext(nr,a$,0)
        ENDIF
        @textfeld(recerror&,"0"+CHR$(0),1)
        @textfeld(recpeaks&,"0"+CHR$(0),1)
      ENDIF
      IF falcon=FALSE THEN
        IF dspuse=FALSE THEN
          IF dig24=FALSE THEN
            IF nr=peak& THEN
              recback=XBIOS(xbs,131,0,L:saa%,L:sba%,L:cntstrt,sca%,sda%)  ! fÅr 16bit mit peak
            ELSE
              recback=XBIOS(xbs,122,0,L:saa%,L:sba%,L:cntstrt,sca%,sda%)  ! fÅr 16bit
            ENDIF
          ELSE
            IF nr=peak& THEN
              recback=XBIOS(xbs,131,2,L:saa%,L:sba%,L:cntstrt,sca%,sda%) ! fÅr 24Bit-Mode mit peak
            ELSE
              recback=XBIOS(xbs,122,2,L:saa%,L:sba%,L:cntstrt,sca%,sda%) ! fÅr 24Bit-Mode
            ENDIF
          ENDIF
          IF cueplay=TRUE THEN
            cueflag=recback+60
            cuestrt=recback+64
            cueend=recback+68
            @cuenext
          ENDIF
          '
          IF dig24=TRUE THEN
            '            ~XBIOS(xbs,28,1)
          ENDIF
          IF mod96=TRUE THEN
            ~XBIOS(xbs,24,1)
          ENDIF
          '
          PAUSE 5
          IF pwait=FALSE THEN
            IF mtc=TRUE THEN
              @wait_mtc
            ENDIF
            @write_int(1)
          ELSE
            intnr=1
            @pausewait
          ENDIF
        ELSE
          @write_int(0)
          ~XBIOS(xbs,55,0)
          ~XBIOS(&H8B,0,2,0,clk,1)
          ~XBIOS(&H8B,1,8,0,clk,1)
          recback=XBIOS(xbs,122,1,L:saa%,L:sba%,L:cntstrt,sca%,sda%)
          ~XBIOS(xbs,74)
          '        ~XBIOS(xbs,73,0)
          ~XBIOS(112,&H12)
          ~XBIOS(xbs,55,1)
        ENDIF
      ELSE
        ~XBIOS(&H83,0,L:saa%,L:sba%)
        ~XBIOS(&H84,1)
        ~XBIOS(&H85,0,0)
        ~XBIOS(&H86,0)
        ~XBIOS(&H87,0,0)   ! war 1,0
        ~XBIOS(&H8B,0,8+4,0,clk,1)
        '
        '
        a=1
        IF sloop!=TRUE THEN
          a=a+2
        ENDIF
        a=XBIOS(&H88,a)
        PAUSE 5
      ENDIF
      pkreq=XBIOS(xbs,150)               ! peak-request Adresse holen
      intplay=TRUE
      t=TIMER
      peaktime=t
      peakint=FALSE
      b=mbit*INT((saa%-meml)/mbit)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      REPEAT
      UNTIL @mousek=0
      wleer=0
      peakret=recback+16    ! max. Peakwert
      peakexit=recback+8    ! Break-Flag
      peakfull=recback+12   ! Fehlerflag
      zaehlpos=recback+24   ! zaehlerposition
      peaks=0
      peaks2=0
      IF pstop=FALSE THEN
        REPEAT
          IF falcon=FALSE THEN
            back%=LPEEK(recback)
            back2%=LPEEK(recback+28)
            back3%=LPEEK(recback+8)
            back4%=LPEEK(recback+24)
            wleer2=LPEEK(recback+12)
          ELSE
            back2%=0
            back3%=0
            a=XBIOS(&H8C,0)
            IF a<>0 THEN
              INC wleer2%
            ENDIF
            a=XBIOS(&H8D,L:mdat%)
            back%=LPEEK(mdat%)
            back4%=LPEEK(mdat%)-saa%
            '
            '          bi=XBIOS(500,308)
            '          bi$=STR$(LPEEK(bi))+" : "+STR$(LPEEK(bi+4))+SPACE$(10)
            '          TEXT 64,64,bi$
            '
          ENDIF
          hsec2=INT((TIMER-t)/2)
          point=INT(saa%-meml+back4%)
          IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
            @show_timepos_mem
            IF nr=smpedit& THEN
              IF wleer2<>wleer THEN
                wleer=wleer2
                b$=STR$(wleer)+CHR$(0)
                @textfeld(smprate&,b$,1)
              ENDIF
              b=mbit*INT((back%-meml)/mbit)
              @intzeiger2(b)
            ENDIF
            IF nr=peak& THEN
              IF wleer2<>wleer THEN
                wleer=wleer2
                b$=STR$(wleer)+CHR$(0)
                @textfeld(recerror&,b$,1)
              ENDIF
              IF peaks2<>peaks THEN
                peaks=peaks2
                b$=STR$(peaks)+CHR$(0)
                @textfeld(recpeaks&,b$,1)
              ENDIF
              @peakrec
            ENDIF
            '
            @makesmpte(point)
            '
          ENDIF
          k=@mousek
          ~FRE(0)
          @peakbreak
          IF BTST(em,0) AND ascii|=32 THEN
            @keymarkers
          ENDIF
          IF falcon=TRUE AND sloop!=FALSE THEN
            IF back4%>=(sba%-saa%) OR back4%=0 THEN
              back3%=1
            ENDIF
          ENDIF
          IF cueplay=TRUE THEN
            IF LPEEK(cueflag)=0 THEN
              @cuenext
            ENDIF
          ENDIF
        UNTIL back3%=1 OR k=3 OR k=2
      ENDIF
      @write_int(0)
      intplay=FALSE
      IF dspuse=TRUE THEN
        '        ~XBIOS(xbs,73,0)
        ~XBIOS(112,&H12)
        ~XBIOS(xbs,74)
        ~XBIOS(xbs,55,0)
        ~XBIOS(&H8B,0,2,0,clk,1)
        ~XBIOS(&H8B,3,11,0,clk,1)
      ENDIF
      IF dig24=TRUE THEN
        '        ~XBIOS(xbs,28,0)
      ENDIF
      IF mod96=TRUE THEN
        ~XBIOS(xbs,24,0)
      ENDIF
      IF nr=smpedit& THEN
        @intzeiger3
        IF bigfoot=TRUE THEN
          hsec=0
          @htimeset
          @textfeld(editime&,a$,1)
        ELSE
          @textfeld(smpsec&,sec$,1)
        ENDIF
      ENDIF
    ENDIF
  ELSE
    back%=0
    back2%=0
  ENDIF
  pstop=FALSE
  ~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE maschruf3
  .| Glob. Var.: demo#,sab%,a#,sbb%,l#,scb%,sth#,sdb%,recfifolen#,seb%,adr#
  .|     sfb%,nr#,peak&,t#,b#,saa%,meml#,smpedit&,hsec#,hz#,peakmax&,a$
  .|     peakint#,back%,back3%,hsec2#,smpsec&,peakpos&,peakret#,sec$,edit_obj&
  .|     idx&,tree&,mdat%,mdat2%,cached#
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,peakrec
  .|     mousek,intzeiger3,rsc_message,markhlp
  .| Aufruf in : record-1,
  LOCAL p,b$
  ' RECORD
  '
  exfill=FALSE
  @maus_player
  omspos=-1
  fkms=TRUE
  IF sblock=0 THEN
    kms=1
  ELSE
    kms=sms+1
  ENDIF
  IF dspuse=TRUE THEN
    @dsprec2
    '    PAUSE 20
  ENDIF
  mausbm=TRUE
  IF demo=FALSE THEN
    sab%=ar
    sbb%=ar+lr
    IF falcon=FALSE THEN
      scb%=sth
      sdb%=recfifolen/8-1
      seb%=adr+&H60
      sfb%=adr+&H100-1
    ENDIF
    IF dspuse=TRUE THEN
      sdb%=&H1000               ! war vorher 1000-1
    ENDIF
    IF XBIOS(xbs,1)=&H71273800 OR falcon=TRUE THEN
      IF falcon=FALSE THEN
        IF dspuse=FALSE THEN
          IF nr=peak& THEN
            IF recpaus=TRUE THEN
              @write_int(0)
            ENDIF
            backlist=XBIOS(xbs,130,0,L:sab%,L:sbb%)
          ELSE
            '
            IF dig24=TRUE THEN
              '              ~XBIOS(xbs,28,1)
            ENDIF
            IF mod96=TRUE THEN
              ~XBIOS(xbs,24,1)
            ENDIF
            '
            IF dig24=FALSE THEN
              backlist=XBIOS(xbs,121,0,L:sab%,L:sbb%)
            ELSE
              backlist=XBIOS(xbs,121,2,L:sab%,L:sbb%)   ! fÅr 24Bit-Mode
            ENDIF
          ENDIF
        ELSE
          @write_int(0)
          ~XBIOS(xbs,55,0)
          backlist=XBIOS(xbs,130,1,L:sab%,L:sbb%)
        ENDIF
      ELSE
        ~XBIOS(&H83,1,L:sab%,L:sbb%)
        ~XBIOS(&H84,1)
        ~XBIOS(&H85,0,0)
        ~XBIOS(&H86,0)
        ~XBIOS(&H87,0,0)
        IF digana=TRUE THEN
          ~XBIOS(&H8B,3,9,0,clk,1)
        ELSE
          ~XBIOS(&H8B,3,9,0,0,1)
        ENDIF
        a=4
        IF sloop!=TRUE THEN
          a=a+8
        ENDIF
        ~XBIOS(&H88,a)
        back3%=0
      ENDIF
      pkreq=XBIOS(xbs,150)               ! peak-request Adresse holen
      PAUSE 5
      IF autorec=FALSE THEN
        '        @fifodel
      ENDIF
      b=mbit*INT((saa%-meml)/mbit)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
        v=sbb%-meml
        hsec=INT(v/hz/mbit*100)
        @htimeset
        IF bigfoot=TRUE THEN
          @textfeld(editime&,a$,1)
        ELSE
          @textfeld(smpsec&,a$,1)
        ENDIF
      ENDIF
      IF nr=peak& THEN
        v=sbb%-meml
        hsec=INT(v/hz/mbit*100)
        @htimeset
        IF bigtxt=FALSE THEN
          @textfeld(peakmax&,a$,1)
          v=sab%-meml
          hsec=INT(v/hz/mbit*100)
          @htimeset
          @textfeld(peakpos&,a$,1)
        ELSE
          @bigtext(nr,a$,0)
          v=sab%-meml
          hsec=INT(v/hz/mbit*100)
          @htimeset
          @bigtext(nr,a$,1)
        ENDIF
        @textfeld(recerror&,"0"+CHR$(0),1)
        @textfeld(recpeaks&,"0"+CHR$(0),1)
      ENDIF
      IF dspuse=FALSE THEN
        IF falcon=FALSE THEN
          IF mtc=TRUE THEN
            @wait_mtc
          ENDIF
          intnr=2
          IF recpaus=FALSE THEN
            IF beeper=FALSE THEN
              @write_int(2)
            ELSE
              @beepmaster
            ENDIF
          ELSE
            IF nr=peak& THEN
              obj=peakwait&
            ENDIF
            IF nr=smpedit& THEN
              obj=smpwait&
            ENDIF
            @breakwait
            @beepmaster
          ENDIF
        ENDIF
      ELSE
        '        ~XBIOS(xbs,73,0)
        ~XBIOS(112,&H12)
        ~XBIOS(xbs,55,1)
        PAUSE 5
        '        ~XBIOS(xbs,73,1)
        ~XBIOS(112,&H13)
      ENDIF
      intrec=TRUE
      t=TIMER
      peaktime=t
      peakint=FALSE
      IF falcon=TRUE THEN
        peakret=mdat%   ! Dummy
        peakexit=mdat%  ! Dummy
        peakfull=mdat%  ! Dummy
      ENDIF
      REPEAT
      UNTIL @mousek=0
      rfull=0
      peaks=0
      peaks2=0
      IF pstop=FALSE THEN
        REPEAT
          IF falcon=FALSE THEN
            peakret=backlist+16
            peakexit=backlist+8
            peakfull=backlist+12
            back%=LPEEK(backlist)
            back4%=LPEEK(backlist+24)
            rfull2=LPEEK(peakfull)
          ENDIF
          '
          IF dighead=TRUE AND falcon=FALSE AND ad=0 AND dig24=TRUE AND rch4=FALSE AND rmo8=FALSE AND dspuse=FALSE THEN            ! Digital Data ?
            ustart=XBIOS(xbs,151) ! Userblock DAT-Startmarke Adresse
            IF ustart<>0 AND ustart<>ustartp THEN
              ustartp=ustart
              point=INT(ustartp-meml-(recfifolen*4))
              IF point<0 THEN
                point=0
              ENDIF
              @keymarkers
            ENDIF
          ENDIF
          '
          hsec2=INT((TIMER-t)/2)
          point=INT(sab%-meml+back4%)
          IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
            IF falcon=TRUE THEN
              IF XBIOS(&H8C,0)<>0 THEN
                INC rfull2%
              ENDIF
              ~XBIOS(&H8D,L:mdat%)
              back%=LPEEK(mdat%+4)
              back4%=LPEEK(mdat%+4)-sab%
            ENDIF
            hsec=INT((sab%-meml+back4%)/hz/mbit*100)
            @htimeset
            hsec=hsec2
            IF nr=smpedit& THEN
              IF bigfoot=TRUE THEN
                IF flicker=TRUE THEN
                  VSYNC
                ENDIF
                @textfeld(editime&,a$,1)
              ELSE
                @textfeld(smpsec&,a$,1)
              ENDIF
              IF rfull2<>rfull THEN
                rfull=rfull2
                b$=STR$(rfull)+CHR$(0)
                @textfeld(smprate&,b$,1)
              ENDIF
              b=mbit*INT((back%-meml)/mbit)
              @intzeiger2(b)
            ENDIF
            IF nr=peak& THEN
              IF bigtxt=FALSE THEN
                IF flicker=TRUE THEN
                  VSYNC
                ENDIF
                @textfeld(peakpos&,a$,1)
              ELSE
                @bigtext(nr,a$,1)
              ENDIF
              IF rfull2<>rfull THEN
                rfull=rfull2
                b$=STR$(rfull)+CHR$(0)
                @textfeld(recerror&,b$,1)
              ENDIF
              IF peaks2<>peaks THEN
                peaks=peaks2
                b$=STR$(peaks)+CHR$(0)
                @textfeld(recpeaks&,b$,1)
              ENDIF
              @peakrec
            ENDIF
            '
            @makesmpte(point)
            '
          ENDIF
          k=@mousek
          ~FRE(0)
          IF falcon=FALSE THEN
            back3%=LPEEK(peakexit)
          ELSE
            IF (back4%>=(sbb%-sab%) OR back4%=0) AND sloop!=FALSE THEN
              back3%=1
            ENDIF
          ENDIF
          @peakbreak
          IF BTST(em,0) AND ascii|=32 THEN
            @keymarkers
          ENDIF
          @read_digsrate
          IF hzc<>rwert THEN
            @makehz3
          ENDIF
        UNTIL back3%=1 OR k=3 OR k=2
      ENDIF
      @write_int(0)
      intrec=FALSE
      IF dspuse=TRUE THEN
        ~XBIOS(xbs,55,0)
        '        ~XBIOS(xbs,73,0)
        ~XBIOS(112,&H12)
        ~XBIOS(xbs,74)
      ENDIF
      IF dig24=TRUE THEN
        '        ~XBIOS(xbs,28,0)
      ENDIF
      IF mod96=TRUE THEN
        ~XBIOS(xbs,24,0)
      ENDIF
      mausbm=FALSE
      IF nr=smpedit& THEN
        @intzeiger3
        IF bigfoot=TRUE THEN
          hsec=0
          @htimeset
          @textfeld(editime&,a$,1)
        ELSE
          @textfeld(smpsec&,sec$,1)
        ENDIF
      ENDIF
      IF nr=peak& THEN
        a$=SPACE$(11)+CHR$(0)
        @textfeld(peakmax&,a$,1)
        @textfeld(peakpos&,a$,1)
        @setbutton(ed_obj,0)
        rsc_message(smpedit&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
        nr=smpedit&
        tree&=nr
        @markhlp
      ENDIF
    ENDIF
    cached=FALSE
  ENDIF
  fkms=FALSE
  pstop=FALSE
RETURN
'
> PROCEDURE maschruf3b
  .| Glob. Var.: demo#,scb%,sth#,sdb%,recfifolen#,seb%,adr#,sfb%,nr#,peak&,a#
  .|     sab%,sbb%,t#,b#,meml#,smpedit&,hsec#,l#,hz#,peakmax&,a$,peakint#
  .|     back%,back3%,hsec2#,smpsec&,peakpos&,peakret#,sec$,edit_obj&,idx&
  .|     tree&,p#,mdat%,mdat2%,cached#
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,peakrec
  .|     mousek,intzeiger3,rsc_message,markhlp
  .| Aufruf in : smpauto-1,
  ' RECORD
  '
  LOCAL b$
  @maus_player
  mausbm=TRUE
  IF demo=FALSE THEN
    scb%=sth
    sdb%=recfifolen/8-1
    seb%=adr+&H60
    sfb%=adr+&H100-1
    IF XBIOS(xbs,1)=&H71273800 THEN
      IF breakrec=FALSE THEN
        IF nr=peak& THEN
          backlist=XBIOS(xbs,130,0,L:sab%,L:sbb%)
        ELSE
          backlist=XBIOS(xbs,121,0,L:sab%,L:sbb%)
        ENDIF
        PAUSE 5
        IF autorec=FALSE THEN
          '        @fifodel
        ENDIF
        @write_int(2)
        t=TIMER
        peaktime=t
        b=mbit*INT((sab%-meml)/mbit)
        IF nr=smpedit& THEN
          @intzeiger1(b)
          @textfeld(smprate&,"0"+CHR$(0),1)
          hsec=INT(l/hz/mbit*100)
          @htimeset
          IF bigfoot=TRUE THEN
            @textfeld(editime&,a$,1)
          ELSE
            @textfeld(smpsec&,a$,1)
          ENDIF
        ENDIF
        IF nr=peak& THEN
          hsec=INT(l/hz/mbit*100)
          @htimeset
          IF bigtxt=FALSE THEN
            @textfeld(peakmax&,a$,1)
          ELSE
            @bigtext(nr,a$,0)
          ENDIF
          @textfeld(recerror&,"0"+CHR$(0),1)
          @textfeld(recpeaks&,"0"+CHR$(0),1)
        ENDIF
        peakint=FALSE
        REPEAT
        UNTIL @mousek=0
        rfull=0
        peaks=0
        peaks2=0
        pkreq=XBIOS(xbs,150)               ! peak-request Adresse holen
        REPEAT
          peakret=backlist+16
          peakexit=backlist+8
          peakfull=backlist+12
          back%=LPEEK(backlist)
          rfull2=LPEEK(peakfull)
          hsec2=INT((TIMER-t)/2)
          IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
            hsec=hsec2
            @htimeset
            IF nr=smpedit& THEN
              IF bigfoot=TRUE THEN
                IF flicker=TRUE THEN
                  VSYNC
                ENDIF
                @textfeld(editime&,a$,1)
              ELSE
                @textfeld(smpsec&,a$,1)
              ENDIF
              IF rfull2<>rfull THEN
                rfull=rfull2
                b$=STR$(rfull)+CHR$(0)
                @textfeld(smprate&,b$,1)
              ENDIF
              b=mbit*INT((back%-meml)/mbit)
              @intzeiger2(b)
            ENDIF
            IF nr=peak& THEN
              IF bigtxt=FALSE THEN
                IF flicker=TRUE THEN
                  VSYNC
                ENDIF
                @textfeld(peakpos&,a$,1)
              ELSE
                @bigtext(nr,a$,1)
              ENDIF
              IF rfull2<>rfull THEN
                rfull=rfull2
                b$=STR$(rfull)+CHR$(0)
                @textfeld(recerror&,b$,1)
              ENDIF
              IF peaks2<>peaks THEN
                peaks=peaks2
                b$=STR$(peaks)+CHR$(0)
                @textfeld(recpeaks&,b$,1)
              ENDIF
              peakret=backlist+16
              @peakrec
            ENDIF
          ENDIF
          k=@mousek
          ~FRE(0)
          back3%=LPEEK(peakexit)
          @peakbreak
          IF BTST(em,0) AND ascii|=32 THEN
            @keymarkers
          ENDIF
          @read_digsrate
          IF hzc<>rwert THEN
            @makehz3
          ENDIF
        UNTIL back3%=1 OR k=3 OR k=2
      ENDIF
      @write_int(0)
      mausbm=FALSE
      IF nr=smpedit& THEN
        @intzeiger3
        IF bigfoot=TRUE THEN
          hsec=0
          @htimeset
          @textfeld(editime&,a$,1)
        ELSE
          @textfeld(smpsec&,sec$,1)
        ENDIF
      ENDIF
      IF nr=peak& THEN
        a$=SPACE$(11)+CHR$(0)
        @textfeld(peakmax&,a$,1)
        @textfeld(peakpos&,a$,1)
        @setbutton(ed_obj,0)
        IF breakrec=FALSE THEN
          rsc_message(smpedit&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
          nr=smpedit&
          tree&=nr
          @markhlp
        ENDIF
      ENDIF
    ENDIF
    cached=FALSE
  ENDIF
  mausbm=FALSE
RETURN
'
> PROCEDURE maschruf4b
  .| Glob. Var.: demo#,tr%,th#,sac%,adr#,sbc%,a#,mdat3%,cached#
  .| Ruft auf  : maschinit4,fifodel
  .| Aufruf in : smpauto-1,
  ' RECORD AUTO-WAIT
  '
  IF hrd=0 THEN
    IF nr=smpedit& THEN
      hsec=INT(l/hz/mbit*100)
      @htimeset
      IF bigfoot=TRUE THEN
        @textfeld(editime&,a$,1)
      ELSE
        @textfeld(smpsec&,a$,1)
      ENDIF
    ENDIF
    IF nr=peak& THEN
      hsec=INT(l/hz/mbit*100)
      @htimeset
      IF bigtxt=FALSE THEN
        @textfeld(peakmax&,a$,1)
        hsec=0
        @htimeset
        @textfeld(peakpos&,a$,1)
      ELSE
        @bigtext(nr,a$,0)
        hsec=0
        @htimeset
        @bigtext(nr,a$,1)
      ENDIF
      @textfeld(recerror&,"0"+CHR$(0),1)
      @textfeld(recpeaks&,"0"+CHR$(0),1)
    ENDIF
  ELSE
    rmlen=sectors       !max. Bytes
    IF nr=smpedit& THEN
      hsec=INT(rmlen/hz/mbit*100)
      @htimeset
      IF bigfoot=TRUE THEN
        @textfeld(editime&,a$,1)
      ELSE
        @textfeld(smpsec&,a$,1)
      ENDIF
    ENDIF
    IF nr=peak& THEN
      hsec=INT(rmlen/hz/mbit*100)
      @htimeset
      IF bigtxt=FALSE THEN
        @textfeld(peakmax&,a$,1)
        hsec=0
        @htimeset
        @textfeld(peakpos&,a$,1)
      ELSE
        @bigtext(nr,a$,0)
        hsec=0
        @htimeset
        @bigtext(nr,a$,1)
      ENDIF
      @textfeld(recerror&,"0"+CHR$(0),1)
      @textfeld(recpeaks&,"0"+CHR$(0),1)
    ENDIF
  ENDIF
  IF demo=FALSE AND falcon=FALSE THEN
    @maus_playwait
    IF dig24=FALSE THEN
      tr%=th
    ELSE
      tr%=SHL(th,8)
    ENDIF
    @write_int(0)
    @fifodel
    IF XBIOS(xbs,1)=&H71273800 THEN
      a=XBIOS(xbs,111,L:tr%)
      IF INP?(2)=TRUE THEN
        breakrec=TRUE
      ENDIF
    ENDIF
    cached=FALSE
  ENDIF
RETURN
'
> PROCEDURE breakstop
  IF (nr=mixer& AND obj=mixstop&) OR (nr=cuelist& AND obj=cuestop&) OR (nr=peak& AND obj=playstop& AND volmake=FALSE AND balmake=FALSE) OR (nr=virtual& AND obj=virtstop&) OR (nr=smpedit& AND obj=smpstop&) OR (nr=fsel& AND (obj=fsstop& OR obj=fsend&))
    @setbutton(obj,1)
    PAUSE 1
    back3%=1
    exfill=TRUE
    REPEAT
    UNTIL @mousek=0
    @setbutton(obj,0)
    IF nr=peak& THEN
      @textfeld(recpeaks&,"0"+CHR$(0),1)
      @textfeld(recerror&,"0"+CHR$(0),1)
      @textfeld(peakname&,CHR$(0),1)
    ENDIF
    IF nr=fsel& AND obj=fsend& THEN
      fsbreak=TRUE
    ENDIF
    DEFMOUSE 0
  ENDIF
  IF (nr=arranger& AND obj=stop&) OR (nr=trakker& AND obj=stop2&) THEN
    @setbutton(obj,1)
    PAUSE 1
    back3%=1
    exfill=TRUE
    REPEAT
    UNTIL @mousek=0
    @setbutton(obj,0)
    DEFMOUSE 0
  ENDIF
RETURN
'
> PROCEDURE breakwait
  IF (nr=cuelist& AND obj=cuewait&) OR (nr=smpedit& AND obj=smpwait&) OR (nr=fsel& AND obj=fswait&) OR (nr=peak& AND obj=peakwait& AND volmake=FALSE AND balmake=FALSE) OR (nr=arranger& AND obj=pause&) OR (nr=trakker& AND obj=pause2&)
    @write_int(0)
    @setbutton(obj,1)
    @pausewait
  ENDIF
  IF nr=mixer& AND obj=mixwait& THEN
    @write_int(0)
    @setbutton(obj,1)
    @pausewait
  ENDIF
RETURN
'
> PROCEDURE keycheck
  LOCAL x,v,prbut,prkey,v4,k
  ~GRAF_MKSTATE(x,v,prbut,prkey)
  v4=prkey
  k=prbut
  IF v4=0 THEN
    nokey=TRUE
  ELSE
    nokey=FALSE
  ENDIF
  IF (v4 AND 1)=0 THEN
    rshft=FALSE
  ELSE
    rshft=TRUE
  ENDIF
  IF (v4 AND 2)=0 THEN
    lshft=FALSE
  ELSE
    lshft=TRUE
  ENDIF
  IF (v4 AND 4)=0 THEN
    ctrlkey=FALSE
  ELSE
    ctrlkey=TRUE
  ENDIF
  IF (v4 AND 8)=0 THEN
    altkey=FALSE
  ELSE
    altkey=TRUE
  ENDIF
RETURN
'
> PROCEDURE peakbreak
  LOCAL my,mx,mbi,mz,r%,n,shift&,c,ky
  IF nr=mixer& OR nr=cuelist& OR nr=peak& OR nr=smpedit& OR nr=virtual& OR nr=fsel& OR nr=arranger& OR nr=trakker& THEN
    em=EVNT_MULTI(&X100011,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mbi,shift&,ky,c)
    IF BTST(em,1) AND mbi<>0 THEN
      mbi=1
    ELSE
      mbi=0
    ENDIF
    IF BTST(em,0) THEN
      ascii|=BYTE(ky)                                  ! ASCII-Code
      scan|=BYTE(SHR(ky,8))                            ! SCAN-Code
      @shortcuts2
    ELSE
      IF mbi=1 THEN
        r%=rsc_adr%(nr)
        obj=OBJC_FIND(r%,0,100,mx,my)
        @breakstop
        @breakwait
      ENDIF
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE pausewait
  LOCAL mx,my,n,mbi,evnt&,r%,shift&,key&,c,expause
  expause=FALSE
  exfill=FALSE
  pstop=FALSE
  REPEAT
    ~EVNT_MULTI(&X100011,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mbi,shift&,key&,c)
  UNTIL @mousek=0 AND mbi=0
  r%=rsc_adr%(nr)
  REPEAT
    n=0
    REPEAT
      evnt&=EVNT_MULTI(&X100011,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mbi,shift&,key&,c)
    UNTIL mbi=1 OR BTST(evnt&,0)
    '
    n=0
    IF BTST(evnt&,0) THEN
      ascii|=BYTE(key&)                                  ! ASCII-Code
      scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
      @shortcuts3
      n=obj
      REPEAT
        IF INP?(2)=TRUE THEN
          ~INP(2)
        ENDIF
      UNTIL INP?(2)=FALSE
    ENDIF
    '
    IF BTST(evnt&,1) AND mbi<>0 THEN
      n=OBJC_FIND(r%,0,100,mx,my)
    ENDIF
    IF (nr=mixer& AND n=mixwait&) OR (nr=cuelist& AND n=cuewait&) OR (nr=smpedit& AND n=smpwait&) OR (nr=fsel& AND n=fswait&) OR (nr=peak& AND n=peakwait& AND volmake=FALSE AND balmake=FALSE) OR (nr=arranger& AND n=pause&) OR (nr=trakker& AND n=pause2&)
      expause=TRUE
    ENDIF
    IF (nr=peak& AND n=playstop& AND volmake=FALSE AND balmake=FALSE) OR (nr=smpedit& AND n=smpstop&) OR (nr=arranger& AND n=stop&) OR (nr=trakker& AND n=stop2&) OR (nr=fsel& AND n=fsstop&) OR (nr=cuelist& AND n=cuestop&)
      expause=TRUE
    ENDIF
  UNTIL expause=TRUE
  IF (nr=peak& AND n=playstop& AND volmake=FALSE AND balmake=FALSE) OR (nr=smpedit& AND n=smpstop&) OR (nr=arranger& AND n=stop&) OR (nr=trakker& AND n=stop2&) OR (nr=fsel& AND n=fsstop&) OR (nr=cuelist& AND n=cuestop&)
    IF nr=peak& THEN
      @setbutton(peakwait&,0)
    ENDIF
    IF nr=smpedit& THEN
      @setbutton(smpwait&,0)
    ENDIF
    IF nr=arranger& THEN
      @setbutton(pause&,0)
    ENDIF
    IF nr=trakker& THEN
      @setbutton(pause2&,0)
    ENDIF
    IF nr=fsel& THEN
      @setbutton(fswait&,0)
    ENDIF
    IF nr=cuelist& THEN
      @setbutton(cuewait&,0)
    ENDIF
    obj=n
    pstop=TRUE
    @breakstop
    intnr=0
  ENDIF
  IF recp=TRUE AND nr=trakker& AND recpaus=TRUE THEN
    @write_int(0)
  ELSE
    @write_int(intnr)
  ENDIF
  @setbutton(n,0)
  REPEAT
    ~EVNT_MULTI(&X100011,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mbi,shift&,key&,c)
  UNTIL @mousek=0 AND mbi=0
  pwait=FALSE
  obj=0
  next_obj&=0
RETURN
'
> PROCEDURE peakbreak3
  LOCAL mx,mx,mbi,mz,r%,n,shift&,key&,c
  evnt&=EVNT_MULTI(&X100011,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mbi,shift&,key&,c)
  IF BTST(evnt&,1) THEN
    mbi=1
  ENDIF
  IF BTST(evnt&,0) THEN
    ascii|=BYTE(key&)                                  ! ASCII-Code
    scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
    @shortcuts2
  ELSE
    IF mbi=1 THEN
      r%=rsc_adr%(nr)
      obj=OBJC_FIND(r%,0,100,mx,my)
      @breakstop
      @breakwait
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE fillpmem
  LOCAL i,bw,memz
  '
  ' mb = lÑnge des blocks der an einem StÅck geladen wird
  ' halfbuf,meml1,meml2 = halfbuffer-lÑnge
  '
  IF memf=1 AND vmemf=0 THEN
    memz=mems1
    IF adder<0 THEN
      vv=GEMDOS(66,L:offs,handle,0)
    ENDIF
    halfbuf=meml1
    REPEAT
      IF firstp=FALSE THEN
        @busy_mouse
      ENDIF
      IF sectors>=mb AND halfbuf>=mb THEN
        bw=GEMDOS(63,handle,L:mb,L:memz)
      ELSE
        IF halfbuf>=sectors THEN
          bw=GEMDOS(63,handle,L:sectors,L:memz)
        ELSE
          bw=GEMDOS(63,handle,L:halfbuf,L:memz)
        ENDIF
      ENDIF
      halfbuf=halfbuf-bw
      allcount=allcount-bw
      sectors=sectors-bw
      IF nr=cuelist& THEN
        memz=memz+bw
        IF sectors=0 AND cueplay=TRUE THEN
          @cuenext2
          IF cueplay=FALSE THEN
            exfill=TRUE
          ENDIF
        ENDIF
      ELSE
        memz=memz+bw
        IF (memz-mems1)<=(meme1-mems1) THEN
          sba%=memz
          one%=1
        ENDIF
      ENDIF
      @zeigtime
      @peakbreak
      IF BTST(em,0) AND ascii|=32 THEN
        @keymarkers
      ENDIF
      IF nr<>cuelist& AND allcount<=0 THEN
        IF sloop!=FALSE OR virtual=FALSE OR (nr<>smpedit& AND nr<>peak&) THEN
          exfill=TRUE
        ELSE
          v=GEMDOS(66,L:playpos,handle,0)     ! SEEK
          allcount=allcountm
          sectors=allcount
        ENDIF
      ENDIF
    UNTIL halfbuf=0 OR exfill=TRUE OR (allcount<=0 AND (((sloop!=FALSE OR virtual=FALSE) AND (nr=smpedit& OR nr=peak&)) OR (nr<>smpedit& AND nr<>peak&)))
    offs=offs-meml2
    IF offs<0 THEN
      offs=0
    ENDIF
    IF firstp=FALSE THEN
      DEFMOUSE 0
      firstp=TRUE
    ENDIF
    vmemf=memf
  ENDIF
  IF memf=0 AND vmemf=1 THEN
    memz=mems2
    IF adder<0 THEN
      vv=GEMDOS(66,L:offs,handle,0)
    ENDIF
    halfbuf=meml2
    REPEAT
      IF sectors>=mb AND halfbuf>=mb THEN
        bw=GEMDOS(63,handle,L:mb,L:memz)
      ELSE
        IF halfbuf>=sectors THEN
          bw=GEMDOS(63,handle,L:sectors,L:memz)
        ELSE
          bw=GEMDOS(63,handle,L:halfbuf,L:memz)
        ENDIF
      ENDIF
      allcount=allcount-bw
      sectors=sectors-bw
      halfbuf=halfbuf-bw
      IF nr=cuelist& THEN
        memz=memz+bw
        IF sectors=0 AND cueplay=TRUE THEN
          @cuenext2
          IF cueplay=FALSE THEN
            exfill=TRUE
          ENDIF
        ENDIF
      ELSE
        memz=memz+bw
      ENDIF
      @zeigtime
      @peakbreak
      IF BTST(em,0) AND ascii|=32 THEN
        @keymarkers
      ENDIF
      IF nr<>cuelist& AND allcount<=0 THEN
        IF sloop!=FALSE OR virtual=FALSE OR (nr<>smpedit& AND nr<>peak&) THEN
          exfill=TRUE
        ELSE
          v=GEMDOS(66,L:playpos,handle,0)     ! SEEK
          allcount=allcountm
          sectors=allcount
        ENDIF
      ENDIF
    UNTIL halfbuf=0 OR exfill=TRUE OR (allcount<=0 AND (((sloop!=FALSE OR virtual=FALSE) AND (nr=smpedit& OR nr=peak&)) OR (nr<>smpedit& AND nr<>peak&)))
    offs=offs-meml1
    IF offs<0 THEN
      offs=0
    ENDIF
    vmemf=memf
  ENDIF
  @zeigtime
  @peakbreak
  IF BTST(em,0) AND ascii|=32 THEN
    @keymarkers
  ENDIF
RETURN
'
> PROCEDURE zeigtime
  IF intplay=TRUE THEN
    IF demo=FALSE THEN
      back%=LPEEK(recback+24)          ! Playbyte
      back2%=LPEEK(recback+4)       !4 Anzahl loops
      IF back3%=0 THEN
        back3%=LPEEK(peakexit)  ! Breakflag
      ENDIF
      memf=LPEEK(recback+4)        ! Memflag
      wleer2=LPEEK(peakfull)  ! Fehlerflag
    ENDIF
    IF sloop!=TRUE AND (nr=smpedit& OR nr=peak&) THEN
      back%=back%-posloop
      IF back%>posgrenz THEN
        posloop=posloop+posgrenz
      ENDIF
    ENDIF
    point=INT(back%)
    hsec2=INT((TIMER-t)/2)
    IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
      @show_timepos_hd
      '      @busy_mouse
      IF nr=smpedit& THEN
        IF wleer2<>wleer THEN
          wleer=wleer2
          b$=STR$(wleer)+CHR$(0)
          @textfeld(smprate&,b$,1)
        ENDIF
        IF nr=smpedit& AND virtual=TRUE THEN
          b=playpos+back%
          @intzeiger2(b)
        ENDIF
        @maketime
      ENDIF
      IF nr=peak& THEN
        IF wleer2<>wleer THEN
          wleer=wleer2
          b$=STR$(wleer)+CHR$(0)
          @textfeld(recerror&,b$,1)
        ENDIF
        IF peaks2<>peaks THEN
          peaks=peaks2
          b$=STR$(peaks)+CHR$(0)
          @textfeld(recpeaks&,b$,1)
        ENDIF
        @peakrec
      ENDIF
      IF nr=trakker& THEN
        @edhandler5(mbit)
      ENDIF
      IF nr=arranger& THEN
        @edhandler4
      ENDIF
      '
      @makesmpte(point)
      '
    ENDIF
    ~FRE(0)
  ENDIF
  IF (nr<>cuelist& AND nr<>smpedit& AND nr<>peak&) OR ((virtual=FALSE OR sloop!=FALSE) AND (nr=peak& OR nr=smpedit&)) THEN
    IF (back%>=endcount AND adder>=0) OR (-back%>=endcount AND adder<0) THEN
      @write_int(0)
      back3%=1
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE playinit
  mems1=meml
  meml1=INT(((memh-meml)-mbit)/mb/2)*mb
  meml1=INT(meml1/(adder+mbit))*(adder+mbit)
  IF meml1>g*mb THEN
    meml1=g*mb
    meml1=INT(meml1/mbit)*mbit
  ENDIF
  meml2=meml1
  meme1=mems1+meml1
  mems2=meme1
  meme2=mems2+meml2
  IF adder>=0 THEN
    saa%=mems1
    sba%=meme1
    saa2%=mems2
    sba2%=meme2
  ELSE
    saa%=meme1
    sba%=mems1
    saa2%=meme2
    sba2%=mems2
    offs=playpos-meml1
  ENDIF
  sca%=adder
  l=sret
  IF sloop!=TRUE AND nr<>cuelist& THEN
    l=l+1
  ENDIF
  sda%=l
  sea%=playfifolen/8-1
  sfa%=midiwort
  sga%=adr+&H40
  sha%=adr+&H100
  sfila%=fileart
  memf=1
  tmemf=1
  vmemf=0
  tvmemf=0
  recback=mdat%  ! Dummy
  back3%=0
  one%=0
  peakexit=recback+8    ! Break-Flag
  peakfull=recback+12   ! Fehlerflag
  peakret=recback+16    ! max. Peakwert
  zaehlpos=recback+24   ! zaehlerposition
RETURN
'
> PROCEDURE tplayinit
  mems1=meml
  meml1=INT(((memh-meml)-mbit)/mb/2)*mb
  meml1=INT(meml1/(adder+mbit))*(adder+mbit)
  IF meml1>g*mb THEN
    meml1=g*mb
    meml1=INT(meml1/mbit)*mbit
  ENDIF
  meml2=meml1
  meme1=mems1+meml1
  mems2=meme1
  meme2=mems2+meml2
  IF adder>=0 THEN
    tsaa%=mems1
    tsba%=meme1
    tsaa2%=mems2
    tsba2%=meme2
  ELSE
    tsaa%=meme1
    tsba%=mems1
    tsaa2%=meme2
    tsba2%=mems2
    offs=playpos-meml1
  ENDIF
  tsca%=adder
  l=sret
  IF sloop!=TRUE THEN
    l=l+1
  ENDIF
  tsda%=l
  tsea%=playfifolen/8-1
  tsfa%=midiwort
  tsga%=adr+&H40
  tsha%=adr+&H100
  tsfila%=fileart
  memf=1
  vmemf=0
  trecback=mdat%  ! Dummy
  FOR i=0 TO 100 STEP 4
    LPOKE trecback+i,0
  NEXT i
  tback3%=0
  tone%=0
  peakexit=trecback+8    ! Break-Flag
  peakfull=trecback+12   ! Fehlerflag
  peakret=trecback+16    ! max. Peakwert
  zaehlpos=trecback+24   ! zaehlerposition
RETURN
'
> PROCEDURE maschrufb5
  .| Glob. Var.: demo#,mdat%,fastrec#,sad%,over#,flen#,sbd%,playfifolen#,scd%
  .|     handle#,sdd%,playpos#,sectors#,sed%,sfd%,sgd%,l#,shd%,sid%,midiwort#
  .|     sjd%,adr#,skd%,sld%,wback%,a#,t#,fxlen#,b2#,nr#,smpedit&,virtual#
  .|     sret#,sloop#,back%,back2%,back3%,hsec2#,hsec#,smpsec&,a$,b#,sec$
  .|     mdat2%
  .| Ruft auf  : busy_mouse,intzeiger1,htimeset,textfeld,intzeiger2,mousek
  .|     intzeiger3
  .| Aufruf in : newfsel-2,trakforw-2,trkbackw-2,virtual-1,mforw-2,mbackw-2,
  LOCAL p,b$,g
  ' HARDDISK-PLAY second generation (ersetzt wie maschruf5c)
  '
  IF (nr=cuelist& AND cntstrt=0) OR nr<>cuelist& THEN
    cntstrt=0
  ENDIF
  back%=0
  back3%=0
  vdig24=dig24
  hdp=TRUE
  IF virtual=FALSE THEN
    kms=0
  ELSE
    kms=sms
  ENDIF
  '
  IF kms>0 THEN
    IF sms2=0 AND kms=1 THEN
      kms=0
    ENDIF
  ENDIF
  '
  exfill=FALSE
  firstp=FALSE
  IF dspuse=TRUE THEN
    @dspplay2
    '    PAUSE 20
  ENDIF
  IF demo=FALSE AND sectors>0 THEN
    g=8
    IF adder>mbit OR adder<(-mbit*2) THEN
      g=128
    ENDIF
    mb=flen*maxhdsec
    mb=INT(mb/mbit)*mbit
    '
    IF blkrmax=TRUE THEN  ! maxium blocksize ?
      mb=1
      g=meml
    ENDIF
    '
    @playinit
    '
    IF blkrmax=TRUE THEN  ! maxium blocksize ?
      mb=meml1
    ENDIF
    '
    allcount=0
    IF dspuse=TRUE THEN
      sea%=&H800-1            ! war vorher &H1000-1
    ENDIF
    v=GEMDOS(66,L:playpos,handle,0)     ! SEEK
    endcount=sectors-head
    IF nr=cuelist& THEN
      @cuenext2
      IF cueplay=TRUE THEN
        endcount=cuemaxfound
      ELSE
        endcount=sectors
      ENDIF
    ENDIF
    endcount=INT(endcount/mbit)*mbit
    allcount=endcount
    '
    allcountm=allcount
    posgrenz=allcountm
    posgrenz=allcountm
    posloop=0
    '
    @fillpmem
    @maus_player
    back%=cntstrt
    @show_timepos_hd
    IF nr=smpedit& THEN
      @textfeld(smprate&,"0"+CHR$(0),1)
    ENDIF
    IF nr=peak& THEN
      IF sblock=0 THEN
        v=endcount
      ELSE
        v=endcount+playpos-head
      ENDIF
      hsec=INT(v/hz/mbit*100)
      @htimeset
      IF bigtxt=FALSE THEN
        @textfeld(peakmax&,a$,1)
      ELSE
        @bigtext(nr,a$,0)
      ENDIF
      @textfeld(recerror&,"0"+CHR$(0),1)
      @textfeld(recpeaks&,"0"+CHR$(0),1)
    ENDIF
    IF XBIOS(xbs,1)=&H71273800 THEN
      IF dspuse=FALSE THEN
        IF pmo8=FALSE THEN
          IF (nr=smpedit& OR nr=arranger&) AND recpkc=FALSE THEN
            ~XBIOS(xbs,153,1)
          ENDIF
          recback=XBIOS(xbs,141,0,L:saa%,L:saa2%,L:saa2%-saa%,L:cntstrt,L:endcount,sfila%,sca%,sda%)   ! mit peaks
        ELSE
          recback=XBIOS(xbs,141,2,L:saa%,L:saa2%,L:saa2%-saa%,L:cntstrt,L:endcount,sfila%,sca%,sda%)
          ~XBIOS(xbs,27,2)
          ~XBIOS(xbs,72,14)
          '
          ~XBIOS(&H8B,0,2,0,0,0)
          ~XBIOS(&H8B,1,8,0,0,0)
          '
        ENDIF
        PAUSE 5
        IF pwait=FALSE THEN
          IF mtc=TRUE THEN
            @wait_mtc
          ENDIF
          @write_int(1)
        ELSE
          intnr=1
          @pausewait
        ENDIF
      ELSE
        ~XBIOS(xbs,55,0)
        @write_int(0)
        ~XBIOS(&H8B,0,2,0,clk,1)
        ~XBIOS(&H8B,1,8,0,clk,1)
        IF (nr=smpedit& OR nr=arranger&) AND recpkc=FALSE THEN
          ~XBIOS(xbs,153,1)
        ENDIF
        recback=XBIOS(xbs,141,1,L:saa%,L:saa2%,L:saa2%-saa%,L:cntstrt,L:endcount,sfila%,sca%,sda%)
        ~XBIOS(xbs,74)
        ~XBIOS(xbs,73,0)
        ~XBIOS(xbs,55,1)
      ENDIF
      pkreq=XBIOS(xbs,150)               ! peak-request Adresse holen
      intplay=TRUE
      t=TIMER
      peaktime=t
      peakint=FALSE
      REPEAT
      UNTIL @mousek=0
      wleer=0
      peakret=recback+16    ! max. Peakwert
      peakexit=recback+8    ! Break-Flag
      peakfull=recback+12   ! Fehlerflag
      zaehlpos=recback+24   ! zaehlerposition
      IF nr=smpedit& AND virtual=TRUE THEN
        @intzeiger1(playpos)
      ENDIF
      '
      peaks=0
      peaks2=0
      REPEAT
        IF exfill=FALSE THEN
          @fillpmem
        ELSE
          @zeigtime
          @peakbreak
          IF BTST(em,0) AND ascii|=32 THEN
            @keymarkers
          ENDIF
        ENDIF
        k=@mousek
      UNTIL back3%=1 OR k=3 OR k=2
      intplay=FALSE
      @write_int(0)
      IF dspuse=TRUE THEN
        ~XBIOS(xbs,55,0)
        ~XBIOS(xbs,73,0)
        ~XBIOS(xbs,74)
        ~XBIOS(&H8B,0,2,0,clk,1)
        ~XBIOS(&H8B,3,11,0,clk,1)
      ENDIF
      IF nr=smpedit& THEN
        IF virtual=TRUE THEN
          @intzeiger3
        ENDIF
        IF bigfoot=TRUE THEN
          hsec=0
          @htimeset
          @textfeld(editime&,a$,1)
        ELSE
          @textfeld(smpsec&,sec$,1)
        ENDIF
      ENDIF
      IF nr=peak& THEN
        @textfeld(recpeaks&,"0"+CHR$(0),1)
        @textfeld(recerror&,"0"+CHR$(0),1)
        @textfeld(peakname&,CHR$(0),1)
      ENDIF
    ENDIF
    IF XBIOS(xbs,1)=&H71273800 AND oldplay=FALSE THEN
      IF demo=FALSE THEN
        back%=LPEEK(zaehlpos)
      ENDIF
    ENDIF
  ENDIF
  hdp=FALSE
  dig24=vdig24
  IF dig24=FALSE THEN
    @setbitrate16
  ELSE
    @setbitrate24
  ENDIF
  exfill=FALSE
  IF (nr=smpedit& OR nr=arranger&) AND recpkc=FALSE THEN
    ~XBIOS(xbs,153,0)
  ENDIF
  ~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE maschruf6
  .| Glob. Var.: demo#,sad%,playfifolen#,sbd%,adr#,scd%,a#,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : monitor-1,
  ' MONITOR
  '
  @maus_player
  IF demo=FALSE AND falcon=FALSE THEN
    @write_int(0)
    IF XBIOS(xbs,1)=&H71273800 THEN
      ~XBIOS(xbs,259)
      a=XBIOS(xbs,110)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE maschruf7
  .| Glob. Var.: demo#,saa%,a#,sba%,b#,sca%,adder#,sda%,l#,sea%,playfifolen#
  .|     sfa%,midiwort#,sga%,adr#,sha%,wback%,sia%,mdat%,t#,meml#,nr#,smpedit&
  .|     back%,back2%,back3%,hsec2#,hsec#,smpsec&,a$,sec$,mdat2%
  .| Ruft auf  : busy_mouse,digout,intzeiger1,htimeset,textfeld,intzeiger2
  .|     mousek,intzeiger3
  .| Aufruf in : smpplay-2,smppmhlp-2,
  LOCAL b$
  ' RECPLAY
  '
  @maus_player
  IF demo=FALSE THEN
    @digout(TRUE)
    saa%=ar
    saap%=ar+24576
    sba%=ar+lr-mbit
    sca%=sth
    sda%=0
    sea%=recfifolen/8-1
    sga%=adr+&H40
    sha%=adr+&H100-1
    sia%=adr+&H280-1
    IF XBIOS(xbs,1)=&H71273800 THEN
      IF dig24=FALSE THEN
        a2=XBIOS(xbs,121,0,L:saa%,L:sba%)
        a=XBIOS(xbs,123,0,L:saap%,L:sba%,L:0,0,0)
      ELSE
        a2=XBIOS(xbs,121,2,L:saa%,L:sba%)
        a=XBIOS(xbs,123,0,L:saap%,L:sba%,L:0,0,0)
      ENDIF
      PAUSE 5
      IF mtc=TRUE THEN
        @wait_mtc
      ENDIF
      @write_int(3)
      t=TIMER
      b=mbit*INT((saa%-meml)/mbit)
      IF nr=smpedit& THEN
        @intzeiger1(b)
        @textfeld(smprate&,"0"+CHR$(0),1)
      ENDIF
      REPEAT
      UNTIL @mousek=0
      wleer=0
      REPEAT
        back%=LPEEK(a)           ! Returnwert play
        back2%=LPEEK(a2)        ! Returnwert rec
        back3%=LPEEK(a+8)        ! Break play
        back4%=LPEEK(a2+8)       ! Break rec
        wleer2=LPEEK(a+12)       ! Fehler play
        wleer3=LPEEK(a2+12)       ! Fehler rec
        hsec2=INT((TIMER-t)/2)
        IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
          hsec=hsec2
          @htimeset
          IF nr=smpedit& THEN
            IF bigfoot=TRUE THEN
              IF flicker=TRUE THEN
                VSYNC
              ENDIF
              @textfeld(editime&,a$,1)
            ELSE
              @textfeld(smpsec&,a$,1)
            ENDIF
            IF wleer3<>wleer THEN
              wleer=wleer3
              b$=STR$(wleer)+CHR$(0)
              @textfeld(smprate&,b$,1)
            ENDIF
            b=mbit*INT((back%-meml)/mbit)
            @intzeiger2(b)
          ENDIF
        ENDIF
        k=@mousek
        ~FRE(0)
        @peakbreak
        IF BTST(em,0) AND ascii|=32 THEN
          @keymarkers
        ENDIF
      UNTIL back4%=1 OR back3%=1 OR k=3 OR k=2
      @write_int(0)
      @digout(FALSE)
      cached=FALSE
      IF nr=smpedit& THEN
        @intzeiger3
        IF bigfoot=TRUE THEN
          hsec=0
          @htimeset
          @textfeld(editime&,a$,1)
        ELSE
          @textfeld(smpsec&,sec$,1)
        ENDIF
      ENDIF
      ~XBIOS(&H8B,0,0,0,clk,1)
      ~XBIOS(&H8B,1,0,0,clk,1)
      ~XBIOS(&H8B,3,11,0,clk,1)
    ENDIF
  ELSE
    back%=0
    back2%=0
  ENDIF
RETURN
'
> PROCEDURE peakbreak2
  LOCAL mx,my,mb,shift&,r%,c,ky
  IF nr=peak& OR nr=smpedit& OR nr=trakker& OR nr=arranger& THEN
    em=EVNT_MULTI(&X100011,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mb,shift&,ky,c)
    IF BTST(em,1) THEN
      mb=1
    ENDIF
    IF BTST(em,0) THEN
      ascii|=BYTE(ky)                                  ! ASCII-Code
      scan|=BYTE(SHR(ky,8))                            ! SCAN-Code
      @shortcuts2
    ELSE
      IF mb=1 THEN
        r%=rsc_adr%(nr)
        obj=OBJC_FIND(r%,0,100,mx,my)
        @breakstop
        @breakwait
      ENDIF
    ENDIF
  ENDIF
  IF rsc_mtsk!=TRUE THEN
    '    @winhandler
  ENDIF
RETURN
'
> PROCEDURE fillrmem
  LOCAL i,membl,bw,memz
  IF recp=FALSE THEN
    brkex2=FALSE
  ENDIF
  @zeigtime2
  '
  IF memf=1 AND vmemf=0 THEN
    IF rch4=FALSE THEN
      membl=rmeml1/rmb
      memz=rmems1
    ELSE
      '      membl=dis1/rmb
      rmb=dis1
      membl=1
      '
      memz=nsaa%
      memz2=dsaa%
    ENDIF
    FOR i=1 TO membl
      @zeigtime2
      bw=GEMDOS(64,rhandle,L:rmb,L:memz)
      IF rch4=TRUE THEN
        bw2=GEMDOS(64,dhandle,L:rmb,L:memz2)
      ENDIF
      IF bw=rmb THEN
        memz=memz+bw
        IF rch4=TRUE THEN
          memz2=memz2+bw
        ENDIF
        rmlen=rmlen-bw
      ELSE
        rmlen=0
      ENDIF
      IF recp=FALSE THEN
        @peakbreak2
        IF BTST(em,0) AND ascii|=32 THEN
          @keymarkers
        ENDIF
      ENDIF
      IF rmlen<=0 THEN
        exfill2=TRUE
        back3%=1
      ENDIF
      '      EXIT IF exfill2=TRUE
      IF exfill2=TRUE AND brkex2=FALSE THEN
        @setbutton(ed_obj,0)
        brkex2=TRUE
      ENDIF
      EXIT IF exfill=TRUE
    NEXT i
    vmemf=memf
  ENDIF
  IF memf=0 AND vmemf=1 THEN
    IF rch4=FALSE THEN
      membl=rmeml2/rmb
      memz=rmems2
    ELSE
      '      membl=dis2/rmb
      rmb=dis2
      membl=1
      '
      memz=nsaa2%
      memz2=dsaa2%
    ENDIF
    FOR i=1 TO membl
      @zeigtime2
      bw=GEMDOS(64,rhandle,L:rmb,L:memz)
      IF rch4=TRUE THEN
        bw2=GEMDOS(64,dhandle,L:rmb,L:memz2)
      ENDIF
      IF bw=rmb THEN
        memz=memz+bw
        IF rch4=TRUE THEN
          memz2=memz2+bw
        ENDIF
        rmlen=rmlen-bw
      ELSE
        rmlen=0
      ENDIF
      IF recp=FALSE THEN
        @peakbreak2
        IF BTST(em,0) AND ascii|=32 THEN
          @keymarkers
        ENDIF
      ENDIF
      IF rmlen<=0 THEN
        exfill2=TRUE
        back3%=1
      ENDIF
      '      EXIT IF exfill2=TRUE
      IF exfill2=TRUE AND brkex2=FALSE THEN
        @setbutton(ed_obj,0)
        brkex2=TRUE
      ENDIF
      EXIT IF exfill=TRUE
    NEXT i
    vmemf=memf
  ENDIF
  IF recp=FALSE THEN
    @peakbreak2
    IF BTST(em,0) AND ascii|=32 THEN
      @keymarkers
    ENDIF
  ENDIF
  IF exfill2=TRUE THEN
    exfill=TRUE
    back3%=1
  ENDIF
  IF rmlen>0 AND exfill=TRUE THEN
    @zeigtime2
    IF (membl-i)>0 THEN
      @setbutton(ed_obj,0)
      bw=GEMDOS(64,rhandle,L:rmb*(membl-i),L:memz)
      IF rch4=TRUE THEN
        bw2=GEMDOS(64,dhandle,L:rmb*(membl-i),L:memz2)
      ENDIF
      IF bw=rmb*(membl-i) THEN
        memz=memz+bw
        IF rch4=TRUE THEN
          memz2=memz2+bw
        ENDIF
        rmlen=rmlen-bw
      ELSE
        rmlen=0
      ENDIF
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE zeigtime2
  IF demo=FALSE THEN
    back%=LPEEK(recback+24) ! ZÑhlbyte
    IF back3%=0 THEN
      back3%=LPEEK(peakexit)  ! Breakflag
    ENDIF
    back4%=LPEEK(recback)   ! Recbyte
    memf=LPEEK(recback+4)  ! Memflag
    wleer2=LPEEK(peakfull)  ! Fehlerflag
  ENDIF
  point=INT(back%)
  '
  IF dighead=TRUE AND falcon=FALSE AND ad=0 AND dig24=TRUE AND rch4=FALSE AND rmo8=FALSE AND dspuse=FALSE THEN            ! Digital Data ?
    ustart=XBIOS(xbs,151) ! Userblock DAT-Startmarke Adresse
    IF ustart<>0 AND ustart<>ustartp THEN
      ustartp=ustart
      point=INT(ustartp-meml-(recfifolen*4))
      IF point<0 THEN
        point=0
      ENDIF
      @keymarkers
    ENDIF
  ENDIF
  '
  IF brkex2=FALSE THEN
    hsec2=INT((TIMER-t)/2)
    IF INT(hsec2/4)<>INT(hsec/4) THEN    ! ums langsamer zu machen !
      hsec=INT(back%/hz/mbit*100)
      @htimeset
      hsec=hsec2
      IF nr=smpedit& THEN
        IF bigfoot=TRUE THEN
          IF flicker=TRUE THEN
            VSYNC
          ENDIF
          @textfeld(editime&,a$,1)
        ELSE
          @textfeld(smpsec&,a$,1)
        ENDIF
        IF wleer2<>wleer THEN
          wleer=wleer2
          b$=STR$(wleer)+CHR$(0)
          @textfeld(smprate&,b$,1)
        ENDIF
        @maketime
      ENDIF
      IF nr=peak& THEN
        IF bigtxt=FALSE THEN
          IF flicker=TRUE THEN
            VSYNC
          ENDIF
          @textfeld(peakpos&,a$,1)
        ELSE
          @bigtext(nr,a$,1)
        ENDIF
        IF wleer2<>wleer THEN
          wleer=wleer2
          b$=STR$(wleer)+CHR$(0)
          @textfeld(recerror&,b$,1)
        ENDIF
        IF peaks2<>peaks THEN
          peaks=peaks2
          b$=STR$(peaks)+CHR$(0)
          @textfeld(recpeaks&,b$,1)
        ENDIF
        @peakrec
      ENDIF
      IF nr=trakker& THEN
        @edhandler5(mbit)
      ENDIF
      IF nr=arranger& THEN
        @edhandler4
      ENDIF
      '
      @makesmpte(point)
      '
    ENDIF
  ENDIF
  ~FRE(0)
RETURN
'
> PROCEDURE hearfour
  IF demo=FALSE THEN
    @dspbypass
    ~XBIOS(xbs,20,1)   ! Analogeingang benutzen
    ~XBIOS(xbs,23,0)   ! Taktrate vom digitaleingang
    '
    ~XBIOS(xbs,26,1)
    ~XBIOS(&H8B,3,11,0,0,1)
    '
    POKE &HFEFF0441,0
    POKE &HFEFF0441,4
    POKE &HFEFF0441,4
    POKE &HFEFF0441,4
    POKE &HFEFF0441,4
    POKE &HFEFF0481,1+4+32
  ENDIF
RETURN
'
> PROCEDURE beepmaster
  LOCAL bp$,beep,beeph,bpl,bhz
  IF demo=FALSE AND beeper=TRUE AND exfill=FALSE THEN
    bp$=lfw$+"BEEP.S16"+CHR$(0)
    IF EXIST(bp$) THEN
      beep=@malloc(140000,1)     ! Peak-Buffer
      IF beep>0 THEN
        bintnr=intnr
        @write_int(0)
        LPOKE mdat%,0
        ~XBIOS(500,254,L:mdat%)
        @digout(TRUE)
        bhz=hz
        nofliphz=TRUE
        @ad8
        OPEN "I",#5,bp$
        bpl=LOF(#5)-20
        CLOSE #5
        beeph=GEMDOS(61,L:VARPTR(bp$),0) ! open
        ~GEMDOS(66,L:20,beeph,0)        ! seek
        ~GEMDOS(63,beeph,L:bpl,L:beep)  ! read
        ~GEMDOS(62,beeph)               ! close
        recback=XBIOS(xbs,122,0,L:beep,L:beep+bpl,L:0,0,0)  ! fÅr 16bit
        @write_int(1)
        REPEAT
          back%=LPEEK(recback+24)          ! Playbyte
        UNTIL back%=bpl
        @write_int(0)
        @plugcfgset
        hz=bhz
        @fliphz2
        nofliphz=FALSE
        ~MFREE(beep)
        beep=0
        @digout(FALSE)
        IF (nr=peak& OR nr=smpedit& OR nr=arranger& OR nr=trakker&) AND falcon=FALSE THEN
          IF hrd=0 THEN
            IF dspuse=FALSE THEN
              IF nr=peak& THEN
                backlist=XBIOS(xbs,130,0,L:sab%,L:sbb%)
              ELSE
                IF dig24=FALSE THEN
                  backlist=XBIOS(xbs,121,0,L:sab%,L:sbb%)
                ELSE
                  backlist=XBIOS(xbs,121,2,L:sab%,L:sbb%)   ! fÅr 24Bit-Mode
                ENDIF
              ENDIF
            ELSE
              backlist=XBIOS(xbs,130,1,L:sab%,L:sbb%)
            ENDIF
          ELSE
            IF dspuse=FALSE THEN
              IF rmo8=FALSE THEN
                IF rch4=FALSE THEN
                  recback=XBIOS(xbs,140,0,L:saa%,L:saa2%,L:saa2%-saa%,L:rmlen,sfila%,L:peakmem2%)
                ELSE
                  recback=XBIOS(xbs,143,L:nsaa%,L:nsaa2%,L:dsaa%,L:dsaa2%,L:dis1,L:rmlen,sfila%,L:peakmem2%,L:peakmem2%)
                ENDIF
              ELSE
                recback=XBIOS(xbs,140,2,rchmo,L:saa%,L:saa2%,L:saa2%-saa%,L:rmlen,sfila%,L:peakmem2%)
              ENDIF
            ELSE
              recback=XBIOS(xbs,140,1,L:saa%,L:saa2%,L:saa2%-saa%,L:rmlen,sfila%,L:peakmem2%)
            ENDIF
          ENDIF
          peakexit=recback+8    ! Break-Flag
          peakfull=recback+12   ! Fehlerflag
          peakret=recback+16    ! max. Peakwert
          peakmemend=recback+20 ! Ende des Peakmem-Buffers
        ENDIF
        intnr=bintnr
        @write_int(intnr)
      ENDIF
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE maschruf8c
  LOCAL a,b,pe,a$,b$,mdigana
  ' HARDDISK-RECORD Type 2 second generation (ersetzt maschruf8b)
  '
  hdr=TRUE
  kms=0
  back%=0
  back3%=0
  omspos=-1
  vdig24=dig24
  IF rch4=FALSE THEN
    IF dspuse=TRUE THEN
      @dsprec2
    ENDIF
  ELSE
    @dsprec4
    '
    IF demo=FALSE THEN
      ~XBIOS(xbs,26,1)
    ENDIF
  ENDIF
  exfill=FALSE
  exfill2=FALSE
  DEFMOUSE 0
  mausbm=TRUE
  rmlen=sectors       !max. Bytes
  IF recpkc=TRUE THEN
    pbuf2=(INT(rmlen/(128))+128)
    peakmem2%=@malloc(pbuf2,1)     ! Peak-Buffer
  ELSE
    pbuf2=6
    peakmem2%=mdat%+4500     ! Peak-DummyBuffer
  ENDIF
  nopeakmem2=FALSE
  IF peakmem2%<=0 THEN
    nopeakmem2=TRUE
  ENDIF
  IF nopeakmem2=FALSE THEN
    recf$=fil$+CHR$(0)
    recfs=VARPTR(recf$)        !Pfad
    filadr=recfs
    rhandle=GEMDOS(60,L:recfs,0)
    IF rch4=TRUE THEN
      da$=LEFT$(fil$,RINSTR(fil$,".")-1)
      slash=RINSTR(da$,"\")
      IF (LEN(da$)-slash)>6 THEN
        da$=LEFT$(da$,slash)+MID$(da$,slash+1,6)
      ENDIF
      da$=da$+"_B."+RIGHT$(fil$,LEN(fil$)-RINSTR(fil$,"."))
      da$=da$+CHR$(0)
      da=VARPTR(da$)        !Pfad
      dhandle=GEMDOS(60,L:da,0)
    ENDIF
    '
    IF rch4=TRUE THEN
      mdigana=digana
      digana=FALSE
      @makehz
    ENDIF
    @rec_headinit(recf$)
    IF rch4=TRUE THEN
      digana=mdigana
      @makehz
    ENDIF
    '
    IF rhandle>=0 THEN
      bw=GEMDOS(64,rhandle,L:head,L:danf)  ! neu seit 18.5.98,fwrite
      rmb=flen*maxhdsec                 ! sektorgrîûe
      rmb=INT(rmb/mbit)*mbit
      IF recp=FALSE THEN
        rmems1=meml
        rmeml1=INT(((memh-meml)-mbit)/rmb/2)*rmb
      ELSE
        reclen%=&H100000
        recmem%=@malloc(reclen%,1)     ! Peak-Buffer
        rmems1=recmem%
        rmeml1=INT((reclen%-mbit)/rmb/2)*rmb
      ENDIF
      rmeml1=INT(rmeml1/mbit)*mbit
      rmeml2=rmeml1
      rmeme1=rmems1+rmeml1
      rmems2=rmeme1
      rmeme2=rmems2+rmeml2
      saa%=rmems1
      sba%=rmeme1
      saa2%=rmems2
      sba2%=rmeme2
      IF blkrmax=TRUE THEN  ! maxium blocksize ?
        rmb=rmeml1
      ENDIF
      psect%=INT(rmlen/(recfifolen/2))
      IF dspuse=TRUE THEN
        psect%=INT(rmlen/&H1000)      ! war vorher /&H1000
      ENDIF
      IF psect%=0 THEN
        psect%=1
      ENDIF
      sfila%=sfileart
      sea%=recfifolen/8-1
      IF rmo8=TRUE THEN
        sea%=recfifolen/8/4-1
        @setadatr
      ENDIF
      IF dspuse=TRUE THEN
        sea%=&H1000-1
      ENDIF
      IF rch4=TRUE THEN
        sea2%=511
      ENDIF
      sda%=sth
      sga%=adr+&H60
      sha%=adr+&H100-1
      memf=0
      vmemf=0
      recback=mdat%
      back3%=0
      peakexit=recback+8    ! Break-Flag
      peakfull=recback+12   ! Fehlerflag
      peakret=recback+16    ! max. Peakwert
      peakmemend=recback+20 ! Ende des Peakmem-Buffers
      IF rch4=TRUE THEN
        dis1=INT((rmeme1-rmems1)/2)
        dis1=INT(dis1/mbit)*mbit
        dis2=INT((rmeme2-rmems2)/2)
        dis2=INT(dis2/mbit)*mbit
        nsaa%=rmems1
        nsba%=rmems1+dis1
        nsaa2%=rmems2
        nsba2%=rmems2+dis2
        dsaa%=rmems1+dis1
        dsba%=rmems1+dis1+dis1
        dsaa2%=rmems2+dis2
        dsba2%=rmems2+dis2+dis2
      ENDIF
      '
      @maus_player
      IF demo=FALSE THEN
        IF XBIOS(xbs,1)=&H71273800 THEN
          IF recpaus=TRUE THEN
            @write_int(0)
          ENDIF
          IF nr=peak& OR nr=smpedit& OR nr=arranger& OR nr=trakker& THEN
            IF dspuse=FALSE THEN
              IF rmo8=FALSE THEN
                IF rch4=FALSE THEN
                  IF (nr=smpedit& OR nr=arranger&) AND recpkc=FALSE THEN
                    ~XBIOS(xbs,153,1)
                  ENDIF
                  recback=XBIOS(xbs,140,0,L:saa%,L:saa2%,L:saa2%-saa%,L:rmlen,sfila%,L:peakmem2%)
                ELSE
                  '
                  recback=XBIOS(xbs,143,L:nsaa%,L:nsaa2%,L:dsaa%,L:dsaa2%,L:dis1,L:rmlen,sfila%,L:peakmem2%,L:peakmem2%)
                  '
                ENDIF
              ELSE
                recback=XBIOS(xbs,140,2,rchmo,L:saa%,L:saa2%,L:saa2%-saa%,L:rmlen,sfila%,L:peakmem2%)
                '
                ~XBIOS(xbs,72,14)
                ~XBIOS(xbs,27,2)
                ~XBIOS(xbs,26,2)
                IF mixdsp=FALSE THEN
                  ~XBIOS(&H8B,2,1,0,clk,1)
                ELSE
                  IF dspmodemix=FALSE THEN
                    @dspmix8
                  ELSE
                    @dspeffmix8
                  ENDIF
                  ~XBIOS(&H8B,1,1,0,clk,1)
                  ~XBIOS(&H8B,2,2,0,clk,1)    ! Record vom external RDATA (Achtkanal)
                ENDIF
                '
              ENDIF
            ELSE
              ~XBIOS(xbs,55,0)
              @write_int(0)
              IF (nr=smpedit& OR nr=arranger&) AND recpkc=FALSE THEN
                ~XBIOS(xbs,153,1)
              ENDIF
              recback=XBIOS(xbs,140,1,L:saa%,L:saa2%,L:saa2%-saa%,L:rmlen,sfila%,L:peakmem2%)
            ENDIF
            peakexit=recback+8    ! Break-Flag
            peakfull=recback+12   ! Fehlerflag
            peakret=recback+16    ! max. Peakwert
            peakmemend=recback+20 ! Ende des Peakmem-Buffers
          ENDIF
          '          PAUSE 5
          IF autorec=FALSE THEN
            '            @fifodel
          ENDIF
          IF nr=smpedit& THEN
            @textfeld(smprate&,"0"+CHR$(0),1)
            hsec=INT(rmlen/hz/mbit*100)
            @htimeset
            IF bigfoot=TRUE THEN
              @textfeld(editime&,a$,1)
            ELSE
              @textfeld(smpsec&,a$,1)
            ENDIF
          ENDIF
          IF nr=peak& THEN
            '            IF rmo8=FALSE THEN
            hsec=INT(rmlen/hz/mbit*100)
            '          ELSE
            '            hsec=INT(rmlen/hz/16*100)
            '          ENDIF
            @htimeset
            IF bigtxt=FALSE THEN
              @textfeld(peakmax&,a$,1)
              hsec=0
              @htimeset
              @textfeld(peakpos&,a$,1)
            ELSE
              @bigtext(nr,a$,0)
              hsec=0
              @htimeset
              @bigtext(nr,a$,1)
            ENDIF
            @textfeld(recerror&,"0"+CHR$(0),1)
            @textfeld(recpeaks&,"0"+CHR$(0),1)
          ENDIF
          IF rch4=FALSE THEN
            IF dspuse=FALSE THEN
              IF mtc=TRUE THEN
                @wait_mtc
              ENDIF
              intnr=2
              IF recpaus=FALSE THEN
                @write_int(2)
              ELSE
                IF nr=peak& THEN
                  obj=peakwait&
                ENDIF
                IF nr=smpedit& THEN
                  obj=smpwait&
                ENDIF
                IF nr=arranger& THEN
                  obj=pause&
                ENDIF
                IF nr=trakker& THEN
                  obj=pause2&
                ENDIF
                @breakwait
                @beepmaster
              ENDIF
            ELSE
              ~XBIOS(xbs,55,0)
              @write_int(0)
              ~XBIOS(xbs,73,0)
              ~XBIOS(xbs,55,1)
              ~XBIOS(xbs,73,1)
            ENDIF
          ELSE
            IF mtc=TRUE THEN
              @wait_mtc
            ENDIF
            intnr=2
            IF recpaus=FALSE THEN
              @write_int(2)
            ELSE
              IF nr=peak& THEN
                obj=peakwait&
              ENDIF
              IF nr=smpedit& THEN
                obj=smpwait&
              ENDIF
              IF nr=arranger& THEN
                obj=pause&
              ENDIF
              IF nr=trakker& THEN
                obj=pause2&
              ENDIF
              @breakwait
              @beepmaster
            ENDIF
            ~XBIOS(xbs,55,0)
            PAUSE 2
            ~XBIOS(xbs,73,0)
            PAUSE 5
            intnr=2
            IF recpaus=FALSE THEN
              @write_int(2)
            ELSE
              IF nr=peak& THEN
                obj=peakwait&
              ENDIF
              IF nr=smpedit& THEN
                obj=smpwait&
              ENDIF
              IF nr=arranger& THEN
                obj=pause&
              ENDIF
              IF nr=trakker& THEN
                obj=pause2&
              ENDIF
              @breakwait
              @beepmaster
            ENDIF
            ~XBIOS(xbs,55,1)
            PAUSE 2
            ~XBIOS(xbs,73,1)
          ENDIF
          intrec=TRUE
          t=TIMER
          peaktime=t
          peakint=FALSE
          REPEAT
          UNTIL @mousek=0
          rfull=0
          peaks=0
          peaks2=0
          '
          @maus_player
          pkreq=XBIOS(xbs,150)               ! peak-request Adresse holen
          '
          IF recp=FALSE THEN
            REPEAT
              IF exfill=FALSE THEN
                @fillrmem
              ELSE
                @zeigtime2
                @peakbreak2
                IF BTST(em,0) AND ascii|=32 THEN
                  @keymarkers
                ENDIF
              ENDIF
              k=@mousek
              @read_digsrate
              IF hzc<>rwert THEN
                @makehz3
              ENDIF
            UNTIL back3%=1 OR k=3 OR k=2
            intrec=FALSE
            @write_int(0)
          ENDIF
          IF dspuse=TRUE OR rch4=TRUE THEN
            ~XBIOS(xbs,55,0)
            ~XBIOS(xbs,73,0)
            ~XBIOS(xbs,74)
          ENDIF
          IF nr=peak& THEN
            @textfeld(recpeaks&,"0"+CHR$(0),1)
            @textfeld(recerror&,"0"+CHR$(0),1)
            @textfeld(peakname&,CHR$(0),1)
          ENDIF
          '
          IF recp=FALSE THEN
            @hrecend
            PAUSE 50
          ENDIF
          '
          IF nr=smpedit& THEN
            IF bigfoot=TRUE THEN
              hsec=0
              @htimeset
              @textfeld(editime&,a$,1)
            ELSE
              @textfeld(smpsec&,sec$,1)
            ENDIF
          ENDIF
          IF nr=trakker& THEN
            @setbutton(ed_obj,0)
          ENDIF
          IF nr=peak& THEN
            a$=SPACE$(11)+CHR$(0)
            IF bigtxt=FALSE THEN
              @textfeld(peakmax&,a$,1)
            ELSE
              @bigtext(nr,a$,0)
            ENDIF
            IF bigtxt=FALSE THEN
              IF flicker=TRUE THEN
                VSYNC
              ENDIF
              @textfeld(peakpos&,a$,1)
            ELSE
              @bigtext(nr,a$,1)
            ENDIF
            @setbutton(ed_obj,0)
            '          rsc_message(smpedit&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
            '          nr=smpedit&
            '          tree&=nr
            '          @markhlp
          ENDIF
        ENDIF
      ENDIF
      IF recp=FALSE THEN
        @hrecend2
        IF rch4=TRUE THEN
          ~GEMDOS(62,dhandle)
          IF demo=FALSE THEN
            IF ad=0 THEN
              @digital
            ELSE
              @analog
            ENDIF
          ENDIF
        ENDIF
        IF rmo8=TRUE AND demo=FALSE THEN
          ~XBIOS(xbs,26,0)
          ~XBIOS(xbs,27,0)
          ~XBIOS(&H8B,3,11,0,clk,1)
          @setadatp
        ENDIF
      ENDIF
    ENDIF
    mausbm=FALSE
  ELSE
    @alerts(3)
  ENDIF
  IF recp=FALSE THEN
    hdr=FALSE
    dig24=vdig24
    IF dig24=FALSE THEN
      @setbitrate16
    ELSE
      @setbitrate24
    ENDIF
  ENDIF
  exfill=FALSE
  IF (nr=smpedit& OR nr=arranger&) AND recpkc=FALSE THEN
    ~XBIOS(xbs,153,0)
  ENDIF
RETURN
'
> PROCEDURE hrecend
  LOCAL a,b,pe,a$
  @setbutton(ed_obj,0)
  IF nopeakmem2=FALSE AND rhandle>=0 AND pstop=FALSE THEN
    IF rch4=FALSE AND recpkc=TRUE THEN
      s=RINSTR(fil$,".")
      a$=LEFT$(fil$,s)+peak$+CHR$(0)
      a=VARPTR(a$)        !Pfad
      pe=LPEEK(peakmemend)
      b=pe-peakmem2%
      IF b>mbit THEN
        phandle=GEMDOS(60,L:a,0)
        a=GEMDOS(64,phandle,L:b,L:peakmem2%)
        ~GEMDOS(62,phandle)
        ~MFREE(peakmem2%)
      ENDIF
    ENDIF
    peakmem2%=0
    '
    IF rmlen>0 THEN
      @zeigtime2
      IF rch4=FALSE THEN
        IF memf=0 THEN
          memz=rmems1
          rmlen=back4%-rmems1
        ELSE
          memz=rmems2
          rmlen=back4%-rmems2
        ENDIF
      ELSE
        IF memf=0 THEN
          memz=nsaa%
          rmlen=back4%-nsaa%
          memz2=dsaa%
        ELSE
          memz=rmems2
          memz2=dsaa2%
          rmlen=back4%-rmems2
        ENDIF
      ENDIF
      membl=INT(rmlen/mbit)*mbit
      @busy_mouse
      bw=GEMDOS(64,rhandle,L:membl,L:memz)
      IF rch4=TRUE THEN
        dbw=GEMDOS(64,dhandle,L:membl,L:memz2)
      ENDIF
      memz=memz+membl
      memz2=memz2+membl
    ENDIF
    mausbm=FALSE
    @rec_header
  ENDIF
RETURN
'
> PROCEDURE hrecend2
  IF nopeakmem2=FALSE AND rhandle>=0 THEN
    ~GEMDOS(62,rhandle)
    IF demo=FALSE THEN
      ~XBIOS(xbs,26,0)
    ENDIF
  ENDIF
RETURN
'
> PROCEDURE adatmoni
  IF demo=FALSE THEN
    '  ~XBIOS(500,26,2)
    POKE &HFEFF0441,0
    POKE &HFEFF0441,4
    POKE &HFEFF0481,36+3
    POKE &HFEFF0441,4
    POKE &HFEFF0481,36+3
    POKE &HFEFF0441,4
    POKE &HFEFF0481,36+1
    POKE &HFEFF0441,0
    POKE &HFEFF0615,3
    '
    POKE &HFEFF0615,3+8
    a=XBIOS(&H86,pt)
  ENDIF
RETURN
'
> PROCEDURE maschruf9(ca,cb)
  .| Glob. Var.: cfa%,cfb%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpmhlp-18,smpcut-8,virtmove-2,sampleinf-1,make-1,trash-1
  .|     setup-1,conspace-2,coninsert-3,memtovirt-1,memtovirt2-1,makeresmp-4,
  ' CUT
  '
  @busy_mouse
  ~XBIOS(xbs,300,L:ca,L:cb)
  '  muster=&H10000
  '  INPUT muster
  ' v=XBIOS(xbs,305,L:ca,L:cb)
  IF nr<>trakker& THEN
    cached=FALSE
  ENDIF
RETURN
'
> PROCEDURE maschruf10(ca,cb,cc,cd)
  .| Glob. Var.: cfa%,cfb%,cfc%,cfd%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpkhlp-5,makeresmp-2,
  ' COPY
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  cfc%=cc
  cfd%=cd
  ~XBIOS(xbs,309,L:cfa%,L:cfb%,L:cfc%,L:cfd%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf11(ca,cb,cc)
  .| Glob. Var.: cfa%,cfb%,cfc%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpkhlp-1,
  ' BACK-COPY
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  cfc%=cc
  ~XBIOS(xbs,311,L:cfa%,L:cfb%,L:cfc%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf12(ca,cb)
  .| Glob. Var.: cfa%,cfb%,wback%,cfc%,mdat2%,back%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : normtest-3,
  ' PEAK-SUCH
  '
  @busy_mouse
  cfa%=ca
  cfb%=cb
  back%=XBIOS(xbs,312,L:cfa%,L:cfb%)
RETURN
'
> PROCEDURE maschruf13(ca,cb,cc,cd)
  LOCAL j,shft
  .| Glob. Var.: cfa%,cfb%,cfc%,cfd%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : makenorm-2,
  ' NORMALIZE
  '
  @busy_mouse
  IF dig24=TRUE THEN
    j=1
    shft=0
    REPEAT
      IF j<cd THEN
        j=j*2
        INC shft
      ENDIF
    UNTIL j>=cd
    cc=INT(j*cc/cd)
    cd=shft
  ENDIF
  cfa%=ca
  cfb%=cb
  cfc%=cc
  cfd%=cd
  ~XBIOS(xbs,313,L:cfa%,L:cfb%,L:cfc%,L:cfd%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf16(a,b,c,d,e,f)
  .| Glob. Var.: saa%,sba%,sca%,sda%,sea%,sfa%,wback%,sga%,mdat2%,back%
  .|     cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : arr_resmp-1,makeresmp-5,
  ' RESAMPLE
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  ' c - destanf
  ' d - destende
  ' e - source-sample-rate (320,441,480)
  ' f - dest-sample-rate (320,441,480)
  ' back% - destende-RETURN-Wert
  '
  saa%=a
  sba%=b
  sca%=c
  sda%=d
  sea%=e
  sfa%=f
  back%=XBIOS(xbs,314,L:saa%,L:sba%,L:sca%,L:sda%,sea%,sfa%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf17(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : mono-3,
  ' MONO
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~XBIOS(xbs,315,L:saa%,L:sba%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf19(a,b,c)
  ' convert 24bit to 16bit
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a*2
  sba%=b
  sca%=c
  IF virtual=FALSE THEN
    sda%=0
  ELSE
    sda%=fileart
  ENDIF
  ~XBIOS(xbs,325,L:saa%,L:sba%,L:sca%,sda%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf20(a,b,c)
  ' convert 16bit to 24bit
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a*2
  sba%=b+a*4
  sca%=c+a*6
  IF virtual=FALSE THEN
    sda%=0
  ELSE
    sda%=fileart
  ENDIF
  ~XBIOS(xbs,324,L:saa%,L:sba%,L:sca%,sda%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf28(start,datalen)
  .| Glob. Var.: sad%,sbd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : smpsave-2,ldhlp-1,
  ' swap (bytes) to wave
  '
  @busy_mouse
  sad%=start
  sbd%=start+datalen
  ~XBIOS(xbs,316,L:sad%,L:sbd%)
RETURN
'
> PROCEDURE maschruf29(start,dest)
  .| Glob. Var.: sad%,sbd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : make-2,
  ' COPYBACK
  '
  @busy_mouse
  sad%=start
  sbd%=dest
  ~XBIOS(xbs,317,L:sad%,L:sbd%)
RETURN
'
> PROCEDURE maschruf30(daten,werte,von,bis)
  .| Glob. Var.: sad%,sbd%,scd%,meml#,sdd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : fade_it-3,
  ' FADE IN&OUT
  '
  @busy_mouse
  sad%=daten
  sbd%=werte
  scd%=INT((meml+von)/mbit)*mbit
  sdd%=INT((meml+bis)/mbit)*mbit
  sed%=INT((sdd%-scd%)/mbit/werte)
  ~XBIOS(xbs,303,L:sad%,sbd%,L:scd%,L:sdd%,L:sed%)
RETURN
'
> PROCEDURE maschruf31
  .| Glob. Var.: virtual#,sac%,i#,sbc%,stp#,vcs#,mdat2%,a#,am#
  .| Aufruf in : curve-2,hardproof2-2,
  ' MITTEL2/Hîchstwert berechnen
  LOCAL p
  '
  IF virtual=FALSE THEN
    sac%=i
    sbc%=i+stp
  ELSE
    sac%=i-vcs
    sbc%=(i+stp)-vcs
  ENDIF
  p=XBIOS(xbs,308,L:sac%,L:sbc%)
  a=LPEEK(p)
  am=LPEEK(p+4)
  IF dig24=TRUE THEN
    a=SHR(a,8)
    am=SHR(am,8)
  ENDIF
RETURN
'
> PROCEDURE maschruf32(ca,cb,cc)
  .| Glob. Var.: cfa%,meml#,cfb%,cfc%,back%,wback%,cfd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : fade_it-4,springart-4,
  ' ZERONO
  '
  @busy_mouse
  cfa%=INT((meml+ca)/mbit)*mbit
  cfb%=INT((meml+cb)/mbit)*mbit
  cfc%=cc
  back%=XBIOS(xbs,302,L:cfa%,L:cfb%,cfc%)
  IF back%>=0 THEN
    back%=INT((back%-meml)/mbit)*mbit
  ENDIF
  IF back%<0 THEN
    back%=-1
  ENDIF
RETURN
'
> PROCEDURE maschruf33(ca,cb,cc)
  .| Glob. Var.: cfa%,meml#,cfb%,cfc%,back%,wback%,cfd%,mdat2%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : springart-4,
  ' ZERO
  '
  @busy_mouse
  cfa%=INT((meml+ca)/mbit)*mbit
  cfb%=INT((meml+cb)/mbit)*mbit
  cfc%=cc
  back%=XBIOS(xbs,318,L:cfa%,L:cfb%,cfc%)
  IF back%<>-1 THEN
    back%=INT((back%-meml)/mbit)*mbit
  ENDIF
  IF back%<0 AND back%<>-1 THEN
    back%=-1
  ENDIF
RETURN
'
> PROCEDURE maschruf34(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : negate-3,
  ' NEGATE
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~XBIOS(xbs,319,L:saa%,L:sba%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf35(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : lrchange-3,
  ' Left/Right-Change LRCHANGE
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~XBIOS(xbs,320,L:saa%,L:sba%)
  cached=FALSE
RETURN
'
> PROCEDURE maschruf36(l,h,l2,h2,hdl,VAR ret)
  .| Glob. Var.: saa%,sba%,sca%,sda%,sea%,mdat2%,mdat3%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : sdsave-2,
  ' Save Mono  SDMONO
  '
  @busy_mouse
  saa%=l
  sba%=h
  sca%=l2
  sda%=h2
  sea%=hdl
  ret=XBIOS(xbs,321,L:saa%,L:sba%,L:sca%,L:sda%,sea%)
RETURN
'
> PROCEDURE maschruf37(l,h,l2,h2,hdl,VAR ret)
  .| Glob. Var.: saa%,sba%,sca%,sda%,sea%,mdat2%,mdat3%
  .| Ruft auf  : busy_mouse
  .| Aufruf in : sdload-2,
  ' Load 2xMono  SDSTEREO
  '
  @busy_mouse
  saa%=l
  sba%=h
  sca%=l2
  sda%=h2
  sea%=hdl
  ret=XBIOS(xbs,322,L:saa%,L:sba%,L:sca%,L:sda%,sea%)
RETURN
'
> PROCEDURE maschruf38(a,b)
  .| Glob. Var.: saa%,sba%,mdat2%,cached#
  .| Ruft auf  : busy_mouse
  .| Aufruf in : sdsave-2,ldhlp-1,
  ' WAVALON
  '
  @busy_mouse
  ' a - sourceanf
  ' b - sourceende
  '
  saa%=a
  sba%=b
  ~XBIOS(xbs,323,L:saa%,L:sba%)
  cached=FALSE
RETURN
' ------------------------------------------------------------------------------
' ------------------------FLYDIALS--------------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE key
  .| Glob. Var.: key&,edit_obj&,cont&,rsc_adr%,next_obj&,idx&,obj&,mrkhandle2#
  .|     v1#,v2#,v3#,ascii|,scan|,a#,shift&,title&,shcut#,nob#,nr#,keytab%,a&
  .|     a$,tree&,evnt&,mb&,mx&,my&
  .| Felder    : rsc_adr%()
  .| Ruft auf  : form_keybd,rsc_shortcut
  .| Aufruf in : rsc_do-1,
  LOCAL bs
  ' Mîchten Sie erweiterte Tastaturkommandos? Dann entREMen Sie
  ' diese Zeile und ersetzen die Prozedur durch:
  '  IF key& AND edit_obj&<>0     ! vorher so....
  IF (key& AND edit_obj&<>0) OR (((key& AND 255)=13) AND ((key& DIV 256)<>50))    ! jetzt so....
    cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  ENDIF
  '  cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  '
  obj&=0
  ~WIND_GET(MENU(4),10,mrkhandle2,v1,v2,v3)
  '  ~WIND_GET(mrkhandle,10,mrkhandle2,v1,v2,v3)
  '
  ascii|=BYTE(key&)                                  ! ASCII-Code
  scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
  a=@rsc_shortcut(dropdown&,scan|,shift&,title&)
  shcut=FALSE
  IF a<>0 THEN
    nob=a
    obj&=a
    shcut=TRUE
  ELSE
    mscan=scan|
  ENDIF
  '
  rsc_adr%=rsc_adr%(nr)
  IF ascii|=0                                        ! Kein ASCII-Code...
    '
    IF scan|=97 OR scan|=98                          ! UNDO/HELP...
      ascii|=ADD(SUB(scan|,97),14)
      mb&=0
      obj&=0
      '
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
      '
      IF BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE IF scan|>=59 AND scan|<=68                  ! F-Tasten...
      ascii|=SUB(scan|,58)
      obj&=0
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
      IF SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE                                             ! ALT+Buchstabe...
      '
      IF scan|>=120 AND scan|<=129                   ! Zahlen...
        SUB scan|,118
        keytab%={XBIOS(16,L:-1,L:-1,L:-1)}           ! ...ohne Shift
      ELSE                                           ! Alles andere...
        keytab%={ADD(XBIOS(16,L:-1,L:-1,L:-1),4)}    ! ...mit Shift
      ENDIF
      '
      ascii|=BYTE{ADD(keytab%,scan|)}                ! ASCII-Code holen
      IF ascii|<>0                                      ! Tastaturbedienbar...
        CLR a&,obj&
        '
        DO WHILE NOT BTST(OB_FLAGS(rsc_adr%,obj&),5) ! Nicht LASTOBJ
          INC obj&
          '
          scan|=BYTE(SHR(OB_TYPE(rsc_adr%,obj&),8))
          IF scan|=26 OR scan|=28                    ! Ein Button/String...
            a$=@rsc_text$(tree&,obj&)                ! ...Text
            '
            a&=INSTR(a$,"[")
            IF a&                                    ! Tastaturbedienbar...
              a&=ASC(MID$(a$,SUCC(a&),1))
              a&=(BCLR(a&,5)=ascii|) OR (a&>=48 AND a&<=57 AND a&=ascii|)
            ENDIF
            '                                        ! '[' vor Zeichen
          ENDIF
          '
        LOOP UNTIL a&                                ! ...gefunden
        '
        IF a&                                        ! Objekt gefunden...
          key&=0                                     ! ...keine Eingabe mehr
          mb&=0
          '                                          ! +SHIFT Circle-Butt?
          IF BTST(shift&,1) AND BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5) AND SHR(OB_TYPE(rsc_adr%,obj&+2),8)=27
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simulieren
            ~OBJC_OFFSET(rsc_adr%,obj&+2,mx&,my&)
            shcut=TRUE
            '                                        ! Ist es ein Popup...
          ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5)
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simul.
            ~OBJC_OFFSET(rsc_adr%,obj&,mx&,my&)
            shcut=TRUE
          ELSE                                       ! ...Button bedienen
            cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
          ENDIF
        ENDIF
        '
      ENDIF
    ENDIF
    '
  ENDIF
  '
  IF next_obj&<>0 AND edit_obj&<>next_obj&
    ~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,3,idx&)  ! ...Eingabe
  ENDIF
  '  obj=obj&
  '
  IF shcut=FALSE AND nr<>virtual& THEN
    @shortcuts
  ENDIF
RETURN
> PROCEDURE vor_update
  nr=a
  @markhlp
  ~WIND_GET(ha1,11,x1,y1,b1,h1)
  CLIP x1,y1,b1,h1
  ~WIND_UPDATE(1)                                    ! BEG_UPDATE
  ~WIND_UPDATE(3)                                    ! BEG_UPDATE
  cupdate=TRUE
RETURN
> PROCEDURE nach_update
  cupdate=FALSE
  ~WIND_UPDATE(0)                                    ! BEG_UPDATE
  ~WIND_UPDATE(2)                                    ! BEG_UPDATE
  CLIP OFF
  nr=mnr
  @markhlp
RETURN
> PROCEDURE message
  .| Glob. Var.: handle&,a&,rsc_trees&,accwindopen#,tree&,rsc_window&
  .|     next_obj&,edit_obj&,idx&,nr#,peak&,peakint#,mx#,my#,mz#,rsc_adr%,n#
  .|     butdirect#,butnr#,donr#,h#,a#,smpedit&,mnr#,cs#,ce#
  .| Felder    : rsc_handle%(),rsc_adr%()
  .| Ruft auf  : markhlp,rsc_message,mouse,button,rsc_redraw_obj,curve
  .|     markprod3
  .| Aufruf in : rsc_do-1,helptxt-2,
  LOCAL iz,a,a&,n,h,ha1,x1,y1,b1,h1
  @markhlp
  handle&=MENU(4)                                    ! ...Fenster-Handle
  '
  FOR a&=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
    EXIT IF handle&=rsc_handle%(a&)
  NEXT a&
  '
  '  IF handle&=rsc_handle%(a&) THEN
  '  mywindow=TRUE
  '  wind_active=a&
  ' ELSE
  '  mywindow=FALSE
  '  wind_active=0
  ' ENDIF
  '
  IF MENU(1)=&H4724 THEN
    accwindopen=TRUE
  ENDIF
  '
  IF MENU(1)=27                                 ! Fenster vergrîûern...
    IF handle&=rsc_handle%(a&) THEN
      tree&=a&
      IF tree&=smpedit& THEN
        xneu=MENU(5)
        yneu=MENU(6)
        bneu=MENU(7)
        hneu=MENU(8)
        @calc_editsize
      ENDIF
      IF tree&=peak& THEN
        xneu2=MENU(5)
        yneu2=MENU(6)
        bneu2=MENU(7)
        hneu2=MENU(8)
        @calc_peaksize
      ENDIF
      IF tree&=trakker& THEN
        xneu3=MENU(5)
        yneu3=MENU(6)
        bneu3=MENU(7)
        hneu3=MENU(8)
        @calc_traksize
      ENDIF
    ENDIF
    winmove=TRUE
    evnt&=0
    prkey=0
    prbut=0
    k=0
    x=0
    y=0
  ENDIF
  IF MENU(1)=23                                 ! Fenster auf volle Grîûe...
    IF handle&=rsc_handle%(a&) THEN
      tree&=a&
      IF tree&=smpedit& THEN
        IF rscw&(tree&)=xwidth AND rsch&(tree&)=ywidth-3 AND bold<>0 AND hold<>0 THEN
          IF bold<>0 AND hold<>0 THEN
            bneu=bold
            hneu=hold
          ENDIF
        ELSE
          xold=rscx&(tree&)
          yold=rscy&(tree&)
          bold=rscw&(tree&)
          hold=rsch&(tree&)
          IF yold<19 THEN
            yold=19
          ENDIF
          IF hold>ywidth-19 THEN
            hold=ywidth-19
          ENDIF
          xneu=0
          yneu=19
          bneu=xwidth
          hneu=ywidth-19
        ENDIF
        @calc_editsize
      ENDIF
      IF tree&=peak& THEN
        IF rsch&(tree&)=ywidth-3 AND bold2<>0 AND hold2<>0 THEN
          IF bold2<>0 AND hold2<>0 THEN
            bneu2=bold2
            hneu2=hold2
          ENDIF
        ELSE
          xold2=rscx&(tree&)
          yold2=rscy&(tree&)
          bold2=rscw&(tree&)
          hold2=rsch&(tree&)
          IF yold2<19 THEN
            yold2=19
          ENDIF
          IF hold2>ywidth-19 THEN
            hold2=ywidth-19
          ENDIF
          xneu2=0
          yneu2=19
          bneu2=xwidth
          hneu2=ywidth-19
        ENDIF
        @calc_peaksize
      ENDIF
      IF tree&=trakker& THEN
        IF rscw&(tree&)=xwidth AND rsch&(tree&)=INT((ywidth-3)/4)*4 AND bold3<>0 AND hold3<>0 THEN
          IF bold3<>0 AND hold3<>0 THEN
            bneu3=bold3
            hneu3=hold3
          ENDIF
        ELSE
          xold3=rscx&(tree&)
          yold3=rscy&(tree&)
          bold3=rscw&(tree&)
          hold3=rsch&(tree&)
          IF yold3<19 THEN
            yold3=19
          ENDIF
          IF hold3>ywidth-19 THEN
            hold3=ywidth-19
          ENDIF
          xneu3=0
          yneu3=19
          bneu3=xwidth
          hneu3=ywidth-19
        ENDIF
        @calc_traksize
      ENDIF
    ENDIF
  ENDIF
  IF MENU(1)=41 OR (MENU(1)=22 AND tree&=a&)         ! AC_CLOSE/Closer...
    MUL rsc_window&,-(MENU(1)=22)
    '
    next_obj&=9999                                   ! ...Exit-Code
    '
    GOTO rsc_dox_ende                                ! ...rsc_do verlassen
    '
  ELSE IF a&>-1 AND NOT (MENU(1)=21 AND a&<>tree&)   ! Ein RSC-Fenster....
    rsc_message(a&,MENU(1),MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    '
  ELSE IF MENU(1)=40 OR MENU(1)=21                   ! AC_OPEN/Anderes Fenster toppen...
    '
    IF a&<>-1 THEN
      IF handle&=rsc_handle%(a&) THEN
        tree&=a&
        IF nr=wmode& THEN
          edit_obj&=0
        ENDIF
        IF nr=smpedit& OR nr=smp16& THEN
          nonhz=hz
        ENDIF
        IF nr=peak& OR nr=info& THEN
          intplay=FALSE
          @write_int(0)
          IF nr=info& THEN
            hz=nonhz
            @fliphz2
            @digout(nbypmode)
          ENDIF
        ENDIF
        nr=tree&
        IF nr=peak& THEN
          peakint=FALSE
          wpl=0   ! peakhold left
          wpr=0   ! peakhold right
          vpl=0
          vpr=0
          prt=-1
          plt=-1
          prw=FALSE
          plw=FALSE
          @peakinit
        ENDIF
        @mouse(mx,my,mz)
        rsc_adr%=rsc_adr%(tree&)
        n=OBJC_FIND(rsc_adr%,0,100,mx,my)
        IF n<>0 AND n<>-1 THEN
          @button
          butdirect=TRUE
          butnr=donr
        ENDIF
        '        @rsc_redraw_obj(nr,0)
      ENDIF
    ENDIF
    '
    rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    @markhlp                ! neu
    IF nr=arranger& THEN
      IF adrag=TRUE THEN
        @setbutton(arrclip&,1)
      ELSE
        @setbutton(arrclip&,0)
      ENDIF
    ENDIF
    IF nr=info& THEN
      nonhz=hz
    ENDIF
    IF nr=trakker& THEN
      wpl=0   ! peakhold left
      wpr=0   ! peakhold right
      vpl=0
      vpr=0
      prt=-1
      plt=-1
      prw=FALSE
      plw=FALSE
      @tpeakinit
      @trakvolinit
      IF tdrag=TRUE OR trdrag=TRUE THEN
        @setbutton(trakclip&,1)
      ELSE
        @setbutton(trakclip&,0)
      ENDIF
      IF hz<>thz THEN
        thz=hz
        IF trkz>0 THEN
          @wischwasch
          @timeline
          @tractdraw
        ENDIF
      ENDIF
    ENDIF
    IF nr=cuelist& THEN
      IF tedart<>cted OR cuehz<>hz OR cdig24<>dig24 THEN
        @cueshow
      ENDIF
    ENDIF
    IF nr=arranger& THEN
      IF vhz<>hz THEN
        vhz=hz
        @arrnrset
      ENDIF
    ENDIF
    IF nr=smpedit& THEN
      IF dig24=FALSE THEN
        IF bigfoot=TRUE THEN
          a$=@rsc_text$(popups&,bitp16&)
          @textfeld(resolu&,a$,1)
        ELSE
          @textfeld(resolu&,"16 BIT"+CHR$(0),1)
        ENDIF
      ELSE
        IF bigfoot=TRUE THEN
          a$=@rsc_text$(popups&,bitp24&)
          @textfeld(resolu&,a$,1)
        ELSE
          @textfeld(resolu&,"24 BIT"+CHR$(0),1)
        ENDIF
      ENDIF
      IF idrag=TRUE THEN
        @setbutton(flyer&,1)
      ELSE
        @setbutton(flyer&,0)
      ENDIF
      IF hrd=1 THEN
        @setbutton(hard&,1)
      ELSE
        @setbutton(hard&,0)
      ENDIF
      '      IF trkmemr=TRUE THEN
      '      @getmem
      '      trkmemr=FALSE
      '    ENDIF
    ENDIF
    IF nr=smp16& THEN
      @makehz
      @sethertz
    ENDIF
    IF nr=wmode& THEN
      edit_obj&=0
      IF dig24=TRUE THEN
        @hidetree2(recm8&,TRUE)
        @hidetree2(mixdsp&,TRUE)
        @hidetree2(mixdma&,TRUE)
        @setbutton3(mast16&,0,nr)
        @setbutton3(mast24&,1,nr)
        @setbutton3(mixdsp&,0,nr)
        @setbutton3(mixdma&,0,nr)
        @setbutton3(mixcpu&,1,nr)
        matrix=FALSE
        IF rmo8=TRUE THEN
          rmo8=FALSE
          vshading=shading
          shading=TRUE
          dopix=TRUE
          @setrecart
          dopix=FALSE
          shading=vshading
        ENDIF
        mixdsp=FALSE
      ELSE
        @hidetree2(recm8&,FALSE)
        @hidetree2(mixdsp&,FALSE)
        @hidetree2(mixdma&,FALSE)
        @setbutton3(mast24&,0,nr)
        @setbutton3(mast16&,1,nr)
      ENDIF
      @setrecart2
    ENDIF
    IF nr=peak& THEN
      wpl=0   ! peakhold left
      wpr=0   ! peakhold right
      vpl=0
      vpr=0
      prt=-1
      plt=-1
      prw=FALSE
      plw=FALSE
      @peakinit
      @volinit
      IF hrd=1 THEN
        @setbutton(hardpeak&,1)
      ELSE
        @setbutton(hardpeak&,0)
      ENDIF
      IF adat=TRUE OR rch8=TRUE THEN
        @hidetree(peakch1&,FALSE,peakbox&)
        @hidetree(peakch2&,FALSE,peakbox&)
        @hidetree(peakch3&,FALSE,peakbox&)
        @hidetree(peakch4&,FALSE,peakbox&)
      ELSE
        @hidetree2(peakch1&,TRUE)
        @hidetree2(peakch2&,TRUE)
        @hidetree2(peakch3&,TRUE)
        @hidetree2(peakch4&,TRUE)
        @rsc_redraw_obj(nr,0)
        IF rchmo=0 THEN
          @setbutton(peakch1&,1)
        ENDIF
        IF rchmo=1 THEN
          @setbutton(peakch2&,1)
        ENDIF
        IF rchmo=2 THEN
          @setbutton(peakch3&,1)
        ENDIF
        IF rchmo=3 THEN
          @setbutton(peakch4&,1)
        ENDIF
      ENDIF
    ENDIF
    '
  ELSE IF MENU(1)<>21 AND MENU(1)<>22                ! nicht toppen/schlieûen...
  ELSE                                               ! Nichts zu machen...
    ~BIOS(3,2,7)
  ENDIF
  IF MENU(1)=20 THEN
    mnr=nr
    h=MENU(4)                                    ! ...Fenster-Handle
    FOR a=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
      EXIT IF h=rsc_handle%(a)
    NEXT a
    ha1=h
    IF a<>-1 THEN
      IF a=peak& THEN
        peakint=FALSE
        wpl=0   ! peakhold left
        wpr=0   ! peakhold right
        vpl=0
        vpr=0
        prt=-1
        plt=-1
        prw=FALSE
        plw=FALSE
        @vor_update
        IF b1<>0 AND h1<>0 THEN
          @bigtext2
          REPEAT
            ~WIND_GET(ha1,12,x1,y1,b1,h1)
            IF b1<>0 AND h1<>0 THEN
              CLIP x1,y1,b1,h1
              @bigtext2
            ENDIF
          UNTIL b1=0 OR h1=0
        ENDIF
        @nach_update
        @peakinit
      ENDIF
      IF a=smpedit& THEN
        @vor_update
        IF b1<>0 AND h1<>0 THEN
          @putcsize
          IF memc=0 OR cached=FALSE OR (drawnew2=TRUE AND mnr=smpedit&) THEN
            credraw=TRUE
            @curve(cs,ce)
            @blkupdate
            credraw=FALSE
            IF drawnew2=TRUE AND mnr=smpedit& THEN
              @getcurve
            ENDIF
          ELSE
            @putcurve
          ENDIF
          REPEAT
            ~WIND_GET(ha1,12,x1,y1,b1,h1)
            IF b1<>0 AND h1<>0 THEN
              CLIP x1,y1,b1,h1
              IF memc=0 OR cached=FALSE OR (drawnew2=TRUE AND mnr=smpedit&) THEN
                credraw=TRUE
                @curve(cs,ce)
                @blkupdate
                credraw=FALSE
                IF drawnew2=TRUE AND mnr=smpedit& THEN
                  @getcurve
                ENDIF
              ELSE
                @putcurve
              ENDIF
            ENDIF
          UNTIL b1=0 OR h1=0
        ENDIF
        @nach_update
      ENDIF
      '
      IF a=editfade& THEN
        @vor_update
        IF b1<>0 AND h1<>0 THEN
          @putfsize
          IF memfade=0 OR (drawnew3=TRUE AND mnr=editfade&) THEN
            credraw=TRUE
            IF fadericht=0 THEN
              @infade
            ELSE
              @ausfade
            ENDIF
            IF drawnew3=TRUE AND mnr=editfade& THEN
              @getfade
            ENDIF
            credraw=FALSE
          ELSE
            @putfade
          ENDIF
          REPEAT
            ~WIND_GET(ha1,12,x1,y1,b1,h1)
            IF b1<>0 AND h1<>0 THEN
              CLIP x1,y1,b1,h1
              IF memfade=0 OR (drawnew3=TRUE AND mnr=editfade&) THEN
                credraw=TRUE
                IF fadericht=0 THEN
                  @infade
                ELSE
                  @ausfade
                ENDIF
                IF drawnew3=TRUE AND mnr=editfade& THEN
                  @getfade
                ENDIF
                credraw=FALSE
              ELSE
                @putfade
              ENDIF
            ENDIF
          UNTIL b1=0 OR h1=0
        ENDIF
        @nach_update
      ENDIF
      '
      IF a=trakker& THEN
        wpl=0   ! peakhold left
        wpr=0   ! peakhold right
        vpl=0
        vpr=0
        prt=-1
        plt=-1
        prw=FALSE
        plw=FALSE
        '        tcached=TRUE             ! entfernt seit 13.6.98
        IF hz<>thz AND mnr=trakker& THEN
          thz=hz
          tcached=FALSE
        ENDIF
        @vor_update
        IF b1<>0 AND h1<>0 THEN
          @puttrsize
          IF memtrak=0 OR tcached=FALSE OR (drawnew4=TRUE AND mnr=trakker&) THEN
            credraw=TRUE
            @timeline
            credraw=FALSE
            IF drawnew4=TRUE AND mnr=trakker& THEN
              @gettrak
            ENDIF
          ELSE
            @puttrak
          ENDIF
          REPEAT
            ~WIND_GET(ha1,12,x1,y1,b1,h1)
            IF b1<>0 AND h1<>0 THEN
              CLIP x1,y1,b1,h1
              IF memtrak=0 OR tcached=FALSE OR (drawnew4=TRUE AND mnr=trakker&) THEN
                credraw=TRUE
                @timeline
                credraw=FALSE
                IF drawnew4=TRUE AND mnr=trakker& THEN
                  @gettrak
                ENDIF
              ELSE
                @puttrak
              ENDIF
            ENDIF
          UNTIL b1=0 OR h1=0
        ENDIF
        @nach_update
        @tpeakinit
      ENDIF
    ENDIF
  ENDIF
rsc_dox_ende:
RETURN
> PROCEDURE button
  .| Glob. Var.: mrkhandle2#,mx&,my&,rsc_adr%,nr#,next_obj&,fsel&,fssldbut&
  .|     fsslide&,fsmax#,fsz#,slflg#,arranger&,arrslbut&,arrslide&,slmax#,pbz#
  .|     trakker&,trakxbut&,trakslid&,tmax#,trakkz#,trakybut&,trkvslid&,tymax#
  .|     trakkyz#,virtual&,vslbut&,vslider&,hbg#,hbz#,vhbldstrt#,smplen#,zu%
  .|     edit_obj&,idx&,vblkstrt&,a$,slr#,hbgm#,mt#,vslc#,lslide#,smpedit&
  .|     zoombutt&,mrz#,zoomp#,mrcs#,cs#,mrce#,ce#,zomslide&,zmax#,mrzoom#
  .|     scrlslde&,scrolbut&,scmax#,scrollp#,mrscroll#,scteil#,scrolm#,vmem#
  .|     cached#,scstep#,peak&,cont&,tree&,evnt&,obj&,ob_tail&,rsc_popup&,b$
  .|     popup&,rate&,digana#,mover&,input&,source&,dsp&,rate2&,smp16&
  .|     makerate&,arrmake&,make&,mb&,editfade&,peakmute&,arrm1&,arrm2&,arrm3&
  .|     arrm4&,arrclip&,leave#,v#,v2#,v3#,v4#
  .| Felder    : rsc_adr%(),rscx&(),rscy&(),rscw&(),rsch&()
  .| Ruft auf  : sliding,fsnrset,setbutton,slideupdate,arrnrset,timeline
  .|     blkart,slidelr,textbutt,zoomcalc,scrollinit,setslide,restaura
  .|     rsc_movedial,rsc_text,rsc_popup,rsc_set_cursor,edhandler2
  .| Aufruf in : message-1,rsc_do-2,
  LOCAL popok,dif
  rsc_adr%=rsc_adr%(nr)
  IF next_obj&<>-1 OR rsc_handle%(tree&)>1000 THEN
    IF BTST(evnt&,4) THEN    ! redraw bevor buttondruck in fremdes Fenster gezeichnet wird
      @message
      @wischwasch
    ENDIF
    next_obj&=OBJC_FIND(rsc_adr%,0,100,mx&,my&)
  ENDIF
  IF (nr=peak& OR intactive=FALSE OR NOT (nr=smpedit& OR nr=virtual& OR nr=trakker& OR nr=arranger& OR nr=fsel&)) AND next_obj&<>-1 THEN
    leave=FALSE
    mrkhandle2=WIND_FIND(mx&,my&)
    '  IF mrkhandle=mrkhandle2 THEN
    '  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
    '  IF v<>0 AND kenn=mrkhandle2 THEN
    '
    '                                                  ! String vor Popup...
    IF next_obj&>0
      IF BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND SHR(OB_TYPE(rsc_adr%,next_obj&),8)=28 AND BTST(OB_STATE(rsc_adr%,SUCC(next_obj&)),5)
        ' (TOUCHEXIT, STRING, SUCC: SHADOWED)
        INC next_obj&
      ENDIF
    ENDIF
    '
    IF next_obj&=-1                                    ! Neben die Box...
      IF rsc_mtsk!=FALSE THEN
        '        SOUND 1,15,10,4,10
        '        SOUND 0,0,0,0,0
      ENDIF
      next_obj&=0
    ELSE
      '
      IF nr=dspedit& AND next_obj&=dspslbut& THEN
        IF dspsz2>(dspsmax-dspstep) THEN
          dspsz2=dspsmax-dspstep
        ENDIF
        @sliding2(dspslide&,dspslbut&,dspsmax+2,dspstep,dspsz2,slflg)
        IF slflg=TRUE THEN
          @dsp_butset
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=dspedit& AND next_obj&=dspslide& THEN
        ay&=rscy&(nr)
        @slideupdate2(dspslide&,dspslbut&,ay&+3,dspsmax,mx&,my&,dspstep,dspsz2,slflg)
        IF slflg=TRUE THEN
          @dsp_butset
        ENDIF
        next_obj&=0
      ENDIF
      '
      IF tfselm=TRUE AND nr=fsel& AND next_obj&=fssldbut& THEN
        IF tfsz2>(tfsmax-tfstep) THEN
          tfsz2=tfsmax-tfstep
        ENDIF
        xfsz=tfsz
        @sliding2(fsslide&,fssldbut&,tfsmax+2,tfstep,tfsz2,slflg)
        IF slflg=TRUE THEN
          @clearfsel
          @tfscalc
          IF tmfsz>0 THEN
            tmfsz=tmfsz-xfsz+tfsz
          ENDIF
          @tfsbutset
          @tfsgetsel2
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF tfselm=TRUE AND nr=fsel& AND next_obj&=fsslide& THEN
        ay&=rscy&(nr)
        xfsz=tfsz
        @slideupdate2(fsslide&,fssldbut&,ay&+3,tfsmax,mx&,my&,tfstep,tfsz2,slflg)
        IF slflg=TRUE THEN
          @clearfsel
          @tfscalc
          IF tmfsz>0 THEN
            tmfsz=tmfsz-xfsz+tfsz
          ENDIF
          @tfsbutset
          @tfsgetsel2
        ENDIF
        next_obj&=0
      ENDIF
      '
      IF tfselm=FALSE AND nr=fsel& AND next_obj&=fssldbut& THEN
        IF fsz2>(fsmax-fstep) THEN
          fsz2=fsmax-fstep
        ENDIF
        xfsz=fsz
        @sliding3(fsslide&,fssldbut&,fsmax,fstep,fsz2,slflg)
        IF slflg=TRUE THEN
          @clearfsel
          @fscalc
          IF actfsel>0 THEN
            actfsel=actfsel-xfsz+fsz
            mfsz=actfsel
          ENDIF
          @fsbutset
          @getsel2
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF tfselm=FALSE AND nr=fsel& AND next_obj&=fsslide& THEN
        ay&=rscy&(nr)
        xfsz=fsz
        @slideupdate2(fsslide&,fssldbut&,ay&+3,fsmax,mx&,my&,fstep,fsz2,slflg)
        IF slflg=TRUE THEN
          @clearfsel
          @fscalc
          IF actfsel>0 THEN
            actfsel=actfsel-xfsz+fsz
            mfsz=actfsel
          ENDIF
          @fsbutset
          @getsel2
        ENDIF
        next_obj&=0
      ENDIF
      '
      IF nr=trakker& AND next_obj&=spurybut& THEN
        @sliding(spurslid&,spurybut&,trkvmax-4,5,trkvz,slflg)
        IF slflg=TRUE THEN
          @spurbutt
          @timeline
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      IF nr=trakker& AND next_obj&=spurslid& THEN
        IF bigfoot=FALSE THEN
          @slideupdate(spurslid&,spurybut&,ay&+32,trkvmax-4,mx&,my&,4,5,trkvz,slflg)
        ELSE
          @slideupdate(spurslid&,spurybut&,ay&+42,trkvmax-4,mx&,my&,4,5,trkvz,slflg)
        ENDIF
        IF slflg=TRUE THEN
          @spurbutt
          @timeline
        ENDIF
        next_obj&=0
      ENDIF
      '
      IF nr=arranger& AND next_obj&=arrslbut& THEN
        @sliding(arrslide&,arrslbut&,slmax-3,5,pbz,slflg)
        IF slflg=TRUE THEN
          @arrnrset
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=arranger& AND next_obj&=arrslide& THEN
        @slideupdate(arrslide&,arrslbut&,ay&-33,slmax-3,mx&,my&,4,5,pbz,slflg)
        IF slflg=TRUE THEN
          @arrnrset
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=trakker& AND next_obj&=trakxbut& THEN
        IF dclick=FALSE THEN
          @killpmark2
          IF trakkz2>(tscmax-tscstep) THEN
            trakkz2=tscmax-tscstep
          ENDIF
          @sliding2(trakslid&,trakxbut&,tscmax,tscstep,trakkz2,slflg)
          IF slflg=TRUE THEN
            @timeinit2
            @timeinit3
            @timeline
          ENDIF
        ELSE
          @trkgotime
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      IF nr=trakker& AND next_obj&=trakslid& THEN
        @killpmark2
        IF trakkz2>(tscmax-tscstep) THEN
          trakkz2=tscmax-tscstep
        ENDIF
        IF bigfoot=FALSE THEN
          @slideupdate2(trakslid&,trakxbut&,ax&+1,tscmax,mx&,my&,tscstep,trakkz2,slflg)
        ELSE
          @slideupdate2(trakslid&,trakxbut&,ax&+5,tscmax,mx&,my&,tscstep,trakkz2,slflg)
        ENDIF
        IF slflg=TRUE THEN
          @timeinit2
          @timeinit3
          @timeline
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=trakker& AND next_obj&=zoomxbut& THEN
        @killpmark2
        @sliding(zoomslid&,zoomxbut&,tymax,5,trakkyz,slflg)
        @delcache
        IF slflg=TRUE THEN
          @timeinit6
          trakkz=0
          trakkz2=0
          tmax=trkztop
          @timeinit
          @timeinit3
          @slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
          @setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
          @timeline
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=trakker& AND next_obj&=zoomslid& THEN
        @killpmark2
        IF bigfoot=FALSE THEN
          tzj=1
        ELSE
          tzj=8  ! war 7
        ENDIF
        @slideupdate(zoomslid&,zoomxbut&,ax&+tzj,tymax,mx&,my&,1,5,trakkyz,slflg)
        @delcache
        IF slflg=TRUE THEN
          @timeinit6
          trakkz=0
          trakkz2=0
          tmax=trkztop
          @timeinit
          @timeinit3
          @slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
          @setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
          @timeline
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& THEN
        IF nr=smpedit& AND next_obj&=smpstop& THEN
          @setbutton(obj,1)
          back3%=1
          exfill=TRUE
          PAUSE 2
          @setbutton(obj,0)
          IF nr=peak& THEN
            @textfeld(recpeaks&,"0"+CHR$(0),1)
            @textfeld(recerror&,"0"+CHR$(0),1)
            @textfeld(peakname&,CHR$(0),1)
          ENDIF
          IF nr=fsel& AND obj=fsend& THEN
            fsbreak=TRUE
          ENDIF
        ENDIF
        IF nr=smpedit& AND (next_obj&=smpwait& AND pwait=FALSE AND intactive=TRUE) THEN
          pwait=TRUE
          @write_int(0)
          @setbutton(smpwait&,1)
          @pausewait
          pwait=FALSE
        ENDIF
      ENDIF
      '
      IF nr=smpedit& AND next_obj&=edmbut& THEN
        @sliding(edmslide&,edmbut&,loopz,5,vsms,slflg)
        IF slflg=TRUE THEN
          @edslidemove(vsms+1)
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& AND next_obj&=edmslide& THEN
        IF bigfoot=FALSE THEN
          edj=rsch&(smpedit&)-180
        ELSE
          edj=rsch&(smpedit&)-172
        ENDIF
        vdifb=INT((loopz+1)/50)
        @slideupdate(edmslide&,edmbut&,ay&+edj,loopz,mx&,my&,vdifb,5,vsms,slflg)
        IF slflg=TRUE THEN
          @edslidemove(vsms+1)
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=cuelist& AND next_obj&=cueslbut& THEN
        IF cuesz2>(cuesmax-cuestep) THEN
          cuesz2=cuesmax-cuestep
        ENDIF
        @sliding2(cueslide&,cueslbut&,cuesmax+2,cuestep,cuesz2,slflg)
        IF slflg=TRUE THEN
          @cuemove
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=cuelist& AND next_obj&=cueslide& THEN
        @slideupdate2(cueslide&,cueslbut&,ay&-34,cuesmax,mx&,my&,cuestep,cuesz2,slflg)
        IF slflg=TRUE THEN
          @cuemove
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=mrkfind& AND next_obj&=mrkfbut& THEN
        @sliding(mrkfslid&,mrkfbut&,loopz,5,vedsms,slflg)
        IF slflg=TRUE THEN
          @mrkfslidemove(vedsms+1)
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=mrkfind& AND next_obj&=mrkfslid& THEN
        ay&=rscy&(nr)
        vdifb2=INT((loopz+1)/50)
        @slideupdate(mrkfslid&,mrkfbut&,ay&+51,loopz,mx&,my&,vdifb2,5,vedsms,slflg)
        IF slflg=TRUE THEN
          @mrkfslidemove(vedsms+1)
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=clocks& AND next_obj&=clkbut& THEN
        @sliding(clkslid&,clkbut&,cdivz,5,vcdivsms,slflg)
        IF slflg=TRUE THEN
          @clocklook(vcdivsms+1)
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=clocks& AND next_obj&=clkslid& THEN
        ay&=rscy&(nr)
        @slideupdate(clkslid&,clkbut&,ay&+85,cdivz,mx&,my&,5,5,vcdivsms,slflg)
        IF slflg=TRUE THEN
          @clocklook(vcdivsms+1)
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=virtual& AND next_obj&=vslbut& THEN
        @sliding2(vslider&,vslbut&,lslide,hbreit,hbz,slflg)
        @setbutton(vslbut&,0)
        IF slflg=TRUE THEN
          vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
          ~OBJC_EDIT(zu%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
          edit_obj&=vblkstrt&
          @blkart
        ENDIF
        idx&=LEN(a$)
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=virtual& AND next_obj&=vslider& THEN
        ax&=rscx&(nr)    ! wenn als Dialog
        hbgm=(smplen/mt)       ! Einteilungsanzahl
        @slideupdate2(vslider&,vslbut&,ax&+20,lslide,mx&,my&,hbreit,hbz,slflg)
        IF slflg=TRUE THEN
          vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
          ~OBJC_EDIT(zu%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
          edit_obj&=vblkstrt&
          @blkart
        ENDIF
        idx&=LEN(a$)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& AND next_obj&=zoombutt& THEN
        mrz=zoomp
        mrcs=cs
        mrce=ce
        @sliding(zomslide&,zoombutt&,zmax,16,zoomp,slflg)
        IF slflg=TRUE THEN
          IF mrz<>zoomp THEN
            a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
            @textbutt(zomslide&,zoombutt&,a$,1)
            @zoomcalc
            mrzoom=zoomp
            IF mrcs<>cs OR mrce<>ce THEN
              @scrollinit
              @setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
              mrscroll=scrollp
            ENDIF
          ENDIF
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& AND next_obj&=zomslide& THEN
        mrcs=cs
        mrce=ce
        mrz=zoomp
        IF bigfoot=FALSE THEN
          zj=INT((rscw&(smpedit&)/2)-320)
        ELSE
          zj=INT((rscw&(smpedit&)/2)-505)
        ENDIF
        @slideupdate(zomslide&,zoombutt&,ax&+zj,zmax,mx&,my&,1,16,zoomp,slflg)
        IF slflg=TRUE THEN
          IF mrz<>zoomp THEN
            a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
            @textbutt(zomslide&,zoombutt&,a$,1)
            @zoomcalc
            mrzoom=zoomp
            IF mrcs<>cs OR mrce<>ce THEN
              @scrollinit
              @setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
              mrscroll=scrollp
            ENDIF
          ENDIF
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& AND next_obj&=scrolbut& THEN
        IF dclick=FALSE THEN
          mrcs=cs
          mrce=ce
          mrz=scrollp
          @sliding2(scrlslde&,scrolbut&,scmax,scstep,scrollp,slflg)
          IF slflg=TRUE THEN
            IF scrollp<>mrz THEN
              dif=ce-cs
              cs=scrollp*scteil
              ce=dif+scrollp*scteil
              IF ce>vmem THEN
                cs=vmem-dif
                ce=vmem
              ENDIF
              cs=INT(cs/mbit)*mbit
              ce=INT(ce/mbit)*mbit
              cached=FALSE
              IF mrcs<>cs OR mrce<>ce THEN
                @setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
                mrscroll=scrollp
              ENDIF
              @restaura
            ENDIF
          ENDIF
        ELSE
          edscrolljump
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=smpedit& AND next_obj&=scrlslde& THEN
        mrcs=cs
        mrce=ce
        mrz=scrollp
        sdif=scmax/vmem*(ce-cs)
        @slideupdate3(scrlslde&,scrolbut&,ax&+12,scmax,mx&,my&,scstep,sdif,scrollp,slflg)
        IF slflg=TRUE THEN
          dif=ce-cs
          IF scrollp>mrz THEN
            cs=cs+dif
            ce=ce+dif
          ELSE
            cs=cs-dif
            IF cs<0 THEN
              cs=0
            ENDIF
            ce=cs+dif
          ENDIF
          IF ce>vmem THEN
            cs=vmem-dif
            ce=vmem
          ENDIF
          cs=INT(cs/mbit)*mbit
          ce=INT(ce/mbit)*mbit
          cached=FALSE
          '          scrollp=ROUND(scmax/vmem*cs)
          @setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
          mrscroll=scrollp
          @restaura
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=peak& AND next_obj&=pholdbut& THEN
        @sliding(phldslid&,pholdbut&,16,16,phold,slflg)
        IF slflg=TRUE THEN
          a$=RIGHT$(" "+STR$(phold),2)+CHR$(0)
          @textbutt(phldslid&,pholdbut&,a$,1)
        ENDIF
        @setbutton(next_obj&,0)
        next_obj&=0
      ENDIF
      '
      '
      IF nr=peak& AND next_obj&=phldslid& THEN
        @slideupdate(phldslid&,pholdbut&,ax&+135,16,mx&,my&,1,16,phold,slflg)
        IF slflg=TRUE THEN
          a$=RIGHT$(" "+STR$(phold),2)+CHR$(0)
          @textbutt(phldslid&,pholdbut&,a$,1)
        ENDIF
        next_obj&=0
      ENDIF
      '
      '
      IF nr=trakker& THEN
        IF next_obj&=tpsl& OR next_obj&=tpsr& OR next_obj&=tpel& OR next_obj&=tper& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=strtl& OR next_obj&=strtr& OR next_obj&=lend& OR next_obj&=rend& OR next_obj&=ltime& OR next_obj&=rtime& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=trklevo1& OR next_obj&=trklevo2& OR next_obj&=trklevo3& OR next_obj&=trklevo4& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=trklevu1& OR next_obj&=trklevu2& OR next_obj&=trklevu3& OR next_obj&=trklevu4& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=panl1& OR next_obj&=panl2& OR next_obj&=panl3& OR next_obj&=panl4& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=panr1& OR next_obj&=panr2& OR next_obj&=panr3& OR next_obj&=panr4& THEN
          leave=TRUE
        ENDIF
        IF next_obj&=trkvol& THEN
          leave=TRUE
        ENDIF
      ENDIF
      IF nr<>plugin& AND nr<>peak& AND NOT (nr=trakker& AND leave=TRUE) THEN
        cont&=FORM_BUTTON(rsc_adr%,next_obj&,1,next_obj&)        ! fÅr MagiC weggelassen, macht Probleme
      ENDIF
      ' ------------------------------------------------ Flydial-Ecke
      IF BTST(OB_STATE(rsc_adr%,next_obj&),1)          ! (CROSSED)
        rsc_movedial(tree&,edit_obj&,idx&)             ! ...Dialog verschieben
        '
        next_obj&=0                                    ! Damit der Cursor..
        cont&=1                                        ! ..bleibt wo er ist
        ' ---------------------------------------------- Circle-Button...
      ELSE IF SHR(OB_TYPE(rsc_adr%,next_obj&),8)=27 AND BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),5) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),3))
        ' (G_BOXCHAR, PRED: SHADOWED /NOT DISABLED)
        '
        popok2=TRUE
        IF next_obj&=ratecirc& AND nr=smpedit& THEN
          @testsrate
          IF (adat=TRUE OR digana=FALSE OR (retime=1 AND digana=TRUE AND tstsr=TRUE)) THEN
            popok2=FALSE
          ENDIF
        ENDIF
        IF next_obj&=ratecir2& AND nr=smp16& THEN
          IF (adat=TRUE OR digana=FALSE OR (retime=1 AND digana=TRUE AND tstsr=TRUE)) THEN
            @testsrate
            popok2=FALSE
          ENDIF
        ENDIF
        '
        IF popok2=TRUE THEN
          next_obj&=PRED(next_obj&)                      ! Objektnr. Button
          a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
          evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
          '
          obj&=1
          FOR ob_tail&=1 TO PRED(evnt&)
            obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
          NEXT ob_tail&
          '
          evnt&=SUCC(obj&)
          b$=@rsc_text$(rsc_popup&,evnt&)
          DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
            INC evnt&                                    ! Defaulteintrag
          LOOP
          '
          REPEAT
            INC evnt&                                    ! NÑchster Eintrag...
            IF evnt&>OB_TAIL(rsc_adr%(rsc_popup&),obj&)  ! ...gibt es nicht
              evnt&=SUCC(obj&)                           ! ...dann wieder 1.
            ENDIF
            '                                            ! bis nicht DISABLED
          UNTIL NOT BTST(OB_STATE(rsc_adr%(rsc_popup&),evnt&),3)
          '                                              ! Button Ñndern...
          rsc_text(tree&,next_obj&,@rsc_text$(rsc_popup&,evnt&))
          ~OBJC_DRAW(rsc_adr%,next_obj&,1,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
          popup&=SUB(evnt&,obj&)
          '          REPEAT
          '          ~GRAF_MKSTATE(v,v2,v3,v4)
          '        UNTIL v3=0
          ' ---------------------------------------------- Popup-Menue...
          REPEAT
          UNTIL @mousek=0
        ENDIF
      ELSE IF BTST(OB_STATE(rsc_adr%,next_obj&),5) AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND (NOT BTST(OB_STATE(rsc_adr%,next_obj&),3))
        popok=FALSE
        IF (next_obj&=rate& AND digana=TRUE AND nr=smpedit&) THEN
          @testsrate
          IF adat=FALSE AND ((retime=0 OR (retime=1 AND tstsr=FALSE))) THEN
            popok=TRUE
          ENDIF
        ENDIF
        IF (next_obj&=mover& OR (next_obj&=resolu& AND bigfoot=TRUE)) AND nr=smpedit& THEN
          popok=TRUE
        ENDIF
        IF adat=FALSE AND ((next_obj&=rate2& AND digana=TRUE AND nr=smp16&)) THEN
          @testsrate
          IF (retime=0 OR (retime=1 AND tstsr=FALSE)) THEN
            popok=TRUE
          ENDIF
        ENDIF
        IF ((next_obj&=protect& OR next_obj&=mode& OR next_obj&=emphasis& OR next_obj&=input& OR next_obj&=source& OR next_obj&=dsp&) AND nr=smp16&) THEN
          popok=TRUE
        ENDIF
        IF next_obj&=makerate& AND nr=arrmake& THEN
          popok=TRUE
        ENDIF
        IF next_obj&=frame& AND nr=wmode& THEN
          popok=TRUE
        ENDIF
        IF next_obj&=trkmon& AND nr=trakker& THEN
          popok=TRUE
        ENDIF
        IF next_obj&=setform& AND nr=setup& THEN
          popok=TRUE
        ENDIF
        IF next_obj&=resmpsel& AND nr=resample& THEN
          popok=TRUE
        ENDIF
        IF next_obj&=dspflip& AND nr=dspedit& THEN
          popok=TRUE
        ENDIF
        IF popok=TRUE THEN
          ' (SHADOWED, TOUCHEXIT, NOT DISABLED)
          evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
          obj&=1
          FOR ob_tail&=1 TO PRED(evnt&)
            obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
          NEXT ob_tail&
          ob_tail&=OB_TAIL(rsc_adr%(rsc_popup&),obj&)
          a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
          evnt&=SUCC(obj&)
          DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
            INC evnt&                                    ! Ausrichtung ermitteln
          LOOP UNTIL evnt&>ob_tail&
          '
          IF evnt&<=ob_tail&                             ! Defaulteintrag...
            popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,SUB(evnt&,SUCC(obj&)))
          ELSE                                           ! Sonst ohne...
            IF tree&=smpedit& OR tree&=make& OR tree&=wmode& THEN
              popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,1)
            ENDIF
          ENDIF
          IF popup&=0                                    ! Abbruch...
            cont&=1                                      ! ...weiter geht's
            next_obj&=0                                  ! ...Cursor 'festhalten'
          ENDIF
        ENDIF
        ' ---------------------------------------------- Cursor positionieren
        ' Mîchten Sie den Cursor mit der Maus zeichengenau positionieren?
        ' Dann entREMen Sie diese Zeilen und laden diese Prozedur nach:
      ELSE IF BTST(OB_FLAGS(rsc_adr%,next_obj&),3)
        @rsc_set_cursor(rsc_adr%,mx&,my&,edit_obj&,next_obj&,idx&)
      ENDIF
      '
    ENDIF
    IF cont&=0 OR (next_obj&<>0 AND next_obj&<>edit_obj&)
      ~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
    ENDIF
    ' ENDIF
    ' ENDIF
    IF nr=smpedit& AND mb&<>0 THEN
      @edhandler2
    ENDIF
    IF nr=smpedit& THEN
      IF next_obj&=flyer& AND (edcart2<>0 OR edcart<>0) THEN
        leave=TRUE
      ENDIF
      IF next_obj&=edmnr& AND ((edcart2=0 AND edcart3=0) OR (edcart=1 AND edcart3=1)) THEN
        leave=TRUE
      ENDIF
      IF next_obj&=edmbuts& AND ((edcart2=0 AND edcart3=0) OR (edcart>1 AND edcart<6 AND edcart3=1)) THEN
        leave=TRUE
      ENDIF
      IF next_obj&=edmbute& AND ((edcart2=0 AND edcart3=0) OR (edcart>1 AND edcart<6 AND edcart3=1)) THEN
        leave=TRUE
      ENDIF
      IF next_obj&=edmbuti& AND ((edcart2=0 AND edcart3=0) OR (edcart>1 AND edcart<6 AND edcart3=1)) THEN
        leave=TRUE
      ENDIF
      IF next_obj&=edmbutr& AND ((edcart2=0 AND edcart3=0) OR (edcart>1 AND edcart<6 AND edcart3=1)) THEN
        leave=TRUE
      ENDIF
    ENDIF
    IF nr=editfade& OR nr=peak& OR ((next_obj&=arrm1& OR next_obj&=arrm2& OR next_obj&=arrm3& OR next_obj&=arrm4& OR next_obj&=arrclip&) AND nr=arranger&) THEN
      leave=TRUE
    ENDIF
    IF nr=plugin& AND next_obj&=plgbox1& THEN
      leave=TRUE
    ENDIF
    IF ((next_obj&=trakk1& OR next_obj&=trakk2& OR next_obj&=trakk3& OR next_obj&=trakk4& OR next_obj&=trakclip&) AND nr=trakker&) THEN
      leave=TRUE
    ENDIF
    '    REPEAT
    '    ~GRAF_MKSTATE(v,v2,v3,v4)        ! fÅr MagiC weggelassen,macht Probleme
    '  UNTIL v3=0 OR leave=TRUE
    IF next_obj&=0 AND nr<>editfade& THEN
      next_obj&=-1
    ENDIF
  ENDIF
RETURN
> PROCEDURE rsc_init
  .| Glob. Var.: ap_id&,rsc_aes&,rsc_mtsk!,rsc_alert&,wchar&,hchar&,rsc_vh&
  .|     planes&,deskx&,desky&,deskw&,deskh&,rsc_flyd%,rsc_bitblt%,rsc_obspec%
  .|     rsc_cookie%
  .| Felder    : rsc_adr%()
  .| Aufruf in : HAUPTPROGRAMM-1,
  LOCAL a&
  '
  ' Initialisiert die von den RSC-Routinen benîtigten Variablen...
  '
  ap_id&=APPL_INIT()                         ! Applikations-ID
  '
  rsc_aes&=INT{{ADD(GB,4)}}                  ! AES-Version
  rsc_mtsk!=INT{ADD({ADD(GB,4)},2)}<>1       ! Multitasking?
  rsc_alert&=-1                              ! Noch keine fliegenden Alerts
  '
  CONTRL(6)=GRAF_HANDLE(wchar&,hchar&,a&,a&) ! AES-Handle, Zeichenbreite/Hîhe
  rsc_vh&=V_OPNVWK(1)                        ! Virt.Workst. fÅr Flydials îffnen
  IF rsc_vh&=0
    rsc_vh&=V~H                              ! ...Fehler, dann eben die alte
  ENDIF
  CONTRL(6)=V~H
  '
  INTIN(0)=1
  VDISYS 102,1,0
  planes&=INTOUT(4)                          ! Bitplanes
  '
  ~WIND_GET(0,7,deskx&,desky&,deskw&,deskh&) ! Hintergrundfenster
  ' ------------------------------------------------------ Inline vorbereiten
  INLINE rsc_flyd%,3090
  '
  rsc_bitblt%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,16)})      ! BITBLT-Routine
  rsc_obspec%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,18)})      ! OB_SPEC-Routine...
  rsc_cookie%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,20)})      ! COOKIE-Routine...
  '
  {ADD(rsc_flyd%,22)}=ADD(GB,24)                         ! VDI-Parameterblock
  INT{ADD(rsc_flyd%,26)}=rsc_vh&                         ! Virt. Workstation
  INT{ADD(rsc_flyd%,28)}=wchar&                          ! Zeichenzellenbreite
  INT{ADD(rsc_flyd%,30)}=hchar&                          ! Zeichenzellenhîhe
  ' ------------------------------------------------------
  ' Berechnet den Speicherbedarf einer Bitmap-Grafik...
  DEFFN getsize(w&,h&)=SHL(SHR(ADD(MUL(MUL(SHR(ADD(w&,15),3),h&),planes&),255),8),8)
  '
  ' GegenstÅck zur Prozedur rsc_text: Universelles Objekt-Text auslesen...
  DEFFN rsc_text$(tree&,obj&)=CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}
  '
RETURN
> PROCEDURE rsc_exit
  .| Glob. Var.: rsc_vh&,popup_back%,rsc_userblk%
  .| Aufruf in : goodbye-1,
  '
  CONTRL(6)=rsc_vh&
  VDISYS 38,0,0                              ! vqt_attributes
  IF ABS(INTOUT(0))<>1                       ! Anderer AES-Zeichensatz (MTOS)...
    ~VST_UNLOAD_FONTS(0)                     ! ...freigeben
  ENDIF
  '
  IF rsc_vh&<>V~H                            ! Flydial-Workstation freigeben...
    ~V_CLSVWK()
  ENDIF
  '
  ' Die folgenden Zeilen sind nur im Interpreter relevant und kînnen im
  ' Compilat wegfallen. Tip: Mit dem ERGO!pro-PrÑprozessor ausblenden.
  '
  ~RSRC_FREE()                               ! Resource entfernen
  '
  IF popup_back%
    ~MFREE(popup_back%)                      ! Popup-Hintergrund freigeben
  ENDIF
  '
  IF rsc_userblk%
    ~MFREE(rsc_userblk%)                     ! Userblks freigeben
  ENDIF
  '
RETURN
> FUNCTION rsc_change(trees&,popup&,menu&,alert&)
$F%
.| Glob. Var.: popup_back%,rsc_trees&,rsc_popup&,rsc_menu&,rsc_alert&
.|     rsc_aes&,rsc_vh&,dreidim#,rsc_flyd%
.| Felder    : rsc_adr%(),rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&()
.| Ruft auf  : xrsrc_load,xrsrc_gaddr,rsc_walk_tree
.| Aufruf in : HAUPTPROGRAMM-2,
LOCAL tree&,obj&,font_h&,font_id&,color3d&,a%
popup_back%=0
'
' ------------------------------------------------------
DIM rsc_adr%(trees&),rsc_handle%(trees&)
DIM rscx&(trees&),rscy&(trees&),rscw&(trees&),rsch&(trees&)
'
rsc_trees&=trees&                                      ! Anzahl ObjektbÑume-1
rsc_popup&=popup&                                      ! Popup-Baum
rsc_menu&=menu&                                        ! Dropdown-Baum
rsc_alert&=alert&                                      ! Alert-Baum
' ------------------------------------------------------ Adressen ermitteln
FOR tree&=0 TO trees&
  '
  ~@xrsrc_gaddr(0,tree&,a%)  ! Kompatibel zu den XRSRC-Routinen
  rsc_adr%(tree&)=a%
  IF tree&<>menu&
    ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
  ENDIF
  '
NEXT tree&
' ------------------------------------------------------ Grîûtes Popup
IF popup&>-1
  obj&=1
  WHILE obj&>0
    popup_back%=MAX(popup_back%,@getsize(ADD(OB_W(rsc_adr%(popup&),obj&),21),OB_H(rsc_adr%(popup&),obj&)))
    obj&=OB_NEXT(rsc_adr%(popup&),obj&)
  WEND
  popup_back%=@malloc(popup_back%,7)                   ! Hintergrundpuffer...
  IF popup_back%=0
    RETURN FALSE                                       ! ...nicht geklappt
  ENDIF
ENDIF
' ------------------------------------------------------ Anderer Zeichensatz
IF rsc_aes&>=&H400 OR APPL_FIND("?API")=0              ! Hat APPL_GETINFO()...
  '
  GCONTRL(0)=130
  GCONTRL(1)=1
  GCONTRL(2)=5
  GCONTRL(3)=0
  GCONTRL(4)=0
  GINTIN(0)=0
  '
  GEMSYS                                               ! APPL_GETINFO()
  '
  IF GINTOUT(0)=1                                      ! Hat geklappt...
    font_h&=GINTOUT(1)                                 ! AES-Font Hîhe
    font_id&=GINTOUT(2)                                ! AES-Font ID
    '
    IF ABS(font_id&)<>1 AND GDOS?<>0                   ! Anderer AES-Font...
      V~H=rsc_vh&
      ~VST_LOAD_FONTS(0)                               ! ...Fonts laden
      DEFTEXT ,,,,font_id&
      DEFTEXT ,,,font_h&                               ! ...und einstellen
      V~H=-1
    ENDIF
  ENDIF
ENDIF
' ------------------------------------------------------ 3D-Darstellung
IF rsc_aes&>=&H340                                     ! Ab AES 3.40...
  GCONTRL(0)=48
  GCONTRL(1)=4
  GCONTRL(2)=3
  GCONTRL(3)=0
  GCONTRL(4)=0
  '
  GINTIN(0)=0                                          ! Inquire
  GINTIN(1)=5                                          ! Background
  '
  GEMSYS                                               ! OBJC_SYSVAR()
  '
  IF GINTOUT(0)>0                                      ! Hat geklappt...
    color3d&=GINTOUT(1)                                ! ...3D-Farbe
  ENDIF
ENDIF
IF dreidim=0 OR maxcol=2 THEN
  color3d&=0
ELSE
  color3d&=8
ENDIF
' ------------------------------------------------------
INT{ADD(rsc_flyd%,32)}=color3d&>0                      ! 3D-Darstellung an/aus
INT{ADD(rsc_flyd%,34)}=color3d&                        ! 3D-Farbe
' ------------------------------------------------------
IF @rsc_walk_tree(trees&)
  RETURN TRUE                                          ! alles ok
ENDIF
'
RETURN FALSE                                           ! Error!
ENDFUNC
> FUNCTION rsc_walk_tree(trees&)
$F%
.| Glob. Var.: rsc_userblk%,hchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_instal_userdef
.| Aufruf in : rsc_laden-1,
LOCAL a&,b&,userblk&,tree&,obj&,a%
'
' RSC-Baum durchgehen und userdefs installieren...
'
' ------------------------------------------------------ Userdefs ermitteln
FOR tree&=0 TO trees&
'
obj&=-1
'
REPEAT
  '
  INC obj&
  '
  a&=SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)           ! Es ist ein userdef...
  ADD userblk&,-AND(a&>=17,a&<=22)
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! ...bis LAST_OBJ
'
NEXT tree&
'
rsc_userblk%=@malloc(SHL(SUCC(userblk&),3),7)             ! Userblks(+1) anfordern (*8)
IF rsc_userblk%=0                                      ! Zu wenig Speicher...
RETURN FALSE                                         ! ...Error!
ENDIF
a%=rsc_userblk%                                        ! Merken
' ------------------------------------------------------ ObjektbÑume modifiz.
FOR tree&=0 TO trees&
'
obj&=-1
REPEAT
  '
  INC obj&
  '
  SELECT SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)       ! OB_TYPE
    ' ------------------------------------------------ Flydial-Ecke...
  CASE 17
    rsc_instal_userdef(tree&,obj&,5)
    ' ------------------------------------------------ Button/String...
  CASE 18
    '
    a&=OB_FLAGS(rsc_adr%(tree&),obj&)                ! OB_FLAGS
    b&=BYTE(OB_TYPE(rsc_adr%(tree&),obj&))           ! Alter OB_TYPE
    '
    IF BTST(a&,4)                                    ! Radiobutton...
      rsc_instal_userdef(tree&,obj&,1)
      '                                              ! BUTTON, nicht EXIT
    ELSE IF b&=26 AND (NOT BTST(a&,2))               ! Checkbutton...
      rsc_instal_userdef(tree&,obj&,2)
      '
    ELSE                                             ! Normale EXIT-Buttons...
      '
      IF b&<>28                                      ! Kein STRING...
        a&=SUCC(-BTST(a&,1)-BTST(a&,2)-BTST(a&,6))
        IF a&>1 !EXIT       DEFAULT    TOUCHEXIT
          OB_X(rsc_adr%(tree&),obj&)=SUB(OB_X(rsc_adr%(tree&),obj&),a&)
          OB_Y(rsc_adr%(tree&),obj&)=SUB(OB_Y(rsc_adr%(tree&),obj&),a&)
          OB_W(rsc_adr%(tree&),obj&)=ADD(OB_W(rsc_adr%(tree&),obj&),ADD(a&,a&))
          OB_H(rsc_adr%(tree&),obj&)=SUCC(ADD(OB_H(rsc_adr%(tree&),obj&),ADD(a&,a&)))
        ENDIF                                        ! ...fÅr Redraw grîûer
      ENDIF
      '
      rsc_instal_userdef(tree&,obj&,6)
      '
    ENDIF
    ' ------------------------------------------------ Unterstr. Text...
  CASE 19
    rsc_instal_userdef(tree&,obj&,4)
    OB_FLAGS(rsc_adr%(tree&),obj&)=BSET(OB_FLAGS(rsc_adr%(tree&),obj&),13)
    ' ...OB_FLAG 13 setzen, wird in 'rsc_draw' benîtigt
    ' ------------------------------------------------ Rahmen...
  CASE 20
    rsc_instal_userdef(tree&,obj&,3)
    ' ------------------------------------------------ Niceline...
  CASE 21
    rsc_instal_userdef(tree&,obj&,8)
    ' ------------------------------------------------ Circlebutton...
  CASE 22
    IF hchar&=8 OR hchar&=16                         ! ...nur wenn mîglich
      rsc_instal_userdef(tree&,obj&,7)               ! ...als Bitmap
    ELSE
      OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(27,8),BYTE(OB_TYPE(rsc_adr%(tree&),obj&)))
    ENDIF                                            ! ...sonst Pfeil lassen
    '
  ENDSELECT
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! Bis LAST_OB gesetzt
'
NEXT tree&
'
{rsc_userblk%}=0                                       ! FÅr Nullstrings
rsc_userblk%=a%                                        ! FÅr MFREE() am Ende
'
RETURN TRUE                                            ! Alles OK
ENDFUNC
> PROCEDURE rsc_instal_userdef(tree&,obj&,nr&)
.| Glob. Var.: rsc_userblk%,rsc_flyd%
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_walk_tree-8,
'
' Userdef-Objekt installieren...
'
' nr& bezeichnet eine der folgenden Ausgaberoutinen:
' 1  Radiobutton, rund
' 2  Check-Button
' 3  Rahmen
' 4  Unterstr. Text
' 5  Flydial
' 6  Button
' 7  Circlebutton
' 8  Niceline
'
{rsc_userblk%}=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,SHL(PRED(nr&),1))})
{ADD(rsc_userblk%,4)}=OB_SPEC(rsc_adr%(tree&),obj&)
'
OB_SPEC(rsc_adr%(tree&),obj&)=rsc_userblk%             ! userdef und alter Typ
OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(BYTE(OB_TYPE(rsc_adr%(tree&),obj&)),8),24)
'                                                      ! im oberen Byte
ADD rsc_userblk%,8
'
RETURN
> PROCEDURE rsc_draw(tree&,flag%)
.| Glob. Var.: hchar&,deskx&,desky&,deskw&,deskh&,rsc_window&,rsc_obspec%
.|     rsc_userblk%,mrkhandle#,rsc_list$
.| Felder    : rsc_adr%(),rscx&(),rscy&(),rscw&(),rsch&(),rsc_handle%()
.| Ruft auf  : rsc_menu_ienable,rsc_message,rsc_bitblt
.| Aufruf in : rsc_alert-1,main-1,normalize-1,fade-1,smptime-1,movefrag-1
.|     smpsave-1,blklfrag-1,newfsel-4,sampleinf-2,resample-1,arranger-1
.|     trakker-1,arrsmpr-1,arrdelay-1,arrmname-1,virtual-1,abackup-1
.|     makeaback-1,smpedit-1,blkfunc-1,time_edit-1,make-2,info-1,setupdat-1
.|     conspace-1,memtovirt2-1,midi-1,loopwahl-1,dspwahl-1,peak-1,
LOCAL fly&,title&,obj&,x&,y&,w&,h&,rx&,ry&,rb&,rh&,handle&,a%,rsc_adr%
'
' Stellt einen Dialog auf dem Bildschirm dar...
'
' tree&   : Index des Dialogbaumes
' flag%   : Bitbelegung
'           Bit 0 -> Fensterdialog
'           Bit 1 -> Schlieûfeld
'           Bit 2 -> Bei Fensterdialogen: Sofort zeichnen
'
'  mywindow=TRUE
'  wind_active=tree&
'
IF flag%=0 THEN
fly=TRUE
ELSE
fly=FALSE
ENDIF
rsc_adr%=rsc_adr%(tree&)
' --------------------------------------------------- Titel & Flugecke suchen
DO WHILE NOT (fly&>0 AND title&>0)
INC obj&
IF BTST(OB_STATE(rsc_adr%,obj&),1)                ! Flugecke...
  fly&=obj&
ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),13)          ! Dialogtitel...
  title&=obj&
ENDIF
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
' --------------------------------------------------- Als Fenster-Dialog
IF BTST(flag%,0)
x&=SUCC(rscx&(tree&))
y&=ADD(ADD(rscy&(tree&),SHL(hchar&,1)),5)
w&=SUB(rscw&(tree&),2)
h&=SUB(SUB(rsch&(tree&),SHL(hchar&,1)),5)
'
IF fly&                                           ! Flugecke hidden...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                 ! Rahmen: 1 Pixel auûen...
OB_SPEC(rsc_adr%,0)=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
'
rx&=OR(&X1001,SHL(-BTST(flag%,1),1))              ! Ggf. Schlieûfeld
'
IF tree&=smpedit& OR tree&=peak& OR tree&=trakker& THEN
  IF autoicnfy=0 THEN
    rx&=(rx& OR &H46E4)              !  Fuller,Mover und Rollpfeile (Rollpfeile wegen MagiC)
  ELSE
    rx&=(rx& OR &H6E4)              !  Fuller,Mover und Rollpfeile (Rollpfeile wegen MagiC)
  ENDIF
ENDIF
'
handle&=WIND_CREATE(rx&,deskx&,desky&,deskw&,deskh&)
'    ~WIND_SET(handle&,10,handle&,0,0,0)  ! Fenstertitel setzen
IF handle&>0                                      ! Fenster vorhanden...
  '
  ~WIND_UPDATE(1)                                 ! BEG_UPDATE
  '
  INC rsc_window&                                 ! Anz. offene Fenster+1
  rsc_menu_ienable(FALSE)                         ! MenÅtitel disablen
  '
  IF title&                                       ! Dialogtitel existiert...
    a%=C:rsc_obspec%(L:rsc_adr%,title&)           ! ...Adresse des Titels
  ELSE
    a%=rsc_userblk%                               ! ...sonst Nullstring
  ENDIF
  ~WIND_SET(handle&,2,INT(SWAP(a%)),INT(a%),0,0)  ! Fenstertitel setzen
  mrkhandle=handle&
  '
  ~WIND_CALC(0,&X1001,x&,y&,w&,h&,rx&,ry&,rb&,rh&)! WC_BORDER
  ~WIND_OPEN(handle&,rx&,ry&,rb&,rh&)
  '
  rsc_handle%(tree&)=handle&
  '
  IF BTST(flag%,2)                                ! Sofort zeichnen...
    rsc_message(tree&,20,x&,y&,w&,h&,0,0)         ! ...redrawen
  ENDIF
  '
  ~WIND_UPDATE(0)                                 ! END_UPDATE
  '
ENDIF
ENDIF
' --------------------------------------------------- Als normaler Dialog
IF rsc_handle%(tree&)=0
a%=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
OB_SPEC(rsc_adr%,0)=OR(a%,SHL(2,16))              ! Rahmen: 2 Pixel innen
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'                                                 ! Auûerhalb des Screens...
IF rscy&(tree&)<desky& OR ADD(rscx&(tree&),PRED(w&))>ADD(deskx&,PRED(deskw&)) OR ADD(rscy&(tree&),PRED(h&))>ADD(desky&,PRED(deskh&))
  ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                             ! ...wieder in die Mitte
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
'
rsc_list$=rsc_list$+MKI$(tree&)                   ! Dialog in die Liste aufnehmen
'
rsc_handle%(tree&)=@malloc(@getsize(w&,h&),7)
IF rsc_handle%(tree&)                             ! Hintergrund retten...
  rsc_bitblt(0,0,0,rsc_handle%(tree&),w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
  '
ENDIF
'
IF fly&>0 AND rsc_handle%(tree&)>0               ! Flugecke sichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BCLR(OB_FLAGS(rsc_adr%,fly&),7)
ELSE IF fly&                                     ! unsichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                ! Zeichnen...
~OBJC_DRAW(rsc_adr%,0,9,rscx&(tree&),rscy&(tree&),w&,h&)
ENDIF
'  mrkhandle=WIND_FIND(x&,y&)
rsc_menu_ienable(TRUE)                         ! MenÅtitel disablen
RETURN
> PROCEDURE rsc_menu_ienable(stat!)
.| Glob. Var.: rsc_menu&,rsc_window&,rsc_aes&,rsc_mtsk!,ap_id&
.| Felder    : rsc_adr%(),rscw&()
.| Aufruf in : rsc_draw-1,rsc_back-1,main-1,windows-1,fade-1,arranger-1
.|     trakker-1,abackup-1,makeaback-1,smpedit-3,blkfunc-1,info-1
.|     loopwahl-1,dspwahl-1,
LOCAL obj&,title&,rsc_adr%
'
' Disabled/enabled alle MenÅ-Titel und den 'About...'-MenÅ-Eintrag...
'                                ! Gibt es ein MenÅ..
IF rsc_menu&>-1
'
rsc_adr%=rsc_adr%(rsc_menu&)
'                              ! Objektbreite verÑndern...
IF stat!                       ! Enablen...
  OB_W(rsc_adr%,2)=rscw&(rsc_menu&)
ELSE                           ! Disablen...
  rscw&(rsc_menu&)=OB_W(rsc_adr%,2)
  OB_W(rsc_adr%,2)=OB_W(rsc_adr%,3)
ENDIF
'
obj&=3                         ! Ersten MenÅtitel Åberspringen
'
REPEAT
  INC obj&
  '                            ! G_TITEL...
  IF BYTE(OB_TYPE(rsc_adr%,obj&))=32
    '
    ~MENU_IENABLE(rsc_adr%,obj&,stat!)
    '
    title&=obj&                ! Wird fÅr 'About...' gebraucht
  ENDIF
  '
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
'                              ! 'About...' dis/enablen
~MENU_IENABLE(rsc_adr%,ADD(title&,3),stat!)
'                              ! Unter MultiTOS...
IF (rsc_aes&>=&H400) AND rsc_mtsk!
  ' zzz=MENU_BAR(rsc_adr%,-1)
  ' IF ap_id&=zzz THEN
  ~MENU_BAR(rsc_adr%,1)      ! ...Menu nur neu anzeigen, wenn erlaubt
  ' ENDIF
ELSE                           ! Unter SingleTOS...
  ~MENU_BAR(rsc_adr%,1)        ! ...Menu immer neu anzeigen
ENDIF
'
ENDIF
'
RETURN
> FUNCTION rsc_do(tree&,next_obj&,VAR popup&)
$F%
.| Glob. Var.: obj#,donr#,nr#,edit_obj&,idx&,tim&,mx&,my&,mb&,shift&,c#
.|     shcut#,winh#,smp16&,peak&,editfade&,smpedit&,digana#,xd#,xm#,ce#,cs#
.|     stay1#,stay2#,show#,showdat#,tedart#,hz#,showbdat#,shw$,showxy&
.|     butdirect#,othernr#
.| Felder    : rsc_handle%(),rsc_adr%()
.| Ruft auf  : message,drop,button,key,drop2,edhandler,peakread,fadehandler
.|     maketime,edhandler3,textfeld
.| Aufruf in : rsc_alert-1,windows-1,normalize-1,fade-1,smptime-1
.|     movefrag-1,smpsave-1,blklfrag-1,newfsel-1,sampleinf-1,resample-1
.|     arrsmpr-1,arrdelay-1,arrmname-1,virtual-1,abackup-1,time_edit-1
.|     make-1,setupdat-1,conspace-1,midi-1,
LOCAL a&,handle&,a$,c
LOCAL cont&,ob_tail&,obj&,flags&,rsc_adr%,keytab%
LOCAL ascii|,scan|,evnt&,mc&,key&
'
' Dialog auswerten...
'
obj=0
donr=nr
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(1)                                      ! ...BEG_UPDATE
~WIND_UPDATE(3)                                      ! ...BEG_MCTRL
flags&=&X11                                          ! ...BUTTON/KEYBD-Events
'
ELSE                                                   ! Fenster-Dialog...
flags&=&X110011                                      ! ...zus. MESSAGE-Events
ENDIF
'  IF nr=arranger& AND intplay=TRUE THEN
'  flags&=&X10011                                          ! keine Timer-Events wegen Interrupts
' ENDIF
'
rsc_adr%=rsc_adr%(tree&)
cont&=TRUE
' ------------------------------------------------------ Editierbares Objekt
DO WHILE (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3)) OR BTST(OB_STATE(rsc_adr%,next_obj&),3)
INC next_obj&
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,next_obj&),5)
IF BTST(OB_FLAGS(rsc_adr%,next_obj&),5) AND (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3))
next_obj&=0
ENDIF
' ------------------------------------------------------
'
'  IF cont&<>0 AND (next_obj&<>0 AND edit_obj&=0)             ! Ggf. Cursor setzen...  NEU !!!
IF cont&<>0 AND (next_obj&<>0 AND edit_obj&<>next_obj&)             ! Ggf. Cursor setzen...
edit_obj&=next_obj&                                ! ...Exit-Code zurÅck
next_obj&=0                                        ! ...'rsc_do' verlassen
~OBJC_EDIT(rsc_adr%,edit_obj&,27,idx&,1,idx&)       ! ...Cursor ein
ENDIF
'
next_obj&=0
tim&=20   ! EVENT-TIMER in msec
REPEAT
c=0
evnt&=EVNT_MULTI(flags&,2,1,1,0,0,0,0,0,0,0,0,0,0,0,tim&,mx&,my&,mb&,shift&,key&,c)
IF c=1 THEN
click=TRUE
ELSE
click=FALSE
ENDIF
IF c=2 THEN
dclick=TRUE
ELSE
dclick=FALSE
ENDIF
IF evnt&<>0 THEN
IF donr=nr THEN
  IF BTST(evnt&,4) THEN
    @message
    @drop
    @wischwasch    ! ganz neu !!!!
  ENDIF
  '
  IF BTST(evnt&,5) OR BTST(evnt&,0) OR BTST(evnt&,1) OR prkey<>0 OR prbut<>0 THEN
    @get_specialkeys
  ENDIF
  '
  '
  IF (BTST(evnt&,1) OR BTST(evnt&,5)) AND nr=trakker& AND MENU(1)<>27 THEN
    '
    IF mislide=TRUE THEN
      REPEAT
        @midislide   ! Midi Slidersteuerung
        @midislide3
      UNTIL INP?(3)=FALSE
    ENDIF
    '
    ' Drag & Drop
    IF k=1 THEN
      IF (v4=0 AND trmode=1) AND dclick=FALSE THEN
        @wischwasch
        @searchtrak
        @pmarkhlp2
        IF tfound=TRUE THEN
          @opentrk
        ENDIF
      ENDIF
      IF (v4=4 AND trmode<>5) OR ((v4=4 OR v4=0) AND trmode=5) THEN
        ntrmode=5
        obj=tblkedit&
        @tmarkmode
        obj=0
        @wischwasch
        @searchtrak
        @wischwasch
        IF tfound=TRUE THEN
          nr=smpedit&
          @editselect
          @loadtoedit
          @wischwasch
          '
          ~XBIOS(xbs,27,0)
          IF (pch4=TRUE OR pmo8=TRUE) AND (demo=FALSE OR falcon=TRUE) THEN
            ~XBIOS(&H8B,0,2,0,clk,1)
            ~XBIOS(&H8B,3,11,0,clk,1)
          ENDIF
          IF pmo8=TRUE AND demo=FALSE THEN
            ~XBIOS(xbs,72,14)
          ENDIF
          matrixplay=FALSE
          pch4=FALSE
          pmo8=FALSE
          pch16=FALSE
          '
        ENDIF
      ENDIF
    ENDIF
    IF k=1 OR k=2 THEN
      IF v4=0 OR v4=1 OR v4=2 THEN
        IF trmode=2 OR (v4=0 AND k=2 AND trmode<>6) THEN
          ntrmode=2
          obj=tblkmove&
          @tmarkmode
          obj=0
        ENDIF
        IF (v4=1 OR v4=2) OR (trmode=6 AND ((v4=1 OR v4=2) OR (v4=0 AND (k=1 OR k=2)))) THEN
          IF trmode=6 AND v4=0 AND (k=1 OR k=2) THEN
            IF k=1 THEN
              v4=2
            ELSE
              v4=1
            ENDIF
          ENDIF
          ntrmode=6
          obj=tblksnap&
          @tmarkmode
          obj=0
        ENDIF
        IF trmode=2 OR trmode=6 THEN
          @wischwasch
          @searchtrak
          IF tfound=TRUE THEN
            @opentrk
            @trakmoving
          ENDIF
        ENDIF
      ENDIF
      IF (v4=8 AND trmode<>3) OR (trmode=3 AND (v4=0 OR v4=8)) THEN
        ntrmode=3
        obj=tblkcopy&
        @tmarkmode
        obj=0
        @wischwasch
        @searchtrak
        IF tfound=TRUE THEN
          @opentrk
          @trakcopydrag
        ENDIF
      ENDIF
      IF (v4=12 AND trmode<>4) OR (trmode=4 AND (v4=0 OR v4=12)) THEN
        ntrmode=4
        obj=tblkdrag&
        @tmarkmode
        obj=0
        @searchtrak
        IF tfound=TRUE THEN
          @opentrk
          tdrag2=FALSE
          @trakdrag
        ENDIF
      ENDIF
    ENDIF
    IF just=TRUE AND k=0 THEN
      just=FALSE
      @timeline
    ENDIF
  ENDIF
  '
  IF next_obj&=-1 AND BTST(evnt&,1)=FALSE THEN
    next_obj&=0
  ENDIF
  IF BTST(evnt&,1) THEN
    @button
  ENDIF
  IF BTST(evnt&,0) AND (key&<>7181 OR (next_obj&=0 AND key&=7181)) THEN
    IF nr=trakker& OR nr=record& OR nr=cuelist& THEN
      dropkey=BYTE(SHR(key&,8))                            ! SCAN-Code
      IF ctrlkey=TRUE AND ((nr<>trakker& AND (dropkey=72 OR dropkey=80)) OR (nr=trakker& AND dropkey=50 AND altkey=TRUE)) THEN
        @shortcuts
      ELSE
        dropkey=0
      ENDIF
    ENDIF
    IF nr=virtual& THEN
      ascii|=BYTE(key&)                                  ! ASCII-Code
      scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
      IF ascii|=32 OR ctrlkey=TRUE THEN
        @shortcuts
      ELSE
        @key
      ENDIF
    ELSE
      @key
    ENDIF
    IF obj&<>0 AND mb&=1 THEN
      @button
    ENDIF
    IF obj&<>0 AND shcut=TRUE AND mb&=0 THEN
      @drop2
    ENDIF
  ENDIF
  IF BTST(evnt&,5) AND BTST(winh,smp16&)=TRUE AND nr=smp16& THEN
    @edhandler
  ENDIF
  IF BTST(evnt&,5) AND BTST(winh,info&)=TRUE AND nr=info& THEN
    @nonstop2
  ENDIF
  IF BTST(winh,arranger&)=TRUE AND nr=arranger& AND intplay=TRUE THEN
    @edhandler4
  ENDIF
  IF BTST(evnt&,5) AND nr=mixer& THEN
    IF mislide=TRUE THEN
      REPEAT
        @midislide   ! Midi Slidersteuerung
        @midislide4
      UNTIL INP?(3)=FALSE
    ENDIF
  ENDIF
  IF BTST(evnt&,5) AND nr=peak& THEN
    @peakread
    IF mislide=TRUE THEN
      REPEAT
        @midislide   ! Midi Slidersteuerung
        @midislide2
      UNTIL INP?(3)=FALSE
    ENDIF
    IF peaks2<>peaks THEN
      peaks=peaks2
      b$=STR$(peaks)+CHR$(0)
      @textfeld(recpeaks&,b$,1)
    ENDIF
  ENDIF
  IF BTST(evnt&,5) AND BTST(evnt&,4)=FALSE AND nr=editfade& THEN
    @fadehandler
  ENDIF
  @maketime
  IF BTST(evnt&,5) AND nr=smpedit& THEN
    IF digana=FALSE THEN
      @edhandler3
    ENDIF
    IF mx&>=xd AND mx&<=(xm+xd) AND xm>0 AND ce>cs AND my&>=stay1 AND my&<=stay2 AND show=TRUE THEN
      showdat=(INT((INT((ce-cs)/mbit))/xm*(mx&-xd)))+INT(cs/mbit)
      IF virtual=FALSE THEN
        showert=meml+showdat*mbit
        IF dig24=FALSE THEN
          show$=HEX$(DPEEK(showert))+" "+HEX$(DPEEK(showert+2))+CHR$(0)
        ELSE
          show$=HEX$(PEEK(showert)*&H10000+PEEK(showert+1)*256+PEEK(showert+2))+" "+HEX$(PEEK(showert+3)*&H10000+PEEK(showert+4)*256+PEEK(showert+5))+CHR$(0)
        ENDIF
      ENDIF
      IF tedart=0 THEN
        showdat=showdat/hz
      ENDIF
      IF showbdat<>showdat THEN
        showbdat=showdat
        IF tedart=1 THEN
          a$=STR$(INT(showdat))
          @formatsmp
          shw$=a$+CHR$(0)
        ELSE
          hsec=INT(showdat*100)
          @htimeset
          shw$=a$
        ENDIF
        IF LEN(shw$)>13 THEN
          shw$=LEFT$(shw$,13)+CHR$(0)
        ENDIF
        IF flicker=TRUE THEN
          VSYNC
        ENDIF
        @textfeld(freemem&,show$,1)
        @textfeld(showxy&,shw$,1)
      ENDIF
    ENDIF
  ENDIF
ENDIF
ENDIF
IF mc&=2 AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6)      ! Doppelklick auf
next_obj&=WORD(BSET(next_obj&,15))                   ! TOUCHEXIT...
ENDIF
UNTIL (next_obj&>0 OR donr<>nr OR doexit=TRUE)
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(0)                                      ! END_UPDATE
~WIND_UPDATE(2)                                      ! END_MCTRL
ENDIF
IF donr<>nr AND butdirect=FALSE THEN
next_obj&=0
ENDIF
othernr=FALSE
rsc_do_ende:
RETURN next_obj&
ENDFUNC
> FUNCTION rsc_popup(a!,tree&,button&,popup&,def&)
$F%
.| Glob. Var.: rsc_popup&,hchar&,popup_back%,rsc_vh&,wchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_text
.| Aufruf in : button-2,
LOCAL x&,y&,b&,h&,m!
LOCAL evnt&,mx&,my&,mb&,shift&,key&,mc&,ascii|,scan|
LOCAL obj&,old_obj&,first&,anz&
LOCAL rsc&,rsc_adr%
'
' Popup-MenÅ darstellen und auswerten...
'
' a!       : TRUE: Button verÑndern, FALSE: Nur Popup
' tree&    : Index des Dialogbaumes
' button&  : Objektnr. des betÑtigten Buttons
' popup&   : Index des Popups
' def&     : Default-Eintrag (1-x)
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~WIND_UPDATE(3)                                   ! BEG_MCTRL
'
rsc_adr%=rsc_adr%(rsc_popup&)
'
first&=OB_HEAD(rsc_adr%,popup&)                   ! erster Eintrag
anz&=SUB(OB_TAIL(rsc_adr%,popup&),first&)         ! Anzahl EintrÑge-1
' ------------------------------------------------- Popup positionieren
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)
OB_X(rsc_adr%,0)=SUB(x&,OB_X(rsc_adr%,popup&))
OB_Y(rsc_adr%,0)=MAX(ADD(hchar&,4),MIN(SUB(WORK_OUT(1),4)-OB_H(rsc_adr%,popup&),SUB(y&,MUL(def&,hchar&))))-OB_Y(rsc_adr%,popup&)
'
x&=ADD(OB_X(rsc_adr%,0),PRED(OB_X(rsc_adr%,popup&)))
y&=ADD(OB_Y(rsc_adr%,0),PRED(OB_Y(rsc_adr%,popup&)))
b&=ADD(OB_W(rsc_adr%,popup&),4)
h&=ADD(OB_H(rsc_adr%,popup&),4)
' -------------------------------------------------
'
rsc_bitblt(0,0,0,popup_back%,b&,h&,x&,y&,b&,h&,0,0)
'
~OBJC_DRAW(rsc_adr%,0,7,x&,y&,b&,h&)              ! Popup zeichnen
'
IF a!                                             ! Button verÑndern...
'
~GRAF_MOUSE(256,0)                              ! Hidem
V~H=rsc_vh&                                     ! ...Default-Eintrag mit...
GRAPHMODE 2
'
INTIN(0)=8                                      ! ...HÑkchen versehen
PTSIN(0)=ADD(x&,DIV(wchar&,2))
PTSIN(1)=y&-DIV(hchar&,6)+MUL(SUCC(def&),hchar&)
VDISYS 8,1,1                                    ! ...v_gtext()
'
GRAPHMODE 1
V~H=-1
~GRAF_MOUSE(257,0)                              ! Showm
'
ENDIF
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)      ! Objekt unter der Maus...
'
IF obj&<=0                                        ! Daneben...
obj&=ADD(first&,def&)                           ! ...Default-Eintrag nehmen
ENDIF
'
old_obj&=obj&
IF (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))   ! Nicht disabled...
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
ENDIF                                             ! ...selektieren
'
~EVNT_TIMER(200)
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
IF mb&=1
m!=TRUE
evnt&=4
ENDIF
'
' --------------------------------------------------
DO
'
IF NOT m!
evnt&=EVNT_MULTI(&X111,1,1,1,1,mx&,my&,1,1,0,0,0,0,0,0,0,mx&,my&,mb&,shift&,key&,mc&)
ELSE
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
ENDIF
'
IF BTST(evnt&,0)                                 ! Tastaturereignis...
ascii|=BYTE(key&)
scan|=BYTE(SHR(key&,8))
'                                              ! Noch kein sel. Eintrag...
IF NOT (obj&>=first& AND obj&<=ADD(first&,anz&))
obj&=first&
'
ELSE IF scan|=80                               ! ...Cursor runter
INC obj&
IF obj&>ADD(first&,anz&)
  obj&=first&
ENDIF
'
ELSE IF scan|=72                               ! ...Cursor runter
DEC obj&
IF obj&<first&
  obj&=ADD(first&,anz&)
ENDIF
'
ENDIF
'
ENDIF
'
IF BTST(evnt&,2)                                 ! Mausereignis...
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)
ENDIF
'                                                ! Alten Eintrag deselekt...
IF obj&<>old_obj&
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),1)
ENDIF
'                                                ! Im MenÅ und nicht disabled...
IF (obj&>=first& AND obj&<=ADD(first&,anz&)) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
'                                              ! ...neuen selektieren
old_obj&=obj&
rsc&=SUB(obj&,first&)                          ! RÅckgabe
ENDIF
'
LOOP UNTIL BTST(evnt&,1) OR (mb&<>1 AND m!) OR ascii|=13 OR ascii|=27 OR scan|=97
' --------------------------------------------------
rsc_bitblt(popup_back%,b&,h&,0,0,0,0,0,b&,h&,x&,y&)! Hintergrund restaurieren
'
IF rsc&=SUB(obj&,first&) AND scan|<>97 AND ascii|<>27 ! Eintrag ausgewÑhlt...
'
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,obj&),0),0)
'
IF a!                                            ! Button verÑndern...
'                                              ! Neuen Text eintragen:
rsc_text(tree&,button&,@rsc_text$(rsc_popup&,obj&))
'
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)    ! Button zeichnen
~OBJC_DRAW(rsc_adr%(tree&),button&,1,x&,y&,OB_W(rsc_adr%(tree&),button&),OB_H(rsc_adr%(tree&),button&))
'
ENDIF
'
ELSE                                               ! Daneben => Abbruch...
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),0)
'
rsc&=-1                                          ! ...Abbruch markieren
'
ENDIF
'
REPEAT
~GRAF_MKSTATE(mx&,my&,mb&,shift&)                ! Mausknopf 'entprellen'
UNTIL mb&=0
'
~WIND_UPDATE(2)                                    ! END_MCTRL
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN SUCC(rsc&)
ENDFUNC
> PROCEDURE rsc_message(tree&,message&,x&,y&,w&,h&,edit_obj&,idx&)
.| Glob. Var.: wchar&,hchar&
.| Felder    : rsc_handle%(),rsc_adr%(),rscx&(),rscy&()
.| Ruft auf  : rsc_cursor
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,message-2,rsc_draw-1
.|     rsc_back-1,rsc_redraw_obj-1,main-1,fade-1,arranger-1,trakker-1
.|     blkfunc-1,info-1,loopwahl-1,peak-1,
LOCAL a|,ax&,ay&,ab&,ah&,handle&,obj&,rsc_adr%,a%,a$
'
' Wertet ein innerhalb des 'rsc_do' eingetroffenes Message-Ereignis aus...
'
IF nr<>smpinf& AND nr<>fsel& THEN
handle&=rsc_handle%(tree&)                         ! Fensterhandle des Dialogs
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
SELECT message&
' --------------------------------------------------------------------------
CASE 20,21                                         ! WM_REDRAW/WM_TOPPED
IF message&=20                                   ! WM_REDRAW...
~GRAF_MOUSE(256,0)                           ! Hidem
~WIND_GET(handle&,11,ax&,ay&,ab&,ah&)          ! 1. Rechteck
'
REPEAT
  '
  IF RC_INTERSECT(x&,y&,w&,h&,ax&,ay&,ab&,ah&) ! ...redrawen
    ~OBJC_DRAW(rsc_adr%(tree&),0,7,ax&,ay&,ab&,ah&)
  ENDIF
  '
  ~WIND_GET(handle&,12,ax&,ay&,ab&,ah&)        ! NÑchstes Rechteck...
UNTIL ab&=0 AND ah&=0                          ! ...kein Redraw mehr nîtig
'
~GRAF_MOUSE(257,0)                           ! Showm
'
ELSE                                             ! WM_TOPPED...
~WIND_SET(handle&,10,0,0,0,0)                  ! ...toppen
ENDIF
'
~WIND_GET(0,10,ax&,ay&,ay&,ay&)                  ! Oberstes Fenster...
IF ax&=handle& AND edit_obj&>0                   ! Ist das unsrige...
' ---------------------------------------------- Cursor-Setz-Orgie...
rsc_adr%=rsc_adr%(tree&)
'
obj&=edit_obj&                                 ! Parent ermitteln...
'
REPEAT
  obj&=OB_NEXT(rsc_adr%,obj&)
UNTIL obj&<edit_obj&
'
~OBJC_OFFSET(rsc_adr%,edit_obj&,ax&,ay&)       ! Koordinaten des Objekts
'
a$=CHAR{{ADD(OB_SPEC(rsc_adr%,edit_obj&),4)}}  ! Maske: "Eingabe:______"
ah&=1
WHILE MID$(a$,ah&,1)<>"_"                      ! LÑnge des Vortextes...
  INC ah&
WEND                                           ! ...ermitteln
'
ADD ax&,MUL(wchar&,ADD(PRED(ah&),idx&))        ! Cursor-Position im Pixeln
ah&=ADD(OB_H(rsc_adr%,edit_obj&),6)            ! Cursor ist grîûer hchar&
'                                              ! Cursor lîschen...
~OBJC_DRAW(rsc_adr%,obj&,7,ax&,SUB(ay&,3),wchar&,ah&)
rsc_cursor(rsc_adr%,edit_obj&,idx&)            ! ...und setzen
'
ENDIF
' --------------------------------------------------------------------------
CASE 28                                            ! WM_MOVED
~WIND_CALC(1,&X1001,x&,y&,w&,h&,ax&,ay&,ab&,ah&)
'
rscx&(tree&)=PRED(ax&)
rscy&(tree&)=SUB(SUB(ay&,5),MUL(hchar&,2))
OB_X(rsc_adr%(tree&),0)=ADD(rscx&(tree&),3)
OB_Y(rsc_adr%(tree&),0)=ADD(rscy&(tree&),3)
'
~WIND_SET(handle&,5,x&,y&,w&,h&)
'
ENDSELECT
'
~WIND_UPDATE(0)                                    ! END_UPDATE
'
ENDIF
RETURN
> PROCEDURE rsc_back(tree&)                                                ! Alle Fensternamen hier eintragen (zur Unterscheidung Flydial oder nicht) !!!
.| Glob. Var.: rsc_window&,nr#,smp16&,blkfunc&,peak&,loop&,editfade&
.|     arranger&,info&,trakker&,smpedit&,edit_obj&,idx&,rsc_list$
.| Felder    : rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&(),rsc_adr%()
.| Ruft auf  : rsc_menu_ienable,rsc_message,rsc_bitblt
.| Aufruf in : rsc_alert-1,goodbye-1,normalize-1,blklfrag-1,newfsel-4
.|     restaura2-1,restaura2b-1,sampleinf-1,resample-1,make-1,conspace-1
.|     memtovirt2-1,
'
' Entfernt den Dialog vom Bildschirm...
'
' ---------------------------------------------------- Als Fenster-Dialog
IF windowda=TRUE THEN
IF rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
rsc_menu_ienable(TRUE)                             ! ...MenÅ wieder wÑhlbar
'
IF rsc_window&                                     ! Fenster existiert...
'
~WIND_CLOSE(rsc_handle%(tree&))
~WIND_DELETE(rsc_handle%(tree&))                 ! ...schlieûen & abmelden
'
DEC rsc_window&                                  ! Anz. offene Fenster-1
'
ELSE                                               ! Sonst Redraw auslîsen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF
' -------------------------------------------------- Als normaler Dialog
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
IF rsc_window&>0 THEN
IF nr=smpedit& OR nr=mixer& OR nr=cuelist& OR nr=plugin& OR nr=wmode& OR nr=dspedit& OR nr=smp16& OR nr=blkfunc& OR nr=peak& OR nr=loop& OR nr=editfade& OR nr=arranger& OR nr=info& OR nr=trakker& THEN
  nr=smpedit&
  tree&=smpedit&
  rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
ENDIF
IF rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000
fly=FALSE
ELSE
fly=TRUE
ENDIF
ELSE
IF rsc_list$<>"" THEN
rsc_list$=LEFT$(rsc_list$,SUB(LEN(rsc_list$),2))   ! Dialog aus der Liste entf.
ENDIF
'
IF rsc_handle%(tree&)                              ! Hintergrund gerettet...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~MFREE(rsc_handle%(tree&))
'
ELSE                                               ! Desktop redrawen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
IF rsc_list$<>""                                 ! Noch ein Dialog drunter...
  ~OBJC_DRAW(rsc_adr%(CVI(RIGHT$(rsc_list$,2))),0,7,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                            ! ...diesen auch redrawen
ENDIF
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
IF rsc_handle%(vornr)>0 AND rsc_handle%(vornr)<1000
fly=FALSE
ELSE
fly=TRUE
ENDIF
ENDIF
ELSE
fly=FALSE
ENDIF
RETURN
> PROCEDURE rsc_text(tree&,robj&,a$)
.| Aufruf in : button-1,rsc_popup-1,rsc_alert-2,
'
' Universelle Objekt-Text Belegung...
'
CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),robj&)}=a$
RETURN
> PROCEDURE rsc_bitblt(a%,w&,h&,b%,rb&,rh&,ax&,ay&,ab&,ah&,gx&,gy&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : rsc_draw-1,rsc_popup-2,rsc_back-1,rsc_movedial-3
.|     rsc_flipping-23,
'
' Universeller Raster-Kopierer (benutzt vro_cpyfm oder vrt_cpyfm)...
'
IF ab&>0 AND ah&>0                 ! Breite und Hîhe vorhanden...
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:a%,w&,h&,0,planes&,L:b%,rb&,rh&,0,planes&,ax&,ay&,ab&,ah&,gx&,gy&,1)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_cursor(rsc_adr%,edit_obj&,idx&)
.| Aufruf in : rsc_message-1,rsc_movedial-1,
LOCAL a|,a%
'
' Zeichengenaue Positionierung des Cursors...
'
a%=ADD({OB_SPEC(rsc_adr%,edit_obj&)},idx&)
'
a|=BYTE{a%}                                        ! Zeichen merken
BYTE{a%}=0                                         ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)       ! Cursor setzen
BYTE{a%}=a|                                        ! ...Zeichen restaurieren
'
RETURN
> PROCEDURE busy_mouse
.| Glob. Var.: m_adr%,m_busy%
.| Aufruf in : HAUPTPROGRAMM-1,maschruf-1,maschruf2-1,maschinit2b-1
.|     maschruf3-1,maschruf3b-1,maschruf5-1,maschinit5b-1,maschruf5c-1
.|     maschruf6-1,maschruf8-1,maschruf8b-1,maschruf9-1,maschruf10-1
.|     maschruf11-1,maschruf12-1,maschruf13-1,maschruf16-1,maschruf17-1
.|     maschruf18b-1,maschruf18c-1,maschruf28-1,maschruf29-1,maschruf30-1
.|     maschruf31b-1,maschruf32-1,maschruf33-1,maschruf34-1,maschruf35-1
.|     maschruf36-1,maschruf37-1,maschruf38-1,fade_it-7,smpkhlp-1,smpihlp-5
.|     smpcut-3,virtmove-7,virtcopy-2,virtins-4,putpix-3,edhandler2-7
.|     smpsave-2,ldhlp-1,sampleinf-1,trakload-1,arrinsert-1,arrdelete-1
.|     hardfs-1,hardproof2-2,rettmem-1,arrload-1,arrsave-1,make-3,trash-2
.|     setload-1,setsave-1,fseldef-1,conspace-1,coninsert-4,mono-3,negate-3
.|     lrchange-3,springart-1,
' Eine Busy-Maus in der Form eines kleines Balles...
'
IF m_adr%=ADD(m_busy%,518)
m_adr%=m_busy%
'
ELSE
ADD m_adr%,74
ENDIF
'
~GRAF_MOUSE(255,m_adr%)
'
RETURN
> FUNCTION malloc(b%,c%)
LOCAL g,a%
IF gemvers>=&H1900 THEN
a%=@mxalloc(b%,3)     ! Buffer anfordern
IF a%<=0 THEN
a%=MALLOC(b%)       ! Buffer anfordern
ENDIF
ELSE
a%=MALLOC(b%)         ! Buffer fÅr Tracker-Caches
ENDIF
IF a%<=0 THEN
IF (c% AND 3)=1 THEN
@alerts(3)
ENDIF
IF (c% AND 3)=2 THEN
@alerts(4)
ENDIF
IF (c% AND 7)=3 THEN
@alerts(5)
ENDIF
IF (c% AND 7)=7 THEN
@alerts(6)
ENDIF
IF (g=2 AND (c% AND 7)=7) OR (c% AND 4)=4 THEN
@goodbye
ENDIF
ENDIF
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION rsc_get(x&,y&,w&,h&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : fseldef-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%,b%,g
'
b%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
a%=@malloc(b%,1)         ! Buffer fÅr Tracker-Caches
'
IF a%>0 THEN                       ! Hat geklappt...
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
'                                ! Kopieren...
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION rsc_get2(x&,y&,w&,h&,md%)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-3,dragging2-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%
a%=md%                           ! Speicher anfordern
IF a%>0 THEN
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> PROCEDURE rsc_put(a%,x&,y&,m&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&,noblt!,w2&,h2&
noblt!=FALSE
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
~GRAF_MOUSE(256,0)               ! Hidem
IF flicker=TRUE THEN
VSYNC
ENDIF
w2&=w&
h2&=h&
IF x&+w&>=xwidth THEN
w2&=xwidth-x&-1
IF w2&<=0 THEN
noblt!=TRUE
ENDIF
ENDIF
IF y&+h&>=ywidth THEN
h2&=ywidth-y&-1
IF h2&<=0 THEN
noblt!=TRUE
ENDIF
ENDIF
IF noblt!=FALSE AND y&>19 AND x&>0 THEN
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,0,0,w2&,h2&,x&,y&,m&)
ENDIF
~GRAF_MOUSE(257,0)               ! Showm
ENDIF
RETURN
> PROCEDURE rsc_put2(a%,x&,y&,m&,sx,bx)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&,noblt!,h2&
noblt!=FALSE
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
~GRAF_MOUSE(256,0)               ! Hidem
IF flicker=TRUE THEN
VSYNC
ENDIF
h2&=h&
IF y&+h&>=ywidth THEN
h2&=ywidth-y&-1
IF h2&<=0 THEN
noblt!=TRUE
ENDIF
ENDIF
IF noblt!=FALSE AND y&>19 AND x&>0 THEN
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,sx,0,bx,h2&,x&,y&,m&)
ENDIF
~GRAF_MOUSE(257,0)               ! Showm
ENDIF
RETURN
> PROCEDURE rsc_putblock(a%,x&,y&,x2&,y2&,b2&,h2&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&
'
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
IF flicker=TRUE THEN
VSYNC
ENDIF
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,x2&,y2&,b2&,h2&,x&,y&,1)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> FUNCTION rsc_len(w&,h&)
LOCAL a%
'
a%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION planes
'
CONTRL(0)=102       ! Opcode fÅr VDI-Funktion VQ_EXTND
CONTRL(1)=0         ! EintrÑge in ptsin()
CONTRL(3)=1         ! EintrÑge in intin()
CONTRL(6)=V~H       ! GerÑtekennung
INTIN(0)=1          ! owflag (0=Standard, 1=erweiterte Parameter)
'
VDISYS
'
RETURN INTOUT(4)   ! Anzahl der Bitplanes zurÅckgeben
'
ENDFUNC
'
' ------------------------------------------------------------------------------
' ------------------------INTERFACE-FARBICONS-----------------------------------
' ------------------------------------------------------------------------------
' ************************************************************************
' **                        XRSRC-Routinen                              **
' ************************************************************************
> FUNCTION xrsrc_init(rsn)
LOCAL a%,tl%,dl%,bl%,p$
'
' Initialisierungsroutine fÅr die Xrsrc-Routinen
' XRSRC-Routinen Copyright (c)1992 Olaf Meisiek
'
' -----------------------------------------------------------
INLINE xrsrc%,9423
INLINE relo%,94
'
f.base%(rsn)=GEMDOS(75,5,L:0,L:0,L:0)     ! CREATE BASEPAGE
'
IF f.base%(rsn)<=0
RETURN FALSE                       ! ERROR!
ENDIF
'
tl%={xrsrc%+2}                       ! LÑnge TEXT
dl%={xrsrc%+6}                       ! LÑnge DATA
bl%={xrsrc%+10}                      ! LÑnge BSS
'
{f.base%(rsn)+8}=f.base%(rsn)+256              ! Adresse TEXT
{f.base%(rsn)+16}={f.base%(rsn)+8}+{xrsrc%+2}  ! Adresse DATA
{f.base%(rsn)+24}={f.base%(rsn)+16}+{xrsrc%+6} ! Adresse BSS
'
{f.base%(rsn)+12}=tl%                     ! LÑnge TEXT
{f.base%(rsn)+20}=dl%                     ! LÑnge DATA
{f.base%(rsn)+28}=bl%                     ! LÑnge BSS
'
' {f.base%(rsn)+32}=dta%                  ! Addresse DTA
'
BMOVE xrsrc%+28,f.base%(rsn)+256,9423-28  ! Relozieren...
~C:relo%(L:f.base%(rsn)+256,L:tl%,L:dl%,L:INT{xrsrc%+14})
'
'  ~MSHRINK(f.base%(rsn),256+tl%+dl%+bl%)   ! Macht Probleme unter MagiC
'
f.init%(rsn)={f.base%(rsn)+8}
'
p$=STRING$(100,0)
{f.init%(rsn)+4}=V:p$
'
fi%=f.init%(rsn)
$C+
a%=C:fi%(L:f.base%(rsn))              ! Initialisierung
$C-
'
IF a%=0                              ! Hat geklappt...
f.scalc%(rsn)={f.init%(rsn)+42}
'
WORD{f.init%(rsn)+4+36}=128             ! Nummer der Function
fsc%=f.scalc%(rsn)
$C+
r%=C:fsc%()
$C-
'
RETURN TRUE
ENDIF
'
RETURN FALSE                         ! ERROR!
ENDFUNC
> PROCEDURE xrsrc_exit(rsn)
'
WORD{f.init%(rsn)+4+36}=129          ! Nummer der Funktion
fsc%=f.scalc%(rsn)
$C+
r%=C:fsc%()
$C-
'
~MFREE(f.base%(rsn))
'
RETURN
> FUNCTION xrsrc_load(rsn,file$)
LOCAL r%
'
file$=file$+CHR$(0)
'
WORD{f.init%(rsn)+4+36}=1          ! Nummer der Funktion
'
{f.init%(rsn)+4+16}=V:file$
'
fsc%=f.scalc%(rsn)
$C+
r%=C:fsc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_free(rsn)
LOCAL r%
'
WORD{f.init%(rsn)+4+36}=2          ! Nummer der Function
'
fsc%=f.scalc%(rsn)
$C+
r%=C:fsc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_gaddr(re_gtype&,re_gindex&,VAR re_gaddr%)
LOCAL r%,regi&
'
IF re_gindex&>(lastrsc2+lastrsc1+1) THEN
rsn=3
regi&=re_gindex&-lastrsc1-lastrsc2-2
ELSE
IF re_gindex&>lastrsc1 THEN
rsn=2
regi&=re_gindex&-lastrsc1-1
ELSE
rsn=1
regi&=re_gindex&
ENDIF
ENDIF
'
WORD{f.init%(rsn)+4+36}=3          ! Nummer der Funktion
'
WORD{f.init%(rsn)+4+0}=re_gtype&
WORD{f.init%(rsn)+4+2}=regi&
'
{f.init%(rsn)+4+16}=V:re_gaddr%
'
fsc%=f.scalc%(rsn)
$C+
r%=C:fsc%()
$C-
'
RETURN r%
ENDFUNC
'
' ------------------------------------------------------------------------------
' ------------------------ENHANCED-FLYDIALS-------------------------------------
' ------------------------------------------------------------------------------
DEFFN rsc_flags(tree&,obj&,bit&)=BTST(OB_FLAGS(rsc_adr%(tree&),obj&),bit&)
DEFFN rsc_state(tree&,obj&,bit&)=BTST(OB_STATE(rsc_adr%(tree&),obj&),bit&)
> FUNCTION form_keybd(rsc_adr%,edit_obj&,key&,a&,VAR next_obj&,key_back&,idx&)
.| Ruft auf  : form_search_flag
.| Aufruf in : key-1,
' ZusÑtzliche Tastaturkommandos...
' Einfach FORM_KEYBD in 'rsc_do' durch @form_keybd ersetzen.
$F%
LOCAL scan|,cont&
'
' Ersetzt FORM_KEYBD()...
'
key_back&=0
cont&=1
'
SELECT key&
'
' ------------------------------------------------- SHIFT right
CASE &H4D36
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
' ------------------------------------------------- SHIFT left
CASE &H4B34
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
'
a&=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=0
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=a&
'
' ------------------------------------------------- Cursor runter
CASE &H5000
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
' ------------------------------------------------- Cursor rauf
CASE &H4800
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,-1)
' ------------------------------------------------- SHIFT runter/HOME
CASE &H5032,&H4737                                  ! =>letztes Feld
REPEAT
next_obj&=edit_obj&
edit_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
UNTIL edit_obj&=0
' ------------------------------------------------- SHIFT rauf, HOME
CASE &H4838,&H4700                                  ! =>erstes Feld
next_obj&=@form_search_flag(rsc_adr%,0,3,1)
' ------------------------------------------------- HELP/UNDO
CASE &H6200,&H6100
key_back&=key&
' ------------------------------------------------- Alles andere
DEFAULT
scan|=BYTE(SHR(key&,8))                           ! SCAN-Code
'
IF BYTE(key&)>0 OR scan|=75 OR scan|=77           ! Cursor rauf/runter
cont&=FORM_KEYBD(rsc_adr%,edit_obj&,key&,0,next_obj&,key&)
'                                               ! Kein Ende&TAB u. EDITABLE
IF cont&>0 AND BYTE(key&)<>9 AND BTST(OB_FLAGS(rsc_adr%,edit_obj&),3)
'
scan|=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)+8}+idx&}! Maske 'A' oder 'N'...
IF scan|=65 OR (scan|=78 AND (BYTE(key&)<48 OR BYTE(key&)>57))
key&=BCLR(key&,5)                             ! ...Groûschrift setzen
ENDIF
'
~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,2,idx&) ! ...Eingabe
ENDIF
'
ELSE
key_back&=key&
ENDIF
'
ENDSELECT
'
RETURN cont&
ENDFUNC
> FUNCTION form_search_flag(rsc_adr%,obj&,flag&,step&)
$F%
.| Aufruf in : form_keybd-4,
'
' Unterroutine fÅr form_keybd. Sucht das nÑchste/vorhergehende Objekt mit
' dem gesetzten Bit 'flag&' in OB_FLAGS...
'
' Sonderfall: Letztes Objekt ist edierbar, Cursor runter:
IF NOT (BTST(OB_FLAGS(rsc_adr%,obj&),5)=TRUE AND step&>0)
'
REPEAT
ADD obj&,step&
'
IF BTST(OB_FLAGS(rsc_adr%,obj&),flag&) AND (NOT BTST(OB_STATE(rsc_adr%,obj&),3))
RETURN obj&
ENDIF
UNTIL (obj&<=0) OR BTST(OB_FLAGS(rsc_adr%,obj&),5)
'
ENDIF
'
RETURN 0
ENDFUNC
> PROCEDURE rsc_movedial(tree&,edit_obj&,idx&)
.| Glob. Var.: deskx&,deskw&,desky&,deskh&
.| Felder    : rscw&(),rsch&(),rscx&(),rscy&(),rsc_handle%(),rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_flipping,rsc_cursor
.| Aufruf in : button-1,
' SOLID Flydials...
' Einfach die Prozedur 'rsc_movedial' ersetzen.
LOCAL x&,y&,w&,h&,fx&,fy&,mx&,my&,mb&,shift&,rsc%
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'
~GRAF_MKSTATE(mx&,my&,x&,y&)
' Nicht zusÑtzl. rechte Maustaste oder SHIFT/CONTROL/ALT...
IF NOT (x&=3 OR AND(y&,&X1111)>0)
rsc%=@malloc(@getsize(w&,h&),7)                    ! Dialog retten
ENDIF
IF rsc%                                           ! Hat geklappt...
rsc_bitblt(0,0,0,rsc%,w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
ENDIF
'
~GRAF_MOUSE(4,0)                                  ! FLAT_HAND
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
fx&=SUB(mx&,SUCC(rscx&(tree&)))                   ! Relativer Mausfaktor
fy&=SUB(my&,SUCC(rscy&(tree&)))
'
mx&=rscx&(tree&)
my&=rscy&(tree&)
' ------------------------------------------------- Bewegen
IF rsc%                                           ! SOLID...
REPEAT
'
~GRAF_MKSTATE(x&,y&,mb&,shift&)
'
x&=SUB(PRED(x&),fx&)
y&=SUB(PRED(y&),fy&)                          ! Clipping...
x&=MIN(MAX(x&,deskx&),SUB(ADD(deskx&,deskw&),w&))
y&=MIN(MAX(y&,desky&),SUB(ADD(desky&,deskh&),h&))
'
IF mx&<>x& OR my&<>y&
rsc_flipping(rsc_handle%(tree&),rsc%,mx&,my&,w&,h&,x&,y&)
mx&=x&
my&=y&
'
ENDIF
'
UNTIL mb&=0
'
~MFREE(rsc%)
'
ELSE                                              ! Nicht SOLID...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~GRAF_DRAGBOX(rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),deskx&,desky&,deskw&,deskh&,x&,y&)
ENDIF
' ------------------------------------------------- Hinsetzen
rscx&(tree&)=x&
rscy&(tree&)=y&
OB_X(rsc_adr%(tree&),0)=ADD(x&,3)
OB_Y(rsc_adr%(tree&),0)=ADD(y&,3)
'
IF rsc%=0                                         ! Nicht SOLID...
rsc_bitblt(0,0,0,rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
~OBJC_DRAW(rsc_adr%(tree&),0,10,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
'
IF edit_obj&
rsc_cursor(rsc_adr%(tree&),edit_obj&,idx&)    ! ...Cursor ein
ENDIF
ENDIF
'
~GRAF_MOUSE(0,0)
'
RETURN
> PROCEDURE rsc_flipping(rsc_back%,rsc%,ax&,ay&,w&,h&,x&,y&)
.| Ruft auf  : rsc_bitblt
.| Aufruf in : rsc_movedial-1,
LOCAL rb&,rh&,gw&,gh&
'
gw&=ABS(SUB(x&,ax&))         ! Verschiebbreite
gh&=ABS(SUB(y&,ay&))         ! Verschiebhîhe
rb&=SUB(w&,gw&)              ! Restbreite
rh&=SUB(h&,gh&)              ! Resthîhe
'
IF rb&<0 OR rh&<0            ! rsc% auûerhalb von rsc_back%
'
' Gesamten Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,h&,ax&,ay&)
'
' Gesamten Dialog aktualisieren -----
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,h&,0,0)
'
ELSE IF x&>ax&               ! nach rechts...
'
IF y&>ay&                  ! nach rechts-unten veschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,gh&,gw&,rh&,ax&,ADD(ay&,gh&))
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,gh&,ax&,ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,gh&,rb&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),rb&,gh&,0,rh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ELSE                      ! nach rechts-oben / rechts verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,gw&,rh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,0,rb&,rh&,0,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,rb&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ENDIF
'                         ! nach links / oben / unten...
ELSE IF y&>ay&              ! nach links-unten / unten verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,rb&,gh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,h&,ADD(ax&,rb&),ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,gh&,rb&,rh&,gw&,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,gw&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),w&,gh&,0,rh&)
'
ELSE                        ! nach links-oben / links / oben verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,rh&,ADD(ax&,rb&),ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,0,rb&,rh&,gw&,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,gh&),gw&,rh&,0,gh&)
'
ENDIF
'
rsc_bitblt(rsc%,w&,h&,0,0,0,0,0,w&,h&,x&,y&)
'
RETURN
> PROCEDURE rsc_set_cursor(rsc_adr%,mx&,my&,VAR edit_obj&,next_obj&,idx&)
.| Glob. Var.: wchar&
.| Aufruf in : button-1,
' Zeichengenaues Cursor-Positionieren mit der Maus...
' Nur die entsprechenden 2 Zeilen in 'rsc_do' (ziemlich am Ende) entREMen.
LOCAL x&,a&,i&,ob_spec%,a$
'
ob_spec%=OB_SPEC(rsc_adr%,next_obj&)
'
~OBJC_OFFSET(rsc_adr%,next_obj&,x&,a&)          ! Absolute X-Position
'
x&=DIV(SUB(mx&+SHR(wchar&,2),x&),wchar&)        ! Spaltenposition
'
a$=CHAR{{ADD(ob_spec%,4)}}                      ! Maske lesen
'
FOR a&=1 TO x&                                  ! Pos. im Eingabefeld...
IF MID$(a$,a&,1)="_"
INC i&                                      ! ...nur relevante
ENDIF
NEXT a&
SUB x&,(x&-i&)
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)    ! Cursor aus
'
ob_spec%=ADD({ob_spec%},x&)
'
a&=BYTE{ob_spec%}                               ! Zeichen merken
BYTE{ob_spec%}=0                                ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,next_obj&,0,idx&,1,idx&)    ! Cursor setzen
BYTE{ob_spec%}=a&                               ! ...und Zeichen restaurieren
'
edit_obj&=next_obj&
'
RETURN
> PROCEDURE rsc_set_popup(popup&,anz&)
LOCAL a&,obj&
'
' popup&: Objektnummer des Popup-MenÅs
' anz&  : Neue Anzahl EintrÑge
'
' ----------------------------------------- Alle EintrÑge aktivieren...
obj&=OB_TAIL(rsc_adr%(rsc_popup&),popup&) ! Letzter Eintrag des Popup's
'
a&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)     ! Darauf folgender
'
WHILE a&=popup&                           ! Zeigt auf's Parent-Objekt...
INC obj&                                ! ...nÑchster Eintrag
'
a&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)
IF a&>0 AND a&<=SUCC(obj&)              ! Existiert...
~OBJC_ADD(rsc_adr%(rsc_popup&),popup&,obj&)
ENDIF                                   ! ...wieder aktivieren
'
WEND
'
' ----------------------------------------- EintrÑge entfernen...
a&=OB_TAIL(rsc_adr%(rsc_popup&),popup&)   ! Letzter Eintrag des Popup's
'
FOR obj&=a& DOWNTO ADD(popup&,SUCC(anz&)) ! Von hinten nach vorne...
~OBJC_DELETE(rsc_adr%(rsc_popup&),obj&) ! ...entfernen
NEXT obj&
'
' ----------------------------------------- Neue Hîhe setzen
OB_H(rsc_adr%(rsc_popup&),popup&)=MUL(hchar&,anz&)
'
RETURN
> FUNCTION rsc_shortcut(tree&,scan|,shift&,VAR title&)
.| Felder    : rsc_adr%()
.| Aufruf in : key-1,
' MenÅshortcut ermitteln...
$F%
LOCAL a&,obj&,rsc_adr%,s$,t$
'
' tree&      : Index des MenÅbaumes
' scan|      : SCAN-Code der gedrÅckten Taste
' shift&     : Status der tastaturumschalttasten
' VAR title& : Bei Erfolg Objektnummer des MenÅtitels
'
SELECT scan|
CASE 2 TO 10                                   ! 1-2...
s$=CHR$(ADD(47,scan|))
CASE 15                                        ! TAB...
s$="I"
shift&=BSET(shift&,2)                        ! ...entspricht "^I"
'
CASE 59 TO 68,84 TO 93                         ! Ftasten...
IF scan|<84
s$="F"+STR$(SUB(scan|,58))                 ! ...normal
ELSE
s$="F"+STR$(SUB(scan|,83))                 ! ...mit Shift
ENDIF
CASE 71                                        ! ClrHome...
s$="CLR"
CASE 83                                        ! DELETE...
s$="DEL"
CASE 97                                        ! UNDO...
s$="UNDO"
CASE 98                                        ! HELP...
s$="HELP"
DEFAULT                                        ! Alles andere...
rsc_adr%={XBIOS(16,L:-1,L:-1,L:-1)}
s$=CHR$(BCLR(BYTE{ADD(rsc_adr%,scan|)},5))
ENDSELECT
'
IF BTST(shift&,3)                              ! Alternate...
s$=CHR$(7)+s$
ENDIF
IF BTST(shift&,2)                              ! Control...
s$="^"+s$
ENDIF
IF BTST(shift&,0) OR BTST(shift&,1)            ! Shift...
s$=CHR$(1)+s$
ENDIF
'
title&=2                                       ! Position des Titels
obj&=5                                         ! Beginn der eigentl. MenÅs
rsc_adr%=rsc_adr%(tree&)                       ! öbersichtlicher
'
REPEAT                                         ! alle Objekte d. MenÅbaums
INC obj&
'
IF BYTE(OB_TYPE(rsc_adr%,obj&))=28           ! G_STRING...
IF NOT BTST(OB_STATE(rsc_adr%,obj&),3)     ! disabled ?
'
t$=TRIM$(CHAR{OB_SPEC(rsc_adr%,obj&)})   ! MenÅpunkt-Text
'
a&=RINSTR(t$," ")
IF a&                                    ! Shortcut vorhanden ?
'
IF MID$(t$,SUCC(a&))=s$                ! hier der vermutete Shortcut
RETURN obj&                          ! gefunden
ENDIF
'
ENDIF
ENDIF
'
ELSE IF BYTE(OB_TYPE(rsc_adr%,obj&))=20      ! G_STRING ?
INC title&
ENDIF
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)          ! LAST_OB ?
'
title&=0
RETURN 0                                       ! nicht gef. oder disabled
ENDFUNC
> FUNCTION rsc_alert(icon&,text$,def&,button$)
.| Glob. Var.: rsc_alert&,wchar&,hchar&
.| Felder    : rsc_adr%(),rscw&(),rsch&(),rscx&(),rscy&()
.| Ruft auf  : rsc_text,rsc_draw,rsc_do,rsc_back
.| Aufruf in : copytoarr-1,
' Fliegende ALERT-Box...
$F%
LOCAL a&,b&,h&,i&,l&,len&,w&,x&,y&,z&,ab&,ah&,rsc&,rsc_adr%,a$,knr,kobj,rdraw
'
' Alert-Box darstellen...
'
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF rsc_alert&>-1 AND rscda=TRUE THEN      ! Wenn's den Baum gibt:
rsc_adr%=rsc_adr%(rsc_alert&)                               ! rsc_alert=GLOBAL
'
text$=text$+"|"
button$=button$+"|"
' ---------------------------------------------------- Icon bestimmen
OB_FLAGS(rsc_adr%,2)=BSET(OB_FLAGS(rsc_adr%,2),7)    ! Hidden...
OB_FLAGS(rsc_adr%,3)=BSET(OB_FLAGS(rsc_adr%,3),7)
OB_FLAGS(rsc_adr%,4)=BSET(OB_FLAGS(rsc_adr%,4),7)
'
OB_FLAGS(rsc_adr%,SUCC(icon&))=BCLR(OB_FLAGS(rsc_adr%,SUCC(icon&)),7)
' ---------------------------------------------------- Buttons
OB_FLAGS(rsc_adr%,10)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,10)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,11)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,11)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,12)=OR(&X100101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,12))) ! LAST_OB+EXIT+SELECT.
'                                                    ! Default-Button...
OB_FLAGS(rsc_adr%,9+def&)=BSET(OB_FLAGS(rsc_adr%,9+def&),1)
' ---------------------------------------------------- Textzeilen setzen
FOR i&=1 TO 5
a&=INSTR(text$,"|")
a$=LEFT$(text$,MIN(30,MAX(0,PRED(a&))))
IF LEN(a$)>0 THEN
a$=a$+" "
ENDIF
IF LEN(a$)>30 THEN
a$=LEFT$(a$,30)
ENDIF
text$=MID$(text$,SUCC(a&))
'
z&=MAX(z&,-i&*(a$<>""))                            ! Hîchste belegte Zeile
l&=MAX(l&,LEN(a$))                                 ! LÑngste Zeile
'
rsc_text(rsc_alert&,ADD(4,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Button-Texte setzen
FOR i&=1 TO 3
a&=INSTR(button$,"|")
a$=LEFT$(button$,MIN(10,MAX(0,PRED(a&))))
button$=MID$(button$,SUCC(a&))
'
ADD b&,-(a$<>"")                                   ! Anzahl Buttons
len&=MAX(len&,LEN(a$))                             ! LÑngster Button
'
rsc_text(rsc_alert&,ADD(9,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Dialog-Breite Ñndern
l&=MAX(l&,MUL(10,b&))                                ! Minimal-Breite
'
w&=OB_W(rsc_adr%,3)+MUL(wchar&,ADD(l&,5))
OB_W(rsc_adr%,0)=w&                                  ! Neue Breite
'
OB_X(rsc_adr%,1)=w&-PRED(OB_W(rsc_adr%,1))           ! Flydial verschieben
rscw&(rsc_alert&)=ADD(w&,6)
' ---------------------------------------------------- Dialog-Hîhe Ñndern
h&=OB_H(rsc_adr%,10)+MUL(hchar&,ADD(z&,2))
OB_H(rsc_adr%,0)=h&                                  ! Neue Hîhe
rsch&(rsc_alert&)=ADD(h&,6)
' ---------------------------------------------------- Buttons plazieren
len&=MUL(wchar&,MAX(8,SUCC(len&)))
OB_W(rsc_adr%,10)=len&                               ! Breite anpassen..
OB_W(rsc_adr%,11)=len&
OB_W(rsc_adr%,12)=len&
'
good=TRUE
SELECT b&                                            ! Anzahl Buttons...
CASE 1
OB_FLAGS(rsc_adr%,11)=BSET(OB_FLAGS(rsc_adr%,11),7)! ...hidden
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
' OB_X(rsc_adr%,10)=SHR(SUB(w&,OB_W(rsc_adr%,10)),1)
OB_X(rsc_adr%,10)=SUB(w&,OB_W(rsc_adr%,10))-2*wchar&
'
CASE 2
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
x&=w&-OB_W(rsc_adr%,11)-2*wchar&
OB_X(rsc_adr%,11)=x&
OB_X(rsc_adr%,10)=x&-OB_W(rsc_adr%,10)-wchar&
'
CASE 3
x&=w&-OB_W(rsc_adr%,12)-SHL(wchar&,1)              ! ...Mitte
OB_X(rsc_adr%,12)=x&
OB_X(rsc_adr%,11)=x&-OB_W(rsc_adr%,10)-wchar&
OB_X(rsc_adr%,10)=OB_X(rsc_adr%,11)-OB_W(rsc_adr%,10)-wchar&
'
ENDSELECT
'
y&=h&-OB_H(rsc_adr%,10)-SHR(hchar&,1)
OB_Y(rsc_adr%,10)=y&
OB_Y(rsc_adr%,11)=y&
OB_Y(rsc_adr%,12)=y&
' ---------------------------------------------------- Anzeigen
~FORM_CENTER(rsc_adr%(rsc_alert&),rscx&(rsc_alert&),rscy&(rsc_alert&),rscw&(rsc_alert&),rsch&(rsc_alert&))
'
rdraw=FALSE
'    IF rsc_handle%(nr)>1000                             ! Normaler Dialog...
'      rsc_back(nr)
'      rdraw=TRUE
'  ENDIF
knr=nr
kobj=obj
nr=alertbox&
@rsc_draw(nr,0)
rsc&=@rsc_do(nr,0,popup&)
rsc_back(nr)
nr=knr
obj=kobj
'    IF rdraw=TRUE THEN
'    @rsc_draw(nr,0)
'  ENDIF
rdraw=FALSE
' ----------------------------------------------------
OB_STATE(rsc_adr%,rsc&)=BCLR(OB_STATE(rsc_adr%,rsc&),0)! SELECTED lîschen
'
RETURN SUB(rsc&,9)                                   ! Nummer des Buttons 1-3
ELSE
' Normaler Alert...
WHILE INSTR(button$,"[")>0
button$=LEFT$(button$,PRED(INSTR(button$,"[")))+MID$(button$,SUCC(INSTR(button$,"[")))
WEND                                                   ! ...'[' rausfiltern
RETURN FORM_ALERT(def&,"["+STR$(icon&)+"]["+text$+"]["+button$+"]")
ENDIF
ENDFUNC
> PROCEDURE rsc_state(tree&,obj&,bit&,stat!)
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_tristate-4,rsc_tristate2-4,
' Setzen und Abfragen einzelner Bits in OB_STATE und OB_FLAGS...
'
' tree& : Index des Objektbaumes
' obj&  : Objektnummer
' bit&  : Zu setzendes Bit
' stat! : TRUE =Bit setzen, FALSE =Bit lîschen
'
IF tree&<>-1 THEN
IF stat!
OB_STATE(rsc_adr%(tree&),obj&)=BSET(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ELSE
OB_STATE(rsc_adr%(tree&),obj&)=BCLR(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ENDIF
ENDIF
'
RETURN
> PROCEDURE rsc_tristate(tree&,obj&)
.| Glob. Var.: tri#
.| Ruft auf  : rsc_state,rsc_draw_obj
.| Aufruf in : arrtristate-1,
' Behandlung eines Tristate-Buttons...
'
INC tri
IF tri=3 THEN
tri=0
ENDIF
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
IF shading=FALSE AND dopix=FALSE THEN
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
ENDIF
RETURN
> PROCEDURE rsc_tristate2(tree&,obj&)
.| Glob. Var.: tri#
.| Ruft auf  : rsc_state,rsc_draw_obj
.| Aufruf in : arrnrset-4,arranger-4,arrdel-4,
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
IF shading=FALSE AND dopix=FALSE THEN
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
ENDIF
RETURN
> PROCEDURE rsc_draw_obj(tree&,obj&)
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_tristate-1,rsc_tristate2-1,
' Zeichnen eines einzelnen Objektes...
LOCAL x&,y&
'
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
~OBJC_DRAW(rsc_adr%(tree&),obj&,8,x&,y&,OB_W(rsc_adr%(tree&),obj&),OB_H(rsc_adr%(tree&),obj&))
'
RETURN
> PROCEDURE rsc_redraw_obj(tree&,obj&)
.| Glob. Var.: edit_obj&,idx&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_message
.| Aufruf in : message-1,fadehandler-1,clsfade-1,fadedel-1,restaura3-1
.|     trakload-1,trakforw-1,trkbackw-1,hardfs-1,mforw-1,mbackw-1
.|     time_edit-1,coninsert-1,record2-1,record3-1,
' Sauberer Redraw eines Objektes, nur fÅr Fensterdialoge!...
LOCAL x&,y&,w&,h&
'
' Sendet einen Redraw-Event fÅr ein Objekt
' --------------------------------------------------
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
w&=OB_W(rsc_adr%(tree&),obj&)
h&=OB_H(rsc_adr%(tree&),obj&)
'
'  appl_write(ap_id&,20,rsc_handle%(tree&),x&-3,y&-3,w&+6,h&+6,"")   ! WM_REDRAW
rsc_message(tree&,20,x&-3,y&-3,w&+6,h&+6,edit_obj&,idx&)   ! WM_REDRAW
'
RETURN
> PROCEDURE appl_write(id&,msg&,handle&,x&,y&,w&,h&,a$)
.| Glob. Var.: msg%,ap_id&
.| Aufruf in : helptxt-2,
' LOCAL b$
'
' Sendet eine Message an ein Programm. Dabei kann es sich auch um
' das eigene Programm handeln (id&=ap_id&), siehe 'rsc_redraw_obj'
' --------------------------------------------------
INLINE msg%,256
'
INT{msg%}=msg&                                     ! 0 Message-ID
INT{msg%+2}=ap_id&                                 ! 1 Unsere ID
INT{msg%+4}=0                                      ! 2 Keine öberlÑnge
INT{msg%+6}=handle&                                ! 3
INT{msg%+8}=x&                                     ! 4 MenÅpunkt
INT{msg%+10}=y&                                    ! 5
INT{msg%+12}=w&                                    ! 6
INT{msg%+14}=h&                                    ! 7
'
'  IF x&=0                                            ! String (z.B. fÅr VA_START)...
CHAR{msg%+16}=LEFT$(a$,240)
{msg%+6}=msg%+16
' ENDIF
'
~APPL_WRITE(id&,16,msg%)                           ! Weg damit
'
RETURN
> FUNCTION rsrc_conv(r_ra%)
$F%
'     r_ra%                            ! RSC INLINE Adresse
LOCAL r_buf!                           ! TRUE=RSC Daten puffern
LOCAL r_pa%                            ! Puffer-Adresse
LOCAL r_o&,r_t&                        ! Laufvar
LOCAL r_ob&                            ! Beginn des Objekt Feldes
LOCAL r_no&                            ! Anzahl OBJECTS
LOCAL r_nt&                            ! Anzahl TREES
LOCAL r_rs&                            ! LÑnge des INLINEs
LOCAL r_napt%                          ! neue TREE Table Adresse
LOCAL r_gb%                            ! Adresse des AES Global Feldes
LOCAL r_of%                            ! Objekt Feld
LOCAL r_ns&                            ! Anzahl der freien Strings
LOCAL r_ni&                            ! Anzahl der freien Images
LOCAL r_adr%,r_i&                      ! Hilfsvar, Laufvar
'
r_buf!=(BYTE{ADD(BASEPAGE,256)}=96)    ! Im Interpreter? ==>puffern
'
r_rs&=WORD{ADD(r_ra%,&H22)}            ! LÑnge des INLINEs
IF r_buf! AND DIM?(rsc_buf|())>0       ! Ist RSC Buf schon dimensioniert?...
r_rs&=0
ENDIF
'
IF r_rs&>0
'
IF r_buf!                            ! RSC Daten puffern (nur Interpreter)...
DIM rsc_buf|(r_rs&)
r_pa%=ADD({*rsc_buf|()},4)
BMOVE r_ra%,r_pa%,r_rs&
r_ra%=r_pa%
ENDIF
'
r_napt%=ADD(r_ra%,WORD{ADD(r_ra%,&H12)})       ! neue Adresse der Tree Tabelle
r_gb%={ADD(GB,4)}                    ! Adr. des AES-GLOBAL-Feldes
{ADD(r_gb%,10)}=r_napt%              ! GLOBAL(5/6): neue Tabellen Adr.
r_ob&=WORD{ADD(r_ra%,2)}             ! bisheriger Start Objekt Feld
r_of%=ADD(r_ra%,r_ob&)               ! Neue Startadr. Objekt Feld
r_no&=PRED(WORD{ADD(r_ra%,&H14)})    ! Anzahl der Objekte im File -1
r_nt&=PRED(WORD{ADD(r_ra%,&H16)})    ! Anzahl der Trees in File  -1
'
FOR r_o&=0 TO r_no&                  ! Alle Objekte durchgehen...
~RSRC_OBFIX(r_of%,r_o&)            ! ...Koordinaten umrechnen
'
SELECT BYTE(OB_TYPE(r_of%,r_o&))   ! Objekt-Typ...
'
CASE 21,22,29,30,31                ! ...G_TEXT,G_BOXTEXT,G_FTEXT,G_FBOXTEXT,G_ICON
OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
{OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
{ADD(OB_SPEC(r_of%,r_o&),4)}=ADD({ADD(OB_SPEC(r_of%,r_o&),4)},r_ra%)
{ADD(OB_SPEC(r_of%,r_o&),8)}=ADD({ADD(OB_SPEC(r_of%,r_o&),8)},r_ra%)
'
CASE 24                            ! ...G_USERDEF
OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
{OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
{ADD(OB_SPEC(r_of%,r_o&),4)}=ADD({ADD(OB_SPEC(r_of%,r_o&),4)},r_ra%)
'
CASE 23                            ! ...G_IMAGE
OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
{OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
'
CASE 26,28,32                      ! ...G_BUTTON,G_STRING,G_TITLE
OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
ENDSELECT
'
NEXT r_o&
'
FOR r_t&=0 TO r_nt&
{ADD(r_napt%,MUL(4,r_t&))}=ADD({ADD(r_napt%,MUL(4,r_t&))},r_ra%)
NEXT r_t&
'
r_ns&=PRED(WORD{ADD(r_ra%,&H1E)})
IF r_ns&>-1
r_adr%=ADD(r_ra%,WORD{ADD(r_ra%,&HA)})
FOR r_i&=0 TO r_ns&
{ADD(r_adr%,MUL(4,r_i&))}=ADD({ADD(r_adr%,MUL(4,r_i&))},r_ra%)
NEXT r_i&
ENDIF
'
r_ni&=PRED(WORD{ADD(r_ra%,&H20)})
IF r_ni&>-1
r_adr%=ADD(r_ra%,WORD{ADD(r_ra%,&H10)})
'
FOR r_i&=0 TO r_ni&
{ADD(r_adr%,MUL(4,r_i&))}=ADD({ADD(r_adr%,MUL(4,r_i&))},r_ra%)
{{ADD(r_adr%,MUL(4,r_i&))}}=ADD({{ADD(r_adr%,MUL(4,r_i&))}},r_ra%)
NEXT r_i&
'
ENDIF
'
ENDIF
'
RETURN r_rs&
ENDFUNC
> FUNCTION rsc_clicks(VAR rsc&)
$F%
LOCAL mc&
'
mc&=BTST(rsc&,15)                                  ! Doppelklick?
IF mc&
rsc&=AND(rsc&,&X111111111111111)                 ! Bit 15 ausmaskieren
ENDIF
'
RETURN 1-mc&
ENDFUNC
'
' ------------------------------------------------------------------------------
' ------------------------RCS-Zugriffs-Routinen---------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE windowtest
LOCAL v,v1,v1,wb,wh
IF fly=TRUE THEN
mywindow=TRUE
IF dopix=FALSE THEN
shading=FALSE
ENDIF
ELSE
~WIND_GET(v,10,wind_active,v,v,v)
IF wind_active=rsc_handle%(nr) THEN
mywindow=TRUE
~WIND_GET(rsc_handle%(nr),11,v1,v2,wb,wh)
IF dopix=FALSE THEN
IF wb=0 THEN
shading=TRUE
vshading=TRUE
ELSE
shading=FALSE
vshading=FALSE
ENDIF
ENDIF
ELSE
mywindow=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE textfeld(txtname,txt$,versatz)            ! Textausgabe mit Redraw ins aktive Fenster
LOCAL a
@windowtest
IF mywindow=TRUE OR dopix=TRUE THEN
~@xrsrc_gaddr(0,nr,zu%)
string=LPEEK(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
IF cupdate=FALSE AND shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,txtname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
~FRE(0)
ENDIF
RETURN
'
> PROCEDURE textfeld2(drawnr,txtname,txt$,versatz)    ! Textausgabe ohne Redraw
LOCAL a
~@xrsrc_gaddr(0,drawnr,dzu%)
string=LPEEK(LPEEK(dzu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
RETURN
'
> PROCEDURE readfeld2(drawnr,txtname)
LOCAL a,it
~@xrsrc_gaddr(0,drawnr,dzu%)
string=LPEEK(LPEEK(dzu%+24*txtname+12))
it=0
rf$=""
REPEAT
a=PEEK(string+it)
rf$=rf$+CHR$(a)
INC it
UNTIL a=0
RETURN
'
> PROCEDURE readfeld3(drawnr,txtname)                   ! protected textfeld
LOCAL a,it,b
crkey:
DATA 4,63,12,55,2,66,112,75,23,36,68,93,88,13,113,136,41,39,99,85,49,17,89,54,89,92,52,75,91,67,34,63,89,48,36,1,77,118,19,70
~@xrsrc_gaddr(0,drawnr,dzu%)
string=LPEEK(LPEEK(dzu%+24*txtname+12))
it=0
rf$=""
RESTORE crkey
IF PEEK(string+it)=0 THEN
REPEAT
a=PEEK(string+it+1)
IF a<>0 THEN
READ b
a=((a-b) AND 255)
ENDIF
POKE string+it,a
rf$=rf$+CHR$(a)
INC it
UNTIL a=0
ELSE
REPEAT
a=PEEK(string+it)
rf$=rf$+CHR$(a)
INC it
UNTIL a=0
ENDIF
RETURN
'
> PROCEDURE textfeld3(drawnr,txtname,txt$,versatz)    ! Textausgabe mit Hintergrund-Redraw in nichtaktives oder aktives Fenster
LOCAL a,h,x1,y1,b1,h1,it,string,dzu%
h=rsc_handle%(drawnr)
~@xrsrc_gaddr(0,drawnr,dzu%)
string=LPEEK(LPEEK(dzu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
IF h<>0 THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~WIND_GET(h,11,x1,y1,b1,h1)
~OBJC_DRAW(dzu%,txtname,1,x1,y1,b1,h1)
IF b1<>0 AND h1<>0 THEN
REPEAT
~WIND_GET(h,12,x1,y1,b1,h1)
IF b1<>0 AND h1<>0 THEN
~OBJC_DRAW(dzu%,txtname,1,x1,y1,b1,h1)
ENDIF
UNTIL b1=0 OR h1=0
ENDIF
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE stringfeld(numb,txtname,txt$,versatz)
LOCAL a
~@xrsrc_gaddr(0,numb,zu%)
string=LPEEK(zu%+24*txtname+12)
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
EXIT IF a=0
POKE string+it-1+(versatz-1),a
NEXT it
RETURN
'
> PROCEDURE textbutt(parent,txtname,txt$,versatz)
@windowtest
IF mywindow=TRUE OR dopix=TRUE THEN
~@xrsrc_gaddr(0,nr,zu%)
string=(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
POKE string+it-1+(versatz-1),ASC(MID$(txt$,it,1))
NEXT it
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,parent,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
RETURN
'
> PROCEDURE setbutton(buttnr,buttflag)
@windowtest
IF mywindow=TRUE OR dopix=TRUE THEN
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE setbutton2(buttnr,buttflag,n)
LOCAL buttadr,zu%
@windowtest
IF mywindow=TRUE OR dopix=TRUE THEN
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,n,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE setbutton3(buttnr,buttflag,n)
LOCAL zu%
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,n,zu%)
DPOKE zu%+24*buttnr+10,buttflag
ENDIF
RETURN
'
> PROCEDURE drawbutton(buttnr)
@windowtest
IF mywindow=TRUE OR dopix=TRUE THEN
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,nr,zu%)
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE setbild(buttnr,buttflag)
@windowtest
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
RETURN
'
> PROCEDURE hidetree(buttnr,buttflag,box)
LOCAL bf
@windowtest
IF mywindow=TRUE OR dopix=TRUE THEN
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,box,99,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE hidetree2(buttnr,buttflag)
LOCAL bf
@windowtest
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,0    ! setbutton lîschen
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
ENDIF
RETURN
'
> PROCEDURE hidetree3(drawnr,buttnr,buttflag)
LOCAL bf
@windowtest
~@xrsrc_gaddr(0,drawnr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,0    ! setbutton lîschen
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
ENDIF
RETURN
'
> PROCEDURE readbutton(buttnr)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+10)
RETURN
'
> PROCEDURE flagbutton(buttnr,bfl)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE (buttadr+8),bfl
RETURN
'
> PROCEDURE readflag(buttnr)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+8)
RETURN
'
> PROCEDURE readpos(buttnr)
.| Glob. Var.: nr#,zu%,buttadr#,bx#,by#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : dragging1-1,dragging2-1,
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
bx=DPEEK(buttadr+16)
by=DPEEK(buttadr+18)
RETURN
'
> PROCEDURE setpos(buttnr,bx,by)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+16,bx
DPOKE buttadr+18,by
RETURN
'
> PROCEDURE colorbox(nrr,buttnr,col,fill)
.| Glob. Var.: zu%,buttadr#,colflag#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : HAUPTPROGRAMM-68,
~@xrsrc_gaddr(0,nrr,zu%)
buttadr=zu%+24*buttnr
colflag=DPEEK(buttadr+14)
colflag=(colflag AND &HFFF0)+col
colflag=(colflag AND &HFF8F)+fill*16
DPOKE buttadr+14,colflag
RETURN
'
> PROCEDURE textcolor(nrr,buttnr,col,rahmen,fill)
~@xrsrc_gaddr(0,nrr,zu%)
buttadr=LPEEK(zu%+24*buttnr+12)
colflag=DPEEK(buttadr+18)
colflag=(colflag AND &HF0)+col*256+rahmen*4096+fill
DPOKE buttadr+18,colflag
RETURN
'
> PROCEDURE editread(edread)
.| Glob. Var.: nr#,zu%,editadr#,erd#,a$,bv$
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-2,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkproof-1,tedproof-1,setupdat-1,setsave-1,
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edread+12
erd=LPEEK(LPEEK(editadr))
a$=""
WHILE PEEK(erd)<>0
bv$=CHR$(PEEK(erd))
a$=a$+bv$
erd=erd+1
WEND
RETURN
'
> PROCEDURE editfeld(edname,ed$)
.| Glob. Var.: edit_obj&,nr#,zu%,editadr#,edanf#,edz#,ef#,ap#,xwidth#
.|     ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-8,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkart-1,tedart-2,setdat-1,
@windowtest
edit_obj&=0
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edname+12
edanf=LPEEK(LPEEK(editadr))
edz=LEN(ed$)
FOR ef=1 TO edz
ap=ASC(MID$(ed$,ef,1))
POKE edanf+ef-1,ap
NEXT ef
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,edname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
~FRE(0)
RETURN
'
> PROCEDURE editmask(edname,edbox,ed$,ed2$)
@windowtest
edit_obj&=0
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edname+12
edanf=LPEEK(LPEEK(editadr)+8)
edanf2=LPEEK(LPEEK(editadr)+4)
edz=LEN(ed$)
FOR ef=1 TO edz
ap=ASC(MID$(ed$,ef,1))
POKE edanf+ef-1,ap
NEXT ef
edz=LEN(ed2$)
FOR ef=1 TO edz
ap=ASC(MID$(ed2$,ef,1))
POKE edanf2+ef-1,ap
NEXT ef
DPOKE (LPEEK(editadr)+26),LEN(ed2$)
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,edbox,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
~FRE(0)
RETURN
'
> PROCEDURE editmask2(drawnr,edname,ed$,ed2$)
@windowtest
edit_obj&=0
~@xrsrc_gaddr(0,drawnr,zu%)
editadr=zu%+24*edname+12
edanf=LPEEK(LPEEK(editadr)+8)
edanf2=LPEEK(LPEEK(editadr)+4)
edz=LEN(ed$)
FOR ef=1 TO edz
ap=ASC(MID$(ed$,ef,1))
POKE edanf+ef-1,ap
NEXT ef
edz=LEN(ed2$)
FOR ef=1 TO edz
ap=ASC(MID$(ed2$,ef,1))
POKE edanf2+ef-1,ap
NEXT ef
DPOKE (LPEEK(editadr)+26),LEN(ed2$)
RETURN
'
> PROCEDURE editfeld2(drawnr,edname,ed$)
@windowtest
edit_obj&=0
~@xrsrc_gaddr(0,drawnr,zu%)
editadr=zu%+24*edname+12
edanf=LPEEK(LPEEK(editadr))
edz=LEN(ed$)
FOR ef=1 TO edz
ap=ASC(MID$(ed$,ef,1))
POKE edanf+ef-1,ap
NEXT ef
RETURN
'
> PROCEDURE mouse(VAR mx,my,mk)
.| Aufruf in : message-1,normalize-1,fadehandler-2,markhandl4-1,arrsmpr-1
.|     dragging1-2,dragging2-2,arrmname-1,virtual-1,setupdat-1,midi-1
.|     do_peak-1,markhandler-1,
LOCAL void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx,my,mk,void&)
~WIND_UPDATE(2)
'
SUB mx,WORD{WINDTAB+64}
SUB my,WORD{WINDTAB+66}
RETURN
'
> FUNCTION mousek
$F%
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf4b-1
.|     maschruf5-1,maschruf5c-1,maschruf8b-1,fadehandler-1,fade-1,smptime-1
.|     movefrag-1,drawpix-2,edhandler2-3,smpsave-1,blklfrag-1,newfsel-1
.|     sampleinf-1,trkplay-1,dragging2-1,arrtristate-1,arrdelay-1,arrplay-1
.|     abackup-1,time_edit-1,make-1,smpsts-1,smpes-1,do_peak-1,peakwert-1
.|     markhandler-1,
LOCAL void&
'
'  ~WIND_UPDATE(3)
~GRAF_MKSTATE(void&,void&,mk&,void&)
'  ~WIND_UPDATE(2)
'
RETURN mk&
'
ENDFUNC
'
> FUNCTION mousex
$F%
.| Aufruf in : markhandl4-1,do_peak-1,
LOCAL mx&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx&,void&,void&,void&)
~WIND_UPDATE(2)
SUB mx&,WORD{WINDTAB+64}
'
RETURN mx&
'
ENDFUNC
'
> FUNCTION mousey
$F%
.| Aufruf in : markhandl4-1,do_peak-1,
LOCAL my&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(void&,my&,void&,void&)
~WIND_UPDATE(2)
SUB my&,WORD{WINDTAB+66}
'
RETURN my&
'
ENDFUNC
'
> FUNCTION dfree(fdsk)
$F%
LOCAL dfn,dfret,dfr
IF dfmem=0 THEN
dfmem=MALLOC(16)
dfn=TRUE
ENDIF
dfret=GEMDOS(54,L:dfmem,fdsk)
IF dfret<0 THEN
dfr=DFREE(fdsk)
ENDIF
IF dfn=TRUE THEN
~MFREE(dfmem)
dfn=FALSE
ENDIF
dfr=LPEEK(dfmem)*LPEEK(dfmem+8)*LPEEK(dfmem+12)
RETURN dfr
ENDFUNC
'
> PROCEDURE maus_note
LOCAL a,i,m$
mausdata:
DATA &H07FE,&H07FE,&H0402,&H07FE
DATA &H07FE,&H0402,&H0402,&H0402
DATA &H0402,&H043E,&H047E,&H047E
DATA &H7C3C,&HFC00,&HFC00,&H7800
m$=MKI$(0)+MKI$(0)+MKI$(1)+MKI$(0)+MKI$(1)
RESTORE mausdata
FOR i=1 TO 16
READ a
m$=m$+MKI$(a)
NEXT i
RESTORE mausdata
FOR i=1 TO 16
READ a
m$=m$+MKI$(a)
NEXT i
DEFMOUSE m$
RETURN
'
> PROCEDURE maus_player
LOCAL a,i,m$
mausdata2:
DATA &H01F8,&H03FC,&H07FE,&H07FE
DATA &H7FFF,&HFFFF,&HFF3F,&HFFFF
DATA &HFFFF,&HFFFF,&H7FFF,&H0FFE
DATA &H07FE,&H03FC,&H00F8,&H0000
DATA &H01F8,&H0304,&H0602,&H0602
DATA &H7C01,&HCCC1,&H8C01,&H8D21
DATA &HFD21,&HFCC1,&H7C01,&H0E02
DATA &H0602,&H0304,&H00F8,&H0000
m$=MKI$(0)+MKI$(0)+MKI$(1)+MKI$(0)+MKI$(1)
RESTORE mausdata2
FOR i=1 TO 16
READ a
m$=m$+MKI$(a)
NEXT i
FOR i=1 TO 16
READ a
m$=m$+MKI$(a)
NEXT i
DEFMOUSE m$
RETURN
'
> PROCEDURE maus_playwait
LOCAL a,i,m$
mausdata3:
DATA &H01F9,&H63FF,&H37FE,&H1FFE
DATA &H7FFF,&HFFFF,&HFF7F,&HFFFF
DATA &HFFFF,&HFFFF,&H7FFF,&H0FFE
DATA &H1FFE,&H33FE,&H60FB,&H0001
DATA &H01F9,&H6307,&H3606,&H1E0E
DATA &H7C19,&HCEF1,&H8F61,&H8DE1
DATA &HFDE1,&HFFE1,&H7E31,&H0E1A
DATA &H1E0E,&H3306,&H60FB,&H0001
m$=MKI$(0)+MKI$(0)+MKI$(1)+MKI$(0)+MKI$(1)
RESTORE mausdata3
FOR i=1 TO 16
READ a
m$=m$+MKI$(a)
NEXT i
FOR i=1 TO 16
READ a
m$=m$+MKI$(a)
NEXT i
DEFMOUSE m$
RETURN
'
' ------------------------------------------------------------------------------
'          HardwareunabhÑngiger Teil - GEM
' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------
' ------------------------HAUPTPROGRAMM-----------------------------------------
' ------------------------------------------------------------------------------
'
> PROCEDURE midislide
LOCAL f2,x,xx
x=INP?(3)
IF x=TRUE THEN
xx=INP(3)                    ! Befehl
IF BTST(xx,7)=TRUE THEN
misli2=FALSE
IF (xx>=&HB0 AND xx<=&HBF) THEN
misli=xx
ELSE
misli=0
ENDIF
ELSE
IF misli2=FALSE THEN
misli2=TRUE
misli2b=xx   ! zweites Byte (Code 7)
ELSE
IF misli<>0 AND misli2b=mcc THEN
misli2=FALSE
mnowslid=misli-&HB0
mputslid=TRUE
IF nr=peak& THEN
mnowslid=mnowslid+16
ENDIF
midislide(mnowslid)=xx
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE midislide2
IF mputslid=TRUE AND mnowslid>=16 AND mnowslid<=17 THEN
IF midislide(mnowslid)<>vmidislide(mnowslid) THEN
obj=volume&
IF bigtxt=FALSE THEN
pydist=190
ELSE
pydist=290
ENDIF
scpy=INT(pymax/127*(127-midislide(mnowslid)))
IF mnowslid=16 THEN
vio=FALSE
@setbutton(volinout&,0)
ELSE
vio=TRUE
@setbutton(volinout&,1)
ENDIF
~@xrsrc_gaddr(0,nr,zu%)
~OBJC_DRAW(zu%,volbox&,3,0,0,xwidth,ywidth)      ! neu zeichnen
@peakvolume(scpy)
vmidislide(mnowslid)=midislide(mnowslid)
ENDIF
ENDIF
RETURN
'
> PROCEDURE midislide3
LOCAL v,w,b
IF mputslid=TRUE THEN
IF mnowslid<16 AND midislide(mnowslid)<>vmidislide(mnowslid) THEN
IF trkwahl(mnowslid+1)>0 THEN
w=trkwahl(mnowslid+1)
IF trkwahl(mnowslid+1)>0 AND trkmute(w)=FALSE THEN
v=INT(200/127*midislide(mnowslid))
trklev(w)=v
IF tdig24=TRUE THEN
v=128*v/100
ENDIF
DPOKE mdat%+(mnowslid*2),v
IF w>=trkvz+1 AND w<=trkvz+4 THEN
~@xrsrc_gaddr(0,nr,zu%)
IF w=trkvz+1 THEN
b=trklevt1&
ENDIF
IF w=trkvz+2 THEN
b=trklevt2&
ENDIF
IF w=trkvz+3 THEN
b=trklevt3&
ENDIF
IF w=trkvz+4 THEN
b=trklevt4&
ENDIF
a$=STR$(trklev(w))+CHR$(0)
@textfeld(b,a$,1)
ENDIF
ENDIF
ENDIF
vmidislide(mnowslid)=midislide(mnowslid)
ENDIF
ENDIF
RETURN
'
> PROCEDURE midislide4
LOCAL v,w,b,b2,b3,p
IF mputslid=TRUE THEN
IF mnowslid<16 AND midislide(mnowslid)<>vmidislide(mnowslid) THEN
IF trkwahl(mnowslid+1)>0 OR mnowslid=15 THEN
w=trkwahl(mnowslid+1)
IF (trkwahl(mnowslid+1)>0 AND trkmute(w)=FALSE) OR mnowslid=15 THEN
v=INT(200/127*midislide(mnowslid))
trklev(w)=v
IF tdig24=TRUE THEN
v=128*v/100
ENDIF
DPOKE mdat%+(mnowslid*2),v
IF (mnowslid>=0 AND mnowslid<=7) OR mnowslid=15 THEN
~@xrsrc_gaddr(0,nr,zu%)
IF mnowslid=0 THEN
b=mixvolt1&
b2=mixvol1&
b3=mixvbox1&
ENDIF
IF mnowslid=1 THEN
b=mixvolt2&
b2=mixvol2&
b3=mixvbox2&
ENDIF
IF mnowslid=2 THEN
b=mixvolt3&
b2=mixvol3&
b3=mixvbox3&
ENDIF
IF mnowslid=3 THEN
b=mixvolt4&
b2=mixvol4&
b3=mixvbox4&
ENDIF
IF mnowslid=4 THEN
b=mixvolt5&
b2=mixvol5&
b3=mixvbox5&
ENDIF
IF mnowslid=5 THEN
b=mixvolt6&
b2=mixvol6&
b3=mixvbox6&
ENDIF
IF mnowslid=6 THEN
b=mixvolt7&
b2=mixvol7&
b3=mixvbox7&
ENDIF
IF mnowslid=7 THEN
b=mixvolt8&
b2=mixvol8&
b3=mixvbox8&
ENDIF
IF mnowslid=15 THEN
b=mixvoltm&
b2=mixvolm&
b3=mixvboxm&
ENDIF
a$=STR$(trklev(w))+CHR$(0)
@textfeld(b,a$,1)
@buttbh(mixfade1&,v,h)
@buttbh(mixvol1&,v,h2)
p=INT((h-h2)-((h-h2)/200*trklev(w))+(0))
DPOKE (zu%+24*b2+18),p                       ! Volume-Slider positionieren
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~OBJC_DRAW(zu%,b3,9,0,0,xwidth,ywidth)       ! neu zeichnen
~WIND_UPDATE(0)                                   ! BEG_UPDATE
ENDIF
ENDIF
ENDIF
ENDIF
vmidislide(mnowslid)=midislide(mnowslid)
ENDIF
ENDIF
RETURN
'
> PROCEDURE changetreenumbs
'
lastrsc1=fsel&
lastrsc2=clocks&
lastrsc3=alertbox&
'
info&=info&+lastrsc1+1
peak&=peak&+lastrsc1+1
blkfunc&=blkfunc&+lastrsc1+1
cuelist&=cuelist&+lastrsc1+1
mixer&=mixer&+lastrsc1+1
virtual&=virtual&+lastrsc1+1
record&=record&+lastrsc1+1
LET savebloc&=savebloc&+lastrsc1+1
abackup&=abackup&+lastrsc1+1
midiedit&=midiedit&+lastrsc1+1
normaliz&=normaliz&+lastrsc1+1
resample&=resample&+lastrsc1+1
mrkfind&=mrkfind&+lastrsc1+1
disked&=disked&+lastrsc1+1
xfade&=xfade&+lastrsc1+1
clocks&=clocks&+lastrsc1+1
'
smp16&=smp16&+lastrsc1+lastrsc2+2
dspedit&=dspedit&+lastrsc1+lastrsc2+2
loop&=loop&+lastrsc1+lastrsc2+2
editfade&=editfade&+lastrsc1+lastrsc2+2
wmode&=wmode&+lastrsc1+lastrsc2+2
plugin&=plugin&+lastrsc1+lastrsc2+2
setup&=setup&+lastrsc1+lastrsc2+2
arrmname&=arrmname&+lastrsc1+lastrsc2+2
moving&=moving&+lastrsc1+lastrsc2+2
timeed&=timeed&+lastrsc1+lastrsc2+2
inftxt&=inftxt&+lastrsc1+lastrsc2+2
smpinf&=smpinf&+lastrsc1+lastrsc2+2
meldung&=meldung&+lastrsc1+lastrsc2+2
trknamin&=trknamin&+lastrsc1+lastrsc2+2
trkcomin&=trkcomin&+lastrsc1+lastrsc2+2
mrktxtin&=mrktxtin&+lastrsc1+lastrsc2+2
marknumb&=marknumb&+lastrsc1+lastrsc2+2
plgconfg&=plgconfg&+lastrsc1+lastrsc2+2
arrmake&=arrmake&+lastrsc1+lastrsc2+2
alertbox&=alertbox&+lastrsc1+lastrsc2+2
partsel&=partsel&+lastrsc1+lastrsc2+2
popups&=popups&+lastrsc1+lastrsc2+2
dropdown&=dropdown&+lastrsc1+lastrsc2+2
'
btree=alertbox&
'
RETURN
'
> PROCEDURE calc_resource
IF maxcol=2 THEN
IF bigfoot=FALSE THEN
@rsc_for_lo_mono
ELSE
@rsc_for_hi_mono
ENDIF
@rsc_for_mono
ELSE
IF bigfoot=FALSE THEN
@rsc_for_lo_color
ELSE
@rsc_for_hi_color
ENDIF
@rsc_for_color
ENDIF
@rsc_for_all
RETURN
'
> PROCEDURE changecr
crkey2:
DATA 14,23,52,15,52,86,12,85,23,66,98,13,38,15,109,114,25,88,92,81,46,11,81,51,66,42,22,85,101,17,24,69,12,55,70,14,17,48,119,18
DATA 14,23,52,15,52,86,12,85,23,66,98,13,38,15,109,114,25,88,92,81,46,11,81,51,66,42,22,85,101,17,24,69,12,55,70,14,17,48,119,18
IF compile=TRUE THEN
reg0$="COPYRIGHT0111111111111"+CHR$(0)
reg1$="COPYRIGHT111111111111111111111111111111111"+CHR$(0)
reg2$="COPYRIGHT211111111111111111111111111111111"+CHR$(0)
reg3$="COPYRIGHT311111111111111111111111111111111"+CHR$(0)
reg4$="COPYRIGHT411111111111111111111111111111111"+CHR$(0)
reg5$="COPYRIGHT511111111111111111111111111111111"+CHR$(0)
reg6$="COPYRIGHT6111111111111111111111111111111111111111"+CHR$(0)
'
a=INSTR(reg0$,CHR$(0))
IF a<>0 THEN
reg0$=LEFT$(reg0$,a-1)
ENDIF
a=INSTR(reg1$,CHR$(0))
IF a<>0 THEN
reg1$=LEFT$(reg1$,a-1)
ENDIF
a=INSTR(reg2$,CHR$(0))
IF a<>0 THEN
reg2$=LEFT$(reg2$,a-1)
ENDIF
a=INSTR(reg3$,CHR$(0))
IF a<>0 THEN
reg3$=LEFT$(reg3$,a-1)
ENDIF
a=INSTR(reg4$,CHR$(0))
IF a<>0 THEN
reg4$=LEFT$(reg4$,a-1)
ENDIF
a=INSTR(reg5$,CHR$(0))
IF a<>0 THEN
reg5$=LEFT$(reg5$,a-1)
ENDIF
a=INSTR(reg6$,CHR$(0))
IF a<>0 THEN
reg6$=LEFT$(reg6$,a)
ENDIF
RESTORE crkey2
FOR i=1 TO LEN(reg0$)
a=ASC(MID$(reg0$,i,1))
READ b
a=((a-b) AND 255)
MID$(reg0$,i,1)=CHR$(a)
NEXT i
RESTORE crkey2
FOR i=1 TO LEN(reg1$)
a=ASC(MID$(reg1$,i,1))
READ b
a=((a-b) AND 255)
MID$(reg1$,i,1)=CHR$(a)
NEXT i
RESTORE crkey2
FOR i=1 TO LEN(reg2$)
a=ASC(MID$(reg2$,i,1))
READ b
a=((a-b) AND 255)
MID$(reg2$,i,1)=CHR$(a)
NEXT i
RESTORE crkey2
FOR i=1 TO LEN(reg3$)
a=ASC(MID$(reg3$,i,1))
READ b
a=((a-b) AND 255)
MID$(reg3$,i,1)=CHR$(a)
NEXT i
RESTORE crkey2
FOR i=1 TO LEN(reg4$)
a=ASC(MID$(reg4$,i,1))
READ b
a=((a-b) AND 255)
MID$(reg4$,i,1)=CHR$(a)
NEXT i
RESTORE crkey2
FOR i=1 TO LEN(reg5$)
a=ASC(MID$(reg5$,i,1))
READ b
a=((a-b) AND 255)
MID$(reg5$,i,1)=CHR$(a)
NEXT i
RESTORE crkey2
FOR i=1 TO LEN(reg6$)
a=ASC(MID$(reg6$,i,1))
IF a<>0 THEN
READ b
a=((a-b) AND 255)
MID$(reg6$,i,1)=CHR$(a)
ENDIF
NEXT i
ENDIF
IF LEN(reg0$)>20 THEN
reg0$=LEFT$(reg0$,20)
ENDIF
IF LEN(reg1$)>40 THEN
reg1$=LEFT$(reg1$,40)
ENDIF
IF LEN(reg2$)>40 THEN
reg2$=LEFT$(reg2$,40)
ENDIF
IF LEN(reg3$)>40 THEN
reg3$=LEFT$(reg3$,40)
ENDIF
IF LEN(reg4$)>40 THEN
reg4$=LEFT$(reg4$,40)
ENDIF
IF LEN(reg6$)>47 THEN
reg6$=LEFT$(reg6$,47)+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE rsc_for_lo_mono  ! Resource fÅr monochrome Auflîsungen kleiner als 1024x768
REM Resource Datei Indizes fÅr STARLOM
'
LET smpedit&=0 ! Formular/Dialog
LET editbox7&=0 ! BOX in Baum SMPEDIT
LET editbox&=1 ! BOX in Baum SMPEDIT
LET zomslide&=2 ! BOX in Baum SMPEDIT
LET zoombutt&=3 ! BUTTON in Baum SMPEDIT
LET zooml&=4 ! USERDEF in Baum SMPEDIT
LET zoomr&=5 ! USERDEF in Baum SMPEDIT
LET pixzoom&=7 ! USERDEF in Baum SMPEDIT
LET csmintex&=8 ! TEXT in Baum SMPEDIT
LET cemaxtex&=9 ! TEXT in Baum SMPEDIT
LET cstxt&=10 ! BOXTEXT in Baum SMPEDIT
LET cetxt&=11 ! BOXTEXT in Baum SMPEDIT
LET smpl3&=13 ! USERDEF in Baum SMPEDIT
LET smpl2&=14 ! USERDEF in Baum SMPEDIT
LET smpl1&=15 ! USERDEF in Baum SMPEDIT
LET smpr1&=16 ! USERDEF in Baum SMPEDIT
LET smpr2&=17 ! USERDEF in Baum SMPEDIT
LET smpr3&=18 ! USERDEF in Baum SMPEDIT
LET smpanf&=19 ! USERDEF in Baum SMPEDIT
LET smpmid&=20 ! USERDEF in Baum SMPEDIT
LET smpend&=21 ! USERDEF in Baum SMPEDIT
LET editbox5&=22 ! BOX in Baum SMPEDIT
LET mover&=24 ! BOXTEXT in Baum SMPEDIT
LET movecirc&=25 ! BOXCHAR in Baum SMPEDIT
LET trash&=26 ! USERDEF in Baum SMPEDIT
LET smpauto2&=29 ! USERDEF in Baum SMPEDIT
LET smpstrt2&=30 ! USERDEF in Baum SMPEDIT
LET recplay3&=31 ! USERDEF in Baum SMPEDIT
LET smpplay&=32 ! USERDEF in Baum SMPEDIT
LET smpstop&=33 ! USERDEF in Baum SMPEDIT
LET smpwait&=34 ! USERDEF in Baum SMPEDIT
LET hard&=35 ! USERDEF in Baum SMPEDIT
LET editbox3&=36 ! BOX in Baum SMPEDIT
LET edmtims&=37 ! BOXTEXT in Baum SMPEDIT
LET edmtime&=38 ! BOXTEXT in Baum SMPEDIT
LET edmdown&=39 ! USERDEF in Baum SMPEDIT
LET edmslide&=40 ! BOX in Baum SMPEDIT
LET edmbut&=41 ! BUTTON in Baum SMPEDIT
LET edmup&=42 ! USERDEF in Baum SMPEDIT
LET edmnr&=43 ! BOXTEXT in Baum SMPEDIT
LET edmtimi&=44 ! BOXTEXT in Baum SMPEDIT
LET edmtimr&=45 ! BOXTEXT in Baum SMPEDIT
LET edmtxt&=46 ! BOXTEXT in Baum SMPEDIT
LET edmbox&=47 ! BOX in Baum SMPEDIT
LET edmbuts&=48 ! USERDEF in Baum SMPEDIT
LET edmbute&=49 ! USERDEF in Baum SMPEDIT
LET edmbuti&=50 ! USERDEF in Baum SMPEDIT
LET edmbutr&=51 ! USERDEF in Baum SMPEDIT
LET smplen&=54 ! BOXTEXT in Baum SMPEDIT
LET smpsec&=55 ! BOXTEXT in Baum SMPEDIT
LET smpfile&=56 ! BOXTEXT in Baum SMPEDIT
LET smprate&=57 ! BOXTEXT in Baum SMPEDIT
LET showxy&=58 ! BOXTEXT in Baum SMPEDIT
LET pntprsmp&=59 ! BOXTEXT in Baum SMPEDIT
LET freemem&=60 ! BOXTEXT in Baum SMPEDIT
LET clock&=61 ! BOXTEXT in Baum SMPEDIT
LET smpname&=62 ! BOXTEXT in Baum SMPEDIT
LET resolu&=64 ! BOXTEXT in Baum SMPEDIT
LET editbox6&=65 ! BOX in Baum SMPEDIT
LET smppmark&=66 ! USERDEF in Baum SMPEDIT
LET midi&=67 ! USERDEF in Baum SMPEDIT
LET mintext&=68 ! BOXTEXT in Baum SMPEDIT
LET smploop&=69 ! USERDEF in Baum SMPEDIT
LET smpcblk&=70 ! USERDEF in Baum SMPEDIT
LET rate&=74 ! BOXTEXT in Baum SMPEDIT
LET ratecirc&=75 ! BOXCHAR in Baum SMPEDIT
LET flyer&=76 ! USERDEF in Baum SMPEDIT
LET smpedhlp&=78 ! BOXTEXT in Baum SMPEDIT
LET smpexit&=79 ! BUTTON in Baum SMPEDIT
LET editbox2&=80 ! BOX in Baum SMPEDIT
LET setuper&=81 ! USERDEF in Baum SMPEDIT
LET edfade&=82 ! USERDEF in Baum SMPEDIT
LET peaksw2&=83 ! USERDEF in Baum SMPEDIT
LET disk&=84 ! USERDEF in Baum SMPEDIT
LET loopart&=85 ! USERDEF in Baum SMPEDIT
LET blocfunc&=86 ! USERDEF in Baum SMPEDIT
LET arrange&=87 ! USERDEF in Baum SMPEDIT
LET smpload&=88 ! USERDEF in Baum SMPEDIT
LET smpsave&=89 ! USERDEF in Baum SMPEDIT
LET infoicon&=90 ! USERDEF in Baum SMPEDIT
LET edmidi&=91 ! USERDEF in Baum SMPEDIT
LET trak&=92 ! USERDEF in Baum SMPEDIT
LET edsmp16&=93 ! USERDEF in Baum SMPEDIT
LET swdsp&=94 ! USERDEF in Baum SMPEDIT
LET smpdbank&=95 ! USERDEF in Baum SMPEDIT
LET swmark&=96 ! USERDEF in Baum SMPEDIT
LET wmodes&=97 ! USERDEF in Baum SMPEDIT
LET swyzoom&=98 ! USERDEF in Baum SMPEDIT
LET swclick&=99 ! USERDEF in Baum SMPEDIT
LET swdraw&=100 ! USERDEF in Baum SMPEDIT
LET swblk&=101 ! USERDEF in Baum SMPEDIT
LET scrubs&=102 ! USERDEF in Baum SMPEDIT
LET swsearch&=103 ! USERDEF in Baum SMPEDIT
LET curvbox&=104 ! BOX in Baum SMPEDIT
LET editbox4&=105 ! BOX in Baum SMPEDIT
LET editbox8&=106 ! BOX in Baum SMPEDIT
LET smptxr&=107 ! TEXT in Baum SMPEDIT
LET smptxl&=108 ! TEXT in Baum SMPEDIT
LET rm80&=109 ! BOXTEXT in Baum SMPEDIT
LET rp0&=110 ! BOXTEXT in Baum SMPEDIT
LET rp80&=111 ! BOXTEXT in Baum SMPEDIT
LET rp60&=112 ! BOXTEXT in Baum SMPEDIT
LET rp40&=113 ! BOXTEXT in Baum SMPEDIT
LET rm60&=114 ! BOXTEXT in Baum SMPEDIT
LET rm40&=115 ! BOXTEXT in Baum SMPEDIT
LET lp80&=116 ! BOXTEXT in Baum SMPEDIT
LET lm80&=117 ! BOXTEXT in Baum SMPEDIT
LET lp40&=118 ! BOXTEXT in Baum SMPEDIT
LET lp60&=119 ! BOXTEXT in Baum SMPEDIT
LET lm60&=120 ! BOXTEXT in Baum SMPEDIT
LET lm40&=121 ! BOXTEXT in Baum SMPEDIT
LET lm20&=122 ! BOXTEXT in Baum SMPEDIT
LET lp0&=123 ! BOXTEXT in Baum SMPEDIT
LET rp20&=124 ! BOXTEXT in Baum SMPEDIT
LET rm20&=125 ! BOXTEXT in Baum SMPEDIT
LET lp20&=126 ! BOXTEXT in Baum SMPEDIT
LET scrlslde&=127 ! BOX in Baum SMPEDIT
LET scrolbut&=128 ! BUTTON in Baum SMPEDIT
LET lscroll&=129 ! USERDEF in Baum SMPEDIT
LET rscroll&=130 ! USERDEF in Baum SMPEDIT
LET lr100&=131 ! BOXTEXT in Baum SMPEDIT
LET blkfilel&=138 ! BOX in Baum SMPEDIT
LET blkfiler&=139 ! BOX in Baum SMPEDIT
LET blkfile&=140 ! TEXT in Baum SMPEDIT
'
LET arranger&=1 ! Formular/Dialog
LET arrbox&=0 ! BOX in Baum ARRANGER
LET arrbox2&=1 ! BOX in Baum ARRANGER
LET hlpedit2&=2 ! USERDEF in Baum ARRANGER
LET arrload&=3 ! USERDEF in Baum ARRANGER
LET arrsave&=4 ! USERDEF in Baum ARRANGER
LET arrmidi&=5 ! USERDEF in Baum ARRANGER
LET arrins&=6 ! USERDEF in Baum ARRANGER
LET arrdel&=7 ! USERDEF in Baum ARRANGER
LET smpauto3&=9 ! USERDEF in Baum ARRANGER
LET smpstrt3&=10 ! USERDEF in Baum ARRANGER
LET pause&=11 ! USERDEF in Baum ARRANGER
LET rewind&=12 ! USERDEF in Baum ARRANGER
LET recplay&=13 ! USERDEF in Baum ARRANGER
LET smpplay2&=14 ! USERDEF in Baum ARRANGER
LET smprplay&=15 ! USERDEF in Baum ARRANGER
LET forward&=16 ! USERDEF in Baum ARRANGER
LET arrstrt&=17 ! USERDEF in Baum ARRANGER
LET arrend&=18 ! USERDEF in Baum ARRANGER
LET stop&=19 ! USERDEF in Baum ARRANGER
LET arrbox4&=20 ! BOX in Baum ARRANGER
LET playlen&=21 ! BOXTEXT in Baum ARRANGER
LET arreal&=22 ! USERDEF in Baum ARRANGER
LET arrblk&=23 ! USERDEF in Baum ARRANGER
LET arrbox3&=24 ! BOX in Baum ARRANGER
LET arrm1&=26 ! USERDEF in Baum ARRANGER
LET arrm2&=27 ! USERDEF in Baum ARRANGER
LET arrm3&=28 ! USERDEF in Baum ARRANGER
LET arrm4&=29 ! USERDEF in Baum ARRANGER
LET arrtri1&=33 ! BUTTON in Baum ARRANGER
LET arrtri2&=34 ! BUTTON in Baum ARRANGER
LET arrtri3&=35 ! BUTTON in Baum ARRANGER
LET arrtri4&=36 ! BUTTON in Baum ARRANGER
LET arrloop1&=39 ! USERDEF in Baum ARRANGER
LET arrloop2&=40 ! USERDEF in Baum ARRANGER
LET arrloop3&=41 ! USERDEF in Baum ARRANGER
LET arrloop4&=42 ! USERDEF in Baum ARRANGER
LET arrdel1&=49 ! USERDEF in Baum ARRANGER
LET arrdel2&=50 ! USERDEF in Baum ARRANGER
LET arrdel3&=51 ! USERDEF in Baum ARRANGER
LET arrdel4&=52 ! USERDEF in Baum ARRANGER
LET hardstrt&=53 ! USERDEF in Baum ARRANGER
LET hardend&=54 ! USERDEF in Baum ARRANGER
LET arrplay1&=57 ! USERDEF in Baum ARRANGER
LET arrplay2&=58 ! USERDEF in Baum ARRANGER
LET arrplay3&=59 ! USERDEF in Baum ARRANGER
LET arrplay4&=60 ! USERDEF in Baum ARRANGER
LET spur1&=61 ! BOXTEXT in Baum ARRANGER
LET spur2&=62 ! BOXTEXT in Baum ARRANGER
LET spur3&=63 ! BOXTEXT in Baum ARRANGER
LET spur4&=64 ! BOXTEXT in Baum ARRANGER
LET arrmem1&=65 ! BOXTEXT in Baum ARRANGER
LET arrmem2&=66 ! BOXTEXT in Baum ARRANGER
LET arrmem3&=67 ! BOXTEXT in Baum ARRANGER
LET arrmem4&=68 ! BOXTEXT in Baum ARRANGER
LET arrnr1&=69 ! BOXTEXT in Baum ARRANGER
LET arrnr2&=70 ! BOXTEXT in Baum ARRANGER
LET arrnr3&=71 ! BOXTEXT in Baum ARRANGER
LET arrnr4&=72 ! BOXTEXT in Baum ARRANGER
LET arrsmpr1&=73 ! BOXTEXT in Baum ARRANGER
LET arrsmpr2&=74 ! BOXTEXT in Baum ARRANGER
LET arrsmpr3&=75 ! BOXTEXT in Baum ARRANGER
LET arrsmpr4&=76 ! BOXTEXT in Baum ARRANGER
LET arrch1&=77 ! BOXTEXT in Baum ARRANGER
LET arrch2&=78 ! BOXTEXT in Baum ARRANGER
LET arrch3&=79 ! BOXTEXT in Baum ARRANGER
LET arrch4&=80 ! BOXTEXT in Baum ARRANGER
LET arrnote1&=81 ! BOXTEXT in Baum ARRANGER
LET arrnote2&=82 ! BOXTEXT in Baum ARRANGER
LET arrnote3&=83 ! BOXTEXT in Baum ARRANGER
LET arrnote4&=84 ! BOXTEXT in Baum ARRANGER
LET hardst1&=85 ! BOXTEXT in Baum ARRANGER
LET hardst2&=86 ! BOXTEXT in Baum ARRANGER
LET hardst3&=87 ! BOXTEXT in Baum ARRANGER
LET hardst4&=88 ! BOXTEXT in Baum ARRANGER
LET harde1&=89 ! BOXTEXT in Baum ARRANGER
LET harde2&=90 ! BOXTEXT in Baum ARRANGER
LET harde3&=91 ! BOXTEXT in Baum ARRANGER
LET harde4&=92 ! BOXTEXT in Baum ARRANGER
LET hardlen1&=93 ! BOXTEXT in Baum ARRANGER
LET hardlen2&=94 ! BOXTEXT in Baum ARRANGER
LET hardlen3&=95 ! BOXTEXT in Baum ARRANGER
LET hardlen4&=96 ! BOXTEXT in Baum ARRANGER
LET arrslide&=97 ! BOX in Baum ARRANGER
LET arrslbut&=98 ! BUTTON in Baum ARRANGER
LET arrexit&=99 ! BUTTON in Baum ARRANGER
LET arrhelp&=100 ! BOXTEXT in Baum ARRANGER
LET arrclip&=101 ! USERDEF in Baum ARRANGER
LET arrprint&=102 ! USERDEF in Baum ARRANGER
LET klavier&=103 ! USERDEF in Baum ARRANGER
LET slideup&=104 ! USERDEF in Baum ARRANGER
LET slidedwn&=105 ! USERDEF in Baum ARRANGER
LET playname&=106 ! BOXTEXT in Baum ARRANGER
LET arrtrash&=107 ! USERDEF in Baum ARRANGER
'
LET trakker&=2 ! Formular/Dialog
LET trakbox&=0 ! BOX in Baum TRAKKER
LET trakbox3&=1 ! BOX in Baum TRAKKER
LET hlpedit3&=2 ! USERDEF in Baum TRAKKER
LET hrdmerg2&=3 ! USERDEF in Baum TRAKKER
LET trakload&=4 ! USERDEF in Baum TRAKKER
LET trakplay&=5 ! USERDEF in Baum TRAKKER
LET trakdel&=6 ! USERDEF in Baum TRAKKER
LET traksall&=7 ! USERDEF in Baum TRAKKER
LET traklall&=8 ! USERDEF in Baum TRAKKER
LET killtrak&=9 ! USERDEF in Baum TRAKKER
LET trakclip&=10 ! USERDEF in Baum TRAKKER
LET tblksel&=11 ! USERDEF in Baum TRAKKER
LET tblkmove&=12 ! USERDEF in Baum TRAKKER
LET tblkcopy&=13 ! USERDEF in Baum TRAKKER
LET tblkdrag&=14 ! USERDEF in Baum TRAKKER
LET tblkedit&=15 ! USERDEF in Baum TRAKKER
LET tblksnap&=16 ! USERDEF in Baum TRAKKER
LET tblkvol&=17 ! USERDEF in Baum TRAKKER
LET tblkcut&=18 ! USERDEF in Baum TRAKKER
LET trkcd&=19 ! USERDEF in Baum TRAKKER
LET timeline&=20 ! BOXTEXT in Baum TRAKKER
LET trkslot&=21 ! BOXTEXT in Baum TRAKKER
LET trakedbx&=22 ! BOX in Baum TRAKKER
LET trakbox2&=23 ! BOX in Baum TRAKKER
LET trakbox5&=24 ! BOX in Baum TRAKKER
LET trkbx1&=25 ! BOX in Baum TRAKKER
LET trklevo1&=26 ! USERDEF in Baum TRAKKER
LET trklevt1&=27 ! BOXTEXT in Baum TRAKKER
LET trklevu1&=28 ! USERDEF in Baum TRAKKER
LET trkmute1&=29 ! USERDEF in Baum TRAKKER
LET trakk1&=30 ! BOXTEXT in Baum TRAKKER
LET trksolo1&=31 ! USERDEF in Baum TRAKKER
LET trkact1&=32 ! USERDEF in Baum TRAKKER
LET trkbx3&=33 ! BOX in Baum TRAKKER
LET trklevo3&=34 ! USERDEF in Baum TRAKKER
LET trklevt3&=35 ! BOXTEXT in Baum TRAKKER
LET trklevu3&=36 ! USERDEF in Baum TRAKKER
LET trkmute3&=37 ! USERDEF in Baum TRAKKER
LET trakk3&=38 ! BOXTEXT in Baum TRAKKER
LET trksolo3&=39 ! USERDEF in Baum TRAKKER
LET trkact3&=40 ! USERDEF in Baum TRAKKER
LET trktxt3&=41 ! BOXTEXT in Baum TRAKKER
LET panl3&=42 ! USERDEF in Baum TRAKKER
LET pantxt3&=43 ! BOXTEXT in Baum TRAKKER
LET trkbx4&=44 ! BOX in Baum TRAKKER
LET trklevo4&=45 ! USERDEF in Baum TRAKKER
LET trklevt4&=46 ! BOXTEXT in Baum TRAKKER
LET trklevu4&=47 ! USERDEF in Baum TRAKKER
LET trkmute4&=48 ! USERDEF in Baum TRAKKER
LET trakk4&=49 ! BOXTEXT in Baum TRAKKER
LET trksolo4&=50 ! USERDEF in Baum TRAKKER
LET trkact4&=51 ! USERDEF in Baum TRAKKER
LET trktxt4&=52 ! BOXTEXT in Baum TRAKKER
LET panl4&=53 ! USERDEF in Baum TRAKKER
LET pantxt4&=54 ! BOXTEXT in Baum TRAKKER
LET trkbx2&=55 ! BOX in Baum TRAKKER
LET trklevo2&=56 ! USERDEF in Baum TRAKKER
LET trklevt2&=57 ! BOXTEXT in Baum TRAKKER
LET trklevu2&=58 ! USERDEF in Baum TRAKKER
LET trkmute2&=59 ! USERDEF in Baum TRAKKER
LET trakk2&=60 ! BOXTEXT in Baum TRAKKER
LET trksolo2&=61 ! USERDEF in Baum TRAKKER
LET trkact2&=62 ! USERDEF in Baum TRAKKER
LET trktxt2&=63 ! BOXTEXT in Baum TRAKKER
LET panl2&=64 ! USERDEF in Baum TRAKKER
LET pantxt2&=65 ! BOXTEXT in Baum TRAKKER
LET trktxt1&=66 ! BOXTEXT in Baum TRAKKER
LET panr1&=67 ! USERDEF in Baum TRAKKER
LET panl1&=68 ! USERDEF in Baum TRAKKER
LET pantxt1&=69 ! BOXTEXT in Baum TRAKKER
LET panr2&=70 ! USERDEF in Baum TRAKKER
LET panr3&=71 ! USERDEF in Baum TRAKKER
LET panr4&=72 ! USERDEF in Baum TRAKKER
LET trktitxt&=73 ! TEXT in Baum TRAKKER
LET spurslid&=74 ! BOX in Baum TRAKKER
LET spurybut&=75 ! BUTTON in Baum TRAKKER
LET spuro&=76 ! USERDEF in Baum TRAKKER
LET spuru&=77 ! USERDEF in Baum TRAKKER
LET trakslid&=78 ! BOX in Baum TRAKKER
LET trakxbut&=79 ! BUTTON in Baum TRAKKER
LET trakxr&=80 ! USERDEF in Baum TRAKKER
LET trakxl&=81 ! USERDEF in Baum TRAKKER
LET zoomxl&=82 ! USERDEF in Baum TRAKKER
LET zoomxr&=83 ! USERDEF in Baum TRAKKER
LET zoomslid&=84 ! BOX in Baum TRAKKER
LET zoomxbut&=85 ! BUTTON in Baum TRAKKER
LET trakbxw&=86 ! BOX in Baum TRAKKER
LET trkmon&=88 ! BOXTEXT in Baum TRAKKER
LET trakstrt&=96 ! BOXTEXT in Baum TRAKKER
LET trakend&=97 ! BOXTEXT in Baum TRAKKER
LET trakdur&=98 ! BOXTEXT in Baum TRAKKER
LET traklen&=99 ! BOXTEXT in Baum TRAKKER
LET trksmpte&=100 ! BOXTEXT in Baum TRAKKER
LET trksize&=101 ! BOXTEXT in Baum TRAKKER
LET tpstrt&=102 ! BOXTEXT in Baum TRAKKER
LET tpend&=103 ! BOXTEXT in Baum TRAKKER
LET strtl&=104 ! USERDEF in Baum TRAKKER
LET strtr&=105 ! USERDEF in Baum TRAKKER
LET lend&=106 ! USERDEF in Baum TRAKKER
LET rend&=107 ! USERDEF in Baum TRAKKER
LET ltime&=108 ! USERDEF in Baum TRAKKER
LET rtime&=109 ! USERDEF in Baum TRAKKER
LET tpsl&=110 ! USERDEF in Baum TRAKKER
LET tpsr&=111 ! USERDEF in Baum TRAKKER
LET tpel&=112 ! USERDEF in Baum TRAKKER
LET tper&=113 ! USERDEF in Baum TRAKKER
LET trkblk&=114 ! USERDEF in Baum TRAKKER
LET trkcopy&=115 ! USERDEF in Baum TRAKKER
LET trkdel&=116 ! USERDEF in Baum TRAKKER
LET tblkplay&=119 ! USERDEF in Baum TRAKKER
LET tnamcom&=122 ! USERDEF in Baum TRAKKER
LET curve&=123 ! USERDEF in Baum TRAKKER
LET trksolo&=124 ! USERDEF in Baum TRAKKER
LET trakinfo&=125 ! BOXTEXT in Baum TRAKKER
LET trakbox4&=126 ! BOX in Baum TRAKKER
LET traktime&=127 ! BOXTEXT in Baum TRAKKER
LET trakname&=128 ! BOXTEXT in Baum TRAKKER
LET trkerr&=129 ! BOXTEXT in Baum TRAKKER
LET pause2&=131 ! USERDEF in Baum TRAKKER
LET rewind2&=132 ! USERDEF in Baum TRAKKER
LET stop2&=133 ! USERDEF in Baum TRAKKER
LET recplay2&=134 ! USERDEF in Baum TRAKKER
LET smpplay3&=135 ! USERDEF in Baum TRAKKER
LET smprpla2&=136 ! USERDEF in Baum TRAKKER
LET forward2&=137 ! USERDEF in Baum TRAKKER
LET trakanf&=138 ! USERDEF in Baum TRAKKER
LET trakfull&=139 ! USERDEF in Baum TRAKKER
LET smpstrt4&=140 ! USERDEF in Baum TRAKKER
LET smpauto4&=141 ! USERDEF in Baum TRAKKER
LET trkvbox&=142 ! BOXTEXT in Baum TRAKKER
LET trkvol&=144 ! USERDEF in Baum TRAKKER
LET trklvol&=148 ! BOX in Baum TRAKKER
LET trkrvol&=149 ! BOX in Baum TRAKKER
LET trklmax&=150 ! BOX in Baum TRAKKER
LET trkrmax&=151 ! BOX in Baum TRAKKER
LET trk4&=152 ! USERDEF in Baum TRAKKER
LET trk8&=153 ! USERDEF in Baum TRAKKER
LET trk12&=154 ! USERDEF in Baum TRAKKER
LET trk16&=155 ! USERDEF in Baum TRAKKER
LET trakhelp&=156 ! BOXTEXT in Baum TRAKKER
LET trakexit&=157 ! BUTTON in Baum TRAKKER
'
LET fsel&=3 ! Formular/Dialog
LET fselbox&=0 ! BOX in Baum FSEL
LET fselbox2&=1 ! BOX in Baum FSEL
LET fsbut1&=2 ! BOXTEXT in Baum FSEL
LET fsbut2&=3 ! BOXTEXT in Baum FSEL
LET fsbut3&=4 ! BOXTEXT in Baum FSEL
LET fsbut4&=5 ! BOXTEXT in Baum FSEL
LET fsbut5&=6 ! BOXTEXT in Baum FSEL
LET fsbut6&=7 ! BOXTEXT in Baum FSEL
LET fsbut7&=8 ! BOXTEXT in Baum FSEL
LET fsbut8&=9 ! BOXTEXT in Baum FSEL
LET fsbut9&=10 ! BOXTEXT in Baum FSEL
LET fsbut10&=11 ! BOXTEXT in Baum FSEL
LET fsbut11&=12 ! BOXTEXT in Baum FSEL
LET fsbut12&=13 ! BOXTEXT in Baum FSEL
LET fsbut13&=14 ! BOXTEXT in Baum FSEL
LET fsbut14&=15 ! BOXTEXT in Baum FSEL
LET fsbut15&=16 ! BOXTEXT in Baum FSEL
LET fstxt1&=17 ! BOXTEXT in Baum FSEL
LET fstxt2&=18 ! BOXTEXT in Baum FSEL
LET fstxt3&=19 ! BOXTEXT in Baum FSEL
LET fstxt4&=20 ! BOXTEXT in Baum FSEL
LET fstxt5&=21 ! BOXTEXT in Baum FSEL
LET fstxt6&=22 ! BOXTEXT in Baum FSEL
LET fstxt7&=23 ! BOXTEXT in Baum FSEL
LET fstxt8&=24 ! BOXTEXT in Baum FSEL
LET fstxt9&=25 ! BOXTEXT in Baum FSEL
LET fstxt10&=26 ! BOXTEXT in Baum FSEL
LET fstxt11&=27 ! BOXTEXT in Baum FSEL
LET fstxt12&=28 ! BOXTEXT in Baum FSEL
LET fstxt13&=29 ! BOXTEXT in Baum FSEL
LET fstxt14&=30 ! BOXTEXT in Baum FSEL
LET fstxt15&=31 ! BOXTEXT in Baum FSEL
LET fsslide&=32 ! BOX in Baum FSEL
LET fssldbut&=33 ! BUTTON in Baum FSEL
LET fsok&=34 ! BUTTON in Baum FSEL
LET fshelp&=35 ! BOXTEXT in Baum FSEL
LET fsplay&=36 ! USERDEF in Baum FSEL
LET fsexit&=37 ! BUTTON in Baum FSEL
LET fsordner&=39 ! BUTTON in Baum FSEL
LET fsotxt&=40 ! BOXTEXT in Baum FSEL
LET fsmatic&=41 ! USERDEF in Baum FSEL
LET fsins&=42 ! USERDEF in Baum FSEL
LET fsdel&=43 ! USERDEF in Baum FSEL
LET fsadd&=44 ! BUTTON in Baum FSEL
LET fsnew&=45 ! BUTTON in Baum FSEL
LET fsload&=46 ! USERDEF in Baum FSEL
LET fssave&=47 ! USERDEF in Baum FSEL
LET fsclf&=48 ! USERDEF in Baum FSEL
LET fssldup&=49 ! USERDEF in Baum FSEL
LET fsslddwn&=50 ! USERDEF in Baum FSEL
LET fsstop&=51 ! USERDEF in Baum FSEL
LET fswait&=52 ! USERDEF in Baum FSEL
LET fsend&=53 ! USERDEF in Baum FSEL
LET fstime&=54 ! BOXTEXT in Baum FSEL
LET fslplay&=55 ! USERDEF in Baum FSEL
LET tfsabc&=56 ! USERDEF in Baum FSEL
LET tfsearch&=57 ! BUTTON in Baum FSEL
LET nfseltxt&=58 ! TEXT in Baum FSEL
'
rsc$="STARLOM.RSC"
'
RETURN
'
> PROCEDURE rsc_for_lo_color ! Resource fÅr Farbauflîsungen kleiner als 1024x768
REM Resource Datei Indizes fÅr STARLOC
'
LET smpedit&=0 ! Formular/Dialog
LET editbox7&=0 ! BOX in Baum SMPEDIT
LET editbox&=1 ! BOX in Baum SMPEDIT
LET zomslide&=2 ! BOX in Baum SMPEDIT
LET zoombutt&=3 ! BUTTON in Baum SMPEDIT
LET zooml&=4 ! USERDEF in Baum SMPEDIT
LET zoomr&=5 ! USERDEF in Baum SMPEDIT
LET csmintex&=7 ! TEXT in Baum SMPEDIT
LET cemaxtex&=8 ! TEXT in Baum SMPEDIT
LET cstxt&=9 ! BOXTEXT in Baum SMPEDIT
LET cetxt&=10 ! BOXTEXT in Baum SMPEDIT
LET smpl3&=12 ! USERDEF in Baum SMPEDIT
LET smpl2&=13 ! USERDEF in Baum SMPEDIT
LET smpl1&=14 ! USERDEF in Baum SMPEDIT
LET smpr1&=15 ! USERDEF in Baum SMPEDIT
LET smpr2&=16 ! USERDEF in Baum SMPEDIT
LET smpr3&=17 ! USERDEF in Baum SMPEDIT
LET smpanf&=18 ! USERDEF in Baum SMPEDIT
LET smpmid&=19 ! USERDEF in Baum SMPEDIT
LET smpend&=20 ! USERDEF in Baum SMPEDIT
LET editbox5&=21 ! BOX in Baum SMPEDIT
LET mover&=23 ! BOXTEXT in Baum SMPEDIT
LET movecirc&=24 ! BOXCHAR in Baum SMPEDIT
LET trash&=25 ! USERDEF in Baum SMPEDIT
LET smpauto2&=28 ! USERDEF in Baum SMPEDIT
LET smpstrt2&=29 ! USERDEF in Baum SMPEDIT
LET recplay3&=30 ! USERDEF in Baum SMPEDIT
LET smpplay&=31 ! USERDEF in Baum SMPEDIT
LET smpstop&=32 ! USERDEF in Baum SMPEDIT
LET smpwait&=33 ! USERDEF in Baum SMPEDIT
LET hard&=34 ! USERDEF in Baum SMPEDIT
LET smplen&=37 ! BOXTEXT in Baum SMPEDIT
LET smpsec&=38 ! BOXTEXT in Baum SMPEDIT
LET smpfile&=39 ! BOXTEXT in Baum SMPEDIT
LET smprate&=40 ! BOXTEXT in Baum SMPEDIT
LET showxy&=41 ! BOXTEXT in Baum SMPEDIT
LET pntprsmp&=42 ! BOXTEXT in Baum SMPEDIT
LET smpname&=43 ! BOXTEXT in Baum SMPEDIT
LET freemem&=44 ! BOXTEXT in Baum SMPEDIT
LET clock&=45 ! BOXTEXT in Baum SMPEDIT
LET resolu&=47 ! BOXTEXT in Baum SMPEDIT
LET rate&=51 ! BOXTEXT in Baum SMPEDIT
LET ratecirc&=52 ! BOXCHAR in Baum SMPEDIT
LET flyer&=53 ! USERDEF in Baum SMPEDIT
LET smpedhlp&=55 ! BOXTEXT in Baum SMPEDIT
LET smpexit&=56 ! BUTTON in Baum SMPEDIT
LET editbox6&=57 ! BOX in Baum SMPEDIT
LET smppmark&=58 ! USERDEF in Baum SMPEDIT
LET midi&=59 ! USERDEF in Baum SMPEDIT
LET mintext&=60 ! BOXTEXT in Baum SMPEDIT
LET smploop&=61 ! USERDEF in Baum SMPEDIT
LET smpcblk&=62 ! USERDEF in Baum SMPEDIT
LET pixzoom&=63 ! USERDEF in Baum SMPEDIT
LET editbox3&=64 ! BOX in Baum SMPEDIT
LET edmtims&=65 ! BOXTEXT in Baum SMPEDIT
LET edmtime&=66 ! BOXTEXT in Baum SMPEDIT
LET edmdown&=67 ! USERDEF in Baum SMPEDIT
LET edmslide&=68 ! BOX in Baum SMPEDIT
LET edmbut&=69 ! BUTTON in Baum SMPEDIT
LET edmup&=70 ! USERDEF in Baum SMPEDIT
LET edmnr&=71 ! BOXTEXT in Baum SMPEDIT
LET edmtimi&=72 ! BOXTEXT in Baum SMPEDIT
LET edmtimr&=73 ! BOXTEXT in Baum SMPEDIT
LET edmtxt&=74 ! BOXTEXT in Baum SMPEDIT
LET edmbox&=75 ! BOX in Baum SMPEDIT
LET edmbuts&=76 ! USERDEF in Baum SMPEDIT
LET edmbute&=77 ! USERDEF in Baum SMPEDIT
LET edmbuti&=78 ! USERDEF in Baum SMPEDIT
LET edmbutr&=79 ! USERDEF in Baum SMPEDIT
LET editbox2&=80 ! BOX in Baum SMPEDIT
LET setuper&=81 ! USERDEF in Baum SMPEDIT
LET edfade&=82 ! USERDEF in Baum SMPEDIT
LET peaksw2&=83 ! USERDEF in Baum SMPEDIT
LET disk&=84 ! USERDEF in Baum SMPEDIT
LET loopart&=85 ! USERDEF in Baum SMPEDIT
LET blocfunc&=86 ! USERDEF in Baum SMPEDIT
LET arrange&=87 ! USERDEF in Baum SMPEDIT
LET smpload&=88 ! USERDEF in Baum SMPEDIT
LET smpsave&=89 ! USERDEF in Baum SMPEDIT
LET infoicon&=90 ! USERDEF in Baum SMPEDIT
LET edmidi&=91 ! USERDEF in Baum SMPEDIT
LET trak&=92 ! USERDEF in Baum SMPEDIT
LET edsmp16&=93 ! USERDEF in Baum SMPEDIT
LET swdsp&=94 ! USERDEF in Baum SMPEDIT
LET smpdbank&=95 ! USERDEF in Baum SMPEDIT
LET swmark&=96 ! USERDEF in Baum SMPEDIT
LET wmodes&=97 ! USERDEF in Baum SMPEDIT
LET swyzoom&=98 ! USERDEF in Baum SMPEDIT
LET swclick&=99 ! USERDEF in Baum SMPEDIT
LET swdraw&=100 ! USERDEF in Baum SMPEDIT
LET swblk&=101 ! USERDEF in Baum SMPEDIT
LET scrubs&=102 ! USERDEF in Baum SMPEDIT
LET swsearch&=103 ! USERDEF in Baum SMPEDIT
LET curvbox&=104 ! BOX in Baum SMPEDIT
LET editbox4&=105 ! BOX in Baum SMPEDIT
LET editbox8&=106 ! BOX in Baum SMPEDIT
LET smptxr&=107 ! TEXT in Baum SMPEDIT
LET smptxl&=108 ! TEXT in Baum SMPEDIT
LET rm80&=109 ! BOXTEXT in Baum SMPEDIT
LET rp0&=110 ! BOXTEXT in Baum SMPEDIT
LET rp80&=111 ! BOXTEXT in Baum SMPEDIT
LET rp60&=112 ! BOXTEXT in Baum SMPEDIT
LET rp40&=113 ! BOXTEXT in Baum SMPEDIT
LET rm60&=114 ! BOXTEXT in Baum SMPEDIT
LET rm40&=115 ! BOXTEXT in Baum SMPEDIT
LET lp80&=116 ! BOXTEXT in Baum SMPEDIT
LET lm80&=117 ! BOXTEXT in Baum SMPEDIT
LET lp40&=118 ! BOXTEXT in Baum SMPEDIT
LET lp60&=119 ! BOXTEXT in Baum SMPEDIT
LET lm60&=120 ! BOXTEXT in Baum SMPEDIT
LET lm40&=121 ! BOXTEXT in Baum SMPEDIT
LET lm20&=122 ! BOXTEXT in Baum SMPEDIT
LET lp0&=123 ! BOXTEXT in Baum SMPEDIT
LET rp20&=124 ! BOXTEXT in Baum SMPEDIT
LET rm20&=125 ! BOXTEXT in Baum SMPEDIT
LET lp20&=126 ! BOXTEXT in Baum SMPEDIT
LET scrlslde&=127 ! BOX in Baum SMPEDIT
LET scrolbut&=128 ! BUTTON in Baum SMPEDIT
LET lscroll&=129 ! USERDEF in Baum SMPEDIT
LET rscroll&=130 ! USERDEF in Baum SMPEDIT
LET lr100&=131 ! BOXTEXT in Baum SMPEDIT
LET blkfilel&=138 ! BOX in Baum SMPEDIT
LET blkfiler&=139 ! BOX in Baum SMPEDIT
LET blkfile&=140 ! TEXT in Baum SMPEDIT
'
LET arranger&=1 ! Formular/Dialog
LET arrbox&=0 ! BOX in Baum ARRANGER
LET arrbox2&=1 ! BOX in Baum ARRANGER
LET hlpedit2&=2 ! USERDEF in Baum ARRANGER
LET arrload&=3 ! USERDEF in Baum ARRANGER
LET arrsave&=4 ! USERDEF in Baum ARRANGER
LET arrmidi&=5 ! USERDEF in Baum ARRANGER
LET arrins&=6 ! USERDEF in Baum ARRANGER
LET arrdel&=7 ! USERDEF in Baum ARRANGER
LET smpauto3&=9 ! USERDEF in Baum ARRANGER
LET smpstrt3&=10 ! USERDEF in Baum ARRANGER
LET pause&=11 ! USERDEF in Baum ARRANGER
LET rewind&=12 ! USERDEF in Baum ARRANGER
LET recplay&=13 ! USERDEF in Baum ARRANGER
LET smpplay2&=14 ! USERDEF in Baum ARRANGER
LET smprplay&=15 ! USERDEF in Baum ARRANGER
LET forward&=16 ! USERDEF in Baum ARRANGER
LET arrstrt&=17 ! USERDEF in Baum ARRANGER
LET arrend&=18 ! USERDEF in Baum ARRANGER
LET stop&=19 ! USERDEF in Baum ARRANGER
LET arrbox4&=20 ! BOX in Baum ARRANGER
LET playlen&=21 ! BOXTEXT in Baum ARRANGER
LET arreal&=22 ! USERDEF in Baum ARRANGER
LET arrblk&=23 ! USERDEF in Baum ARRANGER
LET arrbox3&=24 ! BOX in Baum ARRANGER
LET arrm1&=26 ! USERDEF in Baum ARRANGER
LET arrm2&=27 ! USERDEF in Baum ARRANGER
LET arrm3&=28 ! USERDEF in Baum ARRANGER
LET arrm4&=29 ! USERDEF in Baum ARRANGER
LET arrtri1&=33 ! BUTTON in Baum ARRANGER
LET arrtri2&=34 ! BUTTON in Baum ARRANGER
LET arrtri3&=35 ! BUTTON in Baum ARRANGER
LET arrtri4&=36 ! BUTTON in Baum ARRANGER
LET arrloop1&=39 ! USERDEF in Baum ARRANGER
LET arrloop2&=40 ! USERDEF in Baum ARRANGER
LET arrloop3&=41 ! USERDEF in Baum ARRANGER
LET arrloop4&=42 ! USERDEF in Baum ARRANGER
LET arrdel1&=49 ! USERDEF in Baum ARRANGER
LET arrdel2&=50 ! USERDEF in Baum ARRANGER
LET arrdel3&=51 ! USERDEF in Baum ARRANGER
LET arrdel4&=52 ! USERDEF in Baum ARRANGER
LET hardstrt&=53 ! USERDEF in Baum ARRANGER
LET hardend&=54 ! USERDEF in Baum ARRANGER
LET arrplay1&=57 ! USERDEF in Baum ARRANGER
LET arrplay2&=58 ! USERDEF in Baum ARRANGER
LET arrplay3&=59 ! USERDEF in Baum ARRANGER
LET arrplay4&=60 ! USERDEF in Baum ARRANGER
LET spur1&=61 ! BOXTEXT in Baum ARRANGER
LET spur2&=62 ! BOXTEXT in Baum ARRANGER
LET spur3&=63 ! BOXTEXT in Baum ARRANGER
LET spur4&=64 ! BOXTEXT in Baum ARRANGER
LET arrnr1&=65 ! BOXTEXT in Baum ARRANGER
LET arrnr2&=66 ! BOXTEXT in Baum ARRANGER
LET arrnr3&=67 ! BOXTEXT in Baum ARRANGER
LET arrnr4&=68 ! BOXTEXT in Baum ARRANGER
LET arrmem1&=69 ! BOXTEXT in Baum ARRANGER
LET arrmem2&=70 ! BOXTEXT in Baum ARRANGER
LET arrmem3&=71 ! BOXTEXT in Baum ARRANGER
LET arrmem4&=72 ! BOXTEXT in Baum ARRANGER
LET arrsmpr1&=73 ! BOXTEXT in Baum ARRANGER
LET arrsmpr2&=74 ! BOXTEXT in Baum ARRANGER
LET arrsmpr3&=75 ! BOXTEXT in Baum ARRANGER
LET arrsmpr4&=76 ! BOXTEXT in Baum ARRANGER
LET arrch1&=77 ! BOXTEXT in Baum ARRANGER
LET arrch2&=78 ! BOXTEXT in Baum ARRANGER
LET arrch3&=79 ! BOXTEXT in Baum ARRANGER
LET arrch4&=80 ! BOXTEXT in Baum ARRANGER
LET arrnote1&=81 ! BOXTEXT in Baum ARRANGER
LET arrnote2&=82 ! BOXTEXT in Baum ARRANGER
LET arrnote3&=83 ! BOXTEXT in Baum ARRANGER
LET arrnote4&=84 ! BOXTEXT in Baum ARRANGER
LET hardst1&=85 ! BOXTEXT in Baum ARRANGER
LET hardst2&=86 ! BOXTEXT in Baum ARRANGER
LET hardst3&=87 ! BOXTEXT in Baum ARRANGER
LET hardst4&=88 ! BOXTEXT in Baum ARRANGER
LET harde1&=89 ! BOXTEXT in Baum ARRANGER
LET harde2&=90 ! BOXTEXT in Baum ARRANGER
LET harde3&=91 ! BOXTEXT in Baum ARRANGER
LET harde4&=92 ! BOXTEXT in Baum ARRANGER
LET hardlen1&=93 ! BOXTEXT in Baum ARRANGER
LET hardlen2&=94 ! BOXTEXT in Baum ARRANGER
LET hardlen3&=95 ! BOXTEXT in Baum ARRANGER
LET hardlen4&=96 ! BOXTEXT in Baum ARRANGER
LET arrslide&=97 ! BOX in Baum ARRANGER
LET arrslbut&=98 ! BUTTON in Baum ARRANGER
LET arrexit&=99 ! BUTTON in Baum ARRANGER
LET arrhelp&=100 ! BOXTEXT in Baum ARRANGER
LET arrclip&=101 ! USERDEF in Baum ARRANGER
LET arrprint&=102 ! USERDEF in Baum ARRANGER
LET klavier&=103 ! USERDEF in Baum ARRANGER
LET slideup&=104 ! USERDEF in Baum ARRANGER
LET slidedwn&=105 ! USERDEF in Baum ARRANGER
LET playname&=106 ! BOXTEXT in Baum ARRANGER
LET arrtrash&=107 ! USERDEF in Baum ARRANGER
'
LET trakker&=2 ! Formular/Dialog
LET trakbox&=0 ! BOX in Baum TRAKKER
LET trakbox3&=1 ! BOX in Baum TRAKKER
LET hlpedit3&=2 ! USERDEF in Baum TRAKKER
LET hrdmerg2&=3 ! USERDEF in Baum TRAKKER
LET trakload&=4 ! USERDEF in Baum TRAKKER
LET trakplay&=5 ! USERDEF in Baum TRAKKER
LET trakdel&=6 ! USERDEF in Baum TRAKKER
LET traksall&=7 ! USERDEF in Baum TRAKKER
LET traklall&=8 ! USERDEF in Baum TRAKKER
LET killtrak&=9 ! USERDEF in Baum TRAKKER
LET trakclip&=10 ! USERDEF in Baum TRAKKER
LET tblksel&=11 ! USERDEF in Baum TRAKKER
LET tblkmove&=12 ! USERDEF in Baum TRAKKER
LET tblkcopy&=13 ! USERDEF in Baum TRAKKER
LET tblkdrag&=14 ! USERDEF in Baum TRAKKER
LET tblkedit&=15 ! USERDEF in Baum TRAKKER
LET tblksnap&=16 ! USERDEF in Baum TRAKKER
LET tblkvol&=17 ! USERDEF in Baum TRAKKER
LET tblkcut&=18 ! USERDEF in Baum TRAKKER
LET trkcd&=19 ! USERDEF in Baum TRAKKER
LET timeline&=20 ! BOXTEXT in Baum TRAKKER
LET trkslot&=21 ! BOXTEXT in Baum TRAKKER
LET trakedbx&=22 ! BOX in Baum TRAKKER
LET trakbox2&=23 ! BOX in Baum TRAKKER
LET trakbox5&=24 ! BOX in Baum TRAKKER
LET trkbx1&=25 ! BOX in Baum TRAKKER
LET trklevo1&=26 ! USERDEF in Baum TRAKKER
LET trklevt1&=27 ! BOXTEXT in Baum TRAKKER
LET trklevu1&=28 ! USERDEF in Baum TRAKKER
LET trkmute1&=29 ! USERDEF in Baum TRAKKER
LET trakk1&=30 ! BOXTEXT in Baum TRAKKER
LET trksolo1&=31 ! USERDEF in Baum TRAKKER
LET trkact1&=32 ! USERDEF in Baum TRAKKER
LET trkbx3&=33 ! BOX in Baum TRAKKER
LET trklevo3&=34 ! USERDEF in Baum TRAKKER
LET trklevt3&=35 ! BOXTEXT in Baum TRAKKER
LET trklevu3&=36 ! USERDEF in Baum TRAKKER
LET trkmute3&=37 ! USERDEF in Baum TRAKKER
LET trakk3&=38 ! BOXTEXT in Baum TRAKKER
LET trksolo3&=39 ! USERDEF in Baum TRAKKER
LET trkact3&=40 ! USERDEF in Baum TRAKKER
LET trktxt3&=41 ! BOXTEXT in Baum TRAKKER
LET panl3&=42 ! USERDEF in Baum TRAKKER
LET pantxt3&=43 ! BOXTEXT in Baum TRAKKER
LET trkbx4&=44 ! BOX in Baum TRAKKER
LET trklevo4&=45 ! USERDEF in Baum TRAKKER
LET trklevt4&=46 ! BOXTEXT in Baum TRAKKER
LET trklevu4&=47 ! USERDEF in Baum TRAKKER
LET trkmute4&=48 ! USERDEF in Baum TRAKKER
LET trakk4&=49 ! BOXTEXT in Baum TRAKKER
LET trksolo4&=50 ! USERDEF in Baum TRAKKER
LET trkact4&=51 ! USERDEF in Baum TRAKKER
LET trktxt4&=52 ! BOXTEXT in Baum TRAKKER
LET panl4&=53 ! USERDEF in Baum TRAKKER
LET pantxt4&=54 ! BOXTEXT in Baum TRAKKER
LET trkbx2&=55 ! BOX in Baum TRAKKER
LET trklevo2&=56 ! USERDEF in Baum TRAKKER
LET trklevt2&=57 ! BOXTEXT in Baum TRAKKER
LET trklevu2&=58 ! USERDEF in Baum TRAKKER
LET trkmute2&=59 ! USERDEF in Baum TRAKKER
LET trakk2&=60 ! BOXTEXT in Baum TRAKKER
LET trksolo2&=61 ! USERDEF in Baum TRAKKER
LET trkact2&=62 ! USERDEF in Baum TRAKKER
LET trktxt2&=63 ! BOXTEXT in Baum TRAKKER
LET panl2&=64 ! USERDEF in Baum TRAKKER
LET pantxt2&=65 ! BOXTEXT in Baum TRAKKER
LET trktxt1&=66 ! BOXTEXT in Baum TRAKKER
LET panr1&=67 ! USERDEF in Baum TRAKKER
LET panl1&=68 ! USERDEF in Baum TRAKKER
LET pantxt1&=69 ! BOXTEXT in Baum TRAKKER
LET panr2&=70 ! USERDEF in Baum TRAKKER
LET panr3&=71 ! USERDEF in Baum TRAKKER
LET panr4&=72 ! USERDEF in Baum TRAKKER
LET trktitxt&=73 ! TEXT in Baum TRAKKER
LET spurslid&=74 ! BOX in Baum TRAKKER
LET spurybut&=75 ! BUTTON in Baum TRAKKER
LET spuro&=76 ! USERDEF in Baum TRAKKER
LET spuru&=77 ! USERDEF in Baum TRAKKER
LET trakslid&=78 ! BOX in Baum TRAKKER
LET trakxbut&=79 ! BUTTON in Baum TRAKKER
LET trakxr&=80 ! USERDEF in Baum TRAKKER
LET trakxl&=81 ! USERDEF in Baum TRAKKER
LET zoomxl&=82 ! USERDEF in Baum TRAKKER
LET zoomxr&=83 ! USERDEF in Baum TRAKKER
LET zoomslid&=84 ! BOX in Baum TRAKKER
LET zoomxbut&=85 ! BUTTON in Baum TRAKKER
LET trakbxw&=86 ! BOX in Baum TRAKKER
LET trkmon&=88 ! BOXTEXT in Baum TRAKKER
LET trakstrt&=96 ! BOXTEXT in Baum TRAKKER
LET trakend&=97 ! BOXTEXT in Baum TRAKKER
LET trakdur&=98 ! BOXTEXT in Baum TRAKKER
LET traklen&=99 ! BOXTEXT in Baum TRAKKER
LET trksmpte&=100 ! BOXTEXT in Baum TRAKKER
LET trksize&=101 ! BOXTEXT in Baum TRAKKER
LET tpstrt&=102 ! BOXTEXT in Baum TRAKKER
LET tpend&=103 ! BOXTEXT in Baum TRAKKER
LET strtl&=104 ! USERDEF in Baum TRAKKER
LET strtr&=105 ! USERDEF in Baum TRAKKER
LET lend&=106 ! USERDEF in Baum TRAKKER
LET rend&=107 ! USERDEF in Baum TRAKKER
LET ltime&=108 ! USERDEF in Baum TRAKKER
LET rtime&=109 ! USERDEF in Baum TRAKKER
LET tpsl&=110 ! USERDEF in Baum TRAKKER
LET tpsr&=111 ! USERDEF in Baum TRAKKER
LET tpel&=112 ! USERDEF in Baum TRAKKER
LET tper&=113 ! USERDEF in Baum TRAKKER
LET trkblk&=114 ! USERDEF in Baum TRAKKER
LET trkcopy&=115 ! USERDEF in Baum TRAKKER
LET trkdel&=116 ! USERDEF in Baum TRAKKER
LET tblkplay&=119 ! USERDEF in Baum TRAKKER
LET tnamcom&=122 ! USERDEF in Baum TRAKKER
LET curve&=123 ! USERDEF in Baum TRAKKER
LET trksolo&=124 ! USERDEF in Baum TRAKKER
LET trakinfo&=125 ! BOXTEXT in Baum TRAKKER
LET trakbox4&=126 ! BOX in Baum TRAKKER
LET traktime&=127 ! BOXTEXT in Baum TRAKKER
LET trakname&=128 ! BOXTEXT in Baum TRAKKER
LET trkerr&=129 ! BOXTEXT in Baum TRAKKER
LET pause2&=131 ! USERDEF in Baum TRAKKER
LET rewind2&=132 ! USERDEF in Baum TRAKKER
LET stop2&=133 ! USERDEF in Baum TRAKKER
LET recplay2&=134 ! USERDEF in Baum TRAKKER
LET smpplay3&=135 ! USERDEF in Baum TRAKKER
LET smprpla2&=136 ! USERDEF in Baum TRAKKER
LET forward2&=137 ! USERDEF in Baum TRAKKER
LET trakanf&=138 ! USERDEF in Baum TRAKKER
LET trakfull&=139 ! USERDEF in Baum TRAKKER
LET smpstrt4&=140 ! USERDEF in Baum TRAKKER
LET smpauto4&=141 ! USERDEF in Baum TRAKKER
LET trkvbox&=142 ! BOXTEXT in Baum TRAKKER
LET trkvol&=144 ! USERDEF in Baum TRAKKER
LET trklvol&=148 ! BOX in Baum TRAKKER
LET trkrvol&=149 ! BOX in Baum TRAKKER
LET trklmax&=150 ! BOX in Baum TRAKKER
LET trkrmax&=151 ! BOX in Baum TRAKKER
LET trk4&=152 ! USERDEF in Baum TRAKKER
LET trk8&=153 ! USERDEF in Baum TRAKKER
LET trk12&=154 ! USERDEF in Baum TRAKKER
LET trk16&=155 ! USERDEF in Baum TRAKKER
LET trakhelp&=156 ! BOXTEXT in Baum TRAKKER
LET trakexit&=157 ! BUTTON in Baum TRAKKER
'
LET fsel&=3 ! Formular/Dialog
LET fselbox&=0 ! BOX in Baum FSEL
LET fselbox2&=1 ! BOX in Baum FSEL
LET fsbut1&=2 ! BOXTEXT in Baum FSEL
LET fsbut2&=3 ! BOXTEXT in Baum FSEL
LET fsbut3&=4 ! BOXTEXT in Baum FSEL
LET fsbut4&=5 ! BOXTEXT in Baum FSEL
LET fsbut5&=6 ! BOXTEXT in Baum FSEL
LET fsbut6&=7 ! BOXTEXT in Baum FSEL
LET fsbut7&=8 ! BOXTEXT in Baum FSEL
LET fsbut8&=9 ! BOXTEXT in Baum FSEL
LET fsbut9&=10 ! BOXTEXT in Baum FSEL
LET fsbut10&=11 ! BOXTEXT in Baum FSEL
LET fsbut11&=12 ! BOXTEXT in Baum FSEL
LET fsbut12&=13 ! BOXTEXT in Baum FSEL
LET fsbut13&=14 ! BOXTEXT in Baum FSEL
LET fsbut14&=15 ! BOXTEXT in Baum FSEL
LET fsbut15&=16 ! BOXTEXT in Baum FSEL
LET fstxt1&=17 ! BOXTEXT in Baum FSEL
LET fstxt2&=18 ! BOXTEXT in Baum FSEL
LET fstxt3&=19 ! BOXTEXT in Baum FSEL
LET fstxt4&=20 ! BOXTEXT in Baum FSEL
LET fstxt5&=21 ! BOXTEXT in Baum FSEL
LET fstxt6&=22 ! BOXTEXT in Baum FSEL
LET fstxt7&=23 ! BOXTEXT in Baum FSEL
LET fstxt8&=24 ! BOXTEXT in Baum FSEL
LET fstxt9&=25 ! BOXTEXT in Baum FSEL
LET fstxt10&=26 ! BOXTEXT in Baum FSEL
LET fstxt11&=27 ! BOXTEXT in Baum FSEL
LET fstxt12&=28 ! BOXTEXT in Baum FSEL
LET fstxt13&=29 ! BOXTEXT in Baum FSEL
LET fstxt14&=30 ! BOXTEXT in Baum FSEL
LET fstxt15&=31 ! BOXTEXT in Baum FSEL
LET fsslide&=32 ! BOX in Baum FSEL
LET fssldbut&=33 ! BUTTON in Baum FSEL
LET fsok&=34 ! BUTTON in Baum FSEL
LET fshelp&=35 ! BOXTEXT in Baum FSEL
LET fsplay&=36 ! USERDEF in Baum FSEL
LET fsexit&=37 ! BUTTON in Baum FSEL
LET fsordner&=39 ! BUTTON in Baum FSEL
LET fsotxt&=40 ! BOXTEXT in Baum FSEL
LET fsmatic&=41 ! USERDEF in Baum FSEL
LET fsins&=42 ! USERDEF in Baum FSEL
LET fsdel&=43 ! USERDEF in Baum FSEL
LET fsadd&=44 ! BUTTON in Baum FSEL
LET fsnew&=45 ! BUTTON in Baum FSEL
LET fsload&=46 ! USERDEF in Baum FSEL
LET fssave&=47 ! USERDEF in Baum FSEL
LET fsclf&=48 ! USERDEF in Baum FSEL
LET fssldup&=49 ! USERDEF in Baum FSEL
LET fsslddwn&=50 ! USERDEF in Baum FSEL
LET fsstop&=51 ! USERDEF in Baum FSEL
LET fswait&=52 ! USERDEF in Baum FSEL
LET fsend&=53 ! USERDEF in Baum FSEL
LET fstime&=54 ! BOXTEXT in Baum FSEL
LET fslplay&=55 ! USERDEF in Baum FSEL
LET tfsabc&=56 ! USERDEF in Baum FSEL
LET tfsearch&=57 ! BUTTON in Baum FSEL
LET nfseltxt&=58 ! TEXT in Baum FSEL
'
rsc$="STARLOC.RSC"
'
RETURN
'
> PROCEDURE rsc_for_hi_mono  ! Resource fÅr monochrome Auflîsungen ab 1024x768
REM Resource Datei Indizes fÅr STARHIM
'
LET smpedit&=0 ! Formular/Dialog
LET editbox7&=0 ! BOX in Baum SMPEDIT
LET editbox&=1 ! BOX in Baum SMPEDIT
LET csmintex&=3 ! TEXT in Baum SMPEDIT
LET cemaxtex&=4 ! TEXT in Baum SMPEDIT
LET zomslide&=16 ! BOX in Baum SMPEDIT
LET zoombutt&=17 ! BUTTON in Baum SMPEDIT
LET zooml&=18 ! USERDEF in Baum SMPEDIT
LET zoomr&=19 ! USERDEF in Baum SMPEDIT
LET pixzoom&=20 ! USERDEF in Baum SMPEDIT
LET editbox5&=21 ! BOX in Baum SMPEDIT
LET smpanf&=22 ! USERDEF in Baum SMPEDIT
LET smpr1&=23 ! USERDEF in Baum SMPEDIT
LET smpl1&=24 ! USERDEF in Baum SMPEDIT
LET smpl2&=25 ! USERDEF in Baum SMPEDIT
LET smpr2&=26 ! USERDEF in Baum SMPEDIT
LET smpl3&=27 ! USERDEF in Baum SMPEDIT
LET smpmid&=28 ! USERDEF in Baum SMPEDIT
LET smpend&=29 ! USERDEF in Baum SMPEDIT
LET smpr3&=30 ! USERDEF in Baum SMPEDIT
LET mover&=32 ! BOXTEXT in Baum SMPEDIT
LET movecirc&=33 ! BOXCHAR in Baum SMPEDIT
LET editbox3&=34 ! BOX in Baum SMPEDIT
LET edmtims&=35 ! BOXTEXT in Baum SMPEDIT
LET edmtime&=36 ! BOXTEXT in Baum SMPEDIT
LET edmdown&=37 ! USERDEF in Baum SMPEDIT
LET edmslide&=38 ! BOX in Baum SMPEDIT
LET edmbut&=39 ! BUTTON in Baum SMPEDIT
LET edmup&=40 ! USERDEF in Baum SMPEDIT
LET edmnr&=41 ! BOXTEXT in Baum SMPEDIT
LET edmtimi&=42 ! BOXTEXT in Baum SMPEDIT
LET edmtimr&=43 ! BOXTEXT in Baum SMPEDIT
LET edmtxt&=44 ! BOXTEXT in Baum SMPEDIT
LET edmbox&=45 ! BOX in Baum SMPEDIT
LET edmbuts&=46 ! USERDEF in Baum SMPEDIT
LET edmbute&=47 ! USERDEF in Baum SMPEDIT
LET edmbuti&=48 ! USERDEF in Baum SMPEDIT
LET edmbutr&=49 ! USERDEF in Baum SMPEDIT
LET cstxt&=50 ! BOXTEXT in Baum SMPEDIT
LET cetxt&=51 ! BOXTEXT in Baum SMPEDIT
LET resolu&=52 ! BOXTEXT in Baum SMPEDIT
LET resolirc&=53 ! BOXCHAR in Baum SMPEDIT
LET rate&=55 ! BOXTEXT in Baum SMPEDIT
LET ratecirc&=56 ! BOXCHAR in Baum SMPEDIT
LET editime&=57 ! BOXTEXT in Baum SMPEDIT
LET recplay3&=58 ! USERDEF in Baum SMPEDIT
LET hard&=59 ! USERDEF in Baum SMPEDIT
LET smpauto2&=60 ! USERDEF in Baum SMPEDIT
LET smpstrt2&=61 ! USERDEF in Baum SMPEDIT
LET smpplay&=62 ! USERDEF in Baum SMPEDIT
LET smpstop&=63 ! USERDEF in Baum SMPEDIT
LET smpwait&=64 ! USERDEF in Baum SMPEDIT
LET smpsec&=66 ! BOXTEXT in Baum SMPEDIT
LET smpfile&=67 ! BOXTEXT in Baum SMPEDIT
LET clock&=68 ! BOXTEXT in Baum SMPEDIT
LET showxy&=69 ! BOXTEXT in Baum SMPEDIT
LET pntprsmp&=70 ! BOXTEXT in Baum SMPEDIT
LET freemem&=71 ! BOXTEXT in Baum SMPEDIT
LET smprate&=72 ! BOXTEXT in Baum SMPEDIT
LET smpname&=73 ! BOXTEXT in Baum SMPEDIT
LET smplen&=74 ! BOXTEXT in Baum SMPEDIT
LET flyer&=75 ! USERDEF in Baum SMPEDIT
LET trash&=76 ! USERDEF in Baum SMPEDIT
LET editbox6&=77 ! BOX in Baum SMPEDIT
LET smppmark&=78 ! USERDEF in Baum SMPEDIT
LET midi&=79 ! USERDEF in Baum SMPEDIT
LET mintext&=80 ! BOXTEXT in Baum SMPEDIT
LET smploop&=81 ! USERDEF in Baum SMPEDIT
LET smpcblk&=82 ! USERDEF in Baum SMPEDIT
LET smpedhlp&=83 ! BOXTEXT in Baum SMPEDIT
LET smpexit&=84 ! BUTTON in Baum SMPEDIT
LET editbox2&=85 ! BOX in Baum SMPEDIT
LET edfade&=86 ! USERDEF in Baum SMPEDIT
LET edmidi&=87 ! USERDEF in Baum SMPEDIT
LET peaksw2&=88 ! USERDEF in Baum SMPEDIT
LET disk&=89 ! USERDEF in Baum SMPEDIT
LET loopart&=90 ! USERDEF in Baum SMPEDIT
LET blocfunc&=91 ! USERDEF in Baum SMPEDIT
LET arrange&=92 ! USERDEF in Baum SMPEDIT
LET smpload&=93 ! USERDEF in Baum SMPEDIT
LET smpsave&=94 ! USERDEF in Baum SMPEDIT
LET infoicon&=95 ! USERDEF in Baum SMPEDIT
LET wmodes&=96 ! USERDEF in Baum SMPEDIT
LET trak&=97 ! USERDEF in Baum SMPEDIT
LET edsmp16&=98 ! USERDEF in Baum SMPEDIT
LET swdsp&=99 ! USERDEF in Baum SMPEDIT
LET smpdbank&=100 ! USERDEF in Baum SMPEDIT
LET setuper&=101 ! USERDEF in Baum SMPEDIT
LET scrubs&=102 ! USERDEF in Baum SMPEDIT
LET swmark&=103 ! USERDEF in Baum SMPEDIT
LET swblk&=104 ! USERDEF in Baum SMPEDIT
LET swsearch&=105 ! USERDEF in Baum SMPEDIT
LET swyzoom&=106 ! USERDEF in Baum SMPEDIT
LET swclick&=107 ! USERDEF in Baum SMPEDIT
LET swdraw&=108 ! USERDEF in Baum SMPEDIT
LET edpart&=109 ! USERDEF in Baum SMPEDIT
LET edcue&=110 ! USERDEF in Baum SMPEDIT
LET curvbox&=111 ! BOX in Baum SMPEDIT
LET editbox4&=112 ! BOX in Baum SMPEDIT
LET editbox8&=113 ! BOX in Baum SMPEDIT
LET smptxr&=114 ! TEXT in Baum SMPEDIT
LET smptxl&=115 ! TEXT in Baum SMPEDIT
LET rm80&=116 ! BOXTEXT in Baum SMPEDIT
LET rp0&=117 ! BOXTEXT in Baum SMPEDIT
LET rp80&=118 ! BOXTEXT in Baum SMPEDIT
LET rp60&=119 ! BOXTEXT in Baum SMPEDIT
LET rp40&=120 ! BOXTEXT in Baum SMPEDIT
LET rm60&=121 ! BOXTEXT in Baum SMPEDIT
LET rm40&=122 ! BOXTEXT in Baum SMPEDIT
LET lp80&=123 ! BOXTEXT in Baum SMPEDIT
LET lm80&=124 ! BOXTEXT in Baum SMPEDIT
LET lp40&=125 ! BOXTEXT in Baum SMPEDIT
LET lp60&=126 ! BOXTEXT in Baum SMPEDIT
LET lm60&=127 ! BOXTEXT in Baum SMPEDIT
LET lm40&=128 ! BOXTEXT in Baum SMPEDIT
LET lm20&=129 ! BOXTEXT in Baum SMPEDIT
LET lp0&=130 ! BOXTEXT in Baum SMPEDIT
LET rp20&=131 ! BOXTEXT in Baum SMPEDIT
LET rm20&=132 ! BOXTEXT in Baum SMPEDIT
LET lp20&=133 ! BOXTEXT in Baum SMPEDIT
LET scrlslde&=134 ! BOX in Baum SMPEDIT
LET scrolbut&=135 ! BUTTON in Baum SMPEDIT
LET lscroll&=136 ! USERDEF in Baum SMPEDIT
LET rscroll&=137 ! USERDEF in Baum SMPEDIT
LET lr100&=138 ! BOXTEXT in Baum SMPEDIT
LET blkfile&=145 ! TEXT in Baum SMPEDIT
LET blkfilel&=146 ! BOX in Baum SMPEDIT
LET blkfiler&=147 ! BOX in Baum SMPEDIT
'
LET arranger&=1 ! Formular/Dialog
LET arrbox&=0 ! BOX in Baum ARRANGER
LET arrbox2&=1 ! BOX in Baum ARRANGER
LET hlpedit2&=2 ! USERDEF in Baum ARRANGER
LET arrload&=3 ! USERDEF in Baum ARRANGER
LET arrsave&=4 ! USERDEF in Baum ARRANGER
LET arrmidi&=5 ! USERDEF in Baum ARRANGER
LET arrins&=6 ! USERDEF in Baum ARRANGER
LET arrdel&=7 ! USERDEF in Baum ARRANGER
LET smpauto3&=9 ! USERDEF in Baum ARRANGER
LET smpstrt3&=10 ! USERDEF in Baum ARRANGER
LET pause&=11 ! USERDEF in Baum ARRANGER
LET rewind&=12 ! USERDEF in Baum ARRANGER
LET recplay&=13 ! USERDEF in Baum ARRANGER
LET smpplay2&=14 ! USERDEF in Baum ARRANGER
LET smprplay&=15 ! USERDEF in Baum ARRANGER
LET forward&=16 ! USERDEF in Baum ARRANGER
LET arrstrt&=17 ! USERDEF in Baum ARRANGER
LET arrend&=18 ! USERDEF in Baum ARRANGER
LET stop&=19 ! USERDEF in Baum ARRANGER
LET arrbox4&=20 ! BOX in Baum ARRANGER
LET playlen&=21 ! BOXTEXT in Baum ARRANGER
LET arreal&=22 ! USERDEF in Baum ARRANGER
LET arrblk&=23 ! USERDEF in Baum ARRANGER
LET arrbox3&=24 ! BOX in Baum ARRANGER
LET arrm1&=26 ! USERDEF in Baum ARRANGER
LET arrm2&=27 ! USERDEF in Baum ARRANGER
LET arrm3&=28 ! USERDEF in Baum ARRANGER
LET arrm4&=29 ! USERDEF in Baum ARRANGER
LET arrtri1&=33 ! BUTTON in Baum ARRANGER
LET arrtri2&=34 ! BUTTON in Baum ARRANGER
LET arrtri3&=35 ! BUTTON in Baum ARRANGER
LET arrtri4&=36 ! BUTTON in Baum ARRANGER
LET arrloop1&=39 ! USERDEF in Baum ARRANGER
LET arrloop2&=40 ! USERDEF in Baum ARRANGER
LET arrloop3&=41 ! USERDEF in Baum ARRANGER
LET arrloop4&=42 ! USERDEF in Baum ARRANGER
LET arrdel1&=49 ! USERDEF in Baum ARRANGER
LET arrdel2&=50 ! USERDEF in Baum ARRANGER
LET arrdel3&=51 ! USERDEF in Baum ARRANGER
LET arrdel4&=52 ! USERDEF in Baum ARRANGER
LET hardstrt&=53 ! USERDEF in Baum ARRANGER
LET hardend&=54 ! USERDEF in Baum ARRANGER
LET arrplay1&=57 ! USERDEF in Baum ARRANGER
LET arrplay2&=58 ! USERDEF in Baum ARRANGER
LET arrplay3&=59 ! USERDEF in Baum ARRANGER
LET arrplay4&=60 ! USERDEF in Baum ARRANGER
LET spur1&=61 ! BOXTEXT in Baum ARRANGER
LET spur2&=62 ! BOXTEXT in Baum ARRANGER
LET spur3&=63 ! BOXTEXT in Baum ARRANGER
LET spur4&=64 ! BOXTEXT in Baum ARRANGER
LET arrsmpr1&=65 ! BOXTEXT in Baum ARRANGER
LET arrsmpr2&=66 ! BOXTEXT in Baum ARRANGER
LET arrsmpr3&=67 ! BOXTEXT in Baum ARRANGER
LET arrsmpr4&=68 ! BOXTEXT in Baum ARRANGER
LET arrch1&=69 ! BOXTEXT in Baum ARRANGER
LET arrch2&=70 ! BOXTEXT in Baum ARRANGER
LET arrch3&=71 ! BOXTEXT in Baum ARRANGER
LET arrch4&=72 ! BOXTEXT in Baum ARRANGER
LET arrnote1&=73 ! BOXTEXT in Baum ARRANGER
LET arrnote2&=74 ! BOXTEXT in Baum ARRANGER
LET arrnote3&=75 ! BOXTEXT in Baum ARRANGER
LET arrnote4&=76 ! BOXTEXT in Baum ARRANGER
LET hardst1&=77 ! BOXTEXT in Baum ARRANGER
LET hardst2&=78 ! BOXTEXT in Baum ARRANGER
LET hardst3&=79 ! BOXTEXT in Baum ARRANGER
LET hardst4&=80 ! BOXTEXT in Baum ARRANGER
LET harde1&=81 ! BOXTEXT in Baum ARRANGER
LET harde2&=82 ! BOXTEXT in Baum ARRANGER
LET harde3&=83 ! BOXTEXT in Baum ARRANGER
LET harde4&=84 ! BOXTEXT in Baum ARRANGER
LET hardlen1&=85 ! BOXTEXT in Baum ARRANGER
LET hardlen2&=86 ! BOXTEXT in Baum ARRANGER
LET hardlen3&=87 ! BOXTEXT in Baum ARRANGER
LET hardlen4&=88 ! BOXTEXT in Baum ARRANGER
LET arrmem1&=89 ! BOXTEXT in Baum ARRANGER
LET arrmem2&=90 ! BOXTEXT in Baum ARRANGER
LET arrmem3&=91 ! BOXTEXT in Baum ARRANGER
LET arrmem4&=92 ! BOXTEXT in Baum ARRANGER
LET arrnr1&=93 ! BOXTEXT in Baum ARRANGER
LET arrnr2&=94 ! BOXTEXT in Baum ARRANGER
LET arrnr3&=95 ! BOXTEXT in Baum ARRANGER
LET arrnr4&=96 ! BOXTEXT in Baum ARRANGER
LET arrslide&=97 ! BOX in Baum ARRANGER
LET arrslbut&=98 ! BUTTON in Baum ARRANGER
LET arrexit&=99 ! BUTTON in Baum ARRANGER
LET arrhelp&=100 ! BOXTEXT in Baum ARRANGER
LET arrclip&=101 ! USERDEF in Baum ARRANGER
LET arrprint&=102 ! USERDEF in Baum ARRANGER
LET klavier&=103 ! USERDEF in Baum ARRANGER
LET slideup&=104 ! USERDEF in Baum ARRANGER
LET slidedwn&=105 ! USERDEF in Baum ARRANGER
LET playname&=106 ! BOXTEXT in Baum ARRANGER
LET arrtrash&=107 ! USERDEF in Baum ARRANGER
'
LET trakker&=2 ! Formular/Dialog
LET trakbox&=0 ! BOX in Baum TRAKKER
LET trtfilel&=8 ! BOX in Baum TRAKKER
LET trtfile&=9 ! TEXT in Baum TRAKKER
LET trtfiler&=10 ! BOX in Baum TRAKKER
LET trakbox3&=11 ! BOX in Baum TRAKKER
LET hlpedit3&=12 ! USERDEF in Baum TRAKKER
LET hrdmerg2&=13 ! USERDEF in Baum TRAKKER
LET trakload&=14 ! USERDEF in Baum TRAKKER
LET trakplay&=15 ! USERDEF in Baum TRAKKER
LET trakdel&=16 ! USERDEF in Baum TRAKKER
LET traksall&=17 ! USERDEF in Baum TRAKKER
LET traklall&=18 ! USERDEF in Baum TRAKKER
LET killtrak&=19 ! USERDEF in Baum TRAKKER
LET trakclip&=20 ! USERDEF in Baum TRAKKER
LET tblksel&=21 ! USERDEF in Baum TRAKKER
LET tblkmove&=22 ! USERDEF in Baum TRAKKER
LET tblkcopy&=23 ! USERDEF in Baum TRAKKER
LET tblkdrag&=24 ! USERDEF in Baum TRAKKER
LET tblkedit&=25 ! USERDEF in Baum TRAKKER
LET tblksnap&=26 ! USERDEF in Baum TRAKKER
LET tblkvol&=27 ! USERDEF in Baum TRAKKER
LET tblkcut&=28 ! USERDEF in Baum TRAKKER
LET trkcd&=29 ! USERDEF in Baum TRAKKER
LET trakedbx&=30 ! BOX in Baum TRAKKER
LET trakbox2&=31 ! BOX in Baum TRAKKER
LET trakbox5&=32 ! BOX in Baum TRAKKER
LET trkbx1&=33 ! BOX in Baum TRAKKER
LET trklevo1&=34 ! USERDEF in Baum TRAKKER
LET trklevt1&=35 ! BOXTEXT in Baum TRAKKER
LET trakk1&=36 ! BOXTEXT in Baum TRAKKER
LET trktxt1&=37 ! BOXTEXT in Baum TRAKKER
LET trkact1&=38 ! USERDEF in Baum TRAKKER
LET trksolo1&=39 ! USERDEF in Baum TRAKKER
LET trkmute1&=40 ! USERDEF in Baum TRAKKER
LET pantxt1&=41 ! BOXTEXT in Baum TRAKKER
LET panl1&=42 ! USERDEF in Baum TRAKKER
LET panr1&=43 ! USERDEF in Baum TRAKKER
LET trklevu1&=44 ! USERDEF in Baum TRAKKER
LET trkbx2&=45 ! BOX in Baum TRAKKER
LET trklevo2&=46 ! USERDEF in Baum TRAKKER
LET trklevt2&=47 ! BOXTEXT in Baum TRAKKER
LET trakk2&=48 ! BOXTEXT in Baum TRAKKER
LET trktxt2&=49 ! BOXTEXT in Baum TRAKKER
LET trkact2&=50 ! USERDEF in Baum TRAKKER
LET trksolo2&=51 ! USERDEF in Baum TRAKKER
LET trkmute2&=52 ! USERDEF in Baum TRAKKER
LET pantxt2&=53 ! BOXTEXT in Baum TRAKKER
LET panl2&=54 ! USERDEF in Baum TRAKKER
LET panr2&=55 ! USERDEF in Baum TRAKKER
LET trklevu2&=56 ! USERDEF in Baum TRAKKER
LET trkbx4&=57 ! BOX in Baum TRAKKER
LET trklevo4&=58 ! USERDEF in Baum TRAKKER
LET trklevt4&=59 ! BOXTEXT in Baum TRAKKER
LET trakk4&=60 ! BOXTEXT in Baum TRAKKER
LET trktxt4&=61 ! BOXTEXT in Baum TRAKKER
LET trkact4&=62 ! USERDEF in Baum TRAKKER
LET trksolo4&=63 ! USERDEF in Baum TRAKKER
LET trkmute4&=64 ! USERDEF in Baum TRAKKER
LET pantxt4&=65 ! BOXTEXT in Baum TRAKKER
LET panl4&=66 ! USERDEF in Baum TRAKKER
LET panr4&=67 ! USERDEF in Baum TRAKKER
LET trklevu4&=68 ! USERDEF in Baum TRAKKER
LET trkbx3&=69 ! BOX in Baum TRAKKER
LET trklevo3&=70 ! USERDEF in Baum TRAKKER
LET trklevt3&=71 ! BOXTEXT in Baum TRAKKER
LET trakk3&=72 ! BOXTEXT in Baum TRAKKER
LET trktxt3&=73 ! BOXTEXT in Baum TRAKKER
LET trkact3&=74 ! USERDEF in Baum TRAKKER
LET trksolo3&=75 ! USERDEF in Baum TRAKKER
LET trkmute3&=76 ! USERDEF in Baum TRAKKER
LET pantxt3&=77 ! BOXTEXT in Baum TRAKKER
LET panl3&=78 ! USERDEF in Baum TRAKKER
LET panr3&=79 ! USERDEF in Baum TRAKKER
LET trklevu3&=80 ! USERDEF in Baum TRAKKER
LET trakslid&=81 ! BOX in Baum TRAKKER
LET trakxbut&=82 ! BUTTON in Baum TRAKKER
LET trakxl&=83 ! USERDEF in Baum TRAKKER
LET timeline&=84 ! BOXTEXT in Baum TRAKKER
LET trkslot&=85 ! BOXTEXT in Baum TRAKKER
LET trktitxt&=86 ! TEXT in Baum TRAKKER
LET spurslid&=87 ! BOX in Baum TRAKKER
LET spurybut&=88 ! BUTTON in Baum TRAKKER
LET zoomxr&=89 ! USERDEF in Baum TRAKKER
LET zoomslid&=90 ! BOX in Baum TRAKKER
LET zoomxbut&=91 ! BUTTON in Baum TRAKKER
LET zoomxl&=92 ! USERDEF in Baum TRAKKER
LET timelin2&=93 ! BOXTEXT in Baum TRAKKER
LET trkslot2&=94 ! BOXTEXT in Baum TRAKKER
LET trakxr&=95 ! USERDEF in Baum TRAKKER
LET spuro&=96 ! USERDEF in Baum TRAKKER
LET spuru&=97 ! USERDEF in Baum TRAKKER
LET trakbxw&=98 ! BOX in Baum TRAKKER
LET trakstrt&=103 ! BOXTEXT in Baum TRAKKER
LET trakend&=104 ! BOXTEXT in Baum TRAKKER
LET trakdur&=105 ! BOXTEXT in Baum TRAKKER
LET traklen&=106 ! BOXTEXT in Baum TRAKKER
LET strtl&=107 ! USERDEF in Baum TRAKKER
LET strtr&=108 ! USERDEF in Baum TRAKKER
LET lend&=109 ! USERDEF in Baum TRAKKER
LET rend&=110 ! USERDEF in Baum TRAKKER
LET trksmpte&=114 ! BOXTEXT in Baum TRAKKER
LET trksize&=115 ! BOXTEXT in Baum TRAKKER
LET tpstrt&=116 ! BOXTEXT in Baum TRAKKER
LET tpend&=117 ! BOXTEXT in Baum TRAKKER
LET ltime&=118 ! USERDEF in Baum TRAKKER
LET rtime&=119 ! USERDEF in Baum TRAKKER
LET tpsl&=120 ! USERDEF in Baum TRAKKER
LET tpsr&=121 ! USERDEF in Baum TRAKKER
LET tpel&=122 ! USERDEF in Baum TRAKKER
LET tper&=123 ! USERDEF in Baum TRAKKER
LET trkblk&=124 ! USERDEF in Baum TRAKKER
LET trkcopy&=125 ! USERDEF in Baum TRAKKER
LET trkdel&=126 ! USERDEF in Baum TRAKKER
LET tblkplay&=129 ! USERDEF in Baum TRAKKER
LET tnamcom&=132 ! USERDEF in Baum TRAKKER
LET curve&=133 ! USERDEF in Baum TRAKKER
LET trksolo&=134 ! USERDEF in Baum TRAKKER
LET trakinfo&=135 ! BOXTEXT in Baum TRAKKER
LET trakbox4&=136 ! BOX in Baum TRAKKER
LET traktime&=137 ! BOXTEXT in Baum TRAKKER
LET trakname&=138 ! BOXTEXT in Baum TRAKKER
LET trkerr&=139 ! BOXTEXT in Baum TRAKKER
LET pause2&=141 ! USERDEF in Baum TRAKKER
LET rewind2&=142 ! USERDEF in Baum TRAKKER
LET stop2&=143 ! USERDEF in Baum TRAKKER
LET recplay2&=144 ! USERDEF in Baum TRAKKER
LET smpplay3&=145 ! USERDEF in Baum TRAKKER
LET smprpla2&=146 ! USERDEF in Baum TRAKKER
LET forward2&=147 ! USERDEF in Baum TRAKKER
LET trakanf&=148 ! USERDEF in Baum TRAKKER
LET trakfull&=149 ! USERDEF in Baum TRAKKER
LET smpstrt4&=150 ! USERDEF in Baum TRAKKER
LET smpauto4&=151 ! USERDEF in Baum TRAKKER
LET trklvol&=154 ! BOX in Baum TRAKKER
LET trkrvol&=155 ! BOX in Baum TRAKKER
LET trklmax&=156 ! BOX in Baum TRAKKER
LET trkrmax&=157 ! BOX in Baum TRAKKER
LET trkvbox&=158 ! BOXTEXT in Baum TRAKKER
LET trkvol&=160 ! USERDEF in Baum TRAKKER
LET trakbox6&=162 ! BOX in Baum TRAKKER
LET trk4&=163 ! BOXTEXT in Baum TRAKKER
LET trk8&=164 ! BOXTEXT in Baum TRAKKER
LET trk12&=165 ! BOXTEXT in Baum TRAKKER
LET trk16&=166 ! BOXTEXT in Baum TRAKKER
LET trkmon&=169 ! BOXTEXT in Baum TRAKKER
LET trakhelp&=171 ! BOXTEXT in Baum TRAKKER
LET trakexit&=172 ! BUTTON in Baum TRAKKER
'
LET fsel&=3 ! Formular/Dialog
LET fselbox&=0 ! BOX in Baum FSEL
LET fselbox2&=1 ! BOX in Baum FSEL
LET fsbut1&=2 ! BOXTEXT in Baum FSEL
LET fsbut2&=3 ! BOXTEXT in Baum FSEL
LET fsbut3&=4 ! BOXTEXT in Baum FSEL
LET fsbut4&=5 ! BOXTEXT in Baum FSEL
LET fsbut5&=6 ! BOXTEXT in Baum FSEL
LET fsbut6&=7 ! BOXTEXT in Baum FSEL
LET fsbut7&=8 ! BOXTEXT in Baum FSEL
LET fsbut8&=9 ! BOXTEXT in Baum FSEL
LET fsbut9&=10 ! BOXTEXT in Baum FSEL
LET fsbut10&=11 ! BOXTEXT in Baum FSEL
LET fsbut11&=12 ! BOXTEXT in Baum FSEL
LET fsbut12&=13 ! BOXTEXT in Baum FSEL
LET fsbut13&=14 ! BOXTEXT in Baum FSEL
LET fsbut14&=15 ! BOXTEXT in Baum FSEL
LET fsbut15&=16 ! BOXTEXT in Baum FSEL
LET fstxt1&=17 ! BOXTEXT in Baum FSEL
LET fstxt2&=18 ! BOXTEXT in Baum FSEL
LET fstxt3&=19 ! BOXTEXT in Baum FSEL
LET fstxt4&=20 ! BOXTEXT in Baum FSEL
LET fstxt5&=21 ! BOXTEXT in Baum FSEL
LET fstxt6&=22 ! BOXTEXT in Baum FSEL
LET fstxt7&=23 ! BOXTEXT in Baum FSEL
LET fstxt8&=24 ! BOXTEXT in Baum FSEL
LET fstxt9&=25 ! BOXTEXT in Baum FSEL
LET fstxt10&=26 ! BOXTEXT in Baum FSEL
LET fstxt11&=27 ! BOXTEXT in Baum FSEL
LET fstxt12&=28 ! BOXTEXT in Baum FSEL
LET fstxt13&=29 ! BOXTEXT in Baum FSEL
LET fstxt14&=30 ! BOXTEXT in Baum FSEL
LET fstxt15&=31 ! BOXTEXT in Baum FSEL
LET fsslide&=32 ! BOX in Baum FSEL
LET fssldbut&=33 ! BUTTON in Baum FSEL
LET fsok&=34 ! BUTTON in Baum FSEL
LET fshelp&=35 ! BOXTEXT in Baum FSEL
LET fsplay&=36 ! USERDEF in Baum FSEL
LET fsexit&=37 ! BUTTON in Baum FSEL
LET fsordner&=39 ! BUTTON in Baum FSEL
LET fsotxt&=40 ! BOXTEXT in Baum FSEL
LET fsmatic&=41 ! USERDEF in Baum FSEL
LET fsins&=42 ! USERDEF in Baum FSEL
LET fsdel&=43 ! USERDEF in Baum FSEL
LET fsadd&=44 ! BUTTON in Baum FSEL
LET fsnew&=45 ! BUTTON in Baum FSEL
LET fsload&=46 ! USERDEF in Baum FSEL
LET fssave&=47 ! USERDEF in Baum FSEL
LET fsclf&=48 ! USERDEF in Baum FSEL
LET fssldup&=49 ! USERDEF in Baum FSEL
LET fsslddwn&=50 ! USERDEF in Baum FSEL
LET fsstop&=51 ! USERDEF in Baum FSEL
LET fswait&=52 ! USERDEF in Baum FSEL
LET fsend&=53 ! USERDEF in Baum FSEL
LET fstime&=54 ! BOXTEXT in Baum FSEL
LET fslplay&=55 ! USERDEF in Baum FSEL
LET tfsabc&=56 ! USERDEF in Baum FSEL
LET tfsearch&=57 ! BUTTON in Baum FSEL
LET nfseltxt&=58 ! TEXT in Baum FSEL
'
rsc$="STARHIM.RSC"
'
RETURN
'
> PROCEDURE rsc_for_hi_color ! Resource fÅr Farbauflîsungen ab 1024x768
REM Resource Datei Indizes fÅr STARHIC
'
LET smpedit&=0 ! Formular/Dialog
LET editbox7&=0 ! BOX in Baum SMPEDIT
LET editbox&=1 ! BOX in Baum SMPEDIT
LET mover&=3 ! BOXTEXT in Baum SMPEDIT
LET movecirc&=4 ! BOXCHAR in Baum SMPEDIT
LET rate&=6 ! BOXTEXT in Baum SMPEDIT
LET ratecirc&=7 ! BOXCHAR in Baum SMPEDIT
LET csmintex&=9 ! TEXT in Baum SMPEDIT
LET cemaxtex&=10 ! TEXT in Baum SMPEDIT
LET resolu&=22 ! BOXTEXT in Baum SMPEDIT
LET resolirc&=23 ! BOXCHAR in Baum SMPEDIT
LET editime&=24 ! BOXTEXT in Baum SMPEDIT
LET zomslide&=25 ! BOX in Baum SMPEDIT
LET zoombutt&=26 ! BUTTON in Baum SMPEDIT
LET recplay3&=27 ! USERDEF in Baum SMPEDIT
LET hard&=28 ! USERDEF in Baum SMPEDIT
LET smpauto2&=29 ! USERDEF in Baum SMPEDIT
LET smpstrt2&=30 ! USERDEF in Baum SMPEDIT
LET smpplay&=31 ! USERDEF in Baum SMPEDIT
LET smpstop&=32 ! USERDEF in Baum SMPEDIT
LET smpwait&=33 ! USERDEF in Baum SMPEDIT
LET flyer&=34 ! USERDEF in Baum SMPEDIT
LET trash&=35 ! USERDEF in Baum SMPEDIT
LET editbox6&=36 ! BOX in Baum SMPEDIT
LET smppmark&=37 ! USERDEF in Baum SMPEDIT
LET midi&=38 ! USERDEF in Baum SMPEDIT
LET mintext&=39 ! BOXTEXT in Baum SMPEDIT
LET smploop&=40 ! USERDEF in Baum SMPEDIT
LET smpcblk&=41 ! USERDEF in Baum SMPEDIT
LET zooml&=42 ! USERDEF in Baum SMPEDIT
LET zoomr&=43 ! USERDEF in Baum SMPEDIT
LET pixzoom&=44 ! USERDEF in Baum SMPEDIT
LET editbox5&=45 ! BOX in Baum SMPEDIT
LET smpanf&=46 ! USERDEF in Baum SMPEDIT
LET smpr1&=47 ! USERDEF in Baum SMPEDIT
LET smpl1&=48 ! USERDEF in Baum SMPEDIT
LET smpl2&=49 ! USERDEF in Baum SMPEDIT
LET smpr2&=50 ! USERDEF in Baum SMPEDIT
LET smpl3&=51 ! USERDEF in Baum SMPEDIT
LET smpmid&=52 ! USERDEF in Baum SMPEDIT
LET smpend&=53 ! USERDEF in Baum SMPEDIT
LET smpr3&=54 ! USERDEF in Baum SMPEDIT
LET editbox3&=55 ! BOX in Baum SMPEDIT
LET edmtims&=56 ! BOXTEXT in Baum SMPEDIT
LET edmtime&=57 ! BOXTEXT in Baum SMPEDIT
LET edmdown&=58 ! USERDEF in Baum SMPEDIT
LET edmslide&=59 ! BOX in Baum SMPEDIT
LET edmbut&=60 ! BUTTON in Baum SMPEDIT
LET edmup&=61 ! USERDEF in Baum SMPEDIT
LET edmnr&=62 ! BOXTEXT in Baum SMPEDIT
LET edmtimi&=63 ! BOXTEXT in Baum SMPEDIT
LET edmtimr&=64 ! BOXTEXT in Baum SMPEDIT
LET edmbox&=65 ! BOX in Baum SMPEDIT
LET edmbuts&=66 ! USERDEF in Baum SMPEDIT
LET edmbute&=67 ! USERDEF in Baum SMPEDIT
LET edmbuti&=68 ! USERDEF in Baum SMPEDIT
LET edmbutr&=69 ! USERDEF in Baum SMPEDIT
LET edmtxt&=70 ! BOXTEXT in Baum SMPEDIT
LET cstxt&=71 ! BOXTEXT in Baum SMPEDIT
LET cetxt&=72 ! BOXTEXT in Baum SMPEDIT
LET smpsec&=74 ! BOXTEXT in Baum SMPEDIT
LET smpfile&=75 ! BOXTEXT in Baum SMPEDIT
LET clock&=76 ! BOXTEXT in Baum SMPEDIT
LET showxy&=77 ! BOXTEXT in Baum SMPEDIT
LET pntprsmp&=78 ! BOXTEXT in Baum SMPEDIT
LET freemem&=79 ! BOXTEXT in Baum SMPEDIT
LET smprate&=80 ! BOXTEXT in Baum SMPEDIT
LET smpname&=81 ! BOXTEXT in Baum SMPEDIT
LET smplen&=82 ! BOXTEXT in Baum SMPEDIT
LET smpedhlp&=83 ! BOXTEXT in Baum SMPEDIT
LET smpexit&=84 ! BUTTON in Baum SMPEDIT
LET editbox2&=85 ! BOX in Baum SMPEDIT
LET setuper&=86 ! USERDEF in Baum SMPEDIT
LET edfade&=87 ! USERDEF in Baum SMPEDIT
LET peaksw2&=88 ! USERDEF in Baum SMPEDIT
LET disk&=89 ! USERDEF in Baum SMPEDIT
LET loopart&=90 ! USERDEF in Baum SMPEDIT
LET blocfunc&=91 ! USERDEF in Baum SMPEDIT
LET arrange&=92 ! USERDEF in Baum SMPEDIT
LET smpload&=93 ! USERDEF in Baum SMPEDIT
LET smpsave&=94 ! USERDEF in Baum SMPEDIT
LET infoicon&=95 ! USERDEF in Baum SMPEDIT
LET edmidi&=96 ! USERDEF in Baum SMPEDIT
LET trak&=97 ! USERDEF in Baum SMPEDIT
LET edsmp16&=98 ! USERDEF in Baum SMPEDIT
LET swdsp&=99 ! USERDEF in Baum SMPEDIT
LET smpdbank&=100 ! USERDEF in Baum SMPEDIT
LET wmodes&=101 ! USERDEF in Baum SMPEDIT
LET scrubs&=102 ! USERDEF in Baum SMPEDIT
LET swmark&=103 ! USERDEF in Baum SMPEDIT
LET swblk&=104 ! USERDEF in Baum SMPEDIT
LET swsearch&=105 ! USERDEF in Baum SMPEDIT
LET swyzoom&=106 ! USERDEF in Baum SMPEDIT
LET swclick&=107 ! USERDEF in Baum SMPEDIT
LET swdraw&=108 ! USERDEF in Baum SMPEDIT
LET edcue&=109 ! USERDEF in Baum SMPEDIT
LET edpart&=110 ! USERDEF in Baum SMPEDIT
LET curvbox&=111 ! BOX in Baum SMPEDIT
LET editbox4&=112 ! BOX in Baum SMPEDIT
LET editbox8&=113 ! BOX in Baum SMPEDIT
LET smptxr&=114 ! TEXT in Baum SMPEDIT
LET smptxl&=115 ! TEXT in Baum SMPEDIT
LET rm80&=116 ! BOXTEXT in Baum SMPEDIT
LET rp0&=117 ! BOXTEXT in Baum SMPEDIT
LET rp80&=118 ! BOXTEXT in Baum SMPEDIT
LET rp60&=119 ! BOXTEXT in Baum SMPEDIT
LET rp40&=120 ! BOXTEXT in Baum SMPEDIT
LET rm60&=121 ! BOXTEXT in Baum SMPEDIT
LET rm40&=122 ! BOXTEXT in Baum SMPEDIT
LET lp80&=123 ! BOXTEXT in Baum SMPEDIT
LET lm80&=124 ! BOXTEXT in Baum SMPEDIT
LET lp40&=125 ! BOXTEXT in Baum SMPEDIT
LET lp60&=126 ! BOXTEXT in Baum SMPEDIT
LET lm60&=127 ! BOXTEXT in Baum SMPEDIT
LET lm40&=128 ! BOXTEXT in Baum SMPEDIT
LET lm20&=129 ! BOXTEXT in Baum SMPEDIT
LET lp0&=130 ! BOXTEXT in Baum SMPEDIT
LET rp20&=131 ! BOXTEXT in Baum SMPEDIT
LET rm20&=132 ! BOXTEXT in Baum SMPEDIT
LET lp20&=133 ! BOXTEXT in Baum SMPEDIT
LET scrlslde&=134 ! BOX in Baum SMPEDIT
LET scrolbut&=135 ! BUTTON in Baum SMPEDIT
LET lscroll&=136 ! USERDEF in Baum SMPEDIT
LET rscroll&=137 ! USERDEF in Baum SMPEDIT
LET lr100&=138 ! BOXTEXT in Baum SMPEDIT
LET blkfile&=145 ! TEXT in Baum SMPEDIT
LET blkfilel&=146 ! BOX in Baum SMPEDIT
LET blkfiler&=147 ! BOX in Baum SMPEDIT
'
LET arranger&=1 ! Formular/Dialog
LET arrbox&=0 ! BOX in Baum ARRANGER
LET arrbox2&=1 ! BOX in Baum ARRANGER
LET hlpedit2&=2 ! USERDEF in Baum ARRANGER
LET arrload&=3 ! USERDEF in Baum ARRANGER
LET arrsave&=4 ! USERDEF in Baum ARRANGER
LET arrmidi&=5 ! USERDEF in Baum ARRANGER
LET arrins&=6 ! USERDEF in Baum ARRANGER
LET arrdel&=7 ! USERDEF in Baum ARRANGER
LET smpauto3&=9 ! USERDEF in Baum ARRANGER
LET smpstrt3&=10 ! USERDEF in Baum ARRANGER
LET pause&=11 ! USERDEF in Baum ARRANGER
LET rewind&=12 ! USERDEF in Baum ARRANGER
LET recplay&=13 ! USERDEF in Baum ARRANGER
LET smpplay2&=14 ! USERDEF in Baum ARRANGER
LET smprplay&=15 ! USERDEF in Baum ARRANGER
LET forward&=16 ! USERDEF in Baum ARRANGER
LET arrstrt&=17 ! USERDEF in Baum ARRANGER
LET arrend&=18 ! USERDEF in Baum ARRANGER
LET stop&=19 ! USERDEF in Baum ARRANGER
LET arrbox4&=20 ! BOX in Baum ARRANGER
LET playlen&=21 ! BOXTEXT in Baum ARRANGER
LET arreal&=22 ! USERDEF in Baum ARRANGER
LET arrblk&=23 ! USERDEF in Baum ARRANGER
LET arrbox3&=24 ! BOX in Baum ARRANGER
LET arrm1&=26 ! USERDEF in Baum ARRANGER
LET arrm2&=27 ! USERDEF in Baum ARRANGER
LET arrm3&=28 ! USERDEF in Baum ARRANGER
LET arrm4&=29 ! USERDEF in Baum ARRANGER
LET arrtri1&=33 ! BUTTON in Baum ARRANGER
LET arrtri2&=34 ! BUTTON in Baum ARRANGER
LET arrtri3&=35 ! BUTTON in Baum ARRANGER
LET arrtri4&=36 ! BUTTON in Baum ARRANGER
LET arrloop1&=39 ! USERDEF in Baum ARRANGER
LET arrloop2&=40 ! USERDEF in Baum ARRANGER
LET arrloop3&=41 ! USERDEF in Baum ARRANGER
LET arrloop4&=42 ! USERDEF in Baum ARRANGER
LET arrdel1&=49 ! USERDEF in Baum ARRANGER
LET arrdel2&=50 ! USERDEF in Baum ARRANGER
LET arrdel3&=51 ! USERDEF in Baum ARRANGER
LET arrdel4&=52 ! USERDEF in Baum ARRANGER
LET hardstrt&=53 ! USERDEF in Baum ARRANGER
LET hardend&=54 ! USERDEF in Baum ARRANGER
LET arrplay1&=57 ! USERDEF in Baum ARRANGER
LET arrplay2&=58 ! USERDEF in Baum ARRANGER
LET arrplay3&=59 ! USERDEF in Baum ARRANGER
LET arrplay4&=60 ! USERDEF in Baum ARRANGER
LET spur1&=61 ! BOXTEXT in Baum ARRANGER
LET spur2&=62 ! BOXTEXT in Baum ARRANGER
LET spur3&=63 ! BOXTEXT in Baum ARRANGER
LET spur4&=64 ! BOXTEXT in Baum ARRANGER
LET arrmem1&=65 ! BOXTEXT in Baum ARRANGER
LET arrmem2&=66 ! BOXTEXT in Baum ARRANGER
LET arrmem3&=67 ! BOXTEXT in Baum ARRANGER
LET arrmem4&=68 ! BOXTEXT in Baum ARRANGER
LET arrnr1&=69 ! BOXTEXT in Baum ARRANGER
LET arrnr2&=70 ! BOXTEXT in Baum ARRANGER
LET arrnr3&=71 ! BOXTEXT in Baum ARRANGER
LET arrnr4&=72 ! BOXTEXT in Baum ARRANGER
LET hardst1&=73 ! BOXTEXT in Baum ARRANGER
LET hardst2&=74 ! BOXTEXT in Baum ARRANGER
LET hardst3&=75 ! BOXTEXT in Baum ARRANGER
LET hardst4&=76 ! BOXTEXT in Baum ARRANGER
LET harde1&=77 ! BOXTEXT in Baum ARRANGER
LET harde2&=78 ! BOXTEXT in Baum ARRANGER
LET harde3&=79 ! BOXTEXT in Baum ARRANGER
LET harde4&=80 ! BOXTEXT in Baum ARRANGER
LET hardlen1&=81 ! BOXTEXT in Baum ARRANGER
LET hardlen2&=82 ! BOXTEXT in Baum ARRANGER
LET hardlen3&=83 ! BOXTEXT in Baum ARRANGER
LET hardlen4&=84 ! BOXTEXT in Baum ARRANGER
LET arrsmpr1&=85 ! BOXTEXT in Baum ARRANGER
LET arrsmpr2&=86 ! BOXTEXT in Baum ARRANGER
LET arrsmpr3&=87 ! BOXTEXT in Baum ARRANGER
LET arrsmpr4&=88 ! BOXTEXT in Baum ARRANGER
LET arrch1&=89 ! BOXTEXT in Baum ARRANGER
LET arrch2&=90 ! BOXTEXT in Baum ARRANGER
LET arrch3&=91 ! BOXTEXT in Baum ARRANGER
LET arrch4&=92 ! BOXTEXT in Baum ARRANGER
LET arrnote1&=93 ! BOXTEXT in Baum ARRANGER
LET arrnote2&=94 ! BOXTEXT in Baum ARRANGER
LET arrnote3&=95 ! BOXTEXT in Baum ARRANGER
LET arrnote4&=96 ! BOXTEXT in Baum ARRANGER
LET arrslide&=97 ! BOX in Baum ARRANGER
LET arrslbut&=98 ! BUTTON in Baum ARRANGER
LET arrexit&=99 ! BUTTON in Baum ARRANGER
LET arrhelp&=100 ! BOXTEXT in Baum ARRANGER
LET arrclip&=101 ! USERDEF in Baum ARRANGER
LET arrprint&=102 ! USERDEF in Baum ARRANGER
LET klavier&=103 ! USERDEF in Baum ARRANGER
LET slideup&=104 ! USERDEF in Baum ARRANGER
LET slidedwn&=105 ! USERDEF in Baum ARRANGER
LET playname&=106 ! BOXTEXT in Baum ARRANGER
LET arrtrash&=107 ! USERDEF in Baum ARRANGER
'
LET trakker&=2 ! Formular/Dialog
LET trakbox&=0 ! BOX in Baum TRAKKER
LET trakbox3&=1 ! BOX in Baum TRAKKER
LET hlpedit3&=2 ! USERDEF in Baum TRAKKER
LET hrdmerg2&=3 ! USERDEF in Baum TRAKKER
LET trakload&=4 ! USERDEF in Baum TRAKKER
LET trakplay&=5 ! USERDEF in Baum TRAKKER
LET trakdel&=6 ! USERDEF in Baum TRAKKER
LET traksall&=7 ! USERDEF in Baum TRAKKER
LET traklall&=8 ! USERDEF in Baum TRAKKER
LET killtrak&=9 ! USERDEF in Baum TRAKKER
LET trakclip&=10 ! USERDEF in Baum TRAKKER
LET tblksel&=11 ! USERDEF in Baum TRAKKER
LET tblkmove&=12 ! USERDEF in Baum TRAKKER
LET tblkcopy&=13 ! USERDEF in Baum TRAKKER
LET tblkdrag&=14 ! USERDEF in Baum TRAKKER
LET tblkedit&=15 ! USERDEF in Baum TRAKKER
LET tblksnap&=16 ! USERDEF in Baum TRAKKER
LET tblkvol&=17 ! USERDEF in Baum TRAKKER
LET tblkcut&=18 ! USERDEF in Baum TRAKKER
LET trkcd&=19 ! USERDEF in Baum TRAKKER
LET trtfilel&=26 ! BOX in Baum TRAKKER
LET trtfile&=27 ! TEXT in Baum TRAKKER
LET trtfiler&=28 ! BOX in Baum TRAKKER
LET trakedbx&=29 ! BOX in Baum TRAKKER
LET trakbox2&=30 ! BOX in Baum TRAKKER
LET trakbox5&=31 ! BOX in Baum TRAKKER
LET trkbx1&=32 ! BOX in Baum TRAKKER
LET trklevo1&=33 ! USERDEF in Baum TRAKKER
LET trklevt1&=34 ! BOXTEXT in Baum TRAKKER
LET trakk1&=35 ! BOXTEXT in Baum TRAKKER
LET trktxt1&=36 ! BOXTEXT in Baum TRAKKER
LET trkact1&=37 ! USERDEF in Baum TRAKKER
LET trksolo1&=38 ! USERDEF in Baum TRAKKER
LET trkmute1&=39 ! USERDEF in Baum TRAKKER
LET pantxt1&=40 ! BOXTEXT in Baum TRAKKER
LET panl1&=41 ! USERDEF in Baum TRAKKER
LET panr1&=42 ! USERDEF in Baum TRAKKER
LET trklevu1&=43 ! USERDEF in Baum TRAKKER
LET trkbx2&=44 ! BOX in Baum TRAKKER
LET trklevo2&=45 ! USERDEF in Baum TRAKKER
LET trklevt2&=46 ! BOXTEXT in Baum TRAKKER
LET trakk2&=47 ! BOXTEXT in Baum TRAKKER
LET trktxt2&=48 ! BOXTEXT in Baum TRAKKER
LET trkact2&=49 ! USERDEF in Baum TRAKKER
LET trksolo2&=50 ! USERDEF in Baum TRAKKER
LET trkmute2&=51 ! USERDEF in Baum TRAKKER
LET pantxt2&=52 ! BOXTEXT in Baum TRAKKER
LET panl2&=53 ! USERDEF in Baum TRAKKER
LET panr2&=54 ! USERDEF in Baum TRAKKER
LET trklevu2&=55 ! USERDEF in Baum TRAKKER
LET trkbx4&=56 ! BOX in Baum TRAKKER
LET trklevo4&=57 ! USERDEF in Baum TRAKKER
LET trklevt4&=58 ! BOXTEXT in Baum TRAKKER
LET trakk4&=59 ! BOXTEXT in Baum TRAKKER
LET trktxt4&=60 ! BOXTEXT in Baum TRAKKER
LET trkact4&=61 ! USERDEF in Baum TRAKKER
LET trksolo4&=62 ! USERDEF in Baum TRAKKER
LET trkmute4&=63 ! USERDEF in Baum TRAKKER
LET pantxt4&=64 ! BOXTEXT in Baum TRAKKER
LET panl4&=65 ! USERDEF in Baum TRAKKER
LET panr4&=66 ! USERDEF in Baum TRAKKER
LET trklevu4&=67 ! USERDEF in Baum TRAKKER
LET trkbx3&=68 ! BOX in Baum TRAKKER
LET trklevo3&=69 ! USERDEF in Baum TRAKKER
LET trklevt3&=70 ! BOXTEXT in Baum TRAKKER
LET trakk3&=71 ! BOXTEXT in Baum TRAKKER
LET trktxt3&=72 ! BOXTEXT in Baum TRAKKER
LET trkact3&=73 ! USERDEF in Baum TRAKKER
LET trksolo3&=74 ! USERDEF in Baum TRAKKER
LET trkmute3&=75 ! USERDEF in Baum TRAKKER
LET pantxt3&=76 ! BOXTEXT in Baum TRAKKER
LET panl3&=77 ! USERDEF in Baum TRAKKER
LET panr3&=78 ! USERDEF in Baum TRAKKER
LET trklevu3&=79 ! USERDEF in Baum TRAKKER
LET trakslid&=80 ! BOX in Baum TRAKKER
LET trakxbut&=81 ! BUTTON in Baum TRAKKER
LET trakxl&=82 ! USERDEF in Baum TRAKKER
LET timeline&=83 ! BOXTEXT in Baum TRAKKER
LET trkslot&=84 ! BOXTEXT in Baum TRAKKER
LET trktitxt&=85 ! TEXT in Baum TRAKKER
LET spurslid&=86 ! BOX in Baum TRAKKER
LET spurybut&=87 ! BUTTON in Baum TRAKKER
LET zoomxr&=88 ! USERDEF in Baum TRAKKER
LET zoomslid&=89 ! BOX in Baum TRAKKER
LET zoomxbut&=90 ! BUTTON in Baum TRAKKER
LET zoomxl&=91 ! USERDEF in Baum TRAKKER
LET timelin2&=92 ! BOXTEXT in Baum TRAKKER
LET trkslot2&=93 ! BOXTEXT in Baum TRAKKER
LET trakxr&=94 ! USERDEF in Baum TRAKKER
LET spuro&=95 ! USERDEF in Baum TRAKKER
LET spuru&=96 ! USERDEF in Baum TRAKKER
LET trakbxw&=97 ! BOX in Baum TRAKKER
LET trakstrt&=102 ! BOXTEXT in Baum TRAKKER
LET trakend&=103 ! BOXTEXT in Baum TRAKKER
LET trakdur&=104 ! BOXTEXT in Baum TRAKKER
LET traklen&=105 ! BOXTEXT in Baum TRAKKER
LET strtl&=106 ! USERDEF in Baum TRAKKER
LET strtr&=107 ! USERDEF in Baum TRAKKER
LET lend&=108 ! USERDEF in Baum TRAKKER
LET rend&=109 ! USERDEF in Baum TRAKKER
LET trksmpte&=113 ! BOXTEXT in Baum TRAKKER
LET trksize&=114 ! BOXTEXT in Baum TRAKKER
LET tpstrt&=115 ! BOXTEXT in Baum TRAKKER
LET tpend&=116 ! BOXTEXT in Baum TRAKKER
LET ltime&=117 ! USERDEF in Baum TRAKKER
LET rtime&=118 ! USERDEF in Baum TRAKKER
LET tpsl&=119 ! USERDEF in Baum TRAKKER
LET tpsr&=120 ! USERDEF in Baum TRAKKER
LET tpel&=121 ! USERDEF in Baum TRAKKER
LET tper&=122 ! USERDEF in Baum TRAKKER
LET trkblk&=123 ! USERDEF in Baum TRAKKER
LET trkcopy&=124 ! USERDEF in Baum TRAKKER
LET trkdel&=125 ! USERDEF in Baum TRAKKER
LET tblkplay&=128 ! USERDEF in Baum TRAKKER
LET tnamcom&=131 ! USERDEF in Baum TRAKKER
LET curve&=132 ! USERDEF in Baum TRAKKER
LET trksolo&=133 ! USERDEF in Baum TRAKKER
LET trakinfo&=134 ! BOXTEXT in Baum TRAKKER
LET trakbox4&=135 ! BOX in Baum TRAKKER
LET traktime&=136 ! BOXTEXT in Baum TRAKKER
LET trakname&=137 ! BOXTEXT in Baum TRAKKER
LET trkerr&=138 ! BOXTEXT in Baum TRAKKER
LET pause2&=140 ! USERDEF in Baum TRAKKER
LET rewind2&=141 ! USERDEF in Baum TRAKKER
LET stop2&=142 ! USERDEF in Baum TRAKKER
LET recplay2&=143 ! USERDEF in Baum TRAKKER
LET smpplay3&=144 ! USERDEF in Baum TRAKKER
LET smprpla2&=145 ! USERDEF in Baum TRAKKER
LET forward2&=146 ! USERDEF in Baum TRAKKER
LET trakanf&=147 ! USERDEF in Baum TRAKKER
LET trakfull&=148 ! USERDEF in Baum TRAKKER
LET smpstrt4&=149 ! USERDEF in Baum TRAKKER
LET smpauto4&=150 ! USERDEF in Baum TRAKKER
LET trklvol&=151 ! BOX in Baum TRAKKER
LET trkrvol&=152 ! BOX in Baum TRAKKER
LET trklmax&=153 ! BOX in Baum TRAKKER
LET trkrmax&=154 ! BOX in Baum TRAKKER
LET trkvbox&=157 ! BOXTEXT in Baum TRAKKER
LET trkvol&=159 ! USERDEF in Baum TRAKKER
LET trakbox6&=161 ! BOX in Baum TRAKKER
LET trk4&=162 ! BOXTEXT in Baum TRAKKER
LET trk8&=163 ! BOXTEXT in Baum TRAKKER
LET trk12&=164 ! BOXTEXT in Baum TRAKKER
LET trk16&=165 ! BOXTEXT in Baum TRAKKER
LET trkmon&=168 ! BOXTEXT in Baum TRAKKER
LET trakhelp&=170 ! BOXTEXT in Baum TRAKKER
LET trakexit&=171 ! BUTTON in Baum TRAKKER
'
LET fsel&=3 ! Formular/Dialog
LET fselbox&=0 ! BOX in Baum FSEL
LET fselbox2&=1 ! BOX in Baum FSEL
LET fsbut1&=2 ! BOXTEXT in Baum FSEL
LET fsbut2&=3 ! BOXTEXT in Baum FSEL
LET fsbut3&=4 ! BOXTEXT in Baum FSEL
LET fsbut4&=5 ! BOXTEXT in Baum FSEL
LET fsbut5&=6 ! BOXTEXT in Baum FSEL
LET fsbut6&=7 ! BOXTEXT in Baum FSEL
LET fsbut7&=8 ! BOXTEXT in Baum FSEL
LET fsbut8&=9 ! BOXTEXT in Baum FSEL
LET fsbut9&=10 ! BOXTEXT in Baum FSEL
LET fsbut10&=11 ! BOXTEXT in Baum FSEL
LET fsbut11&=12 ! BOXTEXT in Baum FSEL
LET fsbut12&=13 ! BOXTEXT in Baum FSEL
LET fsbut13&=14 ! BOXTEXT in Baum FSEL
LET fsbut14&=15 ! BOXTEXT in Baum FSEL
LET fsbut15&=16 ! BOXTEXT in Baum FSEL
LET fstxt1&=17 ! BOXTEXT in Baum FSEL
LET fstxt2&=18 ! BOXTEXT in Baum FSEL
LET fstxt3&=19 ! BOXTEXT in Baum FSEL
LET fstxt4&=20 ! BOXTEXT in Baum FSEL
LET fstxt5&=21 ! BOXTEXT in Baum FSEL
LET fstxt6&=22 ! BOXTEXT in Baum FSEL
LET fstxt7&=23 ! BOXTEXT in Baum FSEL
LET fstxt8&=24 ! BOXTEXT in Baum FSEL
LET fstxt9&=25 ! BOXTEXT in Baum FSEL
LET fstxt10&=26 ! BOXTEXT in Baum FSEL
LET fstxt11&=27 ! BOXTEXT in Baum FSEL
LET fstxt12&=28 ! BOXTEXT in Baum FSEL
LET fstxt13&=29 ! BOXTEXT in Baum FSEL
LET fstxt14&=30 ! BOXTEXT in Baum FSEL
LET fstxt15&=31 ! BOXTEXT in Baum FSEL
LET fsslide&=32 ! BOX in Baum FSEL
LET fssldbut&=33 ! BUTTON in Baum FSEL
LET fsok&=34 ! BUTTON in Baum FSEL
LET fshelp&=35 ! BOXTEXT in Baum FSEL
LET fsplay&=36 ! USERDEF in Baum FSEL
LET fsexit&=37 ! BUTTON in Baum FSEL
LET fsordner&=39 ! BUTTON in Baum FSEL
LET fsotxt&=40 ! BOXTEXT in Baum FSEL
LET fsmatic&=41 ! USERDEF in Baum FSEL
LET fsins&=42 ! USERDEF in Baum FSEL
LET fsdel&=43 ! USERDEF in Baum FSEL
LET fsadd&=44 ! BUTTON in Baum FSEL
LET fsnew&=45 ! BUTTON in Baum FSEL
LET fsload&=46 ! USERDEF in Baum FSEL
LET fssave&=47 ! USERDEF in Baum FSEL
LET fsclf&=48 ! USERDEF in Baum FSEL
LET fssldup&=49 ! USERDEF in Baum FSEL
LET fsslddwn&=50 ! USERDEF in Baum FSEL
LET fsstop&=51 ! USERDEF in Baum FSEL
LET fswait&=52 ! USERDEF in Baum FSEL
LET fsend&=53 ! USERDEF in Baum FSEL
LET fstime&=54 ! BOXTEXT in Baum FSEL
LET fslplay&=55 ! USERDEF in Baum FSEL
LET tfsabc&=56 ! USERDEF in Baum FSEL
LET tfsearch&=57 ! BUTTON in Baum FSEL
LET nfseltxt&=58 ! TEXT in Baum FSEL
'
rsc$="STARHIC.RSC"
'
RETURN
'
> PROCEDURE rsc_for_mono     ! Resource fÅr monochrome Auflîsungen
REM Resource Datei Indizes fÅr STARMONO
'
LET info&=0 ! Formular/Dialog
LET infobox&=0 ! BOX in Baum INFO
LET infoexit&=1 ! BUTTON in Baum INFO
LET helpinfo&=2 ! BOXTEXT in Baum INFO
LET cpyrdrv&=4 ! TEXT in Baum INFO
LET cpyright&=5 ! TEXT in Baum INFO
LET infobild&=11 ! USERDEF in Baum INFO
LET swelogo&=18 ! USERDEF in Baum INFO
LET inforeg0&=19 ! TEXT in Baum INFO
LET inforeg1&=20 ! TEXT in Baum INFO
LET inforeg2&=21 ! TEXT in Baum INFO
LET inforeg3&=22 ! TEXT in Baum INFO
LET inforeg4&=23 ! TEXT in Baum INFO
'
LET peak&=1 ! Formular/Dialog
LET peakbox&=0 ! BOX in Baum PEAK
LET peaktl&=1 ! TEXT in Baum PEAK
LET peaktr&=2 ! TEXT in Baum PEAK
LET plmax&=3 ! BUTTON in Baum PEAK
LET prmax&=4 ! BUTTON in Baum PEAK
LET peakbox2&=5 ! BOX in Baum PEAK
LET pmdb2&=6 ! TEXT in Baum PEAK
LET pmdb3&=7 ! TEXT in Baum PEAK
LET pmdb4&=8 ! TEXT in Baum PEAK
LET pmdb5&=9 ! TEXT in Baum PEAK
LET pmdb6&=10 ! TEXT in Baum PEAK
LET pmdb7&=11 ! TEXT in Baum PEAK
LET pmdb8&=12 ! TEXT in Baum PEAK
LET pmdb9&=13 ! TEXT in Baum PEAK
LET pmdb10&=14 ! TEXT in Baum PEAK
LET pmdb1&=15 ! TEXT in Baum PEAK
LET peakl&=16 ! USERDEF in Baum PEAK
LET peakr&=17 ! USERDEF in Baum PEAK
LET pmover&=18 ! TEXT in Baum PEAK
LET peakname&=19 ! BOXTEXT in Baum PEAK
LET pkmbox&=20 ! BOX in Baum PEAK
LET volbox&=21 ! BOX in Baum PEAK
LET volfader&=22 ! ICON in Baum PEAK
LET volume&=23 ! USERDEF in Baum PEAK
LET smpautop&=25 ! USERDEF in Baum PEAK
LET smpstrtp&=26 ! USERDEF in Baum PEAK
LET playpeak&=27 ! USERDEF in Baum PEAK
LET recerror&=28 ! BOXTEXT in Baum PEAK
LET balbox&=30 ! BOXTEXT in Baum PEAK
LET balance&=32 ! USERDEF in Baum PEAK
LET recpeaks&=34 ! BOXTEXT in Baum PEAK
LET peakdb&=36 ! BOXTEXT in Baum PEAK
LET peakbal&=37 ! BOXTEXT in Baum PEAK
LET balancem&=55 ! TEXT in Baum PEAK
LET hardpeak&=56 ! USERDEF in Baum PEAK
LET playstop&=57 ! USERDEF in Baum PEAK
LET peakwait&=58 ! USERDEF in Baum PEAK
LET volzero&=59 ! TEXT in Baum PEAK
LET volinout&=60 ! USERDEF in Baum PEAK
LET peakch1&=61 ! BOXTEXT in Baum PEAK
LET peakch4&=62 ! BOXTEXT in Baum PEAK
LET peakch2&=63 ! BOXTEXT in Baum PEAK
LET peakch3&=64 ! BOXTEXT in Baum PEAK
LET lphold&=65 ! USERDEF in Baum PEAK
LET phldslid&=66 ! BOX in Baum PEAK
LET pholdbut&=67 ! BUTTON in Baum PEAK
LET rphold&=68 ! USERDEF in Baum PEAK
LET pkmbox2&=69 ! BOX in Baum PEAK
LET peakpos&=70 ! BOXTEXT in Baum PEAK
LET peakmax&=71 ! BOXTEXT in Baum PEAK
LET peakmaxt&=72 ! TEXT in Baum PEAK
LET peakpost&=73 ! TEXT in Baum PEAK
LET peakmute&=74 ! USERDEF in Baum PEAK
LET balzero&=75 ! USERDEF in Baum PEAK
LET peakhelp&=76 ! BOXTEXT in Baum PEAK
LET peakexit&=77 ! BUTTON in Baum PEAK
'
LET blkfunc&=2 ! Formular/Dialog
LET blkbox&=0 ! BOX in Baum BLKFUNC
LET cutin&=1 ! USERDEF in Baum BLKFUNC
LET cutout&=2 ! USERDEF in Baum BLKFUNC
LET blkexit&=3 ! BUTTON in Baum BLKFUNC
LET blkhelp&=5 ! BOXTEXT in Baum BLKFUNC
LET cutdel&=6 ! USERDEF in Baum BLKFUNC
LET norm&=10 ! USERDEF in Baum BLKFUNC
LET resmp&=11 ! USERDEF in Baum BLKFUNC
LET mono&=12 ! USERDEF in Baum BLKFUNC
LET conmix&=13 ! USERDEF in Baum BLKFUNC
LET conins&=14 ! USERDEF in Baum BLKFUNC
LET conspace&=15 ! USERDEF in Baum BLKFUNC
LET negate&=23 ! USERDEF in Baum BLKFUNC
LET lrchange&=25 ! USERDEF in Baum BLKFUNC
LET conv24&=31 ! USERDEF in Baum BLKFUNC
LET conv16&=32 ! USERDEF in Baum BLKFUNC
LET sernr&=35 ! TEXT in Baum BLKFUNC
'
LET cuelist&=3 ! Formular/Dialog
LET cuebox&=0 ! BOX in Baum CUELIST
LET cuebox2&=1 ! BOX in Baum CUELIST
LET cuex1&=2 ! BOXTEXT in Baum CUELIST
LET cuex2&=3 ! BOXTEXT in Baum CUELIST
LET cuex3&=4 ! BOXTEXT in Baum CUELIST
LET cuex4&=5 ! BOXTEXT in Baum CUELIST
LET cuex5&=6 ! BOXTEXT in Baum CUELIST
LET cuex6&=7 ! BOXTEXT in Baum CUELIST
LET cuex7&=8 ! BOXTEXT in Baum CUELIST
LET cuex8&=9 ! BOXTEXT in Baum CUELIST
LET cuex9&=10 ! BOXTEXT in Baum CUELIST
LET cuex10&=11 ! BOXTEXT in Baum CUELIST
LET cuenr1&=12 ! BOXTEXT in Baum CUELIST
LET cuenr2&=13 ! BOXTEXT in Baum CUELIST
LET cuenr3&=14 ! BOXTEXT in Baum CUELIST
LET cuenr4&=15 ! BOXTEXT in Baum CUELIST
LET cuenr5&=16 ! BOXTEXT in Baum CUELIST
LET cuenr6&=17 ! BOXTEXT in Baum CUELIST
LET cuenr7&=18 ! BOXTEXT in Baum CUELIST
LET cuenr8&=19 ! BOXTEXT in Baum CUELIST
LET cuenr9&=20 ! BOXTEXT in Baum CUELIST
LET cuenr10&=21 ! BOXTEXT in Baum CUELIST
LET cuet1&=22 ! BOXTEXT in Baum CUELIST
LET cuet2&=23 ! BOXTEXT in Baum CUELIST
LET cuet3&=24 ! BOXTEXT in Baum CUELIST
LET cuet4&=25 ! BOXTEXT in Baum CUELIST
LET cuet5&=26 ! BOXTEXT in Baum CUELIST
LET cuet6&=27 ! BOXTEXT in Baum CUELIST
LET cuet7&=28 ! BOXTEXT in Baum CUELIST
LET cuet8&=29 ! BOXTEXT in Baum CUELIST
LET cuet9&=30 ! BOXTEXT in Baum CUELIST
LET cuet10&=31 ! BOXTEXT in Baum CUELIST
LET cues1&=32 ! BOXTEXT in Baum CUELIST
LET cues2&=33 ! BOXTEXT in Baum CUELIST
LET cues3&=34 ! BOXTEXT in Baum CUELIST
LET cues4&=35 ! BOXTEXT in Baum CUELIST
LET cues5&=36 ! BOXTEXT in Baum CUELIST
LET cues6&=37 ! BOXTEXT in Baum CUELIST
LET cues7&=38 ! BOXTEXT in Baum CUELIST
LET cues8&=39 ! BOXTEXT in Baum CUELIST
LET cues9&=40 ! BOXTEXT in Baum CUELIST
LET cues10&=41 ! BOXTEXT in Baum CUELIST
LET cuee1&=42 ! BOXTEXT in Baum CUELIST
LET cuee2&=43 ! BOXTEXT in Baum CUELIST
LET cuee3&=44 ! BOXTEXT in Baum CUELIST
LET cuee4&=45 ! BOXTEXT in Baum CUELIST
LET cuee5&=46 ! BOXTEXT in Baum CUELIST
LET cuee6&=47 ! BOXTEXT in Baum CUELIST
LET cuee7&=48 ! BOXTEXT in Baum CUELIST
LET cuee8&=49 ! BOXTEXT in Baum CUELIST
LET cuee9&=50 ! BOXTEXT in Baum CUELIST
LET cuee10&=51 ! BOXTEXT in Baum CUELIST
LET cuel1&=52 ! BOXTEXT in Baum CUELIST
LET cuel2&=53 ! BOXTEXT in Baum CUELIST
LET cuel3&=54 ! BOXTEXT in Baum CUELIST
LET cuel4&=55 ! BOXTEXT in Baum CUELIST
LET cuel5&=56 ! BOXTEXT in Baum CUELIST
LET cuel6&=57 ! BOXTEXT in Baum CUELIST
LET cuel7&=58 ! BOXTEXT in Baum CUELIST
LET cuel8&=59 ! BOXTEXT in Baum CUELIST
LET cuel9&=60 ! BOXTEXT in Baum CUELIST
LET cuel10&=61 ! BOXTEXT in Baum CUELIST
LET cueslide&=62 ! BOX in Baum CUELIST
LET cueslbut&=63 ! BUTTON in Baum CUELIST
LET cueok&=64 ! BUTTON in Baum CUELIST
LET cuehelp&=65 ! BOXTEXT in Baum CUELIST
LET cuelink&=66 ! BUTTON in Baum CUELIST
LET cueadd&=67 ! BUTTON in Baum CUELIST
LET cueins&=68 ! BUTTON in Baum CUELIST
LET cueload&=69 ! USERDEF in Baum CUELIST
LET cuesave&=70 ! USERDEF in Baum CUELIST
LET cuekill&=71 ! USERDEF in Baum CUELIST
LET cueslup&=72 ! USERDEF in Baum CUELIST
LET cuesldwn&=73 ! USERDEF in Baum CUELIST
LET cuedel&=74 ! BUTTON in Baum CUELIST
LET cueplay&=78 ! USERDEF in Baum CUELIST
LET cuestop&=79 ! USERDEF in Baum CUELIST
LET cuesize&=80 ! BOXTEXT in Baum CUELIST
LET cuewait&=81 ! USERDEF in Baum CUELIST
LET cuepos&=83 ! BOXTEXT in Baum CUELIST
LET cuechnge&=88 ! BUTTON in Baum CUELIST
LET cuemix&=89 ! USERDEF in Baum CUELIST
LET cuecd&=91 ! USERDEF in Baum CUELIST
'
LET mixer&=4 ! Formular/Dialog
LET mixbox1&=0 ! BOX in Baum MIXER
LET mixbox2&=1 ! BOX in Baum MIXER
LET mixload&=2 ! USERDEF in Baum MIXER
LET mixsave&=3 ! USERDEF in Baum MIXER
LET mixbx1&=4 ! BOX in Baum MIXER
LET mixvbox1&=5 ! BOX in Baum MIXER
LET mixfade1&=6 ! USERDEF in Baum MIXER
LET mixvol1&=7 ! USERDEF in Baum MIXER
LET mixdb1&=8 ! BOX in Baum MIXER
LET mixvolm1&=9 ! TEXT in Baum MIXER
LET mixvoll1&=24 ! BOX in Baum MIXER
LET mixvolr1&=25 ! BOX in Baum MIXER
LET mixpkl1&=26 ! BOX in Baum MIXER
LET mixpkr1&=27 ! BOX in Baum MIXER
LET mixvolt1&=28 ! BOXTEXT in Baum MIXER
LET mixvoln1&=29 ! BOXTEXT in Baum MIXER
LET mxbalbx1&=30 ! BOX in Baum MIXER
LET mixball1&=31 ! TEXT in Baum MIXER
LET mixbalr1&=32 ! TEXT in Baum MIXER
LET mixbalm1&=33 ! TEXT in Baum MIXER
LET mixbal1&=34 ! USERDEF in Baum MIXER
LET mixbalz1&=35 ! USERDEF in Baum MIXER
LET mixbalp1&=36 ! USERDEF in Baum MIXER
LET mixtxt1&=37 ! BOXTEXT in Baum MIXER
LET mixbalt1&=38 ! BOXTEXT in Baum MIXER
LET mixbaln1&=39 ! BOXTEXT in Baum MIXER
LET mixon1&=40 ! USERDEF in Baum MIXER
LET mixall1&=41 ! USERDEF in Baum MIXER
LET mixmute1&=42 ! USERDEF in Baum MIXER
LET mixvolz1&=43 ! USERDEF in Baum MIXER
LET mixstop&=44 ! USERDEF in Baum MIXER
LET mixwait&=45 ! USERDEF in Baum MIXER
LET mixhelp&=46 ! BOXTEXT in Baum MIXER
LET mixexit&=47 ! BUTTON in Baum MIXER
LET mixbx2&=48 ! BOX in Baum MIXER
LET mixvbox2&=49 ! BOX in Baum MIXER
LET mixfade2&=50 ! USERDEF in Baum MIXER
LET mixvol2&=51 ! USERDEF in Baum MIXER
LET mixdb2&=52 ! BOX in Baum MIXER
LET mixvolm2&=53 ! TEXT in Baum MIXER
LET mixvoll2&=68 ! BOX in Baum MIXER
LET mixvolr2&=69 ! BOX in Baum MIXER
LET mixpkl2&=70 ! BOX in Baum MIXER
LET mixpkr2&=71 ! BOX in Baum MIXER
LET mixvolt2&=72 ! BOXTEXT in Baum MIXER
LET mixvoln2&=73 ! BOXTEXT in Baum MIXER
LET mxbalbx2&=74 ! BOX in Baum MIXER
LET mixball2&=75 ! TEXT in Baum MIXER
LET mixbalr2&=76 ! TEXT in Baum MIXER
LET mixbalm2&=77 ! TEXT in Baum MIXER
LET mixbal2&=78 ! USERDEF in Baum MIXER
LET mixbalz2&=79 ! USERDEF in Baum MIXER
LET mixbalp2&=80 ! USERDEF in Baum MIXER
LET mixtxt2&=81 ! BOXTEXT in Baum MIXER
LET mixbalt2&=82 ! BOXTEXT in Baum MIXER
LET mixbaln2&=83 ! BOXTEXT in Baum MIXER
LET mixon2&=84 ! USERDEF in Baum MIXER
LET mixall2&=85 ! USERDEF in Baum MIXER
LET mixmute2&=86 ! USERDEF in Baum MIXER
LET mixvolz2&=87 ! USERDEF in Baum MIXER
LET mixbx3&=88 ! BOX in Baum MIXER
LET mixvbox3&=89 ! BOX in Baum MIXER
LET mixfade3&=90 ! USERDEF in Baum MIXER
LET mixvol3&=91 ! USERDEF in Baum MIXER
LET mixdb3&=92 ! BOX in Baum MIXER
LET mixvolm3&=93 ! TEXT in Baum MIXER
LET mixvoll3&=108 ! BOX in Baum MIXER
LET mixvolr3&=109 ! BOX in Baum MIXER
LET mixpkl3&=110 ! BOX in Baum MIXER
LET mixpkr3&=111 ! BOX in Baum MIXER
LET mixvolt3&=112 ! BOXTEXT in Baum MIXER
LET mixvoln3&=113 ! BOXTEXT in Baum MIXER
LET mxbalbx3&=114 ! BOX in Baum MIXER
LET mixball3&=115 ! TEXT in Baum MIXER
LET mixbalr3&=116 ! TEXT in Baum MIXER
LET mixbalm3&=117 ! TEXT in Baum MIXER
LET mixbal3&=118 ! USERDEF in Baum MIXER
LET mixbalz3&=119 ! USERDEF in Baum MIXER
LET mixbalp3&=120 ! USERDEF in Baum MIXER
LET mixtxt3&=121 ! BOXTEXT in Baum MIXER
LET mixbalt3&=122 ! BOXTEXT in Baum MIXER
LET mixbaln3&=123 ! BOXTEXT in Baum MIXER
LET mixon3&=124 ! USERDEF in Baum MIXER
LET mixall3&=125 ! USERDEF in Baum MIXER
LET mixmute3&=126 ! USERDEF in Baum MIXER
LET mixvolz3&=127 ! USERDEF in Baum MIXER
LET mixbx4&=128 ! BOX in Baum MIXER
LET mixvbox4&=129 ! BOX in Baum MIXER
LET mixfade4&=130 ! USERDEF in Baum MIXER
LET mixvol4&=131 ! USERDEF in Baum MIXER
LET mixdb4&=132 ! BOX in Baum MIXER
LET mixvolm4&=133 ! TEXT in Baum MIXER
LET mixvoll4&=148 ! BOX in Baum MIXER
LET mixvolr4&=149 ! BOX in Baum MIXER
LET mixpkl4&=150 ! BOX in Baum MIXER
LET mixpkr4&=151 ! BOX in Baum MIXER
LET mixvolt4&=152 ! BOXTEXT in Baum MIXER
LET mixvoln4&=153 ! BOXTEXT in Baum MIXER
LET mxbalbx4&=154 ! BOX in Baum MIXER
LET mixball4&=155 ! TEXT in Baum MIXER
LET mixbalr4&=156 ! TEXT in Baum MIXER
LET mixbalm4&=157 ! TEXT in Baum MIXER
LET mixbal4&=158 ! USERDEF in Baum MIXER
LET mixbalz4&=159 ! USERDEF in Baum MIXER
LET mixbalp4&=160 ! USERDEF in Baum MIXER
LET mixtxt4&=161 ! BOXTEXT in Baum MIXER
LET mixbalt4&=162 ! BOXTEXT in Baum MIXER
LET mixbaln4&=163 ! BOXTEXT in Baum MIXER
LET mixon4&=164 ! USERDEF in Baum MIXER
LET mixall4&=165 ! USERDEF in Baum MIXER
LET mixmute4&=166 ! USERDEF in Baum MIXER
LET mixvolz4&=167 ! USERDEF in Baum MIXER
LET mixbxm&=168 ! BOX in Baum MIXER
LET mixvboxm&=169 ! BOX in Baum MIXER
LET mixfadem&=170 ! USERDEF in Baum MIXER
LET mixvolm&=171 ! USERDEF in Baum MIXER
LET mixdbm&=172 ! BOX in Baum MIXER
LET mixvolmm&=173 ! TEXT in Baum MIXER
LET mixvollm&=188 ! BOX in Baum MIXER
LET mixvolrm&=189 ! BOX in Baum MIXER
LET mixpklm&=190 ! BOX in Baum MIXER
LET mixpkrm&=191 ! BOX in Baum MIXER
LET mixvoltm&=192 ! BOXTEXT in Baum MIXER
LET mixvolnm&=193 ! BOXTEXT in Baum MIXER
LET mxbalbxm&=194 ! BOX in Baum MIXER
LET mixballm&=195 ! TEXT in Baum MIXER
LET mixbalrm&=196 ! TEXT in Baum MIXER
LET mixbalmm&=197 ! TEXT in Baum MIXER
LET mixbalm&=198 ! USERDEF in Baum MIXER
LET mixbalzm&=199 ! USERDEF in Baum MIXER
LET mixbalpm&=200 ! USERDEF in Baum MIXER
LET mixtxtm&=201 ! BOXTEXT in Baum MIXER
LET mixbaltm&=202 ! BOXTEXT in Baum MIXER
LET mixbalnm&=203 ! BOXTEXT in Baum MIXER
LET mixonm&=204 ! USERDEF in Baum MIXER
LET mixallm&=205 ! USERDEF in Baum MIXER
LET mixmutem&=206 ! USERDEF in Baum MIXER
LET mixvolzm&=207 ! USERDEF in Baum MIXER
LET mixrec&=208 ! USERDEF in Baum MIXER
LET mixplay&=209 ! USERDEF in Baum MIXER
LET mixbx5&=210 ! BOX in Baum MIXER
LET mixvbox5&=211 ! BOX in Baum MIXER
LET mixfade5&=212 ! USERDEF in Baum MIXER
LET mixvol5&=213 ! USERDEF in Baum MIXER
LET mixdb5&=214 ! BOX in Baum MIXER
LET mixvolm5&=215 ! TEXT in Baum MIXER
LET mixvoll5&=230 ! BOX in Baum MIXER
LET mixvolr5&=231 ! BOX in Baum MIXER
LET mixpkl5&=232 ! BOX in Baum MIXER
LET mixpkr5&=233 ! BOX in Baum MIXER
LET mixvolt5&=234 ! BOXTEXT in Baum MIXER
LET mixvoln5&=235 ! BOXTEXT in Baum MIXER
LET mxbalbx5&=236 ! BOX in Baum MIXER
LET mixball5&=237 ! TEXT in Baum MIXER
LET mixbalr5&=238 ! TEXT in Baum MIXER
LET mixbalm5&=239 ! TEXT in Baum MIXER
LET mixbal5&=240 ! USERDEF in Baum MIXER
LET mixbalz5&=241 ! USERDEF in Baum MIXER
LET mixbalp5&=242 ! USERDEF in Baum MIXER
LET mixtxt5&=243 ! BOXTEXT in Baum MIXER
LET mixbalt5&=244 ! BOXTEXT in Baum MIXER
LET mixbaln5&=245 ! BOXTEXT in Baum MIXER
LET mixon5&=246 ! USERDEF in Baum MIXER
LET mixall5&=247 ! USERDEF in Baum MIXER
LET mixmute5&=248 ! USERDEF in Baum MIXER
LET mixvolz5&=249 ! USERDEF in Baum MIXER
LET mixbx6&=250 ! BOX in Baum MIXER
LET mixvbox6&=251 ! BOX in Baum MIXER
LET mixfade6&=252 ! USERDEF in Baum MIXER
LET mixvol6&=253 ! USERDEF in Baum MIXER
LET mixdb6&=254 ! BOX in Baum MIXER
LET mixvolm6&=255 ! TEXT in Baum MIXER
LET mixvoll6&=270 ! BOX in Baum MIXER
LET mixvolr6&=271 ! BOX in Baum MIXER
LET mixpkl6&=272 ! BOX in Baum MIXER
LET mixpkr6&=273 ! BOX in Baum MIXER
LET mixvolt6&=274 ! BOXTEXT in Baum MIXER
LET mixvoln6&=275 ! BOXTEXT in Baum MIXER
LET mxbalbx6&=276 ! BOX in Baum MIXER
LET mixball6&=277 ! TEXT in Baum MIXER
LET mixbalr6&=278 ! TEXT in Baum MIXER
LET mixbalm6&=279 ! TEXT in Baum MIXER
LET mixbal6&=280 ! USERDEF in Baum MIXER
LET mixbalz6&=281 ! USERDEF in Baum MIXER
LET mixbalp6&=282 ! USERDEF in Baum MIXER
LET mixtxt6&=283 ! BOXTEXT in Baum MIXER
LET mixbalt6&=284 ! BOXTEXT in Baum MIXER
LET mixbaln6&=285 ! BOXTEXT in Baum MIXER
LET mixon6&=286 ! USERDEF in Baum MIXER
LET mixall6&=287 ! USERDEF in Baum MIXER
LET mixmute6&=288 ! USERDEF in Baum MIXER
LET mixvolz6&=289 ! USERDEF in Baum MIXER
LET mixbx7&=290 ! BOX in Baum MIXER
LET mixvbox7&=291 ! BOX in Baum MIXER
LET mixfade7&=292 ! USERDEF in Baum MIXER
LET mixvol7&=293 ! USERDEF in Baum MIXER
LET mixdb7&=294 ! BOX in Baum MIXER
LET mixvolm7&=295 ! TEXT in Baum MIXER
LET mixvoll7&=310 ! BOX in Baum MIXER
LET mixvolr7&=311 ! BOX in Baum MIXER
LET mixpkl7&=312 ! BOX in Baum MIXER
LET mixpkr7&=313 ! BOX in Baum MIXER
LET mixvolt7&=314 ! BOXTEXT in Baum MIXER
LET mixvoln7&=315 ! BOXTEXT in Baum MIXER
LET mxbalbx7&=316 ! BOX in Baum MIXER
LET mixball7&=317 ! TEXT in Baum MIXER
LET mixbalr7&=318 ! TEXT in Baum MIXER
LET mixbalm7&=319 ! TEXT in Baum MIXER
LET mixbal7&=320 ! USERDEF in Baum MIXER
LET mixbalz7&=321 ! USERDEF in Baum MIXER
LET mixbalp7&=322 ! USERDEF in Baum MIXER
LET mixtxt7&=323 ! BOXTEXT in Baum MIXER
LET mixbalt7&=324 ! BOXTEXT in Baum MIXER
LET mixbaln7&=325 ! BOXTEXT in Baum MIXER
LET mixon7&=326 ! USERDEF in Baum MIXER
LET mixall7&=327 ! USERDEF in Baum MIXER
LET mixmute7&=328 ! USERDEF in Baum MIXER
LET mixvolz7&=329 ! USERDEF in Baum MIXER
LET mixbx8&=330 ! BOX in Baum MIXER
LET mixvbox8&=331 ! BOX in Baum MIXER
LET mixfade8&=332 ! USERDEF in Baum MIXER
LET mixvol8&=333 ! USERDEF in Baum MIXER
LET mixdb8&=334 ! BOX in Baum MIXER
LET mixvolm8&=335 ! TEXT in Baum MIXER
LET mixvoll8&=350 ! BOX in Baum MIXER
LET mixvolr8&=351 ! BOX in Baum MIXER
LET mixpkl8&=352 ! BOX in Baum MIXER
LET mixpkr8&=353 ! BOX in Baum MIXER
LET mixvolt8&=354 ! BOXTEXT in Baum MIXER
LET mixvoln8&=355 ! BOXTEXT in Baum MIXER
LET mxbalbx8&=356 ! BOX in Baum MIXER
LET mixball8&=357 ! TEXT in Baum MIXER
LET mixbalr8&=358 ! TEXT in Baum MIXER
LET mixbalm8&=359 ! TEXT in Baum MIXER
LET mixbal8&=360 ! USERDEF in Baum MIXER
LET mixbalz8&=361 ! USERDEF in Baum MIXER
LET micbalp8&=362 ! USERDEF in Baum MIXER
LET mixtxt8&=363 ! BOXTEXT in Baum MIXER
LET mixbalt8&=364 ! BOXTEXT in Baum MIXER
LET mixbaln8&=365 ! BOXTEXT in Baum MIXER
LET mixon8&=366 ! USERDEF in Baum MIXER
LET mixall8&=367 ! USERDEF in Baum MIXER
LET mixmute8&=368 ! USERDEF in Baum MIXER
LET mixvolz8&=369 ! USERDEF in Baum MIXER
'
LET virtual&=5 ! Formular/Dialog
LET virtbox&=0 ! BOX in Baum VIRTUAL
LET virthelp&=2 ! BOXTEXT in Baum VIRTUAL
LET virtbloc&=4 ! BUTTON in Baum VIRTUAL
LET virtok&=5 ! BUTTON in Baum VIRTUAL
LET virtbox3&=6 ! BOX in Baum VIRTUAL
LET vblkstrt&=7 ! FTEXT in Baum VIRTUAL
LET vseconds&=8 ! BUTTON in Baum VIRTUAL
LET vsamples&=9 ! BUTTON in Baum VIRTUAL
LET vblkmlen&=10 ! BOXTEXT in Baum VIRTUAL
LET vblkvlen&=12 ! BOXTEXT in Baum VIRTUAL
LET vslider&=13 ! BOX in Baum VIRTUAL
LET vslbut&=14 ! BUTTON in Baum VIRTUAL
LET virtbox2&=15 ! BOX in Baum VIRTUAL
LET virtwork&=16 ! BUTTON in Baum VIRTUAL
LET virtdir&=17 ! BUTTON in Baum VIRTUAL
LET vrslide&=18 ! USERDEF in Baum VIRTUAL
LET vlslide&=19 ! USERDEF in Baum VIRTUAL
LET virtno&=21 ! BUTTON in Baum VIRTUAL
LET virtplay&=22 ! USERDEF in Baum VIRTUAL
LET virtstop&=24 ! USERDEF in Baum VIRTUAL
'
LET record&=6 ! Formular/Dialog
LET recbox&=0 ! BOX in Baum RECORD
LET recfree&=1 ! BOXTEXT in Baum RECORD
LET recok&=2 ! BUTTON in Baum RECORD
LET recexit&=3 ! BUTTON in Baum RECORD
LET timemeld&=4 ! TEXT in Baum RECORD
LET rechelp&=5 ! BOXTEXT in Baum RECORD
LET timetxt&=9 ! FTEXT in Baum RECORD
LET tinpul1&=12 ! USERDEF in Baum RECORD
LET tinpul2&=14 ! USERDEF in Baum RECORD
LET tinpul3&=15 ! USERDEF in Baum RECORD
LET tinpul4&=16 ! USERDEF in Baum RECORD
LET tinpuh1&=17 ! USERDEF in Baum RECORD
LET tinpuh2&=18 ! USERDEF in Baum RECORD
LET tinpuh3&=19 ! USERDEF in Baum RECORD
LET tinpuh4&=20 ! USERDEF in Baum RECORD
LET tinpdh1&=21 ! USERDEF in Baum RECORD
LET tinpdh2&=22 ! USERDEF in Baum RECORD
LET tinpdh3&=23 ! USERDEF in Baum RECORD
LET tinpdh4&=24 ! USERDEF in Baum RECORD
LET tinpdl1&=25 ! USERDEF in Baum RECORD
LET tinpdl2&=26 ! USERDEF in Baum RECORD
LET tinpdl3&=27 ! USERDEF in Baum RECORD
LET tinpdl4&=28 ! USERDEF in Baum RECORD
LET recti1&=31 ! BOX in Baum RECORD
LET recti2&=32 ! BOX in Baum RECORD
LET recti3&=33 ! BOX in Baum RECORD
LET recti4&=34 ! BOX in Baum RECORD
LET tinmin&=35 ! BUTTON in Baum RECORD
LET tinmax&=36 ! BUTTON in Baum RECORD
'
LET savebloc&=7 ! Formular/Dialog
LET savebox&=0 ! BOX in Baum SAVEBLOC
LET savall&=1 ! USERDEF in Baum SAVEBLOC
LET savblock&=2 ! USERDEF in Baum SAVEBLOC
LET savexit&=3 ! BUTTON in Baum SAVEBLOC
LET savetxt&=4 ! TEXT in Baum SAVEBLOC
LET savehelp&=5 ! BOXTEXT in Baum SAVEBLOC
'
LET abackup&=8 ! Formular/Dialog
LET abackbox&=0 ! BOX in Baum ABACKUP
LET abacktxt&=1 ! BOXTEXT in Baum ABACKUP
LET abackok&=2 ! BUTTON in Baum ABACKUP
LET abackex&=3 ! BUTTON in Baum ABACKUP
LET abackhlp&=5 ! BOXTEXT in Baum ABACKUP
LET abackr1&=8 ! USERDEF in Baum ABACKUP
LET abackr2&=9 ! USERDEF in Baum ABACKUP
LET abackl1&=10 ! USERDEF in Baum ABACKUP
LET abackl2&=11 ! USERDEF in Baum ABACKUP
LET abackbo2&=12 ! BOX in Baum ABACKUP
LET aback&=13 ! BUTTON in Baum ABACKUP
LET abacknam&=14 ! BUTTON in Baum ABACKUP
'
LET midiedit&=9 ! Formular/Dialog
LET midibox&=0 ! BOX in Baum MIDIEDIT
LET notetxt&=1 ! BOXTEXT in Baum MIDIEDIT
LET chtxt&=3 ! BOXTEXT in Baum MIDIEDIT
LET midiok&=5 ! BUTTON in Baum MIDIEDIT
LET helpmidi&=6 ! BOXTEXT in Baum MIDIEDIT
LET midinup&=9 ! USERDEF in Baum MIDIEDIT
LET midioup&=10 ! USERDEF in Baum MIDIEDIT
LET midindwn&=11 ! USERDEF in Baum MIDIEDIT
LET midiodwn&=12 ! USERDEF in Baum MIDIEDIT
LET midicup&=13 ! USERDEF in Baum MIDIEDIT
LET midicdwn&=14 ! USERDEF in Baum MIDIEDIT
'
LET normaliz&=10 ! Formular/Dialog
LET normbox&=0 ! BOX in Baum NORMALIZ
LET normok&=2 ! BUTTON in Baum NORMALIZ
LET normexit&=3 ! BUTTON in Baum NORMALIZ
LET maxdb&=4 ! BOXTEXT in Baum NORMALIZ
LET normbox2&=6 ! BOX in Baum NORMALIZ
LET normauto&=7 ! BUTTON in Baum NORMALIZ
LET normadj&=8 ! BUTTON in Baum NORMALIZ
LET normbox3&=9 ! BOX in Baum NORMALIZ
LET norml1&=10 ! USERDEF in Baum NORMALIZ
LET norml2&=11 ! USERDEF in Baum NORMALIZ
LET norml3&=12 ! USERDEF in Baum NORMALIZ
LET normr1&=13 ! USERDEF in Baum NORMALIZ
LET normr2&=14 ! USERDEF in Baum NORMALIZ
LET normr3&=15 ! USERDEF in Baum NORMALIZ
LET helpnorm&=16 ! BOXTEXT in Baum NORMALIZ
LET normdb&=18 ! BOXTEXT in Baum NORMALIZ
'
LET resample&=11 ! Formular/Dialog
LET resmpbox&=0 ! BOX in Baum RESAMPLE
LET rsmptxt1&=2 ! TEXT in Baum RESAMPLE
LET resmpbx2&=3 ! BOX in Baum RESAMPLE
LET restxt&=4 ! FBOXTEXT in Baum RESAMPLE
LET resmpsel&=7 ! BOXTEXT in Baum RESAMPLE
LET resmpirc&=8 ! BOXCHAR in Baum RESAMPLE
LET resmpsec&=10 ! BOXTEXT in Baum RESAMPLE
LET resmplen&=11 ! BOXTEXT in Baum RESAMPLE
LET resmpfac&=12 ! BOXTEXT in Baum RESAMPLE
LET resmpbx3&=13 ! BOX in Baum RESAMPLE
LET resother&=14 ! FBOXTEXT in Baum RESAMPLE
LET rsmptxt2&=15 ! TEXT in Baum RESAMPLE
LET resl3&=16 ! USERDEF in Baum RESAMPLE
LET resl2&=17 ! USERDEF in Baum RESAMPLE
LET resl1&=18 ! USERDEF in Baum RESAMPLE
LET resr1&=19 ! USERDEF in Baum RESAMPLE
LET resr2&=20 ! USERDEF in Baum RESAMPLE
LET resr3&=21 ! USERDEF in Baum RESAMPLE
LET adjresmp&=22 ! BUTTON in Baum RESAMPLE
LET helprsmp&=23 ! BOXTEXT in Baum RESAMPLE
LET resexit&=24 ! BUTTON in Baum RESAMPLE
LET resok&=25 ! BUTTON in Baum RESAMPLE
'
LET mrkfind&=12 ! Formular/Dialog
LET mrkfbox&=0 ! BOX in Baum MRKFIND
LET mrkfex&=2 ! BUTTON in Baum MRKFIND
LET mrkfhelp&=3 ! BOXTEXT in Baum MRKFIND
LET mrkfok&=4 ! BUTTON in Baum MRKFIND
LET mrkfbox2&=6 ! BOX in Baum MRKFIND
LET mrkftims&=7 ! BOXTEXT in Baum MRKFIND
LET mrkftime&=8 ! BOXTEXT in Baum MRKFIND
LET mrkfdown&=9 ! USERDEF in Baum MRKFIND
LET mrkfslid&=10 ! BOX in Baum MRKFIND
LET mrkfbut&=11 ! BUTTON in Baum MRKFIND
LET mrkfup&=12 ! USERDEF in Baum MRKFIND
LET mrkfnr&=13 ! BOXTEXT in Baum MRKFIND
LET mrkftimi&=14 ! BOXTEXT in Baum MRKFIND
LET mrkftimr&=15 ! BOXTEXT in Baum MRKFIND
LET mrkftxt&=16 ! BOXTEXT in Baum MRKFIND
LET mrkfbox3&=17 ! BOX in Baum MRKFIND
LET mrkfbuts&=18 ! USERDEF in Baum MRKFIND
LET mrkfbute&=19 ! USERDEF in Baum MRKFIND
LET mrkfbuti&=20 ! USERDEF in Baum MRKFIND
LET mrkfbutr&=21 ! USERDEF in Baum MRKFIND
'
LET disked&=13 ! Formular/Dialog
LET dskedbox&=0 ! BOX in Baum DISKED
LET dskedex&=1 ! BUTTON in Baum DISKED
LET dskedhlp&=2 ! BOXTEXT in Baum DISKED
LET dskedbx4&=4 ! BOX in Baum DISKED
LET dskedbx2&=5 ! BOX in Baum DISKED
LET dskedit&=6 ! FTEXT in Baum DISKED
LET dskren&=8 ! USERDEF in Baum DISKED
LET dskopie&=9 ! USERDEF in Baum DISKED
LET dskedbx3&=10 ! BOX in Baum DISKED
LET dskedtxt&=11 ! BOXTEXT in Baum DISKED
LET dskill&=13 ! USERDEF in Baum DISKED
'
LET xfade&=14 ! Formular/Dialog
LET xfadebox&=0 ! BOX in Baum XFADE
LET xfadexit&=1 ! BUTTON in Baum XFADE
LET xfadehlp&=2 ! BOXTEXT in Baum XFADE
LET xfadebx2&=4 ! BOX in Baum XFADE
LET xfadeno&=5 ! USERDEF in Baum XFADE
LET xfadeup&=6 ! USERDEF in Baum XFADE
LET xfadcros&=7 ! USERDEF in Baum XFADE
LET xfadedwn&=8 ! USERDEF in Baum XFADE
LET xfadebx3&=9 ! BOX in Baum XFADE
'
LET clocks&=15 ! Formular/Dialog
LET clkbox&=0 ! BOX in Baum CLOCKS
LET clockex&=2 ! BUTTON in Baum CLOCKS
LET clockhlp&=3 ! BOXTEXT in Baum CLOCKS
LET clockok&=4 ! BUTTON in Baum CLOCKS
LET clkbox2&=6 ! BOX in Baum CLOCKS
LET clock1&=7 ! BOXTEXT in Baum CLOCKS
LET clock2&=8 ! BOXTEXT in Baum CLOCKS
LET clkdown&=9 ! USERDEF in Baum CLOCKS
LET clkslid&=10 ! BOX in Baum CLOCKS
LET clkbut&=11 ! BUTTON in Baum CLOCKS
LET clkup&=12 ! USERDEF in Baum CLOCKS
LET clock3&=13 ! BOXTEXT in Baum CLOCKS
LET clock4&=14 ! BOXTEXT in Baum CLOCKS
LET clock5&=15 ! BOXTEXT in Baum CLOCKS
LET clockm&=16 ! BOXTEXT in Baum CLOCKS
'
rsc2$="STARMONO.RSC"
'
RETURN
'
> PROCEDURE rsc_for_color    ! Resource fÅr Farbauflîsungen
REM Resource Datei Indizes fÅr STARCOLR
'
LET info&=0 ! Formular/Dialog
LET infobox&=0 ! BOX in Baum INFO
LET infoexit&=1 ! BUTTON in Baum INFO
LET helpinfo&=2 ! BOXTEXT in Baum INFO
LET cpyrdrv&=4 ! TEXT in Baum INFO
LET cpyright&=5 ! TEXT in Baum INFO
LET infobild&=11 ! USERDEF in Baum INFO
LET swelogo&=18 ! USERDEF in Baum INFO
LET inforeg0&=19 ! TEXT in Baum INFO
LET inforeg1&=20 ! TEXT in Baum INFO
LET inforeg2&=21 ! TEXT in Baum INFO
LET inforeg3&=22 ! TEXT in Baum INFO
LET inforeg4&=23 ! TEXT in Baum INFO
'
LET peak&=1 ! Formular/Dialog
LET peakbox&=0 ! BOX in Baum PEAK
LET peaktl&=1 ! TEXT in Baum PEAK
LET peaktr&=2 ! TEXT in Baum PEAK
LET plmax&=3 ! BUTTON in Baum PEAK
LET prmax&=4 ! BUTTON in Baum PEAK
LET peakbox2&=5 ! BOX in Baum PEAK
LET pmdb2&=6 ! TEXT in Baum PEAK
LET pmdb3&=7 ! TEXT in Baum PEAK
LET pmdb4&=8 ! TEXT in Baum PEAK
LET pmdb5&=9 ! TEXT in Baum PEAK
LET pmdb6&=10 ! TEXT in Baum PEAK
LET pmdb7&=11 ! TEXT in Baum PEAK
LET pmdb8&=12 ! TEXT in Baum PEAK
LET pmdb9&=13 ! TEXT in Baum PEAK
LET pmdb10&=14 ! TEXT in Baum PEAK
LET pmdb1&=15 ! TEXT in Baum PEAK
LET pmover&=16 ! TEXT in Baum PEAK
LET peakname&=17 ! BOXTEXT in Baum PEAK
LET pkmbox&=18 ! BOX in Baum PEAK
LET volbox&=19 ! BOX in Baum PEAK
LET volfader&=20 ! ICON in Baum PEAK
LET volume&=21 ! USERDEF in Baum PEAK
LET smpautop&=23 ! USERDEF in Baum PEAK
LET smpstrtp&=24 ! USERDEF in Baum PEAK
LET playpeak&=25 ! USERDEF in Baum PEAK
LET recerror&=26 ! BOXTEXT in Baum PEAK
LET balbox&=28 ! BOXTEXT in Baum PEAK
LET balance&=30 ! USERDEF in Baum PEAK
LET recpeaks&=32 ! BOXTEXT in Baum PEAK
LET peakdb&=34 ! BOXTEXT in Baum PEAK
LET peakbal&=35 ! BOXTEXT in Baum PEAK
LET balancem&=53 ! TEXT in Baum PEAK
LET hardpeak&=54 ! USERDEF in Baum PEAK
LET playstop&=55 ! USERDEF in Baum PEAK
LET peakwait&=56 ! USERDEF in Baum PEAK
LET volzero&=57 ! TEXT in Baum PEAK
LET volinout&=58 ! USERDEF in Baum PEAK
LET peakch1&=59 ! BOXTEXT in Baum PEAK
LET peakch4&=60 ! BOXTEXT in Baum PEAK
LET peakch2&=61 ! BOXTEXT in Baum PEAK
LET peakch3&=62 ! BOXTEXT in Baum PEAK
LET lphold&=63 ! USERDEF in Baum PEAK
LET rphold&=64 ! USERDEF in Baum PEAK
LET phldslid&=65 ! BOX in Baum PEAK
LET pholdbut&=66 ! BUTTON in Baum PEAK
LET pkmbox2&=67 ! BOX in Baum PEAK
LET peakpos&=68 ! BOXTEXT in Baum PEAK
LET peakmax&=69 ! BOXTEXT in Baum PEAK
LET peakmaxt&=70 ! TEXT in Baum PEAK
LET peakpost&=71 ! TEXT in Baum PEAK
LET peakmute&=72 ! USERDEF in Baum PEAK
LET balzero&=73 ! USERDEF in Baum PEAK
LET peakhelp&=74 ! BOXTEXT in Baum PEAK
LET peakexit&=75 ! BUTTON in Baum PEAK
LET peakl&=77 ! USERDEF in Baum PEAK
LET peakr&=78 ! USERDEF in Baum PEAK
'
LET blkfunc&=2 ! Formular/Dialog
LET blkbox&=0 ! BOX in Baum BLKFUNC
LET cutin&=1 ! USERDEF in Baum BLKFUNC
LET cutout&=2 ! USERDEF in Baum BLKFUNC
LET blkexit&=3 ! BUTTON in Baum BLKFUNC
LET blkhelp&=5 ! BOXTEXT in Baum BLKFUNC
LET cutdel&=6 ! USERDEF in Baum BLKFUNC
LET norm&=10 ! USERDEF in Baum BLKFUNC
LET resmp&=11 ! USERDEF in Baum BLKFUNC
LET mono&=12 ! USERDEF in Baum BLKFUNC
LET conmix&=13 ! USERDEF in Baum BLKFUNC
LET conins&=14 ! USERDEF in Baum BLKFUNC
LET conspace&=15 ! USERDEF in Baum BLKFUNC
LET negate&=23 ! USERDEF in Baum BLKFUNC
LET lrchange&=25 ! USERDEF in Baum BLKFUNC
LET conv24&=31 ! USERDEF in Baum BLKFUNC
LET conv16&=32 ! USERDEF in Baum BLKFUNC
LET sernr&=35 ! TEXT in Baum BLKFUNC
'
LET cuelist&=3 ! Formular/Dialog
LET cuebox&=0 ! BOX in Baum CUELIST
LET cuebox2&=1 ! BOX in Baum CUELIST
LET cuex1&=2 ! BOXTEXT in Baum CUELIST
LET cuex2&=3 ! BOXTEXT in Baum CUELIST
LET cuex3&=4 ! BOXTEXT in Baum CUELIST
LET cuex4&=5 ! BOXTEXT in Baum CUELIST
LET cuex5&=6 ! BOXTEXT in Baum CUELIST
LET cuex6&=7 ! BOXTEXT in Baum CUELIST
LET cuex7&=8 ! BOXTEXT in Baum CUELIST
LET cuex8&=9 ! BOXTEXT in Baum CUELIST
LET cuex9&=10 ! BOXTEXT in Baum CUELIST
LET cuex10&=11 ! BOXTEXT in Baum CUELIST
LET cuenr1&=12 ! BOXTEXT in Baum CUELIST
LET cuenr2&=13 ! BOXTEXT in Baum CUELIST
LET cuenr3&=14 ! BOXTEXT in Baum CUELIST
LET cuenr4&=15 ! BOXTEXT in Baum CUELIST
LET cuenr5&=16 ! BOXTEXT in Baum CUELIST
LET cuenr6&=17 ! BOXTEXT in Baum CUELIST
LET cuenr7&=18 ! BOXTEXT in Baum CUELIST
LET cuenr8&=19 ! BOXTEXT in Baum CUELIST
LET cuenr9&=20 ! BOXTEXT in Baum CUELIST
LET cuenr10&=21 ! BOXTEXT in Baum CUELIST
LET cuet1&=22 ! BOXTEXT in Baum CUELIST
LET cuet2&=23 ! BOXTEXT in Baum CUELIST
LET cuet3&=24 ! BOXTEXT in Baum CUELIST
LET cuet4&=25 ! BOXTEXT in Baum CUELIST
LET cuet5&=26 ! BOXTEXT in Baum CUELIST
LET cuet6&=27 ! BOXTEXT in Baum CUELIST
LET cuet7&=28 ! BOXTEXT in Baum CUELIST
LET cuet8&=29 ! BOXTEXT in Baum CUELIST
LET cuet9&=30 ! BOXTEXT in Baum CUELIST
LET cuet10&=31 ! BOXTEXT in Baum CUELIST
LET cues1&=32 ! BOXTEXT in Baum CUELIST
LET cues2&=33 ! BOXTEXT in Baum CUELIST
LET cues3&=34 ! BOXTEXT in Baum CUELIST
LET cues4&=35 ! BOXTEXT in Baum CUELIST
LET cues5&=36 ! BOXTEXT in Baum CUELIST
LET cues6&=37 ! BOXTEXT in Baum CUELIST
LET cues7&=38 ! BOXTEXT in Baum CUELIST
LET cues8&=39 ! BOXTEXT in Baum CUELIST
LET cues9&=40 ! BOXTEXT in Baum CUELIST
LET cues10&=41 ! BOXTEXT in Baum CUELIST
LET cuee1&=42 ! BOXTEXT in Baum CUELIST
LET cuee2&=43 ! BOXTEXT in Baum CUELIST
LET cuee3&=44 ! BOXTEXT in Baum CUELIST
LET cuee4&=45 ! BOXTEXT in Baum CUELIST
LET cuee5&=46 ! BOXTEXT in Baum CUELIST
LET cuee6&=47 ! BOXTEXT in Baum CUELIST
LET cuee7&=48 ! BOXTEXT in Baum CUELIST
LET cuee8&=49 ! BOXTEXT in Baum CUELIST
LET cuee9&=50 ! BOXTEXT in Baum CUELIST
LET cuee10&=51 ! BOXTEXT in Baum CUELIST
LET cuel1&=52 ! BOXTEXT in Baum CUELIST
LET cuel2&=53 ! BOXTEXT in Baum CUELIST
LET cuel3&=54 ! BOXTEXT in Baum CUELIST
LET cuel4&=55 ! BOXTEXT in Baum CUELIST
LET cuel5&=56 ! BOXTEXT in Baum CUELIST
LET cuel6&=57 ! BOXTEXT in Baum CUELIST
LET cuel7&=58 ! BOXTEXT in Baum CUELIST
LET cuel8&=59 ! BOXTEXT in Baum CUELIST
LET cuel9&=60 ! BOXTEXT in Baum CUELIST
LET cuel10&=61 ! BOXTEXT in Baum CUELIST
LET cueslide&=62 ! BOX in Baum CUELIST
LET cueslbut&=63 ! BUTTON in Baum CUELIST
LET cueok&=64 ! BUTTON in Baum CUELIST
LET cuehelp&=65 ! BOXTEXT in Baum CUELIST
LET cuelink&=66 ! BUTTON in Baum CUELIST
LET cueadd&=67 ! BUTTON in Baum CUELIST
LET cueins&=68 ! BUTTON in Baum CUELIST
LET cueload&=69 ! USERDEF in Baum CUELIST
LET cuesave&=70 ! USERDEF in Baum CUELIST
LET cuekill&=71 ! USERDEF in Baum CUELIST
LET cueslup&=72 ! USERDEF in Baum CUELIST
LET cuesldwn&=73 ! USERDEF in Baum CUELIST
LET cuedel&=74 ! BUTTON in Baum CUELIST
LET cueplay&=78 ! USERDEF in Baum CUELIST
LET cuestop&=79 ! USERDEF in Baum CUELIST
LET cuesize&=80 ! BOXTEXT in Baum CUELIST
LET cuewait&=81 ! USERDEF in Baum CUELIST
LET cuepos&=83 ! BOXTEXT in Baum CUELIST
LET cuechnge&=88 ! BUTTON in Baum CUELIST
LET cuemix&=89 ! USERDEF in Baum CUELIST
LET cuecd&=91 ! USERDEF in Baum CUELIST
'
LET mixer&=4 ! Formular/Dialog
LET mixbox1&=0 ! BOX in Baum MIXER
LET mixbox2&=1 ! BOX in Baum MIXER
LET mixload&=2 ! USERDEF in Baum MIXER
LET mixsave&=3 ! USERDEF in Baum MIXER
LET mixmax&=4 ! BOXTEXT in Baum MIXER
LET mixact&=5 ! BOXTEXT in Baum MIXER
LET mixmaxt&=6 ! TEXT in Baum MIXER
LET mixactt&=7 ! TEXT in Baum MIXER
LET mixfile&=8 ! BOXTEXT in Baum MIXER
LET mixfilet&=9 ! TEXT in Baum MIXER
LET mixbx1&=10 ! BOX in Baum MIXER
LET mixvbox1&=11 ! BOX in Baum MIXER
LET mixfade1&=12 ! USERDEF in Baum MIXER
LET mixvol1&=13 ! USERDEF in Baum MIXER
LET mixdb1&=14 ! BOX in Baum MIXER
LET mixvold1&=18 ! TEXT in Baum MIXER
LET mixvolm1&=22 ! TEXT in Baum MIXER
LET mixvolz1&=30 ! IMAGE in Baum MIXER
LET mixvoll1&=31 ! BOX in Baum MIXER
LET mixvolr1&=32 ! BOX in Baum MIXER
LET mixpkl1&=33 ! BOX in Baum MIXER
LET mixpkr1&=34 ! BOX in Baum MIXER
LET mixvolt1&=35 ! BOXTEXT in Baum MIXER
LET mixvoln1&=36 ! BOXTEXT in Baum MIXER
LET mxbalbx1&=37 ! BOX in Baum MIXER
LET mixball1&=38 ! TEXT in Baum MIXER
LET mixbalr1&=39 ! TEXT in Baum MIXER
LET mixbalm1&=40 ! TEXT in Baum MIXER
LET mixbal1&=41 ! USERDEF in Baum MIXER
LET mixbalp1&=42 ! IMAGE in Baum MIXER
LET mixtit1&=43 ! BOXTEXT in Baum MIXER
LET mixbalt1&=44 ! BOXTEXT in Baum MIXER
LET mixbaln1&=45 ! BOXTEXT in Baum MIXER
LET mixon1&=46 ! USERDEF in Baum MIXER
LET mixall1&=47 ! USERDEF in Baum MIXER
LET mixmute1&=48 ! USERDEF in Baum MIXER
LET mixtxt1&=49 ! BOXTEXT in Baum MIXER
LET mixbyp1&=50 ! BOXTEXT in Baum MIXER
LET mixbx2&=52 ! BOX in Baum MIXER
LET mixvbox2&=53 ! BOX in Baum MIXER
LET mixfade2&=54 ! USERDEF in Baum MIXER
LET mixvol2&=55 ! USERDEF in Baum MIXER
LET mixdb2&=56 ! BOX in Baum MIXER
LET mixvold2&=60 ! TEXT in Baum MIXER
LET mixvolm2&=64 ! TEXT in Baum MIXER
LET mixvolz2&=72 ! IMAGE in Baum MIXER
LET mixvoll2&=73 ! BOX in Baum MIXER
LET mixvolr2&=74 ! BOX in Baum MIXER
LET mixpkl2&=75 ! BOX in Baum MIXER
LET mixpkr2&=76 ! BOX in Baum MIXER
LET mixvolt2&=77 ! BOXTEXT in Baum MIXER
LET mixvoln2&=78 ! BOXTEXT in Baum MIXER
LET mxbalbx2&=79 ! BOX in Baum MIXER
LET mixball2&=80 ! TEXT in Baum MIXER
LET mixbalr2&=81 ! TEXT in Baum MIXER
LET mixbalm2&=82 ! TEXT in Baum MIXER
LET mixbal2&=83 ! USERDEF in Baum MIXER
LET mixbalp2&=84 ! IMAGE in Baum MIXER
LET mixtit2&=85 ! BOXTEXT in Baum MIXER
LET mixbalt2&=86 ! BOXTEXT in Baum MIXER
LET mixbaln2&=87 ! BOXTEXT in Baum MIXER
LET mixon2&=88 ! USERDEF in Baum MIXER
LET mixall2&=89 ! USERDEF in Baum MIXER
LET mixmute2&=90 ! USERDEF in Baum MIXER
LET mixtxt2&=91 ! BOXTEXT in Baum MIXER
LET mixbyp2&=92 ! BOXTEXT in Baum MIXER
LET mixbx3&=93 ! BOX in Baum MIXER
LET mixvbox3&=94 ! BOX in Baum MIXER
LET mixfade3&=95 ! USERDEF in Baum MIXER
LET mixvol3&=96 ! USERDEF in Baum MIXER
LET mixdb3&=97 ! BOX in Baum MIXER
LET mixvold3&=101 ! TEXT in Baum MIXER
LET mixvolm3&=105 ! TEXT in Baum MIXER
LET mixvolz3&=113 ! IMAGE in Baum MIXER
LET mixvoll3&=114 ! BOX in Baum MIXER
LET mixvolr3&=115 ! BOX in Baum MIXER
LET mixpkl3&=116 ! BOX in Baum MIXER
LET mixpkr3&=117 ! BOX in Baum MIXER
LET mixvolt3&=118 ! BOXTEXT in Baum MIXER
LET mixvoln3&=119 ! BOXTEXT in Baum MIXER
LET mxbalbx3&=120 ! BOX in Baum MIXER
LET mixball3&=121 ! TEXT in Baum MIXER
LET mixbalr3&=122 ! TEXT in Baum MIXER
LET mixbalm3&=123 ! TEXT in Baum MIXER
LET mixbal3&=124 ! USERDEF in Baum MIXER
LET mixbalp3&=125 ! IMAGE in Baum MIXER
LET mixtit3&=126 ! BOXTEXT in Baum MIXER
LET mixbalt3&=127 ! BOXTEXT in Baum MIXER
LET mixbaln3&=128 ! BOXTEXT in Baum MIXER
LET mixon3&=129 ! USERDEF in Baum MIXER
LET mixall3&=130 ! USERDEF in Baum MIXER
LET mixmute3&=131 ! USERDEF in Baum MIXER
LET mixtxt3&=132 ! BOXTEXT in Baum MIXER
LET mixbyp3&=133 ! BOXTEXT in Baum MIXER
LET mixbx4&=134 ! BOX in Baum MIXER
LET mixvbox4&=135 ! BOX in Baum MIXER
LET mixfade4&=136 ! USERDEF in Baum MIXER
LET mixvol4&=137 ! USERDEF in Baum MIXER
LET mixdb4&=138 ! BOX in Baum MIXER
LET mixvold4&=142 ! TEXT in Baum MIXER
LET mixvolm4&=146 ! TEXT in Baum MIXER
LET mixvolz4&=154 ! IMAGE in Baum MIXER
LET mixvoll4&=155 ! BOX in Baum MIXER
LET mixvolr4&=156 ! BOX in Baum MIXER
LET mixpkl4&=157 ! BOX in Baum MIXER
LET mixpkr4&=158 ! BOX in Baum MIXER
LET mixvolt4&=159 ! BOXTEXT in Baum MIXER
LET mixvoln4&=160 ! BOXTEXT in Baum MIXER
LET mxbalbx4&=161 ! BOX in Baum MIXER
LET mixball4&=162 ! TEXT in Baum MIXER
LET mixbalr4&=163 ! TEXT in Baum MIXER
LET mixbalm4&=164 ! TEXT in Baum MIXER
LET mixbal4&=165 ! USERDEF in Baum MIXER
LET mixbalp4&=166 ! IMAGE in Baum MIXER
LET mixtit4&=167 ! BOXTEXT in Baum MIXER
LET mixbalt4&=168 ! BOXTEXT in Baum MIXER
LET mixbaln4&=169 ! BOXTEXT in Baum MIXER
LET mixon4&=170 ! USERDEF in Baum MIXER
LET mixall4&=171 ! USERDEF in Baum MIXER
LET mixmute4&=172 ! USERDEF in Baum MIXER
LET mixtxt4&=173 ! BOXTEXT in Baum MIXER
LET mixbyp4&=174 ! BOXTEXT in Baum MIXER
LET mixbx5&=175 ! BOX in Baum MIXER
LET mixvbox5&=176 ! BOX in Baum MIXER
LET mixfade5&=177 ! USERDEF in Baum MIXER
LET mixvol5&=178 ! USERDEF in Baum MIXER
LET mixdb5&=179 ! BOX in Baum MIXER
LET mixvold5&=183 ! TEXT in Baum MIXER
LET mixvolm5&=187 ! TEXT in Baum MIXER
LET mixvolz5&=195 ! IMAGE in Baum MIXER
LET mixvoll5&=196 ! BOX in Baum MIXER
LET mixvolr5&=197 ! BOX in Baum MIXER
LET mixpkl5&=198 ! BOX in Baum MIXER
LET mixpkr5&=199 ! BOX in Baum MIXER
LET mixvolt5&=200 ! BOXTEXT in Baum MIXER
LET mixvoln5&=201 ! BOXTEXT in Baum MIXER
LET mxbalbx5&=202 ! BOX in Baum MIXER
LET mixball5&=203 ! TEXT in Baum MIXER
LET mixbalr5&=204 ! TEXT in Baum MIXER
LET mixbalm5&=205 ! TEXT in Baum MIXER
LET mixbal5&=206 ! USERDEF in Baum MIXER
LET mixbalp5&=207 ! IMAGE in Baum MIXER
LET mixtit5&=208 ! BOXTEXT in Baum MIXER
LET mixbalt5&=209 ! BOXTEXT in Baum MIXER
LET mixbaln5&=210 ! BOXTEXT in Baum MIXER
LET mixon5&=211 ! USERDEF in Baum MIXER
LET mixall5&=212 ! USERDEF in Baum MIXER
LET mixmute5&=213 ! USERDEF in Baum MIXER
LET mixtxt5&=214 ! BOXTEXT in Baum MIXER
LET mixbyp5&=215 ! BOXTEXT in Baum MIXER
LET mixbx6&=216 ! BOX in Baum MIXER
LET mixvbox6&=217 ! BOX in Baum MIXER
LET mixfade6&=218 ! USERDEF in Baum MIXER
LET mixvol6&=219 ! USERDEF in Baum MIXER
LET mixdb6&=220 ! BOX in Baum MIXER
LET mixvold6&=224 ! TEXT in Baum MIXER
LET mixvolm6&=228 ! TEXT in Baum MIXER
LET mixvolz6&=236 ! IMAGE in Baum MIXER
LET mixvoll6&=237 ! BOX in Baum MIXER
LET mixvolr6&=238 ! BOX in Baum MIXER
LET mixpkl6&=239 ! BOX in Baum MIXER
LET mixpkr6&=240 ! BOX in Baum MIXER
LET mixvolt6&=241 ! BOXTEXT in Baum MIXER
LET mixvoln6&=242 ! BOXTEXT in Baum MIXER
LET mxbalbx6&=243 ! BOX in Baum MIXER
LET mixball6&=244 ! TEXT in Baum MIXER
LET mixbalr6&=245 ! TEXT in Baum MIXER
LET mixbalm6&=246 ! TEXT in Baum MIXER
LET mixbal6&=247 ! USERDEF in Baum MIXER
LET mixbalp6&=248 ! IMAGE in Baum MIXER
LET mixtit6&=249 ! BOXTEXT in Baum MIXER
LET mixbalt6&=250 ! BOXTEXT in Baum MIXER
LET mixbaln6&=251 ! BOXTEXT in Baum MIXER
LET mixon6&=252 ! USERDEF in Baum MIXER
LET mixall6&=253 ! USERDEF in Baum MIXER
LET mixmute6&=254 ! USERDEF in Baum MIXER
LET mixtxt6&=255 ! BOXTEXT in Baum MIXER
LET mixbyp6&=256 ! BOXTEXT in Baum MIXER
LET mixbx7&=257 ! BOX in Baum MIXER
LET mixvbox7&=258 ! BOX in Baum MIXER
LET mixfade7&=259 ! USERDEF in Baum MIXER
LET mixvol7&=260 ! USERDEF in Baum MIXER
LET mixdb7&=261 ! BOX in Baum MIXER
LET mixvold7&=265 ! TEXT in Baum MIXER
LET mixvolm7&=269 ! TEXT in Baum MIXER
LET mixvolz7&=277 ! IMAGE in Baum MIXER
LET mixvoll7&=278 ! BOX in Baum MIXER
LET mixvolr7&=279 ! BOX in Baum MIXER
LET mixpkl7&=280 ! BOX in Baum MIXER
LET mixpkr7&=281 ! BOX in Baum MIXER
LET mixvolt7&=282 ! BOXTEXT in Baum MIXER
LET mixvoln7&=283 ! BOXTEXT in Baum MIXER
LET mxbalbx7&=284 ! BOX in Baum MIXER
LET mixball7&=285 ! TEXT in Baum MIXER
LET mixbalr7&=286 ! TEXT in Baum MIXER
LET mixbalm7&=287 ! TEXT in Baum MIXER
LET mixbal7&=288 ! USERDEF in Baum MIXER
LET mixbalp7&=289 ! IMAGE in Baum MIXER
LET mixtit7&=290 ! BOXTEXT in Baum MIXER
LET mixbalt7&=291 ! BOXTEXT in Baum MIXER
LET mixbaln7&=292 ! BOXTEXT in Baum MIXER
LET mixon7&=293 ! USERDEF in Baum MIXER
LET mixall7&=294 ! USERDEF in Baum MIXER
LET mixmute7&=295 ! USERDEF in Baum MIXER
LET mixtxt7&=296 ! BOXTEXT in Baum MIXER
LET mixbyp7&=297 ! BOXTEXT in Baum MIXER
LET mixbx8&=298 ! BOX in Baum MIXER
LET mixvbox8&=299 ! BOX in Baum MIXER
LET mixfade8&=300 ! USERDEF in Baum MIXER
LET mixvol8&=301 ! USERDEF in Baum MIXER
LET mixdb8&=302 ! BOX in Baum MIXER
LET mixvold8&=306 ! TEXT in Baum MIXER
LET mixvolm8&=310 ! TEXT in Baum MIXER
LET mixvolz8&=318 ! IMAGE in Baum MIXER
LET mixvoll8&=319 ! BOX in Baum MIXER
LET mixvolr8&=320 ! BOX in Baum MIXER
LET mixpkl8&=321 ! BOX in Baum MIXER
LET mixpkr8&=322 ! BOX in Baum MIXER
LET mixvolt8&=323 ! BOXTEXT in Baum MIXER
LET mixvoln8&=324 ! BOXTEXT in Baum MIXER
LET mxbalbx8&=325 ! BOX in Baum MIXER
LET mixball8&=326 ! TEXT in Baum MIXER
LET mixbalr8&=327 ! TEXT in Baum MIXER
LET mixbalm8&=328 ! TEXT in Baum MIXER
LET mixbal8&=329 ! USERDEF in Baum MIXER
LET mixbalp8&=330 ! IMAGE in Baum MIXER
LET mixtit8&=331 ! BOXTEXT in Baum MIXER
LET mixbalt8&=332 ! BOXTEXT in Baum MIXER
LET mixbaln8&=333 ! BOXTEXT in Baum MIXER
LET mixon8&=334 ! USERDEF in Baum MIXER
LET mixall8&=335 ! USERDEF in Baum MIXER
LET mixmute8&=336 ! USERDEF in Baum MIXER
LET mixtxt8&=337 ! BOXTEXT in Baum MIXER
LET mixbyp8&=338 ! BOXTEXT in Baum MIXER
LET mixbxm&=339 ! BOX in Baum MIXER
LET mixvboxm&=340 ! BOX in Baum MIXER
LET mixfadem&=341 ! USERDEF in Baum MIXER
LET mixvolm&=342 ! USERDEF in Baum MIXER
LET mixdbm&=343 ! BOX in Baum MIXER
LET mixvoldm&=347 ! TEXT in Baum MIXER
LET mixvolmm&=351 ! TEXT in Baum MIXER
LET mixvolzm&=359 ! IMAGE in Baum MIXER
LET mixvollm&=360 ! BOX in Baum MIXER
LET mixvolrm&=361 ! BOX in Baum MIXER
LET mixpklm&=362 ! BOX in Baum MIXER
LET mixpkrm&=363 ! BOX in Baum MIXER
LET mixvoltm&=364 ! BOXTEXT in Baum MIXER
LET mixvolnm&=365 ! BOXTEXT in Baum MIXER
LET mxbalbxm&=366 ! BOX in Baum MIXER
LET mixballm&=367 ! TEXT in Baum MIXER
LET mixbalrm&=368 ! TEXT in Baum MIXER
LET mixbalmm&=369 ! TEXT in Baum MIXER
LET mixbalm&=370 ! USERDEF in Baum MIXER
LET mixbalpm&=371 ! IMAGE in Baum MIXER
LET mixtitm&=372 ! BOXTEXT in Baum MIXER
LET mixbaltm&=373 ! BOXTEXT in Baum MIXER
LET mixbalnm&=374 ! BOXTEXT in Baum MIXER
LET mixonm&=375 ! USERDEF in Baum MIXER
LET mixallm&=376 ! USERDEF in Baum MIXER
LET mixmutem&=377 ! USERDEF in Baum MIXER
LET mixtxtm&=378 ! BOXTEXT in Baum MIXER
LET mixbypm&=379 ! BOXTEXT in Baum MIXER
LET mixbx9&=380 ! BOX in Baum MIXER
LET mixvbox9&=381 ! BOX in Baum MIXER
LET mixfade9&=382 ! USERDEF in Baum MIXER
LET mixvol9&=383 ! USERDEF in Baum MIXER
LET mixdb9&=384 ! BOX in Baum MIXER
LET mixvold9&=388 ! TEXT in Baum MIXER
LET mixvolm9&=392 ! TEXT in Baum MIXER
LET mixvolz9&=400 ! IMAGE in Baum MIXER
LET mixvoll9&=401 ! BOX in Baum MIXER
LET mixvolr9&=402 ! BOX in Baum MIXER
LET mixpkl9&=403 ! BOX in Baum MIXER
LET mixpkr9&=404 ! BOX in Baum MIXER
LET mixvolt9&=405 ! BOXTEXT in Baum MIXER
LET mixvoln9&=406 ! BOXTEXT in Baum MIXER
LET mxbalbx9&=407 ! BOX in Baum MIXER
LET mixball9&=408 ! TEXT in Baum MIXER
LET mixbalr9&=409 ! TEXT in Baum MIXER
LET mixbalm9&=410 ! TEXT in Baum MIXER
LET mixbal9&=411 ! USERDEF in Baum MIXER
LET mixbalp9&=412 ! IMAGE in Baum MIXER
LET mixtit9&=413 ! BOXTEXT in Baum MIXER
LET mixbalt9&=414 ! BOXTEXT in Baum MIXER
LET mixbaln9&=415 ! BOXTEXT in Baum MIXER
LET mixon9&=416 ! USERDEF in Baum MIXER
LET mixall9&=417 ! USERDEF in Baum MIXER
LET mixmute9&=418 ! USERDEF in Baum MIXER
LET mixtxt9&=419 ! BOXTEXT in Baum MIXER
LET mixbyp9&=420 ! BOXTEXT in Baum MIXER
LET mixbx10&=421 ! BOX in Baum MIXER
LET mxvbox10&=422 ! BOX in Baum MIXER
LET mixfad10&=423 ! USERDEF in Baum MIXER
LET mixvol10&=424 ! USERDEF in Baum MIXER
LET mixdb10&=425 ! BOX in Baum MIXER
LET mxvold10&=429 ! TEXT in Baum MIXER
LET mxvolm10&=433 ! TEXT in Baum MIXER
LET mxvolz10&=441 ! IMAGE in Baum MIXER
LET mxvoll10&=442 ! BOX in Baum MIXER
LET mxvolr10&=443 ! BOX in Baum MIXER
LET mixpkl10&=444 ! BOX in Baum MIXER
LET mixpkr10&=445 ! BOX in Baum MIXER
LET mxvolt10&=446 ! BOXTEXT in Baum MIXER
LET mxvoln10&=447 ! BOXTEXT in Baum MIXER
LET mbalbx10&=448 ! BOX in Baum MIXER
LET mixbll10&=449 ! TEXT in Baum MIXER
LET mixblr10&=450 ! TEXT in Baum MIXER
LET mixblm10&=451 ! TEXT in Baum MIXER
LET mixbal10&=452 ! USERDEF in Baum MIXER
LET mixblp10&=453 ! IMAGE in Baum MIXER
LET mixtit10&=454 ! BOXTEXT in Baum MIXER
LET mixblt10&=455 ! BOXTEXT in Baum MIXER
LET mixbln10&=456 ! BOXTEXT in Baum MIXER
LET mixon10&=457 ! USERDEF in Baum MIXER
LET mixall10&=458 ! USERDEF in Baum MIXER
LET mixmut10&=459 ! USERDEF in Baum MIXER
LET mixtxt10&=460 ! BOXTEXT in Baum MIXER
LET mixbyp10&=461 ! BOXTEXT in Baum MIXER
LET mixbx11&=462 ! BOX in Baum MIXER
LET mxvbox11&=463 ! BOX in Baum MIXER
LET mixfad11&=464 ! USERDEF in Baum MIXER
LET mixvol11&=465 ! USERDEF in Baum MIXER
LET mixdb11&=466 ! BOX in Baum MIXER
LET mxvold11&=470 ! TEXT in Baum MIXER
LET mxvolm11&=474 ! TEXT in Baum MIXER
LET mxvolz11&=482 ! IMAGE in Baum MIXER
LET mxvoll11&=483 ! BOX in Baum MIXER
LET mxvolr11&=484 ! BOX in Baum MIXER
LET mixpkl11&=485 ! BOX in Baum MIXER
LET mixpkr11&=486 ! BOX in Baum MIXER
LET mxvolt11&=487 ! BOXTEXT in Baum MIXER
LET mxvoln11&=488 ! BOXTEXT in Baum MIXER
LET mbalbx11&=489 ! BOX in Baum MIXER
LET mixbll11&=490 ! TEXT in Baum MIXER
LET mixblr11&=491 ! TEXT in Baum MIXER
LET mixblm11&=492 ! TEXT in Baum MIXER
LET mixbal11&=493 ! USERDEF in Baum MIXER
LET mixblp11&=494 ! IMAGE in Baum MIXER
LET mixtit11&=495 ! BOXTEXT in Baum MIXER
LET mixblt11&=496 ! BOXTEXT in Baum MIXER
LET mixbln11&=497 ! BOXTEXT in Baum MIXER
LET mixon11&=498 ! USERDEF in Baum MIXER
LET mixall11&=499 ! USERDEF in Baum MIXER
LET mixmut11&=500 ! USERDEF in Baum MIXER
LET mixtxt11&=501 ! BOXTEXT in Baum MIXER
LET mixbyp11&=502 ! BOXTEXT in Baum MIXER
LET mixbx12&=503 ! BOX in Baum MIXER
LET mxvbox12&=504 ! BOX in Baum MIXER
LET mixfad12&=505 ! USERDEF in Baum MIXER
LET mixvol12&=506 ! USERDEF in Baum MIXER
LET mixdb12&=507 ! BOX in Baum MIXER
LET mxvold12&=511 ! TEXT in Baum MIXER
LET mxvolm12&=515 ! TEXT in Baum MIXER
LET mxvolz12&=523 ! IMAGE in Baum MIXER
LET mxvoll12&=524 ! BOX in Baum MIXER
LET mxvolr12&=525 ! BOX in Baum MIXER
LET mixpkl12&=526 ! BOX in Baum MIXER
LET mixpkr12&=527 ! BOX in Baum MIXER
LET mxvolt12&=528 ! BOXTEXT in Baum MIXER
LET mxvoln12&=529 ! BOXTEXT in Baum MIXER
LET mbalbx12&=530 ! BOX in Baum MIXER
LET mixbll12&=531 ! TEXT in Baum MIXER
LET mixblr12&=532 ! TEXT in Baum MIXER
LET mixblm12&=533 ! TEXT in Baum MIXER
LET mixbal12&=534 ! USERDEF in Baum MIXER
LET mixblp12&=535 ! IMAGE in Baum MIXER
LET mixtit12&=536 ! BOXTEXT in Baum MIXER
LET mixblt12&=537 ! BOXTEXT in Baum MIXER
LET mixbln12&=538 ! BOXTEXT in Baum MIXER
LET mixon12&=539 ! USERDEF in Baum MIXER
LET mixall12&=540 ! USERDEF in Baum MIXER
LET mixmut12&=541 ! USERDEF in Baum MIXER
LET mixtxt12&=542 ! BOXTEXT in Baum MIXER
LET mixbyp12&=543 ! BOXTEXT in Baum MIXER
LET mixbx13&=544 ! BOX in Baum MIXER
LET mxvbox13&=545 ! BOX in Baum MIXER
LET mixfad13&=546 ! USERDEF in Baum MIXER
LET mixvol13&=547 ! USERDEF in Baum MIXER
LET mixdb13&=548 ! BOX in Baum MIXER
LET mxvold13&=552 ! TEXT in Baum MIXER
LET mxvolm13&=556 ! TEXT in Baum MIXER
LET mxvolz13&=564 ! IMAGE in Baum MIXER
LET mxvoll13&=565 ! BOX in Baum MIXER
LET mxvolr13&=566 ! BOX in Baum MIXER
LET mixpkl13&=567 ! BOX in Baum MIXER
LET mixpkr13&=568 ! BOX in Baum MIXER
LET mxvolt13&=569 ! BOXTEXT in Baum MIXER
LET mxvoln13&=570 ! BOXTEXT in Baum MIXER
LET mbalbx13&=571 ! BOX in Baum MIXER
LET mixbll13&=572 ! TEXT in Baum MIXER
LET mixblr13&=573 ! TEXT in Baum MIXER
LET mixblm13&=574 ! TEXT in Baum MIXER
LET mixbal13&=575 ! USERDEF in Baum MIXER
LET mixblp13&=576 ! IMAGE in Baum MIXER
LET mixtit13&=577 ! BOXTEXT in Baum MIXER
LET mixblt13&=578 ! BOXTEXT in Baum MIXER
LET mixbln13&=579 ! BOXTEXT in Baum MIXER
LET mixon13&=580 ! USERDEF in Baum MIXER
LET mixall13&=581 ! USERDEF in Baum MIXER
LET mixmut13&=582 ! USERDEF in Baum MIXER
LET mixtxt13&=583 ! BOXTEXT in Baum MIXER
LET mixbyp13&=584 ! BOXTEXT in Baum MIXER
LET mixbx14&=585 ! BOX in Baum MIXER
LET mxvbox14&=586 ! BOX in Baum MIXER
LET mixfad14&=587 ! USERDEF in Baum MIXER
LET mixvol14&=588 ! USERDEF in Baum MIXER
LET mixdb14&=589 ! BOX in Baum MIXER
LET mxvold14&=593 ! TEXT in Baum MIXER
LET mxvolm14&=597 ! TEXT in Baum MIXER
LET mxvolz14&=605 ! IMAGE in Baum MIXER
LET mxvoll14&=606 ! BOX in Baum MIXER
LET mxvolr14&=607 ! BOX in Baum MIXER
LET mixpkl14&=608 ! BOX in Baum MIXER
LET mixpkr14&=609 ! BOX in Baum MIXER
LET mxvolt14&=610 ! BOXTEXT in Baum MIXER
LET mxvoln14&=611 ! BOXTEXT in Baum MIXER
LET mbalbx14&=612 ! BOX in Baum MIXER
LET mixbll14&=613 ! TEXT in Baum MIXER
LET mixblr14&=614 ! TEXT in Baum MIXER
LET mixblm14&=615 ! TEXT in Baum MIXER
LET mixbal14&=616 ! USERDEF in Baum MIXER
LET mixblp14&=617 ! IMAGE in Baum MIXER
LET mixtit14&=618 ! BOXTEXT in Baum MIXER
LET mixblt14&=619 ! BOXTEXT in Baum MIXER
LET mixbln14&=620 ! BOXTEXT in Baum MIXER
LET mixon14&=621 ! USERDEF in Baum MIXER
LET mixall14&=622 ! USERDEF in Baum MIXER
LET mixmut14&=623 ! USERDEF in Baum MIXER
LET mixtxt14&=624 ! BOXTEXT in Baum MIXER
LET mixbyp14&=625 ! BOXTEXT in Baum MIXER
LET mixbx15&=626 ! BOX in Baum MIXER
LET mxvbox15&=627 ! BOX in Baum MIXER
LET mixfad15&=628 ! USERDEF in Baum MIXER
LET mixvol15&=629 ! USERDEF in Baum MIXER
LET mixdb15&=630 ! BOX in Baum MIXER
LET mxvold15&=634 ! TEXT in Baum MIXER
LET mxvolm15&=638 ! TEXT in Baum MIXER
LET mxvolz15&=646 ! IMAGE in Baum MIXER
LET mxvoll15&=647 ! BOX in Baum MIXER
LET mxvolr15&=648 ! BOX in Baum MIXER
LET mixpkl15&=649 ! BOX in Baum MIXER
LET mixpkr15&=650 ! BOX in Baum MIXER
LET mxvolt15&=651 ! BOXTEXT in Baum MIXER
LET mxvoln15&=652 ! BOXTEXT in Baum MIXER
LET mbalbx15&=653 ! BOX in Baum MIXER
LET mixbll15&=654 ! TEXT in Baum MIXER
LET mixblr15&=655 ! TEXT in Baum MIXER
LET mixblm15&=656 ! TEXT in Baum MIXER
LET mixbal15&=657 ! USERDEF in Baum MIXER
LET mixblp15&=658 ! IMAGE in Baum MIXER
LET mixtit15&=659 ! BOXTEXT in Baum MIXER
LET mixblt15&=660 ! BOXTEXT in Baum MIXER
LET mixbln15&=661 ! BOXTEXT in Baum MIXER
LET mixon15&=662 ! USERDEF in Baum MIXER
LET mixall15&=663 ! USERDEF in Baum MIXER
LET mixmut15&=664 ! USERDEF in Baum MIXER
LET mixtxt15&=665 ! BOXTEXT in Baum MIXER
LET mixbyp15&=666 ! BOXTEXT in Baum MIXER
LET mixbx16&=667 ! BOX in Baum MIXER
LET mxvbox16&=668 ! BOX in Baum MIXER
LET mixfad16&=669 ! USERDEF in Baum MIXER
LET mixvol16&=670 ! USERDEF in Baum MIXER
LET mixdb16&=671 ! BOX in Baum MIXER
LET mxvold16&=675 ! TEXT in Baum MIXER
LET mxvolm16&=679 ! TEXT in Baum MIXER
LET mxvolz16&=687 ! IMAGE in Baum MIXER
LET mxvoll16&=688 ! BOX in Baum MIXER
LET mxvolr16&=689 ! BOX in Baum MIXER
LET mixpkl16&=690 ! BOX in Baum MIXER
LET mixpkr16&=691 ! BOX in Baum MIXER
LET mxvolt16&=692 ! BOXTEXT in Baum MIXER
LET mxvoln16&=693 ! BOXTEXT in Baum MIXER
LET mbalbx16&=694 ! BOX in Baum MIXER
LET mixbll16&=695 ! TEXT in Baum MIXER
LET mixblr16&=696 ! TEXT in Baum MIXER
LET mixblm16&=697 ! TEXT in Baum MIXER
LET mixbal16&=698 ! USERDEF in Baum MIXER
LET mixblp16&=699 ! IMAGE in Baum MIXER
LET mixtit16&=700 ! BOXTEXT in Baum MIXER
LET mixblt16&=701 ! BOXTEXT in Baum MIXER
LET mixbln16&=702 ! BOXTEXT in Baum MIXER
LET mixon16&=703 ! USERDEF in Baum MIXER
LET mixall16&=704 ! USERDEF in Baum MIXER
LET mixmut16&=705 ! USERDEF in Baum MIXER
LET mixtxt16&=706 ! BOXTEXT in Baum MIXER
LET mixbyp16&=707 ! BOXTEXT in Baum MIXER
LET mixbox3&=708 ! BOX in Baum MIXER
LET mixstop&=709 ! USERDEF in Baum MIXER
LET mixwait&=710 ! USERDEF in Baum MIXER
LET mixhelp&=711 ! BOXTEXT in Baum MIXER
LET mixexit&=712 ! BUTTON in Baum MIXER
LET mixrec&=713 ! USERDEF in Baum MIXER
LET mixplay&=714 ! USERDEF in Baum MIXER
LET mixarec&=715 ! USERDEF in Baum MIXER
LET mixrecp&=716 ! USERDEF in Baum MIXER
LET mpkhl&=717 ! USERDEF in Baum MIXER
LET mpkhslid&=718 ! BOX in Baum MIXER
LET mpkhbut&=719 ! BUTTON in Baum MIXER
LET mpkhr&=720 ! USERDEF in Baum MIXER
LET mixpeak&=721 ! BOXTEXT in Baum MIXER
LET mixpeakt&=722 ! TEXT in Baum MIXER
LET mixerr&=723 ! BOXTEXT in Baum MIXER
LET mixerrt&=724 ! TEXT in Baum MIXER
'
LET virtual&=5 ! Formular/Dialog
LET virtbox&=0 ! BOX in Baum VIRTUAL
LET virthelp&=2 ! BOXTEXT in Baum VIRTUAL
LET virtbloc&=4 ! BUTTON in Baum VIRTUAL
LET virtok&=5 ! BUTTON in Baum VIRTUAL
LET virtbox3&=6 ! BOX in Baum VIRTUAL
LET vblkstrt&=7 ! FBOXTEXT in Baum VIRTUAL
LET vseconds&=8 ! BUTTON in Baum VIRTUAL
LET vsamples&=9 ! BUTTON in Baum VIRTUAL
LET vblkmlen&=10 ! BOXTEXT in Baum VIRTUAL
LET vblkvlen&=12 ! BOXTEXT in Baum VIRTUAL
LET vslider&=13 ! BOX in Baum VIRTUAL
LET vslbut&=14 ! BUTTON in Baum VIRTUAL
LET virtbox2&=15 ! BOX in Baum VIRTUAL
LET virtwork&=16 ! BUTTON in Baum VIRTUAL
LET virtdir&=17 ! BUTTON in Baum VIRTUAL
LET vrslide&=18 ! USERDEF in Baum VIRTUAL
LET vlslide&=19 ! USERDEF in Baum VIRTUAL
LET virtno&=21 ! BUTTON in Baum VIRTUAL
LET virtplay&=22 ! USERDEF in Baum VIRTUAL
LET virtstop&=24 ! USERDEF in Baum VIRTUAL
'
LET record&=6 ! Formular/Dialog
LET recbox&=0 ! BOX in Baum RECORD
LET recfree&=1 ! BOXTEXT in Baum RECORD
LET recok&=2 ! BUTTON in Baum RECORD
LET recexit&=3 ! BUTTON in Baum RECORD
LET timemeld&=4 ! TEXT in Baum RECORD
LET rechelp&=5 ! BOXTEXT in Baum RECORD
LET timetxt&=9 ! FBOXTEXT in Baum RECORD
LET tinpul1&=12 ! USERDEF in Baum RECORD
LET tinpul2&=14 ! USERDEF in Baum RECORD
LET tinpul3&=15 ! USERDEF in Baum RECORD
LET tinpul4&=16 ! USERDEF in Baum RECORD
LET tinpuh1&=17 ! USERDEF in Baum RECORD
LET tinpuh2&=18 ! USERDEF in Baum RECORD
LET tinpuh3&=19 ! USERDEF in Baum RECORD
LET tinpuh4&=20 ! USERDEF in Baum RECORD
LET tinpdh1&=21 ! USERDEF in Baum RECORD
LET tinpdh2&=22 ! USERDEF in Baum RECORD
LET tinpdh3&=23 ! USERDEF in Baum RECORD
LET tinpdh4&=24 ! USERDEF in Baum RECORD
LET tinpdl1&=25 ! USERDEF in Baum RECORD
LET tinpdl2&=26 ! USERDEF in Baum RECORD
LET tinpdl3&=27 ! USERDEF in Baum RECORD
LET tinpdl4&=28 ! USERDEF in Baum RECORD
LET recti1&=31 ! BOX in Baum RECORD
LET recti2&=32 ! BOX in Baum RECORD
LET recti3&=33 ! BOX in Baum RECORD
LET recti4&=34 ! BOX in Baum RECORD
LET tinmin&=35 ! BUTTON in Baum RECORD
LET tinmax&=36 ! BUTTON in Baum RECORD
'
LET savebloc&=7 ! Formular/Dialog
LET savebox&=0 ! BOX in Baum SAVEBLOC
LET savall&=1 ! USERDEF in Baum SAVEBLOC
LET savblock&=2 ! USERDEF in Baum SAVEBLOC
LET savexit&=3 ! BUTTON in Baum SAVEBLOC
LET savetxt&=4 ! TEXT in Baum SAVEBLOC
LET savehelp&=5 ! BOXTEXT in Baum SAVEBLOC
'
LET abackup&=8 ! Formular/Dialog
LET abackbox&=0 ! BOX in Baum ABACKUP
LET abacktxt&=1 ! BOXTEXT in Baum ABACKUP
LET abackok&=2 ! BUTTON in Baum ABACKUP
LET abackex&=3 ! BUTTON in Baum ABACKUP
LET abackhlp&=5 ! BOXTEXT in Baum ABACKUP
LET abackr1&=8 ! USERDEF in Baum ABACKUP
LET abackr2&=9 ! USERDEF in Baum ABACKUP
LET abackl1&=10 ! USERDEF in Baum ABACKUP
LET abackl2&=11 ! USERDEF in Baum ABACKUP
LET abackbo2&=12 ! BOX in Baum ABACKUP
LET aback&=13 ! BUTTON in Baum ABACKUP
LET abacknam&=14 ! BUTTON in Baum ABACKUP
'
LET midiedit&=9 ! Formular/Dialog
LET midibox&=0 ! BOX in Baum MIDIEDIT
LET notetxt&=1 ! BOXTEXT in Baum MIDIEDIT
LET chtxt&=3 ! BOXTEXT in Baum MIDIEDIT
LET midiok&=5 ! BUTTON in Baum MIDIEDIT
LET helpmidi&=6 ! BOXTEXT in Baum MIDIEDIT
LET midinup&=9 ! USERDEF in Baum MIDIEDIT
LET midioup&=10 ! USERDEF in Baum MIDIEDIT
LET midindwn&=11 ! USERDEF in Baum MIDIEDIT
LET midiodwn&=12 ! USERDEF in Baum MIDIEDIT
LET midicup&=13 ! USERDEF in Baum MIDIEDIT
LET midicdwn&=14 ! USERDEF in Baum MIDIEDIT
'
LET normaliz&=10 ! Formular/Dialog
LET normbox&=0 ! BOX in Baum NORMALIZ
LET normok&=2 ! BUTTON in Baum NORMALIZ
LET normexit&=3 ! BUTTON in Baum NORMALIZ
LET maxdb&=4 ! BOXTEXT in Baum NORMALIZ
LET normbox2&=6 ! BOX in Baum NORMALIZ
LET normauto&=7 ! BUTTON in Baum NORMALIZ
LET normadj&=8 ! BUTTON in Baum NORMALIZ
LET normbox3&=9 ! BOX in Baum NORMALIZ
LET norml1&=10 ! USERDEF in Baum NORMALIZ
LET norml2&=11 ! USERDEF in Baum NORMALIZ
LET norml3&=12 ! USERDEF in Baum NORMALIZ
LET normr1&=13 ! USERDEF in Baum NORMALIZ
LET normr2&=14 ! USERDEF in Baum NORMALIZ
LET normr3&=15 ! USERDEF in Baum NORMALIZ
LET helpnorm&=16 ! BOXTEXT in Baum NORMALIZ
LET normdb&=18 ! BOXTEXT in Baum NORMALIZ
'
LET resample&=11 ! Formular/Dialog
LET resmpbox&=0 ! BOX in Baum RESAMPLE
LET rsmptxt1&=1 ! TEXT in Baum RESAMPLE
LET resmpsel&=6 ! BOXTEXT in Baum RESAMPLE
LET resmpirc&=7 ! BOXCHAR in Baum RESAMPLE
LET resmpsec&=8 ! BOXTEXT in Baum RESAMPLE
LET resmplen&=9 ! BOXTEXT in Baum RESAMPLE
LET resmpfac&=10 ! BOXTEXT in Baum RESAMPLE
LET resmpbx3&=11 ! BOX in Baum RESAMPLE
LET resother&=12 ! FBOXTEXT in Baum RESAMPLE
LET rsmptxt2&=13 ! TEXT in Baum RESAMPLE
LET resl3&=14 ! USERDEF in Baum RESAMPLE
LET resl2&=15 ! USERDEF in Baum RESAMPLE
LET resl1&=16 ! USERDEF in Baum RESAMPLE
LET resr1&=17 ! USERDEF in Baum RESAMPLE
LET resr2&=18 ! USERDEF in Baum RESAMPLE
LET resr3&=19 ! USERDEF in Baum RESAMPLE
LET adjresmp&=20 ! BUTTON in Baum RESAMPLE
LET resmpbx2&=21 ! BOX in Baum RESAMPLE
LET restxt&=22 ! FBOXTEXT in Baum RESAMPLE
LET helprsmp&=23 ! BOXTEXT in Baum RESAMPLE
LET resexit&=24 ! BUTTON in Baum RESAMPLE
LET resok&=25 ! BUTTON in Baum RESAMPLE
'
LET mrkfind&=12 ! Formular/Dialog
LET mrkfbox&=0 ! BOX in Baum MRKFIND
LET mrkfex&=2 ! BUTTON in Baum MRKFIND
LET mrkfhelp&=3 ! BOXTEXT in Baum MRKFIND
LET mrkfok&=4 ! BUTTON in Baum MRKFIND
LET mrkfbox2&=6 ! BOX in Baum MRKFIND
LET mrkftims&=7 ! BOXTEXT in Baum MRKFIND
LET mrkftime&=8 ! BOXTEXT in Baum MRKFIND
LET mrkfdown&=9 ! USERDEF in Baum MRKFIND
LET mrkfslid&=10 ! BOX in Baum MRKFIND
LET mrkfbut&=11 ! BUTTON in Baum MRKFIND
LET mrkfup&=12 ! USERDEF in Baum MRKFIND
LET mrkfnr&=13 ! BOXTEXT in Baum MRKFIND
LET mrkftimi&=14 ! BOXTEXT in Baum MRKFIND
LET mrkftimr&=15 ! BOXTEXT in Baum MRKFIND
LET mrkftxt&=16 ! BOXTEXT in Baum MRKFIND
LET mrkfbox3&=17 ! BOX in Baum MRKFIND
LET mrkfbuts&=18 ! USERDEF in Baum MRKFIND
LET mrkfbute&=19 ! USERDEF in Baum MRKFIND
LET mrkfbuti&=20 ! USERDEF in Baum MRKFIND
LET mrkfbutr&=21 ! USERDEF in Baum MRKFIND
'
LET disked&=13 ! Formular/Dialog
LET dskedbox&=0 ! BOX in Baum DISKED
LET dskedex&=1 ! BUTTON in Baum DISKED
LET dskedhlp&=2 ! BOXTEXT in Baum DISKED
LET dskedbx4&=4 ! BOX in Baum DISKED
LET dskedbx2&=5 ! BOX in Baum DISKED
LET dskedit&=6 ! FBOXTEXT in Baum DISKED
LET dskren&=8 ! USERDEF in Baum DISKED
LET dskopie&=9 ! USERDEF in Baum DISKED
LET dskedbx3&=10 ! BOX in Baum DISKED
LET dskedtxt&=11 ! BOXTEXT in Baum DISKED
LET dskill&=13 ! USERDEF in Baum DISKED
'
LET xfade&=14 ! Formular/Dialog
LET xfadebox&=0 ! BOX in Baum XFADE
LET xfadexit&=1 ! BUTTON in Baum XFADE
LET xfadehlp&=2 ! BOXTEXT in Baum XFADE
LET xfadebx2&=4 ! BOX in Baum XFADE
LET xfadeno&=5 ! USERDEF in Baum XFADE
LET xfadeup&=6 ! USERDEF in Baum XFADE
LET xfadcros&=7 ! USERDEF in Baum XFADE
LET xfadedwn&=8 ! USERDEF in Baum XFADE
LET xfadebx3&=9 ! BOX in Baum XFADE
'
LET clocks&=15 ! Formular/Dialog
LET clkbox&=0 ! BOX in Baum CLOCKS
LET clockex&=2 ! BUTTON in Baum CLOCKS
LET clockhlp&=3 ! BOXTEXT in Baum CLOCKS
LET clockok&=4 ! BUTTON in Baum CLOCKS
LET clkbox2&=6 ! BOX in Baum CLOCKS
LET clock1&=7 ! BOXTEXT in Baum CLOCKS
LET clock2&=8 ! BOXTEXT in Baum CLOCKS
LET clkdown&=9 ! USERDEF in Baum CLOCKS
LET clkslid&=10 ! BOX in Baum CLOCKS
LET clkbut&=11 ! BUTTON in Baum CLOCKS
LET clkup&=12 ! USERDEF in Baum CLOCKS
LET clock3&=13 ! BOXTEXT in Baum CLOCKS
LET clock4&=14 ! BOXTEXT in Baum CLOCKS
LET clock5&=15 ! BOXTEXT in Baum CLOCKS
LET clockm&=16 ! BOXTEXT in Baum CLOCKS
'
rsc2$="STARCOLR.RSC"
'
RETURN
'
> PROCEDURE rsc_for_all      ! Resource fÅr alle
REM Resource Datei Indizes fÅr STARALL
'
LET smp16&=0 ! Formular/Dialog
LET mainbox&=0 ! BOX in Baum SMP16
LET exit&=1 ! BUTTON in Baum SMP16
LET mainbox2&=2 ! BOX in Baum SMP16
LET emph&=4 ! BUTTON in Baum SMP16
LET audio&=5 ! BUTTON in Baum SMP16
LET use&=6 ! BUTTON in Baum SMP16
LET smp32&=8 ! BUTTON in Baum SMP16
LET smp44&=9 ! BUTTON in Baum SMP16
LET smp48&=10 ! BUTTON in Baum SMP16
LET noval&=12 ! BUTTON in Baum SMP16
LET confid&=13 ! BUTTON in Baum SMP16
LET parity&=14 ! BUTTON in Baum SMP16
LET biphase&=15 ! BUTTON in Baum SMP16
LET nolock&=16 ! BUTTON in Baum SMP16
LET prot&=18 ! BUTTON in Baum SMP16
LET smp64&=19 ! BUTTON in Baum SMP16
LET smp88&=20 ! BUTTON in Baum SMP16
LET smp96&=21 ! BUTTON in Baum SMP16
LET mainbox5&=22 ! BOX in Baum SMP16
LET ydsp&=23 ! STRING in Baum SMP16
LET dsp&=24 ! BOXTEXT in Baum SMP16
LET dspcirc&=25 ! BOXCHAR in Baum SMP16
LET mainbox6&=26 ! BOX in Baum SMP16
LET input&=28 ! BOXTEXT in Baum SMP16
LET incirc&=29 ! BOXCHAR in Baum SMP16
LET rate2&=31 ! BOXTEXT in Baum SMP16
LET ratecir2&=32 ! BOXCHAR in Baum SMP16
LET helporig&=33 ! BOXTEXT in Baum SMP16
LET mainbox4&=34 ! BOX in Baum SMP16
LET source&=36 ! BOXTEXT in Baum SMP16
LET srccirc&=37 ! BOXCHAR in Baum SMP16
LET protect&=39 ! BOXTEXT in Baum SMP16
LET protcirc&=40 ! BOXCHAR in Baum SMP16
LET mode&=42 ! BOXTEXT in Baum SMP16
LET modecirc&=43 ! BOXCHAR in Baum SMP16
LET emphasis&=45 ! BOXTEXT in Baum SMP16
LET emphcirc&=46 ! BOXCHAR in Baum SMP16
LET bridge&=47 ! BUTTON in Baum SMP16
LET digmark&=48 ! BUTTON in Baum SMP16
'
LET dspedit&=1 ! Formular/Dialog
LET dspbox&=0 ! BOX in Baum DSPEDIT
LET dspslot0&=12 ! BOXTEXT in Baum DSPEDIT
LET dspslot1&=13 ! BOXTEXT in Baum DSPEDIT
LET dspslot2&=14 ! BOXTEXT in Baum DSPEDIT
LET dspslot3&=15 ! BOXTEXT in Baum DSPEDIT
LET dspslot4&=16 ! BOXTEXT in Baum DSPEDIT
LET dspslot5&=17 ! BOXTEXT in Baum DSPEDIT
LET dspslot6&=18 ! BOXTEXT in Baum DSPEDIT
LET dspslot7&=19 ! BOXTEXT in Baum DSPEDIT
LET dspslot8&=20 ! BOXTEXT in Baum DSPEDIT
LET dspslot9&=21 ! BOXTEXT in Baum DSPEDIT
LET dspslup&=22 ! USERDEF in Baum DSPEDIT
LET dspslide&=23 ! BOX in Baum DSPEDIT
LET dspslbut&=24 ! BUTTON in Baum DSPEDIT
LET dspsldwn&=25 ! USERDEF in Baum DSPEDIT
LET dspload&=26 ! BUTTON in Baum DSPEDIT
LET dspsave&=27 ! BUTTON in Baum DSPEDIT
LET dspswtch&=28 ! STRING in Baum DSPEDIT
LET dspflip&=29 ! BOXTEXT in Baum DSPEDIT
LET dspfcirc&=30 ! BOXCHAR in Baum DSPEDIT
LET helpdsp&=31 ! BOXTEXT in Baum DSPEDIT
LET dspexit&=32 ! BUTTON in Baum DSPEDIT
'
LET loop&=2 ! Formular/Dialog
LET loopbox&=0 ! BOX in Baum LOOP
LET loopexit&=1 ! BUTTON in Baum LOOP
LET loopbox2&=2 ! BOX in Baum LOOP
LET forw&=3 ! BUTTON in Baum LOOP
LET cross&=4 ! BUTTON in Baum LOOP
LET backw&=5 ! BUTTON in Baum LOOP
LET helploop&=6 ! BOXTEXT in Baum LOOP
LET autoloop&=7 ! BUTTON in Baum LOOP
'
LET editfade&=3 ! Formular/Dialog
LET fadebox&=0 ! BOX in Baum EDITFADE
LET fadexit&=2 ! BUTTON in Baum EDITFADE
LET fadelin&=3 ! BUTTON in Baum EDITFADE
LET edfadbox&=4 ! BOX in Baum EDITFADE
LET infade&=5 ! BUTTON in Baum EDITFADE
LET ausfade&=6 ! BUTTON in Baum EDITFADE
LET helpfade&=7 ! BOXTEXT in Baum EDITFADE
LET fadexp&=8 ! BUTTON in Baum EDITFADE
LET fadesqrt&=9 ! BUTTON in Baum EDITFADE
LET fadeundo&=10 ! BUTTON in Baum EDITFADE
LET fadedel&=11 ! BUTTON in Baum EDITFADE
LET fdsquare&=12 ! BUTTON in Baum EDITFADE
LET fadelog&=13 ! BUTTON in Baum EDITFADE
LET fadload&=14 ! BUTTON in Baum EDITFADE
LET fadsave&=15 ! BUTTON in Baum EDITFADE
'
LET wmode&=4 ! Formular/Dialog
LET wmbox1&=0 ! BOX in Baum WMODE
LET wmhelp&=1 ! BOXTEXT in Baum WMODE
LET wmexit&=2 ! BUTTON in Baum WMODE
LET wmbox2&=4 ! BOX in Baum WMODE
LET mixcpu&=5 ! BUTTON in Baum WMODE
LET mixdma&=6 ! BUTTON in Baum WMODE
LET mixdsp&=7 ! BUTTON in Baum WMODE
LET mixsum24&=8 ! BUTTON in Baum WMODE
LET wmbox4&=10 ! BOX in Baum WMODE
LET mast16&=11 ! BUTTON in Baum WMODE
LET mast24&=12 ! BUTTON in Baum WMODE
LET wmbox3&=14 ! BOX in Baum WMODE
LET recm2&=15 ! BUTTON in Baum WMODE
LET recm4&=16 ! BUTTON in Baum WMODE
LET recm8&=17 ! BUTTON in Baum WMODE
LET recm16&=18 ! BUTTON in Baum WMODE
LET wmbox5&=20 ! BOX in Baum WMODE
LET ramlo&=21 ! BUTTON in Baum WMODE
LET ramhi&=22 ! BUTTON in Baum WMODE
LET syncpcg&=24 ! BUTTON in Baum WMODE
LET syncalc&=25 ! BUTTON in Baum WMODE
LET syncadat&=26 ! BUTTON in Baum WMODE
LET clkfalc&=27 ! BUTTON in Baum WMODE
LET syncmtc&=28 ! BUTTON in Baum WMODE
LET syncxmit&=29 ! BUTTON in Baum WMODE
LET frame&=31 ! BOXTEXT in Baum WMODE
LET frameirc&=32 ! BOXCHAR in Baum WMODE
LET syncsrte&=35 ! FBOXTEXT in Baum WMODE
LET wmodebx2&=37 ! BOX in Baum WMODE
LET synchz&=38 ! FBOXTEXT in Baum WMODE
LET wmodebx3&=40 ! BOX in Baum WMODE
LET smpteset&=41 ! FBOXTEXT in Baum WMODE
LET midictrl&=44 ! BUTTON in Baum WMODE
LET stream&=45 ! BUTTON in Baum WMODE
'
LET plugin&=5 ! Formular/Dialog
LET panbox&=0 ! BOX in Baum PLUGIN
LET panexit&=1 ! BUTTON in Baum PLUGIN
LET panhelp&=2 ! BOXTEXT in Baum PLUGIN
LET plglev1&=3 ! ICON in Baum PLUGIN
LET plgbox1&=4 ! USERDEF in Baum PLUGIN
LET plglev2&=5 ! ICON in Baum PLUGIN
LET plgbox2&=6 ! USERDEF in Baum PLUGIN
LET plglev3&=7 ! ICON in Baum PLUGIN
LET plgbox3&=8 ! USERDEF in Baum PLUGIN
LET plglev4&=9 ! ICON in Baum PLUGIN
LET plgbox4&=10 ! USERDEF in Baum PLUGIN
LET levtxt1&=11 ! BOXTEXT in Baum PLUGIN
LET levtxt5&=12 ! BOXTEXT in Baum PLUGIN
LET plglev5&=13 ! ICON in Baum PLUGIN
LET plgbox5&=14 ! USERDEF in Baum PLUGIN
LET levtxt3&=15 ! BOXTEXT in Baum PLUGIN
LET levcnt1&=16 ! BOXTEXT in Baum PLUGIN
LET levcnt2&=17 ! BOXTEXT in Baum PLUGIN
LET levcnt3&=18 ! BOXTEXT in Baum PLUGIN
LET levcnt4&=19 ! BOXTEXT in Baum PLUGIN
LET levcnt5&=20 ! BOXTEXT in Baum PLUGIN
LET plgtitel&=21 ! BOXTEXT in Baum PLUGIN
LET levart1&=22 ! BOXTEXT in Baum PLUGIN
LET levtxt4&=23 ! BOXTEXT in Baum PLUGIN
LET levtxt2&=24 ! BOXTEXT in Baum PLUGIN
LET levart2&=25 ! BOXTEXT in Baum PLUGIN
LET levart3&=26 ! BOXTEXT in Baum PLUGIN
LET levart4&=27 ! BOXTEXT in Baum PLUGIN
LET levart5&=28 ! BOXTEXT in Baum PLUGIN
LET plugct2&=29 ! BOXTEXT in Baum PLUGIN
LET plugct3&=30 ! BOXTEXT in Baum PLUGIN
LET plugct1&=31 ! BOXTEXT in Baum PLUGIN
LET pluglin&=32 ! BOX in Baum PLUGIN
LET plugnam&=33 ! TEXT in Baum PLUGIN
LET plglev6&=34 ! ICON in Baum PLUGIN
LET plgbox6&=35 ! USERDEF in Baum PLUGIN
LET plglev7&=36 ! ICON in Baum PLUGIN
LET plgbox7&=37 ! USERDEF in Baum PLUGIN
LET plglev8&=38 ! ICON in Baum PLUGIN
LET plgbox8&=39 ! USERDEF in Baum PLUGIN
LET plglev9&=40 ! ICON in Baum PLUGIN
LET plgbox9&=41 ! USERDEF in Baum PLUGIN
LET plglev10&=42 ! ICON in Baum PLUGIN
LET plgbox10&=43 ! USERDEF in Baum PLUGIN
LET plglev11&=44 ! ICON in Baum PLUGIN
LET plgbox11&=45 ! USERDEF in Baum PLUGIN
LET plglev12&=46 ! ICON in Baum PLUGIN
LET plgbox12&=47 ! USERDEF in Baum PLUGIN
LET plglev13&=48 ! ICON in Baum PLUGIN
LET plgbox13&=49 ! USERDEF in Baum PLUGIN
LET plglev14&=50 ! ICON in Baum PLUGIN
LET plgbox14&=51 ! USERDEF in Baum PLUGIN
LET plglev15&=52 ! ICON in Baum PLUGIN
LET plgbox15&=53 ! USERDEF in Baum PLUGIN
LET plglev16&=54 ! ICON in Baum PLUGIN
LET plgbox16&=55 ! USERDEF in Baum PLUGIN
LET plglev17&=56 ! ICON in Baum PLUGIN
LET plgbox17&=57 ! USERDEF in Baum PLUGIN
LET plglev18&=58 ! ICON in Baum PLUGIN
LET plgbox18&=59 ! USERDEF in Baum PLUGIN
LET plglev19&=60 ! ICON in Baum PLUGIN
LET plgbox19&=61 ! USERDEF in Baum PLUGIN
LET plglev20&=62 ! ICON in Baum PLUGIN
LET plgbox20&=63 ! USERDEF in Baum PLUGIN
LET plglev21&=64 ! ICON in Baum PLUGIN
LET plgbox21&=65 ! USERDEF in Baum PLUGIN
LET levtxt6&=66 ! BOXTEXT in Baum PLUGIN
LET levtxt7&=67 ! BOXTEXT in Baum PLUGIN
LET levtxt8&=68 ! BOXTEXT in Baum PLUGIN
LET levtxt9&=69 ! BOXTEXT in Baum PLUGIN
LET levtxt10&=70 ! BOXTEXT in Baum PLUGIN
LET levtxt11&=71 ! BOXTEXT in Baum PLUGIN
LET levtxt12&=72 ! BOXTEXT in Baum PLUGIN
LET levtxt13&=73 ! BOXTEXT in Baum PLUGIN
LET levtxt14&=74 ! BOXTEXT in Baum PLUGIN
LET levtxt15&=75 ! BOXTEXT in Baum PLUGIN
LET levtxt16&=76 ! BOXTEXT in Baum PLUGIN
LET levtxt17&=77 ! BOXTEXT in Baum PLUGIN
LET levtxt18&=78 ! BOXTEXT in Baum PLUGIN
LET levtxt19&=79 ! BOXTEXT in Baum PLUGIN
LET levtxt20&=80 ! BOXTEXT in Baum PLUGIN
LET levtxt21&=81 ! BOXTEXT in Baum PLUGIN
LET levart6&=82 ! BOXTEXT in Baum PLUGIN
LET levart7&=83 ! BOXTEXT in Baum PLUGIN
LET levart8&=84 ! BOXTEXT in Baum PLUGIN
LET levart9&=85 ! BOXTEXT in Baum PLUGIN
LET levart10&=86 ! BOXTEXT in Baum PLUGIN
LET levart11&=87 ! BOXTEXT in Baum PLUGIN
LET levart12&=88 ! BOXTEXT in Baum PLUGIN
LET levart13&=89 ! BOXTEXT in Baum PLUGIN
LET levart14&=90 ! BOXTEXT in Baum PLUGIN
LET levart15&=91 ! BOXTEXT in Baum PLUGIN
LET levart16&=92 ! BOXTEXT in Baum PLUGIN
LET levart17&=93 ! BOXTEXT in Baum PLUGIN
LET levart18&=94 ! BOXTEXT in Baum PLUGIN
LET levart19&=95 ! BOXTEXT in Baum PLUGIN
LET levart20&=96 ! BOXTEXT in Baum PLUGIN
LET levart21&=97 ! BOXTEXT in Baum PLUGIN
LET levcnt6&=98 ! BOXTEXT in Baum PLUGIN
LET levcnt7&=99 ! BOXTEXT in Baum PLUGIN
LET levcnt8&=100 ! BOXTEXT in Baum PLUGIN
LET levcnt9&=101 ! BOXTEXT in Baum PLUGIN
LET levcnt10&=102 ! BOXTEXT in Baum PLUGIN
LET levcnt11&=103 ! BOXTEXT in Baum PLUGIN
LET levcnt12&=104 ! BOXTEXT in Baum PLUGIN
LET levcnt13&=105 ! BOXTEXT in Baum PLUGIN
LET levcnt14&=106 ! BOXTEXT in Baum PLUGIN
LET levcnt15&=107 ! BOXTEXT in Baum PLUGIN
LET levcnt16&=108 ! BOXTEXT in Baum PLUGIN
LET levcnt17&=109 ! BOXTEXT in Baum PLUGIN
LET levcnt18&=110 ! BOXTEXT in Baum PLUGIN
LET levcnt19&=111 ! BOXTEXT in Baum PLUGIN
LET levcnt20&=112 ! BOXTEXT in Baum PLUGIN
LET levcnt21&=113 ! BOXTEXT in Baum PLUGIN
'
LET setup&=6 ! Formular/Dialog
LET setupbox&=0 ! BOX in Baum SETUP
LET sync&=2 ! BUTTON in Baum SETUP
LET fseldef&=4 ! BUTTON in Baum SETUP
LET fseltxt&=6 ! BOXTEXT in Baum SETUP
LET setform&=8 ! BOXTEXT in Baum SETUP
LET setfbut&=9 ! BOXCHAR in Baum SETUP
LET nfsbut&=10 ! BUTTON in Baum SETUP
LET seclen&=14 ! BOXTEXT in Baum SETUP
LET secl&=15 ! BUTTON in Baum SETUP
LET secr&=16 ! BUTTON in Baum SETUP
LET maxhd&=17 ! TEXT in Baum SETUP
LET setblmax&=18 ! BUTTON in Baum SETUP
LET viewcalc&=20 ! BUTTON in Baum SETUP
LET mallmax&=23 ! BUTTON in Baum SETUP
LET setupbx2&=24 ! BOX in Baum SETUP
LET lenmall&=25 ! FBOXTEXT in Baum SETUP
LET sethelp&=27 ! BOXTEXT in Baum SETUP
LET recm&=30 ! BOXTEXT in Baum SETUP
LET recl&=31 ! BUTTON in Baum SETUP
LET recr&=32 ! BUTTON in Baum SETUP
LET rmaxim&=33 ! BUTTON in Baum SETUP
LET tresdb&=36 ! BOXTEXT in Baum SETUP
LET tresl&=37 ! BUTTON in Baum SETUP
LET tresr&=38 ! BUTTON in Baum SETUP
LET setexit&=39 ! BUTTON in Baum SETUP
LET setsave&=40 ! BUTTON in Baum SETUP
LET setload&=41 ! BUTTON in Baum SETUP
LET setok&=42 ! BUTTON in Baum SETUP
LET dreide&=43 ! BUTTON in Baum SETUP
LET flip&=44 ! BUTTON in Baum SETUP
LET timeset&=45 ! BUTTON in Baum SETUP
LET setshow&=46 ! BUTTON in Baum SETUP
LET setupbx3&=48 ! BOX in Baum SETUP
LET vertline&=49 ! BUTTON in Baum SETUP
LET linkdot&=50 ! BUTTON in Baum SETUP
LET spacefil&=51 ! BUTTON in Baum SETUP
LET zoomy&=52 ! BUTTON in Baum SETUP
LET grid&=53 ! BUTTON in Baum SETUP
LET posy&=54 ! BUTTON in Baum SETUP
LET zerosnap&=55 ! BUTTON in Baum SETUP
LET frec&=56 ! BUTTON in Baum SETUP
LET menuset&=57 ! BUTTON in Baum SETUP
LET freeze&=59 ! BUTTON in Baum SETUP
LET viewset&=60 ! BUTTON in Baum SETUP
LET emulset&=61 ! BUTTON in Baum SETUP
'
LET arrmname&=7 ! Formular/Dialog
LET arrmnbox&=0 ! BOX in Baum ARRMNAME
LET arrmnbx2&=1 ! BOX in Baum ARRMNAME
LET memname&=2 ! FBOXTEXT in Baum ARRMNAME
LET amexit&=4 ! BUTTON in Baum ARRMNAME
LET amhelp&=5 ! BOXTEXT in Baum ARRMNAME
LET amok&=6 ! BUTTON in Baum ARRMNAME
'
LET moving&=8 ! Formular/Dialog
LET movngbox&=0 ! BOX in Baum MOVING
LET movhlp&=1 ! BOXTEXT in Baum MOVING
LET mvcutcpy&=3 ! BUTTON in Baum MOVING
LET mvcutins&=4 ! BUTTON in Baum MOVING
LET mvclrins&=5 ! BUTTON in Baum MOVING
LET mvclrcpy&=6 ! BUTTON in Baum MOVING
LET movexit&=7 ! BUTTON in Baum MOVING
'
LET timeed&=9 ! Formular/Dialog
LET timebox&=0 ! BOX in Baum TIMEED
LET timebox2&=1 ! BOX in Baum TIMEED
LET tedtxt&=2 ! FBOXTEXT in Baum TIMEED
LET tedexit&=4 ! BUTTON in Baum TIMEED
LET tedhelp&=5 ! BOXTEXT in Baum TIMEED
LET tedok&=6 ! BUTTON in Baum TIMEED
LET tedmin&=9 ! BUTTON in Baum TIMEED
LET tedmax&=10 ! BUTTON in Baum TIMEED
'
LET inftxt&=10 ! Formular/Dialog
LET infbox&=0 ! BOX in Baum INFTXT
LET infbox2&=1 ! BOX in Baum INFTXT
LET inftitel&=2 ! BUTTON in Baum INFTXT
'
LET smpinf&=11 ! Formular/Dialog
LET sinfbox&=0 ! BOX in Baum SMPINF
LET sinfhelp&=1 ! BOXTEXT in Baum SMPINF
LET sinfexit&=2 ! BUTTON in Baum SMPINF
LET sinfok&=3 ! BUTTON in Baum SMPINF
LET sinfname&=7 ! BOXTEXT in Baum SMPINF
LET sinflen&=9 ! BOXTEXT in Baum SMPINF
LET sinfrate&=11 ! BOXTEXT in Baum SMPINF
LET sinfsus2&=16 ! BOXTEXT in Baum SMPINF
LET sinfrel2&=17 ! BOXTEXT in Baum SMPINF
LET sinfl5&=19 ! BOXTEXT in Baum SMPINF
LET sinfl6&=20 ! BOXTEXT in Baum SMPINF
LET sinfl7&=23 ! BOXTEXT in Baum SMPINF
LET sinfl8&=24 ! BOXTEXT in Baum SMPINF
LET sinfl1&=25 ! BOXTEXT in Baum SMPINF
LET sinfl2&=27 ! BOXTEXT in Baum SMPINF
LET sinfl3&=29 ! BOXTEXT in Baum SMPINF
LET sinfl4&=31 ! BOXTEXT in Baum SMPINF
LET sinfdate&=33 ! BOXTEXT in Baum SMPINF
LET sinfrel1&=34 ! BOXTEXT in Baum SMPINF
LET sinfsus1&=35 ! BOXTEXT in Baum SMPINF
LET sinfbox2&=36 ! BOX in Baum SMPINF
LET sinfcomm&=37 ! FBOXTEXT in Baum SMPINF
LET sinfsrc&=38 ! FBOXTEXT in Baum SMPINF
LET sinfl9&=41 ! BOXTEXT in Baum SMPINF
LET sinfl10&=42 ! BOXTEXT in Baum SMPINF
LET sinfl11&=43 ! BOXTEXT in Baum SMPINF
LET sinfl12&=44 ! BOXTEXT in Baum SMPINF
'
LET meldung&=12 ! Formular/Dialog
LET meldbox&=0 ! BOX in Baum MELDUNG
LET meldtxt&=1 ! BOXTEXT in Baum MELDUNG
'
LET trknamin&=13 ! Formular/Dialog
LET trktxbox&=0 ! BOX in Baum TRKNAMIN
LET trktxbo2&=1 ! BOX in Baum TRKNAMIN
LET trktxtin&=2 ! FBOXTEXT in Baum TRKNAMIN
LET trktxex&=4 ! BUTTON in Baum TRKNAMIN
LET trktxhlp&=5 ! BOXTEXT in Baum TRKNAMIN
LET trktxok&=6 ! BUTTON in Baum TRKNAMIN
'
LET trkcomin&=14 ! Formular/Dialog
LET trkcbox&=0 ! BOX in Baum TRKCOMIN
LET trkcbox2&=1 ! BOX in Baum TRKCOMIN
LET trkctxin&=2 ! FBOXTEXT in Baum TRKCOMIN
LET trkcexit&=4 ! BUTTON in Baum TRKCOMIN
LET trkchlp&=5 ! BOXTEXT in Baum TRKCOMIN
LET trkcok&=6 ! BUTTON in Baum TRKCOMIN
'
LET mrktxtin&=15 ! Formular/Dialog
LET mtexbox&=0 ! BOX in Baum MRKTXTIN
LET mtexbox2&=1 ! BOX in Baum MRKTXTIN
LET mtex&=2 ! FBOXTEXT in Baum MRKTXTIN
LET mtexex&=4 ! BUTTON in Baum MRKTXTIN
LET mtexhelp&=5 ! BOXTEXT in Baum MRKTXTIN
LET mtexok&=6 ! BUTTON in Baum MRKTXTIN
'
LET marknumb&=16 ! Formular/Dialog
LET mnumbox&=0 ! BOX in Baum MARKNUMB
LET mnumbox2&=1 ! BOX in Baum MARKNUMB
LET mnumtxt&=2 ! FBOXTEXT in Baum MARKNUMB
LET mnumexit&=4 ! BUTTON in Baum MARKNUMB
LET mnumhelp&=5 ! BOXTEXT in Baum MARKNUMB
LET mnumok&=6 ! BUTTON in Baum MARKNUMB
'
LET plgconfg&=17 ! Formular/Dialog
LET pcfgbox&=0 ! BOX in Baum PLGCONFG
LET pcfgexit&=1 ! BUTTON in Baum PLGCONFG
LET pcfghelp&=2 ! BOXTEXT in Baum PLGCONFG
LET plgrec1&=3 ! BOXTEXT in Baum PLGCONFG
LET pcfgtex1&=4 ! BOXTEXT in Baum PLGCONFG
LET plgrec2&=5 ! BOXTEXT in Baum PLGCONFG
LET plgrec3&=6 ! BOXTEXT in Baum PLGCONFG
LET plgrec4&=7 ! BOXTEXT in Baum PLGCONFG
LET plgplay1&=8 ! BOXTEXT in Baum PLGCONFG
LET plgplay2&=9 ! BOXTEXT in Baum PLGCONFG
LET plgplay3&=10 ! BOXTEXT in Baum PLGCONFG
LET plgplay4&=11 ! BOXTEXT in Baum PLGCONFG
LET pcfgtex2&=12 ! BOXTEXT in Baum PLGCONFG
LET pcfgtex3&=13 ! BOXTEXT in Baum PLGCONFG
LET pcfgld&=14 ! BUTTON in Baum PLGCONFG
LET pcfgsve&=15 ! BUTTON in Baum PLGCONFG
LET pcfgclr&=16 ! BUTTON in Baum PLGCONFG
LET plgcfg1&=18 ! BOXTEXT in Baum PLGCONFG
LET plgcfg2&=19 ! BOXTEXT in Baum PLGCONFG
LET plgcfg3&=20 ! BOXTEXT in Baum PLGCONFG
LET plgcfg4&=21 ! BOXTEXT in Baum PLGCONFG
LET plgcfg5&=22 ! BOXTEXT in Baum PLGCONFG
LET plgcfg6&=23 ! BOXTEXT in Baum PLGCONFG
LET plgcfg7&=24 ! BOXTEXT in Baum PLGCONFG
LET plgcfg8&=25 ! BOXTEXT in Baum PLGCONFG
LET plgcfg9&=26 ! BOXTEXT in Baum PLGCONFG
LET plgcfg10&=27 ! BOXTEXT in Baum PLGCONFG
LET plgrec5&=28 ! BOXTEXT in Baum PLGCONFG
LET plgplay5&=29 ! BOXTEXT in Baum PLGCONFG
LET plgrec&=30 ! BUTTON in Baum PLGCONFG
LET plgplay&=31 ! BUTTON in Baum PLGCONFG
LET noplugs1&=33 ! TEXT in Baum PLGCONFG
LET noplugs2&=34 ! TEXT in Baum PLGCONFG
'
LET arrmake&=18 ! Formular/Dialog
LET makebox&=0 ! BOX in Baum ARRMAKE
LET maketxt&=4 ! BOXTEXT in Baum ARRMAKE
LET makefsel&=5 ! BUTTON in Baum ARRMAKE
LET makerate&=7 ! BOXTEXT in Baum ARRMAKE
LET makehelp&=10 ! BOXTEXT in Baum ARRMAKE
LET makexit&=11 ! BUTTON in Baum ARRMAKE
LET makeok&=12 ! BUTTON in Baum ARRMAKE
'
LET partsel&=19 ! Formular/Dialog
LET partbox&=0 ! BOX in Baum PARTSEL
LET partc&=3 ! BUTTON in Baum PARTSEL
LET partd&=4 ! BUTTON in Baum PARTSEL
LET parte&=5 ! BUTTON in Baum PARTSEL
LET partf&=6 ! BUTTON in Baum PARTSEL
LET partg&=7 ! BUTTON in Baum PARTSEL
LET parth&=8 ! BUTTON in Baum PARTSEL
LET parti&=9 ! BUTTON in Baum PARTSEL
LET partj&=10 ! BUTTON in Baum PARTSEL
LET partk&=11 ! BUTTON in Baum PARTSEL
LET partl&=12 ! BUTTON in Baum PARTSEL
LET partm&=13 ! BUTTON in Baum PARTSEL
LET partn&=14 ! BUTTON in Baum PARTSEL
LET parto&=15 ! BUTTON in Baum PARTSEL
LET partp&=16 ! BUTTON in Baum PARTSEL
LET partq&=17 ! BUTTON in Baum PARTSEL
LET partr&=18 ! BUTTON in Baum PARTSEL
LET parts&=19 ! BUTTON in Baum PARTSEL
LET partt&=20 ! BUTTON in Baum PARTSEL
LET partu&=21 ! BUTTON in Baum PARTSEL
LET partv&=22 ! BUTTON in Baum PARTSEL
LET partw&=23 ! BUTTON in Baum PARTSEL
LET partx&=24 ! BUTTON in Baum PARTSEL
LET party&=25 ! BUTTON in Baum PARTSEL
LET partz&=26 ! BUTTON in Baum PARTSEL
LET part1&=27 ! BUTTON in Baum PARTSEL
LET part2&=28 ! BUTTON in Baum PARTSEL
LET part3&=29 ! BUTTON in Baum PARTSEL
LET part4&=30 ! BUTTON in Baum PARTSEL
LET part5&=31 ! BUTTON in Baum PARTSEL
LET part6&=32 ! BUTTON in Baum PARTSEL
LET partfsc&=33 ! BOXTEXT in Baum PARTSEL
LET partfsd&=34 ! BOXTEXT in Baum PARTSEL
LET partfse&=35 ! BOXTEXT in Baum PARTSEL
LET partfsf&=36 ! BOXTEXT in Baum PARTSEL
LET partfsg&=37 ! BOXTEXT in Baum PARTSEL
LET partfsh&=38 ! BOXTEXT in Baum PARTSEL
LET partfsi&=39 ! BOXTEXT in Baum PARTSEL
LET partfsj&=40 ! BOXTEXT in Baum PARTSEL
LET partfsk&=41 ! BOXTEXT in Baum PARTSEL
LET partfsl&=42 ! BOXTEXT in Baum PARTSEL
LET partfsm&=43 ! BOXTEXT in Baum PARTSEL
LET partfsn&=44 ! BOXTEXT in Baum PARTSEL
LET partfso&=45 ! BOXTEXT in Baum PARTSEL
LET partfsp&=46 ! BOXTEXT in Baum PARTSEL
LET partfsq&=47 ! BOXTEXT in Baum PARTSEL
LET partfsr&=48 ! BOXTEXT in Baum PARTSEL
LET partfss&=49 ! BOXTEXT in Baum PARTSEL
LET partfst&=50 ! BOXTEXT in Baum PARTSEL
LET partfsu&=51 ! BOXTEXT in Baum PARTSEL
LET partfsv&=52 ! BOXTEXT in Baum PARTSEL
LET partfsw&=53 ! BOXTEXT in Baum PARTSEL
LET partfsx&=54 ! BOXTEXT in Baum PARTSEL
LET partfsy&=55 ! BOXTEXT in Baum PARTSEL
LET partfsz&=56 ! BOXTEXT in Baum PARTSEL
LET partfs1&=57 ! BOXTEXT in Baum PARTSEL
LET partfs2&=58 ! BOXTEXT in Baum PARTSEL
LET partfs3&=59 ! BOXTEXT in Baum PARTSEL
LET partfs4&=60 ! BOXTEXT in Baum PARTSEL
LET partfs5&=61 ! BOXTEXT in Baum PARTSEL
LET partfs6&=62 ! BOXTEXT in Baum PARTSEL
LET partact&=63 ! BUTTON in Baum PARTSEL
LET parthelp&=64 ! BOXTEXT in Baum PARTSEL
LET partld&=65 ! BUTTON in Baum PARTSEL
LET partsav&=66 ! BUTTON in Baum PARTSEL
LET partexit&=67 ! BUTTON in Baum PARTSEL
LET partok&=68 ! BUTTON in Baum PARTSEL
'
LET dsmove&=20 ! Formular/Dialog
LET dsmovbox&=0 ! BOX in Baum DSMOVE
LET dsmovhlp&=1 ! BOXTEXT in Baum DSMOVE
LET dsmovsw&=2 ! BUTTON in Baum DSMOVE
LET dsil1&=5 ! BUTTON in Baum DSMOVE
LET dsil2&=6 ! BUTTON in Baum DSMOVE
LET dsil3&=7 ! BUTTON in Baum DSMOVE
LET dsil4&=8 ! BUTTON in Baum DSMOVE
LET dsil5&=9 ! BUTTON in Baum DSMOVE
LET dsil6&=10 ! BUTTON in Baum DSMOVE
LET dsil7&=11 ! BUTTON in Baum DSMOVE
LET dsil8&=12 ! BUTTON in Baum DSMOVE
LET dsil9&=13 ! BUTTON in Baum DSMOVE
LET dsil10&=14 ! BUTTON in Baum DSMOVE
LET dsil11&=15 ! BUTTON in Baum DSMOVE
LET dsil12&=16 ! BUTTON in Baum DSMOVE
LET dsil13&=17 ! BUTTON in Baum DSMOVE
LET dsil14&=18 ! BUTTON in Baum DSMOVE
LET dsil15&=19 ! BUTTON in Baum DSMOVE
LET dsil16&=20 ! BUTTON in Baum DSMOVE
LET dsir1&=21 ! BUTTON in Baum DSMOVE
LET dsir2&=22 ! BUTTON in Baum DSMOVE
LET dsir3&=23 ! BUTTON in Baum DSMOVE
LET dsir4&=24 ! BUTTON in Baum DSMOVE
LET dsir5&=25 ! BUTTON in Baum DSMOVE
LET dsir6&=26 ! BUTTON in Baum DSMOVE
LET dsir7&=27 ! BUTTON in Baum DSMOVE
LET dsir8&=28 ! BUTTON in Baum DSMOVE
LET dsir9&=29 ! BUTTON in Baum DSMOVE
LET dsir10&=30 ! BUTTON in Baum DSMOVE
LET dsir11&=31 ! BUTTON in Baum DSMOVE
LET dsir12&=32 ! BUTTON in Baum DSMOVE
LET dsir13&=33 ! BUTTON in Baum DSMOVE
LET dsir14&=34 ! BUTTON in Baum DSMOVE
LET dsir15&=35 ! BUTTON in Baum DSMOVE
LET dsir16&=36 ! BUTTON in Baum DSMOVE
LET dsmovex&=37 ! BUTTON in Baum DSMOVE
LET dsmovtxt&=39 ! TEXT in Baum DSMOVE
LET dsmovl&=40 ! BUTTON in Baum DSMOVE
LET dsmovs&=41 ! BUTTON in Baum DSMOVE
LET dsmovclr&=42 ! BUTTON in Baum DSMOVE
'
LET popups&=21 ! Formular/Dialog
LET smppopup&=1 ! BOX in Baum POPUPS
LET rate32&=2 ! STRING in Baum POPUPS
LET rate44&=3 ! STRING in Baum POPUPS
LET rate48&=4 ! STRING in Baum POPUPS
LET rate64&=5 ! STRING in Baum POPUPS
LET rate88&=6 ! STRING in Baum POPUPS
LET rate96&=7 ! STRING in Baum POPUPS
LET rate8&=8 ! STRING in Baum POPUPS
LET rate11&=9 ! STRING in Baum POPUPS
LET rate12&=10 ! STRING in Baum POPUPS
LET rate16&=11 ! STRING in Baum POPUPS
LET rate17&=12 ! STRING in Baum POPUPS
LET rate22&=13 ! STRING in Baum POPUPS
LET rate24&=14 ! STRING in Baum POPUPS
LET rate33&=15 ! STRING in Baum POPUPS
LET ratexth2&=16 ! STRING in Baum POPUPS
LET ratextl2&=17 ! STRING in Baum POPUPS
LET ratexth1&=18 ! STRING in Baum POPUPS
LET ratextl1&=19 ! STRING in Baum POPUPS
LET ratediv&=20 ! STRING in Baum POPUPS
LET dsppopup&=21 ! BOX in Baum POPUPS
LET dspoff&=22 ! STRING in Baum POPUPS
LET dspin&=23 ! STRING in Baum POPUPS
LET dspout&=24 ! STRING in Baum POPUPS
LET smppop2&=25 ! BOX in Baum POPUPS
LET ad32&=26 ! STRING in Baum POPUPS
LET ad44&=27 ! STRING in Baum POPUPS
LET ad48&=28 ! STRING in Baum POPUPS
LET ad64&=29 ! STRING in Baum POPUPS
LET ad88&=30 ! STRING in Baum POPUPS
LET ad96&=31 ! STRING in Baum POPUPS
LET ad8&=32 ! STRING in Baum POPUPS
LET ad11&=33 ! STRING in Baum POPUPS
LET ad12&=34 ! STRING in Baum POPUPS
LET ad16&=35 ! STRING in Baum POPUPS
LET ad17&=36 ! STRING in Baum POPUPS
LET ad22&=37 ! STRING in Baum POPUPS
LET ad24&=38 ! STRING in Baum POPUPS
LET ad33&=39 ! STRING in Baum POPUPS
LET adexth2&=40 ! STRING in Baum POPUPS
LET adextl2&=41 ! STRING in Baum POPUPS
LET adexth1&=42 ! STRING in Baum POPUPS
LET adextl1&=43 ! STRING in Baum POPUPS
LET addiv&=44 ! STRING in Baum POPUPS
LET inpop&=45 ! BOX in Baum POPUPS
LET analog&=46 ! STRING in Baum POPUPS
LET digital&=47 ! STRING in Baum POPUPS
LET srcpop&=48 ! BOX in Baum POPUPS
LET opto&=49 ! STRING in Baum POPUPS
LET coax&=50 ! STRING in Baum POPUPS
LET aesebu&=51 ! STRING in Baum POPUPS
LET popmark&=52 ! BOX in Baum POPUPS
LET smpmark&=53 ! STRING in Baum POPUPS
LET smpzoom&=54 ! STRING in Baum POPUPS
LET smpscrol&=55 ! STRING in Baum POPUPS
LET kopy&=56 ! STRING in Baum POPUPS
LET move&=57 ! STRING in Baum POPUPS
LET insert&=58 ! STRING in Baum POPUPS
LET merge&=59 ! STRING in Baum POPUPS
LET fade&=60 ! STRING in Baum POPUPS
LET popmake&=61 ! BOX in Baum POPUPS
LET make32&=62 ! STRING in Baum POPUPS
LET make44&=63 ! STRING in Baum POPUPS
LET make48&=64 ! STRING in Baum POPUPS
LET make64&=65 ! STRING in Baum POPUPS
LET make88&=66 ! STRING in Baum POPUPS
LET make96&=67 ! STRING in Baum POPUPS
LET popform&=68 ! BOX in Baum POPUPS
LET sets16&=69 ! STRING in Baum POPUPS
LET setwav&=70 ! STRING in Baum POPUPS
LET setavr&=71 ! STRING in Baum POPUPS
LET setaif&=72 ! STRING in Baum POPUPS
LET setsnd&=73 ! STRING in Baum POPUPS
LET setsd&=74 ! STRING in Baum POPUPS
LET setau&=75 ! STRING in Baum POPUPS
LET setsmp&=76 ! STRING in Baum POPUPS
LET setall&=77 ! STRING in Baum POPUPS
LET popscms&=78 ! BOX in Baum POPUPS
LET scmsno&=79 ! STRING in Baum POPUPS
LET scmsone&=80 ! STRING in Baum POPUPS
LET scmsfree&=81 ! STRING in Baum POPUPS
LET modepop&=82 ! BOX in Baum POPUPS
LET consumer&=83 ! STRING in Baum POPUPS
LET profess&=84 ! STRING in Baum POPUPS
LET emphpop&=85 ! BOX in Baum POPUPS
LET emphoff&=86 ! STRING in Baum POPUPS
LET emphon&=87 ! STRING in Baum POPUPS
LET framepop&=88 ! BOX in Baum POPUPS
LET frame24&=89 ! STRING in Baum POPUPS
LET frame25&=90 ! STRING in Baum POPUPS
LET frame30&=91 ! STRING in Baum POPUPS
LET frame75&=92 ! STRING in Baum POPUPS
LET frame100&=93 ! STRING in Baum POPUPS
LET bitpop&=94 ! BOX in Baum POPUPS
LET bitp16&=95 ! STRING in Baum POPUPS
LET bitp24&=96 ! STRING in Baum POPUPS
LET monpop&=97 ! BOX in Baum POPUPS
LET mon1&=98 ! STRING in Baum POPUPS
LET mon2&=99 ! STRING in Baum POPUPS
LET mon3&=100 ! STRING in Baum POPUPS
LET mon4&=101 ! STRING in Baum POPUPS
LET monpop2&=102 ! BOX in Baum POPUPS
LET monb1&=103 ! STRING in Baum POPUPS
LET monb2&=104 ! STRING in Baum POPUPS
LET monb3&=105 ! STRING in Baum POPUPS
LET monb4&=106 ! STRING in Baum POPUPS
LET mixopop&=107 ! BOX in Baum POPUPS
LET mixo1&=108 ! STRING in Baum POPUPS
LET mixo2&=109 ! STRING in Baum POPUPS
LET mixo3&=110 ! STRING in Baum POPUPS
LET mixo4&=111 ! STRING in Baum POPUPS
LET mixo5&=112 ! STRING in Baum POPUPS
LET mixo6&=113 ! STRING in Baum POPUPS
LET mixo7&=114 ! STRING in Baum POPUPS
LET mixo8&=115 ! STRING in Baum POPUPS
LET mixo9&=116 ! STRING in Baum POPUPS
LET mixo10&=117 ! STRING in Baum POPUPS
LET mixo11&=118 ! STRING in Baum POPUPS
LET mixo12&=119 ! STRING in Baum POPUPS
LET mixo13&=120 ! STRING in Baum POPUPS
LET mixo14&=121 ! STRING in Baum POPUPS
LET mixo15&=122 ! STRING in Baum POPUPS
LET mixo16&=123 ! STRING in Baum POPUPS
LET mixmpop&=124 ! BOX in Baum POPUPS
LET mixm1&=125 ! STRING in Baum POPUPS
LET mixm2&=126 ! STRING in Baum POPUPS
LET mixm3&=127 ! STRING in Baum POPUPS
LET mixm4&=128 ! STRING in Baum POPUPS
LET mixm5&=129 ! STRING in Baum POPUPS
LET mixm6&=130 ! STRING in Baum POPUPS
LET mixm7&=131 ! STRING in Baum POPUPS
LET mixm8&=132 ! STRING in Baum POPUPS
'
LET dropdown&=22 ! Menuebaum
LET ddstar&=3 ! TITLE in Baum DROPDOWN
LET dddat&=4 ! TITLE in Baum DROPDOWN
LET ddwind&=5 ! TITLE in Baum DROPDOWN
LET ddfunc&=6 ! TITLE in Baum DROPDOWN
LET ddplugin&=7 ! TITLE in Baum DROPDOWN
LET ddinfo&=10 ! STRING in Baum DROPDOWN
LET ddbank&=19 ! STRING in Baum DROPDOWN
LET dddisk&=20 ! STRING in Baum DROPDOWN
LET ddpart&=21 ! STRING in Baum DROPDOWN
LET ddgrenz&=22 ! STRING in Baum DROPDOWN
LET ddload&=23 ! STRING in Baum DROPDOWN
LET ddsave&=24 ! STRING in Baum DROPDOWN
LET ddexit&=25 ! STRING in Baum DROPDOWN
LET ddsmp16&=27 ! STRING in Baum DROPDOWN
LET ddblock&=28 ! STRING in Baum DROPDOWN
LET ddpeak&=29 ! STRING in Baum DROPDOWN
LET ddarr&=30 ! STRING in Baum DROPDOWN
LET ddtrakk&=31 ! STRING in Baum DROPDOWN
LET ddloop&=32 ! STRING in Baum DROPDOWN
LET dddsp&=33 ! STRING in Baum DROPDOWN
LET ddworkm&=34 ! STRING in Baum DROPDOWN
LET ddcue&=35 ! STRING in Baum DROPDOWN
LET ddsetup&=37 ! STRING in Baum DROPDOWN
LET ddfader&=38 ! STRING in Baum DROPDOWN
LET ddmidi&=39 ! STRING in Baum DROPDOWN
LET ddmon&=41 ! STRING in Baum DROPDOWN
LET ddauto&=42 ! STRING in Baum DROPDOWN
LET ddmanu&=43 ! STRING in Baum DROPDOWN
LET ddplay&=44 ! STRING in Baum DROPDOWN
LET ddpleft&=46 ! STRING in Baum DROPDOWN
LET ddpright&=47 ! STRING in Baum DROPDOWN
LET ddpboth&=48 ! STRING in Baum DROPDOWN
LET ddhost&=50 ! STRING in Baum DROPDOWN
LET ddmix&=51 ! STRING in Baum DROPDOWN
LET ddplug1&=53 ! STRING in Baum DROPDOWN
LET ddplug2&=54 ! STRING in Baum DROPDOWN
LET ddplug3&=55 ! STRING in Baum DROPDOWN
LET ddplug4&=56 ! STRING in Baum DROPDOWN
LET ddplug5&=57 ! STRING in Baum DROPDOWN
LET ddplug6&=58 ! STRING in Baum DROPDOWN
LET ddplug7&=59 ! STRING in Baum DROPDOWN
LET ddplug8&=60 ! STRING in Baum DROPDOWN
LET ddplug9&=61 ! STRING in Baum DROPDOWN
LET ddplug10&=62 ! STRING in Baum DROPDOWN
LET ddconv&=64 ! STRING in Baum DROPDOWN
LET ddmodld&=65 ! STRING in Baum DROPDOWN
LET ddmodkil&=66 ! STRING in Baum DROPDOWN
LET ddplgcfg&=68 ! STRING in Baum DROPDOWN
'
LET alertbox&=23 ! Formular/Dialog
LET alertcol&=0 ! BOX in Baum ALERTBOX
'
rsc3$="STARALL.RSC"
'
RETURN
'
> PROCEDURE calc_window(i)
LOCAL cwb,cwh
IF prgversion>=1.2 THEN                              ! Screen-Restauration
pkreinit=FALSE
IF nosetload=FALSE THEN          ! Versionskontrolle
IF freez=TRUE OR (fcall=TRUE AND (i=smpedit& OR i=trakker& OR i=peak&)) THEN
rscx&(i)=rx(i)
rscy&(i)=ry(i)
ENDIF
IF prgversion<1.2 THEN          ! Versionskontrolle
cwb=OB_W(rsc_adr%(i),0)
cwh=OB_H(rsc_adr%(i),0)
ENDIF
IF prgversion>=1.2 THEN          ! Versionskontrolle
IF i=smpedit& OR i=trakker& OR i=peak& THEN
IF freez=TRUE OR fcall=TRUE THEN
rscw&(i)=rb(i)
rsch&(i)=rh(i)
ENDIF
ENDIF
cwb=rscw&(i)
cwh=rsch&(i)
IF i=smpedit& THEN
xold=rscx&(i)
yold=rscy&(i)+19
bold=rscw&(i)
hold=rsch&(i)-19
xneu=rscx&(i)
yneu=rscy&(i)+19
bneu=rscw&(i)
hneu=rsch&(i)-19
ENDIF
IF i=peak& THEN
xold2=rscx&(i)
yold2=rscy&(i)+19
bold2=rscw&(i)
hold2=rsch&(i)-19
xneu2=rscx&(i)
yneu2=rscy&(i)+19
bneu2=rscw&(i)
hneu2=rsch&(i)-19
nr=i
notopen=TRUE
@calc_peaksize
nr=smpedit&
notopen=FALSE
ENDIF
IF i=trakker& THEN
xold3=rscx&(i)
yold3=rscy&(i)+19
bold3=rscw&(i)
hold3=rsch&(i)-19
xneu3=rscx&(i)
yneu3=rscy&(i)+19
bneu3=rscw&(i)
hneu3=rsch&(i)-19
nr=i
notopen=TRUE
@calc_traksize
nr=smpedit&
notopen=FALSE
ENDIF
ENDIF
ELSE
cwb=OB_W(rsc_adr%(i),0)
cwh=OB_H(rsc_adr%(i),0)
ENDIF
IF (rscx&(i)+cwb+3)>xwidth THEN
rscx&(i)=xwidth-cwb-3
IF i=smpedit& THEN
xold=rscx&(i)
xneu=rscx&(i)
ENDIF
IF i=peak& THEN
xold2=rscx&(i)
xneu2=rscx&(i)
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
xold3=rscx&(i)
xneu3=rscx&(i)
pkreinit=TRUE
ENDIF
ENDIF
IF (rscy&(i)+cwh+3)>ywidth THEN
rscy&(i)=ywidth-cwh-3
IF i=smpedit& THEN
yold=rscy&(i)+19
yneu=rscy&(i)+19
ENDIF
IF i=peak& THEN
yold2=rscy&(i)+19
yneu2=rscy&(i)+19
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
yold3=rscy&(i)+19
yneu3=rscy&(i)+19
pkreinit=TRUE
ENDIF
ENDIF
IF rscx&(i)<0 THEN
rscx&(i)=0
IF i=smpedit& THEN
xold=rscx&(i)
xneu=rscx&(i)
ENDIF
IF i=peak& THEN
xold2=rscx&(i)
xneu2=rscx&(i)
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
xold3=rscx&(i)
xneu3=rscx&(i)
pkreinit=TRUE
ENDIF
ENDIF
IF rscy&(i)<0 THEN
rscy&(i)=0
IF i=smpedit& THEN
yold=rscy&(i)+19
yneu=rscy&(i)+19
ENDIF
IF i=peak& THEN
yold2=rscy&(i)+19
yneu2=rscy&(i)+19
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
yold3=rscy&(i)+19
yneu3=rscy&(i)+19
pkreinit=TRUE
ENDIF
ENDIF
IF (rscx&(i)+rscw&(i))>xwidth THEN
IF freez=TRUE OR (fcall=TRUE AND (i=smpedit& OR i=trakker& OR i=peak&)) THEN
rscw&(i)=xwidth-rscx&(i)
ENDIF
IF i=smpedit& THEN
bold=rscw&(i)
bneu=rscw&(i)
ENDIF
IF i=peak& THEN
bold2=rscw&(i)
bneu2=rscw&(i)
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
bold3=rscw&(i)
bneu3=rscw&(i)
pkreinit=TRUE
ENDIF
ENDIF
IF (rscy&(i)+rsch&(i))>ywidth THEN
IF freez=TRUE OR (fcall=TRUE AND (i=smpedit& OR i=trakker& OR i=peak&)) THEN
rsch&(i)=ywidth-rscy&(i)
ENDIF
IF i=smpedit& THEN
hold=rsch&(i)-19
hneu=rsch&(i)-19
ENDIF
IF i=peak& THEN
hold2=rsch&(i)-19
hneu2=rsch&(i)-19
pkreinit=TRUE
ENDIF
IF i=trakker& THEN
hold3=rsch&(i)-19
hneu3=rsch&(i)-19
pkreinit=TRUE
ENDIF
ENDIF
IF i=peak& AND pkreinit=TRUE THEN
nr=i
notopen=TRUE
@calc_peaksize
nr=smpedit&
notopen=FALSE
ENDIF
IF i=trakker& AND pkreinit=TRUE THEN
nr=i
notopen=TRUE
@calc_traksize
nr=smpedit&
notopen=FALSE
ENDIF
OB_X(rsc_adr%(i),0)=ADD(rscx&(i),3)
OB_Y(rsc_adr%(i),0)=ADD(rscy&(i),3)
ENDIF
RETURN
'
> PROCEDURE change_colors
IF maxcol=2 OR dreidim=0 THEN
@textcolor(peak&,peakmax&,0,1,1)  !text,rahmen,fill
@textcolor(peak&,peakch1&,1,1,0)  !text,rahmen,fill
@textcolor(peak&,peakch2&,1,1,0)  !text,rahmen,fill
@textcolor(peak&,peakch3&,1,1,0)  !text,rahmen,fill
@textcolor(peak&,peakch4&,1,1,0)  !text,rahmen,fill
@textcolor(marknumb&,mnumhelp&,1,1,0)
@textcolor(smp16&,helporig&,1,1,0)
@textcolor(smp16&,input&,1,1,0)
@textcolor(smp16&,rate2&,1,1,0)
@textcolor(smp16&,source&,1,1,0)
@textcolor(smp16&,mode&,1,1,0)
@textcolor(smp16&,protect&,1,1,0)
@textcolor(smp16&,emphasis&,1,1,0)
@textcolor(smp16&,dsp&,1,1,0)
@textcolor(smpedit&,smpedhlp&,1,1,0)
@textcolor(smpedit&,mover&,1,1,0)
@textcolor(smpedit&,rate&,1,1,0)
@textcolor(smpedit&,lr100&,1,1,0)
@textcolor(smpedit&,lp80&,1,1,0)
@textcolor(smpedit&,lp60&,1,1,0)
@textcolor(smpedit&,lp40&,1,1,0)
@textcolor(smpedit&,lp20&,1,1,0)
@textcolor(smpedit&,lp0&,1,1,0)
@textcolor(smpedit&,lm20&,1,1,0)
@textcolor(smpedit&,lm40&,1,1,0)
@textcolor(smpedit&,lm60&,1,1,0)
@textcolor(smpedit&,lm80&,1,1,0)
@textcolor(smpedit&,rp80&,1,1,0)
@textcolor(smpedit&,rp60&,1,1,0)
@textcolor(smpedit&,rp40&,1,1,0)
@textcolor(smpedit&,rp20&,1,1,0)
@textcolor(smpedit&,rp0&,1,1,0)
@textcolor(smpedit&,rm20&,1,1,0)
@textcolor(smpedit&,rm40&,1,1,0)
@textcolor(smpedit&,rm60&,1,1,0)
@textcolor(smpedit&,rm80&,1,1,0)
@textcolor(dspedit&,dspflip&,1,1,0)
@textcolor(dspedit&,helpdsp&,1,1,0)
@textcolor(dspedit&,dspslot0&,1,1,0)
@textcolor(dspedit&,dspslot1&,1,1,0)
@textcolor(dspedit&,dspslot2&,1,1,0)
@textcolor(dspedit&,dspslot3&,1,1,0)
@textcolor(dspedit&,dspslot4&,1,1,0)
@textcolor(dspedit&,dspslot5&,1,1,0)
@textcolor(dspedit&,dspslot6&,1,1,0)
@textcolor(dspedit&,dspslot7&,1,1,0)
@textcolor(dspedit&,dspslot8&,1,1,0)
@textcolor(dspedit&,dspslot9&,1,1,0)
@textcolor(peak&,peakhelp&,1,1,0)
@textcolor(peak&,peakmax&,1,1,0)
@textcolor(peak&,peakpos&,1,1,0)
@textcolor(peak&,peakdb&,1,1,0)
@textcolor(peak&,peakbal&,1,1,0)
@textcolor(peak&,peakname&,1,1,0)
@textcolor(peak&,recpeaks&,1,1,0)
@textcolor(peak&,recerror&,1,1,0)
@textcolor(peak&,balbox&,1,1,0)
@textcolor(loop&,helploop&,1,1,0)
@textcolor(normaliz&,helpnorm&,1,1,0)
@textcolor(normaliz&,normdb&,1,1,0)
@textcolor(normaliz&,maxdb&,1,1,0)
@textcolor(resample&,resmpsel&,1,1,0)
@textcolor(resample&,helprsmp&,1,1,0)
@textcolor(resample&,resmplen&,1,1,0)
@textcolor(resample&,resmpsec&,1,1,0)
@textcolor(resample&,resmpfac&,1,1,0)
@textcolor(resample&,resother&,1,1,0)
@textcolor(midiedit&,helpmidi&,1,1,0)
@textcolor(midiedit&,notetxt&,1,1,0)
@textcolor(midiedit&,chtxt&,1,1,0)
@textcolor(editfade&,helpfade&,1,1,0)
@textcolor(record&,rechelp&,1,1,0)
@textcolor(record&,recfree&,1,1,0)
@textcolor(blkfunc&,blkhelp&,1,1,0)
@textcolor(savebloc&,savehelp&,1,1,0)
@textcolor(arranger&,arrhelp&,1,1,0)
'    @textcolor(arranger&,playlen&,1,1,0)
@textcolor(arranger&,playname&,1,1,0)
@textcolor(arranger&,arrnr1&,1,1,0)
@textcolor(arranger&,arrmem1&,1,1,0)
@textcolor(arranger&,spur1&,1,1,0)
@textcolor(arranger&,arrsmpr1&,1,1,0)
@textcolor(arranger&,arrnote1&,1,1,0)
@textcolor(arranger&,arrch1&,1,1,0)
@textcolor(arranger&,hardst1&,1,1,0)
@textcolor(arranger&,harde1&,1,1,0)
@textcolor(arranger&,hardlen1&,1,1,0)
@textcolor(arranger&,arrnr2&,1,1,0)
@textcolor(arranger&,arrmem2&,1,1,0)
@textcolor(arranger&,spur2&,1,1,0)
@textcolor(arranger&,arrsmpr2&,1,1,0)
@textcolor(arranger&,arrnote2&,1,1,0)
@textcolor(arranger&,arrch2&,1,1,0)
@textcolor(arranger&,hardst2&,1,1,0)
@textcolor(arranger&,harde2&,1,1,0)
@textcolor(arranger&,hardlen2&,1,1,0)
@textcolor(arranger&,arrnr3&,1,1,0)
@textcolor(arranger&,arrmem3&,1,1,0)
@textcolor(arranger&,spur3&,1,1,0)
@textcolor(arranger&,arrsmpr3&,1,1,0)
@textcolor(arranger&,arrnote3&,1,1,0)
@textcolor(arranger&,arrch3&,1,1,0)
@textcolor(arranger&,hardst3&,1,1,0)
@textcolor(arranger&,harde3&,1,1,0)
@textcolor(arranger&,hardlen3&,1,1,0)
@textcolor(arranger&,arrnr4&,1,1,0)
@textcolor(arranger&,arrmem4&,1,1,0)
@textcolor(arranger&,spur4&,1,1,0)
@textcolor(arranger&,arrsmpr4&,1,1,0)
@textcolor(arranger&,arrnote4&,1,1,0)
@textcolor(arranger&,arrch4&,1,1,0)
@textcolor(arranger&,hardst4&,1,1,0)
@textcolor(arranger&,harde4&,1,1,0)
@textcolor(arranger&,hardlen4&,1,1,0)
@textcolor(setup&,sethelp&,1,1,0)
@textcolor(setup&,tresdb&,1,1,0)
@textcolor(setup&,recm&,1,1,0)
@textcolor(setup&,seclen&,1,1,0)
@textcolor(setup&,fseltxt&,1,1,0)
@textcolor(setup&,setform&,1,1,0)
@textcolor(info&,helpinfo&,1,1,0)
@textcolor(arrmname&,amhelp&,1,1,0)
@textcolor(trknamin&,trktxhlp&,1,1,0)
@textcolor(virtual&,virthelp&,1,1,0)
@textcolor(virtual&,vblkmlen&,1,1,0)
@textcolor(virtual&,vblkvlen&,1,1,0)
@textcolor(arrmake&,makehelp&,1,1,0)
@textcolor(arrmake&,maketxt&,1,1,0)
@textcolor(arrmake&,makerate&,1,1,0)
@textcolor(timeed&,tedhelp&,1,1,0)
@textcolor(smpinf&,sinfhelp&,1,1,0)
@textcolor(smpinf&,sinfname&,1,1,0)
@textcolor(smpinf&,sinflen&,1,1,0)
@textcolor(smpinf&,sinfrate&,1,1,0)
@textcolor(smpinf&,sinfdate&,1,1,0)
@textcolor(smpinf&,sinfsus1&,1,1,0)
@textcolor(smpinf&,sinfsus2&,1,1,0)
@textcolor(smpinf&,sinfrel1&,1,1,0)
@textcolor(smpinf&,sinfrel2&,1,1,0)
@textcolor(smpinf&,sinfl1&,1,1,0)
@textcolor(smpinf&,sinfl2&,1,1,0)
@textcolor(smpinf&,sinfl3&,1,1,0)
@textcolor(smpinf&,sinfl4&,1,1,0)
@textcolor(smpinf&,sinfl5&,1,1,0)
@textcolor(smpinf&,sinfl6&,1,1,0)
@textcolor(smpinf&,sinfl7&,1,1,0)
@textcolor(smpinf&,sinfl8&,1,1,0)
@textcolor(smpinf&,sinfl9&,1,1,0)
@textcolor(smpinf&,sinfl10&,1,1,0)
@textcolor(smpinf&,sinfl11&,1,1,0)
@textcolor(smpinf&,sinfl12&,1,1,0)
@textcolor(trakker&,trakhelp&,1,1,0)
IF bigfoot=TRUE THEN
@textcolor(trakker&,trk4&,1,1,0)
@textcolor(trakker&,trk8&,1,1,0)
@textcolor(trakker&,trk12&,1,1,0)
@textcolor(trakker&,trk16&,1,1,0)
ENDIF
@textcolor(trakker&,trkmon&,1,1,0)
@textcolor(trakker&,trakk1&,1,1,0)
@textcolor(trakker&,trakk2&,1,1,0)
@textcolor(trakker&,trakk3&,1,1,0)
@textcolor(trakker&,trakk4&,1,1,0)
@textcolor(trakker&,trakstrt&,1,1,0)
@textcolor(trakker&,trakend&,1,1,0)
@textcolor(trakker&,traklen&,1,1,0)
@textcolor(trakker&,trksmpte&,1,1,0)
@textcolor(trakker&,trakdur&,1,1,0)
@textcolor(trakker&,tpstrt&,1,1,0)
@textcolor(trakker&,tpend&,1,1,0)
'    @textcolor(trakker&,trakinfo&,1,1,0)
'    @textcolor(trakker&,trakname&,1,1,0)
'    @textcolor(trakker&,traktime&,1,1,0)
'    @textcolor(trakker&,trkerr&,1,1,0)
@textcolor(trakker&,timeline&,1,1,0)
IF bigfoot=TRUE THEN
@textcolor(trakker&,timelin2&,1,1,0)
@textcolor(trakker&,trkslot2&,1,1,0)
ENDIF
@textcolor(trakker&,trkslot&,1,1,0)
@textcolor(fsel&,fshelp&,1,1,0)
@textcolor(fsel&,fsotxt&,1,1,0)
@textcolor(fsel&,fsbut1&,1,1,0)
@textcolor(fsel&,fsbut2&,1,1,0)
@textcolor(fsel&,fsbut3&,1,1,0)
@textcolor(fsel&,fsbut4&,1,1,0)
@textcolor(fsel&,fsbut5&,1,1,0)
@textcolor(fsel&,fsbut6&,1,1,0)
@textcolor(fsel&,fsbut7&,1,1,0)
@textcolor(fsel&,fsbut8&,1,1,0)
@textcolor(fsel&,fsbut9&,1,1,0)
@textcolor(fsel&,fsbut10&,1,1,0)
@textcolor(fsel&,fsbut11&,1,1,0)
@textcolor(fsel&,fsbut12&,1,1,0)
@textcolor(fsel&,fsbut13&,1,1,0)
@textcolor(fsel&,fsbut14&,1,1,0)
@textcolor(fsel&,fsbut15&,1,1,0)
@textcolor(fsel&,fstxt1&,1,1,0)
@textcolor(fsel&,fstxt2&,1,1,0)
@textcolor(fsel&,fstxt3&,1,1,0)
@textcolor(fsel&,fstxt4&,1,1,0)
@textcolor(fsel&,fstxt5&,1,1,0)
@textcolor(fsel&,fstxt6&,1,1,0)
@textcolor(fsel&,fstxt7&,1,1,0)
@textcolor(fsel&,fstxt8&,1,1,0)
@textcolor(fsel&,fstxt9&,1,1,0)
@textcolor(fsel&,fstxt10&,1,1,0)
@textcolor(fsel&,fstxt11&,1,1,0)
@textcolor(fsel&,fstxt12&,1,1,0)
@textcolor(fsel&,fstxt13&,1,1,0)
@textcolor(fsel&,fstxt14&,1,1,0)
@textcolor(fsel&,fstxt15&,1,1,0)
@textcolor(fsel&,fstime&,1,1,0)
@textcolor(moving&,movhlp&,1,1,0)
@textcolor(abackup&,abackhlp&,1,1,0)
@textcolor(abackup&,abacktxt&,1,1,0)
@textcolor(smpedit&,cstxt&,1,1,0)
@textcolor(smpedit&,cetxt&,1,1,0)
@textcolor(smpedit&,edmtims&,1,1,0)
@textcolor(smpedit&,edmtime&,1,1,0)
@textcolor(smpedit&,edmtimi&,1,1,0)
@textcolor(smpedit&,edmtimr&,1,1,0)
@textcolor(smpedit&,edmnr&,1,1,0)
@textcolor(smpedit&,edmtxt&,1,1,0)
@textcolor(smpedit&,smplen&,1,1,0)
@textcolor(smpedit&,smpfile&,1,1,0)
@textcolor(smpedit&,smpname&,1,1,0)
@textcolor(smpedit&,showxy&,1,1,0)
@textcolor(smpedit&,freemem&,1,1,0)
@textcolor(smpedit&,clock&,1,1,0)
@textcolor(smpedit&,pntprsmp&,1,1,0)
@textcolor(smpedit&,smprate&,1,1,0)
@textcolor(smpedit&,smpsec&,1,1,0)
@textcolor(smpedit&,mintext&,1,1,0)
@textcolor(trakker&,trklevt1&,1,1,0)
@textcolor(trakker&,trklevt2&,1,1,0)
@textcolor(trakker&,trklevt3&,1,1,0)
@textcolor(trakker&,trklevt4&,1,1,0)
@textcolor(trakker&,trktxt1&,1,1,0)
@textcolor(trakker&,trktxt2&,1,1,0)
@textcolor(trakker&,trktxt3&,1,1,0)
@textcolor(trakker&,trktxt4&,1,1,0)
@textcolor(trakker&,pantxt1&,1,1,0)
@textcolor(trakker&,pantxt2&,1,1,0)
@textcolor(trakker&,pantxt3&,1,1,0)
@textcolor(trakker&,pantxt4&,1,1,0)
@textcolor(trakker&,trksize&,1,1,0)
@textcolor(trakker&,trkvbox&,1,1,0)
@textcolor(disked&,dskedtxt&,1,1,0)
@textcolor(meldung&,meldtxt&,1,1,0)
@textcolor(mrkfind&,mrkfnr&,1,1,0)
@textcolor(mrkfind&,mrkftims&,1,1,0)
@textcolor(mrkfind&,mrkftime&,1,1,0)
@textcolor(mrkfind&,mrkftimi&,1,1,0)
@textcolor(mrkfind&,mrkftimr&,1,1,0)
@textcolor(mrkfind&,mrkftxt&,1,1,0)
@textcolor(smpedit&,edmnr&,1,1,0)
@textcolor(smpedit&,edmtims&,1,1,0)
@textcolor(smpedit&,edmtime&,1,1,0)
@textcolor(smpedit&,edmtimi&,1,1,0)
@textcolor(smpedit&,edmtimr&,1,1,0)
@textcolor(smpedit&,edmtxt&,1,1,0)
@textcolor(smpedit&,smpedhlp&,1,1,0)
@textcolor(trkcomin&,trkchlp&,1,1,0)
@textcolor(mrktxtin&,mtexhelp&,1,1,0)
@textcolor(mrkfind&,mrkfhelp&,1,1,0)
@textcolor(disked&,dskedhlp&,1,1,0)
@textcolor(wmode&,wmhelp&,1,1,0)
@textcolor(wmode&,frame&,1,1,0)
@textcolor(clocks&,clockhlp&,1,1,0)
@textcolor(clocks&,clockm&,1,1,0)
@textcolor(clocks&,clock1&,1,1,0)
@textcolor(clocks&,clock2&,1,1,0)
@textcolor(clocks&,clock3&,0,1,1)
@textcolor(clocks&,clock4&,1,1,0)
@textcolor(clocks&,clock5&,1,1,0)
@textcolor(smpedit&,resolu&,1,1,0)
@textcolor(plugin&,panhelp&,1,1,0)
@textcolor(plugin&,levcnt1&,1,1,0)
@textcolor(plugin&,levcnt2&,1,1,0)
@textcolor(plugin&,levcnt3&,1,1,0)
@textcolor(plugin&,levcnt4&,1,1,0)
@textcolor(plugin&,levcnt5&,1,1,0)
@textcolor(plugin&,levcnt6&,1,1,0)
@textcolor(plugin&,levcnt7&,1,1,0)
@textcolor(plugin&,levcnt8&,1,1,0)
@textcolor(plugin&,levcnt9&,1,1,0)
@textcolor(plugin&,levcnt10&,1,1,0)
@textcolor(plugin&,levcnt11&,1,1,0)
@textcolor(plugin&,levcnt12&,1,1,0)
@textcolor(plugin&,levcnt13&,1,1,0)
@textcolor(plugin&,levcnt14&,1,1,0)
@textcolor(plugin&,levcnt15&,1,1,0)
@textcolor(plugin&,levcnt16&,1,1,0)
@textcolor(plugin&,levcnt17&,1,1,0)
@textcolor(plugin&,levcnt18&,1,1,0)
@textcolor(plugin&,levcnt19&,1,1,0)
@textcolor(plugin&,levcnt20&,1,1,0)
@textcolor(plugin&,levcnt21&,1,1,0)
@textcolor(plugin&,levart1&,1,1,0)
@textcolor(plugin&,levart2&,1,1,0)
@textcolor(plugin&,levart3&,1,1,0)
@textcolor(plugin&,levart4&,1,1,0)
@textcolor(plugin&,levart5&,1,1,0)
@textcolor(plugin&,levart6&,1,1,0)
@textcolor(plugin&,levart7&,1,1,0)
@textcolor(plugin&,levart8&,1,1,0)
@textcolor(plugin&,levart9&,1,1,0)
@textcolor(plugin&,levart10&,1,1,0)
@textcolor(plugin&,levart11&,1,1,0)
@textcolor(plugin&,levart12&,1,1,0)
@textcolor(plugin&,levart13&,1,1,0)
@textcolor(plugin&,levart14&,1,1,0)
@textcolor(plugin&,levart15&,1,1,0)
@textcolor(plugin&,levart16&,1,1,0)
@textcolor(plugin&,levart17&,1,1,0)
@textcolor(plugin&,levart18&,1,1,0)
@textcolor(plugin&,levart19&,1,1,0)
@textcolor(plugin&,levart20&,1,1,0)
@textcolor(plugin&,levart21&,1,1,0)
@textcolor(plugin&,levtxt1&,1,1,0)
@textcolor(plugin&,levtxt2&,1,1,0)
@textcolor(plugin&,levtxt3&,1,1,0)
@textcolor(plugin&,levtxt4&,1,1,0)
@textcolor(plugin&,levtxt5&,1,1,0)
@textcolor(plugin&,levtxt6&,1,1,0)
@textcolor(plugin&,levtxt7&,1,1,0)
@textcolor(plugin&,levtxt8&,1,1,0)
@textcolor(plugin&,levtxt9&,1,1,0)
@textcolor(plugin&,levtxt10&,1,1,0)
@textcolor(plugin&,levtxt11&,1,1,0)
@textcolor(plugin&,levtxt12&,1,1,0)
@textcolor(plugin&,levtxt13&,1,1,0)
@textcolor(plugin&,levtxt14&,1,1,0)
@textcolor(plugin&,levtxt15&,1,1,0)
@textcolor(plugin&,levtxt16&,1,1,0)
@textcolor(plugin&,levtxt17&,1,1,0)
@textcolor(plugin&,levtxt18&,1,1,0)
@textcolor(plugin&,levtxt19&,1,1,0)
@textcolor(plugin&,levtxt20&,1,1,0)
@textcolor(plugin&,levtxt21&,1,1,0)
@textcolor(plugin&,plugct1&,1,1,0)
@textcolor(plugin&,plugct2&,1,1,0)
@textcolor(plugin&,plugct3&,1,1,0)
@textcolor(plugin&,plgtitel&,1,1,0)
@textcolor(plgconfg&,pcfghelp&,1,1,0)
@textcolor(plgconfg&,plgcfg1&,1,1,0)
@textcolor(plgconfg&,plgcfg2&,1,1,0)
@textcolor(plgconfg&,plgcfg3&,1,1,0)
@textcolor(plgconfg&,plgcfg4&,1,1,0)
@textcolor(plgconfg&,plgcfg5&,1,1,0)
@textcolor(plgconfg&,plgcfg6&,1,1,0)
@textcolor(plgconfg&,plgcfg7&,1,1,0)
@textcolor(plgconfg&,plgcfg8&,1,1,0)
@textcolor(plgconfg&,plgcfg9&,1,1,0)
@textcolor(plgconfg&,plgcfg10&,1,1,0)
@textcolor(plgconfg&,plgrec1&,1,1,0)
@textcolor(plgconfg&,plgrec2&,1,1,0)
@textcolor(plgconfg&,plgrec3&,1,1,0)
@textcolor(plgconfg&,plgrec4&,1,1,0)
@textcolor(plgconfg&,plgrec5&,1,1,0)
@textcolor(plgconfg&,plgplay1&,1,1,0)
@textcolor(plgconfg&,plgplay2&,1,1,0)
@textcolor(plgconfg&,plgplay3&,1,1,0)
@textcolor(plgconfg&,plgplay4&,1,1,0)
@textcolor(plgconfg&,plgplay5&,1,1,0)
@textcolor(plgconfg&,pcfgtex1&,1,1,0)
@textcolor(plgconfg&,pcfgtex2&,1,1,0)
@textcolor(plgconfg&,pcfgtex3&,1,1,0)
@textcolor(cuelist&,cuehelp&,1,1,0)
FOR i=0 TO 9
@textcolor(cuelist&,cuex1&+i,1,1,0)
@textcolor(cuelist&,cuenr1&+i,1,1,0)
@textcolor(cuelist&,cuet1&+i,1,1,0)
@textcolor(cuelist&,cues1&+i,1,1,0)
@textcolor(cuelist&,cuee1&+i,1,1,0)
@textcolor(cuelist&,cuel1&+i,1,1,0)
NEXT i
FOR i=partfsc& TO partfs6&
@textcolor(partsel&,i,1,1,0)
NEXT i
@textcolor(partsel&,parthelp&,1,1,0)
@textcolor(xfade&,xfadehlp&,1,1,0)
@colorbox(mixer&,mixbox1&,0,7)
@colorbox(mixer&,mixbox2&,0,7)
@colorbox(mixer&,mixbx1&,0,7)
@colorbox(mixer&,mixbx2&,0,7)
@colorbox(mixer&,mixbx3&,0,7)
@colorbox(mixer&,mixbx4&,0,7)
@colorbox(mixer&,mixbx5&,0,7)
@colorbox(mixer&,mixbx6&,0,7)
@colorbox(mixer&,mixbx7&,0,7)
@colorbox(mixer&,mixbx8&,0,7)
@colorbox(mixer&,mixbxm&,0,7)
@colorbox(mixer&,mixvbox1&,0,7)
@colorbox(mixer&,mixvbox2&,0,7)
@colorbox(mixer&,mixvbox3&,0,7)
@colorbox(mixer&,mixvbox4&,0,7)
@colorbox(mixer&,mixvbox5&,0,7)
@colorbox(mixer&,mixvbox6&,0,7)
@colorbox(mixer&,mixvbox7&,0,7)
@colorbox(mixer&,mixvbox8&,0,7)
@colorbox(mixer&,mixvboxm&,0,7)
@colorbox(mixer&,mxbalbx1&,0,7)
@colorbox(mixer&,mxbalbx2&,0,7)
@colorbox(mixer&,mxbalbx3&,0,7)
@colorbox(mixer&,mxbalbx4&,0,7)
@colorbox(mixer&,mxbalbx5&,0,7)
@colorbox(mixer&,mxbalbx6&,0,7)
@colorbox(mixer&,mxbalbx7&,0,7)
@colorbox(mixer&,mxbalbx8&,0,7)
@colorbox(mixer&,mxbalbxm&,0,7)
@colorbox(mixer&,mixdb1&,0,7)
@colorbox(mixer&,mixdb2&,0,7)
@colorbox(mixer&,mixdb3&,0,7)
@colorbox(mixer&,mixdb4&,0,7)
@colorbox(mixer&,mixdb5&,0,7)
@colorbox(mixer&,mixdb6&,0,7)
@colorbox(mixer&,mixdb7&,0,7)
@colorbox(mixer&,mixdb8&,0,7)
@colorbox(mixer&,mixdbm&,0,7)
@textcolor(mixer&,mixtxt1&,1,1,0)
@textcolor(mixer&,mixtxt2&,1,1,0)
@textcolor(mixer&,mixtxt3&,1,1,0)
@textcolor(mixer&,mixtxt4&,1,1,0)
@textcolor(mixer&,mixtxt5&,1,1,0)
@textcolor(mixer&,mixtxt6&,1,1,0)
@textcolor(mixer&,mixtxt7&,1,1,0)
@textcolor(mixer&,mixtxt8&,1,1,0)
@textcolor(mixer&,mixtxtm&,1,1,0)
@textcolor(mixer&,mixhelp&,1,1,0)
@textcolor(mixer&,mixbaln1&,1,1,0)
@textcolor(mixer&,mixbaln2&,1,1,0)
@textcolor(mixer&,mixbaln3&,1,1,0)
@textcolor(mixer&,mixbaln4&,1,1,0)
@textcolor(mixer&,mixbaln5&,1,1,0)
@textcolor(mixer&,mixbaln6&,1,1,0)
@textcolor(mixer&,mixbaln7&,1,1,0)
@textcolor(mixer&,mixbaln8&,1,1,0)
@textcolor(mixer&,mixbalnm&,1,1,0)
@textcolor(mixer&,mixvoln1&,1,1,0)
@textcolor(mixer&,mixvoln2&,1,1,0)
@textcolor(mixer&,mixvoln3&,1,1,0)
@textcolor(mixer&,mixvoln4&,1,1,0)
@textcolor(mixer&,mixvoln5&,1,1,0)
@textcolor(mixer&,mixvoln6&,1,1,0)
@textcolor(mixer&,mixvoln7&,1,1,0)
@textcolor(mixer&,mixvoln8&,1,1,0)
@textcolor(mixer&,mixvolnm&,1,1,0)
@textcolor(mixer&,mixvolt1&,0,0,1)
@textcolor(mixer&,mixvolt2&,0,0,1)
@textcolor(mixer&,mixvolt3&,0,0,1)
@textcolor(mixer&,mixvolt4&,0,0,1)
@textcolor(mixer&,mixvolt5&,0,0,1)
@textcolor(mixer&,mixvolt6&,0,0,1)
@textcolor(mixer&,mixvolt7&,0,0,1)
@textcolor(mixer&,mixvolt8&,0,0,1)
@textcolor(mixer&,mixvoltm&,0,0,1)
@textcolor(mixer&,mixbalt1&,0,0,1)
@textcolor(mixer&,mixbalt2&,0,0,1)
@textcolor(mixer&,mixbalt3&,0,0,1)
@textcolor(mixer&,mixbalt4&,0,0,1)
@textcolor(mixer&,mixbalt5&,0,0,1)
@textcolor(mixer&,mixbalt6&,0,0,1)
@textcolor(mixer&,mixbalt7&,0,0,1)
@textcolor(mixer&,mixbalt8&,0,0,1)
@textcolor(mixer&,mixbaltm&,0,0,1)
@colorbox(plugin&,panbox&,0,7)
@colorbox(plgconfg&,pcfgbox&,0,7)
@colorbox(smp16&,mainbox6&,0,7)
@colorbox(smp16&,mainbox&,0,7)
@colorbox(smp16&,mainbox2&,0,7)
@colorbox(smp16&,mainbox4&,0,7)
@colorbox(smp16&,mainbox5&,0,7)
@colorbox(smpedit&,editbox&,0,7)
@colorbox(smpedit&,editbox2&,0,7)
@colorbox(smpedit&,editbox3&,0,7)
@colorbox(smpedit&,editbox5&,0,7)
@colorbox(smpedit&,editbox6&,0,7)
@colorbox(smpedit&,editbox7&,0,7)
@colorbox(smpedit&,zomslide&,1,1)
@colorbox(smpedit&,edmslide&,1,1)
@colorbox(smpedit&,scrlslde&,1,1)
@colorbox(smpedit&,curvbox&,0,7)
@colorbox(smpedit&,editbox4&,0,7)
@colorbox(smpedit&,editbox8&,0,7)
@colorbox(peak&,peakbox&,0,7)
@colorbox(peak&,pkmbox&,0,7)
@colorbox(peak&,pkmbox2&,0,7)
@colorbox(peak&,peakbox2&,0,7)
@colorbox(peak&,volbox&,0,7)
@colorbox(peak&,phldslid&,1,1)
@colorbox(partsel&,partbox&,0,7)
@colorbox(xfade&,xfadebox&,0,7)
@colorbox(xfade&,xfadebx2&,0,7)
@colorbox(xfade&,xfadebx3&,0,7)
@colorbox(loop&,loopbox&,0,7)
@colorbox(loop&,loopbox2&,0,7)
@colorbox(normaliz&,normbox&,0,7)
@colorbox(normaliz&,normbox2&,0,7)
@colorbox(resample&,resmpbox&,0,7)
@colorbox(midiedit&,midibox&,0,7)
@colorbox(editfade&,fadebox&,0,7)
@colorbox(editfade&,edfadbox&,0,7)
@colorbox(record&,recbox&,0,7)
@colorbox(blkfunc&,blkbox&,0,7)
@colorbox(savebloc&,savebox&,0,7)
@colorbox(arranger&,arrbox&,0,7)
@colorbox(arranger&,arrbox2&,0,7)
@colorbox(arranger&,arrbox3&,0,7)
@colorbox(arranger&,arrbox4&,0,7)
@colorbox(arranger&,arrslide&,1,1)
'    @colorbox(info&,infobox&,0,7)
@colorbox(trknamin&,trktxbox&,0,7)
@colorbox(trknamin&,trktxbo2&,0,7)
@colorbox(arrmname&,arrmnbox&,0,7)
@colorbox(arrmname&,arrmnbx2&,0,7)
@colorbox(dspedit&,dspbox&,0,7)
@colorbox(dspedit&,dspslide&,1,1)
@colorbox(virtual&,virtbox&,0,7)
@colorbox(virtual&,virtbox2&,0,7)
@colorbox(virtual&,virtbox3&,0,7)
@colorbox(virtual&,vslider&,1,1)
@colorbox(moving&,movngbox&,0,7)
@colorbox(arrmake&,makebox&,0,7)
@colorbox(timeed&,timebox&,0,7)
@colorbox(timeed&,timebox2&,0,7)
@colorbox(abackup&,abackbox&,0,7)
@colorbox(abackup&,abackbo2&,0,7)
@colorbox(inftxt&,infbox&,0,7)
@colorbox(inftxt&,infbox2&,0,7)
@colorbox(trakker&,trakbox&,0,7)
@colorbox(trakker&,trakedbx&,0,7)
@colorbox(trakker&,trakbox2&,0,7)
@colorbox(trakker&,trakbox3&,0,7)
'    @colorbox(trakker&,trakbox4&,0,7)
@colorbox(trakker&,trakbox5&,0,7)
@colorbox(trakker&,trakbxw&,0,7)
@colorbox(trakker&,trakslid&,1,1)
@colorbox(trakker&,zoomslid&,1,1)
@colorbox(trakker&,spurslid&,1,1)
@colorbox(mrkfind&,mrkfslid&,1,1)
@colorbox(setup&,setupbox&,0,7)
@colorbox(setup&,setupbx2&,0,7)
@colorbox(setup&,setupbx3&,0,7)
@colorbox(fsel&,fselbox&,0,7)
@colorbox(fsel&,fselbox2&,0,7)
@colorbox(fsel&,fsslide&,1,1)
@colorbox(smpinf&,sinfbox&,0,7)
@colorbox(smpinf&,sinfbox2&,0,7)
@colorbox(trakker&,tlevbox&,0,7)
@colorbox(trakker&,trkbx1&,0,7)
@colorbox(trakker&,trkbx2&,0,7)
@colorbox(trakker&,trkbx3&,0,7)
@colorbox(trakker&,trkbx4&,0,7)
@colorbox(meldung&,meldbox&,0,7)
@colorbox(trkcomin&,trkcbox&,0,7)
@colorbox(trkcomin&,trkcbox2&,0,7)
@colorbox(mrktxtin&,mtexbox&,0,7)
@colorbox(mrktxtin&,mtexbox2&,0,7)
@colorbox(mrkfind&,mrkfbox&,0,7)
@colorbox(mrkfind&,mrkfbox2&,0,7)
@colorbox(mrkfind&,mrkfbox3&,0,7)
@colorbox(cuelist&,cuebox&,0,7)
@colorbox(cuelist&,cuebox2&,0,7)
@colorbox(cuelist&,cueslide&,1,1)
IF bigfoot=TRUE THEN
@colorbox(trakker&,trakbox6&,0,7)
ENDIF
@colorbox(disked&,dskedbox&,0,7)
@colorbox(disked&,dskedbx2&,0,7)
@colorbox(disked&,dskedbx3&,0,7)
@colorbox(disked&,dskedbx4&,0,7)
@colorbox(alertbox&,alertcol&,0,7)
@colorbox(wmode&,wmbox1&,0,7)
@colorbox(wmode&,wmbox2&,0,7)
@colorbox(wmode&,wmbox3&,0,7)
@colorbox(wmode&,wmbox4&,0,7)
@colorbox(wmode&,wmbox5&,0,7)
@colorbox(clocks&,clkbox&,0,7)
@colorbox(clocks&,clkbox2&,0,7)
@colorbox(clocks&,clkslid&,1,1)
@colorbox(marknumb&,mnumbox&,0,7)
@colorbox(marknumb&,mnumbox2&,0,7)
ELSE
@colorbox(smpedit&,curvbox&,smpwcol,7)
@colorbox(smpedit&,editbox4&,smpblkcol,7)
@colorbox(smpedit&,editbox8&,smpblkcol,7)
@colorbox(trakker&,trakbox2&,smpblkcol,7)
@colorbox(trakker&,trakedbx&,smpwcol,7)
@textcolor(trakker&,trkslot&,0,smpwcol,smpwcol)
@textcolor(trakker&,timeline&,0,smpwcol,smpwcol)
IF bigfoot=TRUE THEN
@textcolor(trakker&,trkslot2&,0,smpwcol,smpwcol)
@textcolor(trakker&,timelin2&,0,smpwcol,smpwcol)
ENDIF
@textcolor(trakker&,trktitxt&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lr100&,6,smpwcol,smpwcol)
@textcolor(smpedit&,lp80&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lp60&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lp40&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lp20&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lp0&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lm20&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lm40&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lm60&,0,smpwcol,smpwcol)
@textcolor(smpedit&,lm80&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rp80&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rp60&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rp40&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rp20&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rp0&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rm20&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rm40&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rm60&,0,smpwcol,smpwcol)
@textcolor(smpedit&,rm80&,0,smpwcol,smpwcol)
@textcolor(smpedit&,smptxl&,0,smpwcol,smpwcol)
@textcolor(smpedit&,smptxr&,0,smpwcol,smpwcol)
ENDIF
IF (magix=0 AND magicmac=0 AND nova<>0) OR maxcol=2 THEN
@textcolor(virtual&,vblkstrt&,1,1,0)  !text,rahmen,fill
@textcolor(record&,timetxt&,1,1,0)  !text,rahmen,fill
@textcolor(resample&,restxt&,1,1,0)  !text,rahmen,fill
@textcolor(resample&,resother&,1,1,0)  !text,rahmen,fill
@textcolor(disked&,dskedit&,1,1,0)  !text,rahmen,fill
@textcolor(wmode&,syncsrte&,1,1,0)  !text,rahmen,fill
@textcolor(wmode&,synchz&,1,1,0)  !text,rahmen,fill
@textcolor(wmode&,smpteset&,1,1,0)  !text,rahmen,fill
@textcolor(setup&,lenmall&,1,1,0)  !text,rahmen,fill
@textcolor(arrmname&,memname&,1,1,0)  !text,rahmen,fill
@textcolor(timeed&,tedtxt&,1,1,0)  !text,rahmen,fill
@textcolor(smpinf&,sinfcomm&,1,1,0)  !text,rahmen,fill
@textcolor(smpinf&,sinfsrc&,1,1,0)  !text,rahmen,fill
@textcolor(trknamin&,trktxtin&,1,1,0)  !text,rahmen,fill
@textcolor(trkcomin&,trkctxin&,1,1,0)  !text,rahmen,fill
@textcolor(mrktxtin&,mtex&,1,1,0)  !text,rahmen,fill
@textcolor(marknumb&,mnumtxt&,1,1,0)  !text,rahmen,fill
@colorbox(smpinf&,sinfbox2&,0,7)
ENDIF
RETURN
'
> PROCEDURE bigtext(tre,t$,n)
LOCAL l,s
@markhlp
~GRAF_MOUSE(256,0)                              ! Hidem
s=40
GRAPHMODE 1
DEFFILL 1,1,1
IF flicker=TRUE THEN
VSYNC
ENDIF
PBOX ax&-1+texposx,ay&-38+texposy+n*(s+5),ax&-1+texposx+bneu2-21,ay&-38+texposy-s-1+n*(s+5)
IF n=0 THEN
IF maxcol=2 THEN
DEFTEXT 0,2,0,s
ELSE
DEFTEXT dgrey,0,0,s
ENDIF
ELSE
IF maxcol=2 THEN
DEFTEXT 0,0,0,s
ELSE
DEFTEXT green,0,0,s
ENDIF
ENDIF
GRAPHMODE 2
l=LEN(t$)
IF l>11 THEN
t$=LEFT$(t$,11)
ENDIF
TEXT ax&-1+texposx+13,ay&-38+texposy-4+n*(s+5),t$
DEFTEXT 1,0,0,4
~GRAF_MOUSE(257,0)                              ! Showm
RETURN
'
> PROCEDURE bigtext2
LOCAL s
IF bigtxt=TRUE AND nr=peak& THEN
@markhlp
s=40
GRAPHMODE 1
DEFFILL 1,1,1
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&-1+texposx,ay&-38+texposy+0*(s+5),ax&-1+texposx+bneu2-21,ay&-38+texposy-s-1+0*(s+5)
PBOX ax&-1+texposx,ay&-38+texposy+1*(s+5),ax&-1+texposx+bneu2-21,ay&-38+texposy-s-1+1*(s+5)
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE bigtext3(x,y,n,t$,a,b)
LOCAL l,s,m,m2,m3
~GRAF_MOUSE(256,0)                              ! Hidem
IF bigfoot=FALSE THEN
s=4
s3=1
ELSE
s=11
s3=0
ENDIF
s2=6
GRAPHMODE 1
IF maxcol=2 OR dreidim=0 THEN
DEFFILL 0,1,0
ELSE
DEFFILL smpwcol,1,smpwcol
ENDIF
m=s2*n*11
m2=INT(m/2/n)+2
IF bigfoot=FALSE AND t$="     " THEN
m2=m2/2
ENDIF
m3=LEN(t$)*s2
IF a=0 THEN
PBOX x-m2-5,y+s3,x+m2-4,y-s
m3=INT(m3/2)
ELSE
PBOX x-m2-5,y+s3,x+m2-4,y-s
m3=INT(m3/2)+5
ENDIF
IF maxcol=2 OR dreidim=0 THEN
IF b=6 THEN
IF bigfoot=FALSE THEN
DEFTEXT 0,0,0,s
ELSE
DEFTEXT 1,2,0,s
ENDIF
ELSE
DEFTEXT 1,0,0,s
ENDIF
ELSE
DEFTEXT b,0,0,s
ENDIF
GRAPHMODE 2
l=LEN(t$)
IF l>11 THEN
t$=LEFT$(t$,11)
ENDIF
TEXT x-m3+1,y,t$
DEFTEXT 1,0,0,4
~GRAF_MOUSE(257,0)                              ! Showm
RETURN
'
> PROCEDURE calc_editsize
LOCAL v,hadd,hadd2,hadd4,q,cc
IF ((freez=TRUE OR fcall=TRUE) AND notopen=TRUE) OR notopen=FALSE THEN
IF bigfoot=FALSE THEN
IF bneu<661+3 THEN
bneu=661
ENDIF
IF hneu<400 THEN
hneu=400
ENDIF
ELSE
IF bneu<1020 THEN
bneu=1020
ENDIF
IF hneu<562 THEN
hneu=562
ENDIF
ENDIF
bneu=bneu-6
hneu=hneu-6
@buttbh(editbox7&,b,h)
badd=bneu-b
IF cefadd2=FALSE THEN
cefadd=16
cefadd2=TRUE
ELSE
cefadd=0
ENDIF
hadd=hneu-h+cefadd
hadd2=INT(hadd/2)
hadd4=INT(hadd/4)
@setbuttbh(editbox7&,bneu,hneu)
@buttbh(editbox2&,b,h)
b=b+badd
@setbuttbh(editbox2&,b,h)
@buttbh(curvbox&,b,h)
b=b+badd
h=h+hadd
@setbuttbh(curvbox&,b,h)
@buttbh(editbox4&,b,h)
b=b+badd
h=h+hadd2
@setbuttbh(editbox4&,b,h)
@buttbh(editbox8&,b,h)
b=b+badd
h=h+hadd2
@setbuttbh(editbox8&,b,h)
@readpos(editbox&)
bx=INT(bx+badd/2)
by=by+hadd
@setpos(editbox&,bx,by)
@readpos(lscroll&)
by=by+hadd
@setpos(lscroll&,bx,by)
@readpos(rscroll&)
bx=bx+badd
by=by+hadd
@setpos(rscroll&,bx,by)
@readpos(scrlslde&)
by=by+hadd
@setpos(scrlslde&,bx,by)
@buttbh(scrlslde&,b,h)
b=b+badd
@setbuttbh(scrlslde&,b,h)
@readpos(editbox8&)
by=by+hadd2
@setpos(editbox8&,bx,by)
@readpos(smpsave&)
v=16
bx=bneu-v-32
@setpos(smpsave&,bx,by)
bx=bneu-v-32*2
@setpos(smpload&,bx,by)
bx=bneu-v-32*3
@setpos(disk&,bx,by)
bx=bneu-v-32*4
@setpos(smpdbank&,bx,by)
IF bigfoot=TRUE THEN
bx=bneu-v-32*5
@setpos(edpart&,bx,by)
ENDIF
@readpos(blkfiler&)
bx=bneu-v-15-32
IF bigfoot=TRUE THEN
bx=bx-16
ENDIF
@setpos(blkfiler&,bx,by)
bx=bneu-(v-1)-32*4
IF bigfoot=TRUE THEN
bx=bx-32
ENDIF
@setpos(blkfilel&,bx,by)
@readpos(blkfile&)
bx=bneu-(v-21)-32*3
IF bigfoot=TRUE THEN
bx=bx-16
ENDIF
@setpos(blkfile&,bx,by)
@calc_editboxes1
cached=FALSE
q=(ym+3)/10
@readpos(lp80&)
IF bigfoot=FALSE THEN
by2=q+9
ELSE
by2=q+29
ENDIF
@setpos(lp80&,bx,by2)
@readpos(lp60&)
by2=by2+q
by=INT(by2)
@setpos(lp60&,bx,by)
@readpos(lp40&)
by2=by2+q
by=INT(by2)
@setpos(lp40&,bx,by)
@readpos(lp20&)
by2=by2+q
by=INT(by2)
@setpos(lp20&,bx,by)
@readpos(lp0&)
by2=by2+q
by=INT(by2)
@setpos(lp0&,bx,by)
@readpos(lm20&)
by2=by2+q
by=INT(by2)
@setpos(lm20&,bx,by)
@readpos(lm40&)
by2=by2+q
by=INT(by2)
@setpos(lm40&,bx,by)
@readpos(lm60&)
by2=by2+q
by=INT(by2)
@setpos(lm60&,bx,by)
@readpos(lm80&)
by2=by2+q
by=INT(by2)
@setpos(lm80&,bx,by)
@readpos(lr100&)
by2=by2+q+1
by=INT(by2)
@setpos(lr100&,bx,by)
@readpos(rp80&)
by2=by2+q+2
by=INT(by2)
@setpos(rp80&,bx,by)
@readpos(rp60&)
by2=by2+q
by=INT(by2)
@setpos(rp60&,bx,by)
@readpos(rp40&)
by2=by2+q
by=INT(by2)
@setpos(rp40&,bx,by)
@readpos(rp20&)
by2=by2+q
by=INT(by2)
@setpos(rp20&,bx,by)
@readpos(rp0&)
by2=by2+q
by=INT(by2)
@setpos(rp0&,bx,by)
@readpos(rm20&)
by2=by2+q
by=INT(by2)
@setpos(rm20&,bx,by)
@readpos(rm40&)
by2=by2+q
by=INT(by2)
@setpos(rm40&,bx,by)
@readpos(rm60&)
by2=by2+q
by=INT(by2)
@setpos(rm60&,bx,by)
@readpos(rm80&)
by2=by2+q
by=INT(by2)
@setpos(rm80&,bx,by)
IF bigfoot=FALSE THEN
cc=30
ELSE
cc=38
ENDIF
@readpos(smptxl&)
bx=bneu-cc
by=by+hadd4
@setpos(smptxl&,bx,by)
@readpos(smptxr&)
bx=bneu-cc
by=by+hadd2+hadd4
@setpos(smptxr&,bx,by)
IF smpedda=TRUE THEN
@rsc_back(nr)
ENDIF
rscx&(nr)=xneu
rscy&(nr)=yneu-18
rscw&(nr)=bneu+6
rsch&(nr)=hneu+6+16
@setpos(editbox7&,xneu+3,yneu+3-18)
@scrollinit
IF notopen=FALSE THEN
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
@wischwasch
@rsc_draw(nr,7)
@restaura
ENDIF
ENDIF
RETURN
'
> PROCEDURE calc_peaksize
IF ((freez=TRUE OR fcall=TRUE) AND notopen=TRUE) OR notopen=FALSE THEN
bigpeak=532
IF bneu2<>316 THEN
bneu2=316
ENDIF
IF hneu2<406 THEN
hneu2=406
ENDIF
bneu2=bneu2-6
hneu2=hneu2-6
'
hneu2=hneu2+16
hneu2=INT(hneu2/9)*9
hneu2=hneu2-16
'
IF hneu2>bigpeak THEN
IF bigtxt=FALSE THEN
@readpos(pkmbox&)
pkmx=bx
@readpos(pkmbox2&)
pkmx2=bx
@readpos(peakhelp&)
pkmx3=bx
pkmy3=by
@readpos(peakexit&)
pkmx4=bx
pkmy4=by
@readpos(peakmute&)
pkmx5=bx
pkmy5=by
@readpos(balzero&)
pkmx6=bx
pkmy6=by
hadds=27
ELSE
@readpos(pkmbox&)
by=by+102
@setpos(pkmbox&,pkmx,by)
@readpos(pkmbox2&)
by=by+432
@setpos(pkmbox2&,pkmx2,by)
'
@readpos(peakhelp&)
by=by-84+9
@setpos(peakhelp&,pkmx3,by)
@readpos(peakexit&)
by=by-55+7
@setpos(peakexit&,pkmx4,by)
@readpos(peakmute&)
by=by+130-14
@setpos(peakmute&,pkmx5,by)
@readpos(balzero&)
by=by+105-14
@setpos(balzero&,pkmx6,by)
hadds=0
ENDIF
bigtxt=TRUE
@hidetree2(peakpos&,TRUE)
@hidetree2(peakpost&,TRUE)
@hidetree2(peakmax&,TRUE)
@hidetree2(peakmaxt&,TRUE)
ELSE
IF bigtxt=TRUE THEN
@readpos(pkmbox&)
by=by+102
@setpos(pkmbox&,pkmx,by)
@readpos(pkmbox2&)
by=by+432
@setpos(pkmbox2&,pkmx2,by)
@readpos(peakhelp&)
by=by-84+9
@setpos(peakhelp&,pkmx3,by)
@readpos(peakexit&)
by=by-55+7
@setpos(peakexit&,pkmx4,by)
@readpos(peakmute&)
by=by+130-14
@setpos(peakmute&,pkmx5,by)
@readpos(balzero&)
by=by+105-14
@setpos(balzero&,pkmx6,by)
hadds=-27
ELSE
hadds=0
ENDIF
bigtxt=FALSE
@hidetree2(peakpos&,FALSE)
@hidetree2(peakpost&,FALSE)
@hidetree2(peakmax&,FALSE)
@hidetree2(peakmaxt&,FALSE)
ENDIF
texposx=4
texposy=hneu2-62-32
@buttbh(peakbox&,b,h)
badd=bneu2-b
hadd=hneu2-h+16-hadds
hadd2=INT(hadd/2)
hadd4=INT(hadd/4)
@setbuttbh(peakbox&,bneu2,hneu2+16)
@readpos(peakname&)
by=by+hadd
@setpos(peakname&,bx,by)
@readpos(peakmute&)
by=by+hadd
IF hneu2>bigpeak THEN
bx=bneu2-78
by=by-130+14
ENDIF
@setpos(peakmute&,bx,by)
@readpos(balzero&)
by=by+hadd
IF hneu2>bigpeak THEN
bx=bneu2-78
by=by-105+14
ENDIF
@setpos(balzero&,bx,by)
@readpos(peakhelp&)
by=by+hadd
IF hneu2>bigpeak THEN
bx=8
by=by+84-9
ENDIF
@setpos(peakhelp&,bx,by)
@readpos(peakexit&)
by=by+hadd
IF hneu2>bigpeak THEN
bx=bneu2-76
by=by+55-7
ENDIF
@setpos(peakexit&,bx,by)
'
@readpos(pkmbox&)
by=by+hadd
IF hneu2>bigpeak THEN
by=by-102
ENDIF
@setpos(pkmbox&,bx,by)
bx2=bx
@readpos(pkmbox2&)
by=by+hadd
IF hneu2>bigpeak THEN
by=by-432
bx=bx2+30
ENDIF
@setpos(pkmbox2&,bx,by)
@readpos(peaktl&)
by=by+hadd
@setpos(peaktl&,bx,by)
@readpos(peaktr&)
by=by+hadd
@setpos(peaktr&,bx,by)
@buttbh(peakbox2&,b,h)
h=h+hadd
@setbuttbh(peakbox2&,b,h)
@buttbh(plmax&,b,h)
h=h+hadd
@setbuttbh(plmax&,b,h)
@buttbh(prmax&,b,h)
h=h+hadd
@setbuttbh(prmax&,b,h)
IF smpedda=TRUE THEN
@rsc_back(nr)
ENDIF
nr=peak&
rscx&(nr)=xneu2
rscy&(nr)=yneu2-16
rscw&(nr)=bneu2+6
rsch&(nr)=hneu2+6+16
@setpos(peakbox&,xneu2+3,yneu2+3-16)
@buttbh(plmax&,v,peaksize)
wymax=peaksize
pkblk=wymax/9                  ! Einteilungs-Blockgroesse
pkrot=pkblk                      ! roter Bereich in Pixeln
pksix=pkrot+4*pkblk                ! -6db-Bereich
@readpos(pmdb1&)
by2=by-1
@readpos(pmdb2&)
by2=by2+pkblk
@setpos(pmdb2&,bx,by2)
@readpos(pmdb3&)
by2=by2+pkblk
@setpos(pmdb3&,bx,by2)
@readpos(pmdb4&)
by2=by2+pkblk
@setpos(pmdb4&,bx,by2)
@readpos(pmdb5&)
by2=by2+pkblk
@setpos(pmdb5&,bx,by2)
@readpos(pmdb6&)
by2=by2+pkblk
@setpos(pmdb6&,bx,by2)
@readpos(pmdb7&)
by2=by2+pkblk
@setpos(pmdb7&,bx,by2)
@readpos(pmdb8&)
by2=by2+pkblk
@setpos(pmdb8&,bx,by2)
@readpos(pmdb9&)
by2=by2+pkblk
@setpos(pmdb9&,bx,by2)
@readpos(pmdb10&)
by2=by2+pkblk
@setpos(pmdb10&,bx,by2)
wpl=0   ! peakhold left
wpr=0   ! peakhold right
vpl=0   ! peakhold left
vpr=0   ! peakhold right
pl=0   ! peakhold left
pr=0   ! peakhold right
@wischwasch
IF notopen=FALSE THEN
@rsc_draw(nr,7)
ENDIF
ENDIF
RETURN
'
> PROCEDURE calc_traksize
LOCAL v,hadd,hadd2,hadd4,q
IF ((freez=TRUE OR fcall=TRUE) AND notopen=TRUE) OR notopen=FALSE THEN
tcached=FALSE
IF bigfoot=FALSE THEN
IF bneu3<658 THEN
bneu3=658
ENDIF
IF hneu3<404 THEN
hneu3=404
ENDIF
ELSE
IF bneu3<1008 THEN
bneu3=1008
ENDIF
IF hneu3<692 THEN
hneu3=692
ENDIF
ENDIF
bneu3=bneu3-6
hneu3=hneu3-6
@buttbh(trakbox&,b,h)
badd=bneu3-b
badd2=INT(badd/2)
IF cefaddb2=FALSE THEN
cefaddb=16
cefaddb2=TRUE
ELSE
cefaddb=0
ENDIF
hadd=hneu3-h+cefaddb
hadd=INT(hadd/4)*4
hneu3=hadd+h-cefaddb
hadd2=hadd/2
hadd4=hadd/4
hadd8=hadd/8
@setbuttbh(trakbox&,bneu3,hneu3)
@readpos(trakbxw&)
bx=bx+badd2
by=by+hadd
@setpos(trakbxw&,bx,by)
@buttbh(trakedbx&,b,h)
b=b+badd
h=h+hadd
@setbuttbh(trakedbx&,b,h)
@buttbh(trakbox3&,b,h)
b=b+badd
@setbuttbh(trakbox3&,b,h)
@readpos(zoomslid&)
by=by+hadd
@setpos(zoomslid&,bx,by)
@readpos(zoomxl&)
by=by+hadd
@setpos(zoomxl&,bx,by)
@readpos(zoomxr&)
by=by+hadd
@setpos(zoomxr&,bx,by)
@readpos(trakxl&)
by=by+hadd
@setpos(trakxl&,bx,by)
@readpos(trakslid&)
by=by+hadd
@setpos(trakslid&,bx,by)
@buttbh(trakslid&,b,h)
b=b+badd
@setbuttbh(trakslid&,b,h)
@readpos(trakxr&)
bx=bx+badd
by=by+hadd
@setpos(trakxr&,bx,by)
@readpos(spuro&)
bx=bx+badd
@setpos(spuro&,bx,by)
@readpos(spurslid&)
bx=bx+badd
@setpos(spurslid&,bx,by)
@buttbh(spurslid&,b,h)
h=h+hadd
@setbuttbh(spurslid&,b,h)
@readpos(spuru&)
bx=bx+badd
by=by+hadd
@setpos(spuru&,bx,by)
@buttbh(trakbox5&,b,h)
h=h+hadd
@setbuttbh(trakbox5&,b,h)
@buttbh(trakbox2&,b,h)
b=b+badd
h=h+hadd
@setbuttbh(trakbox2&,b,h)
@readpos(traksall&)
bx=bx+badd
@setpos(traksall&,bx,by)
@readpos(traklall&)
bx=bx+badd
@setpos(traklall&,bx,by)
@readpos(trakload&)
bx=bx+badd
@setpos(trakload&,bx,by)
IF bigfoot=TRUE THEN
@readpos(trtfiler&)
bx=bx+badd
@setpos(trtfiler&,bx,by)
@readpos(trtfile&)
bx=bx+badd
@setpos(trtfile&,bx,by)
@readpos(trtfilel&)
bx=bx+badd
@setpos(trtfilel&,bx,by)
ENDIF
@readpos(trkbx1&)
@buttbh(trkbx1&,b,h)
h=h+hadd4
h3=h
@setbuttbh(trkbx1&,b,h)
by=by+h+2
@setpos(trkbx2&,bx,by)
@setbuttbh(trkbx2&,b,h)
by=by+h+2
@setpos(trkbx3&,bx,by)
@setbuttbh(trkbx3&,b,h)
by=by+h+2
@setpos(trkbx4&,bx,by)
@setbuttbh(trkbx4&,b,h)
h2=h
@buttbh(trakk1&,b,h)
@setbuttbh(trakk1&,b,h2)
@setbuttbh(trakk2&,b,h2)
@setbuttbh(trakk3&,b,h2)
@setbuttbh(trakk4&,b,h2)
IF bigfoot=FALSE THEN
@readpos(panr1&)
by=by+h3+2
@setpos(panr2&,bx,by)
by=by+h3+2
@setpos(panr3&,bx,by)
by=by+h3+2
@setpos(panr4&,bx,by)
ENDIF
@readpos(trkact1&)
by=by+hadd8
@setpos(trkact1&,bx,by)
@readpos(trkact2&)
by=by+hadd8
@setpos(trkact2&,bx,by)
@readpos(trkact3&)
by=by+hadd8
@setpos(trkact3&,bx,by)
@readpos(trkact4&)
by=by+hadd8
@setpos(trkact4&,bx,by)
@readpos(trksolo1&)
by=by+hadd8
@setpos(trksolo1&,bx,by)
@readpos(trksolo2&)
by=by+hadd8
@setpos(trksolo2&,bx,by)
@readpos(trksolo3&)
by=by+hadd8
@setpos(trksolo3&,bx,by)
@readpos(trksolo4&)
by=by+hadd8
@setpos(trksolo4&,bx,by)
@readpos(trkmute1&)
by=by+hadd8
@setpos(trkmute1&,bx,by)
@readpos(trkmute2&)
by=by+hadd8
@setpos(trkmute2&,bx,by)
@readpos(trkmute3&)
by=by+hadd8
@setpos(trkmute3&,bx,by)
@readpos(trkmute4&)
by=by+hadd8
@setpos(trkmute4&,bx,by)
@readpos(trklevo1&)
by=by+hadd8
@setpos(trklevo1&,bx,by)
@readpos(trklevo2&)
by=by+hadd8
@setpos(trklevo2&,bx,by)
@readpos(trklevo3&)
by=by+hadd8
@setpos(trklevo3&,bx,by)
@readpos(trklevo4&)
by=by+hadd8
@setpos(trklevo4&,bx,by)
@readpos(trklevu1&)
by=by+hadd8
@setpos(trklevu1&,bx,by)
@readpos(trklevu2&)
by=by+hadd8
@setpos(trklevu2&,bx,by)
@readpos(trklevu3&)
by=by+hadd8
@setpos(trklevu3&,bx,by)
@readpos(trklevu4&)
by=by+hadd8
@setpos(trklevu4&,bx,by)
@readpos(trklevt1&)
by=by+hadd8
@setpos(trklevt1&,bx,by)
@readpos(trklevt2&)
by=by+hadd8
@setpos(trklevt2&,bx,by)
@readpos(trklevt3&)
by=by+hadd8
@setpos(trklevt3&,bx,by)
@readpos(trklevt4&)
by=by+hadd8
@setpos(trklevt4&,bx,by)
@readpos(trktxt1&)
by=by+hadd8
@setpos(trktxt1&,bx,by)
@readpos(trktxt2&)
by=by+hadd8
@setpos(trktxt2&,bx,by)
@readpos(trktxt3&)
by=by+hadd8
@setpos(trktxt3&,bx,by)
@readpos(trktxt4&)
by=by+hadd8
@setpos(trktxt4&,bx,by)
@readpos(panl1&)
by=by+hadd8
@setpos(panl1&,bx,by)
@readpos(panl2&)
by=by+hadd8
@setpos(panl2&,bx,by)
@readpos(panl3&)
by=by+hadd8
@setpos(panl3&,bx,by)
@readpos(panl4&)
by=by+hadd8
@setpos(panl4&,bx,by)
@readpos(panr1&)
by=by+hadd8
@setpos(panr1&,bx,by)
@readpos(panr2&)
by=by+hadd8
@setpos(panr2&,bx,by)
@readpos(panr3&)
by=by+hadd8
@setpos(panr3&,bx,by)
@readpos(panr4&)
by=by+hadd8
@setpos(panr4&,bx,by)
@readpos(pantxt1&)
by=by+hadd8
@setpos(pantxt1&,bx,by)
@readpos(pantxt2&)
by=by+hadd8
@setpos(pantxt2&,bx,by)
@readpos(pantxt3&)
by=by+hadd8
@setpos(pantxt3&,bx,by)
@readpos(pantxt4&)
by=by+hadd8
@setpos(pantxt4&,bx,by)
@calc_trakboxes
IF smpedda=TRUE THEN
@rsc_back(nr)
ENDIF
nr=trakker&
rscx&(nr)=xneu3
rscy&(nr)=yneu3-18
rscw&(nr)=bneu3+6
rsch&(nr)=hneu3+6+16
@setpos(trakbox&,xneu3+3,yneu3+3-18)
IF notopen=TRUE THEN
@timeinit
ENDIF
@slidelen(trakslid&,trakxbut&,v,tscmax)
tscstep=tscmax/tmax
tscplus=tscstep/14
IF notopen=FALSE THEN
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
ENDIF
@wischwasch
IF notopen=FALSE THEN
tcached=FALSE
@rsc_draw(nr,7)
IF notopen=TRUE THEN
@timeinit2
ENDIF
IF toffs3>0 THEN
trakkz2=toffs2/toffs3*tscstep
ELSE
trakkz2=0
ENDIF
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
@setslide(spurslid&,spurybut&,trkvmax,5,trkvz)
ENDIF
ENDIF
RETURN
'
> PROCEDURE timekey
@setbutton(recti1&,0)
@setbutton(recti2&,0)
@setbutton(recti3&,0)
@setbutton(recti4&,0)
SELECT timekey
CASE 1
@setbutton(recti1&,1)
CASE 2
@setbutton(recti2&,1)
CASE 3
@setbutton(recti3&,1)
CASE 4
@setbutton(recti4&,1)
ENDSELECT
RETURN
'
> PROCEDURE nextwindow
LOCAL inx
inx=nr
REPEAT
IF lshft=FALSE AND rshft=FALSE THEN
INC inx
IF inx=32 THEN
inx=0
ENDIF
ELSE
DEC inx
IF inx<0 THEN
inx=31
ENDIF
ENDIF
IF BTST(winh,inx)=TRUE THEN
ENDIF
UNTIL BTST(winh,inx)=TRUE
nr=inx
@editselect
RETURN
'
> PROCEDURE shortcuts
LOCAL v
'  PRINT ascii|,scan|,dropkey
@windowtest
IF mywindow=TRUE THEN
IF nr=virtual& THEN
edit_obj&=0
next_obj&=0
ENDIF
IF fly=FALSE AND ctrlkey=TRUE AND altkey=FALSE THEN
IF ascii|=9 AND scan|=15 THEN    ! CTRL-TAB
@nextwindow
ENDIF
ENDIF
IF nr=plugin& THEN
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF lshft=FALSE AND rshft=FALSE THEN
plgc=-1
IF ascii|=ASC("1") THEN
plgobj=plgbox1&
lshft=TRUE
@plugregtest
ENDIF
IF ascii|=ASC("2") THEN
plgobj=plgbox2&
lshft=TRUE
@plugregtest
ENDIF
IF ascii|=ASC("3") THEN
plgobj=plgbox3&
lshft=TRUE
@plugregtest
ENDIF
IF ascii|=ASC("4") THEN
plgobj=plgbox4&
lshft=TRUE
@plugregtest
ENDIF
IF ascii|=ASC("5") THEN
plgobj=plgbox5&
lshft=TRUE
@plugregtest
ENDIF
IF ascii|=ASC("6") THEN
plgobj=plgbox6&
lshft=TRUE
@plugregtest
ENDIF
IF ascii|=ASC("7") THEN
plgobj=plgbox7&
lshft=TRUE
@plugregtest
ENDIF
IF ascii|=ASC("8") THEN
plgobj=plgbox8&
lshft=TRUE
@plugregtest
ENDIF
IF ascii|=ASC("9") THEN
plgobj=plgbox9&
lshft=TRUE
@plugregtest
ENDIF
IF ascii|=ASC("0") THEN
plgobj=plgbox10&
lshft=TRUE
@plugregtest
ENDIF
IF ascii|=32 THEN
plgobj=plgbox21&
lshft=TRUE
@plugregtest
ENDIF
ELSE
plgc=1
IF scan|=2 THEN
plgobj=plgbox1&
@plugregtest
ENDIF
IF scan|=3 THEN
plgobj=plgbox2&
@plugregtest
ENDIF
IF scan|=4 THEN
plgobj=plgbox3&
@plugregtest
ENDIF
IF scan|=5 THEN
plgobj=plgbox4&
@plugregtest
ENDIF
IF scan|=6 THEN
plgobj=plgbox5&
@plugregtest
ENDIF
IF scan|=7 THEN
plgobj=plgbox6&
@plugregtest
ENDIF
IF scan|=8 THEN
plgobj=plgbox7&
@plugregtest
ENDIF
IF scan|=9 THEN
plgobj=plgbox8&
@plugregtest
ENDIF
IF scan|=10 THEN
plgobj=plgbox9&
@plugregtest
ENDIF
IF scan|=11 THEN
plgobj=plgbox10&
@plugregtest
ENDIF
IF ascii|=32 THEN
plgobj=plgbox21&
@plugregtest
ENDIF
ENDIF
ENDIF
ENDIF
IF nr=trakker& THEN
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF ascii|=keyleft OR scan|=scanleft THEN
obj=trakxl&
@setbutton(obj,1)
PAUSE 2
@killpmark2
IF trakkz2>(tscmax-tscstep) THEN
trakkz2=tscmax-tscstep
ENDIF
@slideup2(trakslid&,trakxbut&,tscmax,tscstep,trakkz2,slflg)
@setbutton(trakxl&,0)
IF slflg=TRUE THEN
@timeinit2
@timeinit3
@timeline
ENDIF
ENDIF
IF ascii|=keyright OR scan|=scanright THEN
obj=trakxr&
@setbutton(obj,1)
PAUSE 2
@killpmark2
IF trakkz2>(tscmax-tscstep) THEN
trakkz2=tscmax-tscstep
ENDIF
@slidedwn2(trakslid&,trakxbut&,tscmax,tscstep,tscstep,trakkz2,slflg)
@setbutton(trakxr&,0)
IF slflg=TRUE THEN
@timeinit2
@timeinit3
@timeline
ENDIF
ENDIF
IF ascii|=55 THEN    ! POS 1
obj=trakanf&
@setbutton(obj,1)
PAUSE 2
@trkanf
ENDIF
IF ascii|=8 THEN     ! BACKSPACE
obj=smprpla2&
@setbutton(obj,1)
hz=thz
over=-mbit*2
@trkbackw
@setbutton(smprpla2&,0)
ENDIF
IF ascii|=32 THEN    ! SPACE
obj=smpplay3&
@setbutton(obj,1)
hz=thz
over=0
@trakforw
@setbutton(smpplay3&,0)
ENDIF
IF ascii|=14 THEN    ! PAUSE/UNDO
@setbutton(smpplay3&,1)
obj=pause2&
@setbutton(obj,1)
pwait=TRUE
@trakforw
@setbutton(smpplay3&,0)
@setbutton(pause2&,0)
ENDIF
IF ascii|=9 THEN     ! TAB
obj=forward2&
@setbutton(obj,1)
hz=thz
over=mbit*2
@trakforw
@setbutton(forward2&,0)
ENDIF
ELSE
IF ascii|=55 THEN    ! SHIFT POS 1
obj=trakfull&
@setbutton(obj,1)
PAUSE 2
@trkfull
ENDIF
IF ascii|=9 THEN     ! SHIFT-TAB
obj=rewind2&
@setbutton(obj,1)
hz=thz
over=-mbit*4
@trkbackw
@setbutton(rewind2&,0)
ENDIF
IF ascii|=32 OR ascii|=14 THEN    ! SHIFT-SPACE/PAUSE
obj=pause2&
@setbutton(obj,1)
obj=smpstrt4&
recpaus=TRUE
@setbutton(obj,1)
hrdmrk=hrd
hrd=1
wisch=TRUE
@smpstart
wisch=FALSE
@setbutton(smpstrt4&,0)
@setbutton(pause2&,0)
IF nofile=0 THEN
@rectotrak
ENDIF
hrd=hrdmrk
recpaus=FALSE
ENDIF
IF ascii|=keyleft THEN
@searchkeytrak(1)
ENDIF
IF ascii|=keyright THEN
@searchkeytrak(2)
ENDIF
ENDIF
IF ascii|=keydwn THEN
IF lshft=FALSE AND rshft=TRUE THEN
@searchkeytrak(4)
ELSE
IF lshft=FALSE AND rshft=FALSE THEN
INC trakact
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
trakact=trakact+4
ENDIF
IF trakact>(trkvmax-1) THEN
trakact=trkvmax-1
ENDIF
IF trakact>trkvz+4 THEN
vtrkvz=trakact-4
ENDIF
IF vtrkvz<0 THEN
vtrkvz=0
ENDIF
IF vtrkvz>(trkvmax-5) THEN
vtrkvz=trkvmax-5
ENDIF
IF vtrkvz<>trkvz THEN
trkvz=vtrkvz
@setslide(spurslid&,spurybut&,trkvmax-4,5,trkvz)
@spurbutt
@timeline
ENDIF
v=trakact-trkvz
SELECT v
CASE 1
obj=trakk1&
CASE 2
obj=trakk2&
CASE 3
obj=trakk3&
CASE 4
obj=trakk4&
ENDSELECT
@setbutton(trakk1&,0)
@setbutton(trakk2&,0)
@setbutton(trakk3&,0)
@setbutton(trakk4&,0)
@setbutton(obj,1)
ENDIF
ENDIF
IF ascii|=keyup THEN
IF lshft=FALSE AND rshft=TRUE THEN
@searchkeytrak(3)
ELSE
IF lshft=FALSE AND rshft=FALSE THEN
DEC trakact
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
trakact=trakact-4
ENDIF
IF trakact<1 THEN
trakact=1
ENDIF
IF trakact<=trkvz THEN
vtrkvz=trakact-1
ENDIF
IF vtrkvz<0 THEN
vtrkvz=0
ENDIF
IF vtrkvz>(trkvmax-5) THEN
vtrkvz=trkvmax-5
ENDIF
IF vtrkvz<>trkvz THEN
trkvz=vtrkvz
@setslide(spurslid&,spurybut&,trkvmax-4,5,trkvz)
@spurbutt
@timeline
ENDIF
v=trakact-trkvz
SELECT v
CASE 1
obj=trakk1&
CASE 2
obj=trakk2&
CASE 3
obj=trakk3&
CASE 4
obj=trakk4&
ENDSELECT
@setbutton(trakk1&,0)
@setbutton(trakk2&,0)
@setbutton(trakk3&,0)
@setbutton(trakk4&,0)
@setbutton(obj,1)
ENDIF
ENDIF
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE THEN    ! CTRL
IF rshft=FALSE AND lshft=TRUE THEN
IF ascii|=keyleft OR scan|=scanleft THEN
obj=zoomxl&
@setbutton(obj,1)
PAUSE 2
@trakzooml
ENDIF
IF ascii|=keyright OR scan|=scanright THEN
obj=zoomxr&
@setbutton(obj,1)
PAUSE 2
@trakzoomr
ENDIF
ENDIF
IF rshft=TRUE AND lshft=FALSE THEN
IF ascii|=keyleft OR scan|=scanleft THEN
obj=trakxl&
@setbutton(obj,1)
PAUSE 2
@ltrakscroll
ENDIF
IF ascii|=keyright OR scan|=scanright THEN
obj=trakxr&
@setbutton(obj,1)
PAUSE 2
@rtrakscroll
ENDIF
ENDIF
IF rshft=FALSE AND lshft=FALSE THEN
IF ascii|=32 THEN    ! CTRL-SPACE
obj=smpauto4&
@setbutton(obj,1)
wisch=TRUE
hrdmrk=hrd
hrd=1
@smpauto
@setbutton(smpauto4&,0)
IF nofile=0 THEN
@rectotrak
ENDIF
hrd=hrdmrk
wisch=FALSE
ENDIF
IF ascii|=keyup THEN
obj=trkvol&
@setbutton(obj,1)
stpy=trkvolume
DEC stpy
PAUSE 1
@trakkvol(stpy)
@setbutton(trkvol&,0)
ENDIF
IF ascii|=keydwn THEN
obj=trkvol&
@setbutton(obj,1)
stpy=trkvolume
INC stpy
PAUSE 1
@trakkvol(stpy)
@setbutton(trkvol&,0)
ENDIF
ELSE
IF ascii|=14 THEN        ! CTRL-SHFT N
v=trakact-trkvz
IF v>0 AND v<5 THEN
SELECT v
CASE 1
obj=trksolo1&
CASE 2
obj=trksolo2&
CASE 3
obj=trksolo3&
CASE 4
obj=trksolo4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@trkstereo
ENDIF
ENDIF
IF ascii|=13 THEN       ! CTRL-SHFT M
v=trakact-trkvz
IF v>0 AND v<5 THEN
SELECT v
CASE 1
obj=trkmute1&
CASE 2
obj=trkmute2&
CASE 3
obj=trkmute3&
CASE 4
obj=trkmute4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@trkmute
ENDIF
ENDIF
IF ascii|=12 THEN     ! CTRL-SHFT L
obj=trakload&
@setbutton(obj,1)
PAUSE 2
@trakload
ENDIF
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE THEN    ! ALT
IF ascii|=32 THEN    ! ALT-SPACE
obj=recplay2&
@setbutton(obj,1)
@trakrecplay
ENDIF
IF ascii|=ASC("T") THEN
v=trakact-trkvz
IF v>0 AND v<5 THEN
SELECT v
CASE 1
obj=trktxt1&
CASE 2
obj=trktxt2&
CASE 3
obj=trktxt3&
CASE 4
obj=trktxt4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@trktext
ENDIF
ENDIF
IF ascii|=ASC("A") THEN
v=trakact-trkvz
IF v>0 AND v<5 THEN
SELECT v
CASE 1
obj=trkact1&
CASE 2
obj=trkact2&
CASE 3
obj=trkact3&
CASE 4
obj=trkact4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@trkwahl
ENDIF
ENDIF
IF ascii|=ASC("B") THEN
obj=trkcd&
@setbutton(obj,1)
@trkmakecd
ENDIF
IF ascii|=ASC("K") THEN
obj=killtrak&
@setbutton(obj,1)
PAUSE 2
@killtrak
ENDIF
IF ascii|=ASC("M") THEN
obj=trkblk&
@setbutton(obj,1)
PAUSE 2
@trakblk
ENDIF
IF ascii|=ASC("W") THEN
obj=tblkplay&
@setbutton(obj,1)
@trakblkplay
ENDIF
IF ascii|=ASC("N") THEN
obj=trkcopy&
@setbutton(obj,1)
PAUSE 2
@trakcopy
ENDIF
IF ascii|=ASC("O") THEN
obj=trksolo&
@traksolo
IF tsolo=TRUE THEN
@setbutton(obj,1)
ELSE
@setbutton(obj,0)
ENDIF
ENDIF
IF ascii|=ASC("V") THEN
obj=tnamcom&
IF tncom=TRUE THEN
@setbutton(obj,0)
ELSE
@setbutton(obj,1)
ENDIF
@tnamcom
ENDIF
IF ascii|=ASC("C") THEN
obj=curve&
IF tvideo=TRUE THEN
@setbutton(obj,0)
ELSE
@setbutton(obj,1)
ENDIF
@trakcurve
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND (rshft=TRUE OR lshft=TRUE) THEN    ! ALT-SHFT
IF ascii|=ASC("G") THEN
obj=tblksel&
ntrmode=1
@tmarkmode
ENDIF
IF ascii|=ASC("D") THEN
obj=tblkmove&
ntrmode=2
@tmarkmode
ENDIF
IF ascii|=ASC("M") THEN
obj=tblkcopy&
ntrmode=3
@tmarkmode
ENDIF
IF ascii|=ASC("C") THEN
obj=tblkdrag&
ntrmode=4
@tmarkmode
ENDIF
IF ascii|=ASC("E") THEN
obj=tblkedit&
ntrmode=5
@tmarkmode
ENDIF
IF ascii|=ASC("F") THEN
obj=tblksnap&
ntrmode=6
@tmarkmode
ENDIF
IF ascii|=ASC("S") THEN
obj=tblkcut&
ntrmode=7
@tmarkmode
ENDIF
IF ascii|=ASC("V") THEN
obj=tblkvol&
ntrmode=8
@tmarkmode
ENDIF
IF ascii|=ASC("K") THEN
obj=trkdel&
@setbutton(obj,1)
PAUSE 2
@trakclr
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=TRUE    ! ALT-CTRL
IF rshft=FALSE AND lshft=FALSE THEN    ! ohne Shift
IF dropkey=50 THEN      ! ALT-CTRL M
dropkey=0
obj=trakplay&
@setbutton(obj,1)
PAUSE 2
hz=thz
@trkplay
ENDIF
IF ascii|=11 THEN      ! ALT-CTRL +
v=trakact-trkvz
IF v>0 AND v<5 THEN
SELECT v
CASE 1
obj=trklevo1&
CASE 2
obj=trklevo2&
CASE 3
obj=trklevo3&
CASE 4
obj=trklevo4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@trklevelup
ENDIF
ENDIF
IF ascii|=31 THEN      ! ALT-CTRL -
v=trakact-trkvz
IF v>0 AND v<5 THEN
SELECT v
CASE 1
obj=trklevu1&
CASE 2
obj=trklevu2&
CASE 3
obj=trklevu3&
CASE 4
obj=trklevu4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@trkleveldown
ENDIF
ENDIF
IF ascii|=28 THEN      ! ALT-CTRL <
v=trakact-trkvz
IF v>0 AND v<5 THEN
SELECT v
CASE 1
obj=panl1&
CASE 2
obj=panl2&
CASE 3
obj=panl3&
CASE 4
obj=panl4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@trkpanleft
ENDIF
ENDIF
IF ascii|=18 THEN    ! ALT-CTRL R
SELECT spuren
CASE 2
obj=trk8&
v=8
CASE 4
obj=trk12&
v=12
CASE 6
obj=trk16&
v=16
CASE 8
obj=trk4&
v=4
ENDSELECT
@setbutton(trk4&,0)
@setbutton(trk8&,0)
@setbutton(trk12&,0)
@setbutton(trk16&,0)
@setbutton(obj,1)
PAUSE 2
@spuren(v)
ENDIF
IF ascii|=2 THEN      ! ALT-CTRL B
obj=tpstrt&
@setbutton(obj,1)
PAUSE 2
@edtpstart
ENDIF
IF ascii|=6 THEN      ! ALT-CTRL F
obj=tpend&
@setbutton(obj,1)
PAUSE 2
@edtpend
ENDIF
IF ascii|=12 THEN      ! ALT-CTRL L
obj=hlpedit3&
@setbutton(obj,1)
PAUSE 2
@traksearch
ENDIF
IF ascii|=24 THEN      ! ALT-CTRL X
obj=hrdmerg2&
@setbutton(obj,1)
PAUSE 2
@downmix
ENDIF
IF ascii|=4 THEN      ! ALT-CTRL D
obj=trakdel&
@setbutton(obj,1)
PAUSE 2
@trakdel
ENDIF
IF ascii|=19 THEN      ! ALT-CTRL S
obj=trakstrt&
@setbutton(obj,1)
PAUSE 2
@trkstrt
ENDIF
IF ascii|=5 THEN      ! ALT-CTRL E
obj=trakend&
@setbutton(obj,1)
PAUSE 2
@trkend
ENDIF
IF ascii|=20 THEN      ! ALT-CTRL T
obj=trksmpte&
@setbutton(obj,1)
PAUSE 2
@trksmpte_edit
ENDIF
ELSE
IF ascii|=30 THEN      ! ALT-CTRL >
v=trakact-trkvz
IF v>0 AND v<5 THEN
SELECT v
CASE 1
obj=panlr&
CASE 2
obj=panr2&
CASE 3
obj=panr3&
CASE 4
obj=panr4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@trkpanright
ENDIF
ENDIF
ENDIF
IF rshft=FALSE AND lshft=TRUE THEN    ! +LSHFT
IF ascii|=19 THEN      ! ALT-CTRL LSHFT S
obj=strtl&
@setbutton(obj,1)
PAUSE 2
@juststart
ENDIF
IF ascii|=5 THEN      ! ALT-CTRL LSHFT E
obj=lend&
@setbutton(obj,1)
PAUSE 2
@justend
ENDIF
IF ascii|=20 THEN      ! ALT-CTRL LSHFT T
obj=ltime&
@setbutton(obj,1)
PAUSE 2
@justtime
ENDIF
IF ascii|=2 THEN      ! ALT-CTRL LSHFT B
obj=tpsl&
@setbutton(obj,1)
PAUSE 2
@justpstart
ENDIF
IF ascii|=6 THEN      ! ALT-CTRL LSHFT F
obj=tpel&
@setbutton(obj,1)
PAUSE 2
@justpend
ENDIF
ENDIF
IF rshft=TRUE AND lshft=FALSE THEN    ! +RSHFT
IF ascii|=19 THEN      ! ALT-CTRL RSHFT S
obj=strtr&
@setbutton(obj,1)
PAUSE 2
@juststart
ENDIF
IF ascii|=5 THEN      ! ALT-CTRL RSHFT E
obj=rend&
@setbutton(obj,1)
PAUSE 2
@justend
ENDIF
IF ascii|=20 THEN      ! ALT-CTRL RSHFT T
obj=rtime&
@setbutton(obj,1)
PAUSE 2
@justtime
ENDIF
IF ascii|=2 THEN      ! ALT-CTRL RSHFT B
obj=tpsr&
@setbutton(obj,1)
PAUSE 2
@justpstart
ENDIF
IF ascii|=6 THEN      ! ALT-CTRL RSHFT F
obj=tper&
@setbutton(obj,1)
PAUSE 2
@justpend
ENDIF
ENDIF
ENDIF
ENDIF
IF nr=peak& THEN
@peakkeys
IF altkey=FALSE AND ctrlkey=TRUE AND rshft=FALSE AND lshft=FALSE THEN    ! CTRL
IF ascii|=32 THEN    ! CTRL-SPACE
obj=smpautop&
@setbutton(obj,1)
@recautopeak
ENDIF
ENDIF
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF ascii|=14 THEN    ! PAUSE
@setbutton(playpeak&,1)
obj=peakwait&
@setbutton(obj,1)
@playpeak
ENDIF
IF ascii|=32 THEN    ! SPACE
obj=playpeak&
@setbutton(obj,1)
@playpeak
ENDIF
ELSE
IF ascii|=14 OR ascii|=32 THEN    ! SHIFT PAUSE/SPACE
obj=peakwait&
recpaus=TRUE
@setbutton(obj,1)
obj=smpstrtp&
@setbutton(obj,1)
@recpeak
recpaus=FALSE
ENDIF
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE THEN    ! ALT
IF ascii|=ASC("H") THEN
obj=hardpeak&
IF virtual=FALSE THEN
@harddisk
ELSE
@setbutton(obj,1)
ENDIF
ENDIF
IF adat=TRUE OR rch8=TRUE THEN
IF ascii|=ASC("1") THEN
obj=peakch1&
@channelrec
ENDIF
IF ascii|=ASC("2") THEN
obj=peakch2&
@channelrec
ENDIF
IF ascii|=ASC("3") THEN
obj=peakch3&
@channelrec
ENDIF
IF ascii|=ASC("4") THEN
obj=peakch4&
@channelrec
ENDIF
ENDIF
ENDIF
ENDIF
IF nr=arranger& THEN
IF altkey=FALSE AND ctrlkey=TRUE AND rshft=FALSE AND lshft=FALSE THEN    ! CTRL
IF ascii|=32 THEN    ! CTRL-SPACE
obj=smpauto3&
@setbutton(obj,1)
hrdmrk=hrd
hrd=1
@smpauto
@rectoarr
hrd=hrdmrk
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=TRUE AND rshft=FALSE AND lshft=FALSE THEN    ! ALT-CTRL
IF ascii|=9 THEN      ! ALT-CTRL I
obj=arrins&
@setbutton(obj,1)
PAUSE 2
@arrinsdrt
ENDIF
IF ascii|=4 THEN      ! ALT-CTRL D
obj=arrdel&
@setbutton(obj,1)
PAUSE 2
@arrdelete
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND (rshft=TRUE OR lshft=TRUE) THEN    ! ALT-SHIFT
IF ascii|=ASC("D") THEN
v=arrherr-pbz
SELECT v
CASE 1
obj=arrdel1&
CASE 2
obj=arrdel2&
CASE 3
obj=arrdel3&
CASE 4
obj=arrdel4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@arrdel
ENDIF
IF ascii|=ASC("L") THEN
v=arrherr-pbz
SELECT v
CASE 1
obj=arrtri1&
CASE 2
obj=arrtri2&
CASE 3
obj=arrtri3&
CASE 4
obj=arrtri4&
ENDSELECT
@arrtristate
ENDIF
IF ascii|=ASC(">") THEN
obj=hardend&
@setbutton(obj,1)
PAUSE 2
@hardend
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE THEN    ! ALT
IF ascii|=32 THEN    ! ALT-SPACE
obj=recplay&
@setbutton(obj,1)
@recplay
ENDIF
IF ascii|=ASC("<") THEN
obj=hardstrt&
@setbutton(obj,1)
PAUSE 2
@hardstrt
ENDIF
IF ascii|=ASC("T") THEN
obj=arreal&
IF realtime=FALSE THEN
@setbutton(obj,1)
ELSE
@setbutton(obj,0)
ENDIF
@realarr
ENDIF
IF ascii|=ASC("W") THEN
v=arrherr-pbz
SELECT v
CASE 1
obj=arrplay1&
CASE 2
obj=arrplay2&
CASE 3
obj=arrplay3&
CASE 4
obj=arrplay4&
ENDSELECT
@setbutton(obj,1)
@arrplay
ENDIF
IF ascii|=ASC("M") THEN
obj=arrblk&
IF realtime=FALSE THEN
@setbutton(obj,1)
ELSE
@setbutton(obj,0)
ENDIF
@arrblkset
ENDIF
IF ascii|=ASC("K") THEN
obj=arrtrash&
@setbutton(obj,1)
PAUSE 2
@arrkill
ENDIF
IF ascii|=ASC("F") THEN
v=arrherr-pbz
SELECT v
CASE 1
obj=spur1&
CASE 2
obj=spur2&
CASE 3
obj=spur3&
CASE 4
obj=spur4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@hardfs
ENDIF
IF ascii|=ASC("R") THEN
v=arrherr-pbz
SELECT v
CASE 1
obj=arrsmpr1&
CASE 2
obj=arrsmpr2&
CASE 3
obj=arrsmpr3&
CASE 4
obj=arrsmpr4&
ENDSELECT
@setbutton(obj,1)
PAUSE 2
@arrsmpr
ENDIF
IF ascii|=ASC("L") THEN
v=arrherr-pbz
SELECT v
CASE 1
obj=arrloop1&
CASE 2
obj=arrloop2&
CASE 3
obj=arrloop3&
CASE 4
obj=arrloop4&
ENDSELECT
IF arrloop!(pbz+v)=FALSE THEN
@setbutton(obj,1)
ELSE
@setbutton(obj,0)
ENDIF
@arrloop
ENDIF
IF ascii|=ASC("N") THEN
v=arrherr-pbz
SELECT v
CASE 1
obj=arrnote1&
CASE 2
obj=arrnote2&
CASE 3
obj=arrnote3&
CASE 4
obj=arrnote4&
ENDSELECT
@setbutton(obj,1)
vobj=obj
@arrmidi
@setbutton(vobj,0)
ENDIF
ENDIF
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF ascii|=55 THEN    ! POS 1
obj=arrstrt&
@setbutton(obj,1)
@arrstrt
ENDIF
IF ascii|=8 THEN     ! BACKSPACE
obj=smprplay&
@setbutton(obj,1)
over=-mbit*2
@mbackw
@setbutton(smprplay&,0)
ENDIF
IF ascii|=32 THEN    ! SPACE
obj=smpplay2&
@setbutton(obj,1)
over=0
@mforw
@setbutton(smpplay2&,0)
ENDIF
IF ascii|=14 THEN    ! PAUSE/UNDO
@setbutton(smpplay2&,1)
obj=pause&
@setbutton(obj,1)
pwait=TRUE
@mforw
ENDIF
IF ascii|=9 THEN     ! TAB
obj=forward&
@setbutton(obj,1)
@arr_forward
ENDIF
ELSE
IF ascii|=55 THEN    ! SHIFT POS 1
obj=arrend&
@setbutton(obj,1)
@arrend
ENDIF
IF ascii|=9 THEN     ! SHIFT-TAB
obj=rewind&
@setbutton(obj,1)
@arr_rewind
ENDIF
IF ascii|=32 OR ascii|=14 THEN    ! SHIFT-SPACE/PAUSE
obj=pause&
@setbutton(obj,1)
obj=smpstrt3&
recpaus=TRUE
@setbutton(obj,1)
hrdmrk=hrd
hrd=1
@smpstart
@setbutton(pause&,0)
@rectoarr
hrd=hrdmrk
recpaus=FALSE
ENDIF
ENDIF
IF ascii|=keyright THEN
v=arrherr-pbz
SELECT v
CASE 1
obj=arrm1&
CASE 2
obj=arrm2&
CASE 3
obj=arrm3&
CASE 4
obj=arrm4&
ENDSELECT
@arrtowork
ENDIF
IF ascii|=keydwn THEN
IF lshft=FALSE AND rshft=FALSE THEN
INC arrherr
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
arrherr=arrherr+4
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
arrherr=arrherr+12
ENDIF
IF arrherr>lmax2 THEN
arrherr=lmax2
ENDIF
vpbz=INT((arrherr-1)/4)*4
IF vpbz<>pbz THEN
pbz=vpbz
@setslide(arrslide&,arrslbut&,slmax,5,pbz)
@arrnrset
ENDIF
v=arrherr-pbz
SELECT v
CASE 1
obj=arrm1&
CASE 2
obj=arrm2&
CASE 3
obj=arrm3&
CASE 4
obj=arrm4&
ENDSELECT
@setbutton(arrm1&,0)
@setbutton(arrm2&,0)
@setbutton(arrm3&,0)
@setbutton(arrm4&,0)
@setbutton(obj,1)
ENDIF
IF ascii|=keyup THEN
IF lshft=FALSE AND rshft=FALSE THEN
DEC arrherr
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
arrherr=arrherr-4
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
arrherr=arrherr-12
ENDIF
IF arrherr<1 THEN
arrherr=1
ENDIF
vpbz=INT((arrherr-1)/4)*4
IF vpbz<>pbz THEN
pbz=vpbz
@setslide(arrslide&,arrslbut&,slmax,5,pbz)
@arrnrset
ENDIF
v=arrherr-pbz
SELECT v
CASE 1
obj=arrm1&
CASE 2
obj=arrm2&
CASE 3
obj=arrm3&
CASE 4
obj=arrm4&
ENDSELECT
@setbutton(arrm1&,0)
@setbutton(arrm2&,0)
@setbutton(arrm3&,0)
@setbutton(arrm4&,0)
@setbutton(obj,1)
ENDIF
ENDIF
ENDIF
IF nr=smpedit& THEN
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF ascii|=32 THEN    ! SPACE
obj=smpplay&
@setbutton(obj,1)
@smpplay
ENDIF
IF ascii|=14 THEN    ! PAUSE/UNDO
@setbutton(smpplay&,1)
obj=smpwait&
@setbutton(obj,1)
pwait=TRUE
@smpplay
ENDIF
ELSE
IF ascii|=14 OR ascii|=32 THEN    ! SHIFT PAUSE/SPACE
obj=smpwait&
recpaus=TRUE
@setbutton(obj,1)
obj=smpstrt2&
@setbutton(obj,1)
@smpstart
@setbutton(smpwait&,0)
@rectocurve
recpaus=FALSE
ENDIF
ENDIF
IF ascii|=keydwn THEN
@setbutton(edmdown&,1)
IF lshft=FALSE AND rshft=FALSE THEN
@slidedwn(edmslide&,edmbut&,loopz,1,5,vsms,slflg)
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
@slidedwn(edmslide&,edmbut&,loopz,5,5,vsms,slflg)
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
@slidedwn(edmslide&,edmbut&,loopz,10,5,vsms,slflg)
ENDIF
IF slflg=TRUE THEN
@edslidemove(vsms+1)
ENDIF
PAUSE 2
@setbutton(edmdown&,0)
ENDIF
IF ascii|=keyup THEN
@setbutton(edmup&,1)
IF lshft=FALSE AND rshft=FALSE THEN
@slideup(edmslide&,edmbut&,loopz,1,5,vsms,slflg)
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
@slideup(edmslide&,edmbut&,loopz,5,5,vsms,slflg)
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
@slideup(edmslide&,edmbut&,loopz,10,5,vsms,slflg)
ENDIF
IF slflg=TRUE THEN
@edslidemove(vsms+1)
ENDIF
PAUSE 2
@setbutton(edmup&,0)
ENDIF
IF scan|=scanleft OR ascii|=keyleft THEN
IF lshft=FALSE AND rshft=FALSE THEN
obj=smpl1&
@setbutton(obj,1)
@smpl
PAUSE 2
@setbutton(obj,0)
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
obj=smpl2&
@setbutton(obj,1)
@smpl
PAUSE 2
@setbutton(obj,0)
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
obj=smpl3&
@setbutton(obj,1)
@smpl
PAUSE 2
@setbutton(obj,0)
ENDIF
ENDIF
IF scan|=scanright OR ascii|=keyright THEN
IF lshft=FALSE AND rshft=FALSE THEN
obj=smpr1&
@setbutton(obj,1)
@smpr
PAUSE 2
@setbutton(obj,0)
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
obj=smpr2&
@setbutton(obj,1)
@smpr
PAUSE 2
@setbutton(obj,0)
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
obj=smpr3&
@setbutton(obj,1)
@smpr
PAUSE 2
@setbutton(obj,0)
ENDIF
ENDIF
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE AND rshft=TRUE AND lshft=FALSE AND (ascii|=keyleft OR scan|=scanleft) THEN
@setbutton(lscroll&,1)
@edleftscroll
PAUSE 2
@setbutton(lscroll&,0)
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE AND rshft=TRUE AND lshft=FALSE AND (ascii|=keyright OR scan|=scanright) THEN
@setbutton(rscroll&,1)
@edrightscroll
PAUSE 2
@setbutton(rscroll&,0)
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE AND rshft=FALSE AND lshft=TRUE AND (ascii|=keyleft OR scan|=scanleft) THEN
@setbutton(zooml&,1)
@edleftzoom
@setbutton(zooml&,0)
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE AND rshft=FALSE AND lshft=TRUE AND (ascii|=keyright OR scan|=scanright) THEN
@setbutton(zoomr&,1)
@edrightzoom
@setbutton(zoomr&,0)
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE AND ascii|=ASC("V") THEN
vtedart=tedart
@viewset
tedart=vtedart
@hztext
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND (rshft=TRUE OR lshft=TRUE) THEN    ! ALT-SHFT
IF ascii|=ASC("N") THEN
obj=edmnr&
@setbutton(obj,1)
vsms=@marknrinp(sms)
ENDIF
IF ascii|=ASC("P") THEN
obj=swmark&
@setbutton(obj,1)
nmarkmode=1
@setmarkmode
ENDIF
IF ascii|=ASC("B") THEN
obj=swblk&
@setbutton(obj,1)
nmarkmode=2
@setmarkmode
ENDIF
IF ascii|=ASC("H") THEN
obj=scrubs&
@setbutton(obj,1)
nmarkmode=3
@setmarkmode
ENDIF
IF ascii|=ASC("L") THEN
obj=swsearch&
@setbutton(obj,1)
nmarkmode=4
@setmarkmode
ENDIF
IF ascii|=ASC("Z") THEN
obj=swyzoom&
@setbutton(obj,1)
nmarkmode=5
@setmarkmode
ENDIF
IF ascii|=ASC("C") THEN
obj=swclick&
@setbutton(obj,1)
nmarkmode=6
@setmarkmode
ENDIF
IF ascii|=ASC("D") THEN
obj=swdraw&
@setbutton(obj,1)
nmarkmode=7
@setmarkmode
ENDIF
IF ascii|=ASC("M") THEN
obj=smpmid&
@setbutton(obj,1)
PAUSE 2
@smpmid
ENDIF
IF ascii|=ASC(">") THEN
obj=smpend&
@setbutton(obj,1)
PAUSE 2
@smpend
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN    ! lshift
IF ascii|=ASC("S") THEN
@setbutton(edmbute&,0)
@setbutton(edmbuti&,0)
@setbutton(edmbutr&,0)
obj=edmbuts&
@setbutton(obj,1)
@smpstx(sms,1)
ENDIF
IF ascii|=ASC("E") THEN
@setbutton(edmbuts&,0)
@setbutton(edmbuti&,0)
@setbutton(edmbutr&,0)
obj=edmbute&
@setbutton(obj,1)
@smpstx(sms,2)
ENDIF
IF ascii|=ASC("I") THEN
@setbutton(edmbuts&,0)
@setbutton(edmbute&,0)
@setbutton(edmbutr&,0)
obj=edmbuti&
@setbutton(obj,1)
@smpstx(sms,3)
ENDIF
IF ascii|=ASC("O") THEN
@setbutton(edmbuts&,0)
@setbutton(edmbute&,0)
@setbutton(edmbuti&,0)
obj=edmbutr&
@setbutton(obj,1)
@smpstx(sms,4)
ENDIF
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN    ! rshift
IF ascii|=ASC("S") THEN
obj=edmtims&
@setbutton(obj,1)
@time_edit
@setbutton(obj,0)
ENDIF
IF ascii|=ASC("E") THEN
obj=edmtime&
@setbutton(obj,1)
@time_edit
@setbutton(obj,0)
ENDIF
IF ascii|=ASC("I") THEN
obj=edmtimi&
@setbutton(obj,1)
@time_edit
@setbutton(obj,0)
ENDIF
IF ascii|=ASC("O") THEN
obj=edmtimr&
@setbutton(obj,1)
@time_edit
@setbutton(obj,0)
ENDIF
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE THEN    ! ALT
IF ascii|=32 THEN    ! ALT-SPACE
obj=recplay3&
@setbutton(obj,1)
@smpstart
ENDIF
IF ascii|=ASC("H") THEN
obj=hard&
IF virtual=FALSE THEN
@harddisk
ELSE
@setbutton(obj,1)
ENDIF
ENDIF
IF ascii|=ASC("Z") THEN
obj=pixzoom&
@setbutton(obj,1)
PAUSE 2
@zoomtopixel
ENDIF
IF ascii|=ASC("I") THEN
IF ad=1 THEN
@digital
ELSE
@analog
ENDIF
ENDIF
IF ascii|=ASC("J") THEN
SELECT digsource
CASE 0
@coax
CASE 1
@aesebu
CASE 2
@opto
ENDSELECT
ENDIF
IF ascii|=ASC("E") THEN
SELECT dspw
CASE 0
@dspin
CASE 1
@dspout
CASE 2
@dspoff
ENDSELECT
ENDIF
IF ascii|=ASC("O") THEN
SELECT sret
CASE 0
@loopret
CASE 1
@loopcross
CASE 2
@loopfor
ENDSELECT
ENDIF
IF ascii|=ASC("Y") THEN
IF extclock=FALSE THEN
IF digana=FALSE THEN
digana=TRUE
ELSE
digana=FALSE
IF demo=FALSE THEN
~XBIOS(xbs,23,0)          ! Taktrate=spdif
ENDIF
ENDIF
@sethertz
@makehz
ENDIF
ENDIF
IF ascii|=ASC("G") THEN
IF grids=0 THEN
grids=1
ELSE
grids=0
ENDIF
@restaura
ENDIF
IF ascii|=ASC("A") THEN
IF yzoom=FALSE THEN
yzoom=TRUE
ELSE
yzoom=FALSE
ENDIF
@restaura
ENDIF
IF ascii|=ASC("<") THEN
obj=smpanf&
@setbutton(obj,1)
PAUSE 2
@smpanf
ENDIF
IF ascii|=ASC("K") THEN
obj=trash&
@setbutton(obj,1)
PAUSE 2
@trash
ENDIF
IF ascii|=ASC("C") THEN
'        PRINT "clip"
ENDIF
IF ascii|=ASC("L") THEN
obj=smploop&
@smploop
IF sloop!=TRUE THEN
@setbutton(obj,1)
ELSE
@setbutton(obj,0)
ENDIF
ENDIF
IF ascii|=ASC("M") THEN
obj=smppmark&
@smppmark
IF sblock=1 THEN
@setbutton(obj,1)
ELSE
@setbutton(obj,0)
ENDIF
ENDIF
IF ascii|=ASC("N") THEN
obj=midi&
@machmidi
IF mamidi=1 THEN
@setbutton(obj,1)
ELSE
@setbutton(obj,0)
ENDIF
ENDIF
IF ascii|=ASC("W") THEN
obj=smpcblk&
@setbutton(obj,1)
PAUSE 2
@smpcblkplay
@setbutton(smpcblk&,0)
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=TRUE THEN    ! ALT-CTRL
IF rshft=FALSE AND lshft=FALSE THEN    ! no shift
IF ascii|=28 THEN         ! ALT-CTRL-<
obj=cstxt&
@setbutton(obj,1)
@time_edit
@setbutton(obj,0)
ENDIF
IF ascii|=12 THEN         ! ALT-CTRL-L
obj=smplen&
@setbutton(obj,1)
@smplen
ENDIF
IF ascii|=8 THEN          ! ALT-CTRL-H
IF yline=FALSE THEN
yline=TRUE
ELSE
yline=FALSE
ENDIF
@restaura
ENDIF
IF ascii|=22 THEN         ! ALT-CTRL-V
IF spacefill=TRUE THEN
vspacefill=FALSE
vlinkdot=FALSE
vvertline=TRUE
ENDIF
IF spacefill=FALSE AND linkdot=FALSE AND vertline=TRUE THEN
vspacefill=FALSE
vlinkdot=TRUE
vvertline=FALSE
ENDIF
IF spacefill=FALSE AND linkdot=TRUE AND vertline=FALSE THEN
vspacefill=FALSE
vlinkdot=TRUE
vvertline=TRUE
ENDIF
IF spacefill=FALSE AND linkdot=TRUE AND vertline=TRUE THEN
vspacefill=TRUE
vlinkdot=FALSE
vvertline=FALSE
ENDIF
spacefill=vspacefill
linkdot=vlinkdot
vertline=vvertline
@restaura
ENDIF
IF ascii|=20 THEN         ! ALT-CTRL-T
obj=smpsec&
@setbutton(obj,1)
@smpsec
ENDIF
IF ascii|=9 THEN          ! ALT-CTRL-I
obj=smpfile&
@setbutton(obj,1)
PAUSE 2
@smpinfbutt
ENDIF
IF ascii|=2 THEN          ! ALT-CTRL-B
obj=clock&
@setbutton(obj,1)
@abackup
ENDIF
IF ascii|=5 THEN          ! ALT-CTRL-E
obj=edmtxt&
@setbutton(obj,1)
@edmtextin
ENDIF
ENDIF
IF rshft=TRUE OR lshft=TRUE THEN    ! ALT-CTRL-SHFT
IF ascii|=30 THEN         ! ALT-CTRL >
obj=cetxt&
@setbutton(obj,1)
@time_edit
@setbutton(obj,0)
ENDIF
ENDIF
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE AND rshft=FALSE AND lshft=FALSE THEN    ! CTRL
IF ascii|=9 AND scan|<>15 THEN           ! CTRL I
@setbutton(infoicon&,1)
@info
ENDIF
IF ascii|=32 THEN    ! CTRL-SPACE
obj=smpauto2&
@setbutton(obj,1)
@smpauto
IF breakrec=FALSE THEN
@rectocurve
ENDIF
@setbutton(smpwait&,0)
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE AND ascii|=ASC("B") THEN
g=0
@trash
IF g=1 THEN
IF dig24=FALSE THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
tdig24=dig24   ! fÅr Tracker
tmbit=mbit     ! fÅr Tracker
@fnamwrite
@hztext
@restaura3
cached=FALSE
credraw=TRUE
@curve(cs,ce)
@blkupdate
credraw=FALSE
@getcurve
ENDIF
ENDIF
ENDIF
IF nr=record& THEN
IF altkey=FALSE AND ctrlkey=TRUE THEN
IF ascii|=keyleft OR scan|=scanleft THEN   ! CTRL-LEFT
DEC timekey
IF timekey<1 THEN
timekey=4
ENDIF
@timekey
ENDIF
IF ascii|=keyright OR scan|=scanright THEN   ! CTRL-RIGHT
INC timekey
IF timekey>4 THEN
timekey=1
ENDIF
@timekey
ENDIF
scan|=0
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE THEN
IF dropkey=80 THEN                       ! DOWN
IF lshft=FALSE AND rshft=FALSE THEN
SELECT timekey
CASE 1
keyobj=tinpdl1&
CASE 2
keyobj=tinpdl2&
CASE 3
keyobj=tinpdl3&
CASE 4
keyobj=tinpdl4&
ENDSELECT
ELSE
SELECT timekey
CASE 1
keyobj=tinpdh1&
CASE 2
keyobj=tinpdh2&
CASE 3
keyobj=tinpdh3&
CASE 4
keyobj=tinpdh4&
ENDSELECT
ENDIF
@setbutton(keyobj,1)
PAUSE 2
doexit=TRUE
ENDIF
IF dropkey=72 THEN                      ! UP
IF lshft=FALSE AND rshft=FALSE THEN
SELECT timekey
CASE 1
keyobj=tinpul1&
CASE 2
keyobj=tinpul2&
CASE 3
keyobj=tinpul3&
CASE 4
keyobj=tinpul4&
ENDSELECT
ELSE
SELECT timekey
CASE 1
keyobj=tinpuh1&
CASE 2
keyobj=tinpuh2&
CASE 3
keyobj=tinpuh3&
CASE 4
keyobj=tinpuh4&
ENDSELECT
ENDIF
@setbutton(keyobj,1)
doexit=TRUE
PAUSE 2
ENDIF
dropkey=0
ENDIF
ENDIF
IF nr=setup& AND ctrlkey=TRUE THEN
IF ascii|=keyleft OR scan|=scanleft THEN   ! CTRL-LEFT
IF nokey=TRUE OR (altkey=FALSE AND lshft=FALSE AND rshft=FALSE) THEN
obj=secl&
@setbutton(obj,1)
@secbutt
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND lshft=TRUE AND rshft=FALSE THEN
obj=tresl&
@setbutton(obj,1)
@tresbutt
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND lshft=FALSE AND rshft=TRUE THEN
obj=recl&
@setbutton(obj,1)
@recbutt
PAUSE 2
@setbutton(obj,0)
ENDIF
ENDIF
IF ascii|=keyright OR scan|=scanright THEN   ! CTRL-RIGHT
IF nokey=TRUE OR (altkey=FALSE AND lshft=FALSE AND rshft=FALSE) THEN
obj=secr&
@setbutton(obj,1)
@secbutt
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND lshft=TRUE AND rshft=FALSE THEN
obj=tresr&
@setbutton(obj,1)
@tresbutt
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND lshft=FALSE AND rshft=TRUE THEN
obj=recr&
@setbutton(obj,1)
@recbutt
PAUSE 2
@setbutton(obj,0)
ENDIF
ENDIF
ENDIF
IF nr=clocks& THEN
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF ascii|=keydwn THEN
@setbutton(clkdown&,1)
IF lshft=FALSE AND rshft=FALSE THEN
@slidedwn(clkslid&,clkbut&,cdivz,1,5,vcdivsms,slflg)
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
@slidedwn(clkslid&,clkbut&,cdivz,5,5,vcdivsms,slflg)
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
@slidedwn(clkslid&,clkbut&,cdivz,10,5,vcdivsms,slflg)
ENDIF
IF slflg=TRUE THEN
@clocklook(vcdivsms+1)
ENDIF
PAUSE 2
@setbutton(clkdown&,0)
ENDIF
IF ascii|=keyup THEN
@setbutton(clkup&,1)
IF lshft=FALSE AND rshft=FALSE THEN
@slideup(clkslid&,clkbut&,cdivz,1,5,vcdivsms,slflg)
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
@slideup(clkslid&,clkbut&,cdivz,5,5,vcdivsms,slflg)
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
@slideup(clkslid&,clkbut&,cdivz,10,5,vcdivsms,slflg)
ENDIF
IF slflg=TRUE THEN
@clocklook(vcdivsms+1)
ENDIF
PAUSE 2
@setbutton(clkup&,0)
ENDIF
ENDIF
ENDIF
IF nr=savebloc& THEN
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE THEN
IF ascii|=ASC("A") THEN
keyobj=savall&
@setbutton(keyobj,1)
PAUSE 2
doexit=TRUE
ENDIF
IF ascii|=ASC("B") THEN
keyobj=savblock&
@setbutton(keyobj,1)
PAUSE 2
doexit=TRUE
ENDIF
ENDIF
ENDIF
IF nr=cuelist& THEN
IF altkey=FALSE AND ctrlkey=TRUE THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF dropkey=80 THEN    ! DOWN
obj=cuesldwn&
@setbutton(obj,1)
IF lshft=FALSE AND rshft=FALSE THEN
@cue_down
ENDIF
@setbutton(cuesldwn&,0)
ENDIF
IF dropkey=72 THEN    ! UP
obj=cueslup&
@setbutton(obj,1)
IF lshft=FALSE AND rshft=FALSE THEN
@cue_up
ENDIF
@setbutton(cueslup&,0)
ENDIF
ELSE
IF dropkey=80 THEN    ! DOWN
obj=cuesldwn&
@setbutton(obj,1)
IF lshft=TRUE AND rshft=FALSE THEN
cuez=cuez+5
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
cuez=cuez+10
ENDIF
IF cuez>cuemax-10 THEN
cuez=cuemax-10
ENDIF
ENDIF
IF dropkey=72 THEN    ! UP
obj=cueslup&
@setbutton(obj,1)
IF lshft=TRUE AND rshft=FALSE THEN
cuez=cuez-5
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
cuez=cuez-10
ENDIF
IF cuez<0 THEN
cuez=0
ENDIF
ENDIF
cuesz2=cuesmax/cuemax*cuez
@setslide2(cueslide&,cueslbut&,cuesmax,cuesz2,cuestep)
@cueshow
IF dropkey=80 THEN    ! DOWN
@setbutton(cuesldwn&,0)
ENDIF
IF dropkey=72 THEN    ! UP
@setbutton(cueslup&,0)
ENDIF
ENDIF
dropkey=0
ENDIF
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF ascii|=32 THEN    ! SPACE
obj=cueplay&
@setbutton(obj,1)
@cueplay
ENDIF
IF ascii|=14 THEN    ! PAUSE/UNDO
@setbutton(cueplay&,1)
obj=cuewait&
@setbutton(obj,1)
pwait=TRUE
@cueplay
@setbutton(cuewait&,0)
ENDIF
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE THEN
IF ascii|=ASC("M") THEN
obj=cuemix&
@setbutton(obj,1)
@cuemixdown
ENDIF
IF ascii|=ASC("B") THEN
obj=cuecd&
@setbutton(obj,1)
@cuemakecd
ENDIF
IF ascii|=ASC("K") THEN
obj=cuekill&
@setbutton(obj,1)
@cuekiller
PAUSE 2
@setbutton(cuekill&,0)
ENDIF
ENDIF
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF ascii|=keydwn THEN
IF cuep=0 THEN
cuep=1
ENDIF
IF lshft=FALSE AND rshft=FALSE THEN
INC cuep
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
cuep=cuep+5
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
cuep=cuep+10
ENDIF
IF cuep>cuemax THEN
cuep=cuemax
ENDIF
IF cuep<=cuez OR cuep>cuez+10 THEN
REPEAT
IF cuep<=cuez THEN
cuez=cuez-10
ENDIF
IF cuep>cuez+10 THEN
cuez=cuez+10
ENDIF
UNTIL cuep>cuez AND cuep<cuez+11
cuesz2=cuesmax/cuemax*cuez
@setslide2(cueslide&,cueslbut&,cuesmax,cuesz2,cuestep)
@cueshow
ENDIF
obj=cuenr1&+(cuep-cuez-1)
@setbutton(obj,1)
@cuenumber
ENDIF
IF ascii|=keyup THEN
IF lshft=FALSE AND rshft=FALSE THEN
DEC cuep
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
cuep=cuep-5
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
cuep=cuep-10
ENDIF
IF cuep<1 THEN
cuep=1
ENDIF
IF cuep<=cuez OR cuep>cuez+10 THEN
REPEAT
IF cuep<=cuez THEN
cuez=cuez-10
ENDIF
IF cuep>cuez+10 THEN
cuez=cuez+10
ENDIF
UNTIL cuep>cuez AND cuep<cuez+11
cuesz2=cuesmax/cuemax*cuez
@setslide2(cueslide&,cueslbut&,cuesmax,cuesz2,cuestep)
@cueshow
ENDIF
obj=cuenr1&+(cuep-cuez-1)
@setbutton(obj,1)
@cuenumber
ENDIF
ENDIF
ENDIF
IF nr=virtual& THEN
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF ascii|=32 THEN    ! SPACE
obj=virtplay&
@setbutton(obj,1)
edit_obj&=0
next_obj&=0
@virtplay
ENDIF
ENDIF
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE THEN
IF ascii|=keyleft OR scan|=scanleft THEN   ! CTRL-LEFT
obj=vlslide&
@setbutton(obj,1)
IF lshft=FALSE AND rshft=FALSE THEN
@virtleft
ELSE
hbgm=(smplen/mt)       ! Einteilungsanzahl
@slideup2(vslider&,vslbut&,lslide,hbreit,hbz,slflg)
IF slflg=TRUE THEN
vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
~OBJC_EDIT(zu%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
edit_obj&=vblkstrt&
@blkart
ENDIF
idx&=LEN(a$)
next_obj&=0
ENDIF
PAUSE 2
@setbutton(vlslide&,0)
ENDIF
IF ascii|=keyright OR scan|=scanright THEN   ! CTRL-RIGHT
obj=vrslide&
@setbutton(obj,1)
IF lshft=FALSE AND rshft=FALSE THEN
@virtright
ELSE
hbgm=(smplen/mt)       ! Einteilungsanzahl
@slidedwn2(vslider&,vslbut&,lslide,hbreit,hbreit,hbz,slflg)
IF slflg=TRUE THEN
vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
~OBJC_EDIT(zu%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
edit_obj&=vblkstrt&
@blkart
ENDIF
idx&=LEN(a$)
next_obj&=0
ENDIF
PAUSE 2
@setbutton(vrslide&,0)
ENDIF
ENDIF
ENDIF
IF nr=dspedit& THEN
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF ascii|>0 AND ascii|<11 THEN     ! F1-F10
obj=dspslot0&+(ascii|-1)
FOR v=0 TO 9
@setbutton(dspslot0&+v,0)
NEXT v
@setbutton(obj,1)
@dspslots
ENDIF
IF ascii|=keydwn THEN
obj=dspsldwn&
@setbutton(obj,1)
IF lshft=FALSE AND rshft=FALSE THEN
@dspdown
ELSE
@slidedwn2(dspslide&,dspslbut&,dspsmax,dspstep,dspstep,dspsz2,slflg)
IF slflg=TRUE THEN
@dsp_butset
ENDIF
next_obj&=0
ENDIF
PAUSE 2
@setbutton(dspsldwn&,0)
ENDIF
IF ascii|=keyup THEN
obj=dspslup&
@setbutton(obj,1)
IF lshft=FALSE AND rshft=FALSE THEN
@dspup
ELSE
@slideup2(dspslide&,dspslbut&,dspsmax,dspstep,dspsz2,slflg)
IF slflg=TRUE THEN
@dsp_butset
ENDIF
next_obj&=0
ENDIF
PAUSE 2
@setbutton(dspslup&,0)
ENDIF
ENDIF
ENDIF
IF nr=fsel& THEN
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF tfselm=FALSE THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF ascii|=14 THEN    ! PAUSE
@setbutton(fsplay&,1)
obj=fswait&
@setbutton(obj,1)
@fselplay
ENDIF
IF ascii|=32 THEN    ! SPACE
obj=fsplay&
@setbutton(obj,1)
@fselplay
ENDIF
ELSE
IF ascii|=32 THEN    ! SHIFT-SPACE
obj=fslplay&
@setbutton(obj,1)
@fselplay
ENDIF
ENDIF
ENDIF
IF ascii|=keydwn THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF tfselm=FALSE THEN
IF actfsel=0 OR (actfsel>fsz AND actfsel<fsz+fsl) THEN
IF actfsel=0 THEN
actfsel=fsz
ENDIF
INC actfsel
mfsz=actfsel
n=actfsel-fsz
obj=fsbut1&+n-1
@getsel3
@setbutton(obj,1)
nfk=n
mfsz=fsz+nfk
ENDIF
ELSE
IF tmfsz=0 OR (tmfsz>tfsz AND tmfsz<tfsz+fsl) THEN
IF tmfsz=0 THEN
tmfsz=fsz
ENDIF
INC tmfsz
n=tmfsz-tfsz
obj=fsbut1&+n-1
@tfsgetsel3
@setbutton(obj,1)
tnfk=n
tmfsz=tfsz+tnfk
ENDIF
ENDIF
ELSE
obj=fsslddwn&
@setbutton(obj,1)
IF lshft=TRUE AND rshft=FALSE THEN
IF tfselm=FALSE THEN
@fseldown
ELSE
@fselsearchdown
ENDIF
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
IF tfselm=FALSE THEN
xfsz=fsz
@slidedwn2(fsslide&,fssldbut&,fsmax,fstep,fstep,fsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@fscalc
IF actfsel>0 THEN
actfsel=actfsel-xfsz+fsz
mfsz=actfsel
ENDIF
@fsbutset
@getsel2
ENDIF
ELSE
xfsz=tfsz
@slidedwn2(fsslide&,fssldbut&,tfsmax,tfstep,tfstep,tfsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@tfscalc
IF tmfsz>0 THEN
tmfsz=tmfsz-xfsz+tfsz
ENDIF
@tfsbutset
@tfsgetsel2
ENDIF
ENDIF
ENDIF
PAUSE 2
@setbutton(fsslddwn&,0)
ENDIF
ENDIF
IF ascii|=keyup THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF tfselm=FALSE THEN
IF actfsel>fsz+1 AND actfsel<fsz+fsl+1 THEN
DEC actfsel
mfsz=actfsel
n=actfsel-fsz
obj=fsbut1&+n-1
@getsel3
@setbutton(obj,1)
nfk=n
mfsz=fsz+nfk
ENDIF
ELSE
IF tmfsz>tfsz+1 AND tmfsz<tfsz+fsl+1 THEN
DEC tmfsz
n=tmfsz-tfsz
obj=fsbut1&+n-1
@tfsgetsel3
@setbutton(obj,1)
tnfk=n
tmfsz=tfsz+tnfk
ENDIF
ENDIF
ELSE
obj=fssldup&
@setbutton(obj,1)
IF lshft=TRUE AND rshft=FALSE THEN
IF tfselm=FALSE THEN
@fselup
ELSE
@fselsearchup
ENDIF
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
IF tfselm=FALSE THEN
xfsz=fsz
@slideup2(fsslide&,fssldbut&,fsmax,fstep,fsz2,slflg)
@setbutton(fssldup&,0)
IF slflg=TRUE THEN
@clearfsel
@fscalc
IF actfsel>0 THEN
actfsel=actfsel-xfsz+fsz
mfsz=actfsel
ENDIF
@fsbutset
@getsel2
ENDIF
ELSE
xfsz=tfsz
@slideup2(fsslide&,fssldbut&,tfsmax,tfstep,tfsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@tfscalc
IF tmfsz>0 THEN
tmfsz=tmfsz-xfsz+tfsz
ENDIF
@tfsbutset
@tfsgetsel2
ENDIF
ENDIF
ENDIF
PAUSE 2
@setbutton(fssldup&,0)
ENDIF
ENDIF
ENDIF
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE THEN
IF tfselm=FALSE THEN
IF ascii|=ASC("C") THEN
obj=fsmatic&
@setbutton(obj,1)
@fselswitch
PAUSE 2
@setbutton(fsmatic&,0)
ENDIF
IF ascii|=ASC("K") THEN
obj=fsclf&
@setbutton(obj,1)
@killfsel
PAUSE 2
@setbutton(fsclf&,0)
ENDIF
IF fsmplay=FALSE THEN
IF ascii|=ASC("I") THEN
obj=fsins&
@setbutton(obj,1)
@fselinsert
PAUSE 2
@setbutton(fsins&,0)
ENDIF
ELSE
IF ascii|=ASC("D") THEN
obj=fsdel&
@setbutton(obj,1)
@fseldelete
PAUSE 2
@setbutton(fsdel&,0)
ENDIF
IF ascii|=ASC("L") THEN
obj=fsload&
@setbutton(obj,1)
@loadfsel
PAUSE 2
@setbutton(fsload&,0)
ENDIF
IF ascii|=ASC("S") THEN
obj=fssave&
@setbutton(obj,1)
@savefsel
PAUSE 2
@setbutton(fssave&,0)
ENDIF
ENDIF
ELSE
IF ascii|=ASC("C") THEN
obj=tfsabc&
@tfselabc
ENDIF
ENDIF
ENDIF
ENDIF
IF nr=mrkfind& THEN
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF ascii|=keydwn THEN
@setbutton(mrkfdown&,1)
IF lshft=FALSE AND rshft=FALSE THEN
@slidedwn(mrkfslid&,mrkfbut&,loopz,1,5,vedsms,slflg)
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
@slidedwn(mrkfslid&,mrkfbut&,loopz,5,5,vedsms,slflg)
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
@slidedwn(mrkfslid&,mrkfbut&,loopz,10,5,vedsms,slflg)
ENDIF
IF slflg=TRUE THEN
@mrkfslidemove(vedsms+1)
ENDIF
PAUSE 2
@setbutton(mrkfdown&,0)
ENDIF
IF ascii|=keyup THEN
@setbutton(mrkfup&,1)
IF lshft=FALSE AND rshft=FALSE THEN
@slideup(mrkfslid&,mrkfbut&,loopz,1,5,vedsms,slflg)
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
@slideup(mrkfslid&,mrkfbut&,loopz,5,5,vedsms,slflg)
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
@slideup(mrkfslid&,mrkfbut&,loopz,10,5,vedsms,slflg)
ENDIF
IF slflg=TRUE THEN
@mrkfslidemove(vedsms+1)
ENDIF
PAUSE 2
@setbutton(mrkfup&,0)
ENDIF
ENDIF
ENDIF
IF nr=disked& THEN
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE THEN
IF ascii|=ASC("K") THEN
obj=dskill&
@setbutton(obj,1)
@killdisk
PAUSE 2
@setbutton(dskill&,0)
ENDIF
IF ascii|=ASC("R") THEN
obj=dskren&
@setbutton(obj,1)
@rendisk
PAUSE 2
@setbutton(dskren&,0)
ENDIF
IF ascii|=ASC("C") THEN
obj=dskopie&
@setbutton(obj,1)
@changedisk
PAUSE 2
@setbutton(dskopie&,0)
ENDIF
ENDIF
ENDIF
IF nr=abackup& THEN
IF nokey=TRUE OR altkey=FALSE THEN
IF ascii|=keyleft OR scan|=scanleft THEN   ! CTRL-LEFT
IF lshft=FALSE AND rshft=FALSE THEN
obj=abackl1&
@setbutton(obj,1)
ELSE
obj=abackl2&
@setbutton(obj,1)
ENDIF
PAUSE 2
@abackl
ENDIF
IF ascii|=keyright OR scan|=scanright THEN   ! CTRL-RIGHT
IF lshft=FALSE AND rshft=FALSE THEN
obj=abackr1&
@setbutton(obj,1)
ELSE
obj=abackr2&
@setbutton(obj,1)
ENDIF
PAUSE 2
@abackr
ENDIF
ENDIF
ENDIF
IF nr=midiedit& THEN
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF ascii|=keydwn THEN
IF lshft=FALSE AND rshft=FALSE THEN
obj=midicdwn&
@setbutton(obj,1)
@channeldown
PAUSE 2
@setbutton(obj,0)
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
obj=midindwn&
@setbutton(obj,1)
@notedown
PAUSE 2
@setbutton(obj,0)
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
obj=midiodwn&
@setbutton(obj,1)
@oktdown
PAUSE 2
@setbutton(obj,0)
ENDIF
ENDIF
IF ascii|=keyup THEN
IF lshft=FALSE AND rshft=FALSE THEN
obj=midicup&
@setbutton(obj,1)
@channelup
PAUSE 2
@setbutton(obj,0)
ENDIF
IF lshft=TRUE AND rshft=FALSE THEN
obj=midinup&
@setbutton(obj,1)
@noteup
PAUSE 2
@setbutton(obj,0)
ENDIF
IF lshft=FALSE AND rshft=TRUE THEN
obj=midioup&
@setbutton(obj,1)
@oktup
PAUSE 2
@setbutton(obj,0)
ENDIF
ENDIF
ENDIF
ENDIF
IF nr=resample& THEN
IF scan|=scanleft THEN   ! CTRL-LEFT
IF altkey=FALSE AND ctrlkey=TRUE AND lshft=FALSE AND rshft=FALSE THEN
obj=resl1&
@setbutton(obj,1)
@resl
@resmptxt
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE AND lshft=TRUE AND rshft=FALSE THEN
obj=resl2&
@setbutton(obj,1)
@resl
@resmptxt
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE AND lshft=FALSE AND rshft=TRUE THEN
obj=resl3&
@setbutton(obj,1)
@resl
@resmptxt
PAUSE 2
@setbutton(obj,0)
ENDIF
ENDIF
IF scan|=scanright THEN   ! CTRL-RIGHT
IF altkey=FALSE AND ctrlkey=TRUE AND lshft=FALSE AND rshft=FALSE THEN
obj=resr1&
@setbutton(obj,1)
@resr
@resmptxt
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE AND lshft=TRUE AND rshft=FALSE THEN
obj=resr2&
@setbutton(obj,1)
@resr
@resmptxt
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND ctrlkey=TRUE AND lshft=FALSE AND rshft=TRUE THEN
obj=resr3&
@setbutton(obj,1)
@resr
@resmptxt
PAUSE 2
@setbutton(obj,0)
ENDIF
ENDIF
ENDIF
IF nr=normaliz& AND norma=0 THEN
IF ascii|=keyleft OR scan|=scanleft THEN   ! CTRL-LEFT
IF nokey=TRUE OR (altkey=FALSE AND lshft=FALSE AND rshft=FALSE) THEN
obj=norml1&
@setbutton(obj,1)
@norml
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND lshft=TRUE AND rshft=FALSE THEN
obj=norml2&
@setbutton(obj,1)
@norml
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND lshft=FALSE AND rshft=TRUE THEN
obj=norml3&
@setbutton(obj,1)
@norml
PAUSE 2
@setbutton(obj,0)
ENDIF
ENDIF
IF ascii|=keyright OR scan|=scanright THEN   ! CTRL-RIGHT
IF nokey=TRUE OR (altkey=FALSE AND lshft=FALSE AND rshft=FALSE) THEN
obj=normr1&
@setbutton(obj,1)
@normr
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND lshft=TRUE AND rshft=FALSE THEN
obj=normr2&
@setbutton(obj,1)
@normr
PAUSE 2
@setbutton(obj,0)
ENDIF
IF altkey=FALSE AND lshft=FALSE AND rshft=TRUE THEN
obj=normr3&
@setbutton(obj,1)
@normr
PAUSE 2
@setbutton(obj,0)
ENDIF
ENDIF
ENDIF
IF nr=blkfunc& THEN
IF altkey=TRUE AND ctrlkey=FALSE THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF ascii|=ASC("I") THEN
obj=cutin&
@smpcut
ENDIF
IF ascii|=ASC("O") THEN
obj=cutout&
@smpcut
ENDIF
IF ascii|=ASC("D") THEN
obj=cutdel&
@smpcut
ENDIF
IF ascii|=ASC("A") THEN
obj=conins&
@setbutton(obj,1)
@coninsert
ENDIF
IF ascii|=ASC("S") THEN
obj=conspace&
@setbutton(obj,1)
@conspace
ENDIF
IF ascii|=ASC("N") THEN
obj=negate&
@setbutton(obj,1)
blkobj=obj
@workblock
ENDIF
IF ascii|=ASC("P") THEN
obj=norm&
@setbutton(obj,1)
@normalize
ENDIF
IF ascii|=ASC("R") THEN
obj=resmp&
@setbutton(obj,1)
@resample
ENDIF
IF ascii|=ASC("M") THEN
obj=mono&
@setbutton(obj,1)
blkobj=obj
@workblock
ENDIF
IF ascii|=ASC("C") THEN
obj=lrchange&
@setbutton(obj,1)
blkobj=obj
@workblock
ENDIF
IF ascii|=ASC("B") THEN
obj=conv16&
@setbutton(obj,1)
blkobj=obj
@makebitconv
ENDIF
ELSE
IF ascii|=ASC("B") THEN
obj=conv24&
@setbutton(obj,1)
blkobj=obj
@makebitconv
ENDIF
ENDIF
ENDIF
ENDIF
obj=0
obj&=0
key&=0
ENDIF
RETURN
'
> PROCEDURE peakkeys
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE THEN    ! ALT
IF ascii|=ASC("Z") THEN
obj=peakmute&
@peakmute
ENDIF
IF ascii|=ASC("M") THEN
obj=balzero&
@setbutton(obj,1)
PAUSE 2
@peakzero
ENDIF
IF ascii|=ASC("V") THEN
obj=volinout&
@volswitch
ENDIF
ENDIF
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF ascii|=keyleft OR scan|=scanleft THEN
obj=balance&
@setbutton(obj,1)
IF vio=FALSE THEN
px=volinbal
ELSE
px=volinbal2
ENDIF
IF px>=-pxmax THEN
DEC px
ENDIF
scpxv=px
PAUSE 1
@peakbalance(scpxv)
@setbutton(balance&,0)
ENDIF
IF ascii|=keyright OR scan|=scanright THEN
obj=balance&
@setbutton(obj,1)
IF vio=FALSE THEN
px=volinbal
ELSE
px=volinbal2
ENDIF
IF px<(pxmax) THEN
INC px
ENDIF
scpxv=px
PAUSE 1
@peakbalance(scpxv)
@setbutton(balance&,0)
ENDIF
IF ascii|=keyup THEN
obj=volume&
@setbutton(obj,1)
IF bigtxt=FALSE THEN
pydist=190
ELSE
pydist=290
ENDIF
IF pyi>0 THEN
DEC pyi
ENDIF
scpy=pyi
PAUSE 1
@peakvolume(scpy)
@setbutton(volume&,0)
ENDIF
IF ascii|=keydwn THEN
obj=volume&
@setbutton(obj,1)
IF bigtxt=FALSE THEN
pydist=190
ELSE
pydist=290
ENDIF
IF pyi<pymax THEN
INC pyi
ENDIF
scpy=pyi
PAUSE 1
@peakvolume(scpy)
@setbutton(volume&,0)
ENDIF
ELSE
IF ascii|=keyleft THEN
obj=lphold&
@setbutton(obj,1)
PAUSE 2
@lpeakhold
ENDIF
IF ascii|=keyright THEN
obj=rphold&
@setbutton(obj,1)
PAUSE 2
@rpeakhold
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE peakkeys2
IF nr=peak& THEN
~@xrsrc_gaddr(0,peak&,zu%)
IF altkey=TRUE AND ctrlkey=FALSE AND rshft=FALSE AND lshft=FALSE THEN    ! ALT
IF scan|=21 THEN   ! ALT Z
obj=peakmute&
@peakmute
obj=0
ENDIF
IF scan|=50 THEN   ! ALT M
obj=balzero&
@setbutton(obj,1)
@peakzero
obj=0
ENDIF
IF scan|=47 THEN   ! ALT V
obj=volinout&
@volswitch
obj=0
ENDIF
ENDIF
IF nokey=TRUE OR (altkey=FALSE AND ctrlkey=FALSE) THEN
IF lshft=FALSE AND rshft=FALSE THEN
IF scan|=75 THEN
obj=balance&
@setbutton(obj,1)
IF vio=FALSE THEN
px=volinbal
ELSE
px=volinbal2
ENDIF
IF px>=-pxmax THEN
DEC px
ENDIF
scpxv=px
@peakbalance(scpxv)
@setbutton(balance&,0)
obj=0
ENDIF
IF scan|=77 THEN
obj=balance&
@setbutton(obj,1)
IF vio=FALSE THEN
px=volinbal
ELSE
px=volinbal2
ENDIF
IF px<(pxmax) THEN
INC px
ENDIF
scpxv=px
@peakbalance(scpxv)
@setbutton(balance&,0)
obj=0
ENDIF
IF scan|=72 THEN
obj=volume&
@setbutton(obj,1)
IF bigtxt=FALSE THEN
pydist=190
ELSE
pydist=290
ENDIF
IF pyi>0 THEN
DEC pyi
ENDIF
scpy=pyi
@peakvolume(scpy)
@setbutton(volume&,0)
obj=0
ENDIF
IF scan|=80 THEN
obj=volume&
@setbutton(obj,1)
IF bigtxt=FALSE THEN
pydist=190
ELSE
pydist=290
ENDIF
IF pyi<pymax THEN
INC pyi
ENDIF
scpy=pyi
@peakvolume(scpy)
@setbutton(volume&,0)
obj=0
ENDIF
ELSE
IF ascii|=keyleft THEN
obj=lphold&
@setbutton(obj,1)
@lpeakhold
obj=0
ENDIF
IF ascii|=keyright THEN
obj=rphold&
@setbutton(obj,1)
@rpeakhold
obj=0
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE shortcuts2       ! keypress stop & wait-in
@windowtest
IF mywindow=TRUE THEN
IF nr=fsel& AND tfselm=FALSE THEN
IF ascii|=27 THEN    ! ESC
obj=fsstop&
@setbutton(obj,1)
@breakstop
@setbutton(fsstop&,0)
ENDIF
IF ascii|=8 THEN    ! BACKSPACE
obj=fsend&
@setbutton(obj,1)
@breakstop
@setbutton(fsend&,0)
ENDIF
IF scan|=97 THEN    ! PAUSE/UNDO
obj=fswait&
@setbutton(obj,1)
@breakwait
ENDIF
ENDIF
IF nr=trakker& THEN
IF ascii|=27 THEN    ! ESC
obj=stop2&
@setbutton(obj,1)
@breakstop
@setbutton(stop2&,0)
@setbutton(smpplay3&,0)
ENDIF
IF scan|=97 THEN    ! PAUSE/UNDO
obj=pause2&
@setbutton(obj,1)
@breakwait
ENDIF
ENDIF
IF nr=arranger& THEN
IF ascii|=27 THEN    ! ESC
obj=stop&
@setbutton(obj,1)
@breakstop
@setbutton(stop&,0)
@setbutton(smpplay2&,0)
ENDIF
IF scan|=97 THEN    ! PAUSE/UNDO
obj=pause&
@setbutton(obj,1)
@breakwait
ENDIF
ENDIF
IF nr=peak& THEN
@keycheck
IF ascii|<>27 AND scan|<>97 THEN
@peakkeys2
ENDIF
IF ascii|=27 THEN    ! ESC
obj=playstop&
@setbutton(obj,1)
@breakstop
@setbutton(playstop&,0)
ENDIF
IF scan|=97 THEN    ! PAUSE/UNDO
obj=peakwait&
@setbutton(obj,1)
@breakwait
ENDIF
ENDIF
IF nr=cuelist& THEN
IF ascii|=27 THEN    ! ESC
obj=cuestop&
@setbutton(obj,1)
@breakstop
@setbutton(cuestop&,0)
ENDIF
IF scan|=97 THEN    ! PAUSE/UNDO
obj=cuewait&
@setbutton(obj,1)
@breakwait
ENDIF
ENDIF
IF nr=virtual& THEN
IF ascii|=27 THEN    ! ESC
obj=virtstop&
@setbutton(obj,1)
@breakstop
ENDIF
ENDIF
IF nr=smpedit& THEN
IF ascii|=27 THEN    ! ESC
obj=smpstop&
@setbutton(obj,1)
@breakstop
ENDIF
IF scan|=97 THEN    ! PAUSE/UNDO
obj=smpwait&
@setbutton(obj,1)
@breakwait
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE shortcuts3       ! keypress wait-out
@windowtest
IF mywindow=TRUE THEN
IF nr=fsel& AND tfselm=FALSE THEN
IF scan|=97 THEN    ! PAUSE/UNDO
obj=fswait&
@setbutton(obj,0)
ENDIF
IF ascii|=27 THEN    ! ESC
obj=fsstop&
@setbutton(obj,1)
@breakstop
@setbutton(fsstop&,0)
ENDIF
ENDIF
IF nr=trakker& THEN
IF scan|=97 THEN    ! PAUSE/UNDO
obj=pause2&
@setbutton(obj,0)
ENDIF
IF ascii|=27 THEN    ! ESC
obj=stop2&
@setbutton(obj,1)
@breakstop
@setbutton(stop2&,0)
@setbutton(smpplay3&,0)
ENDIF
ENDIF
IF nr=arranger& THEN
IF scan|=97 THEN    ! PAUSE/UNDO
obj=pause&
@setbutton(obj,0)
ENDIF
IF ascii|=27 THEN    ! ESC
obj=stop&
@setbutton(obj,1)
@breakstop
@setbutton(stop&,0)
@setbutton(smpplay2&,0)
ENDIF
ENDIF
IF nr=peak& THEN
IF scan|=97 THEN    ! PAUSE/UNDO
obj=peakwait&
@setbutton(obj,0)
ENDIF
IF ascii|=27 THEN    ! ESC
obj=playstop&
@setbutton(obj,1)
@breakstop
@setbutton(playstop&,0)
ENDIF
ENDIF
IF nr=cuelist& THEN
IF scan|=97 THEN    ! PAUSE/UNDO
obj=cuewait&
@setbutton(obj,0)
ENDIF
IF ascii|=27 THEN    ! ESC
obj=cuestop&
@setbutton(obj,1)
@breakstop
@setbutton(cuestop&,0)
ENDIF
ENDIF
IF nr=smpedit& THEN
IF scan|=97 THEN    ! PAUSE/UNDO
obj=smpwait&
@setbutton(obj,0)
ENDIF
IF ascii|=27 THEN    ! ESC
obj=smpstop&
@setbutton(obj,1)
@breakstop
ENDIF
ENDIF
ENDIF
RETURN
'
> FUNCTION hzanalye(hzl)     ! Analysiert die Samplerate und findet passende Taktrate
LOCAL hzl2,hzlf,hze1,hze2,hze3,hze4
hzl2=hzl/100   ! 1% Abweichung
hzlf=FALSE
hze1=INT(masterclk/768)
hze2=INT(masterclk/512)
hze3=INT(masterclk/384)
hze4=INT(masterclk/256)
IF pcg=TRUE THEN
IF hzl>0 THEN
@setpcg(hzl)
synchertz=pcgfreq
hzlyse=freqhz
cdivsms=3
@setsync
ENDIF
ELSE
IF hzl>(8000-hzl2) AND hzl<(8000+hzl2) THEN
hzlyse=8000
hzlf=TRUE
ENDIF
IF hzl>(11025-hzl2) AND hzl<(11025+hzl2) THEN
hzlyse=11025
hzlf=TRUE
ENDIF
IF hzl>(12000-hzl2) AND hzl<(12000+hzl2) THEN
hzlyse=12000
hzlf=TRUE
ENDIF
IF hzl>(16000-hzl2) AND hzl<(16000+hzl2) THEN
hzlyse=16000
hzlf=TRUE
ENDIF
IF hzl>(16538-hzl2) AND hzl<(16538+hzl2) THEN
hzlyse=16538
hzlf=TRUE
ENDIF
IF hzl>(22050-hzl2) AND hzl<(22050+hzl2) THEN
hzlyse=22050
hzlf=TRUE
ENDIF
IF hzl>(24000-hzl2) AND hzl<(24000+hzl2) THEN
hzlyse=24000
hzlf=TRUE
ENDIF
IF hzl>(33075-hzl2) AND hzl<(33075+hzl2) THEN
hzlyse=33075
hzlf=TRUE
ENDIF
IF hzl>(32000-hzl2) AND hzl<(32000+hzl2) THEN
hzlyse=32000
hzlf=TRUE
ENDIF
IF hzl>(44100-hzl2) AND hzl<(44100+hzl2) THEN
hzlyse=44100
hzlf=TRUE
ENDIF
IF hzl>(48000-hzl2) AND hzl<(48000+hzl2) THEN
hzlyse=48000
hzlf=TRUE
ENDIF
IF hzl>(88200-hzl2) AND hzl<(88200+hzl2) THEN
hzlyse=88200
hzlf=TRUE
ENDIF
IF hzl>(96000-hzl2) AND hzl<(96000+hzl2) THEN
hzlyse=96000
hzlf=TRUE
ENDIF
IF hzl>(hze1-hzl2) AND hzl<(hze1+hzl2) THEN
hzlyse=hze1
hzlf=TRUE
ENDIF
IF hzl>(hze2-hzl2) AND hzl<(hze2+hzl2) THEN
hzlyse=hze2
hzlf=TRUE
ENDIF
IF hzl>(hze3-hzl2) AND hzl<(hze3+hzl2) THEN
hzlyse=hze3
hzlf=TRUE
ENDIF
IF hzl>(hze4-hzl2) AND hzl<(hze4+hzl2) THEN
hzlyse=hze4
hzlf=TRUE
ENDIF
IF hzlf=FALSE THEN
hzlyse=INT(hzl)
ENDIF
ENDIF
RETURN hzlyse
ENDFUNC
'
> PROCEDURE formatsmp        ! formatiert die samplewert-anzeigen
sc$=""
s=LEN(a$)
REPEAT
IF s>3 THEN
sc$="."+RIGHT$(a$,3)+sc$
a$=LEFT$(a$,s-3)
s=s-3
ENDIF
UNTIL s<4
IF s>0 THEN
sc$=a$+sc$
ENDIF
a$=sc$
IF LEN(a$)>13 THEN
a$=LEFT$(a$,13)
ENDIF
RETURN
'
> PROCEDURE initplugins
LOCAL d$,d,dta,da,n$,i,a,dn,plnam$,nam,p,b,c,found,n,h,f$,f2$,f3$,f4$,n2$,k,m$,lf,lfget
ptest=@malloc(600,0)
IF ptest>0 THEN
@plugfinder
d$=s$+cpuord$+"*."+plug$+CHR$(0)
d=VARPTR(d$)
dta=GEMDOS(47)   ! fgetdta
da=GEMDOS(78,L:d,0)
IF da=0 THEN
n$=""
i=0
REPEAT
a=PEEK(dta+30+i)
INC i
n$=n$+CHR$(a)
UNTIL a=0
found=FALSE
l=ptest
n2$=s$+cpuord$+n$
n=VARPTR(n2$)
handle=GEMDOS(61,L:n,0)
IF handle>=0 THEN
~GEMDOS(63,handle,L:512,L:ptest)
FOR k=0 TO 511
f$=CHR$(PEEK(ptest+k))
IF f$="P" THEN
f2$=f$+CHR$(PEEK(ptest+k+1))
IF f2$="PL" THEN
f3$=f2$+CHR$(PEEK(ptest+k+2))
IF f3$="PLU" THEN
f4$=f3$+CHR$(PEEK(ptest+k+3))+CHR$(PEEK(ptest+k+4))+CHR$(PEEK(ptest+k+5))
ENDIF
ENDIF
ENDIF
EXIT IF f4$="PLUGIN"
NEXT k
m$=""
IF f4$="PLUGIN" THEN
k2=k+7
REPEAT
a=PEEK(ptest+k2)
m$=m$+CHR$(a)
INC k2
UNTIL a=0
ENDIF
FOR j=1 TO maxplug
IF m$=plugnam$(j) AND m$<>"" THEN
found=TRUE
ENDIF
NEXT j
ENDIF
~GEMDOS(62,handle)
IF found=FALSE THEN
n$=s$+cpuord$+n$
OPEN "I",#1,n$
lf=LOF(#1)
CLOSE #1
IF ldplugs=TRUE THEN
IF gemvers>=&H1900 THEN
lfget=@mxalloc(-1,0)+@mxalloc(-1,1)
ELSE
lfget=MALLOC(-1)
ENDIF
IF lfget>(lf+mrest) THEN
a=EXEC(0,n$,CHR$(0),CHR$(0))
IF a=0 THEN
@plugfinder
ENDIF
ENDIF
ELSE
plugmem=plugmem+lf
ENDIF
ENDIF
REPEAT
dn=GEMDOS(79)
IF dn=0 THEN
n$=""
i=0
REPEAT
a=PEEK(dta+30+i)
INC i
n$=n$+CHR$(a)
UNTIL a=0
found=FALSE
'
l=ptest
n2$=s$+cpuord$+n$
n=VARPTR(n2$)
handle=GEMDOS(61,L:n,0)
IF handle>=0 THEN
~GEMDOS(63,handle,L:512,L:ptest)
f$=""
f2$=""
f3$=""
f4$=""
FOR k=0 TO 511
f$=CHR$(PEEK(ptest+k))
IF f$="P" THEN
f2$=f$+CHR$(PEEK(ptest+k+1))
IF f2$="PL" THEN
f3$=f2$+CHR$(PEEK(ptest+k+2))
IF f3$="PLU" THEN
f4$=f3$+CHR$(PEEK(ptest+k+3))+CHR$(PEEK(ptest+k+4))+CHR$(PEEK(ptest+k+5))
ENDIF
ENDIF
ENDIF
EXIT IF f4$="PLUGIN"
NEXT k
m$=""
IF f4$="PLUGIN" THEN
k2=k+7
REPEAT
a=PEEK(ptest+k2)
m$=m$+CHR$(a)
INC k2
UNTIL a=0
ENDIF
FOR j=1 TO maxplug
IF m$=plugnam$(j) AND m$<>"" THEN
found=TRUE
ENDIF
NEXT j
ENDIF
~GEMDOS(62,handle)
IF found=FALSE THEN
n$=s$+cpuord$+n$
OPEN "I",#1,n$
lf=LOF(#1)
CLOSE #1
IF ldplugs=TRUE THEN
IF gemvers>=&H1900 THEN
lfget=@mxalloc(-1,0)+@mxalloc(-1,1)
ELSE
lfget=MALLOC(-1)
ENDIF
IF lfget>(lf+mrest) THEN
a=EXEC(0,n$,CHR$(0),CHR$(0))
IF a=0 THEN
@plugfinder
ENDIF
ENDIF
ELSE
plugmem=plugmem+lf
ENDIF
ENDIF
ENDIF
UNTIL dn<>0
ENDIF
FOR i=1 TO maxplug
plugnam$(i)=""
NEXT i
pcount=XBIOS(xbs,250)
IF pcount>0 THEN
FOR i=1 TO maxplug
p=XBIOS(xbs,253,i)
IF p<>-1 THEN
nam=LPEEK(p+10)
plnam$=""
REPEAT
b=PEEK(nam)
plnam$=plnam$+CHR$(b)
INC nam
UNTIL b=0
plugnam$(i)=plnam$
plugpara(i)=LPEEK(p+18)
plugparnr(i)=DPEEK(p)
ENDIF
NEXT i
plugcmax=XBIOS(xbs,256)
plugcnow=XBIOS(xbs,258)
ENDIF
IF ldplugs=TRUE THEN
FOR i=1 TO maxplug
IF plugnam$(i)<>"" THEN
IF i<10 THEN
@droptxt(ddplug1&-1+i,LEFT$("  "+LEFT$(plugnam$(i),LEN(plugnam$(i))-1)+SPACE$(21),21)+"F"+CHR$(48+i))
ELSE
@droptxt(ddplug1&-1+i,LEFT$("  "+LEFT$(plugnam$(i),LEN(plugnam$(i))-1)+SPACE$(20),20)+"F10")
ENDIF
ELSE
@rsc_state(dropdown&,ddplug1&-1+i,3,TRUE)
ENDIF
NEXT i
IF EXIST(lfw$+plgconf$)=TRUE THEN
OPEN "I",#1,lfw$+plgconf$
@pluginfread
CLOSE #1
@plugcfgctrl
@plugcfgset
ENDIF
ENDIF
~MFREE(ptest)
ptest=0
ENDIF
RETURN
'
> PROCEDURE plugfinder
FOR i=1 TO maxplug
plugnam$(i)=""
NEXT i
pcount=XBIOS(xbs,250)
IF pcount>0 THEN
FOR i=1 TO maxplug
p=XBIOS(xbs,253,i)
IF p<>-1 THEN
nam=LPEEK(p+10)
plnam$=""
REPEAT
b=PEEK(nam)
plnam$=plnam$+CHR$(b)
INC nam
UNTIL b=0
plugnam$(i)=plnam$
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE plugin(p)
@plugwindow(p)
RETURN
'
> PROCEDURE plugwindow(p)
LOCAL a,b,i
plugwind=p
IF BTST(winh,plugin&)=TRUE THEN   ! Fenster schlieûen, bevor ein neues geîffnet wird
winh=BCLR(winh,plugin&)
@setbutton3(panexit&,0,plugin&)
@rsc_back(plugin&)
@wischwasch
obj=0
ENDIF
dspwind=FALSE
IF plugpara(p)<>-1 THEN
IF BTST(winh,plugin&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=plugin&
'
s=plugpara(p)+plugparnr(p)*8
IF plugparnr(p)>0 THEN
FOR j=1 TO plugparnr(p)
plugcmax(j)=LPEEK(plugpara(p)+j*8-8)
plugcset(j)=LPEEK(plugpara(p)+j*8-4)
plugctxt$(j)=""
REPEAT
t=PEEK(s)
plugctxt$(j)=plugctxt$(j)+CHR$(t)
INC s
UNTIL t=0
plugcart$(j)="("
REPEAT
t=PEEK(s)
plugcart$(j)=plugcart$(j)+CHR$(t)
INC s
UNTIL t=0
plugcart$(j)=LEFT$(plugcart$(j),LEN(plugcart$(j))-1)+")"+CHR$(0)
NEXT j
ENDIF
plugcr$=""
REPEAT
t=PEEK(s)
plugcr$=plugcr$+CHR$(t)
INC s
UNTIL t=0
@textfeld2(nr,plugct1&,"COPYRIGHT BY"+CHR$(0),1)
a=LEN(plugcr$)
IF a>24 THEN
plugcr1$=LEFT$(plugcr$,24)+CHR$(0)
plugcr2$=CHR$(0)
b=RINSTR(plugcr1$," ")
IF b<>0 THEN
plugcr1$=LEFT$(plugcr1$,b-1)+CHR$(0)
plugcr2$=RIGHT$(plugcr$,a-b)
ENDIF
@textfeld2(nr,plugct2&,plugcr1$,1)
@textfeld2(nr,plugct3&,plugcr2$,1)
ELSE
@textfeld2(nr,plugct2&,plugcr$,1)
@textfeld2(nr,plugct3&,CHR$(0),1)
ENDIF
'
@hidetree2(plugct1&,FALSE)
@hidetree2(plugct2&,FALSE)
@hidetree2(plugct3&,FALSE)
@textfeld2(nr,plgtitel&,plugnam$(p),1)
@hideplugs(TRUE)
@hideplugs2(TRUE)
@plugtexsize(FALSE)
@buttbh(panbox&,b,h)
b=160
~@xrsrc_gaddr(0,plugin&,pzu%)
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
DPOKE (pzu%+24*plgtitel&+16),20                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),86                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),4
DPOKE (pzu%+24*plugct2&+16),4
DPOKE (pzu%+24*plugct3&+16),4
IF plugparnr(p)>0 THEN
@hidetree2(plglev1&,FALSE)
@hidetree2(plgbox1&,FALSE)
@hidetree2(levtxt1&,FALSE)
@hidetree2(levart1&,FALSE)
@hidetree2(levcnt1&,FALSE)
'
a$=plugcart$(1)+CHR$(0)
@textfeld2(nr,levart1&,a$,1)
a$=plugctxt$(1)+CHR$(0)
@textfeld2(nr,levtxt1&,a$,1)
@buttbh(panbox&,b,h)
b=160
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
py=105-INT(105/plugcmax(1)*plugcset(1))
DPOKE (pzu%+24*plgbox1&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@plugcalc(1)
a$=STR$(a)+CHR$(0)
@textfeld2(nr,levcnt1&,a$,1)
DPOKE (pzu%+24*plgtitel&+16),20                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),86                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),4
DPOKE (pzu%+24*plugct2&+16),4
DPOKE (pzu%+24*plugct3&+16),4
ENDIF
IF plugparnr(p)>1 THEN
@hidetree2(plglev2&,FALSE)
@hidetree2(plgbox2&,FALSE)
@hidetree2(levtxt2&,FALSE)
@hidetree2(levart2&,FALSE)
@hidetree2(levcnt2&,FALSE)
a$=plugcart$(2)+CHR$(0)
@textfeld2(nr,levart2&,a$,1)
a$=plugctxt$(2)+CHR$(0)
@textfeld2(nr,levtxt2&,a$,1)
b=160
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
py=105-INT(105/plugcmax(2)*plugcset(2))
DPOKE (pzu%+24*plgbox2&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@plugcalc(2)
a$=STR$(a)+CHR$(0)
@textfeld2(nr,levcnt2&,a$,1)
DPOKE (pzu%+24*plgtitel&+16),20                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),86                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),4
DPOKE (pzu%+24*plugct2&+16),4
DPOKE (pzu%+24*plugct3&+16),4
ENDIF
IF plugparnr(p)>2 THEN
@hidetree2(plglev3&,FALSE)
@hidetree2(plgbox3&,FALSE)
@hidetree2(levtxt3&,FALSE)
@hidetree2(levart3&,FALSE)
@hidetree2(levcnt3&,FALSE)
a$=plugcart$(3)+CHR$(0)
@textfeld2(nr,levart3&,a$,1)
a$=plugctxt$(3)+CHR$(0)
@textfeld2(nr,levtxt3&,a$,1)
b=224
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
py=105-INT(105/plugcmax(3)*plugcset(3))
DPOKE (pzu%+24*plgbox3&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@plugcalc(3)
a$=STR$(a)+CHR$(0)
@textfeld2(nr,levcnt3&,a$,1)
DPOKE (pzu%+24*plgtitel&+16),52                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),150                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),36
DPOKE (pzu%+24*plugct2&+16),36
DPOKE (pzu%+24*plugct3&+16),36
ENDIF
IF plugparnr(p)>3 THEN
@hidetree2(plglev4&,FALSE)
@hidetree2(plgbox4&,FALSE)
@hidetree2(levtxt4&,FALSE)
@hidetree2(levart4&,FALSE)
@hidetree2(levcnt4&,FALSE)
a$=plugcart$(4)+CHR$(0)
@textfeld2(nr,levart4&,a$,1)
a$=plugctxt$(4)+CHR$(0)
@textfeld2(nr,levtxt4&,a$,1)
b=288
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
py=105-INT(105/plugcmax(4)*plugcset(4))
DPOKE (pzu%+24*plgbox4&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@plugcalc(4)
a$=STR$(a)+CHR$(0)
@textfeld2(nr,levcnt4&,a$,1)
DPOKE (pzu%+24*plgtitel&+16),84                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),214                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),68
DPOKE (pzu%+24*plugct2&+16),68
DPOKE (pzu%+24*plugct3&+16),68
ENDIF
IF plugparnr(p)>4 THEN
@hidetree2(plglev5&,FALSE)
@hidetree2(plgbox5&,FALSE)
@hidetree2(levtxt5&,FALSE)
@hidetree2(levart5&,FALSE)
@hidetree2(levcnt5&,FALSE)
a$=plugcart$(5)+CHR$(0)
@textfeld2(nr,levart5&,a$,1)
a$=plugctxt$(5)+CHR$(0)
@textfeld2(nr,levtxt5&,a$,1)
b=352
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(nr)=b+4
@setbuttbh(panbox&,b,h)
py=105-INT(105/plugcmax(5)*plugcset(5))
DPOKE (pzu%+24*plgbox5&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@plugcalc(5)
a$=STR$(a)+CHR$(0)
@textfeld2(nr,levcnt5&,a$,1)
DPOKE (pzu%+24*plgtitel&+16),116                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),278                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),100
DPOKE (pzu%+24*plugct2&+16),100
DPOKE (pzu%+24*plugct3&+16),100
ENDIF
'
IF plugparnr(p)=1 THEN
@buttbh(plglev1&,b2,h2)
panbox=68
DPOKE (pzu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=68-b2/2+13
DPOKE (pzu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=68-b2/2+13
DPOKE (pzu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=68-b2/2+12
DPOKE (pzu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF plugparnr(p)=2 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (pzu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (pzu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (pzu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (pzu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF plugparnr(p)=3 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (pzu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (pzu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (pzu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (pzu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev3&,b2,h2)
panbox=164
DPOKE (pzu%+24*plglev3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levtxt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levart3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt3&,b2,h2)
panbox=164-b2/2+12
DPOKE (pzu%+24*levcnt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF plugparnr(p)=4 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (pzu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (pzu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (pzu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (pzu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev3&,b2,h2)
panbox=164
DPOKE (pzu%+24*plglev3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levtxt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levart3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt3&,b2,h2)
panbox=164-b2/2+12
DPOKE (pzu%+24*levcnt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev4&,b2,h2)
panbox=228
DPOKE (pzu%+24*plglev4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt4&,b2,h2)
panbox=228-b2/2+13
DPOKE (pzu%+24*levtxt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart4&,b2,h2)
panbox=228-b2/2+13
DPOKE (pzu%+24*levart4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt4&,b2,h2)
panbox=228-b2/2+12
DPOKE (pzu%+24*levcnt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF plugparnr(p)=5 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (pzu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (pzu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (pzu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (pzu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev3&,b2,h2)
panbox=164
DPOKE (pzu%+24*plglev3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levtxt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levart3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt3&,b2,h2)
panbox=164-b2/2+12
DPOKE (pzu%+24*levcnt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev4&,b2,h2)
panbox=228
DPOKE (pzu%+24*plglev4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt4&,b2,h2)
panbox=228-b2/2+13
DPOKE (pzu%+24*levtxt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart4&,b2,h2)
panbox=228-b2/2+13
DPOKE (pzu%+24*levart4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt4&,b2,h2)
panbox=228-b2/2+12
DPOKE (pzu%+24*levcnt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev5&,b2,h2)
panbox=292
DPOKE (pzu%+24*plglev5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt5&,b2,h2)
panbox=292-b2/2+13
DPOKE (pzu%+24*levtxt5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart5&,b2,h2)
panbox=292-b2/2+13
DPOKE (pzu%+24*levart5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt5&,b2,h2)
panbox=292-b2/2+12
DPOKE (pzu%+24*levcnt5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
a=rsc_adr%(nr)
a=C:rsc_obspec%(L:a,plugnam&)           ! ...Adresse des Titels
a$="CPU-Effect"+CHR$(0)
FOR i=1 TO LEN(a$)
POKE a+i-1,ASC(MID$(a$,i,1))
NEXT i
'
@rsc_draw(nr,7)
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=plugin&
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
ENDIF
RETURN
'
> FUNCTION plugcalc(a)
LOCAL n,max,a$
n=plugcset(a)
max=plugcmax(a)
a$=plugcart$(a)
'
IF a$="(MS)"+CHR$(0) THEN
@makehz
b=INT(n/hz*1000)
ENDIF
IF a$="(DB)"+CHR$(0) THEN
IF n>0 THEN
b=INT(aufloes-(20*LOG10(n*2)*100))/100
ELSE
b=0
ENDIF
ENDIF
RETURN b
ENDFUNC
'
> PROCEDURE plugregler1
SELECT obj
CASE plgbox1&
boxsel=1
cntsel=levcnt1&
levsel=plglev1&
bboxsel=11
bcntsel=levcnt11&
blevsel=plglev11&
bdspbox=plgbox11&
CASE plgbox2&
boxsel=2
cntsel=levcnt2&
levsel=plglev2&
bboxsel=12
bcntsel=levcnt12&
blevsel=plglev12&
bdspbox=plgbox12&
CASE plgbox3&
boxsel=3
cntsel=levcnt3&
levsel=plglev3&
bboxsel=13
bcntsel=levcnt13&
blevsel=plglev13&
bdspbox=plgbox13&
CASE plgbox4&
boxsel=4
cntsel=levcnt4&
levsel=plglev4&
bboxsel=14
bcntsel=levcnt14&
blevsel=plglev14&
bdspbox=plgbox14&
CASE plgbox5&
boxsel=5
cntsel=levcnt5&
levsel=plglev5&
bboxsel=15
bcntsel=levcnt15&
blevsel=plglev15&
bdspbox=plgbox15&
CASE plgbox6&
boxsel=6
cntsel=levcnt6&
levsel=plglev6&
bboxsel=16
bcntsel=levcnt16&
blevsel=plglev16&
bdspbox=plgbox16&
CASE plgbox7&
boxsel=7
cntsel=levcnt7&
levsel=plglev7&
bboxsel=17
bcntsel=levcnt17&
blevsel=plglev17&
bdspbox=plgbox17&
CASE plgbox8&
boxsel=8
cntsel=levcnt8&
levsel=plglev8&
bboxsel=18
bcntsel=levcnt18&
blevsel=plglev18&
bdspbox=plgbox18&
CASE plgbox9&
boxsel=9
cntsel=levcnt9&
levsel=plglev9&
bboxsel=19
bcntsel=levcnt19&
blevsel=plglev19&
bdspbox=plgbox19&
CASE plgbox10&
boxsel=10
cntsel=levcnt10&
levsel=plglev10&
bboxsel=20
bcntsel=levcnt20&
blevsel=plglev20&
bdspbox=plgbox20&
CASE plgbox11&
boxsel=11
cntsel=levcnt11&
levsel=plglev11&
bboxsel=1
bcntsel=levcnt1&
blevsel=plglev1&
bdspbox=plgbox1&
CASE plgbox12&
boxsel=12
cntsel=levcnt12&
levsel=plglev12&
bboxsel=2
bcntsel=levcnt2&
blevsel=plglev2&
bdspbox=plgbox2&
CASE plgbox13&
boxsel=13
cntsel=levcnt13&
levsel=plglev13&
bboxsel=3
bcntsel=levcnt3&
blevsel=plglev3&
bdspbox=plgbox3&
CASE plgbox14&
boxsel=14
cntsel=levcnt14&
levsel=plglev14&
bboxsel=4
bcntsel=levcnt4&
blevsel=plglev4&
bdspbox=plgbox4&
CASE plgbox15&
boxsel=15
cntsel=levcnt15&
levsel=plglev15&
bboxsel=5
bcntsel=levcnt5&
blevsel=plglev5&
bdspbox=plgbox5&
CASE plgbox16&
boxsel=16
cntsel=levcnt16&
levsel=plglev16&
bboxsel=6
bcntsel=levcnt6&
blevsel=plglev6&
bdspbox=plgbox6&
CASE plgbox17&
boxsel=17
cntsel=levcnt17&
levsel=plglev17&
bboxsel=7
bcntsel=levcnt7&
blevsel=plglev7&
bdspbox=plgbox7&
CASE plgbox18&
boxsel=18
cntsel=levcnt18&
levsel=plglev18&
bboxsel=8
bcntsel=levcnt8&
blevsel=plglev8&
bdspbox=plgbox8&
CASE plgbox19&
boxsel=19
cntsel=levcnt19&
levsel=plglev19&
bboxsel=9
bcntsel=levcnt9&
blevsel=plglev9&
bdspbox=plgbox9&
CASE plgbox20&
boxsel=20
cntsel=levcnt20&
levsel=plglev20&
bboxsel=10
bcntsel=levcnt10&
blevsel=plglev10&
bdspbox=plgbox10&
CASE plgbox21&
boxsel=22
cntsel=levcnt21&
levsel=plglev21&
ENDSELECT
RETURN
'
> PROCEDURE plugregtest
IF (dspwind=FALSE AND plugwind>0) OR (dspwind=TRUE AND dplugwind>0) THEN
obj=plgobj
@plugregler1
IF dspwind=FALSE THEN
IF plugparnr(plugwind)>=boxsel THEN
plgreg=105-(105/plugcmax(boxsel)*plugcset(boxsel))
plgreg=plgreg+plgc
@setbutton(plgobj,1)
PAUSE 1
@plugregler2(plgreg)
@setbutton(plgobj,0)
ENDIF
ELSE
IF dplugparnr(dplugwind)>=boxsel OR (dplugparnr(dplugwind)=21 AND boxsel=22) THEN
plgreg=105-(105/(dplugcmax(dplugwind,boxsel)-dplugcmin(dplugwind,boxsel))*(dplugcset(dplugwind,boxsel)-dplugcmin(dplugwind,boxsel)))
plgreg=plgreg+plgc
@setbutton(plgobj,1)
PAUSE 1
@plugregler2(plgreg)
@setbutton(plgobj,0)
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE plugregler2(p)
LOCAL ps
IF p<0 THEN
p=0
ENDIF
IF p>105 THEN
p=105
ENDIF
plgreg=p
IF dspwind=FALSE THEN
lev=(plugcmax(boxsel)/105*(105-p))
plugcset(boxsel)=lev
ps=@plugcalc(boxsel)
a$=STR$(ps)+CHR$(0)
@textfeld(cntsel,a$,1)
LPOKE plugpara(plugwind)+boxsel*8-4,lev
ELSE
lev=((dplugcmax(dplugwind,boxsel)-dplugcmin(dplugwind,boxsel))/105*(105-p))
dplugcset(dplugwind,boxsel)=lev+dplugcmin(dplugwind,boxsel)
ps=@dplugcalc(dplugwind,boxsel)
a$=STR$(ps)+CHR$(0)
@textfeld(cntsel,a$,1)
LPOKE mdat%,boxsel-1
LPOKE mdat%+4,dplugcset(dplugwind,boxsel)
IF demo=FALSE OR (falcon=TRUE AND magicmac=0) THEN
~XBIOS(98,L:mdat%,L:2,L:mdat%+50,L:0)
ENDIF
IF (lshft=TRUE OR rshft=TRUE) AND boxsel<21 AND dplugparnr(dplugwind)=21 THEN
lev=((dplugcmax(dplugwind,bboxsel)-dplugcmin(dplugwind,bboxsel))/105*(105-p))
dplugcset(dplugwind,bboxsel)=lev+dplugcmin(dplugwind,bboxsel)
ps=@dplugcalc(dplugwind,bboxsel)
a$=STR$(ps)+CHR$(0)
@textfeld(bcntsel,a$,1)
LPOKE mdat%,bboxsel-1
LPOKE mdat%+4,dplugcset(dplugwind,bboxsel)
IF demo=FALSE OR (falcon=TRUE AND magicmac=0) THEN
~XBIOS(98,L:mdat%,L:2,L:mdat%+50,L:0)
ENDIF
ENDIF
ENDIF
~@xrsrc_gaddr(0,plugin&,pzu%)
DPOKE (pzu%+24*obj+18),p+3                    ! Hîhenposition des Volume-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
IF flicker=TRUE THEN
VSYNC
ENDIF
~OBJC_DRAW(pzu%,levsel,9,0,0,xwidth,ywidth)     ! neu zeichnen
IF (lshft=TRUE OR rshft=TRUE) AND boxsel<21 AND dplugparnr(dplugwind)=21 THEN
DPOKE (pzu%+24*bdspbox+18),p+3                    ! Hîhenposition des Volume-Sliders verÑndern
~OBJC_DRAW(pzu%,blevsel,9,0,0,xwidth,ywidth)     ! neu zeichnen
ENDIF
~WIND_UPDATE(0)                                  ! BEG_UPDATE
RETURN
'
> PROCEDURE do_plugin
~@xrsrc_gaddr(0,plugin&,pzu%)
zuadr=pzu%
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
'
IF obj=panhelp& THEN
@helptxt("PLUGINS")
ENDIF
'
plgboxf=FALSE
IF (obj=plgbox1& OR obj=plgbox2& OR obj=plgbox3& OR obj=plgbox4& OR obj=plgbox5& OR obj=plgbox6& OR obj=plgbox7& OR obj=plgbox8& OR obj=plgbox9& OR obj=plgbox10&)
plgboxf=TRUE
ENDIF
IF (obj=plgbox11& OR obj=plgbox12& OR obj=plgbox13& OR obj=plgbox14& OR obj=plgbox15& OR obj=plgbox16& OR obj=plgbox17& OR obj=plgbox18& OR obj=plgbox19& OR obj=plgbox20&)
plgboxf=TRUE
ENDIF
IF obj=plgbox21&
plgboxf=TRUE
ENDIF
IF plgboxf=TRUE OR plgmake=TRUE
@plugregler1
~@xrsrc_gaddr(1,obj,zu2%)
REPEAT
~GRAF_MKSTATE(x,y,k,pshift)
IF k=1 AND plgmake=FALSE THEN
plgmake=TRUE
DEFMOUSE mf
opy=y
ENDIF
IF opy<>y THEN
opy=y
py=y-yd-40
@plugregler2(py)
ENDIF
UNTIL k=0
plgmake=FALSE
DEFMOUSE 0
obj=0
ENDIF
IF obj=panexit& OR obj=9999 THEN
dspwind=FALSE
winh=BCLR(winh,plugin&)
@setbutton(panexit&,0)
@restaura2b
obj=0
@sethertz
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
RETURN
'
> PROCEDURE plugconfig
LOCAL l,a$,i,wahl,j
IF pcount>0 THEN
vornr=nr
nr=plgconfg&
FOR i=1 TO pcount
@hidetree2(plgcfg1&-1+i,FALSE)
IF cpu<=30 THEN
@rsc_state(nr,plgcfg1&+i-1,3,TRUE)
@flagbutton(plgcfg1&+i-1,0)
ENDIF
NEXT i
IF cpu<=30 THEN
@textfeld2(nr,noplugs1&,lng$(69)+CHR$(0),1)
@textfeld2(nr,noplugs2&,lng$(70)+CHR$(0),1)
ENDIF
plgsel=0
FOR i=1 TO maxplug
IF plugnam$(i)<>"" THEN
INC plgsel
@textfeld2(nr,plgcfg1&+plgsel-1,plugnam$(i),1)
plgsel$(plgsel)=plugnam$(i)
ENDIF
NEXT i
@textfeld2(nr,plgrec1&,CHR$(0),1)
@textfeld2(nr,plgrec2&,CHR$(0),1)
@textfeld2(nr,plgrec3&,CHR$(0),1)
@textfeld2(nr,plgrec4&,CHR$(0),1)
@textfeld2(nr,plgrec5&,CHR$(0),1)
@textfeld2(nr,plgplay1&,CHR$(0),1)
@textfeld2(nr,plgplay2&,CHR$(0),1)
@textfeld2(nr,plgplay3&,CHR$(0),1)
@textfeld2(nr,plgplay4&,CHR$(0),1)
@textfeld2(nr,plgplay5&,CHR$(0),1)
'
IF plgr>0 THEN
FOR i=1 TO plgr
IF plgrlist(i)>0 AND plgrlist(i)<=plgsel THEN
a$=plgsel$(plgrlist(i))
SELECT i
CASE 1
@textfeld2(nr,plgrec1&,a$,1)
CASE 2
@textfeld2(nr,plgrec2&,a$,1)
CASE 3
@textfeld2(nr,plgrec3&,a$,1)
CASE 4
@textfeld2(nr,plgrec4&,a$,1)
CASE 5
@textfeld2(nr,plgrec5&,a$,1)
ENDSELECT
ENDIF
NEXT i
ENDIF
IF plgp>0 THEN
FOR i=1 TO plgp
IF plgplist(i)>0 AND plgplist(i)<=plgsel THEN
a$=plgsel$(plgplist(i))
SELECT i
CASE 1
@textfeld2(nr,plgplay1&,a$,1)
CASE 2
@textfeld2(nr,plgplay2&,a$,1)
CASE 3
@textfeld2(nr,plgplay3&,a$,1)
CASE 4
@textfeld2(nr,plgplay4&,a$,1)
CASE 5
@textfeld2(nr,plgplay5&,a$,1)
ENDSELECT
ENDIF
NEXT i
ENDIF
@setbutton3(plgplay&,0,nr)
@setbutton3(plgrec&,1,nr)
wahl=0
@rsc_draw(nr,0)
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(1,obj,zu%)
IF obj>=plgcfg1& AND obj<=plgcfg10& THEN
a$=plgsel$(obj-plgcfg1&+1)
IF wahl=0 THEN
IF plgr<5 THEN
INC plgr
plgrlist(plgr)=obj-plgcfg1&+1
SELECT plgr
CASE 1
@textfeld(plgrec1&,a$,1)
CASE 2
@textfeld(plgrec2&,a$,1)
CASE 3
@textfeld(plgrec3&,a$,1)
CASE 4
@textfeld(plgrec4&,a$,1)
CASE 5
@textfeld(plgrec5&,a$,1)
ENDSELECT
ENDIF
ELSE
IF plgp<5 THEN
INC plgp
plgplist(plgp)=obj-plgcfg1&+1
SELECT plgp
CASE 1
@textfeld(plgplay1&,a$,1)
CASE 2
@textfeld(plgplay2&,a$,1)
CASE 3
@textfeld(plgplay3&,a$,1)
CASE 4
@textfeld(plgplay4&,a$,1)
CASE 5
@textfeld(plgplay5&,a$,1)
ENDSELECT
ENDIF
ENDIF
ENDIF
IF obj=plgrec& THEN
wahl=0
@setbutton(plgplay&,0)
@setbutton(plgrec&,1)
ENDIF
IF obj=plgplay& THEN
wahl=1
@setbutton(plgrec&,0)
@setbutton(plgplay&,1)
ENDIF
IF obj=pcfgld& THEN
@plugcfgload
ENDIF
IF obj=pcfgsve& THEN
@plugcfgsave
ENDIF
IF obj=pcfgclr& THEN
IF wahl=0 THEN
IF plgr>0 THEN
FOR i=1 TO plgr
plgrlist(i)=0
NEXT i
@textfeld(plgrec1&,CHR$(0),1)
@textfeld(plgrec2&,CHR$(0),1)
@textfeld(plgrec3&,CHR$(0),1)
@textfeld(plgrec4&,CHR$(0),1)
@textfeld(plgrec5&,CHR$(0),1)
ENDIF
plgr=0
ELSE
IF plgp>0 THEN
FOR i=1 TO plgp
plgplist(i)=0
NEXT i
@textfeld(plgplay1&,CHR$(0),1)
@textfeld(plgplay2&,CHR$(0),1)
@textfeld(plgplay3&,CHR$(0),1)
@textfeld(plgplay4&,CHR$(0),1)
@textfeld(plgplay5&,CHR$(0),1)
ENDIF
plgp=0
ENDIF
ENDIF
IF obj=pcfghelp& THEN
@helptxt("PLUGIN CONFIG")
ENDIF
IF obj<>0 AND obj<>pcfghelp& AND obj<>plgplay& AND obj<>plgrec& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=pcfgexit&
@plugcfgset
@setbutton(obj,0)
@restaura2
obj=0
ELSE
@editselect
ENDIF
RETURN
'
> PROCEDURE plugcfgsave
LOCAL i,g2,a,a$
@fileselect(lfw$+"*."+plgcext$,plgconf$,"PLUGCFG-SAVE:")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+"."+plgcext$
ELSE
IF RIGHT$(fil$,3)<>plgcext$ THEN
fil$=LEFT$(fil$,g2)+plgcext$
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>=sector THEN
OPEN "O",#1,fil$
PRINT #1,"STARTRACK-PLUGCONFIG V2.0"               !versionskontrolle
PRINT #1
PRINT #1,"plugin_quantity=";STR$(plgsel)
IF plgsel>0 THEN
FOR i=1 TO plgsel
a$=plgsel$(i)
a=INSTR(a$,CHR$(0))
IF a<>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
PRINT #1,"plugin_name"+STR$(i)+"="+a$
NEXT i
ENDIF
PRINT #1
PRINT #1,"plugin_inp_quantity=";STR$(plgr)
IF plgr>0 THEN
FOR i=1 TO plgr
PRINT #1,"plugin_inp_number"+STR$(i)+"="+STR$(plgrlist(i))
NEXT i
ENDIF
PRINT #1,"plugin_outp_quantity=";STR$(plgp)
IF plgp>0 THEN
FOR i=1 TO plgp
PRINT #1,"plugin_outp_number"+STR$(i)+"="+STR$(plgplist(i))
NEXT i
ENDIF
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
RETURN
'
> PROCEDURE pluginfread
INPUT #1,plgv$              !  "STARTRACK-PLUGCONFIG V2.0"  Versionskontrolle
IF MID$(plgv$,LEN(plgv$)-3,1)="V" THEN
plgv=VAL(RIGHT$(plgv$,3))
ELSE
plgv=0
ENDIF
IF plgv>=2 THEN
REPEAT
EXIT IF EOF(#1)
INPUT #1,a$
@changelowkey2
IF INSTR(a$,"plugin_quantity")<>0 THEN
@delsourcekey
vplgsel=VAL(a$)
ENDIF
IF INSTR(a$,"plugin_name")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-11)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF maxplug>=b THEN
vplgsel$(b)=a$+CHR$(0)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"plugin_inp_quantity")<>0 THEN
@delsourcekey
plgr=VAL(a$)
ENDIF
IF INSTR(a$,"plugin_inp_number")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-17)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF maxplug>=b THEN
plgrlist(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"plugin_outp_quantity")<>0 THEN
@delsourcekey
plgp=VAL(a$)
ENDIF
IF INSTR(a$,"plugin_outp_number")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-18)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF maxplug>=b THEN
plgplist(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
UNTIL EOF(#1)
ENDIF
RETURN
'
> PROCEDURE plugcfgload
LOCAL i,g2
@fileselect(lfw$+"*."+plgcext$,"","PLUGCFG-LOAD:")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+"."+plgcext$
ELSE
IF RIGHT$(fil$,3)<>plgcext$ THEN
fil$=LEFT$(fil$,g2)+plgcext$
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
IF EXIST(fil$)=TRUE THEN
FOR i=1 TO maxplug
plgrlist(i)=0
plgplist(i)=0
plgsel$(i)=""
NEXT i
OPEN "I",#1,fil$
@pluginfread
CLOSE #1
@plugcfgctrl
@textfeld(plgrec1&,CHR$(0),1)
@textfeld(plgrec2&,CHR$(0),1)
@textfeld(plgrec3&,CHR$(0),1)
@textfeld(plgrec4&,CHR$(0),1)
@textfeld(plgrec5&,CHR$(0),1)
@textfeld(plgplay1&,CHR$(0),1)
@textfeld(plgplay2&,CHR$(0),1)
@textfeld(plgplay3&,CHR$(0),1)
@textfeld(plgplay4&,CHR$(0),1)
@textfeld(plgplay5&,CHR$(0),1)
IF plgr>0 THEN
FOR i=1 TO plgr
IF plgrlist(i)>0 AND plgrlist(i)<=plgsel THEN
a$=plgsel$(plgrlist(i))
SELECT i
CASE 1
@textfeld(plgrec1&,a$,1)
CASE 2
@textfeld(plgrec2&,a$,1)
CASE 3
@textfeld(plgrec3&,a$,1)
CASE 4
@textfeld(plgrec4&,a$,1)
CASE 5
@textfeld(plgrec5&,a$,1)
ENDSELECT
ENDIF
NEXT i
ENDIF
IF plgp>0 THEN
FOR i=1 TO plgp
IF plgplist(i)>0 AND plgplist(i)<=plgsel THEN
a$=plgsel$(plgplist(i))
SELECT i
CASE 1
@textfeld(plgplay1&,a$,1)
CASE 2
@textfeld(plgplay2&,a$,1)
CASE 3
@textfeld(plgplay3&,a$,1)
CASE 4
@textfeld(plgplay4&,a$,1)
CASE 5
@textfeld(plgplay5&,a$,1)
ENDSELECT
ENDIF
NEXT i
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE plugcfgctrl
LOCAL i,j,k,l
IF vplgsel>0 THEN
plgsel=0
FOR i=1 TO maxplug
IF plugnam$(i)<>"" THEN
INC plgsel
plgsel$(plgsel)=plugnam$(i)
ENDIF
NEXT i
IF plgsel>0 THEN
FOR i=1 TO vplgsel
FOR j=1 TO plgsel
EXIT IF vplgsel$(i)=plgsel$(j) AND plgsel$(j)<>""
NEXT j
IF vplgsel$(i)=plgsel$(j) AND plgsel$(j)<>"" THEN
IF plgr>0 THEN
FOR k=1 TO plgr
IF plgrlist(k)=i THEN
plgrlist(k)=j
ENDIF
NEXT k
ENDIF
IF plgp>0 THEN
FOR k=1 TO plgp
IF plgplist(k)=i THEN
plgplist(k)=j
ENDIF
NEXT k
ENDIF
ELSE
IF plgr>0 THEN
FOR k=1 TO plgr
IF plgrlist(k)=i AND plgr>0 THEN
FOR l=k TO plgr
IF l<plgr THEN
plgrlist(l)=plgrlist(l+1)
ELSE
plgrlist(l)=0
ENDIF
NEXT l
DEC plgr
ENDIF
NEXT k
ENDIF
IF plgp>0 THEN
FOR k=1 TO plgp
IF plgplist(k)=i AND plgp>0 THEN
FOR l=k TO plgp
IF l<plgp THEN
plgplist(l)=plgplist(l+1)
ELSE
plgplist(l)=0
ENDIF
NEXT l
DEC plgp
ENDIF
NEXT k
ENDIF
ENDIF
NEXT i
ENDIF
ELSE
plgsel=0
FOR i=1 TO maxplug
plgrlist(i)=0
plgplist(i)=0
plgsel$(i)=""
NEXT i
ENDIF
RETURN
'
> PROCEDURE plugcfgset
l=mdat%
IF plgr>0 THEN
FOR i=1 TO plgr
FOR j=1 TO maxplug
EXIT IF plgsel$(plgrlist(i))=plugnam$(j) AND plugnam$(j)<>""
NEXT j
IF j<=maxplug THEN
IF plgsel$(plgrlist(i))=plugnam$(j) AND plugnam$(j)<>"" THEN
DPOKE l,j
l=l+2
ENDIF
ENDIF
NEXT i
ENDIF
DPOKE l,0
c=XBIOS(xbs,255,L:mdat%)
l=mdat%
IF plgp>0 THEN
FOR i=1 TO plgp
FOR j=1 TO maxplug
EXIT IF plgsel$(plgplist(i))=plugnam$(j) AND plugnam$(j)<>""
NEXT j
IF j<=maxplug THEN
IF plgsel$(plgplist(i))=plugnam$(j) AND plugnam$(j)<>"" THEN
DPOKE l,j
l=l+2
ENDIF
ENDIF
NEXT i
ENDIF
DPOKE l,0
c=XBIOS(xbs,254,L:mdat%)
RETURN
'
> PROCEDURE dsp_pluginit
LOCAL d$,d,dta,da,dn
d$=s$+dspord$+"*."+dspar$+CHR$(0)
d=VARPTR(d$)
dta=GEMDOS(47)   ! fgetdta
da=GEMDOS(78,L:d,0)
dsplugv=0
dsplugz=0
IF da=0 THEN
n$=""
i=0
REPEAT
a=PEEK(dta+30+i)
INC i
n$=n$+CHR$(a)
UNTIL a=0
INC dsplugv
dspath$(dsplugv)=n$
REPEAT
dn=GEMDOS(79)
IF dn=0 THEN
n$=""
i=0
REPEAT
a=PEEK(dta+30+i)
INC i
n$=n$+CHR$(a)
UNTIL a=0
INC dsplugv
dspath$(dsplugv)=n$
ENDIF
UNTIL dn<>0
ENDIF
IF dsplugv>0 THEN
FOR i=1 TO dsplugv
n$=dspath$(i)
n2$=s$+dspord$+n$
n3$=s$+dspord$+LEFT$(n$,LEN(n$)-4)+dsprog$
@dsp_getplug
NEXT i
ENDIF
RETURN
'
> PROCEDURE readline
a$=""
REPEAT
EXIT IF EOF(#1)=TRUE
a=INP(#1)
a$=a$+CHR$(a)
UNTIL a=0 OR a=13 OR a=ASC(",") OR EOF(#1)=TRUE
IF a=13 THEN
a$=LEFT$(a$,LEN(a$)-1)
IF EOF(#1)=FALSE THEN
a=INP(#1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE dsp_getplug
LOCAL c$
IF EXIST(n3$)=TRUE AND EXIST(n2$)=TRUE THEN
INC dsplugz
dplugnam$(dsplugz)=LEFT$(n$,LEN(n$)-4)
dplugparnr(dsplugz)=0
OPEN "I",#1,n2$
REPEAT
@readline
IF LEFT$(a$,5)="TITLE" THEN
b=INSTR(a$," ")
IF b=0 THEN
dplugnam$(dsplugz)=RIGHT$(a$,LEN(a$)-6)
ELSE
dplugnam$(dsplugz)=RIGHT$(a$,LEN(a$)-b)
ENDIF
ENDIF
EXIT IF EOF(#1)=TRUE
IF LEFT$(a$,7)="HEXPARA" THEN
b=INSTR(a$," ")
z=VAL(RIGHT$(a$,LEN(a$)-b))+1
IF z<=maxpar THEN
dplugparnr(dsplugz)=dplugparnr(dsplugz)+1
@readline
dplugcmin(dsplugz,z)=VAL("&H"+a$)
@readline
dplugcmax(dsplugz,z)=VAL("&H"+a$)
@readline
dplugcset(dsplugz,z)=VAL("&H"+a$)
@readline
dplugctxt$(dsplugz,z)=a$
dplugcart$(dsplugz,z)="(NONE)"
ENDIF
ENDIF
IF LEFT$(a$,7)="DECPARA" THEN
b=INSTR(a$," ")
z=VAL(RIGHT$(a$,LEN(a$)-b))+1
IF z<=maxpar THEN
dplugparnr(dsplugz)=dplugparnr(dsplugz)+1
@readline
dplugcmin(dsplugz,z)=VAL(a$)
@readline
dplugcmax(dsplugz,z)=VAL(a$)
@readline
dplugcset(dsplugz,z)=VAL(a$)
@readline
dplugctxt$(dsplugz,z)=a$
dplugcart$(dsplugz,z)="(NONE)"
ENDIF
ENDIF
a$=""
UNTIL EOF(#1)=TRUE
CLOSE #1
ENDIF
RETURN
'
> PROCEDURE hideplugs(f)
@hidetree2(plglev1&,f)
@hidetree2(plgbox1&,f)
@hidetree2(levtxt1&,f)
@hidetree2(levcnt1&,f)
@hidetree2(plglev2&,f)
@hidetree2(plgbox2&,f)
@hidetree2(levtxt2&,f)
@hidetree2(levcnt2&,f)
@hidetree2(plglev3&,f)
@hidetree2(plgbox3&,f)
@hidetree2(levtxt3&,f)
@hidetree2(levcnt3&,f)
@hidetree2(plglev4&,f)
@hidetree2(plgbox4&,f)
@hidetree2(levtxt4&,f)
@hidetree2(levcnt4&,f)
@hidetree2(plglev5&,f)
@hidetree2(plgbox5&,f)
@hidetree2(levtxt5&,f)
@hidetree2(levcnt5&,f)
@hidetree2(plglev6&,f)
@hidetree2(plgbox6&,f)
@hidetree2(levtxt6&,f)
@hidetree2(levcnt6&,f)
@hidetree2(plglev7&,f)
@hidetree2(plgbox7&,f)
@hidetree2(levtxt7&,f)
@hidetree2(levcnt7&,f)
@hidetree2(plglev8&,f)
@hidetree2(plgbox8&,f)
@hidetree2(levtxt8&,f)
@hidetree2(levcnt8&,f)
@hidetree2(plglev9&,f)
@hidetree2(plgbox9&,f)
@hidetree2(levtxt9&,f)
@hidetree2(levcnt9&,f)
@hidetree2(plglev10&,f)
@hidetree2(plgbox10&,f)
@hidetree2(levtxt10&,f)
@hidetree2(levcnt10&,f)
@hidetree2(plglev11&,f)
@hidetree2(plgbox11&,f)
@hidetree2(levtxt11&,f)
@hidetree2(levcnt11&,f)
@hidetree2(plglev12&,f)
@hidetree2(plgbox12&,f)
@hidetree2(levtxt12&,f)
@hidetree2(levcnt12&,f)
@hidetree2(plglev13&,f)
@hidetree2(plgbox13&,f)
@hidetree2(levtxt13&,f)
@hidetree2(levcnt13&,f)
@hidetree2(plglev14&,f)
@hidetree2(plgbox14&,f)
@hidetree2(levtxt14&,f)
@hidetree2(levcnt14&,f)
@hidetree2(plglev15&,f)
@hidetree2(plgbox15&,f)
@hidetree2(levtxt15&,f)
@hidetree2(levcnt15&,f)
@hidetree2(plglev16&,f)
@hidetree2(plgbox16&,f)
@hidetree2(levtxt16&,f)
@hidetree2(levcnt16&,f)
@hidetree2(plglev17&,f)
@hidetree2(plgbox17&,f)
@hidetree2(levtxt17&,f)
@hidetree2(levcnt17&,f)
@hidetree2(plglev18&,f)
@hidetree2(plgbox18&,f)
@hidetree2(levtxt18&,f)
@hidetree2(levcnt18&,f)
@hidetree2(plglev19&,f)
@hidetree2(plgbox19&,f)
@hidetree2(levtxt19&,f)
@hidetree2(levcnt19&,f)
@hidetree2(plglev20&,f)
@hidetree2(plgbox20&,f)
@hidetree2(levtxt20&,f)
@hidetree2(levcnt20&,f)
@hidetree2(plglev21&,f)
@hidetree2(plgbox21&,f)
@hidetree2(levtxt21&,f)
@hidetree2(levcnt21&,f)
RETURN
'
> PROCEDURE hideplugs2(f)
@hidetree2(levart1&,f)
@hidetree2(levart2&,f)
@hidetree2(levart3&,f)
@hidetree2(levart4&,f)
@hidetree2(levart5&,f)
@hidetree2(levart6&,f)
@hidetree2(levart7&,f)
@hidetree2(levart8&,f)
@hidetree2(levart9&,f)
@hidetree2(levart10&,f)
@hidetree2(levart11&,f)
@hidetree2(levart12&,f)
@hidetree2(levart13&,f)
@hidetree2(levart14&,f)
@hidetree2(levart15&,f)
@hidetree2(levart16&,f)
@hidetree2(levart17&,f)
@hidetree2(levart18&,f)
@hidetree2(levart19&,f)
@hidetree2(levart20&,f)
@hidetree2(levart21&,f)
RETURN
'
> PROCEDURE plugtexsize(f)
LOCAL bc,hc,bn,bn2
IF f=FALSE THEN
bn=40
bn2=90
ELSE
bn=24
bn2=18
ENDIF
@buttbh(levcnt1&,bc,hc)
@setbuttbh(levcnt1&,bn,hc)
@setbuttbh(levcnt2&,bn,hc)
@setbuttbh(levcnt3&,bn,hc)
@setbuttbh(levcnt4&,bn,hc)
@setbuttbh(levcnt5&,bn,hc)
@setbuttbh(levcnt6&,bn,hc)
@setbuttbh(levcnt7&,bn,hc)
@setbuttbh(levcnt8&,bn,hc)
@setbuttbh(levcnt9&,bn,hc)
@setbuttbh(levcnt10&,bn,hc)
@setbuttbh(levcnt11&,bn,hc)
@setbuttbh(levcnt12&,bn,hc)
@setbuttbh(levcnt13&,bn,hc)
@setbuttbh(levcnt14&,bn,hc)
@setbuttbh(levcnt15&,bn,hc)
@setbuttbh(levcnt16&,bn,hc)
@setbuttbh(levcnt17&,bn,hc)
@setbuttbh(levcnt18&,bn,hc)
@setbuttbh(levcnt19&,bn,hc)
@setbuttbh(levcnt20&,bn,hc)
@setbuttbh(levcnt21&,bn,hc)
@buttbh(levtxt1&,bc,hc)
@setbuttbh(levtxt1&,bn2,hc)
@setbuttbh(levtxt2&,bn2,hc)
@setbuttbh(levtxt3&,bn2,hc)
@setbuttbh(levtxt4&,bn2,hc)
@setbuttbh(levtxt5&,bn2,hc)
@setbuttbh(levtxt6&,bn2,hc)
@setbuttbh(levtxt7&,bn2,hc)
@setbuttbh(levtxt8&,bn2,hc)
@setbuttbh(levtxt9&,bn2,hc)
@setbuttbh(levtxt10&,bn2,hc)
@setbuttbh(levtxt11&,bn2,hc)
@setbuttbh(levtxt12&,bn2,hc)
@setbuttbh(levtxt13&,bn2,hc)
@setbuttbh(levtxt14&,bn2,hc)
@setbuttbh(levtxt15&,bn2,hc)
@setbuttbh(levtxt16&,bn2,hc)
@setbuttbh(levtxt17&,bn2,hc)
@setbuttbh(levtxt18&,bn2,hc)
@setbuttbh(levtxt19&,bn2,hc)
@setbuttbh(levtxt20&,bn2,hc)
@setbuttbh(levtxt21&,bn2,hc)
RETURN
'
> PROCEDURE dsp_plugwind(p)
LOCAL a,b,i,f,n$
dplugwind=p
IF BTST(winh,plugin&)=TRUE THEN   ! Fenster schlieûen, bevor ein neues geîffnet wird
winh=BCLR(winh,plugin&)
@setbutton3(panexit&,0,plugin&)
@rsc_back(plugin&)
@wischwasch
obj=0
ENDIF
nodsprst=FALSE
IF dplugwind=odplugwind THEN
nodsprst=TRUE
ENDIF
odplugwind=dplugwind
dspwind=TRUE
IF dplugnam$(p)<>"" THEN
IF BTST(winh,plugin&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=plugin&
'
IF INSTR(dplugnam$(p),"Easy")<>0 THEN
plugcr$="SWE STEPHAN WILHELM ELECTRONIC"+CHR$(0)
ELSE
plugcr$="WINREC/A.BINNER"+CHR$(0)
ENDIF
'
@textfeld2(plugin&,plugct1&,"COPYRIGHT BY"+CHR$(0),1)
a=LEN(plugcr$)
IF a>24 THEN
plugcr1$=LEFT$(plugcr$,24)+CHR$(0)
plugcr2$=CHR$(0)
b=RINSTR(plugcr1$," ")
IF b<>0 THEN
plugcr1$=LEFT$(plugcr1$,b-1)+CHR$(0)
plugcr2$=RIGHT$(plugcr$,a-b)
ENDIF
@textfeld2(plugin&,plugct2&,plugcr1$,1)
@textfeld2(plugin&,plugct3&,plugcr2$,1)
ELSE
@textfeld2(plugin&,plugct2&,plugcr$,1)
@textfeld2(plugin&,plugct3&,CHR$(0),1)
ENDIF
'
@hidetree2(plugct1&,FALSE)
@hidetree2(plugct2&,FALSE)
@hidetree2(plugct3&,FALSE)
@textfeld2(plugin&,plgtitel&,dplugnam$(p)+CHR$(0),1)
@hideplugs(TRUE)
@hideplugs2(TRUE)
@plugtexsize(FALSE)
@buttbh(panbox&,b,h)
b=160
~@xrsrc_gaddr(0,plugin&,pzu%)
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(plugin&)=b+4
@setbuttbh(panbox&,b,h)
DPOKE (pzu%+24*plgtitel&+16),20                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),86                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),4
DPOKE (pzu%+24*plugct2&+16),4
DPOKE (pzu%+24*plugct3&+16),4
IF dplugparnr(p)>0 THEN
@hidetree2(plglev1&,FALSE)
@hidetree2(plgbox1&,FALSE)
@hidetree2(levtxt1&,FALSE)
@hidetree2(levart1&,FALSE)
@hidetree2(levcnt1&,FALSE)
a$=dplugcart$(p,1)+CHR$(0)
@textfeld2(plugin&,levart1&,a$,1)
a$=dplugctxt$(p,1)+CHR$(0)
@textfeld2(plugin&,levtxt1&,a$,1)
@buttbh(panbox&,b,h)
b=160
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(plugin&)=b+4
@setbuttbh(panbox&,b,h)
py=105-INT(105/(dplugcmax(p,1)-dplugcmin(p,1))*(dplugcset(p,1)-dplugcmin(p,1)))
DPOKE (pzu%+24*plgbox1&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@dplugcalc(p,1)
a$=STR$(a)+CHR$(0)
@textfeld2(plugin&,levcnt1&,a$,1)
DPOKE (pzu%+24*plgtitel&+16),20                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),86                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),4
DPOKE (pzu%+24*plugct2&+16),4
DPOKE (pzu%+24*plugct3&+16),4
ENDIF
IF dplugparnr(p)>1 THEN
@hidetree2(plglev2&,FALSE)
@hidetree2(plgbox2&,FALSE)
@hidetree2(levtxt2&,FALSE)
@hidetree2(levart2&,FALSE)
@hidetree2(levcnt2&,FALSE)
a$=dplugcart$(p,2)+CHR$(0)
@textfeld2(plugin&,levart2&,a$,1)
a$=dplugctxt$(p,2)+CHR$(0)
@textfeld2(plugin&,levtxt2&,a$,1)
b=160
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(plugin&)=b+4
@setbuttbh(panbox&,b,h)
py=105-INT(105/(dplugcmax(p,2)-dplugcmin(p,2))*(dplugcset(p,2)-dplugcmin(p,2)))
DPOKE (pzu%+24*plgbox2&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@dplugcalc(p,2)
a$=STR$(a)+CHR$(0)
@textfeld2(plugin&,levcnt2&,a$,1)
DPOKE (pzu%+24*plgtitel&+16),20                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),86                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),4
DPOKE (pzu%+24*plugct2&+16),4
DPOKE (pzu%+24*plugct3&+16),4
ENDIF
IF dplugparnr(p)>2 THEN
@hidetree2(plglev3&,FALSE)
@hidetree2(plgbox3&,FALSE)
@hidetree2(levtxt3&,FALSE)
@hidetree2(levart3&,FALSE)
@hidetree2(levcnt3&,FALSE)
a$=dplugcart$(p,3)+CHR$(0)
@textfeld2(plugin&,levart3&,a$,1)
a$=dplugctxt$(p,3)+CHR$(0)
@textfeld2(plugin&,levtxt3&,a$,1)
b=224
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(plugin&)=b+4
@setbuttbh(panbox&,b,h)
py=105-INT(105/(dplugcmax(p,3)-dplugcmin(p,3))*(dplugcset(p,3)-dplugcmin(p,3)))
DPOKE (pzu%+24*plgbox3&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@dplugcalc(p,3)
a$=STR$(a)+CHR$(0)
@textfeld2(plugin&,levcnt3&,a$,1)
DPOKE (pzu%+24*plgtitel&+16),52                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),150                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),36
DPOKE (pzu%+24*plugct2&+16),36
DPOKE (pzu%+24*plugct3&+16),36
ENDIF
IF dplugparnr(p)>3 THEN
@hidetree2(plglev4&,FALSE)
@hidetree2(plgbox4&,FALSE)
@hidetree2(levtxt4&,FALSE)
@hidetree2(levart4&,FALSE)
@hidetree2(levcnt4&,FALSE)
a$=dplugcart$(p,4)+CHR$(0)
@textfeld2(plugin&,levart4&,a$,1)
a$=dplugctxt$(p,4)+CHR$(0)
@textfeld2(plugin&,levtxt4&,a$,1)
b=288
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(plugin&)=b+4
@setbuttbh(panbox&,b,h)
py=105-INT(105/(dplugcmax(p,4)-dplugcmin(p,4))*(dplugcset(p,4)-dplugcmin(p,4)))
DPOKE (pzu%+24*plgbox4&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@dplugcalc(p,4)
a$=STR$(a)+CHR$(0)
@textfeld2(plugin&,levcnt4&,a$,1)
DPOKE (pzu%+24*plgtitel&+16),84                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),214                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),68
DPOKE (pzu%+24*plugct2&+16),68
DPOKE (pzu%+24*plugct3&+16),68
ENDIF
IF dplugparnr(p)>4 THEN
@hidetree2(plglev5&,FALSE)
@hidetree2(plgbox5&,FALSE)
@hidetree2(levtxt5&,FALSE)
@hidetree2(levart5&,FALSE)
@hidetree2(levcnt5&,FALSE)
a$=dplugcart$(p,5)+CHR$(0)
@textfeld2(plugin&,levart5&,a$,1)
a$=dplugctxt$(p,5)+CHR$(0)
@textfeld2(plugin&,levtxt5&,a$,1)
b=352
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(plugin&)=b+4
@setbuttbh(panbox&,b,h)
py=105-INT(105/(dplugcmax(p,5)-dplugcmin(p,5))*(dplugcset(p,5)-dplugcmin(p,5)))
DPOKE (pzu%+24*plgbox5&+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@dplugcalc(p,5)
a$=STR$(a)+CHR$(0)
@textfeld2(plugin&,levcnt5&,a$,1)
DPOKE (pzu%+24*plgtitel&+16),116                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),278                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),100
DPOKE (pzu%+24*plugct2&+16),100
DPOKE (pzu%+24*plugct3&+16),100
ENDIF
IF dplugparnr(p)=21 THEN
@hideplugs(FALSE)
@hideplugs2(TRUE)
@plugtexsize(TRUE)
a$=dplugcart$(p,6)+CHR$(0)
@textfeld2(plugin&,levart6&,a$,1)
a$=dplugctxt$(p,6)+CHR$(0)
@textfeld2(plugin&,levtxt6&,a$,1)
a$=dplugcart$(p,7)+CHR$(0)
@textfeld2(plugin&,levart7&,a$,1)
a$=dplugctxt$(p,7)+CHR$(0)
@textfeld2(plugin&,levtxt7&,a$,1)
a$=dplugcart$(p,8)+CHR$(0)
@textfeld2(plugin&,levart8&,a$,1)
a$=dplugctxt$(p,8)+CHR$(0)
@textfeld2(plugin&,levtxt8&,a$,1)
a$=dplugcart$(p,9)+CHR$(0)
@textfeld2(plugin&,levart9&,a$,1)
a$=dplugctxt$(p,9)+CHR$(0)
@textfeld2(plugin&,levtxt9&,a$,1)
a$=dplugcart$(p,10)+CHR$(0)
@textfeld2(plugin&,levart10&,a$,1)
a$=dplugctxt$(p,10)+CHR$(0)
@textfeld2(plugin&,levtxt10&,a$,1)
a$=dplugcart$(p,11)+CHR$(0)
@textfeld2(plugin&,levart11&,a$,1)
a$=dplugctxt$(p,11)+CHR$(0)
@textfeld2(plugin&,levtxt11&,a$,1)
a$=dplugcart$(p,12)+CHR$(0)
@textfeld2(plugin&,levart12&,a$,1)
a$=dplugctxt$(p,12)+CHR$(0)
@textfeld2(plugin&,levtxt12&,a$,1)
a$=dplugcart$(p,13)+CHR$(0)
@textfeld2(plugin&,levart13&,a$,1)
a$=dplugctxt$(p,13)+CHR$(0)
@textfeld2(plugin&,levtxt13&,a$,1)
a$=dplugcart$(p,14)+CHR$(0)
@textfeld2(plugin&,levart14&,a$,1)
a$=dplugctxt$(p,14)+CHR$(0)
@textfeld2(plugin&,levtxt14&,a$,1)
a$=dplugcart$(p,15)+CHR$(0)
@textfeld2(plugin&,levart15&,a$,1)
a$=dplugctxt$(p,15)+CHR$(0)
@textfeld2(plugin&,levtxt15&,a$,1)
a$=dplugcart$(p,16)+CHR$(0)
@textfeld2(plugin&,levart16&,a$,1)
a$=dplugctxt$(p,16)+CHR$(0)
@textfeld2(plugin&,levtxt16&,a$,1)
a$=dplugcart$(p,17)+CHR$(0)
@textfeld2(plugin&,levart17&,a$,1)
a$=dplugctxt$(p,17)+CHR$(0)
@textfeld2(plugin&,levtxt17&,a$,1)
a$=dplugcart$(p,18)+CHR$(0)
@textfeld2(plugin&,levart18&,a$,1)
a$=dplugctxt$(p,18)+CHR$(0)
@textfeld2(plugin&,levtxt18&,a$,1)
a$=dplugcart$(p,19)+CHR$(0)
@textfeld2(plugin&,levart19&,a$,1)
a$=dplugctxt$(p,19)+CHR$(0)
@textfeld2(plugin&,levtxt19&,a$,1)
a$=dplugcart$(p,20)+CHR$(0)
@textfeld2(plugin&,levart20&,a$,1)
a$=dplugctxt$(p,20)+CHR$(0)
@textfeld2(plugin&,levtxt20&,a$,1)
a$=dplugcart$(p,22)+CHR$(0)
@textfeld2(plugin&,levart21&,a$,1)
a$=dplugctxt$(p,22)+CHR$(0)
@textfeld2(plugin&,levtxt21&,a$,1)
b=632
DPOKE (pzu%+24*pluglin&+20),b-5
rscw&(plugin&)=b+4
@setbuttbh(panbox&,b,h)
FOR i=6 TO 22
SELECT i
CASE 6
a=plgbox6&
b=levcnt6&
CASE 7
a=plgbox7&
b=levcnt7&
CASE 8
a=plgbox8&
b=levcnt8&
CASE 9
a=plgbox9&
b=levcnt9&
CASE 10
a=plgbox10&
b=levcnt10&
CASE 11
a=plgbox11&
b=levcnt11&
CASE 12
a=plgbox12&
b=levcnt12&
CASE 13
a=plgbox13&
b=levcnt13&
CASE 14
a=plgbox14&
b=levcnt14&
CASE 15
a=plgbox15&
b=levcnt15&
CASE 16
a=plgbox16&
b=levcnt16&
CASE 17
a=plgbox17&
b=levcnt17&
CASE 18
a=plgbox18&
b=levcnt18&
CASE 19
a=plgbox19&
b=levcnt19&
CASE 20
a=plgbox20&
b=levcnt20&
CASE 22
a=plgbox21&
b=levcnt21&
ENDSELECT
IF i<>21 THEN
py=105-INT(105/(dplugcmax(p,i)-dplugcmin(p,i))*(dplugcset(p,i)-dplugcmin(p,i)))
DPOKE (pzu%+24*a+18),py+3                    ! Hîhenposition des Volume-Sliders verÑndern
a=@dplugcalc(p,i)
a$=STR$(a)+CHR$(0)
@textfeld2(plugin&,b,a$,1)
ENDIF
NEXT i
DPOKE (pzu%+24*plgtitel&+16),256                    ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*panexit&+16),558                     ! Hîhenposition des Volume-Sliders verÑndern
DPOKE (pzu%+24*plugct1&+16),240
DPOKE (pzu%+24*plugct2&+16),240
DPOKE (pzu%+24*plugct3&+16),240
ENDIF
IF dplugparnr(p)=1 THEN
@buttbh(plglev1&,b2,h2)
panbox=68
DPOKE (pzu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=68-b2/2+13
DPOKE (pzu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=68-b2/2+13
DPOKE (pzu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=68-b2/2+12
DPOKE (pzu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF dplugparnr(p)=2 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (pzu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (pzu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (pzu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (pzu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF dplugparnr(p)=3 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (pzu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (pzu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (pzu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (pzu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev3&,b2,h2)
panbox=164
DPOKE (pzu%+24*plglev3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levtxt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levart3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt3&,b2,h2)
panbox=164-b2/2+12
DPOKE (pzu%+24*levcnt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF dplugparnr(p)=4 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (pzu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (pzu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (pzu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (pzu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev3&,b2,h2)
panbox=164
DPOKE (pzu%+24*plglev3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levtxt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levart3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt3&,b2,h2)
panbox=164-b2/2+12
DPOKE (pzu%+24*levcnt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev4&,b2,h2)
panbox=228
DPOKE (pzu%+24*plglev4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt4&,b2,h2)
panbox=228-b2/2+13
DPOKE (pzu%+24*levtxt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart4&,b2,h2)
panbox=228-b2/2+13
DPOKE (pzu%+24*levart4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt4&,b2,h2)
panbox=228-b2/2+12
DPOKE (pzu%+24*levcnt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
'
IF dplugparnr(p)=5 THEN
@buttbh(plglev1&,b2,h2)
panbox=36
DPOKE (pzu%+24*plglev1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levtxt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart1&,b2,h2)
panbox=36-b2/2+13
DPOKE (pzu%+24*levart1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt1&,b2,h2)
panbox=36-b2/2+12
DPOKE (pzu%+24*levcnt1&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev2&,b2,h2)
panbox=100
DPOKE (pzu%+24*plglev2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levtxt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart2&,b2,h2)
panbox=100-b2/2+13
DPOKE (pzu%+24*levart2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt2&,b2,h2)
panbox=100-b2/2+12
DPOKE (pzu%+24*levcnt2&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev3&,b2,h2)
panbox=164
DPOKE (pzu%+24*plglev3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levtxt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart3&,b2,h2)
panbox=164-b2/2+13
DPOKE (pzu%+24*levart3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt3&,b2,h2)
panbox=164-b2/2+12
DPOKE (pzu%+24*levcnt3&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev4&,b2,h2)
panbox=228
DPOKE (pzu%+24*plglev4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt4&,b2,h2)
panbox=228-b2/2+13
DPOKE (pzu%+24*levtxt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart4&,b2,h2)
panbox=228-b2/2+13
DPOKE (pzu%+24*levart4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt4&,b2,h2)
panbox=228-b2/2+12
DPOKE (pzu%+24*levcnt4&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
'
@buttbh(plglev5&,b2,h2)
panbox=292
DPOKE (pzu%+24*plglev5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levtxt5&,b2,h2)
panbox=292-b2/2+13
DPOKE (pzu%+24*levtxt5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levart5&,b2,h2)
panbox=292-b2/2+13
DPOKE (pzu%+24*levart5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(levcnt5&,b2,h2)
panbox=292-b2/2+12
DPOKE (pzu%+24*levcnt5&+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
ENDIF
panboxx=12
IF dplugparnr(p)=21 THEN
FOR i=1 TO 22
SELECT i
CASE 1
b1=plglev1&
b2=levtxt1&
b3=levart1&
b4=levcnt1&
CASE 2
b1=plglev2&
b2=levtxt2&
b3=levart2&
b4=levcnt2&
CASE 3
b1=plglev3&
b2=levtxt3&
b3=levart3&
b4=levcnt3&
CASE 4
b1=plglev4&
b2=levtxt4&
b3=levart4&
b4=levcnt4&
CASE 5
b1=plglev5&
b2=levtxt5&
b3=levart5&
b4=levcnt5&
CASE 6
b1=plglev6&
b2=levtxt6&
b3=levart6&
b4=levcnt6&
CASE 7
b1=plglev7&
b2=levtxt7&
b3=levart7&
b4=levcnt7&
CASE 8
b1=plglev8&
b2=levtxt8&
b3=levart8&
b4=levcnt8&
CASE 9
b1=plglev9&
b2=levtxt9&
b3=levart9&
b4=levcnt9&
CASE 10
b1=plglev10&
b2=levtxt10&
b3=levart10&
b4=levcnt10&
CASE 11
b1=plglev11&
b2=levtxt11&
b3=levart11&
b4=levcnt11&
panboxx=panboxx+8
CASE 12
b1=plglev12&
b2=levtxt12&
b3=levart12&
b4=levcnt12&
CASE 13
b1=plglev13&
b2=levtxt13&
b3=levart13&
b4=levcnt13&
CASE 14
b1=plglev14&
b2=levtxt14&
b3=levart14&
b4=levcnt14&
CASE 15
b1=plglev15&
b2=levtxt15&
b3=levart15&
b4=levcnt15&
CASE 16
b1=plglev16&
b2=levtxt16&
b3=levart16&
b4=levcnt16&
CASE 17
b1=plglev17&
b2=levtxt17&
b3=levart17&
b4=levcnt17&
CASE 18
b1=plglev18&
b2=levtxt18&
b3=levart18&
b4=levcnt18&
CASE 19
b1=plglev19&
b2=levtxt19&
b3=levart19&
b4=levcnt19&
CASE 20
b1=plglev20&
b2=levtxt20&
b3=levart20&
b4=levcnt20&
CASE 21
b1=plglev21&
b2=levtxt21&
b3=levart21&
b4=levcnt21&
panboxx=panboxx+16
ENDSELECT
IF i<>21 THEN
@buttbh(b1,bx,hx)
DPOKE (pzu%+24*b1+16),panboxx                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(b2,bx,hx)
panbox=panboxx-bx/2+13
DPOKE (pzu%+24*b2+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(b3,bx,hx)
panbox=panboxx-bx/2+13
DPOKE (pzu%+24*b3+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
@buttbh(b4,bx,hx)
panbox=panboxx-bx/2+12
DPOKE (pzu%+24*b4+16),panbox                    ! Hîhenposition des Volume-Sliders verÑndern
panboxx=panboxx+28
ENDIF
NEXT i
ENDIF
IF nodsprst=FALSE THEN
i=RINSTR(dspath$(p),".")
IF i>0 THEN
n$=s$+dspord$+LEFT$(dspath$(p),i)+dsprog$+CHR$(0)
@dsp_lodput(n$)
ENDIF
ENDIF
IF dplugparnr(p)>0 THEN
FOR i=1 TO dplugparnr(p)
boxsel3=i
IF i=21 THEN
i=22         ! equalizer-testweise
ENDIF
LPOKE mdat%,boxsel3-1
LPOKE mdat%+4,dplugcset(p,i)
IF demo=FALSE OR (falcon=TRUE AND magicmac=0) THEN
~XBIOS(98,L:mdat%,L:2,L:mdat%+50,L:0)
ENDIF
NEXT i
ENDIF
a=rsc_adr%(plugin&)
a=C:rsc_obspec%(L:a,plugnam&)           ! ...Adresse des Titels
a$="DSP-Effect"+CHR$(0)
FOR i=1 TO LEN(a$)
POKE a+i-1,ASC(MID$(a$,i,1))
NEXT i
@rsc_draw(plugin&,7)
winh=BSET(winh,plugin&)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=plugin&
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
ENDIF
RETURN
'
> FUNCTION dplugcalc(p,a)
LOCAL n,max,min,a$
n=dplugcset(p,a)
max=dplugcmax(p,a)
min=dplugcmin(p,a)
a$=dplugcart$(p,a)
IF a$="(NONE)" THEN
br=ROUND(100/(max-min)*(n-min))
ENDIF
RETURN br
ENDFUNC
'
> PROCEDURE drop2
.| Glob. Var.: nr#,rsc_adr%,rsc_menu&,nob#,ddinfo&,smpedit&,obj#,infoicon&
.|     ddblock&,blocfunc&,ddsmp16&,edsmp16&,ddpeak&,peaksw2&,ddarr&,arrange&
.|     ddtrakk&,trak&,ddloop&,loopart&,ddload&,smpload&,ddsave&,smpsave&
.|     ddfader&,edfade&,ddsetup&,setuper&,ddmon&,monitor&,dddsp&,swdsp&
.|     ddauto&,smpauto2&,ddmanu&,smpstrt2&,ddplay&,smpplay&,ddexit&,g#
.|     ddmidi&,edmidi&,obj&
.| Felder    : rsc_handle%(),rsc_adr%()
.| Ruft auf  : info,blkfunc,main,peak,arranger,trakker,loopwahl,smpload
.|     smpsave,fade,setupdat,monitor,dspwahl,smpauto,smpstart,smpplay
.|     goodbye,midi
.| Aufruf in : rsc_do-1,drop-1,
LOCAL nodrop,v
IF fly=FALSE AND menuda=TRUE THEN
nodrop=FALSE
IF rsc_handle%(nr)>0 AND rsc_handle%(nr)<1000 THEN
rsc_adr%=rsc_adr%(rsc_menu&)
~MENU_TNORMAL(rsc_adr%,MENU(4),1)
ENDIF
'
IF nob=ddconv& THEN
IF nr=smpedit& OR nr=trakker& OR nr=arranger& THEN
ELSE
nodrop=TRUE
ENDIF
ENDIF
IF nob=ddmodld& THEN
IF nr=smpedit& OR nr=trakker& OR nr=arranger& THEN
ELSE
nodrop=TRUE
ENDIF
ENDIF
IF nob=ddmodkil& THEN
IF nr=smpedit& OR nr=trakker& OR nr=arranger& THEN
ELSE
nodrop=TRUE
ENDIF
ENDIF
IF nob=ddpart& THEN
IF nr=smpedit& OR nr=trakker& OR nr=arranger& THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4=0 OR v4=8 THEN
@partfsel
ENDIF
IF v4=4 THEN
@xfade
ENDIF
IF v4=12 THEN
@mixer
ENDIF
ELSE
nodrop=TRUE
ENDIF
ENDIF
IF nob=ddpleft& THEN
obj=nob
playch=1
@setplaychannels
ENDIF
IF nob=ddpright& THEN
obj=nob
playch=2
@setplaychannels
ENDIF
IF nob=ddpboth& THEN
obj=nob
playch=3
@setplaychannels
ENDIF
IF nob=ddhost& THEN
obj=nob
IF dspuse=FALSE THEN
dspuse=TRUE
ELSE
dspuse=FALSE
ENDIF
@rsc_state(rsc_menu&,obj,2,dspuse)
ENDIF
IF nob=ddmix& THEN
obj=nob
IF dspmodemix=FALSE THEN
dspmodemix=TRUE
ELSE
dspmodemix=FALSE
ENDIF
@rsc_state(rsc_menu&,obj,2,dspmodemix)
ENDIF
IF nr=dspedit& THEN
IF nob>=ddplug1& AND nob<=ddplug10& THEN
obj=dspslot0&+(nob-ddplug1&)
FOR v=0 TO 9
@setbutton(dspslot0&+v,0)
NEXT v
@setbutton(obj,1)
@dspslots
ENDIF
ELSE
IF nob>=ddplug1& AND nob<=ddplug10& THEN
@plugin(nob-ddplug1&+1)
ENDIF
ENDIF
IF nob=ddinfo& THEN
obj=infoicon&
nr=smpedit&
@editselect
@setbutton(obj,1)
@info
ENDIF
IF nob=ddworkm& THEN
obj=wmodes&
nr=smpedit&
@editselect
@setbutton(obj,1)
@workmode
ENDIF
IF nob=ddcue& THEN
@cuelist
ENDIF
IF nob=ddblock& THEN
nr=smpedit&
obj=blocfunc&
@editselect
@setbutton(obj,1)
@blkfunc
ENDIF
IF nob=ddplgcfg& THEN
@plugconfig
ENDIF
IF nob=ddsmp16& THEN
obj=edsmp16&
nr=smpedit&
@editselect
@setbutton(obj,1)
@main
ENDIF
IF nob=ddpeak& THEN
obj=peaksw2&
nr=smpedit&
@editselect
@setbutton(obj,1)
@write_int(0)
peakint=FALSE
@peak
ENDIF
IF nob=ddarr& THEN
obj=arrange&
nr=smpedit&
@editselect
@setbutton(obj,1)
@arranger
ENDIF
IF nob=ddtrakk& THEN
obj=trak&
nr=smpedit&
@editselect
@setbutton(obj,1)
@trakker
ENDIF
IF nob=ddloop& THEN
obj=loopart&
nr=smpedit&
@editselect
@setbutton(obj,1)
@loopwahl
ENDIF
IF nob=ddload& THEN
IF nr=cuelist& THEN
obj=cueload&
@setbutton(obj,1)
@cueload
ENDIF
IF nr=arranger& THEN
obj=arrload&
@setbutton(obj,1)
@arrload
ENDIF
IF nr=trakker& THEN
obj=traklall&
@setbutton(obj,1)
@trkloadall
ENDIF
IF nr<>arranger& AND nr<>trakker& AND nr<>cuelist& THEN
obj=smpload&
neufsel=FALSE
nr=smpedit&
@editselect
@setbutton(obj,1)
@smpload
@editredraw
ENDIF
ENDIF
IF nob=ddbank& THEN
IF nr=blkfunc& OR nr=fsel& THEN
nodrop=TRUE
ELSE
obj=smpdbank&
neufsel=TRUE
@write_int(0)
nr=smpedit&
@editselect
@setbutton(obj,1)
@smpload
neufsel=FALSE
@editredraw
nob=0
ENDIF
ENDIF
IF nob=ddsave& THEN
IF nr=cuelist& THEN
obj=cuesave&
@setbutton(obj,1)
@cuesave
ENDIF
IF nr=arranger& THEN
obj=arrsave&
@setbutton(obj,1)
@arrsave
ENDIF
IF nr=trakker& THEN
obj=traksall&
@setbutton(obj,1)
@trksaveall
ENDIF
IF nr<>arranger& AND nr<>trakker& AND nr<>cuelist& THEN
obj=smpsave&
@write_int(0)
nr=smpedit&
@editselect
@setbutton(obj,1)
@smpsave
ENDIF
ENDIF
IF nob=ddfader& THEN
obj=edfade&
nr=smpedit&
@editselect
@setbutton(obj,1)
@fade
ENDIF
IF nob=ddsetup& THEN
obj=setuper&
nr=smpedit&
@editselect
@setbutton(obj,1)
@setupdat
ENDIF
IF nob=ddmon& THEN
'      obj=monitor&
nr=smpedit&
@editselect
'      @setbutton(obj,1)
@write_int(0)
@monitor
peakint=FALSE
ENDIF
IF nob=dddsp& THEN
obj=swdsp&
nr=smpedit&
@editselect
@setbutton(obj,1)
@dspwahl
ENDIF
IF nob=ddauto& THEN
obj=0
IF nr=smpedit& THEN
obj=smpauto2&
@setbutton(obj,1)
@smpauto
ENDIF
IF nr=peak& THEN
obj=smpautop&
@setbutton(obj,1)
@smpauto
peakint=FALSE
ENDIF
IF nr=arranger& THEN
obj=smpauto3&
hrdmrk=hrd
hrd=1
@setbutton(obj,1)
@smpauto
hrd=hrdmrk
ENDIF
IF nr=trakker& THEN
obj=smpauto4&
hrdmrk=hrd
hrd=1
@setbutton(obj,1)
@smpauto
hrd=hrdmrk
ENDIF
ENDIF
IF nob=ddmanu& THEN
IF nr=smpedit& THEN
obj=smpstrt2&
@setbutton(obj,1)
@smpstart
ENDIF
IF nr=peak& THEN
obj=smpstrtp&
@setbutton(obj,1)
@smpstart
peakint=FALSE
ENDIF
IF nr=arranger& THEN
obj=smpstrt3&
hrdmrk=hrd
hrd=1
@setbutton(obj,1)
@smpstart
hrd=hrdmrk
ENDIF
IF nr=trakker& THEN
obj=smpstrt4&
hrdmrk=hrd
hrd=1
@setbutton(obj,1)
@smpstart
hrd=hrdmrk
ENDIF
ENDIF
'
IF nob=dddisk& THEN
IF nr=blkfunc& THEN
nodrop=TRUE
ELSE
nr=smpedit&
@editselect
obj=disk&
@setbutton(obj,1)
@diskmenu
ENDIF
ENDIF
'
IF nob=ddplay& THEN
obj=0
IF nr=smpedit& THEN
obj=smpplay&
@setbutton(obj,1)
@smpplay
ENDIF
IF nr=peak& AND hrd=1 THEN
obj=playpeak&
@setbutton(obj,1)
@smpplay
peakint=FALSE
ENDIF
IF nr=arranger& THEN
obj=arrmidi&
@setbutton(obj,1)
@arrmidplay
ENDIF
IF nr=trakker& THEN
obj=trakplay&
hz=thz
@setbutton(obj,1)
@trkplay
ENDIF
ENDIF
IF nob=ddexit& THEN
@alerts(99)
IF g=1 THEN
@goodbye
ENDIF
ENDIF
IF nob=ddmidi& THEN
obj=edmidi&
nr=smpedit&
@editselect
@setbutton(obj,1)
@midi
ENDIF
IF nodrop=FALSE THEN
obj=0
obj&=0
ENDIF
nob=0
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF nodrop=TRUE THEN
@shortcuts
ENDIF
ELSE
@shortcuts
ENDIF
RETURN
'
> PROCEDURE setplaychannels
SELECT playch
CASE 0
@rsc_state(rsc_menu&,ddpleft&,2,FALSE)
@rsc_state(rsc_menu&,ddpright&,2,FALSE)
@rsc_state(rsc_menu&,ddpboth&,2,FALSE)
CASE 1
@rsc_state(rsc_menu&,ddpleft&,2,TRUE)
@rsc_state(rsc_menu&,ddpright&,2,FALSE)
@rsc_state(rsc_menu&,ddpboth&,2,FALSE)
CASE 2
@rsc_state(rsc_menu&,ddpleft&,2,FALSE)
@rsc_state(rsc_menu&,ddpright&,2,TRUE)
@rsc_state(rsc_menu&,ddpboth&,2,FALSE)
CASE 3
@rsc_state(rsc_menu&,ddpleft&,2,FALSE)
@rsc_state(rsc_menu&,ddpright&,2,FALSE)
@rsc_state(rsc_menu&,ddpboth&,2,TRUE)
ENDSELECT
IF demo=FALSE THEN
~XBIOS(xbs,29,playch)
ENDIF
RETURN
'
> PROCEDURE setup
LOCAL vnr,lrd,mg,mr
'
OPEN "I",#1,s$+rsc$
lrd=LOF(#1)
CLOSE #1
OPEN "I",#1,s$+rsc2$
lrd=lrd+LOF(#1)
CLOSE #1
OPEN "I",#1,s$+rsc3$
lrd=lrd+LOF(#1)
CLOSE #1
planes&=@planes
lrd=INT(lrd*1.4)
lrd=INT(lrd*(1+0.095*planes))  ! Speicher fÅr Resource-Files
'
dspsz=0
dspsz2=0
drawnew3=TRUE
vcuebut=-1
cuebut=-1
cuemax=100
vnewcue$=""
txfil$=""
newcue$=""
DIM cuelst(cuemax,5)   !1=active/nonactive/link, 2=start, 3=end, 4=smpte, 5=smpte offsetbackup fÅr nonactive
DIM cuetxt$(cuemax)    ! Marker-Texte
cuez=0
cuep=0
'
odplugwind=-1 !zuletzt initialisiertes DSP-Plugin
dplugwind=0 ! aktives DSP-Plugin
plugdsp=50  ! Anzahl der Dsp-Plugins
maxpar=22    ! Max. Anzahl von Reglern
DIM dspath$(plugdsp)     ! Plugin-File
DIM dplugnam$(plugdsp)   ! Plugin-Name
DIM dplugparnr(plugdsp)  ! Parameteranzahl
DIM dplugcmin(plugdsp,maxpar)   ! kleinster Parameterwert
DIM dplugcmax(plugdsp,maxpar)   ! grîûter Parameterwert
DIM dplugcset(plugdsp,maxpar)   ! aktueller Parameterwert
DIM dplugctxt$(plugdsp,maxpar)  ! Regler-Text
DIM dplugcart$(plugdsp,maxpar)  ! Regler-Art (dB,msec etc)
'
maxplug=10
DIM plugnam$(maxplug)   ! Plugin-Name
DIM plugpara(maxplug)   ! Parameter-Adresse
DIM plugpar$(maxplug)   ! Plugin Parameterliste
DIM plugparnr(maxplug)  ! Parameteranzahl
DIM plugcmin(maxplug)   ! kleinster Parameterwert
DIM plugcmax(maxplug)   ! grîûter Parameterwert
DIM plugcset(maxplug)   ! aktueller Parameterwert
DIM plugctxt$(maxplug)  ! Regler-Text
DIM plugcart$(maxplug)  ! Regler-Art (dB,msec etc)
DIM plgrlist(maxplug)   ! Record-Pluginliste
DIM plgplist(maxplug)   ! Play-Pluginliste
DIM plgsel$(maxplug)    ! gefundene Namen aus Config-Liste
DIM vplgsel$(maxplug)   ! NAmen aus Config-Liste
plugmem=0
ldplugs=FALSE
@initplugins
ldplugs=TRUE
FOR i=1 TO maxplug
plgrlist(i)=0
plgplist(i)=0
plugpara(i)=0
plugparnr(i)=0
plugcmax(i)=0
plugcset(i)=0
plugnam$(i)=""
plugctxt$(i)=""
plugcart$(i)=""
vplgsel$(i)=""
plgsel$(i)=""
NEXT i
'
DEFTEXT 1,0,0,4
notrkmem=FALSE
black=1      ! FÅllfarbe schwarz
red=2        ! FÅllfarbe rot
green=3      ! FÅllfarbe dunkelgrÅn
blue=4       ! FÅllfarbe blau
cyan=5       ! FÅllfarbe cyan
yellow=6     ! FÅllfarbe gelb
violet=7     ! FÅllfarbe violett
grey=8       ! FÅllfarbe grau
dgrey=9      ! FÅllfarbe dunkelgrau
dred=10      ! FÅllfarbe dunkelrot
dgreen=11    ! FÅllfarbe dunkelgrÅn
dblue=12     ! FÅllfarbe dunkelblau
dcyan=13     ! FÅllfarbe dunkelcyan
dyellow=14   ! FÅllfarbe dunkelgelb
dviolet=15   ! FÅllfarbe dunkelviolett
keyup=56
keydwn=50
keyleft=52
keyright=54
scanleft=115
scanright=116
spuren=2
just=FALSE
trashalert=FALSE
rettfound=FALSE
ldtrk=FALSE
leaveprog=FALSE
vio=FALSE
adrag=FALSE
tfselm=FALSE
idrag=FALSE
tdrag=FALSE
trdrag=FALSE
misli=0
memc=0
memtrak=0
memfade=0
nonstm=0
clipart=0
trkcart=0
clk=2
drawnew=FALSE
drawnew2=FALSE
edcart2=FALSE
fmclk=FALSE
tvideo=TRUE
tsolo=FALSE
adat=FALSE
wisch=FALSE
timedraw=FALSE
oldplay=FALSE
sabc=FALSE
trkmemr=FALSE
tncom=FALSE
noppause=FALSE
cupdate=FALSE
peakint=FALSE
extclock=FALSE
tplaystart=-1
tplayend=-1
cdivsms=-1
rchmo=0
wurl=0
spc=0
ext=0
arrcwert=0
edcart=0
aretime=0
trkz=0
mamidi=0
trakact=0
trkcwert=0
cted=-2
butdirect=FALSE
isave=FALSE
vtst=FALSE
infbutt=FALSE
infobinv=FALSE
rett=FALSE
proff=FALSE
cached=FALSE
away=FALSE
virtual=FALSE
virtwfile=FALSE
virtld=FALSE
makevirt3=FALSE
makevirt2=FALSE
makevirt=FALSE
blockld=FALSE
wfil$=""
tbkurz=17 ! Breite des Sliders, Ausnahme fÅr Zoomslider im Tracker-MenÅ
trakkz=0               ! Scrollposition fÅr Tracker
trakkyz=5              ! Zoomstufe fÅr Tracker
trkztop=10             ! Anzahl Scrolleinteilungen fÅr Tracker
tmax=trkztop
vcs=0
vce=0
scmax=50               ! Scroll-Auflîsungsstufen
zmax=30                ! Zoom-Auflîsungsstufen
buttg=16               ! Mindestbreite der Sliderbuttons
db16=96.32             ! dB-Auflîsung bei 16 bit
db24=144.49            ! dB-Auflîsung bei 24 bit
@setpeakblks
IF dig24=FALSE THEN
aufloes=db16           ! dB-Aufloesung der Wandler (16Bit)
mbit=4
ELSE
aufloes=db24           ! dB-Aufloesung der Wandler (16Bit)
mbit=6
ENDIF
tmbit=mbit
tdig24=dig24
anspiel=plead*hz*mbit  ! anzuspielende Sektoren
sector=4096            ! Grîûe der Fifos
recfifolen=sector      ! Grîûe des RECORD-FIFO
playfifolen=sector     ! Grîûe des PLAY-FIFO
sram=&HFE900000        ! Anfang des SRAM
hbuf=8192              ! Grîûe des Buffers fÅr Header-Read & sdload/sdsave & Parameter
'
lmcurv=xwidth*ywidth*planes&/8                 ! fÅr Editor-Screen
lmfade=248*224*planes&/8                       ! fÅr Fader-Screen
lmtrak=xwidth*ywidth*planes&/8                 ! fÅr Trakker-Screen
flycach=938*376*planes&/8                      ! fÅr Flydials-Screen (grîûter Flydial ist fsel&)
scachmem=lmcurv+lmfade+lmtrak+flycach+50000    ! Gesamt screen-cache
'
notmem=FALSE
IF gemvers>=&H1900 THEN
m1=@mxalloc(-1,1)  ! TT-RAM
m2=@mxalloc(-1,0)  ! ST-RAM
ELSE
m1=MALLOC(-1)      ! ST-RAM
m2=0
ENDIF
mg=m1+m2            ! freies RAM insgesamt
IF m1>m2 THEN
mbig=m1          ! grîûter freier Block
ELSE
mbig=m2          ! grîûter freier Block
ENDIF
'
IF mg<(hbuf+tmlen+mrest+mwmin+scachmem+lrd+plugmem) AND maxcol<>2 THEN     ! kein Platz fÅr Color-Resource ?
smalluse=TRUE
maxcol=2
tmlen=&H80000        ! 512 KB-Tracker-Cache
mrest=&H10000        ! Mindestrest-Speicher fÅr andere Applikationen
@calc_resource
OPEN "I",#1,s$+rsc$
lrd=LOF(#1)
CLOSE #1
OPEN "I",#1,s$+rsc2$
lrd=lrd+LOF(#1)
CLOSE #1
OPEN "I",#1,s$+rsc3$
lrd=lrd+LOF(#1)
CLOSE #1
lrd=INT(lrd*1.4)
lrd=INT(lrd*(1+0.095*planes))  ! Speicher fÅr Resource-Files
@calc_resource
@changetreenumbs
ENDIF
'
IF mg<(hbuf+tmlen+mrest+mwmin+scachmem+lrd+plugmem) THEN     ! kein Platz fÅr Screen-cache ?
windcache=FALSE
memfade=0
memc=0
memtrak=0
scachmem=0
plugmem=0
ldplugs=FALSE
ELSE
windcache=TRUE
ENDIF
'
IF mg>(hbuf+tmlen+mrest+mwmin+scachmem+lrd+plugmem) THEN
mtst=mg-hbuf-tmlen-mrest-mwmin-scachmem-lrd-plugmem
IF mallmax=FALSE AND mtst>=memmx AND memmx<>0 THEN
mtst=memmx    ! Speicher soll begrenzt werden (Setup-Wert)
ENDIF
IF mtst>mbig THEN ! Sampleram ist grîûer als grîûter freier Block ?
mtst=mbig
ENDIF
IF mtst>=mwmin THEN  ! Sampleram ist grîûer als Mindestgrenze ?
mtst=INT(mtst/24)*24
manf=@malloc(mtst,0)
merkfrei=manf
IF manf>0 THEN
manf=24+INT(manf/24)*24
meml=manf
memh=meml+mtst-24
mlen=memh-meml
mlen=INT(mlen/24)*24
big=1
tmem=@malloc(tmlen,0)         ! Buffer fÅr Tracker-Caches
IF tmem>0 THEN
IF windcache=TRUE THEN
memfade=@rsc_get(0,0,248,224)
memc=@rsc_get(0,0,xwidth,ywidth)
memtrak=@rsc_get(0,0,xwidth,ywidth)
IF memfade<=0 OR memc<=0 OR memtrak<=0 THEN
away=TRUE
ENDIF
ENDIF
IF away=FALSE THEN
mdat%=@malloc(hbuf+32,0)         ! Buffer fÅr Header-Read & sdload/sdsave & Parameter
dfmem=mdat%+hbuf
mdatf=mdat%
IF mdat%>0 THEN
mdat%=INT(mdat%/2)*2+2
IF notmem=FALSE THEN
@maschruf9(tmem,tmem+tmlen)
ENDIF
wback%=INT((mdat%+(hbuf-32))/mbit)*mbit
ELSE
away=TRUE
ENDIF
ENDIF
ELSE
away=TRUE
ENDIF
ELSE
away=TRUE
ENDIF
ELSE
away=TRUE
ENDIF
tim$=TIME$
btim$=tim$
IF gemvers>=&H1900 THEN
mr=@mxalloc(-1,1)+@mxalloc(-1,0)
ELSE
mr=MALLOC(-1)      ! ST-RAM
ENDIF
IF mr<mrest THEN
away=TRUE
ENDIF
'
IF away=FALSE THEN
dat=((INT(anfload/2))*2)+2
cs=0
ce=mlen-1
vmem=INT(mlen/mbit)*mbit
mlen=vmem
DIM clkdiv(60,3)
clkdata:
DATA 1,2,3,4,7,10,17,21,25,18,15,12,19,26,41,16,49,34,27,20,31,42,35,50,39,28,43,58,32,51,36,55,40,44,48,52,56,60
DATA 3,4,7,17,8,25,29,22,37,41,45,49,53,57
RESTORE clkdata
FOR i=1 TO 38
READ a
clkdiv(i,2)=a
NEXT i
FOR i=1 TO 14
READ a
clkdiv(i,3)=a
NEXT i
'
DIM lcs(lmax)         ! Zoomstufe startpointer mem
DIM lce(lmax)         ! zoomstufe endpointer mem
'
DIM midislide(127)    ! Midi-Slider
DIM vmidislide(127)   ! Midi-Slider Backup
DIM arrfn$(lmax2)     ! Samplename
DIM arrlen%(lmax2)    ! SamplelÑnge
DIM arrmidi&(lmax2)   ! Midi-Channel(highbyte)+Note(lowbyte)
DIM arrpath$(lmax2)   ! Samplepfad (ass,byte)
'
DIM arrloop!(lmax2)   ! Loopen (ass,boolean-byte)
DIM arrtri|(lmax2)    ! 1=vorwÑrts,2=rÅckwÑrts,3=cross (ass,byte)
DIM midi&(15,127)     ! channel,note -> entry (ass,word)
DIM arrpath%(lmax2)   ! Samplepfad-Pointer (ass,long)
DIM arrstrt%(lmax2)   ! Startwert (ass,long)
DIM arrend%(lmax2)    ! Endwert (ass,long)
DIM arrsrate%(lmax2)  ! Samplerate (ass,long)
DIM arrbits!(lmax2)   ! Bitdepth (16/24 bit)
DIM arrhead(lmax2)    ! Header-LÑnge
DIM arrmems%(lmax2)   ! Startposition im Arranger-RAM (ass,long)
DIM arrmeml%(lmax2)   ! LÑnge im Arranger-RAM (ass,long)
'
DIM trkfn$(lmax3)     ! track-name
DIM trktnr(lmax3)     ! Nummer in der Fileselect-Liste
DIM trkcom$(lmax3)    ! track-Kommentar (selbstdefiniert) in der Fileliste
DIM trkpath$(lmax3)   ! track-filepfad
DIM trktime(lmax3)    ! smpte-start in 1/1000tel sekunden
DIM trkvor(lmax3)     ! zeiger auf vorheriges sample im gleichen kanal
DIM trknext(lmax3)    ! zeiger auf nÑchstes sample im gleichen kanal
DIM trkstrt(lmax3)    ! anfangspunkt im sample
DIM trkend(lmax3)     ! endpunkt im sample
DIM trklen(lmax3)     ! gesamtlÑnge des samples
DIM trkhead(lmax3)    ! Header des Samples
DIM trkbits(lmax3)    ! Bitanzahl des Samples
DIM trkloop(lmax3)    ! loopen ja/nein
DIM trktri(lmax3)     ! richtung
DIM trksrate(lmax3)   ! sample-rate in hz
DIM trkch(lmax3)      ! track-kanal
DIM trkx(lmax3)       ! X-Position der Curve-Darstellung
DIM trkb(lmax3)       ! Breite der Curve-Darstellung
DIM trkmem(lmax3)     ! Memory-Adresse des Balken-Caches
DIM trkg(lmax3)       ! Anzahl der Pixel des Balken-Caches
DIM tcach(lmax3)      ! Balken-Cache cached/noncached
DIM trkmax(lmax3)     ! maxilmaler Peakwert des Balken-Caches
'
DIM trkpnt(trkvmax)         ! welche position hat das erste sample im kanal x ?
DIM trklev(trkvmax)         ! LautstÑrkewerte der einzelnen Tracks (0-200)
DIM trkpan(trkvmax)         ! Balancewerte der einzelnen Tracks (-50 bis 50)
DIM trkmute(trkvmax)        ! Mute fÅr einzelne Tracks
DIM trksmute(trkvmax)       ! Mute-Merker fÅr Solo-Play
DIM trkstereo(trkvmax)      ! Kanal ist Stereokanal oder Monokanal ?
DIM trktxt$(trkvmax)        ! Textbeschreibung fÅr Kanal
'
maxspur=16
DIM trkwahl(maxspur)        ! welche sind die ausgewÑhlten Tracks ?
DIM trkswahl(maxspur)       ! Merker fÅr Soloplay fÅr ausgewÑhlte Tracks
DIM trkplay(maxspur)        ! welche ist das aktuelle sample im kanal x beim abspielen ?
DIM trkfull24(maxspur)      ! 16bit oder 24bit-spur ?
DIM aktpos(maxspur)         ! aktuelle position der 8 tracks bei play
DIM thandle(maxspur)        ! aktuelle handles der 8 tracks
DIM trkclr(maxspur)         ! Kanal schonmal gelîscht ?
DIM trkclr2(maxspur)        ! Kanal-Ende und schon gelîscht ?
DIM trkseek(maxspur)        ! Seek-Position fÅr Playstart-Position <>0
DIM trkmplay(maxspur)       ! Nummer der geÑnderten Play-Startposition retten fÅr Playstart-Position <>0
DIM trkseek2(maxspur)       ! Seek-Position fÅr Playend-Position <>0
DIM trkmplay2(maxspur)      ! Nummer der geÑnderten Play-Endposition retten fÅr PlayEnd-Position <>0
DIM trkmplay3(maxspur)      ! Nummer der geÑnderten Next-position retten fÅr PlayEnd-Position <>0
DIM ltrk(maxspur)           ! LÑnge der einzelnen zu fÅllenden Buffer-Blîcke
FOR i=0 TO trkvmax
trklev(i)=100
trktxt$(i)="-----"
trkstereo(i)=TRUE
NEXT i
trkmem(0)=tmem
DIM dbank$(lmax4)
DIM dbank2$(lmax4)
DIM mbank$(lmax4)
DIM mbank2$(lmax4)
DIM tdbank$(lmax4)
DIM tdbank2$(lmax4)
DIM mblocks(lmax3)
DIM mblocke(lmax3)
DIM mblockp$(lmax3)
loopz=999
DIM loops%(loopz,4)
DIM vloops%(loopz,4)
DIM edmtxt$(loopz)
DIM vedmtxt$(loopz)
bloopz=8
DIM bloops%(loopz,4)
DIM vbloops%(loopz,4)
FOR i=1 TO bloopz
FOR j=1 TO 4
bloops%(i,j)=-1
vbloops%(i,j)=-1
NEXT j
NEXT i
FOR i=1 TO loopz
FOR j=1 TO 4
loops%(i,j)=-1
vloops%(i,j)=-1
NEXT j
NEXT i
cwerte1=0
mbs=0
vmbs=0
n=note
FOR i=1 TO lmax2
arrmidi&(i)=n+256*(ch-1)
INC n
IF n>127 THEN
n=0
ENDIF
NEXT i
lz=1
smplen=mlen
ext2$=ext$
IF ext2$="*" THEN
IF dig24=FALSE THEN
ext2$="S16"
ELSE
ext2$="S24"
ENDIF
ENDIF
smpnam$="MEMORY."+ext2$
path$=lfw$+smpnam$
@maschruf9(meml,memh)
retime=0
xmp=0
okmark=0
merkerr=0
merkfreq=0
protnr=0
lded=0
hrd=0
merk1=-1
merk2=-1
merk3=-1
merk4=-1
merkc=-1
prt=-1
plt=-1
prw=FALSE
plw=FALSE
zsf=TIMER
stl=0
sth=0
std=4
staes=0
@balwrite(vol,volinbal,balinmax)                                 ! Eingang auf 0 db stellen
balinmax2=24
@balwrite2(vol2,volinbal2,balinmax2)                             ! Ausgang auf 0 db stellen
ENDIF
ELSE
away=TRUE
ENDIF
RETURN
'
> PROCEDURE errorcode
e$=ERR$(ERR)
e=INSTR(2,e$,"[")
e$=RIGHT$(e$,LEN(e$)-e)
e=INSTR(e$,"]")
e$=LEFT$(e$,e-1)
e=INSTR(e$,"|")
e2=FALSE
IF e<>0 THEN
e$=LEFT$(e$,e-1)
e2=TRUE
ENDIF
IF e2=FALSE AND LEN(e$)>28 THEN
e$=LEFT$(e$,25)+"..."
ENDIF
IF e2=TRUE THEN
IF LEN(e$)>25 THEN
e$=LEFT$(e$,25)+"..."
ELSE
e$=e$+"..."
ENDIF
ENDIF
RETURN
'
> PROCEDURE alertload
LOCAL a$,a,lngnr
IF EXIST(lng$)=TRUE THEN
IF alertflag=TRUE THEN
ERASE lng$()
ENDIF
DIM lng$(300)
OPEN "I",#1,lng$
DO
INPUT #1,a$
a=INSTR(a$," ")
lngnr=VAL(LEFT$(a$,a-1))
EXIT IF lngnr=999
a$=RIGHT$(a$,LEN(a$)-a-1)
lng$(lngnr)=LEFT$(a$,LEN(a$)-1)
LOOP
alertflag=TRUE
CLOSE #1
ENDIF
RETURN
'
> PROCEDURE alerts(alert)
LOCAL aobj,afly,a$,abc,ja$,no$,naja$,ok$,exit$,anr
anr=nr
aobj=obj
afly=fly
fly=TRUE
edit_obj&=0
@wischwasch
a$=lng$(alert)
ja$=lng$(56)
no$=lng$(57)
naja$=lng$(58)
ok$=lng$(59)
exit$=lng$(60)
SELECT alert
CASE 1
g=@rsc_alert(3,a$,1,exit$)
CASE 2
g=@rsc_alert(3,a$,1,exit$)
CASE 3
g=@rsc_alert(3,a$,1,exit$)
CASE 4
g=@rsc_alert(3,a$,1,ok$)
CASE 5
g=@rsc_alert(3,a$,2,ok$+"|"+exit$)
CASE 6
g=@rsc_alert(3,a$,2,ok$+"|"+exit$)
CASE 7
g=@rsc_alert(1,a$,1,ok$)
CASE 8
g=@rsc_alert(3,a$,1,exit$)
CASE 9
g=@rsc_alert(3,a$,1,exit$)
CASE 10
g=@rsc_alert(3,a$,1,exit$)
CASE 11
g=@rsc_alert(1,a$,1,exit$)
CASE 12
g=@rsc_alert(1,a$,1,ok$)
CASE 13
g=@rsc_alert(1,a$,1,ok$)
CASE 14
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 15
g=@rsc_alert(1,a$,1,exit$)
CASE 16
g=@rsc_alert(1,a$,1,ok$)
CASE 17
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 18
g=@rsc_alert(1,a$,1,ok$)
CASE 19
g=@rsc_alert(1,a$,1,exit$)
CASE 20
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 21
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 22
g=@rsc_alert(1,a$,1,exit$)
CASE 23
g=@rsc_alert(1,a$,1,exit$)
CASE 24
g=@rsc_alert(1,a$,1,ok$)
CASE 25
g=@rsc_alert(3,a$,1,exit$)
CASE 26
g=@rsc_alert(2,a$,1,ok$+"|"+exit$)
CASE 27
g=@rsc_alert(3,a$,1,exit$)
CASE 28
g=@rsc_alert(1,a$,1,exit$)
CASE 29
g=@rsc_alert(1,a$,1,naja$)
CASE 30
alrt$=a$+"|"+alrt$
g=@rsc_alert(1,alrt$,1,ok$)
CASE 31
g=@rsc_alert(2,a$,1,ok$+"|"+exit$)
CASE 32
g=@rsc_alert(1,a$,1,exit$)
CASE 33
g=@rsc_alert(1,a$,1,exit$)
CASE 34
g=@rsc_alert(1,a$,1,ok$)
CASE 35
g=@rsc_alert(1,a$,1,ok$)
CASE 36
g=@rsc_alert(1,a$,1,ok$)
CASE 37
g=@rsc_alert(1,a$,1,ok$)
CASE 38
g=@rsc_alert(1,a$,1,ok$)
CASE 39
g=@rsc_alert(3,a$,1,exit$)
CASE 40
g=@rsc_alert(2,a$,2,ja$+"|"+no$)
CASE 41
g=@rsc_alert(2,a$,2,ja$+"|"+no$)
CASE 42
g=@rsc_alert(1,a$,1,exit$)
CASE 43
g=@rsc_alert(2,a$,2,ja$+"|"+no$)
CASE 44
g=@rsc_alert(2,a$,2,ja$+"|"+no$)
CASE 45
g=@rsc_alert(2,a$,2,ja$+"|"+no$)
CASE 46
a=@rsc_alert(3,a$,1,ok$)
CASE 47
g=@rsc_alert(1,a$,1,exit$)
CASE 48
frag=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 49
g=@rsc_alert(0,a$,1,ok$)
CASE 50
@errorcode
abc=RINSTR(a$,"|")-1
g=@rsc_alert(3,LEFT$(a$,abc)+STR$(ERR)+"|"+CHR$(34)+e$+CHR$(34)+RIGHT$(a$,LEN(a$)-abc),2,ja$+"|"+no$)
CASE 51
g=@rsc_alert(1,a$,1,ok$)
CASE 61
g=@rsc_alert(2,a$,1,ok$+"|"+exit$)
CASE 62
g=@rsc_alert(2,a$,1,ok$+"|"+exit$)
CASE 63
g=@rsc_alert(1,a$,1,exit$)
CASE 64
g=@rsc_alert(1,a$,1,exit$)
CASE 65
g=@rsc_alert(2,a$,2,ok$+"|"+exit$)
CASE 66
g=@rsc_alert(2,a$+STR$(lastarr),1,ok$+"|"+exit$)
CASE 67
g=@rsc_alert(1,a$,1,exit$)
CASE 68
g=@rsc_alert(1,a$,1,ja$+"|"+no$)
CASE 71
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 72
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
CASE 73
g=@rsc_alert(1,a$,1,exit$)
CASE 74
g=@rsc_alert(1,a$,1,exit$)
CASE 75
g=@rsc_alert(1,a$,1,exit$)
CASE 99
g=@rsc_alert(2,a$,1,ja$+"|"+no$)
ENDSELECT
nr=anr
obj=aobj
fly=afly
edit_obj&=0
wischwasch
RETURN
'
> PROCEDURE alerts2(alert)
SELECT alert
CASE 1
m$=lng$(52)+CHR$(0)
CASE 2
m$=lng$(53)+CHR$(0)
ENDSELECT
RETURN
'
> PROCEDURE alerts3(alert)
SELECT alert
CASE 1
@write(lng$(54),5)
CASE 2
@write(lng$(55),6)
ENDSELECT
RETURN
'
> PROCEDURE language
LOCAL l,fx,fb,zu%,boxadr,fx1,fx2,fx3
'
fx=88
fx1=88+16
fb=8*(LEN(lng$(201))+1)
@droppos(dddat&,fx,fb)             ! MenÅbalken Datei
fx=fx+fb
fx2=fx+16
fb=8*(LEN(lng$(202))+1)
@droppos(ddwind&,fx,fb)            ! MenÅbalken Fenster
fx=fx+fb
fx3=fx+16
fb=8*(LEN(lng$(203))+1)
@droppos(ddfunc&,fx,fb)            ! MenÅbalken Funktion
fx=fx+fb
fx4=fx+16
fb=8*(LEN(lng$(223))+1)
@droppos(ddplugin&,fx,fb)            ! MenÅbalken Plugins
'
zu%=rsc_adr%(dropdown&)
boxadr=zu%+24*2                    ! MenÅ-Balken
DPOKE boxadr+20,fx+fb
'
l=8*(LEN(lng$(205))+3)
@droppos(ddload&-1,fx1,l)          ! Box fÅr MenÅ Datei
l=8*(LEN(lng$(208))+3)
@droppos(ddsmp16&-1,fx2,l)         ! Box fÅr MenÅ Fenster
l=8*(LEN(lng$(215))+3)
@droppos(ddsetup&-1,fx3,l)         ! Box fÅr MenÅ Funktion
l=8*24
@droppos(ddplug1&-1,fx4,l)         ! Box fÅr MenÅ Plugins
l=8*(LEN(lng$(205))+3)
'
@droppos(ddload&,0,l)              ! Box fÅr load
@droppos(ddsave&,0,l)              ! Box fÅr save
@droppos(ddexit&,0,l)              ! Box fÅr exit
@droppos(ddgrenz&,0,l)             ! Box fÅr line
'
@droptxt(ddstar&,lng$(200))
@droptxt(dddat&,lng$(201))
@droptxt(ddwind&,lng$(202))
@droptxt(ddfunc&,lng$(203))
@droptxt(ddinfo&,lng$(204))
@droptxt(ddplugin&,lng$(223))
@droptxt(ddload&,lng$(205)+"^L ")
@droptxt(ddsave&,lng$(206)+"^S ")
@droptxt(ddexit&,lng$(207)+"^Q ")
@droptxt(ddsmp16&,lng$(208)+"^G ")
@droptxt(ddblock&,lng$(209)+"^B ")
@droptxt(ddpeak&,lng$(210)+"^P ")
@droptxt(ddarr&,lng$(211)+"^A ")
@droptxt(ddtrakk&,lng$(212)+"^T ")
@droptxt(ddloop&,lng$(213)+"^O ")
@droptxt(dddsp&,lng$(214)+"^D ")
@droptxt(ddsetup&,lng$(215)+"^E ")
@droptxt(ddfader&,lng$(216)+"^F ")
@droptxt(ddmidi&,lng$(217)+"^N ")
@droptxt(ddbank&,lng$(218)+CHR$(7)+"S ")
@droptxt(ddmon&,lng$(219)+"^M ")
@droptxt(ddauto&,lng$(220)+"^SPACE ")
@droptxt(ddmanu&,lng$(221)+CHR$(1)+"SPACE ")
@droptxt(ddplay&,lng$(222)+" SPACE ")
'
@droptxt(dddisk&,lng$(224)+CHR$(7)+"D ")
@droptxt(ddpart&,lng$(225)+CHR$(7)+"P ")
@droptxt(ddworkm&,lng$(226)+"^W ")
@droptxt(ddcue&,lng$(227)+"^C ")
@droptxt(ddconv&,lng$(228)+"^"+CHR$(7)+"N ")
@droptxt(ddmodld&,lng$(229)+"^"+CHR$(7)+"M ")
@droptxt(ddmodkil&,lng$(230)+"^"+CHR$(7)+"K ")
@droptxt(ddplgcfg&,lng$(231)+"^"+CHR$(7)+"C ")
@droptxt(ddpleft&,lng$(232))
@droptxt(ddpright&,lng$(233))
@droptxt(ddpboth&,lng$(234))
RETURN
'
> PROCEDURE droptxt(dpoint,dtxt$)
LOCAL string,it
zu%=rsc_adr%(dropdown&)
CHAR{C:rsc_obspec%(L:zu%,dpoint)}=dtxt$
RETURN
'
> PROCEDURE droppos(dpoint,xp,bp)
LOCAL string,it
zu%=rsc_adr%(dropdown&)
buttadr=zu%+24*dpoint
DPOKE buttadr+16,xp
DPOKE buttadr+20,bp
RETURN
'
> PROCEDURE dropentrys(dpoint,hp)
LOCAL zu%,buttadr,h
zu%=rsc_adr%(dropdown&)
buttadr=zu%+24*dpoint
DPOKE buttadr+22,hp*16
RETURN
'
> PROCEDURE killedit
IF nr=smpedit& THEN
mbs=0
zoomp=0
scrollp=0
IF virtual=TRUE THEN
@trashvirt
ENDIF
@maschruf9(meml,memh)
cs=0
ce=mlen
@zslidecalc
@scrollinit
@makepnt
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@markdel
@clsed
@restaura
ENDIF
RETURN
'
> PROCEDURE loadtoedit
LOCAL a
ldtrk=TRUE
ldtrk2=TRUE
a$=trkpath$(trkp)
b$=trkfn$(trkp)
a=INSTR(a$,CHR$(0))
IF a>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
a=INSTR(b$,CHR$(0))
IF a>0 THEN
b$=LEFT$(b$,a-1)
ENDIF
a=RINSTR(a$,"\")
IF LEN(a$)=0 THEN
ordner$=""
ELSE
ordner$=LEFT$(a$,a)
ENDIF
IF LEN(b$)<>0 THEN
IF trkbits(trkp)=24 THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
'
enam$=b$
nam$=b$
efil$=ordner$+b$
fil$=ordner$+b$
a=RINSTR(nam$,".")
IF a<>0 THEN
infname$=LEFT$(nam$,a)+inf$
ENDIF
smplen=trklen(trkp)*mbit+trkhead(trkp)
smpnam$=nam$
bnam$=smpnam$
path$=fil$
'
tblks=blks
blks=0
IF virtual=TRUE THEN
@trashvirt
ENDIF
cs=0
ce=mlen
@smpload
@wischwasch
ldtrk3=TRUE
a=0
REPEAT
INC a
UNTIL ((trkstrt(trkp)*mbit)=loops%(a,1) AND (trkend(trkp)*mbit)=loops%(a,2)) OR a=loopz
IF ((trkstrt(trkp)*mbit)=loops%(a,1) AND (trkend(trkp)*mbit)=loops%(a,2) AND sms>0) THEN
sms=a
ELSE
sms=sms+1
loops%(sms,1)=trkstrt(trkp)*mbit
loops%(sms,2)=trkend(trkp)*mbit
loops%(sms,3)=-1
loops%(sms,4)=-1
ENDIF
sms2=1
@restaura
ldtrk2=FALSE
blks=tblks
vtmbit=tmbit
ENDIF
RETURN
'
> PROCEDURE filltrkmem
LOCAL i,membl,bw,memz
IF tmemf=1 THEN
memz=mems1+(ltrk*tmbit*(c-1))+dpos*ltrk(c)
bw=GEMDOS(63,thandle(c),L:tlen*ltrk(c),L:memz)
'    PRINT "0>";thandle(c),memz,tlen*ltrk(c),bw
ENDIF
IF tmemf=0 THEN
memz=mems2+(ltrk*tmbit*(c-1))+dpos*ltrk(c)
bw=GEMDOS(63,thandle(c),L:tlen*ltrk(c),L:memz)
'    PRINT "1>";thandle(c),memz,tlen*ltrk(c),bw
ENDIF
@time8
RETURN
'
> PROCEDURE tcorr
IF dspuse=TRUE THEN
tback%=tback%/spuren
ENDIF
RETURN
'
> PROCEDURE time8
LOCAL v,v2,k,v4
IF mislide=TRUE THEN
REPEAT
@midislide   ! Midi Slidersteuerung
@midislide3
UNTIL INP?(3)=FALSE
ENDIF
IF tdown=FALSE THEN
hsec2=INT((TIMER-t)/2)
tback%=LPEEK(trecback+24)          !36 Playbyte
@tcorr
peakret=trecback+16    !28 max. Peakwert
@peakrec3
IF INT(hsec2/16)<>INT(hsec/16) THEN            ! ums langsamer zu machen !
hsec=INT(tback%/thz/tmbit*100)
@htimeset                                  ! zeituhr zeigen
hsec=hsec2
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(traktime&,a$,1)
~GRAF_MKSTATE(v,v2,k,v4)
IF k=2 AND pmo8=TRUE THEN
IF v4=0 THEN
INC pt
IF pt=4 THEN
pt=0
ENDIF
ELSE
IF pt=0 THEN
pt=4
ENDIF
DEC pt
ENDIF
@channel
REPEAT
UNTIL @mousek=0
ENDIF
ENDIF
@peakbreak3
IF recp=TRUE THEN
IF exfill=FALSE THEN
@fillrmem
ELSE
@zeigtime2
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE trkplay
LOCAL r,akku,j,rr,a,i,cl,ts,pm,sa,tm,tp,tl,ts,b,tbtest
'
'  16 Channel-harddisk-player
'
IF tdig24=TRUE THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
trkall16=FALSE
pl=0
pr=0
vpl=0
vpr=0
wpl=0   ! peakhold left
wpr=0   ! peakhold right
tsfila%=0
IF nr=trakker& THEN
@textfeld(trakinfo&,CHR$(0),1)
ENDIF
IF demo=FALSE AND falcon=FALSE THEN
@spuren(spuren*2)
@setadatp
spurz=spuren*2
'
IF dspuse=TRUE THEN
SELECT spurz
CASE 1 TO 4
@dspplay4
'      PAUSE 20
CASE 5 TO 8
@dspplay8
'      PAUSE 20
CASE 9 TO 12
CASE 13 TO 16
ENDSELECT
ENDIF
IF pch4=TRUE THEN
@dspplay2
'    PAUSE 20
~XBIOS(xbs,27,1)
ENDIF
@soloplay1
FOR i=1 TO spurz
trkstereo(i)=TRUE
trkplay(i)=0
NEXT i
tprint=FALSE
IF tprint=TRUE THEN
PRINT
PRINT
PRINT "samplemem(start,end):";meml,memh
ENDIF
IF tprint=TRUE THEN
CLS
ENDIF
sa=0
FOR a=1 TO spurz
IF trkwahl(a)>0 THEN
trkplay(a)=trkpnt(trkwahl(a))
tm=trkmute(trkwahl(a))
IF tm=TRUE OR (trkplay(a)<>0 AND tdig24=FALSE AND trkbits(trkplay(a))=24) THEN
INC sa
ENDIF
ELSE
INC sa
ENDIF
trkclr(a)=0
trkclr2(a)=0
NEXT a
'
FOR a=1 TO maxspur
trkfull24(a)=FALSE
NEXT a
IF matrix=FALSE THEN           ! CPU-Mode ?
FOR a=1 TO spuren
b=trkplay(a)
IF b<>0 THEN
REPEAT
IF trkbits(b)=24 THEN
trkfull24(a)=TRUE         ! nicht alles 16bit-samples in der spur
ENDIF
b=trknext(b)
UNTIL b=0 OR trkfull24(a)=TRUE
ENDIF
NEXT a
ENDIF
'
IF tplaystart>0 THEN
FOR a=1 TO spurz    ! Startpositionen anpassen fÅr Play-Startposition>0
trkseek(a)=0
trkmplay(a)=0
a2=trkplay(a)
IF a2<>0 THEN
a5=0
REPEAT
a3=trktime(a2)
IF a3<=tplaystart THEN
a5=a2
ENDIF
a2=trknext(a2)
UNTIL a3>tplaystart OR a2=0
IF a5<>0 THEN
trkplay(a)=a5
trkseek(a)=tplaystart-trktime(a5)
IF trkseek(a)<0 OR (trkseek(a)+trkstrt(a5))>=trkend(a5) THEN
trkseek(a)=0
trkplay(a)=trknext(a5)   !neu
ENDIF
trkstrt(a5)=trkstrt(a5)+trkseek(a)
trktime(a5)=trktime(a5)+trkseek(a)
trkmplay(a)=a5
ELSE
trkseek(a)=0
ENDIF
ENDIF
NEXT a
ENDIF
IF tplayend>0 THEN
FOR a=1 TO spurz    ! Endpositionen anpassen fÅr Play-Endposition
trkseek2(a)=0
trkmplay2(a)=0
trkmplay3(a)=0
a2=trkplay(a)
IF a2<>0 THEN
a5=0
REPEAT
a3=trktime(a2)
IF a3<tplayend THEN
a5=a2
ENDIF
a2=trknext(a2)
UNTIL a3>tplayend OR a2=0
IF a5<>0 THEN
trkseek2(a)=(trktime(a5)+(trkend(a5)-trkstrt(a5)))-tplayend
IF trkseek2(a)<0 THEN
trkseek2(a)=0
ENDIF
trkmplay3(a)=trknext(a5)
trknext(a5)=0
trkend(a5)=trkend(a5)-trkseek2(a)
trkmplay2(a)=a5
ELSE
trkplay(a)=0
trkseek2(a)=0
ENDIF
ENDIF
NEXT a
ENDIF
IF tplayend>0 THEN
endcount=tplayend*tmbit
ELSE
endcount=0
FOR a=1 TO spurz    ! Endpositionen anpassen fÅr Play-Endposition
a2=trkplay(a)
IF a2<>0 THEN
REPEAT
a3=trktime(a2)+(trkend(a2)-trkstrt(a2))
IF a3>=endcount AND trkmute(a)=FALSE AND NOT (tdig24=FALSE AND trkbits(a2)=24) THEN
endcount=a3
ENDIF
a2=trknext(a2)
UNTIL a2=0
ENDIF
NEXT a
endcount=endcount*tmbit
ENDIF
IF tplaystart>0 THEN
strtcount=tplaystart*tmbit
ELSE
strtcount=0
ENDIF
'
z=0
adder=0
voldplay=oldplay
oldplay=FALSE
IF virtual=TRUE THEN
@alerts(7)
ENDIF
vad=ad
IF vad=0 THEN
@analog
ENDIF
@wait
over=0
@digout(TRUE)
g=8     ! blocks
ts=sector*g
mb=1024*1024  ! grîûe der blocks
@tplayinit
IF pmo8=TRUE THEN
IF pch16=FALSE THEN
tsea%=playfifolen/8/4-1
ELSE
tsea%=playfifolen/16/4-1
ENDIF
ENDIF
IF dspuse=TRUE THEN
IF spurz=4 THEN
tsea%=&H1000/4-1     ! WICHTIG !!! : muû umgestellt werden auf &H1000/2-1 = $7FF, sonst nicht kompatibel mit XBIOS !!!
ENDIF
IF spurz=8 THEN
tsea%=&H1000/2-1
ENDIF
ENDIF
'  LPOKE trecback+12,0   ! ???
'  LPOKE trecback+24,0          !36 Playbyte
'
IF dspuse=FALSE AND pmo8=FALSE THEN
ltrk=INT(meml2/(spuren+1))     ! lÑnge der einzelnen Channel-Memory-Blocks
ELSE
ltrk=INT(meml2/(spuren*2))     ! lÑnge der einzelnen Channel-Memory-Blocks
ENDIF
ltrk=INT(ltrk/ts)*ts
ltrk=INT(ltrk/tmbit)
'
tsaa%=tsaa%+(ltrk*spuren*tmbit)
tsaa2%=tsaa2%+(ltrk*spuren*tmbit)
FOR a=1 TO spurz
IF trkwahl(a)>0 THEN
tp=trkpnt(trkwahl(a))
tm=trkmute(trkwahl(a))
ELSE
tp=0
tm=TRUE
ENDIF
thandle(a)=0
IF tm=TRUE OR tp=0 OR (tp<>0 AND trkbits(tp)=24 AND tdig24=FALSE) THEN
trkclr(a)=2
trkclr2(a)=2
trkplay(a)=0
ENDIF
IF tm=FALSE THEN
IF trkwahl(a)>0 THEN
tl=trklev(trkwahl(a))
ELSE
tl=100
ENDIF
IF tdig24=TRUE THEN
tl=128*tl/100
ENDIF
DPOKE mdat%+(a*2)-2,tl
ELSE
DPOKE mdat%+(a*2)-2,0
ENDIF
NEXT a
FOR a=1 TO spuren
IF trkfull24(a)=TRUE AND matrix=FALSE AND tdig24=TRUE AND (trkmute(trkwahl(a))=TRUE OR trkwahl(a)=0) THEN
trkfull24(a)=FALSE
ENDIF
NEXT a
IF matrix=FALSE AND tdig24=TRUE THEN
trkall16=TRUE
FOR a=1 TO spuren
IF trkfull24(a)=TRUE THEN
trkall16=FALSE
ENDIF
EXIT IF trkall16=FALSE
NEXT a
ENDIF
FOR a=1 TO spuren
DPOKE mdat%+1000+(a*2)-2,trkfull24(a)
IF dspuse=FALSE AND pmo8=FALSE THEN
ltrk=INT(meml2/(spuren+1))     ! lÑnge der einzelnen Channel-Memory-Blocks
ELSE
ltrk=INT(meml2/(spuren*2))     ! lÑnge der einzelnen Channel-Memory-Blocks
ENDIF
ltrk=INT(ltrk/ts)*ts
ltrk=INT(ltrk/tmbit)
IF tplaystart<>-1 THEN
mempos=tplaystart      ! anfang aktueller blockbereich
aktpos(a)=tplaystart
ELSE
mempos=0
aktpos(a)=0
ENDIF
IF tdig24=TRUE THEN
ltrk(a)=6
ELSE
ltrk(a)=4
ENDIF
IF trkfull24(a)=FALSE AND matrix=FALSE AND tdig24=TRUE THEN
ltrk(a)=4
ENDIF
NEXT a
i=0
c=1
@maschruf9(mems1,mems1+(ltrk*tmbit*(spuren+1)))    ! bereich lîschen
@maschruf9(mems2,mems2+(ltrk*tmbit*(spuren+1)))    ! bereich lîschen
i=0
t=TIMER
tback%=0       ! aktuelle mem-playposition
tback3%=0      ! abbruch ?
t_start=FALSE ! erster sampleload ?
j=0
dpos=0
trkerr=0
mft=FALSE
tmemf=1
exfill=FALSE
IF sa<spurz THEN
@deltrktxt      ! lîscht aktives handle !!!
GRAPHMODE 1
REPEAT
FOR c=1 TO spuren
IF trkwahl(c)>0 THEN
tp=trkpnt(trkwahl(c))
tm=trkmute(trkwahl(c))
ts=trkstereo(trkwahl(c))
ELSE
tp=0
tm=TRUE
ts=TRUE
ENDIF
'      IF ts=TRUE THEN
'      IF c/2=INT(c/2) THEN
'      INC c
'    ENDIF
'    ENDIF
IF tm=FALSE THEN
REPEAT
IF t_start=TRUE THEN               ! nicht beim ersten aufruf...
IF tdown=FALSE THEN
tback%=LPEEK(trecback+24)          !36 Playbyte
@tcorr
tback3%=LPEEK(trecback+8)          ! Breakflag
ELSE
tback3%=0
ENDIF
IF mft=FALSE THEN
IF tdown=FALSE THEN
tmemf=LPEEK(trecback+4)           !12 Memflag
ENDIF
mft=TRUE
ENDIF
ENDIF
cnr=trkplay(c)        ! zeiger auf aktuelles Channel-File
IF tmemf=1 THEN
pm=mems1
ELSE
pm=mems2
ENDIF
IF cnr=0 THEN
IF trkclr2(c)<2 THEN
IF tprint=TRUE THEN
PRINT "ACLR(ch,strt,len):",c,(pm+(ltrk*tmbit*(c-1))),ltrk*ltrk(c)
ENDIF
@maschruf9(pm+(ltrk*tmbit*(c-1)),pm+(ltrk*tmbit*(c-1)+ltrk*ltrk(c)))    ! bereich lîschen
trkclr(c)=2
INC trkclr2(c)
ENDIF
aktpos(c)=aktpos(c)+ltrk            ! aktuelle position ist jetzt ende des blocks
ELSE
pat$=trkpath$(cnr)+CHR$(0)   ! Filepfad
st=trktime(cnr)                    ! smpte-startzeit holen
st3=trkend(cnr)-trkstrt(cnr)       ! lÑnge des samples
IF trknext(cnr)<>0 THEN
ns=trktime(trknext(cnr))
IF st3>ns-st THEN
st3=ns-st
ENDIF
ENDIF
IF st>=mempos AND st<=(mempos+ltrk) THEN       ! ist sample in der aufzubereitenden zeit ?
st2=st3
dpos=st-aktpos(c)                  ! relativ zu speicheranfang
IF dpos>0 AND aktpos(c)<st THEN
ms=pm+(ltrk*tmbit*(c-1))+((aktpos(c)-mempos)*ltrk(c))
me=ms+dpos*ltrk(c)
tlen=dpos
IF tprint=TRUE THEN
PRINT "CLR(a->|) (ch,strt,len,ms,me):",c,aktpos(c)*ltrk(c),tlen*ltrk(c),ms,me
ENDIF
aktpos(c)=aktpos(c)+tlen           ! aktuelle position ist jetzt ende des blocks
@maschruf9(ms,me)    ! bereich lîschen
trkclr(c)=0
trkclr2(c)=0
dpos=st-mempos                  ! relativ zu speicheranfang
ELSE
dpos=st-mempos                  ! relativ zu speicheranfang
ENDIF
tstrt=aktpos(c)                  ! aktuelle zeitposition
tend=aktpos(c)+st2               ! ende der aktuellen zeit+lÑnge
IF tend>mempos+ltrk THEN
tend=mempos+ltrk               ! ende geht Åber aufzubereitenden bereich hinaus ? -> kÅrzen
ENDIF
tlen=tend-tstrt                  ! lÑnge des grîûtmîglichen ladebereichs
IF thandle(c)=0 THEN
thandle(c)=GEMDOS(61,L:VARPTR(pat$),0)    ! open sample
ENDIF
head=trkhead(cnr)
v=GEMDOS(66,L:trkstrt(cnr)*ltrk(c)+head,thandle(c),0)     ! SEEK
IF tprint=TRUE THEN
PRINT "OPEN(ch,nr,handle,name,len):",c,cnr,thandle(c),pat$,(trkend(cnr)-trkstrt(cnr))*ltrk(c)
PRINT "LOAD(ch,nr,name,strt,end,len):",c,cnr,trkfn$(cnr),aktpos(c)*ltrk(c),(tend-strt)*ltrk(c),tlen*ltrk(c)
ENDIF
trkclr(c)=0
trkclr2(c)=0
@filltrkmem                              ! sample in aufzubereitenden speicher laden
aktpos(c)=aktpos(c)+tlen                 ! aktuelle position ist jetzt ende des samples
IF tlen=st2 THEN
cnr=trknext(cnr)                   ! zeiger auf nÑchstes sample im channel
trkplay(c)=cnr                     ! zeiger merken
cl=GEMDOS(62,thandle(c))           ! close sample
thandle(c)=0                       ! handle entfernen
IF tprint=TRUE THEN
PRINT "nCLOSE(ch,handle,closeok,name):",c,thandle(c),cl,trkfn$(cnr)
ENDIF
ENDIF
ELSE
IF thandle(c)<>0 AND st<mempos THEN     ! sample schon geîffnet und restsample existent ?
st2=st+st3-mempos                ! restlÑnge des samples
IF st2>0 THEN
dpos=0
tstrt=mempos                        ! aktuelle zeitposition
tend=mempos+st2                     ! ende der aktuellen zeit+lÑnge
IF tend>mempos+ltrk THEN
tend=mempos+ltrk                  ! ende geht Åber aufzubereitenden bereich hinaus ? -> kÅrzen
IF tprint=TRUE THEN
PRINT "NEXTLOAD(ch,nr,name,strt,end,len):",c,cnr,trkfn$(cnr),aktpos(c)*ltrk(c),(tend-strt)*ltrk(c),(tend-strt-aktpos(c))*ltrk(c)
ENDIF
tlen=tend-tstrt                     ! lÑnge des grîûtmîglichen ladebereichs
trkclr(c)=0
trkclr2(c)=0
@filltrkmem                         ! sample in aufzubereitenden speicher laden
aktpos(c)=aktpos(c)+tlen            ! aktuelle position ist jetzt ende des samples
ELSE
IF tprint=TRUE THEN
PRINT "CLOSE(ch,h,nam,st,e,ln):",c,thandle(c),trkfn$(cnr),aktpos(c)*ltrk(c),(tend-strt)*ltrk(c),(tend-strt-aktpos(c))*ltrk(c)
ENDIF
cnr=trknext(cnr)                    ! zeiger auf nÑchstes sample im channel
trkplay(c)=cnr                      ! zeiger merken
tlen=tend-tstrt                     ! lÑnge des grîûtmîglichen ladebereichs
trkclr(c)=0
trkclr2(c)=0
@filltrkmem                         ! sample in aufzubereitenden speicher laden
aktpos(c)=aktpos(c)+tlen            ! aktuelle position ist jetzt ende des samples
cl=GEMDOS(62,thandle(c))            ! close sample
thandle(c)=0                        ! handle entfernen
IF tprint=TRUE THEN
PRINT cl
ENDIF
IF cnr=0 THEN
ms=pm+(ltrk*tmbit*(c-1))+((aktpos(c)-mempos)*ltrk(c))
me=pm+(ltrk*tmbit*(c-1))+ltrk*ltrk(c)
tlen=ltrk-(aktpos(c)-mempos)
IF tprint=TRUE THEN
PRINT "CLR(|e) (ch,strt,len,ms,me):",c,aktpos(c)*ltrk(c),tlen*ltrk(c),ms,me
ENDIF
aktpos(c)=aktpos(c)+tlen           ! aktuelle position ist jetzt ende des blocks
@maschruf9(ms,me)    ! bereich lîschen
trkclr(c)=0
trkclr2(c)=0
ENDIF
ENDIF
ENDIF
ELSE
IF st>mempos THEN     ! leerlauf ?
tstrt=aktpos(c)
tend=trktime(cnr)
IF tend>mempos+ltrk THEN
tend=mempos+ltrk               ! ende geht Åber aufzubereitenden bereich hinaus ? -> kÅrzen
ENDIF
tlen=tend-tstrt
a2=pm+(aktpos(c)-mempos)*ltrk(c)
ms=a2+(ltrk*(c-1)*tmbit)
me=pm+(ltrk*(c-1)*tmbit)+ltrk*ltrk(c)
IF (tlen=ltrk AND trkclr(c)<2) OR tlen<>ltrk THEN
IF tprint=TRUE THEN
PRINT "CLR(|->e) (ch,strt,len,ms,me):",c,aktpos(c)*ltrk(c),tlen*ltrk(c),ms,me
ENDIF
@maschruf9(ms,me)    ! bereich lîschen
IF tlen=ltrk THEN
INC trkclr(c)
ELSE
trkclr(c)=0
trkclr2(c)=0
ENDIF
ENDIF
aktpos(c)=aktpos(c)+tlen           ! aktuelle position ist jetzt ende des blocks
ENDIF
ENDIF
ENDIF
ENDIF
@time8
UNTIL exfill=TRUE OR aktpos(c)=mempos+ltrk OR cnr=0 OR tback3%=1       ! solange weitere samples laden bis memblock voll ist
IF cnr=0 THEN
a2=pm+(aktpos(c)-mempos)*ltrk(c)
ms=a2+(ltrk*(c-1)*tmbit)
me=pm+(ltrk*(c-1)*tmbit)+ltrk*ltrk(c)
tlen=ltrk-(aktpos(c)-mempos)
IF tlen>0 THEN
IF tprint=TRUE THEN
PRINT "CLR(|->exit) (ch,strt,len,ms,me):",c,aktpos(c)*ltrk(c),tlen*ltrk(c),ms,me
ENDIF
@maschruf9(ms,me)    ! bereich lîschen
aktpos(c)=aktpos(c)+tlen           ! aktuelle position ist jetzt ende des blocks
ENDIF
ENDIF
EXIT IF tback3%=1 OR exfill=TRUE
ENDIF
NEXT c                                       ! nÑchster channel
blen%=ltrk*tmbit
IF tmemf=1 THEN
src%=mems1
dst%=mems1+(ltrk*tmbit*spuren)
IF tprint=TRUE THEN
PRINT "MIX0"
ENDIF
ELSE
src%=mems2
dst%=mems2+(ltrk*tmbit*spuren)
IF tprint=TRUE THEN
PRINT "MIX1"
ENDIF
ENDIF
SELECT spurz
CASE 1 TO 4
IF pch4=FALSE THEN
IF dspuse=FALSE THEN
mix4=XBIOS(xbs,100,4,trkall16,L:src%,L:blen%,L:dst%,L:mdat%,L:mdat%+1000)
ELSE
mix4=XBIOS(xbs,101,4,L:src%,L:blen%,L:dst%)
ENDIF
ENDIF
CASE 5 TO 8
IF dspuse=FALSE THEN
IF pmo8=FALSE THEN
mix8=XBIOS(xbs,100,8,trkall16,L:src%,L:blen%,L:dst%,L:mdat%,L:mdat%+1000)
ELSE
IF pch16=FALSE THEN
mix8=XBIOS(xbs,101,8,L:src%,L:blen%,L:dst%)
ELSE
mix8=XBIOS(xbs,101,16,L:src%,L:blen%,L:dst%)
ENDIF
ENDIF
ELSE
mix8=XBIOS(xbs,101,8,L:src%,L:blen%,L:dst%)
ENDIF
CASE 9 TO 12
mix12=XBIOS(xbs,100,12,trkall16,L:src%,L:blen%,L:dst%,L:mdat%,L:mdat%+1000)
CASE 13 TO 16
IF pmo8=FALSE THEN
mix16=XBIOS(xbs,100,16,trkall16,L:src%,L:blen%,L:dst%,L:mdat%,L:mdat%+1000)
ELSE
IF pch16=TRUE THEN
mix16=XBIOS(xbs,101,16,L:src%,L:blen%,L:dst%)
ENDIF
ENDIF
ENDSELECT
IF tprint=TRUE THEN
'    PRINT "MIX:",dst%,mix4,mix4-dst%
ENDIF
IF z>0 AND j<spuren AND exfill=FALSE THEN
REPEAT
@time8
IF tdown=FALSE THEN
tmemf=LPEEK(trecback+4)           !12 Memflag
tback3%=LPEEK(trecback+8)           ! Breakflag
ELSE
@downmix2
ENDIF
UNTIL tvmemf<>tmemf OR tback3%=1 OR exfill=TRUE OR tdown=TRUE
tvmemf=tmemf
ENDIF
IF z=0 THEN
INC z
'
@trakplay8                                   ! abspielen starten
'
IF pmo8=TRUE THEN
'
IF mixdsp=TRUE THEN
pt=3
ELSE
'              pt=0
ENDIF
@channel
'
ENDIF
'
mft=FALSE
t_start=TRUE
tvmemf=0
IF tdown=FALSE THEN
tmemf=0
ELSE
@downmix2
ENDIF
ENDIF
'
mempos=mempos+ltrk                          ! zum nÑchsten block
tbtest=INT(tback%/tmbit)
IF tbtest>mempos THEN
INC trkerr
@textfeld(trkerr&,"ERR:"+STR$(trkerr)+CHR$(0),1)
ENDIF
'
j=0
FOR a=1 TO spuren
IF trkplay(a)=0 THEN
INC j                       ! alle samples geladen...
'        IF trkwahl(a)>0 THEN
'          ts=trkstereo(trkwahl(a))
'        ELSE
'          ts=TRUE
'        ENDIF
'        IF ts=TRUE AND a/2=INT(a/2) THEN
'         INC j
'         INC a
'        ENDIF
ENDIF
NEXT a
@time8
UNTIL (j=spuren AND tback%>=endcount) OR tback3%=1 OR exfill=TRUE OR (tdown=TRUE AND tlen=0 AND j=spuren)                        ! ...dann ende
'      STOP
FOR i=1 TO spuren
IF thandle(i)>0 THEN
cl=GEMDOS(62,thandle(i))                           ! close sample
IF tprint=TRUE THEN
PRINT ".CLOSE(handle,close):",thandle(i),cl
ENDIF
ENDIF
NEXT i
IF hardopen=FALSE THEN
@opentrk2
ENDIF
ENDIF
IF tprint=TRUE THEN
PRINT "ENDE"
ENDIF
intplay=FALSE
@write_int(0)
IF dspuse=TRUE OR pch4=TRUE THEN
~XBIOS(xbs,55,0)
~XBIOS(xbs,73,0)
ENDIF
IF nr=smpedit& THEN
@intzeiger3
@textfeld(smpsec&,sec$,1)
ENDIF
IF tdown=FALSE THEN
tback%=LPEEK(trecback+24)           !36 letztes playbyte
@tcorr
ENDIF
@digout(FALSE)
'
IF tplaystart>0 THEN
FOR a=1 TO spurz   ! gerettete Startpositionen zurÅckschreiben (fÅr Startplay-Position>0)
a2=trkmplay(a)
IF a2<>0 THEN
IF trkseek(a)<>0 THEN
trkstrt(a2)=trkstrt(a2)-trkseek(a)
trktime(a2)=trktime(a2)-trkseek(a)
ENDIF
ENDIF
NEXT a
ENDIF
'
IF tplayend>0 THEN
FOR a=1 TO spurz   ! gerettete Endpositionen zurÅckschreiben (fÅr Endplay-Position<>0)
a2=trkmplay2(a)
IF a2<>0 THEN
IF trkseek2(a)<>0 THEN
trkend(a2)=trkend(a2)+trkseek2(a)
ENDIF
trknext(a2)=trkmplay3(a)
ENDIF
NEXT a
ENDIF
'
IF trkerr>0 THEN
@textfeld(trkerr&,"        "+CHR$(0),1)
ENDIF
IF vad=0 THEN
@digital
ELSE
@analog
ENDIF
ENDIF
DEFMOUSE 0
@setbutton(trakplay&,0)
IF demo=FALSE THEN
oldplay=voldplay
cached=tcach(0)
@soloplay2
~XBIOS(xbs,27,0)
IF pch4=TRUE OR pmo8=TRUE THEN
IF digana=TRUE AND ad=1 THEN
~XBIOS(&H8B,0,2,0,clk,1)
~XBIOS(&H8B,3,11,0,clk,1)
ELSE
~XBIOS(&H8B,0,2,0,0,1)
~XBIOS(&H8B,3,11,0,0,1)
ENDIF
ENDIF
~@xrsrc_gaddr(0,info&,dzu%)
nkind2=(DPEEK(dzu%+24*inforeg5&+2))
nkind3=(DPEEK(dzu%+24*inforeg5&+4))
IF nkind2<>1 OR nkind3<>23 THEN
tstcpr=23
ENDIF
IF pmo8=TRUE THEN
~XBIOS(xbs,72,14)
ENDIF
matrixplay=FALSE
pch4=FALSE
pmo8=FALSE
pch16=FALSE
~XBIOS(xbs,27,0)
~XBIOS(xbs,28,0)
ENDIF
~@xrsrc_gaddr(0,trakker&,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,trklvol&,1,0,0,xwidth,ywidth)
~OBJC_DRAW(zu%,trkrvol&,1,0,0,xwidth,ywidth)
~OBJC_DRAW(zu%,trklmax&,1,0,0,xwidth,ywidth)
~OBJC_DRAW(zu%,trkrmax&,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE soloplay1
LOCAL i
IF tsolo=TRUE THEN
FOR i=1 TO trkvmax
trksmute(i)=trkmute(i)
trkmute(i)=TRUE
NEXT i
FOR i=1 TO spurz
trkswahl(i)=trkwahl(i)
trkwahl(i)=FALSE
NEXT i
trkmute(trakact)=FALSE
trkwahl(1)=trakact
ENDIF
RETURN
'
> PROCEDURE soloplay2
LOCAL i
IF tsolo=TRUE THEN
FOR i=1 TO trkvmax
trkmute(i)=trksmute(i)
NEXT i
FOR i=1 TO spurz
trkwahl(i)=trkswahl(i)
NEXT i
ENDIF
RETURN
'
> PROCEDURE channel
IF demo=FALSE OR falcon=TRUE THEN
a=XBIOS(&H86,pt)
ENDIF
IF pt=0 THEN
IF bigfoot=FALSE THEN
a$="1+2"
ELSE
a$="M 1+2"
ENDIF
ENDIF
IF pt=1 THEN
IF bigfoot=FALSE THEN
a$="3+4"
ELSE
a$="M 3+4"
ENDIF
ENDIF
IF pt=2 THEN
IF bigfoot=FALSE THEN
a$="5+6"
ELSE
a$="M 5+6"
ENDIF
ENDIF
IF pt=3 THEN
IF bigfoot=FALSE THEN
a$="7+8"
ELSE
a$="M 7+8"
ENDIF
ENDIF
IF nr=trakker& THEN
a$=a$+CHR$(0)
@textfeld(trkmon&,a$,1)
ENDIF
RETURN
'
> PROCEDURE trakplay8
LOCAL p,b$,g,tclk
' HARDDISK-PLAY second generation (ersetzt wie maschruf5c)
'
IF digana=TRUE THEN
tclk=clk
ELSE
tclk=0
ENDIF
'
DEFMOUSE 0
exfill=FALSE
firstp=FALSE
IF dspuse=FALSE AND pmo8=FALSE THEN
tsba%=tsaa%+ltrk*tmbit
tsba2%=tsaa2%+ltrk*tmbit
ELSE
tsba%=tsaa%+ltrk*spuren*tmbit
tsba2%=tsaa2%+ltrk*spuren*tmbit
ENDIF
'
endcount2=endcount+ltrk*2
'
IF XBIOS(xbs,1)=&H71273800 THEN
IF tdown=FALSE THEN
IF dspuse=FALSE THEN
IF pmo8=FALSE THEN
IF pch4=FALSE THEN
trecback=XBIOS(xbs,141,0,L:tsaa%,L:tsaa2%,L:tsba%-tsaa%,L:strtcount,L:endcount2,tsfila%,tsca%,tsda%)
ELSE
nsaa%=mems1
nsba%=mems1+ltrk*tmbit
nsaa2%=mems2
nsba2%=mems2+ltrk*tmbit
dsaa%=mems1+ltrk*tmbit
dsba%=mems1+ltrk*2*tmbit
dsaa2%=mems2+ltrk*tmbit
dsba2%=mems2+ltrk*2*tmbit
sea2%=&H1000/2-1
trecback=XBIOS(xbs,144,L:nsaa%,L:nsaa2%,L:dsaa%,L:dsaa2%,L:ltrk*tmbit,L:strtcount,L:endcount2,tsfila%,tsca%,tsda%)
'
~XBIOS(xbs,27,1)
~XBIOS(&H8B,0,10,0,tclk,1)
'
ENDIF
ELSE
IF pch16=FALSE THEN
trecback=XBIOS(xbs,141,2,L:tsaa%,L:tsaa2%,L:tsba%-tsaa%,L:strtcount,L:endcount2,tsfila%,tsca%,tsda%)
ELSE
trecback=XBIOS(xbs,141,3,L:tsaa%,L:tsaa2%,L:tsba%-tsaa%,L:strtcount,L:endcount2,tsfila%,tsca%,tsda%)
ENDIF
IF pmo8=TRUE THEN
IF dspmodemix=FALSE THEN
@dspmix8
ELSE
@dspeffmix8
ENDIF
IF mixdsp=TRUE THEN
pt=3
ELSE
'              pt=0
ENDIF
IF pch16=FALSE THEN
~XBIOS(xbs,27,2)
ELSE
~XBIOS(xbs,27,3)
ENDIF
@channel
IF matrixplay=TRUE THEN
~XBIOS(xbs,72,14)
~XBIOS(&H8B,0,8+4,0,tclk,1)
ELSE
~XBIOS(xbs,72,15)
~XBIOS(&H8B,0,2,0,tclk,1)
~XBIOS(&H8B,1,8+4,0,tclk,1)
ENDIF
ENDIF
ENDIF
IF pch4=FALSE AND dspuse=FALSE THEN
IF pwait=FALSE THEN
@wait_mtc
@write_int(1)
ELSE
IF recp=FALSE THEN
intnr=1
ELSE
intnr=3
ENDIF
IF recpaus=FALSE THEN
@pausewait
ELSE
@write_int(intnr)
recpaus=FALSE
ENDIF
ENDIF
ELSE
IF pch4=TRUE THEN
~XBIOS(xbs,74)            ! DSP-Clear, muû wieder raus
~XBIOS(xbs,55,0)
~XBIOS(xbs,55,1)      ! Probeweise entfernt, muû wieder rein
~XBIOS(xbs,73,0)
IF pwait=FALSE THEN
@wait_mtc
@write_int(1)
ELSE
IF recp=FALSE THEN
intnr=1
ELSE
intnr=3
ENDIF
IF recpaus=FALSE THEN
@pausewait
ELSE
@write_int(intnr)
recpaus=FALSE
ENDIF
ENDIF
ELSE
IF dspuse=TRUE THEN
~XBIOS(xbs,73,0)
~XBIOS(xbs,55,1)
ENDIF
ENDIF
ENDIF
ELSE
@write_int(0)
~XBIOS(&H8B,0,2,0,tclk,1)
~XBIOS(&H8B,1,8,0,tclk,1)
trecback=XBIOS(xbs,141,1,L:tsaa%,L:tsaa2%,L:tsba%-tsaa%,L:strtcount,L:endcount2,tsfila%,tsca%,tsda%)
'        ~XBIOS(xbs,73,0)
'       ~XBIOS(xbs,55,1)
'
~XBIOS(xbs,74)
~XBIOS(xbs,73,0)
~XBIOS(xbs,55,1)
'
ENDIF
ENDIF
t=TIMER
intplay=TRUE
@maus_player
ENDIF
RETURN
'
> PROCEDURE wait_mtc
LOCAL fz
IF mtc=TRUE THEN
fz=framez
'
'    h=0
'    m=0
'    s=0
'    ms=0
'
'    frames=h*fz*60*60+m*fz*60+s*fz+ms
frames=smptestrt
'
@write_int(0)
~XBIOS(xbs,162,1)           ! framecounter starten
REPEAT
IF INP?(2)=TRUE THEN
~INP(2)
ENDIF
UNTIL INP?(2)=FALSE
'
~XBIOS(xbs,164,L:frames,fz)      ! wait auf mtc oder space-taste
'
REPEAT
IF INP?(2)=TRUE THEN
~INP(2)
ENDIF
UNTIL INP?(2)=FALSE
ENDIF
RETURN
'
> PROCEDURE downmix
LOCAL cl
zdig24=dig24
zmbit=mbit
dig24=tdig24
mbit=tmbit
tdown=TRUE
dpz=0
@fileselect(op$+"*."+ext$,"","FILENAME FOR TRACKBOUNCING:")
IF LEN(fil$)>0 THEN
IF RINSTR(fil$,".")=0 THEN
fil$=fil$+"."+ext$
ENDIF
@headart2(fil$)
IF sfileart<>0 THEN
IF pret<>0 AND pbutt=1 THEN
dm$=fil$+CHR$(0)
@killpbfinf(fil$)
dpch4=pch4
dpmo8=pmo8
dpch16=pch16
dmatrixplay=matrixplay
dmatrix=matrix
pch4=FALSE
pmo8=FALSE
pch16=FALSE
matrixplay=FALSE
matrix=FALSE
@trkplay
IF compile=TRUE AND (VAL(MID$(reg4$,8,4))<2000 OR VAL(MID$(reg4$,8,4))>9999) THEN
BMOVE BASEPAGE+2000,BASEPAGE+9999,100000
CLS
i=0
REPEAT
INC i
PRINT reg5$
UNTIL i=100
ENDIF
pch4=dpch4
pmo8=dpmo8
pch16=dpch16
matrixplay=dmatrixplay
matrix=dmatrix
IF dpz>0 THEN
danf=mdat%+3000
@headart2(fil$)
@headmake
@headmake2
a=GEMDOS(66,L:0,dmh,0)             ! seek to zero
a=GEMDOS(64,dmh,L:head,L:danf)
cl=GEMDOS(62,dmh)                 ! close sample
IF trakact<>0 THEN
@trakloading(fil$)
sectpos=sectall
@trkend
@trkanf
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
tdown=FALSE
dig24=zdig24
mbit=zmbit
@setbutton(hrdmerg2&,0)
RETURN
'
> PROCEDURE downmix2
tback%=tback%+ltrk*tmbit
tback3%=0
dsrc%=dst%    ! bufferadresse
IF dpz=0 THEN
dmh=GEMDOS(60,L:VARPTR(dm$),0)    ! open sample
danf=mdat%+3000
vln=0
fil$=LEFT$(dm$,LEN(dm$)-1)
@headart
fileart=sfileart
IF head>0 THEN
~GEMDOS(64,dmh,L:head,L:danf)
ENDIF
ENDIF
INC dpz
IF fileart=3 THEN
@maschruf28(dsrc%,ltrk*tmbit)   ! swap to wave
ENDIF
dbw=GEMDOS(64,dmh,L:ltrk*tmbit,L:dsrc%)
vln=vln+ltrk*tmbit
IF tmemf=1 THEN
tmemf=0
ELSE
tmemf=1
ENDIF
@busy_mouse
RETURN
'
> PROCEDURE treiberload
IF EXIST(s$+"SOUND.PRG"+CHR$(0))=TRUE THEN
a=EXEC(0,s$+"SOUND.PRG"+CHR$(0),CHR$(0),CHR$(0))
z=0
REPEAT
PAUSE 1
INC z
UNTIL XBIOS(xbs,1)=&H71273800 OR z=50
IF a<>0 OR XBIOS(xbs,1)<>&H71273800 THEN
@alerts(8)
END
ENDIF
ELSE
@alerts(9)
END
ENDIF
RETURN
'
> PROCEDURE rec_headinit(r$)
fil$=LEFT$(r$,INSTR(r$,CHR$(0))-1)
danf=mdat%
@headart
IF sfileart=0 THEN
inf=FALSE
@alerts(10)
ENDIF
RETURN
'
> PROCEDURE rec_header
IF sfileart<>0 THEN
fileart=sfileart
OPEN "I",#1,fil$+CHR$(0)
vmlen=mlen
mlen=LOF(#1)-head
CLOSE #1
vblks=blks
vsret=sret
vsblock=sblock
blks=0
sret=0
sblock=0
vfileart=fileart
fileart=sfileart
@headmake
fileart=vfileart
mlen=vmlen
blks=vblks
sret=vsret
sblock=vsblock
a$=fil$+CHR$(0)
a=VARPTR(a$)        !Pfad
filadr=a
h%=GEMDOS(61,L:filadr,2)
IF h%>0 THEN
ok%=GEMDOS(66,L:0,h%,0)
ok%=GEMDOS(64,h%,L:head,L:danf)
ok%=GEMDOS(62,h%)
ENDIF
ENDIF
RETURN
'
> FUNCTION mxalloc(giveme,art)
a=GEMDOS(68,L:giveme,art)
RETURN a
ENDFUNC
'
> PROCEDURE intzeiger1(bx)
.| Glob. Var.: cs#,ce#,cx#,xm#,c1#,sret#,c2#,sblock#,xd#,stay1#,stay2#,cx2#
.| Ruft auf  : blocklook
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf5-1,maschruf5c-1,
LOCAL j
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
@blocklook
'  IF ((bx=c1 AND (sret=0 OR sret=2)) OR (bx=c2-8 AND sret=1)) AND sblock=1 THEN
GRAPHMODE 3
'    ELSE
'     GRAPHMODE 1
' ENDIF
LINE cx+xd,stay1,cx+xd,stay2
cx2=cx
COLOR 0
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ELSE
cx2=-1
ENDIF
RETURN
'
> PROCEDURE intzeiger2(bx)
.| Glob. Var.: cs#,ce#,cx#,xm#,cx2#,xd#,stay1#,stay2#
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf5-1,maschruf5c-1,
LOCAL j
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
cx=bx-cs
cx=cx/(ce-cs)*xm
'
IF hardcursor=FALSE THEN
~GRAF_MKSTATE(x,y,k,v4)
IF x>=cxd-16 AND x<=cxd+xmc+16 AND y>=ym1-16 AND y<=ym2+ymc+16 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
ENDIF
ENDIF
COLOR 1
GRAPHMODE 3
IF cx2<>-1 THEN
LINE cx2+xd,stay1,cx2+xd,stay2
drawnew=TRUE
ENDIF
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
LINE cx+xd,stay1,cx+xd,stay2
drawnew=TRUE
ENDIF
cx2=cx
COLOR 0
GRAPHMODE 1
IF hardcursor=FALSE THEN
~GRAF_MKSTATE(x,y,k,v4)
IF x>=cxd-16 AND x<=cxd+xmc+16 AND y>=ym1-16 AND y<=ym2+ymc+16 THEN
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ELSE
IF cx2<>-1 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
IF hardcursor=FALSE THEN
~GRAF_MKSTATE(x,y,k,v4)
IF x>=cxd-16 AND x<=cxd+xmc+16 AND y>=ym1-16 AND y<=ym2+ymc+16 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
ENDIF
ENDIF
COLOR 1
GRAPHMODE 3
LINE cx2+xd,stay1,cx2+xd,stay2
drawnew=TRUE
COLOR 0
GRAPHMODE 1
IF hardcursor=FALSE THEN
~GRAF_MKSTATE(x,y,k,v4)
IF x>=cxd-16 AND x<=cxd+xmc+16 AND y>=ym1-16 AND y<=ym2+ymc+16 THEN
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
cx2=-1
ENDIF
RETURN
'
> PROCEDURE intzeiger3
.| Glob. Var.: bx#,cs#,ce#,cx2#,xd#,stay1#,stay2#
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf5-1,maschruf5c-1,
LOCAL j
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF cx2<>-1 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE cx2+xd,stay1,cx2+xd,stay2
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
ENDIF
COLOR 0
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
IF cx2<>-1 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE cx2+xd,stay1,cx2+xd,stay2
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
COLOR 0
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
RETURN
'
> PROCEDURE drop
.| Glob. Var.: nob#
.| Ruft auf  : drop2
.| Aufruf in : rsc_do-1,
IF MENU(1)=10 THEN
nob=MENU(5)
@drop2
ENDIF
RETURN
'
> PROCEDURE editselect
~@xrsrc_gaddr(0,nr,zu%)
@wischwasch
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
@wischwasch
IF nr=smpedit& THEN
IF hrd=1 THEN
@setbutton(hard&,1)
ELSE
@setbutton(hard&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE editredraw
@wischwasch
@rsc_redraw_obj(nr,0)
@wischwasch
@curve(cs,ce)
@markprod3
@getcurve
RETURN
'
> PROCEDURE winbuttset
IF BTST(winh,info&)=TRUE THEN
@setbutton3(infoicon&,1,nr)
ENDIF
IF BTST(winh,peak&)=TRUE THEN
@setbutton3(peaksw2&,1,nr)
ENDIF
IF BTST(winh,blkfunc&)=TRUE THEN
@setbutton3(blocfunc&,1,nr)
ENDIF
IF BTST(winh,loop&)=TRUE THEN
@setbutton3(loopart&,1,nr)
ENDIF
IF BTST(winh,smp16&)=TRUE THEN
@setbutton3(edsmp16&,1,nr)
ENDIF
IF BTST(winh,editfade&)=TRUE THEN
@setbutton3(edfade&,1,nr)
ENDIF
IF BTST(winh,arranger&)=TRUE THEN
@setbutton3(arrange&,1,nr)
ENDIF
IF BTST(winh,trakker&)=TRUE THEN
@setbutton3(trak&,1,nr)
ENDIF
IF BTST(winh,dspedit&)=TRUE THEN
@setbutton3(swdsp&,1,nr)
ENDIF
RETURN
'
> PROCEDURE main
.| Glob. Var.: winh#,smp16&,rsc_window&,vornr#,nr#,menuda#,edsmp16&,g#
.|     smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,setbutton,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
@testcopyright
IF BTST(winh,smp16&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=smp16&
'
vshading=shading
shading=TRUE
dopix=TRUE
@makehz
@sethertz
@fliphz2
@sourcein
dopix=FALSE
shading=vshading
'
@rsc_draw(nr,7)
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@setbutton(edsmp16&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=smp16&
IF vornr=smpedit& THEN
@setbutton2(edsmp16&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_main
.| Glob. Var.: smp16&,zu%,zuadr#,buttadr#,obj#,but#,dsp&,a$,popups&
.|     dsppopup&,popup&,rate2&,digana#,smppop2&,input&,inpop&,source&
.|     srcpop&,protect&,swdsp&,helporig&,exit&,winh#,nr#,smpedit&,edsmp16&
.|     nob#
.| Ruft auf  : xrsrc_gaddr,textfeld,dspoff,dspin,dspout,adlow,admid,adhigh
.|     ext32l,ext44l,ext48l,ext32h,ext44h,ext48h,ext256,ext384,analog
.|     digital,opto,coax,prot,setbutton,dspwahl,helptxt,restaura2b
.| Aufruf in : windows-1,
~@xrsrc_gaddr(0,smp16&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
IF but=22 THEN
IF obj=dsp& THEN
a$=@rsc_text$(popups&,dsppopup&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@dspoff
ENDIF
IF popup&=2 THEN
@dspin
ENDIF
IF popup&=3 THEN
@dspout
ENDIF
ENDIF
IF obj=rate2& AND digana=TRUE THEN
@testsrate
IF (retime=0 OR (retime=1 AND tstsr=FALSE)) THEN
a$=@rsc_text$(popups&,smppop2&+popup&)
@textfeld(obj,a$,1)
IF popup&<>0 THEN
IF popup&=1 THEN
@adlow
ENDIF
IF popup&=2 THEN
@admid
ENDIF
IF popup&=3 THEN
@adhigh
ENDIF
IF popup&=4 THEN
@admid96
ENDIF
IF popup&=5 THEN
@adhigh96
ENDIF
IF popup&=6 THEN
@ad8
ENDIF
IF popup&=7 THEN
@ad11
ENDIF
IF popup&=8 THEN
@ad12
ENDIF
IF popup&=9 THEN
@ad16
ENDIF
IF popup&=10 THEN
@ad17
ENDIF
IF popup&=11 THEN
@ad22
ENDIF
IF popup&=12 THEN
@ad24
ENDIF
IF popup&=13 THEN
@ad33
ENDIF
IF popup&=14 THEN
@adexth2
ENDIF
IF popup&=15 THEN
@adextl2
ENDIF
IF popup&=16 THEN
@adexth1
ENDIF
IF popup&=17 THEN
@adextl1
ENDIF
@kickstart
ENDIF
ENDIF
ENDIF
IF obj=input& THEN
a$=@rsc_text$(popups&,inpop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@analog
ENDIF
IF popup&=2 THEN
@digital
ENDIF
ENDIF
IF obj=source& THEN
a$=@rsc_text$(popups&,srcpop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@opto
ENDIF
IF popup&=2 THEN
@coax
ENDIF
IF popup&=3 THEN
@aesebu
ENDIF
ENDIF
IF obj=emphasis& THEN
a$=@rsc_text$(popups&,emphpop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@emphoff
ENDIF
IF popup&=2 THEN
@emphon
ENDIF
ENDIF
IF obj=mode& THEN
a$=@rsc_text$(popups&,modepop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@consumer
ENDIF
IF popup&=2 THEN
@profess
ENDIF
ENDIF
IF obj=protect& THEN
a$=@rsc_text$(popups&,popscms&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@scmsno
ENDIF
IF popup&=2 THEN
@scmsone
ENDIF
IF popup&=3 THEN
@scmsfree
ENDIF
ENDIF
ENDIF
IF obj=bridge& THEN
@digibridge
ENDIF
IF obj=digmark& THEN
IF dighead=FALSE THEN
dighead=TRUE
ELSE
dighead=FALSE
ENDIF
ENDIF
IF obj=helporig& THEN
@helptxt("EINSTELLUNGEN")
ENDIF
IF obj=exit& OR obj=9999 THEN
winh=BCLR(winh,smp16&)
@setbutton(exit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(edsmp16&,0)
ENDIF
@sethertz
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
nob=0
RETURN
'
> PROCEDURE windows
.| Glob. Var.: menuda#,obj#,nr#,popup&,info&,dspedit&,arranger&,trakker&
.|     loop&,peak&,blkfunc&,smp16&,smpedit&,smpexit&,g#
.| Ruft auf  : rsc_menu_ienable,rsc_do,do_info,do_dsp,do_arrange,do_trakker
.|     do_loop,do_peak,do_blkf,do_main,maketime,do_smpedit,goodbye
.| Aufruf in : smpedit-1,
REPEAT
REPEAT
obj=@rsc_do(nr,obj,popup&)
IF obj<>0 AND nr=peak& THEN
@do_peak
obj=0
ENDIF
IF peakmrk=peak& AND nr<>peak& THEN
@write_int(0)
ENDIF
IF obj<>0 AND nr=info& THEN
@do_info
obj=0
ENDIF
IF obj<>0 AND nr=wmode& THEN
IF obj=-1 OR obj=synchz& OR obj=smpteset& OR obj=syncsrte& THEN
'          edit_obj&=0
'          obj=0
ELSE
@do_workmode
obj=0
ENDIF
ENDIF
IF obj<>0 AND nr=dspedit& THEN
@do_dsp
obj=0
ENDIF
IF obj<>0 AND nr=editfade& THEN
@do_fade
obj=0
ENDIF
IF obj<>0 AND nr=cuelist& THEN
@do_cuelist
obj=0
ENDIF
IF obj<>0 AND nr=arranger& THEN
@do_arrange
obj=0
ENDIF
IF obj<>0 AND nr=trakker& THEN
@do_trakker
obj=0
ENDIF
IF obj<>0 AND nr=mixer& THEN
@do_mixer
obj=0
ENDIF
IF obj<>0 AND nr=loop& THEN
@do_loop
obj=0
ENDIF
IF obj<>0 AND nr=blkfunc& THEN
@do_blkf
obj=0
ENDIF
IF obj<>0 AND nr=smp16& THEN
@do_main
obj=0
ENDIF
IF obj<>0 AND nr=plugin& THEN
@do_plugin
obj=0
ENDIF
IF obj<>0 AND nr=smpedit& THEN
@maketime
@do_smpedit
IF obj<>9999 AND obj<>smpexit& THEN
obj=0
ENDIF
ENDIF
~FRE(0)
IF nr=smpedit& AND ldtrk=TRUE AND (obj=smpexit& OR obj=9999) THEN
IF startup=TRUE THEN
trkstrt(trkp)=INT(loops%(sms,1)/mbit)
trkend(trkp)=INT(loops%(sms,2)/mbit)
@infmemkill
IF virtual=TRUE THEN
@trashvirt
ENDIF
@killedit
nr=trakker&
@editselect
tmbit=vtmbit
IF trkbits(trkp)=24 THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
~XBIOS(xbs,27,0)
IF (pch4=TRUE OR pmo8=TRUE) AND (demo=FALSE OR falcon=TRUE) THEN
~XBIOS(&H8B,0,2,0,clk,1)
~XBIOS(&H8B,3,11,0,clk,1)
ENDIF
IF pmo8=TRUE AND demo=FALSE THEN
~XBIOS(xbs,72,14)
ENDIF
'
obj=0
ldtrk=FALSE
ldtrk3=FALSE
hsec=INT(trkstrt(trkp)/thz*100)
@htimeset
@textfeld(trakstrt&,a$,1)
hsec=INT(trkend(trkp)/thz*100)
@htimeset
@textfeld(trakend&,a$,1)
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz*100)
@htimeset
@textfeld(trakdur&,a$,1)
@setbutton(trakend&,0)
GRAPHMODE 1
@timeline
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
IF obj=9999 AND nr=smpedit& AND ldtrk=FALSE THEN
leaveprog=TRUE
ENDIF
UNTIL leaveprog=TRUE AND (nr=smpedit& AND ldtrk=FALSE AND (obj=smpexit& OR obj=9999))
@alerts(99)
IF g=1 THEN
@write_int(0)
@goodbye
ELSE
leaveprog=FALSE
ENDIF
obj=0
UNTIL g=1
RETURN
'
> PROCEDURE winhandler
LOCAL flags&,evnt&,key&,tim&,flags&,mx,my,mb
tim&=1   ! EVENT-TIMER in msec
flags&=&X110011                                      ! ...zus. MESSAGE-Events
evnt&=EVNT_MULTI(&X110011,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,mx,my,mb,shift&,key&,c)
IF BTST(evnt&,4) THEN
@message
@drop
@markhlp
ENDIF
IF BTST(evnt&,1) THEN
@button
'    @windows
ENDIF
RETURN
'
> PROCEDURE goodbye
.| Glob. Var.: demo#,peakint#,i#,winh#
.| Ruft auf  : rsc_back,rsc_exit,xrsrc_exit,exit
.| Aufruf in : drop2-1,windows-1,fehler-1,
CLOSE
IF demo=FALSE THEN
IF XBIOS(xbs,1)=&H71273800 THEN
peakint=FALSE
@write_int(0)
ENDIF
ENDIF
IF rscda=TRUE AND windowda=TRUE THEN
FOR i=31 TO 0 STEP -1
IF BTST(winh,i)=TRUE THEN
@rsc_back(i)
ENDIF
NEXT i
ENDIF
GEMSYS 109                                        ! Nur ab GEM 1.04!
'
IF rscda=TRUE THEN
@rsc_exit
ENDIF
IF xload=TRUE THEN
~@xrsrc_free(1)    ! gibt RSC frei
~@xrsrc_free(2)    ! gibt RSC frei
~@xrsrc_free(3)    ! gibt RSC frei (nicht unter MagiC - Absturz !!!)
xload=FALSE
ENDIF
IF xinit=TRUE THEN
@xrsrc_exit(1)      ! beendet xrsrc-Routinen
@xrsrc_exit(2)      ! beendet xrsrc-Routinen
@xrsrc_exit(3)      ! beendet xrsrc-Routinen
xinit=FALSE
ENDIF
' hier eventuell noch AufrÑumaktionen von Libs/Routinen
' einfÅgen, die vor den XRSRC-/Mydial-Routinen gestartet werden
'
@exit
'
IF demo=FALSE OR falcon=TRUE THEN
~XBIOS(&H8A,0,7)          ! GPIO als Outputs
~XBIOS(&H8A,2,0)          ! GPIO = 0
ENDIF
IF demo=FALSE THEN
~XBIOS(xbs,28,0)          ! 16 Bit
~XBIOS(xbs,20,1)          ! Analogeingang benutzen
~XBIOS(xbs,25,0)          ! Switch to Bypass-Output
~XBIOS(xbs,26,2)          ! recordmode=Achtkanal
~XBIOS(xbs,27,2)          ! playmode=Achtkanal
~XBIOS(xbs,23,2)          ! Taktrate 44.1 wÑhlen
~XBIOS(xbs,160,1)         ! SND-Cookie Emulationmode
ENDIF
IF demo=FALSE OR falcon=TRUE THEN
~XBIOS(&H8B,0,0,0,2,1)    ! DMAPLAY none
~XBIOS(&H8B,1,0,0,2,1)    ! DSPXMIT none
~XBIOS(&H8B,2,0,0,2,1)    ! EXTINP  none
~XBIOS(&H8B,3,15,0,2,1)   ! ADC to DMAREC + DSPREC + EXTOUT + DAC
~XBIOS(&H84,1)            ! 16 Bit
~XBIOS(&H85,0,0)          ! 2 channels rec/play
~XBIOS(&H86,0)            ! Monitoring 0
~XBIOS(&H81)              ! unlock
ENDIF
'
IF compile=FALSE THEN
RESERVE         ! Reservierung lîschen
ENDIF
IF accx=FALSE THEN
END
ENDIF
RETURN
'
> PROCEDURE memfeld(memolen,grenz)
.| Glob. Var.: mem$,nr#,smp16&,smpedit&
.| Aufruf in : fnamwrite-1,smplen-1,smpplay-1,record3-1,
LOCAL a,b
b=memolen
a=LEN(STR$(b))
IF a>6 THEN
b=INT(b/1024)
ENDIF
mem$=STR$(b)
IF nr=smp16& THEN
IF a>6 THEN
mem$=mem$+" KB used"+CHR$(0)
ELSE
mem$=mem$+" Bytes used"+CHR$(0)
ENDIF
ENDIF
IF nr=smpedit& THEN
IF a>6 THEN
mem$="LEN "+mem$+" KB"+CHR$(0)
ELSE
mem$="LEN "+mem$+" BYTES"+CHR$(0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE secfeld(seclen,grenz)
.| Glob. Var.: sec$,nr#,smpedit&
.| Aufruf in : fnamwrite-1,smpsec-1,do_blkf-1,smpplay-1,record3-1,
IF nr=smpedit& THEN
hsec=INT(seclen*100)
@htimeset
sec$="= "+a$+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE fnamwrite
.| Glob. Var.: nr#,smpedit&,smpfile&,smpnam$,smplen#,smplen&,mem$,sec#,hz#
.|     smpsec&,sec$
.| Ruft auf  : textfeld,memfeld,secfeld,smpfree
.| Aufruf in : smplen-1,smpsec-1,smpsave-1,smpload-1,ldhlp-1,smpedit-1
.|     do_smpedit-11,rebuild-1,markdel-1,setup2-1,memtovirt-1,memtovirt2-1
.|     smpplay-1,record2-1,record4-1,
IF nr=smpedit& THEN
@textfeld(smpfile&,smpnam$+CHR$(0),1)
@memfeld(smplen,8)
@textfeld(smplen&,mem$,1)
sec=smplen/(hz*mbit)
@secfeld(sec,8)
@textfeld(smpsec&,sec$,1)
@smpfree
ENDIF
RETURN
'
> PROCEDURE smpfree
.| Glob. Var.: lfw$,op$,smpname&
.| Ruft auf  : textfeld
.| Aufruf in : fnamwrite-1,setupdat-1,
LOCAL a$,a
a=ASC(LEFT$(lfw$,1))-64
a=INT(@dfree(a)/1024)
a$=LEFT$(lfw$,2)+STR$(a)+"K  "
a=ASC(LEFT$(op$,1))-64
a=INT(@dfree(a)/1024)
a$=a$+LEFT$(op$,2)+STR$(a)+"K"
IF LEN(a$)>20 THEN
a$=LEFT$(a$,20)
ENDIF
a$=a$+CHR$(0)
@textfeld(smpname&,a$,1)
RETURN
'
> PROCEDURE smplen
.| Glob. Var.: mlen#,mem$,smplen&
.| Ruft auf  : memfeld,textfeld,fnamwrite,setbutton
.| Aufruf in : do_smpedit-1,
@memfeld(mlen,8)
mem$="MAX"+RIGHT$(mem$,LEN(mem$)-3)
@textfeld(smplen&,mem$,1)
PAUSE 100
@fnamwrite
@setbutton(smplen&,0)
RETURN
'
> PROCEDURE smpsec
.| Glob. Var.: mlen#,hz#,sec$,smpsec&
.| Ruft auf  : secfeld,textfeld,fnamwrite,setbutton
.| Aufruf in : do_smpedit-1,
LOCAL s
s=(mlen/(hz*mbit))
hsec=INT(s*100)
@htimeset
sec$="MAX "+a$+CHR$(0)
@textfeld(smpsec&,sec$,1)
PAUSE 100
@fnamwrite
@setbutton(smpsec&,0)
RETURN
'
> PROCEDURE selblkstxt(i,a$)        ! Zeit in Marker schreiben
SELECT i
CASE 1
@textfeld(edmtims&,a$,1)
CASE 2
@textfeld(edmtime&,a$,1)
CASE 3
@textfeld(edmtimi&,a$,1)
CASE 4
@textfeld(edmtimr&,a$,1)
ENDSELECT
RETURN
'
> PROCEDURE selblkshak(i,b)         ! Marker auswÑhlen
.| Glob. Var.: hacksa&,hacksb&,hacksc&,hacksd&,hackse&,hackss&
.| Aufruf in : markprod3-1,smpstx-1,smpsts-1,smph3-1,
LOCAL a
SELECT i
CASE 1
a=edmbuts&
@setbutton(a,b)
CASE 2
a=edmbute&
@setbutton(a,b)
CASE 3
a=edmbuti&
@setbutton(a,b)
CASE 4
a=edmbutr&
@setbutton(a,b)
ENDSELECT
RETURN
'
> PROCEDURE helptxt(search$)        ! Hilfstexte von 1st Guide aktivieren
'
' Der Pfad der IDX-Datei muû vorher im 1stGuide Konfigurationsdialog eingegeben werden !!!
'
LOCAL g,hlpfound,t,a,hobj,vfly
msg_id=APPL_FIND("1STGUIDE")
IF msg_id<>-1 THEN
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=s$+"1STGUIDE.IDX"
ENDIF
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=op$+"1STGUIDE.IDX"
ENDIF
IF EXIST(hpath$)=FALSE THEN
hlpfound=FALSE
'    ~GRAF_MOUSE(256,0)                              ! Hidem
'    ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
'   ~GRAF_MOUSE(257,0)                              ! Showm
@fileselect(op$+"*.IDX","1STGUIDE.IDX","Search 1STGUIDE.IDX:")
'   @rsc_put(ab,rscx&(nr),rscy&(nr),1)
IF ordner$<>"" AND pret<>0 AND pbutt=1 THEN
hpath$=ordner$+"1STGUIDE.IDX"
IF EXIST(hpath$)=TRUE THEN
hlpfound=TRUE
ENDIF
ENDIF
ELSE
hlpfound=TRUE
ENDIF
IF hlpfound=TRUE THEN
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
normd=FALSE
IF rsc_handle%(nr)>1000                             ! Normaler Dialog...
normd=TRUE
ndnr=nr
@rsc_back(nr)
ENDIF
'
hpath$=hpath$+CHR$(0)
@appl_write(msg_id,&H4711,0,0,0,0,0,hpath$)    ! VA_START
accwindopen=FALSE
ON MENU MESSAGE GOSUB message
t=TIMER
REPEAT
ON MENU
UNTIL accwindopen=TRUE OR (TIMER-t)>400
@wischwasch
search$=search$+CHR$(0)
a=1025
accwindopen=FALSE
@appl_write(msg_id,a,0,0,0,0,0,search$)                           ! AC_HELP
ON MENU MESSAGE GOSUB message
t=TIMER
REPEAT
ON MENU
UNTIL accwindopen=TRUE OR (TIMER-t)>400
@wischwasch
IF normd=TRUE THEN                            ! Normaler Dialog...
IF rsc_handle%(vornr)<1000                  ! FensterDialog...
IF ndnr=trkcomin& THEN
nr=vorvornr
@editselect
ENDIF
nr=vornr
@editselect
ENDIF
nr=ndnr
@rsc_draw(nr,0)
ENDIF
ELSE
'
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
ENDIF
ELSE
'
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
@wischwasch
@readbutton(obj)
hobj=obj
vfly=fly
fly=TRUE
edit_obj&=0
@alerts(12)
fly=vfly
obj=hobj
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
ENDIF
RETURN
'
> PROCEDURE markhlp
.| Glob. Var.: nr#,handle&,ax&,ay&,ab&,ah&,xd#,yd#,xm#,ym#,sline#,stay1#
.|     ym1#,ym2#,stay2#,dazu#
.| Felder    : rsc_handle%()
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,message-1,normalize-1
.|     fadehandler-1,fade-1,fadelinear-1,fadesquare-1,fadexp-1,fadesqrt-1
.|     fadelog-1,infade-1,ausfade-1,smptime-2,smpkhlp-1,smpmhlp-1,smpihlp-1
.|     zoomhelp-1,smpl-1,smpr-2,smpcut-1,movefrag-1,edhandler2-1,blkstest-1
.|     smpsave-5,blklfrag-2,newfsel-1,blkltest-1,ldhlp-6,sampleinf-1
.|     curve-1,resample-1,slideupdate-1,slidelr-1,dragging1-1,dragging2-1
.|     arrdelay-1,arrmname-1,write-1,smpedit-1,blkfunc-1,time_edit-1,make-1
.|     info-1,trash-2,setupdat-1,smpstx-1,smpsts-1,smpex-1,smpes-1
.|     markhlp6-1,setup-1,conspace-2,midi-1,loopwahl-1,dspwahl-1,peak-1
.|     do_peak-2,peakread2-1,
IF rsc_handle%(nr)<1001                             ! Normaler Dialog...
handle&=rsc_handle%(nr)                         ! Fensterhandle des Dialogs
~WIND_GET(handle&,4,ax&,ay&,ab&,ah&)          ! 1. Rechteck
IF bigfoot=FALSE THEN
xd=ax&+23         ! X-Locator
yd=ay&+13           ! Y-Locator
ELSE
xd=ax&+32         ! X-Locator
yd=ay&+14           ! Y-Locator
ENDIF
dazu=yd+222         ! Y-Locator fÅr Fade
@calc_editboxes1
IF nr=trakker& THEN
IF bigfoot=FALSE THEN
xd=ax&+32
ELSE
xd=ax&+32         ! X-Locator
ENDIF
IF bigfoot=FALSE THEN
yd=ay&+14
ELSE
yd=ay&+14
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE calc_editboxes1
IF nr=smpedit& THEN
@buttbh(editbox4&,xm,ym)
IF bigfoot=FALSE THEN
stay1=yd+32            ! Anfang der Markline
stay2=stay1+ym*2+7
ELSE
stay1=yd+38            ! Anfang der Markline
stay2=stay1+ym*2+24
ENDIF
xm=xm-2
ym=ym-3
ENDIF
RETURN
'
> PROCEDURE calc_editboxes2
LOCAL v
IF nr=smpedit& THEN
@buttbh(editbox4&,v,ym2)
IF bigfoot=FALSE THEN
cxd=ax&+23          ! X-Locator
ym1=ay&+49             ! Y-Locator erste Box
ELSE
cxd=ax&+32          ! X-Locator
ym1=ay&+49+25          ! Y-Locator erste Box
ENDIF
ym2=ym2+ym1+3            ! Y-Locator zweite Box
ENDIF
RETURN
'
> PROCEDURE calc_trakboxes
LOCAL bb3,v
IF nr=trakker& THEN
@buttbh(trakbox2&,trboxl,trboxh)
@buttbh(trkbx1&,bb3,v)
trxstp=(trboxl-bb3-2)/10   ! Pixelabstand pro Zeiteinheits-Teilung der X-Achse
trboxl=trboxl-bb3+2
'
@readpos(trakedbx&)
trhs=by
trhs=trhs-28               ! Y-start-Boxposition
IF bigfoot=TRUE THEN
trhs=trhs+16
ENDIF
'
@buttbh(trkbx1&,mxb,trhb)
trhb=trhb-1                ! Hîhe der Boxen
trht=8                     ! Texthîhe
trhd=3                     ! y-Leerraum zur nÑchsten Box
trhc=INT((trhb-trht)/2)    ! Hîhe der curves
'
IF bigfoot=FALSE THEN
dix=mxb-17
ELSE
dix=mxb-16
ENDIF
'
@buttbh(trakbox2&,dig,v)   ! Breite des Boxenfeldes gesamt
IF bigfoot=FALSE THEN
dig=dig-mxb-2
ELSE
dig=dig-mxb-1
ENDIF
@readpos(trakbxw&)
tvoly=by
ENDIF
RETURN
'
> PROCEDURE markhlp2
.| Glob. Var.: cs#,xd#,stay1#,stay2#,t$
.| Aufruf in : smpstx-1,smpsts-1,smpex-1,smpes-1,
IF cs=0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE xd,stay1,xd,stay2
IF bigfoot=FALSE THEN
DEFTEXT 1,0,0,4
ELSE
DEFTEXT 1,0,0,11
ENDIF
TEXT xd-2,stay1-1,t$
DEFTEXT 1,0,0,4
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
ENDIF
RETURN
'
> PROCEDURE markhlp3(es,i2,stxnr)
LOCAL sc,sc$,s,a$
IF stxnr=-1 THEN
a$=CHR$(0)
sc$=a$
ELSE
IF tedart=0 THEN
hsec=INT(stxnr/hz/mbit*100)
@htimeset
sc$=a$
ELSE
sc=INT(stxnr/mbit)
a$=STR$(sc)
@formatsmp
a$=sc$
IF LEN(sc$)>13 THEN
sc$=LEFT$(sc$,13)
ENDIF
sc$=sc$+CHR$(0)
ENDIF
ENDIF
IF es>0 AND es<=loopz THEN
@selblkstxt(i2,sc$)
ENDIF
IF es=9998 THEN
@textfeld(cstxt&,sc$,1)
ENDIF
IF es=9999 THEN
@textfeld(cetxt&,sc$,1)
ENDIF
RETURN
'
> PROCEDURE markhlp8(i,i2,bx)
.| Glob. Var.: cs#,ce#,cx#,xm#,xd#,stay1#,stay2#,loopz#
.| Ruft auf  : selblkstxt,selblketxt
.| Aufruf in : smph3-2,
LOCAL j,ue
IF i>0 AND i<=loopz THEN
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
LINE cx+xd,stay1,cx+xd,stay2
IF maxcol=2 OR dreidim=0 THEN
COLOR 0
ELSE
COLOR smpwcol
ENDIF
GRAPHMODE 1
IF bigfoot=FALSE THEN
ue=5
ELSE
ue=11
ENDIF
FOR j=xd+cx-3 TO xd+cx+3
LINE j,stay1,j,stay1-ue
NEXT j
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
@selblkstxt(i2,CHR$(0))
ENDIF
RETURN
'
> PROCEDURE normalize
.| Glob. Var.: makecurve#,vorvornr#,vornr#,nr#,normaliz&,normadj&,normauto&
.|     norma#,obj#,popup&,zu%,zuadr#,x#,y#,v#,buttadr#,but#,norml1&,norml2&
.|     norml3&,normr1&,normr2&,normr3&,objadr#,objflag#,helpnorm&,normok&
.|     normexit&,norm&
.| Ruft auf  : rsc_draw,markhlp,setbutton,normtest,rsc_do,xrsrc_gaddr,mouse
.|     norml,normr,helptxt,normauto,normadj,rsc_back,blkrestaura
.| Aufruf in : do_blkf-1,
@testcopyright
makecurve=0
vorvornr=vornr
vornr=nr
nr=normaliz&
IF norma=1 THEN
@hidetree2(normbox3&,TRUE)
ENDIF
IF norma=0 THEN
@setbutton3(normauto&,0,nr)
@setbutton3(normadj&,1,nr)
db$=STR$(db)+CHR$(0)
ELSE
@setbutton3(normadj&,0,nr)
@setbutton3(normauto&,1,nr)
db$=STR$(0)+CHR$(0)
ENDIF
@textfeld2(nr,normdb&,db$,1)
@rsc_draw(nr,0)
@markhlp
@normtest
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v)
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
IF obj=norml1& OR obj=norml2& OR obj=norml3& OR obj=normr1& OR obj=normr2& OR obj=normr3& THEN
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=norml1& OR obj=norml2& OR obj=norml3& THEN
@norml
ENDIF
IF obj=normr1& OR obj=normr2& OR obj=normr3& THEN
@normr
ENDIF
IF obj=normauto& THEN
norma=1
db$=STR$(0)+CHR$(0)
@textfeld(normdb&,db$,1)
@hidetree(normbox3&,TRUE,normbox&)
ENDIF
IF obj=normadj& THEN
norma=0
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
@hidetree(normbox3&,FALSE,normbox&)
ENDIF
IF obj=helpnorm& THEN
@helptxt("OPTIMIZE")
ENDIF
UNTIL obj=normok& OR obj=normexit&
nr=normaliz&
@setbutton(obj,0)
@rsc_back(nr)
IF obj=normok& THEN
nr=smpedit&
@editselect
IF mdb<>-aufloes THEN
IF norma=1 THEN
@normauto
ENDIF
IF norma=0 THEN
@normadj
ENDIF
ENDIF
ENDIF
nr=blkfunc&
@blkrestaura
@setbutton(norm&,0)
vornr=vorvornr
obj=0
RETURN
'
> PROCEDURE fadehandler
.| Glob. Var.: x#,y#,k#,yd#,yma#,dazu#,xd#,fxl#,xm#,ym#,fadericht#,fadnr#,i#
.|     v3#,nr#,buttadr#,zuadr#,obj#,but#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : markhlp,mouse,mousek,rsc_redraw_obj
.| Aufruf in : rsc_do-1,
IF cupdate=FALSE THEN
@windowtest
IF mywindow=TRUE THEN
@markhlp
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
@mouse(x,y,k)
IF y>=(ay&+14) AND y<=(ay&+14+225) AND x>=(ax&+32+fxl) AND x<=(ax&+32+242) AND k=1 THEN
@clsfade
GRAPHMODE 1
yma=dazu
IF x<ax&+32+fxl THEN
x=ax&+32+fxl
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
LINE x,y,x,y
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
xm=x
ym=y
IF fadericht=1 THEN
IF xm>ax&+32+10 THEN
xm=ax&+32+10
ENDIF
ENDIF
REPEAT
@mouse(x,y,k)
IF fadericht=0 THEN
IF x>=xm AND x>ax&+32+fxl-1 AND x<ax&+32+fxl+fadnr-1 THEN
IF y>ym THEN
y=ym
ENDIF
IF y<(ay&+14) THEN
y=ay&+14
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
LINE xm,ym,x,y
FOR i=xm TO x
LINE i,yma,i,y
fadeni(i-(ax&+32)-fxl)=fadnr-(y-(ay&+14))
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
xm=x
ym=y
ENDIF
ELSE
IF x>=xm AND x>ax&+32+fxl-1 AND x<ax&+32+fxl+fadnr-1 THEN
IF ym>y THEN
y=ym
ENDIF
IF y>dazu THEN
y=dazu
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
LINE xm,ym,x,y
FOR i=xm TO x
LINE i,yma,i,y
fadeno(i-(ax&+32)-fxl)=fadnr-(y-(ay&+14))
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
xm=x
ym=y
ENDIF
ENDIF
v3=@mousek
UNTIL v3=0
@getfade
drawnew=TRUE
IF x<ax&+32+fxl+fadnr-1 THEN
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE fade
@testcopyright
IF BTST(winh,editfade&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=editfade&
~@xrsrc_gaddr(0,nr,zu%)
boxadr=zu%
IF fadericht=0 THEN
@setbutton3(infade&,1,nr)
ELSE
@setbutton3(ausfade&,1,nr)
ENDIF
FOR i=1 TO fadnr
bfadeni(i)=fadeni(i)
bfadeno(i)=fadeno(i)
NEXT i
fxl=-14   ! Linke Kante-X Fadefenster
@rsc_draw(nr,7)
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
yma=dazu
CLIP 0,0,xwidth,ywidth
GRAPHMODE 1
DEFLINE 1
COLOR 1
IF drawnew3=TRUE THEN
FOR i=1 TO fadnr
IF fadericht=0 THEN
a=fadeni(i)/fadnr*(dazu-(ay&+14))
y=dazu-a
ELSE
a=fadeno(i)/fadnr*(dazu-(ay&+14))
y=dazu-a
ENDIF
IF a<>0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
LINE i+ax&+32+fxl,yma,i+ax&+32+fxl,y
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
ENDIF
NEXT i
@getfade
ELSE
@putfade
ENDIF
CLIP OFF
ELSE
@setbutton(edfade&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=editfade&
IF vornr=smpedit& THEN
@setbutton2(edfade&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_fade
fxl=-14   ! Linke Kante-X Fadefenster
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
IF obj=helpfade& THEN
@helptxt("FADE-EDITOR")
ENDIF
IF obj=infade& THEN
@infade
ENDIF
IF obj=ausfade& THEN
@ausfade
ENDIF
IF obj=fadelin& THEN
@fadelinear
ENDIF
IF obj=fadexp& THEN
@fadexp
ENDIF
IF obj=fadesqrt& THEN
@fadesqrt
ENDIF
IF obj=fadedel& THEN
@fadedel
ENDIF
IF obj=fdsquare& THEN
@fadesquare
ENDIF
IF obj=fadelog& THEN
@fadelog
ENDIF
IF obj=fadload& THEN
@fadeload
ENDIF
IF obj=fadsave& THEN
@fadesave
ENDIF
IF obj=fadexit& OR obj=fadeundo& OR obj=infade& OR obj=ausfade& THEN
aw=FORM_BUTTON(boxadr,obj,1,a)
REPEAT
UNTIL @mousek=0
ELSE
IF obj<>9999 THEN
@setbutton(obj,1)
PAUSE 1
@setbutton(obj,0)
ENDIF
ENDIF
IF obj=fadexit& THEN
@setbutton(obj,0)
ENDIF
IF obj=fadeundo& THEN
@setbutton(obj,0)
IF fadericht=0 THEN
FOR i=1 TO fadnr
fadeni(i)=bfadeni(i)
NEXT i
@infade
ELSE
FOR i=1 TO fadnr
fadeno(i)=bfadeno(i)
NEXT i
@ausfade
ENDIF
ENDIF
IF obj=fadexit& OR obj=9999 THEN
winh=BCLR(winh,nr)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(edfade&,0)
ENDIF
ENDIF
GRAPHMODE 3
RETURN
'
> PROCEDURE getfade
LOCAL x,y,b,h
IF nr=editfade& THEN
IF windcache=TRUE THEN
@windowtest
@markhlp
IF bigfoot=FALSE THEN
x=ax&+23-1          ! X-Locator
y=ay&+41-28          ! Y-Locator erste Box
ELSE
x=ax&+24-8          ! X-Locator
y=ay&+41-28          ! Y-Locator erste Box
ENDIF
b=248              ! Breite der Box
h=224              ! Hîhe der Box
lmfade=b*h*planes&/8
~GRAF_MOUSE(256,0)                              ! Hidem
IF shading=FALSE AND dopix=FALSE THEN
memfade=@rsc_get2(x,y,b,h,memfade)
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
IF ((x+b)>xwidth OR (y+h)>ywidth) THEN
drawnew3=TRUE
ENDIF
ELSE
drawnew3=TRUE
ENDIF
ENDIF
RETURN
'
> PROCEDURE putfsize
IF bigfoot=FALSE THEN
x=ax&+23-1          ! X-Locator
y=ay&+41-28          ! Y-Locator erste Box
ELSE
x=ax&+24-8          ! X-Locator
y=ay&+41-28          ! Y-Locator erste Box
ENDIF
b=248              ! Breite der Box
h=224              ! Hîhe der Box
IF nr=editfade& THEN
IF (x+b)>xwidth OR (y+h)>ywidth THEN
drawnew3=TRUE
ELSE
IF drawnew3=TRUE THEN
credraw=TRUE
IF fadericht=0 THEN
@infade
ELSE
@ausfade
ENDIF
credraw=FALSE
@getfade
ENDIF
drawnew3=FALSE
ENDIF
ELSE
drawnew3=FALSE
ENDIF
RETURN
'
> PROCEDURE putfade
LOCAL x,y,b,h
IF nr=editfade& THEN
IF windcache=TRUE THEN
@windowtest
@markhlp
IF bigfoot=FALSE THEN
x=ax&+23-1          ! X-Locator
y=ay&+41-28          ! Y-Locator erste Box
ELSE
x=ax&+24-8          ! X-Locator
y=ay&+41-28          ! Y-Locator erste Box
ENDIF
b=248              ! Breite der Box
h=224              ! Hîhe der Box
IF (x1+b1)>=x AND x1<=x+b AND (y1+h1)>=y AND y1<=y+h THEN
mx=x1
my=y1
mx1=x1-x
my1=y1-y
IF x1<x THEN
mx1=0
mx=x
ENDIF
IF y1<y THEN
my1=0
my=y
ENDIF
mb1=b1
mh1=h1
IF x1<x THEN
mb1=(x1+b1)-x
ENDIF
IF y1<y THEN
mh1=(y1+h1)-y
ENDIF
IF mb1>b THEN
mb1=b
ENDIF
IF mh1>h THEN
mh1=h
ENDIF
IF mx+mb1>x+b THEN
mb1=(x+b)-mx
ENDIF
IF my+mh1>y+h THEN
mh1=(y+h)-my
ENDIF
'
IF mx+mb1>xwidth THEN
mb1=xwidth-mx
ENDIF
IF my+mh1>ywidth THEN
mh1=ywidth-my
ENDIF
IF mx>=x AND my>=y AND mx1>=0 AND my1>=0 AND mb1>0 AND mh1>0 THEN
IF shading=FALSE AND dopix=FALSE THEN
~GRAF_MOUSE(256,0)                              ! Hidem
@rsc_putblock(memfade,mx,my,mx1,my1,mb1,mh1)
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
ENDIF
ELSE
drawnew3=TRUE
ENDIF
ENDIF
RETURN
'
> PROCEDURE clsfade
.| Glob. Var.: nr#
.| Ruft auf  : rsc_redraw_obj
.| Aufruf in : fadelinear-1,fadesquare-1,fadexp-1,fadesqrt-1,fadelog-1
.|     infade-1,ausfade-1,
IF nr=editfade& THEN
'  @markhlp
'  COLOR 0
'  GRAPHMODE 1
'  PBOX xd+fxl,dazu-fadnr+24,xd+fxl+fadnr,dazu
'  COLOR 1
IF cupdate=FALSE THEN
@rsc_redraw_obj(nr,0)
@getfade
ENDIF
ENDIF
RETURN
'
> PROCEDURE fadelinear
.| Glob. Var.: fadericht#,ym#,dazu#,y#,i#,fadnr#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL i
@clsfade
GRAPHMODE 1
@markhlp
CLIP 0,0,xwidth,ywidth
IF fadericht=0 THEN
fadewin=0
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
FOR i=1 TO fadnr
IF nr=editfade& THEN
LINE i+ax&+32+fxl,ym,i+ax&+32+fxl,ym-(y/fadnr*(dazu-(ay&+14)))
ENDIF
fadeni(i)=y
y=y+1
drawnew=TRUE
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=0
ym=dazu
y=fadnr-1
~GRAF_MOUSE(256,0)                              ! Hidem
FOR i=1 TO fadnr
IF nr=editfade& THEN
LINE i+ax&+32+fxl,ym,i+ax&+32+fxl,ym-(y/fadnr*(dazu-(ay&+14)))
ENDIF
fadeno(i)=y
y=y-1
drawnew=TRUE
NEXT i
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
@getfade
CLIP OFF
RETURN
'
> PROCEDURE fadesquare
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
c=SQR(fadnr)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
CLIP 0,0,xwidth,ywidth
IF fadericht=0 THEN
fadewin=1
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=teil
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+ax&+32+fxl,ym,i+ax&+32+fxl,ym-(y/fadnr*(dazu-(ay&+14)))
ENDIF
y=b
fadeni(i)=y
a=a+teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=1
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+ax&+32+fxl,ym,i+ax&+32+fxl,ym-(y/fadnr*(dazu-(ay&+14)))
ENDIF
y=b
fadeno(i)=y
a=a-teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
@getfade
CLIP OFF
RETURN
'
> PROCEDURE fadexp
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
d=8
c=LOG(fadnr*d)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
CLIP 0,0,xwidth,ywidth
IF fadericht=0 THEN
fadewin=2
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=0
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+ax&+32+fxl,ym,i+ax&+32+fxl,ym-(y/fadnr*(dazu-(ay&+14)))
ENDIF
y=b
fadeni(i)=y
a=a+teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=2
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+ax&+32+fxl,ym,i+ax&+32+fxl,ym-(y/fadnr*(dazu-(ay&+14)))
ENDIF
y=b
fadeno(i)=y
a=a-teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
@getfade
CLIP OFF
RETURN
'
> PROCEDURE fadesqrt
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
c=SQR(fadnr)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
CLIP 0,0,xwidth,ywidth
IF fadericht=0 THEN
fadewin=3
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+ax&+32+fxl,ym,i+ax&+32+fxl,ym-(y/fadnr*(dazu-(ay&+14)))
ENDIF
y=fadnr-b
fadeni(i)=y
a=a-teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=3
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=0
FOR i=1 TO fadnr
b=a*a
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+ax&+32+fxl,ym,i+ax&+32+fxl,ym-(y/fadnr*(dazu-(ay&+14)))
ENDIF
y=fadnr-b
fadeno(i)=y
a=a+teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
@getfade
CLIP OFF
RETURN
'
> PROCEDURE fadelog
.| Glob. Var.: fadnr#,teil#,fadericht#,ym#,dazu#,y#,i#,xd#,fxl#,yd#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : clsfade,markhlp
.| Aufruf in : fade-1,
LOCAL a,b,c,d,i
d=8
c=LOG(fadnr*d)
teil=c/fadnr
@clsfade
GRAPHMODE 1
@markhlp
CLIP 0,0,xwidth,ywidth
IF fadericht=0 THEN
fadewin=4
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=c
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+ax&+32+fxl,ym,i+ax&+32+fxl,ym-(y/fadnr*(dazu-(ay&+14)))
ENDIF
y=fadnr-b
fadeni(i)=y
a=a-teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
fadewout=4
ym=dazu
y=0
~GRAF_MOUSE(256,0)                              ! Hidem
a=0
FOR i=1 TO fadnr
b=EXP(a)/d
IF y>fadnr THEN
y=fadnr
ENDIF
IF nr=editfade& THEN
LINE i+ax&+32+fxl,ym,i+ax&+32+fxl,ym-(y/fadnr*(dazu-(ay&+14)))
ENDIF
y=fadnr-b
fadeno(i)=y
a=a+teil
NEXT i
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
@getfade
CLIP OFF
RETURN
'
> PROCEDURE setlinear
.| Glob. Var.: y#,i#,fadnr#
.| Felder    : fadeni#(),fadeno#()
.| Aufruf in : fadeset-1,
y=0
FOR i=1 TO fadnr
fadeni(i)=y
y=y+1
NEXT i
y=fadnr
FOR i=1 TO fadnr
fadeno(i)=y
y=y-1
NEXT i
RETURN
'
> PROCEDURE infade
.| Glob. Var.: fadericht#,ausfade&,infade&,yma#,dazu#,i#,fadnr#,a#,yd#,y#
.|     xd#,fxl#
.| Felder    : fadeni#()
.| Ruft auf  : markhlp,clsfade,setbutton
.| Aufruf in : fade-1,fadesave-1,fadeload-1,
LOCAL i
@markhlp
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
fadericht=0
GRAPHMODE 1
IF nr=editfade& AND cupdate=FALSE THEN
@clsfade
@setbutton(ausfade&,0)
@setbutton(infade&,1)
ENDIF
yma=dazu
'  IF nr=editfade& THEN
~GRAF_MOUSE(256,0)                              ! Hidem
' ENDIF
FOR i=1 TO fadnr
a=fadeni(i)/fadnr*(dazu-(ay&+14))
y=dazu-a
IF a<>0 AND nr=editfade& THEN
LINE i+ax&+32+fxl,yma,i+ax&+32+fxl,y
ENDIF
NEXT i
drawnew=TRUE
'  IF nr=editfade& THEN
~GRAF_MOUSE(257,0)                              ! Showm
' ENDIF
@getfade
IF credraw=FALSE THEN
CLIP OFF
ENDIF
RETURN
'
> PROCEDURE ausfade
.| Glob. Var.: fadericht#,infade&,ausfade&,yma#,dazu#,i#,fadnr#,a#,yd#,y#
.|     xd#,fxl#
.| Felder    : fadeno#()
.| Ruft auf  : markhlp,clsfade,setbutton
.| Aufruf in : fade-1,fadesave-1,fadeload-1,
LOCAL i
@markhlp
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
fadericht=1
GRAPHMODE 1
IF nr=editfade& AND cupdate=FALSE THEN
@clsfade
@setbutton(infade&,0)
@setbutton(ausfade&,1)
ENDIF
yma=dazu
'  IF nr=editfade& THEN
~GRAF_MOUSE(256,0)                              ! Hidem
' ENDIF
FOR i=1 TO fadnr
a=fadeno(i)/fadnr*(dazu-(ay&+14))
y=dazu-a
IF a<>0 AND nr=editfade& THEN
LINE i+ax&+32+fxl,yma,i+ax&+32+fxl,y
ENDIF
NEXT i
drawnew=TRUE
'  IF nr=editfade& THEN
~GRAF_MOUSE(257,0)                              ! Showm
' ENDIF
@getfade
IF credraw=FALSE THEN
CLIP OFF
ENDIF
RETURN
'
> PROCEDURE fadedel
.| Glob. Var.: i#,fadnr#,fadericht#,nr#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : rsc_redraw_obj
.| Aufruf in : fade-1,
FOR i=1 TO fadnr
IF fadericht=0 THEN
fadeni(i)=0
ELSE
fadeno(i)=0
ENDIF
NEXT i
@rsc_redraw_obj(nr,0)
@getfade
RETURN
'
> PROCEDURE fade_it
.| Glob. Var.: sblock#,b1#,c1#,b2#,c2#,mlen#,sms#,sme#,fadericht#,a1#,a2#
.|     vmem#,virtual#,okay#,virtwfile#,virtpath$,a#,virtln#,virtp$,virtfile$
.|     vln#,bytes#,e#,meml#,e2#,i#,fadnr#,mdat3%,c#,back%,g#,cached#,path$
.|     smpnam$,noblkdel#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : blocklook,busy_mouse,maschinit31,maschruf31b,maschinit32
.|     maschruf32,maschinit30,maschruf30,restaura,hardproof3,memtovirt2
.|     nomem
.| Aufruf in : smpl-1,smpr-1,
LOCAL teil
teil=1024
IF sblock=1 THEN
@blocklook
b1=INT(c1/mbit)*mbit
b2=INT(c2/mbit)*mbit
ELSE
b1=0
b2=INT(mlen/mbit)*mbit
ENDIF
IF sblock=0 OR (sblock=1 AND c1<c2 AND c1>=0 AND c2>0 AND sms<>0) THEN
IF fadericht=1 THEN
a1=b1
a2=b1+teil
IF a2>vmem THEN
a1=b1-teil
a2=b1
ENDIF
IF a1<0 THEN
a1=0
IF (a2-a1)<teil THEN
a2=teil
ENDIF
ENDIF
ENDIF
IF fadericht=0 THEN
a1=b2-teil
a2=b2
IF a1<0 THEN
a1=b2
a2=b2+teil
ENDIF
IF a2>vmem THEN
a2=vmem
IF (a2-a1)<teil THEN
a1=vmem-teil
ENDIF
ENDIF
ENDIF
IF virtual=FALSE OR (virtual=TRUE AND c2-c1<=mlen) THEN
IF virtual=TRUE THEN
okay=FALSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF @dfree(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
SEEK #1,a1
vln=a2-a1
bytes=INT(mlen/mbit)*mbit
e=0
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ENDIF
IF e=0 AND sblock=1 THEN
e=16384
ENDIF
IF e<>0 AND sblock=1 THEN
FOR i=1 TO fadnr
IF fadericht=0 THEN
DPOKE mdat%+i*2-2,INT(65535/fadnr*fadeni(i))
ELSE
DPOKE mdat%+i*2-2,INT(65535/fadnr*fadeno(i))
ENDIF
NEXT i
IF virtual=FALSE THEN
IF fadericht=0 THEN
c=0
@maschruf32(b1,b2,c)
IF back%<>-1 THEN
b1=back%
ENDIF
ENDIF
IF fadericht=1 THEN
c=1
@maschruf32(b1,b2,c)
IF back%<>-1 THEN
b2=back%
ENDIF
ENDIF
@maschruf30(mdat%,fadnr,b1,b2)
ELSE
IF okay=TRUE THEN
SEEK #1,b1
vln=b2-b1
bytes=INT(mlen/mbit)*mbit
IF vln<=bytes THEN
@busy_mouse
bytes=INT(vln/mbit)*mbit
IF bytes>3 THEN
BGET #1,meml,bytes
IF fadericht=0 THEN
c=0
@maschruf32(0,bytes,c)
IF back%<>-1 THEN
b1=b1+back%
ENDIF
ENDIF
IF fadericht=1 THEN
c=1
@maschruf32(0,bytes,c)
IF back%<>-1 THEN
b2=b2-((b2-b1)-back%)
ENDIF
ENDIF
ENDIF
ENDIF
IF virtwfile=FALSE THEN
SEEK #1,b1
IF (b2-b1)<=mlen THEN
@busy_mouse
BGET #1,meml,b2-b1
@maschruf30(mdat%,fadnr,0,b2-b1)
SEEK #1,b1
BPUT #1,meml,b2-b1
CLOSE #1
ELSE
@alerts(3)
ENDIF
ELSE
SEEK #1,0
IF (b2-b1)<=mlen THEN
vln=b1
bytes=INT(mlen/mbit)*mbit
IF vln>0 THEN
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
@busy_mouse
vln=b2-b1
bytes=INT(vln/mbit)*mbit
BGET #1,meml,bytes
@maschruf30(mdat%,fadnr,0,b2-b1)
BPUT #2,meml,bytes
vln=INT((virtln-b2)/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
IF vln>0 THEN
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ELSE
@alerts(3)
ENDIF
ENDIF
ENDIF
ENDIF
IF virtual=FALSE OR (virtual=TRUE AND okay=TRUE AND (b2-b1)<=mlen AND virtwfile=TRUE) THEN
cached=FALSE
@restaura
ENDIF
ELSE
@alerts(13)
ENDIF
IF okay=TRUE THEN
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
@busy_mouse
path$=virtpath$
a=RINSTR(virtpath$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
cached=FALSE
@restaura
ENDIF
ENDIF
ELSE
IF (c2-c1)>mlen THEN
@alerts(3)
ELSE
@nomem
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@alerts(13)
ENDIF
RETURN
'
> PROCEDURE fadesave
.| Glob. Var.: fade$,lfw$,fil$,pret#,pbutt#,a#,sector#,i#,fadnr#,fadericht#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : fileselect,nomem,infade,ausfade
.| Aufruf in : fade-1,
LOCAL p$,g,g2
g=RINSTR(fade$,"\")
@fileselect(lfw$+"*."+RIGHT$(fade$,3),RIGHT$(fade$,LEN(fade$)-g),"FADER-SAVE:")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+RIGHT$(fade$,4)
ELSE
IF RIGHT$(fil$,4)<>RIGHT$(fil$,4) THEN
fil$=LEFT$(fil$,g2)+RIGHT$(fade$,3)
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>=sector THEN
OPEN "O",#1,fil$
PRINT #1,"STARTRACK-FADER V2.0"           ! Versionskontrolle
PRINT #1
PRINT #1,"items="+STR$(fadnr)
PRINT #1
FOR i=1 TO fadnr
PRINT #1,"fade_in"+STR$(i)+"="+STR$(fadeni(i))
NEXT i
PRINT #1
FOR i=1 TO fadnr
PRINT #1,"fade_out"+STR$(i)+"="+STR$(fadeno(i))
NEXT i
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
IF fadericht=0 THEN
@infade
ELSE
ausfade
ENDIF
RETURN
'
> PROCEDURE fadeload
.| Glob. Var.: fade$,lfw$,fil$,pret#,pbutt#,i#,fadnr#,fadericht#
.| Felder    : fadeni#(),fadeno#()
.| Ruft auf  : fileselect,infade,ausfade
.| Aufruf in : fade-1,
LOCAL p$,g
g=RINSTR(fade$,"\")
@fileselect(lfw$+"*."+RIGHT$(fade$,3),RIGHT$(fade$,LEN(fade$)-g),"FADER-LOAD:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
IF EXIST(fil$) THEN
OPEN "I",#1,fil$
@fadeinfread
CLOSE #1
ENDIF
ENDIF
IF fadericht=0 THEN
@infade
ELSE
ausfade
ENDIF
RETURN
'
> PROCEDURE fadeinfread
LOCAL fadv,fadv$
INPUT #1,fadv$              !  "STARTRACK-PLUGCONFIG V2.0"  Versionskontrolle
IF MID$(fadv$,LEN(fadv$)-3,1)="V" THEN
fadv=VAL(RIGHT$(fadv$,3))
ELSE
fadv=0
ENDIF
IF fadv>=2 THEN
REPEAT
EXIT IF EOF(#1)
INPUT #1,a$
@changelowkey2
IF INSTR(a$,"items")<>0 THEN
@delsourcekey
fadnr=VAL(a$)
fadewin=-1
fadewout=-1
ENDIF
IF INSTR(a$,"fade_in")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-7)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF fadnr>=b THEN
fadeni(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"fade_out")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-8)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF fadnr>=b THEN
fadeno(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
UNTIL EOF(#1)
ENDIF
RETURN
'
> PROCEDURE fadeset
.| Glob. Var.: fadnr#,fade$,i#
.| Felder    : fadeni#(),fadeno#(),bfadeni#(),bfadeno#()
.| Ruft auf  : setlinear
.| Aufruf in : setload-1,
IF fadnr<>246 THEN
fadnr=246          ! Breite des Fadefensters in Pixeln
DIM fadeni(fadnr)
DIM fadeno(fadnr)
DIM bfadeni(fadnr)
DIM bfadeno(fadnr)
IF EXIST(fade$) THEN
OPEN "I",#1,fade$
@fadeinfread
CLOSE #1
ELSE
@setlinear
ENDIF
ENDIF
RETURN
'
> PROCEDURE blocklook
.| Glob. Var.: master#,loopz#,sms#,msms#,sme#,msme#,c1#,c2#,xm#,ce#,mce#
.|     meml#,mcs#
.| Felder    : loops#(),loope#()
.| Aufruf in : intzeiger1-1,fade_it-1,smpkhlp-1,movingmark-1,smpmhlp-1
.|     smpihlp-1,smpl-1,smpr-1,smpcut-1,sampleinf-1,resample-1,copytoarr-1
.|     trash-1,mono-2,negate-2,lrchange-2,makenorm-1,normtest-1,makeresmp-1
.|     smpplay-2,smpauto-1,record-1,
IF sms2<>0 AND sms>0 AND sms<=loopz THEN
c1=loops%(sms,1)
c2=loops%(sms,2)
IF c2=-1 AND c1<>-1 THEN
c2=vmem                   ! NEU sei 12.9.98 !!!
ENDIF
ENDIF
IF xm>0 AND ce<>0 AND sms<>0 AND c2>c1 AND c2<>-1 AND c1<>-1 THEN
mce=c2+meml
mce=INT(mce/mbit)*mbit
mcs=c1+meml
mcs=INT(mcs/mbit)*mbit
ENDIF
RETURN
'
> PROCEDURE smptime
LOCAL a,a2,tex,a$
.| Glob. Var.: hrd#,vornr#,nr#,record&,min$,min#,timetxt&,oldmin#,obj#
.|     popup&,zu%,zuadr#,buttadr#,but#,objadr#,objflag#,rechelp&,recexit&
.|     recok&,recl1&,recl2&,recr1&,recr2&
.| Ruft auf  : markhlp,rsc_draw,textfeld,rsc_do,xrsrc_gaddr,mousek,helptxt
.|     setbutton,restaura2
.| Aufruf in : smpauto-1,smpstart-1,
@testcopyright
a=ASC(LEFT$(fil$,1))-64
a2=@dfree(a)
a2=INT(a2-(a2/254)-16384)
IF a2<=0 THEN
nofile=0
@nomem
ELSE
vornr=nr
nr=record&
a$="Record-Time"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
hsec=INT(a2/hz/mbit*100)
mmax=hsec
@htimeset
a$="FREETIME: "+a$
@textfeld2(nr,recfree&,a$,1)
@rsc_draw(nr,0)
@markhlp
timekey=4
@timekey
REPEAT
@timeinp(mmax,rtime)
IF obj=rechelp& THEN
@helptxt("RECORD-TIME")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
@minwrite
ENDIF
ENDIF
RETURN
'
> PROCEDURE timeinp(timax,VAR tiwert)
LOCAL tex,otiwert
'  LOCAL tiframes,tifrmax
tifrmax=ROUND(timax/100*framez)
tiframes=ROUND(tiwert/100*framez)
IF tiframes>tifrmax THEN
tiframes=tifrmax
ENDIF
hsec=tiframes
@htimeset3
@editfeld(timetxt&,ab$)
otiwert=tiwert
REPEAT
REPEAT
tex=FALSE
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>timetxt& OR doexit=TRUE
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF doexit=TRUE THEN
obj=keyobj
doexit=FALSE
ENDIF
IF obj=tinpul1& OR obj=tinpul2& OR obj=tinpul3& OR obj=tinpul4& THEN
tex=TRUE
ENDIF
IF obj=tinpuh1& OR obj=tinpuh2& OR obj=tinpuh3& OR obj=tinpuh4& THEN
tex=TRUE
ENDIF
IF obj=tinpdl1& OR obj=tinpdl2& OR obj=tinpdl3& OR obj=tinpdl4& THEN
tex=TRUE
ENDIF
IF obj=tinpdh1& OR obj=tinpdh2& OR obj=tinpdh3& OR obj=tinpdh4& THEN
tex=TRUE
ENDIF
IF obj=tinmin& THEN
tiframes=0
hsec=tiframes
@htimeset3
@editfeld(timetxt&,ab$)
@setbutton(obj,0)
ENDIF
IF obj=tinmax& THEN
tiframes=tifrmax
hsec=tiframes
@htimeset3
@editfeld(timetxt&,ab$)
@setbutton(obj,0)
ENDIF
UNTIL obj=rechelp& OR obj=recexit& OR obj=recok& OR tex=TRUE OR doexit=TRUE
IF (obj=recexit& OR obj=recok& OR tex=TRUE) THEN
@setbutton(obj,0)
ENDIF
@editread(timetxt&)
IF LEN(a$)=8 THEN
tiframes=VAL(LEFT$(a$,2))*3600*framez+VAL(MID$(a$,3,2))*60*framez+VAL(MID$(a$,5,2))*framez+VAL(MID$(a$,7,2))
ENDIF
UNTIL obj=rechelp& OR obj=recexit& OR ((obj=recok& OR tex=TRUE) AND LEN(a$)=8 AND tiframes<(24*60*60*framez))
IF tex=TRUE THEN
@timeinp2
hsec=tiframes
@htimeset3
@editfeld(timetxt&,ab$)
ENDIF
UNTIL obj=recexit& OR obj=recok& OR obj=rechelp&
IF obj=recexit& THEN
tiwert=otiwert
ENDIF
IF obj=recok& THEN
tiwert=tiframes/framez*100
ENDIF
RETURN
'
> PROCEDURE timeinp2
IF obj=tinpul1& AND tiframes<=(tifrmax-(3600*framez)) THEN
tiframes=tiframes+(3600*framez)
ENDIF
IF obj=tinpul2& AND tiframes<=(tifrmax-(60*framez)) THEN
tiframes=tiframes+(60*framez)
ENDIF
IF obj=tinpul3& AND tiframes<=(tifrmax-framez) THEN
tiframes=tiframes+framez
ENDIF
IF obj=tinpul4& AND tiframes<=(tifrmax-1) THEN
tiframes=tiframes+1
ENDIF
IF obj=tinpuh1& AND tiframes<=(tifrmax-(36000*framez)) THEN
tiframes=tiframes+(36000*framez)
ENDIF
IF obj=tinpuh2& AND tiframes<=(tifrmax-(600*framez)) THEN
tiframes=tiframes+(600*framez)
ENDIF
IF obj=tinpuh3& AND tiframes<=(tifrmax-(10*framez)) THEN
tiframes=tiframes+(10*framez)
ENDIF
IF obj=tinpuh4& AND tiframes<=(tifrmax-10) THEN
tiframes=tiframes+10
ENDIF
IF obj=tinpdl1& AND tiframes>=(3600*framez) THEN
tiframes=tiframes-(3600*framez)
ENDIF
IF obj=tinpdl2& AND tiframes>=(60*framez) THEN
tiframes=tiframes-(60*framez)
ENDIF
IF obj=tinpdl3& AND tiframes>=framez THEN
tiframes=tiframes-framez
ENDIF
IF obj=tinpdl4& AND tiframes>=1 THEN
tiframes=tiframes-1
ENDIF
IF obj=tinpdh1& AND tiframes>=(36000*framez) THEN
tiframes=tiframes-(36000*framez)
ENDIF
IF obj=tinpdh2& AND tiframes>=(600*framez) THEN
tiframes=tiframes-(600*framez)
ENDIF
IF obj=tinpdh3& AND tiframes>=(10*framez) THEN
tiframes=tiframes-(10*framez)
ENDIF
IF obj=tinpdh4& AND tiframes>=10 THEN
tiframes=tiframes-10
ENDIF
RETURN
'
> PROCEDURE minwrite
IF nr=smpedit& THEN
hsec=rtime
@htimeset
a$=LEFT$(a$,8)+CHR$(0)
@textfeld(mintext&,a$,1)
ENDIF
RETURN
'
> PROCEDURE smpkhlp
.| Glob. Var.: mrkp$,mp$,g#,sms#,sme#,loopz#,xm#,ce#,c2#,c1#,c#,xmp#
.|     virtual#,mcs#,meml#,mce#,memh#,vmem#,mcd#,noms#,xmo#,ncs#,nce#,a#
.|     lfw$,mlen#,workfile$,sblock#,b#,v#,seek#,bytes#,path$,smpnam$
.|     noblkdel#,makevirt3#,workf$,virtwfile#,mm#,virtln#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp,blocklook,maschinit10,maschruf10,maschinit11
.|     maschruf11,busy_mouse,rettmem,memtovirt2,nomem,virtcopy,restaura
.| Aufruf in : smpanf-1,smpend-1,smpl-1,smpr-1,edhandler2-1,
LOCAL makev
makev=FALSE
mrkp$=mp$
@alerts(14)
IF g=1 THEN
IF sms<>0 AND sms<=loopz THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND c2>c1 AND ((c<>0 AND xmp=-1) OR (c=0 AND xmp=0)) THEN
IF virtual=FALSE THEN
IF mcs>=meml AND mce+mbit<memh AND c=1 THEN     !vorwÑrts key
sms=1
loops%(1,1)=c2
loops%(1,2)=c2+(c2-c1)
IF loops%(1,2)>vmem THEN
makev=TRUE
ENDIF
IF makev=FALSE THEN
@maschruf10(mcs,mce,mce+mbit,memh)
ENDIF
ENDIF
IF mcs>=meml AND mce+mbit<memh AND c=2 THEN   ! ans Ende
sms=1
loops%(1,1)=vmem
loops%(1,2)=vmem+(c2-c1)
makev=TRUE
ENDIF
IF mcs>meml AND c=-1 THEN
mcd=mcs-(mce-mcs)
IF mcd<meml THEN
mcd=meml
mcs=mce-(mcs-meml)
ENDIF
@maschruf10(mcs,mce,mcd,mcs)
sms=1
loops%(1,2)=c1
loops%(1,1)=c1-(c2-c1)
IF loops%(1,1)<0 THEN
loops%(1,1)=c1
loops%(1,2)=c2
ENDIF
ENDIF
IF mcs>meml AND c=-2 THEN
noms=0
mcd=mcs-(mce-mcs)
IF mcd<meml THEN
noms=1
mcd=meml
mcs=mce-(mcs-meml)
ELSE
mcd=meml
ENDIF
@maschruf10(mcs,mce,mcd,mcs)
sms=1
loops%(1,2)=c2-c1
loops%(1,1)=0
IF noms=1 THEN
loops%(1,1)=c1
loops%(1,2)=c2
ENDIF
ENDIF
IF xmp=0 AND c=0 THEN
loops%(1,1)=INT((c1+xmo)/mbit)*mbit
loops%(1,2)=INT((c2+xmo)/mbit)*mbit
sms=1
IF loops%(1,1)<0 THEN
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
IF loops%(1,2)>vmem THEN         ! vor per Maus
makev=TRUE
ENDIF
IF makev=FALSE THEN
ncs=loops%(1,1)+meml
ncs=INT(ncs/mbit)*mbit
nce=loops%(1,2)+meml
nce=INT(nce/mbit)*mbit
IF ncs>=mce THEN
@maschruf10(mcs,mce,ncs,memh)
ENDIF
IF ncs<mcs THEN
@maschruf10(mcs,mce,ncs,mce)
ENDIF
IF ncs<mce AND ncs>mcs THEN
@maschruf11(mce,mcs,nce)
ENDIF
ENDIF
ENDIF
IF makev=TRUE THEN
a=ASC(LEFT$(lfw$,1))-64
IF @dfree(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF loops%(sms,1)>=0 AND loops%(sms,2)<=mlen AND sblock=1 THEN
a=loops%(sms,1)
b=loops%(sms,2)
ELSE
a=0
b=mlen
ENDIF
b=INT(b/mbit)*mbit
a=INT(a/mbit)*mbit
v=b-a
v=INT(v/mbit)*mbit
IF a>=0 AND b<=mlen THEN
@busy_mouse
BPUT #1,meml+a,v
ENDIF
IF loops%(1,1)>b THEN
seek=v
ELSE
seek=loops%(1,1)
ENDIF
SEEK #1,seek
c=INT((c2-c1)/mbit)*mbit
BPUT #1,meml+c1,c
bytes=LOF(#1)
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
@rettmem
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
IF c=1 THEN
IF virtwfile=FALSE THEN
loops%(1,1)=c2
loops%(1,2)=c2+(c2-c1)
ENDIF
@virtcopy(c1,c2,c2-c1)
ENDIF
IF c=-1 THEN
mm=c1-(c2-c1)
IF mm<0 THEN
mm=0
ENDIF
IF virtwfile=FALSE THEN
loops%(1,2)=c1
loops%(1,1)=c1-(c2-c1)
IF loops%(1,1)<0 THEN
loops%(1,1)=c1
loops%(1,2)=c2
ENDIF
ENDIF
@virtcopy(c1,mm,c2-c1)
ENDIF
IF c=-2 THEN
IF virtwfile=FALSE THEN
loops%(1,2)=c2-c1
loops%(1,1)=0
ENDIF
@virtcopy(c1,0,c2-c1)
ENDIF
IF c=2 THEN
IF virtwfile=FALSE THEN
loops%(1,1)=vmem-(c2-c1)
loops%(1,2)=vmem
ENDIF
@virtcopy(c1,virtln-(c2-c1),c2-c1)
ENDIF
IF xmp=0 AND c=0 THEN
xmo=INT(xmo/mbit)*mbit
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
@virtcopy(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
@restaura
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE movingmark
.| Glob. Var.: cm1#,c1#,xmo#,i#,loopz#,cm2#,sms#,sme#
.| Felder    : loops#(),loope#()
.| Ruft auf  : blocklook,selblkstxt,selblketxt
.| Aufruf in : smpmhlp-1,
@blocklook
IF cm1<=c1 THEN
xmo=c1-cm1
ELSE
xmo=cm1-c1
xmo=-xmo
ENDIF
FOR i=1 TO loopz
IF loops%(i,1)>=cm1 AND loops%(i,1)<=cm2 AND sms<>i THEN
loops%(i,1)=loops%(i,1)+xmo
@selblkstxt(sms2,CHR$(0))
ENDIF
NEXT i
FOR i=1 TO loopz
IF loops%(i,2)>=cm1 AND loops%(i,2)<=cm2 AND sms<>i THEN
loops%(i,2)=loops%(i,2)+xmo
@selblkstxt(sms2,CHR$(0))
ENDIF
NEXT i
RETURN
'
> PROCEDURE smpmhlp
.| Glob. Var.: moveart#,sms#,sme#,loopz#,cm1#,c1#,cm2#,c2#,sblock#,xm#,ce#
.|     virtual#,a#,lfw$,mlen#,workfile$,xmp#,mcs#,meml#,mce#,memh#,bytes#
.|     virtfile$,m#,mrkstax#,mrkeax#,xmo#,vmem#,ncs#,path$,smpnam$,noblkdel#
.|     makevirt3#,workf$,virt$,n#,g#,virtwfile#,virtln#,cached#
.| Felder    : loops#(),loope#()
.| Ruft auf  : movefrag,markhlp,blocklook,rettmem,maschinit9,maschruf9,nomem
.|     memtovirt2,virtmove,movingmark,restaura
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,edhandler2-1,
@movefrag
IF moveart>0 THEN
IF sms<>0 AND sms<=loopz THEN
@markhlp
@blocklook
cm1=c1
cm2=c2
IF sblock=1 THEN
IF xm>0 AND ce<>0 AND sms<>0 AND c2>c1 THEN
IF virtual=FALSE THEN
sms=1
IF moveart=3 THEN                       ! CLEAR/INS
a=ASC(LEFT$(lfw$,1))-64
IF @dfree(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF xmp=1 AND mcs>meml THEN          ! zum Anfang
BPUT #1,mcs,mce-mcs
@rettmem
@maschruf9(mcs,mce)
BPUT #1,meml,memh-meml
loops%(1,1)=0
loops%(1,2)=c2-c1
bytes=LOF(#1)
ENDIF
IF xmp=3 THEN                       ! ans Ende
IF @dfree(a)>(c2-c1) THEN
OPEN "O",#2,lfw$+virtfile$
BPUT #2,mcs,mce-mcs
CLOSE #2
@rettmem
@maschruf9(mcs,mce)
BPUT #1,meml,memh-meml
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
bytes=LOF(#1)
loops%(1,1)=mlen
loops%(1,2)=bytes
CLOSE #2
KILL lfw$+virtfile$
ELSE
@nomem
ENDIF
ENDIF
IF xmp=2 THEN                        ! zur Mitte
m=((memh-meml)/2)+meml-((mce-mcs)/2)
m=INT(m/mbit)*mbit
IF @dfree(a)>(c2-c1) THEN
OPEN "O",#2,lfw$+virtfile$
BPUT #2,mcs,mce-mcs
CLOSE #2
@rettmem
@maschruf9(mcs,mce)
BPUT #1,meml,m-meml
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
BPUT #1,m,memh-m
CLOSE #2
KILL lfw$+virtfile$
bytes=LOF(#1)
loops%(1,1)=m-meml
loops%(1,2)=(m-meml)+(c2-c1)
ELSE
@nomem
ENDIF
ENDIF
IF xmp=0 THEN                     ! Maus-move
mrkstax=loops%(1,1)
mrkeax=loops%(1,2)
loops%(1,1)=INT((c1+xmo)/mbit)*mbit
loops%(1,2)=INT((c2+xmo)/mbit)*mbit
IF loops%(1,1)<0 THEN
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
IF loops%(1,2)>vmem THEN
loops%(1,2)=INT(vmem/mbit)*mbit
loops%(1,1)=loops%(1,2)-(c2-c1)
ENDIF
ncs=loops%(1,1)+meml
ncs=INT(ncs/mbit)*mbit
IF @dfree(a)>(c2-c1) THEN
@rettmem
OPEN "O",#2,lfw$+virtfile$
BPUT #2,mcs,mce-mcs
CLOSE #2
@maschruf9(mcs,mce)
BPUT #1,meml,ncs-meml
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
BPUT #1,ncs,memh-ncs
CLOSE #2
KILL lfw$+virtfile$
bytes=LOF(#1)
ELSE
@nomem
ENDIF
ENDIF
loops%(1,1)=INT(loops%(1,1)/mbit)*mbit
loops%(1,2)=INT(loops%(1,2)/mbit)*mbit
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 OR moveart=1 OR moveart=2 THEN
IF xmp=1 AND mcs>meml THEN          ! zum Anfang
IF moveart=4 THEN
BMOVE mcs,meml,mce-mcs
IF mcs>meml+(mce-mcs) THEN
@maschruf9(mcs,mce)
ELSE
@maschruf9(meml+(mce-mcs),mce)
ENDIF
ENDIF
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF @dfree(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
IF moveart=2 THEN                            ! CUT/INS
BMOVE meml,meml+(mce-mcs),mlen-(mce-mcs)
ENDIF
OPEN "I",#1,virt$
BGET #1,meml,mce-mcs
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ENDIF
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
IF xmp=3 THEN                        ! ans Ende
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF @dfree(a)>(c2-c1) THEN
OPEN "O",#1,lfw$+virtfile$
BPUT #1,mcs,mce-mcs
CLOSE #1
IF moveart=1 THEN                ! CUT/COPY
BMOVE mce,mcs,memh-mce
OPEN "I",#1,lfw$+virtfile$
BGET #1,memh-(mce-mcs),mce-mcs
CLOSE #1
KILL lfw$+virtfile$
loops%(1,2)=(INT(vmem/mbit)*mbit)
loops%(1,1)=loops%(1,2)-(c2-c1)
ENDIF
IF moveart=2 THEN                ! CUT/INS
@rettmem
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
a=ASC(LEFT$(lfw$,1))-64
IF @dfree(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
BPUT #1,meml,mlen
OPEN "I",#2,lfw$+virtfile$
BGET #2,meml,mce-mcs
BPUT #1,meml,mce-mcs
CLOSE #2
KILL lfw$+virtfile$
bytes=LOF(#1)
loops%(1,1)=mlen
loops%(1,2)=bytes
loops%(1,1)=INT(loops%(1,1)/mbit)*mbit
loops%(1,2)=INT(loops%(1,2)/mbit)*mbit
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 THEN            ! CLEAR/COPY
IF mce<memh-(mce-mcs) THEN
BMOVE mcs,memh-(mce-mcs),mce-mcs
@maschruf9(mcs,mce)
loops%(1,2)=(INT(vmem/mbit)*mbit)
loops%(1,1)=loops%(1,2)-(c2-c1)
ELSE
BMOVE mcs,memh-(mce-mcs),mce-mcs
@maschruf9(mcs,memh-(mce-mcs))
loops%(1,2)=INT(vmem/mbit)*mbit
loops%(1,1)=loops%(1,2)-(c2-c1)
ENDIF
ENDIF
ENDIF
IF xmp=2 THEN                        ! zur Mitte
m=((memh-meml)/2)+meml-((mce-mcs)/2)
m=INT(m/mbit)*mbit
IF moveart=1 OR moveart=2 THEN
a=ASC(LEFT$(lfw$,1))-64
IF @dfree(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
IF moveart=2 THEN                            ! CUT/INS
BMOVE m,m+(mce-mcs),memh-m-(mce-mcs)
ENDIF
OPEN "I",#1,virt$
BGET #1,m,mce-mcs
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ENDIF
IF moveart=4 THEN
IF mcs>=m+(mce-mcs) OR mce<m THEN
BMOVE mcs,m,mce-mcs
@maschruf9(mcs,mce)
ENDIF
IF mcs<m+(mce-mcs) AND mcs>=m AND mce>m+(mce-mcs) THEN
BMOVE mcs,m,mce-mcs
@maschruf9(m+(mce-mcs),mce)
ENDIF
IF mcs<m AND mce>=m AND mce<m+(mce-mcs) THEN
BMOVE mcs,m,mce-mcs
@maschruf9(mcs,m-1)
ENDIF
ENDIF
n=INT((c2-c1)/2)
loops%(1,1)=INT((vmem/2-n)/mbit)*mbit
loops%(1,2)=loops%(1,1)+(c2-c1)
ENDIF
IF xmp=0 THEN                     ! Maus-move
mrkstax=loops%(1,1)
mrkeax=loops%(1,2)
loops%(1,1)=INT((c1+xmo)/mbit)*mbit
loops%(1,2)=INT((c2+xmo)/mbit)*mbit
IF loops%(1,1)<0 THEN
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
IF loops%(1,2)>vmem THEN
loops%(1,2)=INT(vmem/mbit)*mbit
loops%(1,1)=loops%(1,2)-(c2-c1)
ENDIF
ncs=loops%(1,1)+meml
ncs=INT(ncs/mbit)*mbit
IF moveart=1 OR moveart=2 THEN
IF ncs<mcs OR ncs>mce THEN
a=ASC(LEFT$(lfw$,1))-64
IF @dfree(a)>(c2-c1) THEN
OPEN "O",#1,virt$
BPUT #1,mcs,mce-mcs
CLOSE #1
BMOVE mce,mcs,memh-mce
@maschruf9(memh-(mce-mcs),memh)
OPEN "I",#1,virt$
IF mce<=ncs THEN
IF moveart=2 THEN                            ! CUT/INS
BMOVE ncs-(mce-mcs),ncs,memh-ncs
ENDIF
BGET #1,ncs-(mce-mcs),mce-mcs
loops%(1,1)=loops%(1,1)-(mce-mcs)
loops%(1,1)=INT(loops%(1,1)/mbit)*mbit
loops%(1,2)=loops%(1,2)-(mce-mcs)
loops%(1,2)=INT(loops%(1,2)/mbit)*mbit
ELSE
IF moveart=2 THEN                            ! CUT/INS
BMOVE ncs,ncs+(mce-mcs),memh-ncs-(mce-mcs)
ENDIF
BGET #1,ncs,mce-mcs
ENDIF
CLOSE #1
KILL virt$
ELSE
@nomem
ENDIF
ELSE
loops%(1,1)=mrkstax
loops%(1,2)=mrkeax
@alerts(15)
@restaura
ENDIF
ENDIF
IF moveart=4 THEN
BMOVE mcs,ncs,mce-mcs
IF mcs>=ncs+(mce-mcs) OR mce<ncs THEN
@maschruf9(mcs,mce)
ENDIF
IF mcs<ncs+(mce-mcs) AND mcs>=ncs AND mce>ncs+(mce-mcs) THEN
@maschruf9(ncs+(mce-mcs),mce)
ENDIF
IF mcs<ncs AND mce>=ncs AND mce<ncs+(mce-mcs) THEN
@maschruf9(mcs,ncs-1)
ENDIF
ENDIF
ENDIF
ENDIF
ELSE
IF moveart>0 THEN
IF xmp=1 AND mcs>meml THEN        ! an Anfang
IF virtwfile=FALSE THEN
loops%(1,2)=c2-c1
loops%(1,1)=0
ENDIF
@virtmove(c1,0,c2-c1)
ENDIF
IF xmp=2 THEN                     ! zur Mitte
n=INT((c2-c1)/2)
n=INT((vmem/2-n)/mbit)*mbit
IF virtwfile=FALSE THEN
loops%(1,1)=n
loops%(1,2)=loops%(1,1)+(c2-c1)
ENDIF
@virtmove(c1,n,c2-c1)
ENDIF
IF xmp=3 THEN                     ! ans Ende
IF virtwfile=FALSE THEN
IF moveart=4 OR moveart=1 THEN
loops%(1,1)=vmem-(c2-c1)
loops%(1,2)=vmem
ELSE
loops%(1,1)=vmem
loops%(1,2)=vmem+(c2-c1)
ENDIF
ENDIF
IF moveart=4 OR moveart=1 THEN
@virtmove(c1,virtln-(c2-c1),c2-c1)
ELSE
@virtmove(c1,virtln,c2-c1)
ENDIF
ENDIF
IF xmp=0 THEN             ! Maus-move
xmo=INT(xmo/mbit)*mbit
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
@virtmove(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
ENDIF
cached=FALSE
@movingmark
@restaura
ENDIF
ELSE
@alerts(16)
@restaura
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE smpihlp                     ! Routine fÅr mem fehlt noch
.| Glob. Var.: mrkp$,mp$,g#,sms#,sme#,loopz#,xm#,ce#,c2#,c1#,virtual#
.|     sblock#,xmp#,xmo#,mlen#,m#,vmem#,ncs#,meml#,a#,lfw$,workfile$,cached#
.|     b#,bytes#,path$,smpnam$,noblkdel#,makevirt3#,workf$,virtwfile#
.|     virtln#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp,blocklook,busy_mouse,nomem,rettmem,memtovirt2,virtins
.|     restaura
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,edhandler2-1,
LOCAL makev
mrkp$=mp$
makev=FALSE
@alerts(17)
IF g=1 THEN
IF sms<>0 AND sms<=loopz THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND c2>c1 THEN
IF virtual=FALSE THEN
IF sblock=1 THEN
IF xmp=1 THEN
xmo=-c1
ENDIF
IF xmp=3 THEN
xmo=mlen-c2
ENDIF
IF xmp=2 THEN
m=mlen/2
m=INT(m/mbit)*mbit
xmo=m-c1
ENDIF
IF loops%(sms,1)>=0 AND loops%(sms,2)<=mlen THEN
sms=1
IF mlen>=(c2+xmo) AND (c1+xmo)>=0 THEN
xmo=INT(xmo/mbit)*mbit
IF ((c1+xmo)<=loops%(sms,2) AND (loops%(sms,2)+(c2-c1))<=mlen) OR ((c1+xmo)>loops%(sms,2) AND (c1+xmo+(c2-c1))<=mlen) THEN
loops%(1,1)=INT((c1+xmo)/mbit)*mbit
loops%(1,2)=INT((c2+xmo)/mbit)*mbit
IF loops%(1,1)<0 THEN
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
IF loops%(1,2)>vmem THEN
loops%(1,2)=INT(vmem/mbit)*mbit
loops%(1,1)=loops%(1,2)-(c2-c1)
ENDIF
ncs=loops%(1,1)+meml
ncs=INT(ncs/mbit)*mbit
a=ASC(LEFT$(lfw$,1))-64
IF @dfree(a)>=(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
@busy_mouse
BPUT #1,c1+meml,c2-c1
CLOSE #1
IF ((c1+xmo)<=loops%(sms,2) AND (loops%(sms,2)+(c2-c1))<=mlen) THEN
BMOVE ncs,ncs+(c2-c1),loops%(sms,2)-loops%(1,1)
loops%(sms,2)=loops%(sms,2)+(c2-c1)
ENDIF
OPEN "I",#1,lfw$+workfile$
@busy_mouse
BGET #1,ncs,c2-c1
CLOSE #1
KILL lfw$+workfile$
cached=FALSE
ELSE
@nomem
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
makev=TRUE
ENDIF
ELSE
@alerts(16)
@restaura
ENDIF
IF makev=TRUE THEN
a=ASC(LEFT$(lfw$,1))-64
IF @dfree(a)>mlen+(c2-c1) THEN
OPEN "O",#1,lfw$+workfile$
IF loops%(sms,1)>=0 AND loops%(sms,2)<=mlen AND sblock=1 THEN
a=loops%(sms,1)
b=loops%(sms,2)
ELSE
a=0
b=mlen
ENDIF
IF a>=0 AND b<=mlen THEN
IF (c1+xmo)<a THEN
@busy_mouse
BPUT #1,meml+c1,c2-c1
BPUT #1,meml+a,b-a
ENDIF
IF (c1+xmo)>=a AND (c1+xmo)<=b THEN
@busy_mouse
BPUT #1,meml+a,(c1+xmo)-a
BPUT #1,meml+c1,c2-c1
IF (c1+xmo)<b THEN
BPUT #1,meml+c1+xmo,b-(c1+xmo)
ENDIF
ENDIF
IF (c1+xmo)>b THEN
@busy_mouse
BPUT #1,meml,b-a
BPUT #1,meml+c1,c2-c1
ENDIF
ENDIF
bytes=LOF(#1)
CLOSE #1
virtual=TRUE
path$=lfw$+workfile$
smpnam$=workfile$
vmem=bytes
noblkdel=TRUE
@rettmem
makevirt3=TRUE
workf$=lfw$+workfile$
@memtovirt2
noblkdel=FALSE
ELSE
@nomem
ENDIF
ENDIF
ELSE
IF xmp=1 THEN
IF virtwfile=FALSE THEN
loops%(1,1)=0
loops%(1,2)=c2-c1
ENDIF
@virtins(c1,0,c2-c1)
ENDIF
IF xmp=2 THEN
m=(virtln/2)
m=INT(m/mbit)*mbit
IF virtwfile=FALSE THEN
loops%(1,1)=m
loops%(1,2)=m+(c2-c1)
ENDIF
@virtins(c1,m,c2-c1)
ENDIF
IF xmp=3 THEN
IF virtwfile=FALSE THEN
loops%(1,1)=virtln
loops%(1,2)=virtln+(c2-c1)
ENDIF
@virtins(c1,virtln,c2-c1)
ENDIF
IF xmp=0 THEN
xmo=INT(xmo/mbit)*mbit
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
@virtins(c1,c1+xmo,c2-c1)
ENDIF
ENDIF
@restaura
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@restaura
ENDIF
RETURN
'
> PROCEDURE marktextsel(i)
SELECT i
CASE 1
t$="S"
CASE 2
t$="E"
CASE 3
t$="I"
CASE 4
t$="R"
ENDSELECT
RETURN
'
> PROCEDURE markprod2
LOCAL i
IF markmode=2 THEN
i=1
@selblkshak(sms2,0)     ! Marker abwÑhlen
sms2=i
@selblkshak(sms2,1)     ! Marker auswÑhlen
@marktextsel(i)
@markhlp6(loops%(sms,i))
@markhlp3(sms,i,loops%(sms,i))
i=2
@selblkshak(sms2,0)     ! Marker abwÑhlen
sms2=i
@selblkshak(sms2,1)     ! Marker auswÑhlen
@marktextsel(i)
a=loops%(sms,i)
@markhandler(a)
IF a<>loops%(sms,i) THEN
@selblkshak(sms2,0)     ! Marker abwÑhlen
sms2=i
loops%(sms,i)=a
@selblkshak(sms2,1)     ! Marker auswÑhlen
@markhlp3(sms,sms2,loops%(sms,i))
ENDIF
ELSE
FOR i=1 TO 4
IF loops%(sms,i)<>-1 THEN
@marktextsel(i)
a=loops%(sms,i)
@markhandler(a)
IF a<>loops%(sms,i) THEN
@selblkshak(sms2,0)     ! Marker abwÑhlen
sms2=i
loops%(sms,i)=a
@selblkshak(sms2,1)     ! Marker auswÑhlen
@markhlp3(sms,sms2,loops%(sms,i))
ENDIF
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE markprod3
.| Aufruf in : message-2,restaura4-1,smpedit-1,time_edit-1,record2-1,
IF nr=smpedit& THEN
IF sms>0 AND sms<=loopz THEN
@edmarkset(sms)
ENDIF
ENDIF
RETURN
'
> PROCEDURE markprod3b
IF nr=smpedit& THEN
IF sms>0 AND sms<=loopz THEN
@edslidemove(sms)
ENDIF
ENDIF
RETURN
'
> PROCEDURE tplaymark
IF tplaystart<>-1 THEN
hsec=INT(tplaystart/thz*100)
@htimeset
@textfeld(tpstrt&,a$,1)
IF bigfoot=FALSE THEN
t$="s"
ELSE
t$="S"
ENDIF
@pmarkhlp(tplaystart)
ENDIF
IF tplayend<>-1 THEN
hsec=INT(tplayend/thz*100)
@htimeset
@textfeld(tpend&,a$,1)
IF bigfoot=FALSE THEN
t$="e"
ELSE
t$="E"
ENDIF
@pmarkhlp(tplayend)
ENDIF
RETURN
'
> PROCEDURE pmarkhlp(bx)
LOCAL cx,bs,be,by1,by2,pxm
IF bx<>-1 THEN
@markhlp
by1=yd+33
by2=yd+33+4*(trhb+trhd)
IF bigfoot=TRUE THEN
by1=by1+12
by2=by2+12+16
ENDIF
bs=toffs2/1000*thz
be=(toffs2+toffs3)/1000*thz
pxm=dig-1
txax=dix+1
IF bigfoot=TRUE THEN
pxm=pxm-1
ENDIF
txay=12
IF bigfoot=TRUE THEN
txay=8
ENDIF
IF bx>=bs AND bx<=be AND bx<>-1 THEN
cx=bx-bs
cx=cx/(be-bs)*pxm
cx=cx+txax
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE cx+xd,by1-txay+2,cx+xd,by2
IF bigfoot=FALSE THEN
DEFTEXT 1,0,0,4
ELSE
DEFTEXT 1,0,0,11
ENDIF
TEXT cx+xd-2,by1-txay,t$
DEFTEXT 1,0,0,4
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
RETURN
'
> PROCEDURE pmarkhlp2
IF tplaystart<>-1 THEN
IF bigfoot=FALSE THEN
t$="s"
ELSE
t$="S"
ENDIF
a=tplaystart
@pmarkhandler(tpstrt&,a)
tplaystart=a
hsec=INT(tplaystart/thz*100)
@htimeset
@textfeld(tpstrt&,a$,1)
ENDIF
IF tplayend<>-1 THEN
IF bigfoot=FALSE THEN
t$="e"
ELSE
t$="E"
ENDIF
a=tplayend
@pmarkhandler(tpend&,a)
tplayend=a
hsec=INT(tplayend/thz*100)
@htimeset
@textfeld(tpend&,a$,1)
ENDIF
RETURN
'
> PROCEDURE pmarkdel(bx)
LOCAL cx,bs,be,by1,by2,pxm,uu
IF bx<>-1 THEN
@markhlp
by1=yd+33
by2=yd+33+4*(trhb+trhd)
IF bigfoot=TRUE THEN
by1=by1+12
by2=by2+12+16
ENDIF
bs=toffs2/1000*thz
be=(toffs2+toffs3)/1000*thz
pxm=dig-1
txax=dix+1
IF bigfoot=TRUE THEN
pxm=pxm-1
ENDIF
txay=12
IF bigfoot=TRUE THEN
txay=8
ENDIF
IF bx>=bs AND bx<=be AND bx<>-1 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
cx=bx-bs
cx=cx/(be-bs)*pxm
cx=cx+txax
~GRAF_MOUSE(256,0)                              ! Hidem
IF maxcol=2 OR dreidim=0 THEN
COLOR 0
ELSE
COLOR smpwcol
ENDIF
GRAPHMODE 1
IF bigfoot=FALSE THEN
uu=4
ELSE
uu=10
ENDIF
FOR i=cx+xd-4 TO cx+xd+3
LINE i,by1-txay+1,i,by1-txay-uu
NEXT i
COLOR 1
GRAPHMODE 3
LINE cx+xd,by1-txay+2,cx+xd,by2
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE pmarkhandler(po,VAR tx)
LOCAL cx,bs,be,by1,by2,pxm,uu
LOCAL ux,i,vtx
by1=yd+33
by2=yd+33+4*(trhb+trhd)
IF bigfoot=TRUE THEN
by1=by1+12
by2=by2+12+16
ENDIF
bs=toffs2/1000*thz
be=(toffs2+toffs3)/1000*thz
pxm=dig-1
txax=dix+1
IF bigfoot=TRUE THEN
pxm=pxm-1
ENDIF
txay=12
IF bigfoot=TRUE THEN
txay=8
ENDIF
'
cx=bx-bs
cx=cx/(be-bs)*pxm
cx=cx+dix
'
vtx=tx
@mouse(x,y,k)
IF vtx>=bs AND vtx<=be AND (be-bs)>0 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
ux=vtx-bs
ux=INT(ux/(be-bs)*pxm)
IF x>ux+xd+txax-2 AND x<ux+xd+txax+2 AND y>=by1-txay-2 AND y<=by2 THEN
k=@mousek
~GRAF_MOUSE(256,0)                              ! Hidem
IF k=1 THEN
IF maxcol=2 OR dreidim=0 THEN
COLOR 0
ELSE
COLOR smpwcol
ENDIF
GRAPHMODE 1
IF bigfoot=FALSE THEN
uu=4
ELSE
uu=10
ENDIF
FOR i=x-4 TO x+3
LINE i,by1-txay+1,i,by1-txay-uu
NEXT i
drawnew=TRUE
GRAPHMODE 3
f=0
x3=-1
REPEAT
@mouse(x2,v2,k)
'
IF x2>=xd+txax AND x2<=(pxm+xd+txax) AND be>bs AND v2>=by1-txay-2 AND v2<=by2 THEN
pshowdat=INT((be-bs)/pxm*(x2-xd-txax))+bs
IF pshowbdat<>pshowdat THEN
pshowbdat=pshowdat
hsec=INT(pshowdat/thz*100)
@htimeset
@textfeld(po,a$,1)
ENDIF
ENDIF
'
IF x<>x2 THEN
INC f
ENDIF
x=x2
IF x>=xd+txax AND x<=pxm+xd+txax AND y>=by1-txay-2 AND y<=by2 AND x<>ux+xd+txax AND x3<>x THEN
GRAPHMODE 3
COLOR 0
LINE ux+xd+txax,by1-txay+2,ux+xd+txax,by2
COLOR 1
vtx=INT((be-bs)/pxm*(x-xd-txax)+bs)
ux=vtx-bs
ux=INT(ux/(be-bs)*pxm)
x3=x
LINE ux+xd+txax,by1-txay+2,ux+xd+txax,by2
GRAPHMODE 3
drawnew=TRUE
ENDIF
UNTIL k=0
IF zsnap=TRUE AND shit=TRUE THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4<>0 THEN
@springart(vtx)
IF back%>=cs AND back%<=ce THEN
vtx=back%
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
GRAPHMODE 3
COLOR 0
LINE ux+xd,stay1+1,ux+xd,stay2
COLOR 1
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
x3=x
LINE ux+xd,stay1+1,ux+xd,stay2
GRAPHMODE 3
drawnew=TRUE
ENDIF
ENDIF
tx=vtx
COLOR 1
GRAPHMODE 3
IF bigfoot=FALSE THEN
DEFTEXT 1,0,0,4
ELSE
DEFTEXT 1,0,0,11
ENDIF
TEXT ux+xd+txax-2,by1-txay,t$
DEFTEXT 1,0,0,4
drawnew=TRUE
@gettrak
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
GRAPHMODE 1
obj=0
RETURN
'
> PROCEDURE killpmark
@pmarkdel(tplaystart)
@pmarkdel(tplayend)
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(tpstrt&,a$,1)
@textfeld(tpend&,a$,1)
tplaystart=-1
tplayend=-1
RETURN
'
> PROCEDURE killpmark2
@ptextdel(tplaystart)
@ptextdel(tplayend)
RETURN
'
> PROCEDURE ptextdel(bx)
LOCAL cx,bs,be,by1,by2,pxm,uu,uuy
IF bx<>-1 THEN
@markhlp
by1=yd+33
by2=yd+33+4*(trhb+trhd)
IF bigfoot=TRUE THEN
by1=by1+12
by2=by2+12+16
ENDIF
bs=toffs2/1000*thz
be=(toffs2+toffs3)/1000*thz
pxm=dig-1
txax=dix+1
IF bigfoot=TRUE THEN
pxm=pxm-1
ENDIF
txay=12
IF bigfoot=TRUE THEN
txay=8
ENDIF
IF bx>=bs AND bx<=be AND bx<>-1 THEN
cx=bx-bs
cx=cx/(be-bs)*pxm
cx=cx+txax
~GRAF_MOUSE(256,0)                              ! Hidem
IF maxcol=2 OR dreidim=0 THEN
COLOR 0
ELSE
COLOR smpwcol
ENDIF
GRAPHMODE 1
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
IF bigfoot=FALSE THEN
uu=4
uuy=12
ELSE
uu=10
uuy=22
ENDIF
FOR i=cx+xd-4 TO cx+xd+3
LINE i,by1-txay+uuy,i,by1-txay-uu
NEXT i
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
COLOR 1
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
RETURN
'
> PROCEDURE testsrate
tstsr=FALSE
IF hzm=8000 THEN
tstsr=TRUE
ENDIF
IF hzm=11025 THEN
tstsr=TRUE
ENDIF
IF hzm=12000 THEN
tstsr=TRUE
ENDIF
IF hzm=16000 THEN
tstsr=TRUE
ENDIF
IF hzm=16538 THEN
tstsr=TRUE
ENDIF
IF hzm=22050 THEN
tstsr=TRUE
ENDIF
IF hzm=24000 THEN
tstsr=TRUE
ENDIF
IF hzm=33075 THEN
tstsr=TRUE
ENDIF
IF hzm=32000 THEN
tstsr=TRUE
ENDIF
IF hzm=44100 THEN
tstsr=TRUE
ENDIF
IF hzm=48000 THEN
tstsr=TRUE
ENDIF
IF hzm=INT(masterclk/768) THEN
tstsr=TRUE
ENDIF
IF hzm=INT(masterclk/512) THEN
tstsr=TRUE
ENDIF
IF hzm=INT(masterclk/384) THEN
tstsr=TRUE
ENDIF
IF hzm=INT(masterclk/256) THEN
tstsr=TRUE
ENDIF
IF hzm=768 THEN
tstsr=TRUE
ENDIF
IF hzm=512 THEN
tstsr=TRUE
ENDIF
IF hzm=384 THEN
tstsr=TRUE
ENDIF
IF hzm=256 THEN
tstsr=TRUE
ENDIF
IF ext=768 THEN
tstsr=TRUE
ENDIF
IF ext=512 THEN
tstsr=TRUE
ENDIF
IF ext=384 THEN
tstsr=TRUE
ENDIF
IF ext=256 THEN
tstsr=TRUE
ENDIF
IF ext>0 THEN
tstsr=TRUE
ENDIF
RETURN
'
> PROCEDURE hztext
LOCAL j
IF nr=smpedit& THEN
IF sms>0 THEN
FOR j=1 TO 4
IF loops%(sms,j)<>-1 THEN
@markhlp3(sms,j,loops%(sms,j))
ENDIF
NEXT j
ENDIF
@markhlp3(9998,0,cs)
@markhlp3(9999,0,ce)
ENDIF
RETURN
'
> PROCEDURE smph2
.| Glob. Var.: master#,loopz#,t$,a#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhandl2,markhlp3
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
@marktextsel(sms2)
a=loops%(sms,sms2)
@markhandl2(a)
loops%(sms,sms2)=a
@markhlp3(sms,sms2,loops%(sms,sms2))
ENDIF
RETURN
'
> PROCEDURE smpanf
.| Glob. Var.: smark#,xmo#,xmp#,c#,x#,lzhold#,lz#,smpanf&
.| Ruft auf  : smpmhlp,smpihlp,smpkhlp,smph1,smph2,zoomhelp,setbutton
.|     flipptest
.| Aufruf in : do_smpedit-1,
IF smark=6 THEN
xmo=0
xmp=1
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=0
xmp=1
@smpihlp
ENDIF
IF smark=5 THEN
c=-2
@smpkhlp
ENDIF
IF smark=3 THEN
@smph1
x=0
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=1
@zoomhelp
ENDIF
@setbutton(smpanf&,0)
@flipptest
RETURN
'
> PROCEDURE smpend
.| Glob. Var.: smark#,xmp#,xmo#,xm#,c#,x#,vmem#,lzhold#,lz#,lzmrk#,smpend&
.| Ruft auf  : smpmhlp,smpihlp,smpkhlp,smph1,smph2,zoomhelp,setbutton
.|     flipptest
.| Aufruf in : do_smpedit-1,
IF smark=6 THEN
xmp=3
xmo=xm
@smpmhlp
ENDIF
IF smark=4 THEN
xmp=3
xmo=xm
@smpihlp
ENDIF
IF smark=5 THEN
c=2
@smpkhlp
ENDIF
IF smark=3 THEN
@smph1
x=vmem
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=lzmrk
@zoomhelp
ENDIF
@setbutton(smpend&,0)
@flipptest
RETURN
'
> PROCEDURE smpmid
.| Glob. Var.: smark#,xmo#,xm#,xmp#,x#,vmem#,lzhold#,lz#,lzmrk#,smpmid&
.| Ruft auf  : smpmhlp,smpihlp,smph1,smph2,zoomhelp,setbutton,flipptest
.| Aufruf in : do_smpedit-1,
IF smark=6 THEN
xmo=xm/2
xmp=2
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=xm/2
xmp=2
@smpihlp
ENDIF
IF smark=3 THEN
@smph1
x=INT(vmem/2)
@smph2
ENDIF
IF smark=2 THEN
lzhold=lz
lz=INT(lzmrk/2)
IF lz=0 THEN
lz=1
ENDIF
@zoomhelp
ENDIF
@setbutton(smpmid&,0)
@flipptest
RETURN
'
> PROCEDURE zoomhelp
.| Glob. Var.: lz#,cs#,ce#,zoomstop#,lzhold#,xm#,cached#
.| Felder    : lce#(),lcs#()
.| Ruft auf  : curvetest,markhlp,zslidecalc,restaura
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,
IF lce(lz)>0 THEN
cs=lcs(lz)
ce=lce(lz)
ENDIF
@curvetest(cs,ce)
IF zoomstop=FALSE THEN
@markhlp
ELSE
lz=lzhold
ENDIF
IF xm>0 AND ce>cs THEN
@zslidecalc
cached=FALSE
@restaura
ENDIF
RETURN
'
> PROCEDURE smpl
.| Glob. Var.: c#,smark#,xmp#,obj#,smpl1&,smpl2&,smpl3&,xmo#,c2#,c1#,ce#,cs#
.|     xm#,x#,lz#,xs#,v#,v2#,v3#,v4#,lzhold#,memh#,cached#,u#,fadericht#
.| Ruft auf  : markhlp,blocklook,smpmhlp,smpihlp,smpkhlp,smph1,smph2
.|     zoomhelp,zslidecalc,restaura,fade_it,flipptest
.| Aufruf in : do_smpedit-1,
LOCAL mf
@markhlp
c=0
IF smark=6 OR smark=4 THEN
xmp=0
@blocklook
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
IF obj=smpl1& THEN
xmo=INT((c2-c1)/(mbit*4))*mbit
xmo=-xmo
ENDIF
IF obj=smpl2& THEN
xmo=INT((c2-c1)/(mbit*2))*mbit
xmo=-xmo
ENDIF
IF obj=smpl3& THEN
xmo=INT((c2-c1)/mbit)*mbit
xmo=-xmo
ENDIF
IF smark=6 THEN
@smpmhlp
ELSE
@smpihlp
ENDIF
ENDIF
ENDIF
IF smark=5 THEN
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
c=-1
@smpkhlp
ENDIF
ENDIF
IF smark=3 THEN
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
@smph1
mf=INT((ce-cs)/xm/mbit)*mbit
IF obj=smpl1& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x-1*mf
ELSE
x=x-mbit
ENDIF
ENDIF
IF obj=smpl2& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x-3*mf
ELSE
x=x-3*mbit
ENDIF
ENDIF
IF obj=smpl3& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x-10*mf
ELSE
x=x-10*mbit
ENDIF
ENDIF
@smph2
ENDIF
ENDIF
IF smark=2 THEN
IF lz>1 THEN
@smph1
IF obj=smpl1& THEN
xs=1
ENDIF
IF obj=smpl2& THEN
xs=2
ENDIF
IF obj=smpl3& THEN
xs=3
ENDIF
IF lz>xs AND (obj=smpl1& OR obj=smpl2& OR obj=smpl3&) THEN
~WIND_UPDATE(3)
~GRAF_MKSTATE(v,v2,v3,v4)
~WIND_UPDATE(2)
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& AND v4=0 THEN
lzhold=lz
lz=lz-xs
@zoomhelp
ENDIF
IF obj=smpl1& AND v4<>0 THEN
ce=((ce-cs)*1.5)+cs
IF ce>memh THEN
ce=memh
ENDIF
ce=INT(ce/mbit)*mbit
IF xm>0 AND ce>cs THEN
@zslidecalc
@scrollinit
@setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
mrscroll=scrollp
cached=FALSE
@restaura
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF smark=1 THEN
IF obj=smpl1& THEN
xs=(ce-cs)/4
ENDIF
IF obj=smpl2& THEN
xs=(ce-cs)/2
ENDIF
IF obj=smpl3& THEN
xs=ce-cs
ENDIF
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
IF cs-xs>0 THEN
cs=cs-xs
cs=INT(cs/mbit)*mbit
ce=ce-xs
ce=INT(ce/mbit)*mbit
ELSE
u=cs
cs=0
ce=ce-u
ce=INT(ce/mbit)*mbit
ENDIF
cached=FALSE
@restaura
ENDIF
ENDIF
IF smark=8 THEN
fadericht=0
@fade_it
ENDIF
@flipptest
RETURN
'
> PROCEDURE smpr
.| Glob. Var.: c#,smark#,xmp#,obj#,smpr1&,smpr2&,smpr3&,xmo#,c2#,c1#,ce#,cs#
.|     xm#,x#,lz#,lmax#,xs#,xmul#,zoomstop#,i#,loopz#,sms#,dcs#,sme#,dce#
.|     lzmrk#,cached#,g#,vmem#,u#,fadericht#
.| Felder    : lcs#(),lce#(),loops#(),loope#()
.| Ruft auf  : markhlp,blocklook,smpmhlp,smpihlp,smpkhlp,smph1,smph2
.|     curvetest,zslidecalc,restaura,fade_it,flipptest
.| Aufruf in : do_smpedit-1,
LOCAL mf
@markhlp
c=0
IF smark=6 OR smark=4 THEN
xmp=0
@blocklook
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
IF obj=smpr1& THEN
xmo=INT((c2-c1)/(mbit*4))*mbit
ENDIF
IF obj=smpr2& THEN
xmo=INT((c2-c1)/(mbit*2))*mbit
ENDIF
IF obj=smpr3& THEN
xmo=INT((c2-c1)/mbit)*mbit
ENDIF
IF smark=6 THEN
@smpmhlp
ELSE
@smpihlp
ENDIF
ENDIF
ENDIF
IF smark=5 THEN
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
c=1
@smpkhlp
ENDIF
ENDIF
IF smark=3 THEN
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@smph1
mf=INT((ce-cs)/xm/mbit)*mbit
IF obj=smpr1& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x+1*mf
ELSE
x=x+mbit
ENDIF
ENDIF
IF obj=smpr2& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x+3*mf
ELSE
x=x+3*mbit
ENDIF
ENDIF
IF obj=smpr3& THEN
IF ((ce-cs)/mbit)>xm THEN
x=x+10*mf
ELSE
x=x+10*mbit
ENDIF
ENDIF
@smph2
ENDIF
ENDIF
IF smark=2 THEN
IF lz<lmax THEN
@smph1
IF obj=smpr1& THEN
xs=1
xmul=1.5
ENDIF
IF obj=smpr2& THEN
xs=1
xmul=2
ENDIF
IF obj=smpr3& THEN
xs=1
xmul=3
ENDIF
IF (lz+xs)<lmax AND (obj=smpr1& OR obj=smpr2& OR obj=smpr3&) THEN
@curvetest(cs,ce)
IF zoomstop=FALSE THEN
lcs(lz)=cs
lce(lz)=ce
@markhlp
dcs=loops%(sms,1)
dce=loops%(sms,2)
IF sms=0 THEN
dcs=0
dce=INT(ce-cs)
ENDIF
lz=lz+xs
lzmrk=lz
IF dcs=cs AND dce=ce THEN     ! war IF dce>=ce THEN, der Block sollte aber nur um xmul verkleinert werden,wenn die Marker gleich sind
ce=INT(((ce-cs)/xmul)+cs)   ! wenn gleiche Marker wie vorher,dann ein StÅck nÑher zoomen
ELSE
ce=dce                      ! sonst normal auf Markergrenzen zoomen
ENDIF
cs=dcs
ce=INT(ce/mbit)*mbit
lcs(lz)=cs
lce(lz)=ce
IF xm>0 AND ce>cs THEN
@zslidecalc
@scrollinit
@setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
mrscroll=scrollp
cached=FALSE
@restaura
ENDIF
ELSE
@alerts(18)
ENDIF
ENDIF
ENDIF
ENDIF
IF smark=1 THEN
IF obj=smpr1& THEN
xs=(ce-cs)/4
ENDIF
IF obj=smpr2& THEN
xs=(ce-cs)/2
ENDIF
IF obj=smpr3& THEN
xs=ce-cs
ENDIF
IF ce+xs<vmem THEN
cs=cs+xs
cs=INT(cs/mbit)*mbit
ce=ce+xs
ce=INT(ce/mbit)*mbit
ELSE
u=vmem-ce
cs=cs+u
cs=INT(cs/mbit)*mbit
ce=ce+u
ce=INT(ce/mbit)*mbit
ENDIF
cached=FALSE
@restaura
ENDIF
IF smark=8 THEN
fadericht=1
@fade_it
ENDIF
@flipptest
RETURN
'
> PROCEDURE movemark(strtmark,mdif)
.| Glob. Var.: i#,loopz#
.| Felder    : loops#(),loope#()
.| Aufruf in : smpcut-1,
FOR i=1 TO loopz
IF (loops%(i,1)>(strtmark-mdif) AND mdif<0) OR (loops%(i,1)<strtmark AND mdif>0) THEN
loops%(i,1)=loops%(i,1)+mdif
ENDIF
NEXT i
FOR i=1 TO loopz
IF (loops%(i,2)>(strtmark-mdif) AND mdif<0) OR (loops%(i,2)<strtmark AND mdif>0) THEN
loops%(i,2)=loops%(i,2)+mdif
ENDIF
NEXT i
RETURN
'
> PROCEDURE blkfunc
.| Glob. Var.: winh#,blkfunc&,rsc_window&,vornr#,nr#,menuda#,makevirt3#
.|     blocfunc&,g#,smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,markhlp,setbutton,setbutton2
.|     rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
@testcopyright
IF BTST(winh,blkfunc&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=blkfunc&
@rsc_draw(nr,7)
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
makevirt3=FALSE
@markhlp
ELSE
@setbutton(blocfunc&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=blkfunc&
IF vornr=smpedit& THEN
@setbutton2(blocfunc&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_blkf
.| Glob. Var.: obj#,blkhelp&,conins&,conmix&,cached#,conspace&,norm&,resmp&
.|     mono&,negate&,lrchange&,cutin&,cutout&,cutdel&,blkexit&,butdirect#
.|     winh#,blkfunc&,smpedit&,makecurve#,p$,hz#,smprate&,sec#,smplen#
.|     smpsec&,sec$,blocfunc&
.| Ruft auf  : helptxt,coninsert,conmix,conspace,normalize,resample,mono
.|     negate,lrchange,smpcut,setbutton,restaura2b,textfeld,secfeld,timecorr
.| Aufruf in : windows-1,
IF obj=blkhelp& THEN
@helptxt("BLOCK-FUNKTIONEN")
ENDIF
IF obj=conv16& THEN
blkobj=obj
@makebitconv
ENDIF
IF obj=conv24& THEN
blkobj=obj
@makebitconv
ENDIF
IF obj=conins& THEN
@coninsert
ENDIF
IF obj=conmix& THEN
@conmix
cached=FALSE
ENDIF
IF obj=conspace& THEN
@conspace
cached=FALSE
ENDIF
IF obj=norm& THEN
@normalize
ENDIF
IF obj=resmp& THEN
@resample
ENDIF
IF obj=mono& THEN
blkobj=obj
@workblock
ENDIF
IF obj=negate& THEN
blkobj=obj
@workblock
ENDIF
IF obj=lrchange& THEN
blkobj=obj
@workblock
ENDIF
IF obj=cutin& OR obj=cutout& OR obj=cutdel& THEN
@smpcut
ENDIF
IF obj<>blkexit& AND butdirect=TRUE THEN
butdirect=FALSE
'    nr=butnr
'    @rsc_redraw_obj(nr,0)
ENDIF
IF obj=blkexit& OR obj=9999 THEN
@setbutton(blkexit&,0)
winh=BCLR(winh,blkfunc&)
@restaura2b
IF BTST(winh,smpedit&)=TRUE THEN
IF makecurve=1 THEN
p$=STR$(hz/1000)+CHR$(0)
@textfeld(smprate&,p$,1)
sec=smplen/(hz*mbit)
@secfeld(sec,8)
@textfeld(smpsec&,sec$,1)
@timecorr
ENDIF
@setbutton(blocfunc&,0)
ENDIF
obj=0
ENDIF
RETURN
'
> PROCEDURE smpcut
.| Glob. Var.: vobj#,obj#,sms#,sme#,loopz#,cutexit&,xm#,ce#,c2#,c1#,virtual#
.|     cutout&,mcs#,meml#,memh#,mce#,cutin&,cutdel&,virtln2#,virtln#
.|     virtwfile#,virtpath$,a#,virtp$,virtfile$,seekz#,mlen#,bytes#,path$
.|     smpnam$,vmem#,noblkdel#
.| Ruft auf  : markhlp,blocklook,maschinit9,maschruf9,movemark,busy_mouse
.|     hardproof3,memtovirt2,nomem,setbutton,blkrestaura
.| Aufruf in : do_blkf-1,
LOCAL okay,vln,ml,delrange
vobj=obj
@setbutton(vobj,1)
IF sms<>0 AND sms<=loopz AND obj<>cutexit& THEN
@markhlp
@blocklook
IF xm>0 AND ce<>0 AND sms<>0 AND c2>c1 THEN
IF virtual=FALSE THEN
IF obj=cutout& THEN
IF mcs>meml THEN
@maschruf9(meml,mcs)
ENDIF
IF memh>mce THEN
@maschruf9(mce,memh)
ENDIF
ENDIF
IF obj=cutin& THEN
@maschruf9(mcs,mce)
ENDIF
IF obj=cutdel& THEN
IF mce>mcs AND mcs>=meml THEN
mce=INT(mce/mbit)*mbit
@maschruf9(mcs,mce)
IF mce<memh THEN
delrange=(memh-(mce+mbit))
BMOVE mce+mbit,mcs,delrange
@maschruf9(memh-(mce-mcs),memh)
@movemark(c1,c1-c2)
ENDIF
ENDIF
ENDIF
ELSE
virtln2=virtln
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
virtln2=INT(virtln2/mbit)*mbit
okay=FALSE
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
IF virtwfile=FALSE AND obj<>cutdel& THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF @dfree(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
seekz=0
ml=INT(mlen/mbit)*mbit
IF c1>0 THEN
IF okay=TRUE THEN
vln=c1
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=ml
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutout& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln=0
ENDIF
ENDIF
virtln2=virtln2-seekz
IF c2>c1 AND c2<=virtln THEN
IF okay=TRUE THEN
vln=c2-c1
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutin& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
IF obj<>cutdel& THEN
BPUT #2,meml,bytes
ENDIF
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln=0
virtln2=virtln2-(c2-c1)
ENDIF
ENDIF
IF c2<virtln THEN
IF okay=TRUE THEN
vln=virtln2
bytes=ml
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF virtwfile=FALSE AND obj<>cutdel& THEN
SEEK #1,seekz
ENDIF
BGET #1,meml,bytes
IF obj=cutout& THEN
@maschruf9(meml,meml+bytes)
ENDIF
IF virtwfile=TRUE OR obj=cutdel& THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
ENDIF
ENDIF
IF okay=TRUE THEN
CLOSE #1
IF virtwfile=TRUE OR obj=cutdel& THEN
CLOSE #2
ENDIF
IF virtwfile=FALSE AND obj=cutdel& THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
cs=0
ce=vmem
nr=smpedit&
@editselect
@memtovirt2
ENDIF
IF virtwfile=FALSE AND (obj=cutin& OR obj=cutout&) THEN
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
nr=smpedit&
@editselect
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
ENDIF
ENDIF
ENDIF
ENDIF
@blkrestaura
@setbutton(vobj,0)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
RETURN
'
> PROCEDURE movefrag
.| Glob. Var.: vornr#,nr#,moving&,obj#,popup&,zu%,zuadr#,buttadr#,but#
.|     objadr#,objflag#,movhlp&,mvcutcpy&,mvcutins&,mvclrins&,mvclrcpy&
.|     movexit&,moveart#
.| Ruft auf  : rsc_draw,markhlp,rsc_do,xrsrc_gaddr,mousek,helptxt,setbutton
.|     restaura2
.| Aufruf in : smpmhlp-1,
@testcopyright
vornr=nr
nr=moving&
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=movhlp& THEN
@helptxt("MOVE")
ENDIF
UNTIL obj=mvcutcpy& OR obj=mvcutins& OR obj=mvclrins& OR obj=mvclrcpy& OR obj=movexit&
@setbutton(obj,0)
moveart=0
IF obj=mvcutcpy& THEN
moveart=1
ENDIF
IF obj=mvcutins& THEN
moveart=2
ENDIF
IF obj=mvclrins& THEN
moveart=3
ENDIF
IF obj=mvclrcpy& THEN
moveart=4
ENDIF
@restaura2
obj=0
RETURN
'
> PROCEDURE virtmove(ks,kd,kl)
.| Glob. Var.: sms#,sme#,virtln#,a#,virtpath$,vln#,moveart#,virtwfile#
.|     virtp$,virtfile$,bytes#,mlen#,meml#,seek#,memh#,path$,smpnam$,vmem#
.|     g#
.| Ruft auf  : busy_mouse,maschinit9,maschruf9,hardproof3,memtovirt2,nomem
.| Aufruf in : smpmhlp-5,
IF ks<>kd THEN
sms=1
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF @dfree(a)>=vln+kl THEN
IF moveart=4 OR ((moveart=1 OR moveart=3 OR moveart=2) AND (kd>ks+kl OR kd<ks))
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 OR moveart=3 OR moveart=2 THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
IF moveart=4 THEN               ! CLR/COPY
vln=virtln
ENDIF
IF moveart=1 OR (moveart=2 AND kd>ks+kl) THEN               ! CUT/COPY
vln=ks
ENDIF
IF moveart=3 OR (moveart=2 AND kd<ks) THEN               ! CLR/INS
vln=kd
ENDIF
bytes=INT(mlen/mbit)*mbit
IF vln>0 THEN
REPEAT                          ! Source in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
IF moveart=3 OR (moveart=2 AND kd<ks) THEN
seek=0
vln=kl
bytes=INT(mlen/mbit)*mbit
REPEAT                          ! Sourceblock in Destblock kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
SEEK #1,ks+seek
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
IF moveart=1 OR moveart=3 OR (moveart=2 AND (kd>ks+kl OR kd<ks)) THEN    ! bei CUT/COPY den Sourceteil weglassen, den Rest kopieren
IF moveart=1 THEN
SEEK #1,ks+kl
vln=virtln-(ks+kl)
ENDIF
IF moveart=3 THEN
SEEK #1,kd
vln=virtln-kd
ENDIF
IF moveart=2 AND kd>ks+kl THEN    ! StÅck zwischen Sourceende und Destanfang kopieren
SEEK #1,ks+kl
vln=kd-(ks+kl)
ENDIF
IF moveart=2 AND kd<ks THEN   ! StÅck zwischen Destende und Sourceanfang kopieren
SEEK #1,kd
vln=ks-kd
ENDIF
vln=INT(vln/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
IF vln>0 THEN
REPEAT                          ! Source in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ENDIF
IF moveart=2 AND (kd>ks+kl OR kd<ks) THEN
IF kd>ks+kl THEN
SEEK #1,ks
vln=kl
vln=INT(vln/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
REPEAT                          ! Sourceblock in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
IF kd>ks+kl THEN
SEEK #1,kd
vln=virtln-kd
ENDIF
IF kd<ks THEN
SEEK #1,ks+kl
vln=virtln-(ks+kl)
ENDIF
vln=INT(vln/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
IF vln>0 THEN
REPEAT                          ! Von Dest bis Ende in Workfile kopieren
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
ENDIF
CLOSE #2
OPEN "U",#2,virtp$
IF moveart<>2 THEN
IF kd<ks OR moveart=4 THEN
SEEK #2,kd
ELSE
SEEK #2,kd-kl
ENDIF
ENDIF
ELSE
OPEN "U",#1,virtpath$
ENDIF
IF moveart=1 OR moveart=4 THEN
vln=INT(kl/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
seek=0
REPEAT                                ! Sourceblock nach Destblock kopieren
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
IF moveart=4 OR moveart=3 THEN                   ! nur fÅr CLR/COPY und CLR/INS
vln=INT(kl/mbit)*mbit
IF moveart=3 AND kd<ks AND kd+kl>ks THEN
vln=ks-kd
vln=INT(vln/mbit)*mbit
ENDIF
bytes=INT(mlen/mbit)*mbit
IF vln>=bytes THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+vln)
ENDIF
seek=0
IF moveart=3 AND kd<ks
seek=kl
ENDIF
IF moveart=3 AND kd<ks AND kd+kl>ks THEN
seek=kl*2-vln
ENDIF
IF kd>ks AND kd<(ks+kl) AND moveart=4 THEN
vln=kd-ks
vln=INT(vln/mbit)*mbit
ENDIF
IF kd<ks AND kd+kl>ks AND moveart=4 THEN
vln=ks-kd
vln=INT(vln/mbit)*mbit
seek=kd+kl-ks
seek=INT(seek/mbit)*mbit
ENDIF
IF vln>0 THEN
REPEAT                             ! Source mit Zero Åberschreiben
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=3 THEN
SEEK #2,ks+seek
BPUT #2,meml,bytes
ELSE
SEEK #1,ks+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
ENDIF
ENDIF
CLOSE #1
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) OR moveart=1 OR moveart=3 OR moveart=2 THEN ! Source del,Dest-Source rename
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
ENDIF
IF virtwfile=FALSE THEN                                ! Display erneuern
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF (moveart=2 OR moveart=3 OR moveart=1) AND kd<=ks+kl AND kd>ks
@alerts(15)
ENDIF
ELSE
@nomem
ENDIF
ENDIF
RETURN
'
> PROCEDURE virtcopy(ks,kd,kl)
.| Glob. Var.: virtln#,a#,virtpath$,vln#,virtwfile#,virtp$,virtfile$,bytes#
.|     mlen#,meml#,seek#,path$,smpnam$,vmem#
.| Ruft auf  : busy_mouse,hardproof3,memtovirt2,nomem
.| Aufruf in : smpkhlp-5,
IF ks<>kd THEN
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF @dfree(a)>=vln+kl THEN
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
vln=virtln
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #2
OPEN "U",#2,virtp$
SEEK #2,kd
ELSE
OPEN "U",#1,virtpath$
ENDIF
vln=INT(kl/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
seek=0
REPEAT
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
CLOSE #1
IF virtwfile=TRUE OR (kd<(ks+kl) AND kd>ks) THEN
CLOSE #2
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
ENDIF
IF virtwfile=FALSE THEN
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
ENDIF
RETURN
'
> PROCEDURE virtins(ks,kd,kl)
.| Glob. Var.: virtln#,a#,virtpath$,vln#,virtwfile#,virtp$,virtfile$,bytes#
.|     mlen#,meml#,seek#,path$,smpnam$,vmem#
.| Ruft auf  : busy_mouse,hardproof3,memtovirt2,nomem
.| Aufruf in : smpihlp-4,
IF kd>virtln THEN
kd=virtln
ENDIF
IF kd<0 THEN
kd=0
ENDIF
IF kl>(virtln-ks) THEN
kl=virtln-ks
ENDIF
a=ASC(LEFT$(virtpath$,1))-64
IF @dfree(a)>=vln+kl THEN
IF virtwfile=TRUE OR kd<virtln THEN
a=RINSTR(virtpath$,"\")
virtp$=LEFT$(virtpath$,a)+virtfile$
OPEN "I",#1,virtpath$
OPEN "O",#2,virtp$
vln=INT(kd/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
'
vln=INT(kl/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
SEEK #1,ks
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
'
vln=INT((virtln-kd)/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
SEEK #1,kd
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
CLOSE #1
CLOSE #2
ELSE
OPEN "U",#1,virtpath$
vln=INT(kl/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
seek=0
REPEAT
SEEK #1,ks+seek
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
SEEK #1,kd+seek
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
seek=seek+bytes
UNTIL vln<4
CLOSE #1
ENDIF
IF virtwfile=FALSE AND kd<virtln THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
ENDIF
IF virtwfile=FALSE THEN
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
@memtovirt2
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE markhandl4
.| Glob. Var.: y#,stay1#,stay2#,smark#,xmp#,c#,tx#,x#,vc1#,tx2#,vc2#,tm#
.|     tm2#,d1#,d2#,ag#,xd#,mdat%,ag2#,mdat2%,k#,xm#,x2#,t$,t2$
.| Ruft auf  : mousey,rsc_get2,rsc_put,mouse
.| Aufruf in : edhandler2-1,
y=@mousey
IF y>=stay1 AND y<=stay2 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
IF smark=6 OR smark=5 OR smark=4 THEN
xmp=0
c=0
ENDIF
tx=x-(x-vc1)
tx2=x+(vc2-x)
tm=tx
tm2=tx2
COLOR 0
GRAPHMODE 3
COLOR 1
d1=x-vc1
d2=vc2-x
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
mb1=tx2-tx+2
mh1=stay2-stay1+1
IF (tx+xd+(tx2-tx+2))>xwidth THEN
mb1=xwidth-(tx+xd)
ENDIF
IF (stay1+(stay2-stay1+1))>ywidth THEN
mh1=ywidth-stay1
ENDIF
mha4=@rsc_get(tx+xd,stay1,mb1,mh1)
mhb4=@rsc_get(tx+xd,stay1,mb1,mh1)
@rsc_putblock(mha4,tx+xd,stay1,0,0,mb1,mh1)
REPEAT
@mouse(x,y,k)
IF x-d1>=0 AND x+d2<=xm AND y>=stay1 AND y<=stay2 AND x<>x2 THEN
IF (tx+xd+(tx2-tx+2))>xwidth THEN
mb1=xwidth-(tx+xd)
ENDIF
IF (stay1+(stay2-stay1+1))>ywidth THEN
mh1=ywidth-stay1
ENDIF
@rsc_putblock(mhb4,tx+xd,stay1,0,0,mb1,mh1)
tx=x-d1
tx2=x+d2
x2=x
mhb4=@rsc_get2(tx+xd,stay1,mb1,mh1,mhb4)
IF (tx+xd+(tx2-tx+2))>xwidth THEN
mb1=xwidth-(tx+xd)
ENDIF
IF (stay1+(stay2-stay1+1))>ywidth THEN
mh1=ywidth-stay1
ENDIF
@rsc_putblock(mha4,tx+xd,stay1,0,0,mb1,mh1)
ENDIF
UNTIL k=0
GRAPHMODE 3
~MFREE(mha4)
~MFREE(mhb4)
IF bigfoot=FALSE THEN
DEFTEXT 1,0,0,4
ELSE
DEFTEXT 1,0,0,11
ENDIF
TEXT tx+xd-2,stay1,t$
TEXT tx2+xd-2,stay1,t2$
DEFTEXT 1,0,0,4
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
RETURN
'
> PROCEDURE putpix
.| Glob. Var.: edff#,virtual#,v4#,meml#,cs#,a#,wd#,g2#,mdat%,virtwfile#
.|     virtpath$,dsk#,virtln#,f#,virtp$,virtfile$,vln#,bytes#,mlen#
.| Ruft auf  : busy_mouse,nomem
.| Aufruf in : drawpix-2,
edff=TRUE
IF virtual=FALSE THEN
DPOKE meml+cs+((a-1)*mbit)+wd,g2
IF markmode=6 THEN
cached=FALSE
@drawnewcurve
ENDIF
ELSE
IF markmode=7 THEN
vw=((a-1)*mbit)+wd
DPOKE meml+(cs-vcs)+vw,g2
ELSE
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
@busy_mouse
PAUSE 1
vw=((a-1)*mbit)+wd
SEEK #1,cs+vw+head
@busy_mouse
PAUSE 1
DPOKE meml+(cs-vcs)+vw,g2
IF fileart=3 THEN
@maschruf28(meml+(cs-vcs)+vw,4)   ! swap to wave
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
BPUT #1,meml+(cs-vcs)+vw,2
IF fileart=3 THEN
@maschruf28(meml+(cs-vcs)+vw,4)   ! swap to wave
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
CLOSE #1
cached=FALSE
@drawnewcurve
ELSE
dsk=ASC(LEFT$(virtpath$,1))-64
IF @dfree(dsk)>virtln THEN
f=RINSTR(virtpath$,"\")
IF f>0 THEN
virtp$=LEFT$(virtpath$,f)+virtfile$
OPEN "O",#2,virtp$
OPEN "I",#1,virtpath$
vln=virtln
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
CLOSE #1
vw=((a-1)*mbit)+wd
SEEK #2,cs+vw+head
DPOKE meml+(cs-vcs)+vw,g2
IF fileart=3 THEN
@maschruf28(meml+(cs-vcs)+vw,4)   ! swap to wave
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
BPUT #2,meml+(cs-vcs)+vw,2
IF fileart=3 THEN
@maschruf28(meml+(cs-vcs)+vw,4)   ! swap to wave
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
CLOSE #2
cached=FALSE
@drawnewcurve
ENDIF
ELSE
@nomem
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
RETURN
'
> PROCEDURE drawnewcurve
@putcsize
IF memc=0 OR cached=FALSE OR (drawnew2=TRUE AND mnr=smpedit&) THEN
credraw=TRUE
@curve(cs,ce)
@blkupdate
credraw=FALSE
IF drawnew2=TRUE AND mnr=smpedit& THEN
@getcurve
ENDIF
ELSE
@putcurve
ENDIF
RETURN
'
> PROCEDURE drawpix
.| Glob. Var.: edff#,z#,x#,xd#,xm#,a#,b#,w#,d#,w2#,yd#,dist#,ym#,i#,m#,wd#
.| Felder    : cachep1#(),cachem1#(),cachep2#(),cachem2#()
.| Ruft auf  : mousek,putpix
.| Aufruf in : edhandler2-6,
LOCAL f,dsk,v,v2,v3,v4,g,g2,h1,h2
edff=TRUE
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
REPEAT
REPEAT
~GRAF_MKSTATE(v,v2,v3,v4)
UNTIL @mousek=0 OR (v2<>z AND v4=0) OR markmode=7
IF markmode=7 THEN
IF v>x THEN
x=v
ENDIF
IF x>xd+xm THEN
x=xd+xm
ENDIF
a=INT(b/xm*(x-xd))+1
w=xd-1+((a-1)*d)
w2=xd-1+(a*d)
IF w>xd+xm THEN
w=xd+xm
ENDIF
IF w2>xd+xm THEN
w2=xd+xm
ENDIF
ENDIF
h1=z0
h2=ym/2
IF v2>=h1-h2 AND v2<=h1+h2 THEN
COLOR 1
IF markmode=6 THEN
GRAPHMODE 3
ENDIF
IF markmode=7 THEN
GRAPHMODE 1
ENDIF
IF z>=h1-h2 AND z<h1 THEN
FOR i=w TO w2
LINE i,h1-1,i,z
NEXT i
ENDIF
IF z>h1 AND z<=h1+h2 THEN
FOR i=w TO w2
LINE i,h1+1,i,z
NEXT i
ENDIF
IF v2>=h1-h2 AND v2<h1 THEN
FOR i=w TO w2
LINE i,h1-1,i,v2
NEXT i
ENDIF
IF v2>h1 AND v2<=h1+h2 THEN
FOR i=w TO w2
LINE i,h1+1,i,v2
NEXT i
ENDIF
z=v2
ENDIF
UNTIL markmode=7 OR @mousek=0
IF credraw=FALSE THEN
CLIP OFF
ENDIF
drawnew=TRUE
g=z-h1
g=INT(g/ym*2*m)
~GRAF_MOUSE(257,0)                              ! Showm
IF g<=0 THEN
g2=ABS(g)
ELSE
g2=65536-g
ENDIF
IF dist=0 THEN
wd=0
@putpix
DPOKE tma+(a-1)*8,0
DPOKE tma+(a-1)*8+2,0
'    cachep1(a)=0
'    cachem1(a)=0
IF g<=0 THEN
DPOKE tma+(a-1)*8,ABS(g)
'      cachep1(a)=ABS(g)
ENDIF
IF g>=0 THEN
DPOKE tma+(a-1)*8+2,ABS(g)
'      cachem1(a)=g
ENDIF
ELSE
wd=2
@putpix
DPOKE tma+(a-1)*8+4,0
DPOKE tma+(a-1)*8+6,0
'    cachep2(a)=0
'    cachem2(a)=0
IF g<=0 THEN
DPOKE tma+(a-1)*8+4,ABS(g)
'      cachep2(a)=ABS(g)
ELSE
DPOKE tma+(a-1)*8+6,ABS(g)
'      cachem2(a)=g
ENDIF
ENDIF
GRAPHMODE 3
RETURN
'
> PROCEDURE edhandler
.| Glob. Var.: rwert#,merkc#,merkfreq#,smp16&,smp32&,digana#,hz#,smp44&
.|     smp48&,merkerr#,errdel#,noval&,confid&,slipped&,crc&,parity&,biphase&
.|     nolock&,zi#,merk3#,merk4#,prot&,emph&,use&,audio&
.| Ruft auf  : smprate,setbutton2,sethertz,read_statlow,read_statmid
.|     subframe,emphasis
.| Aufruf in : rsc_do-1,
LOCAL merk1,merk2,a,b,c
@read_digsrate
c=rwert
IF c<>merkc THEN
merkc=c
IF c=1 THEN
IF merkfreq<>0 THEN
@setbutton2(merkfreq,0,smp16&)
ENDIF
@setbutton2(smp32&,1,smp16&)
merkfreq=smp32&
IF digana=FALSE THEN
hz=32000
@sethertz
ENDIF
ENDIF
IF c=2 THEN
IF merkfreq<>0 THEN
@setbutton2(merkfreq,0,smp16&)
ENDIF
@setbutton2(smp44&,1,smp16&)
merkfreq=smp44&
IF digana=FALSE THEN
hz=44100
@sethertz
ENDIF
ENDIF
IF c=3 THEN
IF merkfreq<>0 THEN
@setbutton2(merkfreq,0,smp16&)
ENDIF
@setbutton2(smp48&,1,smp16&)
merkfreq=smp48&
IF digana=FALSE THEN
hz=48000
@sethertz
ENDIF
ENDIF
ENDIF
zsf2=TIMER-zsf
IF zsf2>=50 THEN
zsf=TIMER
@digerrorcode
b=(rwert AND 7)           ! Status Mid
IF b=0 THEN
IF merkerr<>0 THEN
@setbutton2(merkerr,0,smp16&)
merkerr=0
errdel=1
ENDIF
ENDIF
IF b=1 THEN
IF merkerr<>0 AND merkerr<>noval& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(noval&,1,smp16&)
merkerr=noval&
errdel=1
ENDIF
IF b=2 THEN
IF merkerr<>0 AND merkerr<>confid& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(confid&,1,smp16&)
merkerr=confid&
errdel=1
ENDIF
IF b=3 THEN
IF merkerr<>0 AND merkerr<>slipped& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
merkerr=0
errdel=1
ENDIF
IF b=4 THEN
IF merkerr<>0 AND merkerr<>crc& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
merkerr=0
errdel=1
ENDIF
IF b=5 THEN
IF merkerr<>0 AND merkerr<>parity& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(parity&,1,smp16&)
merkerr=parity&
errdel=1
ENDIF
IF b=6 THEN
IF merkerr<>0 AND merkerr<>biphase& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(biphase&,1,smp16&)
merkerr=biphase&
errdel=1
ENDIF
IF b=7 THEN
IF merkerr<>0 AND merkerr<>nolock& THEN
@setbutton2(merkerr,0,smp16&)
ENDIF
@setbutton2(nolock&,1,smp16&)
merkerr=nolock&
errdel=1
ENDIF
errdel=0
@digstatcode
b=rwert      ! Status Mid
IF merk4<>b THEN
merk4=b
IF (b AND 4)=4 THEN
@setbutton2(prot&,1,smp16&)
ELSE
@setbutton2(prot&,0,smp16&)
ENDIF
IF (b AND 8)=8 THEN
@setbutton2(emph&,1,smp16&)
ELSE
@setbutton2(emph&,0,smp16&)
ENDIF
IF (b AND 1)=1 THEN
'    "CONSUMER"
@setbutton2(use&,0,smp16&)
ELSE
'    "PROFI"
@setbutton2(use&,1,smp16&)
ENDIF
IF (b AND 2)=2 THEN
'    "DIGITAL"
@setbutton2(audio&,1,smp16&)
ELSE
'    "DATA"
@setbutton2(audio&,0,smp16&)
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler2
.| Glob. Var.: edff#,xmp#,k#,mb&,x#,mx&,y#,my&,xd#,xm#,ce#,cs#,stay1#,stay2#
.|     max#,yzoom#,wyzoom#,rubmax#,v#,v2#,v3#,v4#,ym1#,yd#,z#,dist#,ym2#
.|     sline#,virtual#,virtpath$,mdat%,cached#,virtwfile#,dsk#,virtln#,f#
.|     virtp$,virtfile$,vln#,bytes#,mlen#,meml#,master#,masta#,xx#,zsnap#
.|     back%,loopz#,t$,smark#,sms#,c1#,sme#,c2#,t2$,vc1#,vc2#,xmo#,tx#,tm#
.|     ymd#
.| Felder    : cachep1#(),cachem1#(),cachep2#(),cachem2#(),loops#(),loope#()
.| Ruft auf  : markhlp,drawpix,busy_mouse,mousek,restaura,nomem,smph1
.|     springart,markhlp3,markhlp6,markhandl4,smpkhlp,smpmhlp,smpihlp
.|     flipptest,rubbermax,markprod2
.| Aufruf in : button-1,
LOCAL xw,ym,a1,a2,a,b,c,d,i,w,w2,m,tux
edff=FALSE
xmp=-1
c=0
k=@mousek
IF k<>0 THEN
~GRAF_MKSTATE(v,v2,v3,v4)
@markhlp
x=mx&
y=my&
'
@calc_editboxes2
'
IF k<>0 AND x>=xd AND x<=(xm+xd) AND xm>0 AND ce>cs AND y>=stay1 AND y<=stay2 AND (ce-cs)<=xm THEN
IF max=0 OR yzoom=FALSE THEN
m=32767
ELSE
m=max
ENDIF
IF wyzoom=TRUE THEN
m=rubmax
ENDIF
b=(ce-cs)/mbit
b=INT(b)
d=xm/b
a=INT(b/xm*(x-xd))+1
az=INT((x-xd))+1
w=xd+2+((a-1)*d)
w2=xd+2+(a*d)
'      ~GRAF_MKSTATE(v,v2,v3,v4)
IF markmode=6 AND k=1 THEN
IF y>=ym1 AND y<=ym1+ym THEN
a1=DPEEK(tma+(az-1)*8)
a2=DPEEK(tma+(az-1)*8+2)
'          a1=cachep1(a)
'          a2=cachem1(a)
IF a1>a2 THEN
c=INT(a1/m*ym/2)
c0=ym1+ym/2
IF y>=c0-c AND y<c0-c+4 THEN
z=ym1+ym/2-c
z0=ym1+ym/2
dist=0
@drawpix
ENDIF
ELSE
c=INT(a2/m*ym/2)
c0=ym1+ym/2
IF y<=c0+c AND y>c0+c-4 THEN
z=ym1+ym/2+c
z0=ym1+ym/2
dist=0
@drawpix
ENDIF
ENDIF
ENDIF
IF y>=ym2 AND y<=ym2+ym THEN
a1=DPEEK(tma+(az-1)*8+4)
a2=DPEEK(tma+(az-1)*8+6)
'          a1=cachep2(a)
'          a2=cachem2(a)
IF a1>a2 THEN
c=INT(a1/m*ym/2)
c0=ym2+ym/2
IF y>=c0-c AND y<c0-c+4 THEN
z=ym2+ym/2-c
z0=ym2+ym/2
'              z=yd+65+sline-c
dist=1
@drawpix
ENDIF
ELSE
c=INT(a2/m*ym/2)
c0=ym2+ym/2
IF y<=c0+c AND y>c0+c-4 THEN
'              z=yd+65+sline+c
z=ym2+ym/2+c
z0=ym2+ym/2
dist=1
@drawpix
ENDIF
ENDIF
ENDIF
ENDIF
IF markmode=7 AND k=1 THEN
IF y>=ym1 AND y<=ym1+ym THEN
z=ym1+ym/2
z0=ym1+ym/2
dist=0
REPEAT
@drawpix
UNTIL @mousek=0
ENDIF
IF y>=ym2 AND y<=ym2+ym THEN
z=ym2+ym/2
z0=ym2+ym/2
dist=1
REPEAT
@drawpix
UNTIL @mousek=0
ENDIF
IF edff=TRUE THEN
cached=FALSE
@restaura
ENDIF
IF virtual=TRUE AND edff=TRUE THEN
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
@busy_mouse
SEEK #1,cs+head
IF fileart=3 THEN
@maschruf28(meml+(cs-vcs),ce-cs)   ! swap to wave
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
BPUT #1,meml+(cs-vcs),ce-cs
IF fileart=3 THEN
@maschruf28(meml+(cs-vcs),ce-cs)   ! swap to wave
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
@busy_mouse
PAUSE 1
CLOSE #1
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
dsk=ASC(LEFT$(virtpath$,1))-64
IF @dfree(dsk)>virtln THEN
f=RINSTR(virtpath$,"\")
IF f>0 THEN
virtp$=LEFT$(virtpath$,f)+virtfile$
OPEN "O",#2,virtp$
OPEN "I",#1,virtpath$
vln=virtln
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
CLOSE #1
SEEK #2,cs+head
@busy_mouse
IF fileart=3 THEN
@maschruf28(meml+(cs-vcs),ce-cs)   ! swap to wave
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
BPUT #2,meml+(cs-vcs),ce-cs
IF fileart=3 THEN
@maschruf28(meml+(cs-vcs),ce-cs)   ! swap to wave
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
@busy_mouse
CLOSE #2
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ELSE
@nomem
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF ((markmode=1 OR markmode=2) AND k=1) AND y>=stay1 AND y<=stay2 THEN
IF markmode=2 THEN
IF sms=0 THEN
sms=1
ENDIF
xx=INT(((ce-cs)/xm*(x-xd)+cs)/mbit)*mbit
@edmarkdel
loops%(sms,1)=xx
loops%(sms,2)=xx
sms2=2
masta=xx
ELSE
IF sms<=loopz THEN
IF sms2<>0 THEN
masta=loops%(sms,sms2)
ENDIF
ENDIF
FOR i=1 TO 4
IF loops%(sms,i)<>-1 THEN
@marktextsel(i)
a=loops%(sms,i)
IF a>=cs AND a<=ce AND (ce-cs)>0 THEN
tux=a-cs
tux=INT(tux/(ce-cs)*xm)
EXIT IF x>tux+xd-2 AND x<tux+xd+2 AND y>=stay1 AND y<=stay2
ENDIF
ENDIF
NEXT i
IF x>tux+xd-2 AND x<tux+xd+2 AND y>=stay1 AND y<=stay2 THEN
@selblkshak(sms2,0)     ! Marker abwÑhlen
sms2=i
@selblkshak(sms2,1)     ! Marker auswÑhlen
ENDIF
ENDIF
IF masta<cs OR masta>ce AND sms2<>0 THEN
xw=x
IF k<>0 AND xw>=xd AND xw<=(xm+xd) AND xm>0 AND ce>cs THEN
IF xw>=xd AND xw<=(xm+xd) AND xm>0 AND ce>cs THEN
@smph1
IF sms>0 AND x>ce OR x<cs THEN
edff=TRUE
xx=INT(((ce-cs)/xm*(xw-xd)+cs)/mbit)*mbit
IF zsnap=TRUE THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4<>0 THEN
@springart(xx)
IF back%>=cs AND back%<=ce THEN
xx=back%
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
loops%(sms,sms2)=xx
@marktextsel(sms2)
@markhlp3(sms,sms2,loops%(sms,sms2))
ENDIF
@markhlp6(xx)
REPEAT
k=@mousek
UNTIL k=0
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF k=1 AND y>=stay1 AND y<=stay2 AND x>=xd AND x<=(xm+xd) AND xm>0 THEN
IF smark=6 OR smark=5 OR smark=4 THEN
IF sms>0 THEN
c1=loops%(sms,1)
t$="S"
c2=loops%(sms,2)
t2$="E"
ENDIF
IF (ce-cs)>0 AND c1>=cs AND c2<=ce AND c2>c1 THEN
vc1=INT(xm/(ce-cs)*(c1-cs))
vc2=INT(xm/(ce-cs)*(c2-cs))
IF x>=vc1+xd AND x<=vc2+xd THEN
edff=TRUE
@markhandl4
IF sms>0 THEN
loops%(sms,1)=c1
loops%(sms,2)=c2
ENDIF
IF smark=5 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpkhlp
ENDIF
IF smark=6 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpmhlp
ENDIF
IF smark=4 THEN
xmo=(ce-cs)/xm*(tx-tm)
@smpihlp
ENDIF
@flipptest
ENDIF
ENDIF
ENDIF
IF edff=FALSE AND k=1 AND x>=xd AND x<=(xm+xd) AND xm>0 AND ce>cs AND y>=stay1 AND y<=stay2 THEN
IF y>=ym AND y<=ym1+ym THEN
ymd=ym1
@rubbermax
ENDIF
IF y>=ym2 AND y<=ym2+ym THEN
ymd=ym2
@rubbermax
ENDIF
ENDIF
IF smark=1 OR smark=2 OR smark=3 THEN
IF markmode=2 THEN
@selblkshak(sms2,0)     ! Marker abwÑhlen
sms2=2
@selblkshak(sms2,1)     ! Marker auswÑhlen
ENDIF
@markprod2
IF markmode=2 THEN
@selblkshak(sms2,0)     ! Marker abwÑhlen
sms2=1
@selblkshak(sms2,1)     ! Marker auswÑhlen
ENDIF
@flipptest
xmp=0
c=0
ENDIF
ENDIF
IF @mousek=0 AND drawnew=TRUE THEN
drawnew=FALSE
@getcurve
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler3
.| Glob. Var.: digana#,c#,rwert#,merkc#,merkfreq#,smp32&,hz#,smp44&,smp48&
.| Ruft auf  : smprate,sethertz
.| Aufruf in : rsc_do-1,smpplay-1,
IF digana=FALSE THEN
@read_digsrate
c=rwert
IF c<>merkc THEN
merkc=c
IF c=1 THEN
merkfreq=smp32&
IF digana=FALSE THEN
hz=32000
@sethertz
ENDIF
ENDIF
IF c=2 THEN
merkfreq=smp44&
IF digana=FALSE THEN
hz=44100
@sethertz
ENDIF
ENDIF
IF c=3 THEN
merkfreq=smp48&
IF digana=FALSE THEN
hz=48000
@sethertz
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler4
IF nr=arranger& THEN
IF XBIOS(xbs,1)=&H71273800 THEN
bc=back%
hsec=INT((sectpos+bc)/vhz/mbit*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(playlen&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE edhandler5(br)
IF nr=trakker& THEN
IF XBIOS(xbs,1)=&H71273800 THEN
bc=back%
hsec=INT((sectpos+bc)/hz/br*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(traktime&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE rubbermax
.| Glob. Var.: v#,v2#,v3#,v4#,ce#,cs#,xm#,x#,y#,x2#,y2#,a1#,ymd#,a2#,ym#,a#
.|     max#,m#,wyzoom#,rubmax#,qspacefill#,spacefill#,g#,xd#,scrlslde&
.|     scrolbut&,scmax#,scrollp#,mrscroll#,cached#
.| Ruft auf  : scrollinit,setslide,zslidecalc,writeyproz,restaura
.| Aufruf in : edhandler2-2,
LOCAL x1
~GRAF_MKSTATE(v,v2,v3,v4)
IF (v4=0 AND markmode=5 AND (ce-cs)>=xm) OR (v4=8 AND markmode=5) THEN
~GRAF_RUBBERBOX(x,y,10,10,x2,y2)
a1=y-ymd
a2=ymd+ym-(y2+y)
IF a2>ymd+ym THEN
a2=ymd+ym
ENDIF
IF a1<0 THEN
a1=0
ENDIF
IF a2<0 THEN
a2=0
ENDIF
IF a1<a2 THEN
a=a1
ELSE
a=a2
ENDIF
a=ABS(a)
a=((ym/2)-a)*2
IF max=0 THEN
m=32767
ELSE
m=max
ENDIF
IF wyzoom=TRUE THEN
m=rubmax
ENDIF
a=m/ym*a
IF wyzoom=FALSE THEN
qspacefill=spacefill
ENDIF
wyzoom=TRUE
spacefill=TRUE
IF v4=0 AND markmode=5 THEN
rubmax=INT(a)
IF (100/32767*rubmax)<6 THEN
rubmax=INT(32767/100*6)
@alerts(18)
ENDIF
x1=x-xd
x1=cs+((ce-cs)/xm*x1)
'      cs=INT(x1/mbit)*mbit
x2=x2+x-xd
x2=cs+((ce-cs)/xm*x2)
'      ce=INT(x2/mbit)*mbit
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
mrscroll=scrollp
cached=FALSE
@zslidecalc
ENDIF
IF (v4=8 AND markmode=5) THEN
IF rubmax=0 THEN
rubmax=32767
ENDIF
rubmax=rubmax*1.5
IF rubmax>32767 THEN
rubmax=32767
wyzoom=FALSE
spacefill=qspacefill
ENDIF
ENDIF
@writeyproz
@restaura
ENDIF
RETURN
'
> PROCEDURE blkstest
.| Glob. Var.: master#,shlp#,blksa#,meml#,blkse#,smrk#,c1#,loopz#,c2#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp
.| Aufruf in : smpsave-1,
'  war sms=0 AND shlp=1
IF sms2=0 THEN
blksa=meml
blkse=smrk
blstest=FALSE
ELSE
@markhlp
c1=loops%(sms,1)
c2=loops%(sms,2)
IF c1<>-1 AND c2<>-1 THEN
blkse=c2+meml
blkse=INT(blkse/mbit)*mbit
blksa=c1+meml
blksa=INT(blksa/mbit)*mbit
blstest=TRUE
ELSE
blksa=meml
blkse=smrk
blstest=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE markhlp7
.| Glob. Var.: i#,loopz#,sms#,lmin#,sme#,lma#,blks#,blksa#,meml#
.| Felder    : loops#(),loope#()
.| Aufruf in : smpsave-2,sampleinf-1,
lmin=loops%(sms,1)
lma=loops%(sms,2)
IF blks=0 THEN
lmin=INT(lmin/mbit)*mbit
lma=INT(lma/mbit)*mbit
ELSE
lmin=lmin-(blksa-meml)
lmin=INT(lmin/mbit)*mbit
lma=lma-(blksa-meml)
lma=INT(lma/mbit)*mbit
ENDIF
RETURN
'
> PROCEDURE makesmphead
.| Glob. Var.: danf#,hz#,len#,blks#,m2#,meml#,blksa#,blkse#,j#,nam$
.| Felder    : loops#(),loope#()
.| Aufruf in : sdsave-2,
LOCAL a$,i,a,m
FOR i=0 TO 295
POKE danf+i,0
NEXT i
DPOKE (danf+76),16     ! Bits
LPOKE (danf+72),hz     ! Sample-Rate
a=INT(len/mbit)
LPOKE (danf+92),a      ! datasize
LPOKE (danf+140),a     ! datasize2
LPOKE (danf),0         ! Sample-start
LPOKE (danf+4),a       ! Sample-end
IF blks=0 THEN
m=0
m2=meml
ELSE
m=blksa-meml
m2=blkse-meml
ENDIF
FOR j=1 TO 5
a=INT((loops%(j,1)-m)/mbit)
IF a<0 OR a>m2 THEN
a=0
ENDIF
LPOKE (danf+4+j*4),a       ! Start L1-L5
a=INT((loops%(j,2)-m)/mbit)
IF a<0 OR a>m2 THEN
a=0
ENDIF
LPOKE (danf+36+j*4),a      ! End L1-L5
NEXT j
LPOKE (danf+28),0      ! Start L6
LPOKE (danf+60),0      ! End L6
LPOKE (danf+28),0      ! Start L7
LPOKE (danf+60),0      ! End L7
a$=nam$
POKE danf+77,&H10
a=RINSTR(a$,".")
IF a>0 THEN
a=a-1
ENDIF
FOR i=1 TO a
POKE danf+77+i,ASC(MID$(a$,i,1))
NEXT i
LPOKE danf+96,&HFFFFFFFF   ! ??
LPOKE danf+100,&HFFFFFFFF  ! ??
DPOKE danf+144,1           ! ??
LPOKE danf+104,0       ! Marker 1
LPOKE danf+108,0       ! Marker 2
LPOKE danf+112,0       ! Marker 3
LPOKE danf+116,0       ! Marker 4
LPOKE danf+120,0       ! Marker 5
LPOKE danf+124,0       ! Marker 6
LPOKE danf+128,0       ! Marker 7
LPOKE danf+132,0       ! Marker 8
RETURN
'
> PROCEDURE sdsave
.| Glob. Var.: a#,fil$,b#,a$,danf#,head#,fileart#,datx#,len#,hdl#,mdat%
.|     hbuf#,ret#,i#
.| Ruft auf  : maschinit38,maschruf38,maschinit36,maschruf36,makesmphead
.|     nomem
.| Aufruf in : smpsave-1,
a=RINSTR(fil$,".")
b=RINSTR(fil$,"\")
IF (a-b)>8 THEN
a$=LEFT$(fil$,a-2)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ELSE
a$=LEFT$(fil$,a-1)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ENDIF
OPEN "O",#1,a$
BPUT #1,danf,head
CLOSE #1
IF fileart=6 THEN
@maschruf38(datx,datx+len)
ENDIF
hdl=GEMDOS(61,L:VARPTR(a$),2)
~GEMDOS(66,L:head,hdl,0)
@maschruf36(datx,datx+len,mdat%+2048,mdat%+hbuf-mbit,hdl,ret)
a=GEMDOS(62,hdl)
IF fileart=6 THEN
@makesmphead
OPEN "U",#1,a$
SEEK #1,LOF(#1)
BPUT #1,danf,296   ! Header
CLOSE #1
ENDIF
IF ret=(datx+len) THEN
a=RINSTR(fil$,".")
b=RINSTR(fil$,"\")
IF (a-b)>8 THEN
a$=LEFT$(fil$,a-2)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ELSE
a$=LEFT$(fil$,a-1)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ENDIF
IF fileart=6 THEN
LPOKE danf,&HF07E0001                    ! Kennung
FOR i=danf+4 TO danf+19
POKE i,0
NEXT i
ENDIF
OPEN "O",#1,a$
BPUT #1,danf,head
CLOSE #1
hdl=GEMDOS(61,L:VARPTR(a$),2)
~GEMDOS(66,L:head,hdl,0)
@maschruf36(datx+2,datx+len+2,mdat%+2048,mdat%+hbuf-mbit,hdl,ret)
~GEMDOS(62,hdl)
IF fileart=6 THEN
@makesmphead
OPEN "U",#1,a$
SEEK #1,LOF(#1)
BPUT #1,danf,296   ! Header
CLOSE #1
ENDIF
IF ret<>datx+len+2 THEN
@nomem
ENDIF
ELSE
@nomem
ENDIF
IF fileart=6 THEN
@maschruf38(datx,datx+len)
ENDIF
RETURN
'
> PROCEDURE headart
head=0
IF RINSTR(fil$,".")=0 THEN
fil$=fil$+"."+vext$
ENDIF
@headart2(fil$)
IF head>0 THEN
FOR i=0 TO head-1
POKE danf+i,0
NEXT i
ENDIF
RETURN
'
> PROCEDURE headart2(head$)
LOCAL h
sfileart=0
h=INSTR(head$,CHR$(0))
IF h<>0 THEN
head$=LEFT$(head$,h-1)
ENDIF
IF RIGHT$(head$,4)=".S16" THEN
sfileart=1
head=20
@setbitrate16
ENDIF
IF RIGHT$(head$,4)=".S24" THEN
sfileart=1
head=20
@setbitrate24
ENDIF
IF RIGHT$(head$,4)=".AVR" THEN
sfileart=2
head=128
ENDIF
IF RIGHT$(head$,4)=".WAV" THEN
sfileart=3
head=44
ENDIF
IF RIGHT$(head$,3)=".AU" OR RIGHT$(head$,4)=".SND" THEN
sfileart=4
head=28
ENDIF
IF RIGHT$(head$,3)=".SD" THEN
sfileart=5
head=1336
ENDIF
IF RIGHT$(head$,4)=".SMP" THEN
sfileart=6
head=20+296
ENDIF
IF RIGHT$(head$,4)=".AIF" THEN
sfileart=7
head=54+458
ENDIF
RETURN
'
> PROCEDURE headmake
IF fileart=1 THEN                          ! S16-File
DPOKE danf,&HF07E                        ! SDS-Startkennung
POKE danf+2,1                            ! MIDI-Kanalnummer
POKE danf+3,1
DPOKE danf+4,&H100                       ! Sample-Nr.
IF dig24=FALSE THEN
POKE danf+6,16                           ! Bits
ELSE
POKE danf+6,24                           ! Bits
ENDIF
per=10^9/hz
x=INT(per/65536)
y=per-x*65536
POKE danf+7,x                            ! Periodendauer eines Samples
DPOKE danf+8,y                           ! Periodendauer eines Samples
IF blks=1 AND blstest=TRUE THEN
mlh=INT((blkse-blksa)/(mbit/2))
ELSE
mlh=INT(mlen/(mbit/2))
ENDIF
x2=INT(mlh/256)
y2=mlh-x2*256
DPOKE danf+10,x2                          ! Sample Len in Worten
POKE danf+12,y2                           ! Sample Len in Worten
@markhlp
@markhlp7
x3=INT(lmin/65536)
y3=lmin-x3*65536
POKE danf+13,x3                           ! Sustain Loop-Start
DPOKE danf+14,y3                          ! Sustain Loop-Start
x4=INT(lma/256)
y4=lma-x4*256
DPOKE danf+16,x4                          ! Sustain Loop-End
POKE danf+18,y4                          ! Sustain Loop-End
IF sret=0 THEN
la=0
ELSE
la=1
ENDIF
IF sblock=0 THEN
la=&H7F
ENDIF
POKE danf+19,la                           ! Loop-Art
'      POKE danf+20,&HF7                  ! SDS-Endkennung
ENDIF
'
IF fileart=2 THEN                          ! AVR-File
cdavr=TRUE
'
LPOKE danf,&H32424954                    ! AVR-Kennung
i=RINSTR(nam$,".")
a$=LEFT$(nam$,i-1)
FOR i=1 TO LEN(a$)
POKE danf+3+i,ASC(MID$(a$,i,1))        ! Name des Samples
NEXT i
DPOKE danf+12,&HFFFF                     ! mode
IF dig24=FALSE THEN
DPOKE danf+14,16                         ! resolution
ELSE
DPOKE danf+14,24                         ! resolution
ENDIF
DPOKE danf+16,&HFFFF                     ! sign
la=0
IF sblock=1 AND blstest=TRUE AND cdavr=FALSE THEN
la=&HFFFF     ! herausgenommen wegen Problem mit CD-Rekorder Audio !!!
ENDIF
DPOKE danf+18,la                         ! loop
DPOKE danf+20,&HFFFF                     ! note
LPOKE danf+22,hz                         ! speed
IF blks=1 AND blstest=TRUE THEN
mlh=INT((blkse-blksa)/(mbit/2))
ELSE
mlh=INT(mlen/(mbit/2))
ENDIF
LPOKE danf+26,mlh                        ! len
@markhlp
IF sblock=1 AND blstest=TRUE AND cdavr=FALSE THEN
@markhlp7
LPOKE danf+30,INT(lmin/(mbit/2))              ! beg_loop
LPOKE danf+34,INT(lma/(mbit/2))               ! end_loop
ELSE
LPOKE danf+30,0
LPOKE danf+34,mlh
ENDIF
ENDIF
'
IF fileart=3 THEN                          ! WAV-File
LPOKE danf,&H52494646                    ! "RIFF"
IF blks=1 AND blstest=TRUE THEN
len=blkse-blksa
ELSE
len=mlen
ENDIF
len2=len+head-4
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+4,a4
POKE danf+5,a3
POKE danf+6,a2
POKE danf+7,a1
LPOKE danf+8,&H57415645                  ! "WAVE"
LPOKE danf+12,&H666D7420                 ! "fmt "
POKE danf+16,16                          ! LÑnge des fmt-Chunks
POKE danf+17,0
POKE danf+18,0
POKE danf+19,0
POKE danf+20,1                           ! format PCM
POKE danf+21,0
POKE danf+22,2                           ! channels
POKE danf+23,0
len2=hz
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+24,a4                           ! frequency
POKE danf+25,a3
POKE danf+26,a2
POKE danf+27,a1
len2=hz*mbit                              ! average
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+28,a4                           ! average
POKE danf+29,a3
POKE danf+30,a2
POKE danf+31,a1
POKE danf+32,mbit                         ! align
POKE danf+33,0
IF dig24=FALSE THEN
POKE danf+34,16                           ! bps
ELSE
POKE danf+34,24                           ! bps
ENDIF
POKE danf+35,0
LPOKE danf+36,&H64617461                  ! "data"
len2=len
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+40,a4                           ! LÑnge des data-chunks
POKE danf+41,a3
POKE danf+42,a2
POKE danf+43,a1
ENDIF
'
IF fileart=4 THEN                          ! AU-File
LPOKE danf,&H2E736E64                    ! AVR-Kennung
LPOKE danf+4,28                          ! datalocation
LPOKE danf+12,3                          ! dataformat
LPOKE danf+20,2                          ! channelcount
LPOKE danf+24,0                          ! info
LPOKE danf+16,hz                         ! samplingrate
IF blks=1 AND blstest=TRUE THEN
mlh=blkse-blksa
ELSE
mlh=mlen
ENDIF
LPOKE danf+8,mlh                         ! datasize
@markhlp
ENDIF
'
IF fileart=5 THEN                          ! SD-File
'   0-3    05 38 00 0C          -> Kennung'
'  58-61   FF FF FF 80'
'  64-67   01 47 04 00'
'  69-74   25 53 63 61 6C 65     %Scale'
' 109-114  20 20 6D 73 65 63       msec'
' 148-151  00 04 CC 66          -> LÑnge des Samples in Bytes'
' 184-187  00 04 CC 66          -> LÑnge des Samples in Bytes'
' 1020-1023 AC 44               -> Samplerate'
' 1031-1036 4C 69 6E 65 61 72     Linear'
' 1336-xxxx Daten'
LPOKE danf,&H538000C                     ! SD-Kennung
LPOKE danf+58,&HFFFFFF80                 ! ?
LPOKE danf+64,&H1470400                  ! ?
POKE danf+69,&H25                        ! "%"
LPOKE danf+70,&H5363616C                 ! "Scal"
POKE danf+74,&H65                        ! "e"
POKE danf+109,&H20                       ! " "
LPOKE danf+110,&H206D7365                ! " mse"
POKE danf+114,&H63                       ! "c"
IF blks=1 AND blstest=TRUE THEN
mlh=INT((blkse-blksa)/(mbit/2))
ELSE
mlh=INT(mlen/(mbit/2))
ENDIF
LPOKE danf+148,mlh                       ! len
LPOKE danf+184,mlh                       ! len
LPOKE danf+1020,hz                       ! speed
POKE danf+1031,&H4C                      ! "L"
LPOKE danf+1032,&H696E6561               ! "inea"
POKE danf+1036,&H72                      ! "r"
IF blks=1 AND blstest=TRUE THEN
len=blkse-blksa
ELSE
len=mlen
ENDIF
ENDIF
'
IF fileart=6 THEN                          ! Avalon SMP-File
LPOKE danf,&HF07E0001                    ! Kennung
FOR i=danf+4 TO danf+19
POKE i,0
NEXT i
IF blks=1 AND blstest=TRUE THEN
len=blkse-blksa
ELSE
len=mlen
ENDIF
ENDIF
IF fileart=7 THEN                          ! AIFF-File
LPOKE danf,&H464F524D                    ! "FORM"
IF blks=1 AND blstest=TRUE THEN
mlh=blkse-blksa
ELSE
mlh=mlen
ENDIF
LPOKE danf+4,mlh+512-12                  ! formsize
LPOKE danf+8,&H41494646                  ! "AIFF"
LPOKE danf+12,&H434F4D4D                 ! "COMM"
LPOKE danf+16,&H12                       ! commsize
DPOKE danf+20,2                          ! channels
LPOKE danf+22,INT(mlh/mbit)              ! frames
IF dig24=FALSE THEN
DPOKE danf+26,16                         ! bits
ELSE
DPOKE danf+26,24                         ! bits
ENDIF
DPOKE danf+28,&H400E                     ! lead
DPOKE danf+30,hz                         ! samplingrate
DPOKE danf+32,0                          ! dummy 1
DPOKE danf+34,0                          ! dummy 2
DPOKE danf+36,0                          ! dummy 3
LPOKE danf+38,&H53534E44                 ! "SSND"
LPOKE danf+42,mlh+512-46                 ! soundsize
LPOKE danf+46,458                        ! Offset
LPOKE danf+50,512                        ! blocksize
@markhlp
ENDIF
RETURN
'
> PROCEDURE headmake2
LOCAL len,len2,mlh,x2,y2,a1,a2,a3,a4
IF fileart=1 THEN                          ! S16-File
mlh=INT(vln/(mbit/2))
x2=INT(mlh/256)
y2=mlh-x2*256
DPOKE danf+10,x2                          ! Sample Len in Worten
POKE danf+12,y2                           ! Sample Len in Worten
ENDIF
'
IF fileart=2 THEN                          ! AVR-File
mlh=INT(vln/2)
LPOKE danf+26,mlh                        ! len
IF sblock=1 AND blstest=TRUE THEN
LPOKE danf+30,INT(lmin/2)              ! beg_loop
LPOKE danf+34,INT(lma/2)               ! end_loop
ELSE
LPOKE danf+30,0
LPOKE danf+34,mlh
ENDIF
ENDIF
'
IF fileart=3 THEN                          ! WAV-File
len=vln
len2=len+head-4
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+4,a4
POKE danf+5,a3
POKE danf+6,a2
POKE danf+7,a1
len2=len
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE danf+40,a4                           ! LÑnge des data-chunks
POKE danf+41,a3
POKE danf+42,a2
POKE danf+43,a1
ENDIF
'
IF fileart=4 THEN                          ! AU-File
mlh=vln
LPOKE danf+8,mlh                         ! datasize
ENDIF
'
IF fileart=5 THEN                          ! SD-File
'   0-3    05 38 00 0C          -> Kennung'
'  58-61   FF FF FF 80'
'  64-67   01 47 04 00'
'  69-74   25 53 63 61 6C 65     %Scale'
' 109-114  20 20 6D 73 65 63       msec'
' 148-151  00 04 CC 66          -> LÑnge des Samples in Bytes'
' 184-187  00 04 CC 66          -> LÑnge des Samples in Bytes'
' 1020-1023 AC 44               -> Samplerate'
' 1031-1036 4C 69 6E 65 61 72     Linear'
' 1336-xxxx Daten'
mlh=INT(vln/2)
LPOKE danf+148,mlh                       ! len
LPOKE danf+184,mlh                       ! len
len=vln
ENDIF
'
IF fileart=6 THEN                          ! Avalon SMP-File
len=vln
ENDIF
IF fileart=7 THEN                          ! AIFF-File
mlh=vln
LPOKE danf+4,mlh+512-12                  ! formsize
LPOKE danf+22,INT(mlh/mbit)              ! frames
LPOKE danf+42,mlh+512-46                 ! soundsize
ENDIF
RETURN
'
> PROCEDURE headmake3
LOCAL len,len2,mlh,x2,y2,a1,a2,a3,a4,per,x,y
IF fileart=1 THEN                          ! S16-File
per=10^9/hz
x=INT(per/65536)
y=per-x*65536
POKE meml+7,x                            ! Periodendauer eines Samples
DPOKE meml+8,y                           ! Periodendauer eines Samples
ENDIF
'
IF fileart=2 THEN                          ! AVR-File
LPOKE meml+22,hz                         ! speed
ENDIF
'
IF fileart=3 THEN                          ! WAV-File
len2=hz
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE meml+24,a4                           ! frequency
POKE meml+25,a3
POKE meml+26,a2
POKE meml+27,a1
len2=hz*mbit                                 ! average
a1=INT(len2/&H1000000)
len2=len2-a1*&H1000000
a2=INT(len2/65536)
len2=len2-a2*65536
a3=INT(len2/256)
a4=len2-a3*256
POKE meml+28,a4                           ! average
POKE meml+29,a3
POKE meml+30,a2
POKE meml+31,a1
ENDIF
'
IF fileart=4 THEN                          ! AU-File
LPOKE meml+16,hz                         ! samplingrate
ENDIF
'
IF fileart=5 THEN                          ! SD-File
LPOKE meml+1020,hz                       ! speed
ENDIF
'
IF fileart=7 THEN                          ! AIFF-File
DPOKE meml+30,hz                         ! samplingrate
ENDIF
RETURN
'
> PROCEDURE headmake4
IF fileart=1 THEN
IF dig24=FALSE THEN
POKE mdat%+6,16                           ! Bits
ELSE
POKE mdat%+6,24                           ! Bits
ENDIF
ENDIF
IF fileart=2 THEN
IF dig24=FALSE THEN
DPOKE mdat%+14,16                         ! resolution
ELSE
DPOKE mdat%+14,24                         ! resolution
ENDIF
ENDIF
IF fileart=3 THEN
'    len2=len+head-4
'    a1=INT(len2/&H1000000)
'    len2=len2-a1*&H1000000
'    a2=INT(len2/65536)
'    len2=len2-a2*65536
'    a3=INT(len2/256)
'    a4=len2-a3*256
'    POKE mdat%+4,a4
'    POKE mdat%+5,a3
'    POKE mdat%+6,a2
'    POKE mdat%+7,a1
'
'    len2=hz*mbit                              ! average
'    a1=INT(len2/&H1000000)
'    len2=len2-a1*&H1000000
'    a2=INT(len2/65536)
'    len2=len2-a2*65536
'    a3=INT(len2/256)
'    a4=len2-a3*256
'    POKE mdat%+28,a4                           ! average
'    POKE mdat%+29,a3
'    POKE mdat%+30,a2
'    POKE mdat%+31,a1
IF dig24=FALSE THEN
POKE mdat%+34,16                           ! bps
ELSE
POKE mdat%+34,24                           ! bps
ENDIF
'    len2=len
'    a1=INT(len2/&H1000000)
'    len2=len2-a1*&H1000000
'    a2=INT(len2/65536)
'    len2=len2-a2*65536
'    a3=INT(len2/256)
'    a4=len2-a3*256
'    POKE danf+40,a4                           ! LÑnge des data-chunks
'    POKE danf+41,a3
'    POKE danf+42,a2
'    POKE danf+43,a1
ENDIF
IF fileart=4 THEN
IF mbit=4 THEN
LPOKE mdat%+8,LPEEK(mdat%+8)/6*4                         ! datasize
ELSE
LPOKE mdat%+8,LPEEK(mdat%+8)/4*6                         ! datasize
ENDIF
ENDIF
IF fileart=7 THEN
mlh=LPEEK(mdat%+4)-500
IF mbit=4 THEN
mlh=mlh/6*4                         ! datasize
ELSE
mlh=mlh/4*6                         ! datasize
ENDIF
LPOKE mdat%+4,mlh+512-12                  ! formsize
IF dig24=FALSE THEN
DPOKE mdat%+26,16                         ! bits
ELSE
DPOKE mdat%+26,24                         ! bits
ENDIF
LPOKE mdat%+42,mlh+512-46                 ! soundsize
ENDIF
RETURN
'
> PROCEDURE smpsave
.| Glob. Var.: inf#,nomem#,vornr#,nr#,savebloc&,zu%,versatz#,a$,string#
.|     savetxt&,it#,obj#,popup&,zuadr#,buttadr#,but#,objadr#,objflag#
.|     savehelp&,savexit&,savall&,savblock&,blks#,sms#,loopz#,msms#,sme#
.|     msme#,big#,anfloadx#,mlen#,blkse#,blksa#,meml#,datx#,danf#,mdat%
.|     virtual#,g#,virtpath$,op$,virtwfile#,mp$,ext2$,fil$,pret#,pbutt#,a#
.|     l#,vext$,nam$,sfileart#,head#,fileart#,i#,isave#,bnam$,smplen#,b#,hz#
.|     per#,x#,y#,mlh#,x2#,y2#,x3#,lmin#,y3#,x4#,lma#,y4#,sret#,la#,sblock#
.|     len#,len2#,a2#,a3#,a4#,a1#,oeffne#,path$,smpnam$,vln#,virtln#,stt#
.|     c2#,c1#,vp$,virtfile$,seekz#,bytes#,smpedit&,smpfile&,smpsave&
.| Ruft auf  : infhol,markhlp,xrsrc_gaddr,rsc_draw,rsc_do,mousek,helptxt
.|     setbutton,restaura2,blkstest,makehz,maschinit,busy_mouse,fileselect
.|     sampleinf,maschruf,markhlp7,nomem,maschinit28,maschruf28,sdsave
.|     makedatum,fnamwrite,infsave,textfeld,restaura4
.| Aufruf in : drop2-1,do_smpedit-1,
LOCAL origfil$
@testcopyright
origfil$=fil$       ! Backup variablen
xinfname$=infname$
xper=per
xsmplen=smplen
xordner$=ordner$
xmrkdatum$=mrkdatum$
xretime=retime
inf=FALSE
samplesave=TRUE
nomem=FALSE
@infhol
@markhlp
vornr=nr
nr=savebloc&
~@xrsrc_gaddr(0,nr,zu%)
versatz=1
a$="Save"
string=LPEEK(LPEEK(zu%+24*savetxt&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 OR doexit=TRUE
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=savehelp& THEN
@helptxt("SAVE")
ENDIF
UNTIL obj=savexit& OR obj=savall& OR obj=savblock& OR doexit=TRUE
IF doexit=TRUE THEN
obj=keyobj
doexit=FALSE
ENDIF
@smpsave2
samplesave=FALSE
IF fil$=origfil$ AND inf=TRUE THEN
FOR i=1 TO loopz
FOR j=1 TO 4
IF loops%(i,j)=-1 THEN
bloops%(i,j)=-1
ELSE
bloops%(i,j)=INT(loops%(i,j)/mbit)
ENDIF
NEXT j
NEXT i
ENDIF
IF virtual=TRUE THEN
fil$=origfil$  ! restore filename
infname$=xinfname$
nam$=enam$
path$=fil$
per=xper
smplen=xsmplen
ordner$=xordner$
mrkdatum$=xmrkdatum$
retime=xretime
@fnamwrite
ENDIF
RETURN
'
> PROCEDURE smpsave2
IF obj=savall& THEN
blks=0
ENDIF
IF obj=savblock& THEN
blks=1
ENDIF
@setbutton(obj,0)
@restaura2
IF obj<>savexit& THEN
@blkstest
@makehz
IF big=0 THEN
IF blks=0 THEN
anfloadx=@malloc(mlen+&H200,1)
ELSE
anfloadx=@malloc((blkse-blksa)+&H200,1)
ENDIF
ELSE
IF blks=0 THEN
anfloadx=meml
ELSE
anfloadx=blksa
ENDIF
ENDIF
IF anfloadx<>0 AND anfloadx<>-1 THEN
IF big=0 THEN
datx=((INT(anfloadx/mbit))*mbit)+mbit
ELSE
datx=anfloadx
ENDIF
danf=mdat%
@busy_mouse
IF virtual=TRUE THEN
g=RINSTR(virtpath$,"\")
IF g>0 THEN
op$=LEFT$(virtpath$,g)
ENDIF
IF virtwfile=TRUE THEN
mp$=""
ENDIF
ENDIF
@fileselect(op$+"*."+ext2$,mp$,"SAVE SAMPLE:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 THEN
IF blks=0 THEN
a=meml
l=mlen
IF virtual=TRUE THEN
a=0
l=vmem
ENDIF
ELSE
a=blksa
l=blkse-blksa
ENDIF
vext$=ext2$
IF vext$="*" THEN
IF dig24=FALSE THEN
vext$="S16"
ELSE
vext$="S24"
ENDIF
ENDIF
IF RINSTR(nam$,".")=0 THEN
nam$=nam$+"."+vext$
ENDIF
@headart
IF sfileart=0 THEN
inf=FALSE
@alerts(10)
ELSE
fileart=sfileart
isave=TRUE
bnam$=nam$
smplen=l
@sampleinf
isave=FALSE
ENDIF
IF inf=TRUE THEN
b=datx
IF big=0 THEN
@maschruf1
ENDIF
hz=@hzanalye(hz)
@headmake
a=ASC(LEFT$(fil$,1))-64
oeffne=FALSE
IF @dfree(a)>(head+(blkse-blksa)) THEN
oeffne=TRUE
ELSE
IF virtual=FALSE THEN
@nomem
ENDIF
ENDIF
IF oeffne=TRUE THEN
IF virtual=FALSE THEN
IF blks=0 THEN
len=mlen
ELSE
len=blkse-blksa
ENDIF
IF fileart=3 THEN
@maschruf28(datx,len)
ENDIF
IF len>0 THEN
a=ASC(LEFT$(fil$,1))-64
IF fileart=5 OR fileart=6 THEN
IF @dfree(a)>=(head+len*2) THEN
@sdsave
ELSE
@nomem
ENDIF
ELSE
IF @dfree(a)>=(head+len) THEN
OPEN "O",#1,fil$
BPUT #1,danf,head
BPUT #1,datx,len
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
path$=fil$
smpnam$=nam$
smplen=len
@makedatum
@fnamwrite
IF nomem=FALSE THEN
@infsave
ENDIF
ELSE
@alerts(16)
ENDIF
IF fileart=3 THEN
@maschruf28(datx,len)
ENDIF
ELSE
IF nomem=FALSE THEN
@infsave
ENDIF
IF blks=0 THEN
vln=virtln
stt=0
ELSE
vln=c2-c1
stt=c1
ENDIF
IF vln>0 THEN
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>=vln THEN
IF virtwfile=TRUE THEN
a=RINSTR(virtpath$,"\")
IF a>0 THEN
vp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
ELSE
vp$=virtpath$
ENDIF
IF EXIST(vp$)=FALSE THEN
vp$=virtpath$
ENDIF
kfile=FALSE
IF vp$=fil$ THEN
a=RINSTR(vp$,"\")
IF a>0 THEN
vp$=LEFT$(vp$,a)+virtfile$
ENDIF
NAME fil$ AS vp$
kfile=TRUE
ENDIF
OPEN "I",#1,vp$
OPEN "O",#2,fil$
IF sfileart<>ldfileart THEN
IF vln>ldhead THEN
stt=stt+ldhead
vln=vln-ldhead
ENDIF
@headmake2
BPUT #2,danf,head
ENDIF
vln=INT(vln/mbit)*mbit
seekz=INT(stt/mbit)*mbit
bytes=INT(mlen/mbit)*mbit
IF seekz>0 THEN
SEEK #1,seekz
ENDIF
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF sfileart=3 AND sfileart<>ldfileart THEN
@maschruf28(meml,bytes)
ENDIF
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
CLOSE #1
CLOSE #2
IF kfile=TRUE THEN
KILL vp$
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
ELSE
@alerts(16)
ENDIF
ENDIF
ENDIF
IF nr=smpedit& THEN
@textfeld(smpfile&,nam$+CHR$(0),1)
ENDIF
ENDIF
ENDIF
ENDIF
IF big=0 AND anfloadx<>0 THEN
~MFREE(anfloadx)
anfloadx=0
ENDIF
'    @restaura4
ENDIF
IF nr=smpedit& THEN
@setbutton(smpsave&,0)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE blklfrag
.| Glob. Var.: vornr#,nr#,savebloc&,zu%,versatz#,a$,string#,savetxt&,it#
.|     obj#,popup&,zuadr#,buttadr#,but#,objadr#,objflag#,savehelp&,savexit&
.|     savall&,savblock&,blks#
.| Ruft auf  : markhlp,xrsrc_gaddr,rsc_draw,rsc_do,mousek,helptxt,setbutton
.|     rsc_back
.| Aufruf in : ldhlp-1,
@testcopyright
@markhlp
vornr=nr
nr=savebloc&
~@xrsrc_gaddr(0,nr,zu%)
versatz=1
a$="Load"
string=LPEEK(LPEEK(zu%+24*savetxt&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 OR doexit=TRUE
IF doexit=FALSE THEN
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=savehelp& THEN
@helptxt("LOAD")
ENDIF
ENDIF
UNTIL obj=savexit& OR obj=savall& OR obj=savblock& OR doexit=TRUE
IF doexit=TRUE THEN
obj=keyobj
doexit=FALSE
ENDIF
@blklfrag2
RETURN
'
> PROCEDURE blklfrag2
IF obj=savall& THEN
blks=0
ENDIF
IF obj=savblock& THEN
blks=1
ENDIF
@setbutton(obj,0)
@rsc_back(nr)
nr=vornr
'  @restaura2
RETURN
'
> PROCEDURE clearfsel
.| Glob. Var.: fsbut1&,fsbut2&,fsbut3&,fsbut4&,fsbut5&,fsbut6&,fsbut7&
.|     fsbut8&,fsbut9&,fsbut10&,fsbut11&,fsbut12&,fsbut13&,fsbut14&,fsbut15&
.|     fstxt1&,fstxt2&,fstxt3&,fstxt4&,fstxt5&,fstxt6&,fstxt7&,fstxt8&
.|     fstxt9&,fstxt10&,fstxt11&,fstxt12&,fstxt13&,fstxt14&,fstxt15&
.| Ruft auf  : setbutton,textfeld
.| Aufruf in : getsel5-1,fsnrset-1,newfsel-5,
@setbutton(fsbut1&,0)
@setbutton(fsbut2&,0)
@setbutton(fsbut3&,0)
@setbutton(fsbut4&,0)
@setbutton(fsbut5&,0)
@setbutton(fsbut6&,0)
@setbutton(fsbut7&,0)
@setbutton(fsbut8&,0)
@setbutton(fsbut9&,0)
@setbutton(fsbut10&,0)
@setbutton(fsbut11&,0)
@setbutton(fsbut12&,0)
@setbutton(fsbut13&,0)
@setbutton(fsbut14&,0)
@setbutton(fsbut15&,0)
@textfeld(fsbut1&,CHR$(0),1)
@textfeld(fsbut2&,CHR$(0),1)
@textfeld(fsbut3&,CHR$(0),1)
@textfeld(fsbut4&,CHR$(0),1)
@textfeld(fsbut5&,CHR$(0),1)
@textfeld(fsbut6&,CHR$(0),1)
@textfeld(fsbut7&,CHR$(0),1)
@textfeld(fsbut8&,CHR$(0),1)
@textfeld(fsbut9&,CHR$(0),1)
@textfeld(fsbut10&,CHR$(0),1)
@textfeld(fsbut11&,CHR$(0),1)
@textfeld(fsbut12&,CHR$(0),1)
@textfeld(fsbut13&,CHR$(0),1)
@textfeld(fsbut14&,CHR$(0),1)
@textfeld(fsbut15&,CHR$(0),1)
@textfeld(fstxt1&,CHR$(0),1)
@textfeld(fstxt2&,CHR$(0),1)
@textfeld(fstxt3&,CHR$(0),1)
@textfeld(fstxt4&,CHR$(0),1)
@textfeld(fstxt5&,CHR$(0),1)
@textfeld(fstxt6&,CHR$(0),1)
@textfeld(fstxt7&,CHR$(0),1)
@textfeld(fstxt8&,CHR$(0),1)
@textfeld(fstxt9&,CHR$(0),1)
@textfeld(fstxt10&,CHR$(0),1)
@textfeld(fstxt11&,CHR$(0),1)
@textfeld(fstxt12&,CHR$(0),1)
@textfeld(fstxt13&,CHR$(0),1)
@textfeld(fstxt14&,CHR$(0),1)
@textfeld(fstxt15&,CHR$(0),1)
RETURN
'
> PROCEDURE clearfsel2
.| Glob. Var.: i#,flist#,wurl#
.| Felder    : dbank$(),dbank2$(),wurlnr#()
.| Aufruf in : getsel5-1,
FOR i=1 TO flist
dbank$(i)=""
dbank2$(i)=""
NEXT i
RETURN
'
> PROCEDURE getsel
.| Glob. Var.: b$,flist#,op$
.| Felder    : dbank$(),dbank2$()
.| Aufruf in : getsel5-4,
LOCAL g,a$
g=FALSE
a$=RIGHT$(b$,5)
a$=LEFT$(a$,LEN(a$)-1)
IF a$=".S16" THEN
g=TRUE
ENDIF
IF a$=".S24" THEN
g=TRUE
ENDIF
IF a$=".WAV" THEN
g=TRUE
ENDIF
IF a$=".AU" THEN
g=TRUE
ENDIF
IF a$=".SND" THEN
g=TRUE
ENDIF
IF a$=".SMP" THEN
g=TRUE
ENDIF
IF a$=".AVR" THEN
g=TRUE
ENDIF
IF a$=".AIF" THEN
g=TRUE
ENDIF
IF a$=".SD" THEN
g=TRUE
ENDIF
IF g=TRUE THEN
INC flist
dbank$(flist)=b$
dbank2$(flist)=op$+b$
ENDIF
RETURN
'
> PROCEDURE getsel2
LOCAL gl,mbv,zugriff,zugriff2
.| Glob. Var.: flist#,j#,fsz#,lmax4#,i3#,wurl#,i#,fsmplay#,b$,fsbut1&
.|     fsbut2&,fsbut3&,fsbut4&,fsbut5&,fsbut6&,fsbut7&,fsbut8&,fsbut9&
.|     fsbut10&,fsbut11&,fsbut12&,fsbut13&,fsbut14&,fsbut15&,i2#,bloopz#,a#
.|     c$,src$,a$,fstxt1&,fstxt2&,fstxt3&,fstxt4&,fstxt5&,fstxt6&,fstxt7&
.|     fstxt8&,fstxt9&,fstxt10&,fstxt11&,fstxt12&,fstxt13&,fstxt14&,fstxt15&
.| Felder    : wurlnr#(),dbank$(),dbank2$()
.| Ruft auf  : textfeld
.| Aufruf in : getsel5-2,fsnrset-1,newfsel-5,
IF fsz<0 THEN
fsz=0
ENDIF
IF fsmplay=FALSE THEN
mbv=flist
ELSE
mbv=wurl
ENDIF
IF mbv>0 THEN
j=fsz+1
'
IF j+14>mbv THEN
j=mbv-14
ENDIF
'
IF j<1 THEN
j=1
ENDIF
gl=j+14
IF mbv<(j+14) THEN
gl=mbv-j+1
ENDIF
IF gl<1 THEN
gl=1
ENDIF
mboxa=j-1
FOR i=j TO gl
IF i<=mbv THEN
IF fsmplay=FALSE THEN
b$=dbank$(i)
ELSE
IF mbank$(i)<>"" AND i<=wurl THEN
b$=mbank$(i)
ELSE
b$=""
ENDIF
ENDIF
zugriff=FALSE
zugriff2=FALSE
IF fsmplay=TRUE THEN
IF i<=lmax4 THEN
IF mbank$(i)<>"" THEN
zugriff2=TRUE
IF b$<>"" THEN
zugriff=TRUE
ENDIF
ENDIF
ENDIF
ENDIF
IF fsmplay=FALSE OR (fsmplay=TRUE AND zugriff=TRUE) THEN
IF i=j THEN
@textfeld(fsbut1&,b$,1)
ENDIF
IF i=j+1 THEN
@textfeld(fsbut2&,b$,1)
ENDIF
IF i=j+2 THEN
@textfeld(fsbut3&,b$,1)
ENDIF
IF i=j+3 THEN
@textfeld(fsbut4&,b$,1)
ENDIF
IF i=j+4 THEN
@textfeld(fsbut5&,b$,1)
ENDIF
IF i=j+5 THEN
@textfeld(fsbut6&,b$,1)
ENDIF
IF i=j+6 THEN
@textfeld(fsbut7&,b$,1)
ENDIF
IF i=j+7 THEN
@textfeld(fsbut8&,b$,1)
ENDIF
IF i=j+8 THEN
@textfeld(fsbut9&,b$,1)
ENDIF
IF i=j+9 THEN
@textfeld(fsbut10&,b$,1)
ENDIF
IF i=j+10 THEN
@textfeld(fsbut11&,b$,1)
ENDIF
IF i=j+11 THEN
@textfeld(fsbut12&,b$,1)
ENDIF
IF i=j+12 THEN
@textfeld(fsbut13&,b$,1)
ENDIF
IF i=j+13 THEN
@textfeld(fsbut14&,b$,1)
ENDIF
IF i=j+14 THEN
@textfeld(fsbut15&,b$,1)
ENDIF
'
IF fsmplay=FALSE THEN
b$=dbank2$(i)
ELSE
IF zugriff2=TRUE THEN
IF mbank$(i)<>"" AND i<=wurl THEN
b$=mbank2$(i)
ELSE
b$=""
ENDIF
ENDIF
ENDIF
IF b$<>"" THEN
b$=LEFT$(b$,RINSTR(b$,"."))+"INF"+CHR$(0)
IF EXIST(b$)=TRUE THEN
OPEN "I",#2,b$
@loadloops(FALSE)
c$=src1$
d$=src2$
CLOSE #2
a$=""
IF c$<>"" AND c$<>CHR$(0) THEN
IF RIGHT$(c$,1)=CHR$(0) THEN
c$=LEFT$(c$,LEN(c$)-1)
ENDIF
a$=c$
ENDIF
IF d$<>"" AND d$<>CHR$(0) THEN
IF RIGHT$(d$,1)=CHR$(0) THEN
d$=LEFT$(d$,LEN(d$)-1)
ENDIF
IF LEN(a$)>0 THEN
a$=a$+","
ENDIF
a$=a$+d$
ENDIF
IF a$<>"" THEN
IF bigfoot=FALSE THEN
nfstl=60
ELSE
nfstl=98
ENDIF
IF LEN(a$)>nfstl THEN
a$=LEFT$(a$,nfstl)
ENDIF
a$=a$+CHR$(0)
IF i=j THEN
@textfeld(fstxt1&,a$,1)
ENDIF
IF i=j+1 THEN
@textfeld(fstxt2&,a$,1)
ENDIF
IF i=j+2 THEN
@textfeld(fstxt3&,a$,1)
ENDIF
IF i=j+3 THEN
@textfeld(fstxt4&,a$,1)
ENDIF
IF i=j+4 THEN
@textfeld(fstxt5&,a$,1)
ENDIF
IF i=j+5 THEN
@textfeld(fstxt6&,a$,1)
ENDIF
IF i=j+6 THEN
@textfeld(fstxt7&,a$,1)
ENDIF
IF i=j+7 THEN
@textfeld(fstxt8&,a$,1)
ENDIF
IF i=j+8 THEN
@textfeld(fstxt9&,a$,1)
ENDIF
IF i=j+9 THEN
@textfeld(fstxt10&,a$,1)
ENDIF
IF i=j+10 THEN
@textfeld(fstxt11&,a$,1)
ENDIF
IF i=j+11 THEN
@textfeld(fstxt12&,a$,1)
ENDIF
IF i=j+12 THEN
@textfeld(fstxt13&,a$,1)
ENDIF
IF i=j+13 THEN
@textfeld(fstxt14&,a$,1)
ENDIF
IF i=j+14 THEN
@textfeld(fstxt15&,a$,1)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
NEXT i
IF fsmplay=FALSE THEN
@fsbutset
ENDIF
ENDIF
RETURN
'
> PROCEDURE getsel3
.| Glob. Var.: fsmplay#,obj#,k#,k2#,vfil$,op$
.| Felder    : dbank$()
.| Ruft auf  : setbutton
.| Aufruf in : newfsel-16,
IF fsmplay=TRUE THEN
@setbutton(obj,0)
ENDIF
IF nfk<>0 AND nfk2<>0 AND obj<>nfk2 THEN
@setbutton(nfk2,0)
ENDIF
IF obj=nfk2 AND nfk<>0 AND dbank$(nfk)<>"" THEN
@setbutton(obj,1)
ENDIF
nfk2=obj
IF dbank$(nfk)<>"" AND nfk<>0 THEN
vfil$=op$+dbank$(nfk)
ELSE
vfil$=""
ENDIF
RETURN
'
> PROCEDURE getsel4
.| Glob. Var.: fsel$,a$,op$,fsotxt&
.| Ruft auf  : textfeld
.| Aufruf in : getsel5-1,
IF EXIST(fsel$)=TRUE THEN
a$="FILESELECT-DATEI -->"+fsel$
ELSE
a$=op$
ENDIF
IF LEN(a$)>50 THEN
a$="..."+RIGHT$(a$,47)
ENDIF
a$=a$+CHR$(0)
nfil$=a$
@textfeld(fsotxt&,a$,1)
RETURN
'
> PROCEDURE getsel5
.| Glob. Var.: flist#,fsel$,a$,nf$,op$,a#,dta#,pdta#,b$,k#
.| Ruft auf  : clearfsel,clearfsel2,getsel4,getsel,getsel2
.| Aufruf in : newfsel-6,
LOCAL g
flist=0
@clearfsel2
g=FALSE
IF EXIST(fsel$)=TRUE THEN
g=TRUE
OPEN "I",#1,fsel$
IF LOF(#1)>0 THEN
g=TRUE
WHILE EOF(#1)=FALSE
INPUT #1,a$
nf$=a$+CHR$(0)
op$=LEFT$(a$,LEN(a$)-3)
a=GEMDOS(78,L:VARPTR(nf$),0)
IF a=0 THEN
dta=GEMDOS(47)
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WHILE GEMDOS(79)=0
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WEND
ENDIF
WEND
ENDIF
CLOSE #1
@getsel2
ENDIF
IF g=FALSE THEN
nf$=op$+"*.*"+CHR$(0)
a=GEMDOS(78,L:VARPTR(nf$),0)
IF a=0 THEN
dta=GEMDOS(47)
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WHILE GEMDOS(79)=0
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WEND
@getsel2
ENDIF
ENDIF
nfk=0
RETURN
'
> PROCEDURE getsel6
LOCAL g
ERASE dbank$()
ERASE dbank2$()
@clearfsel
@getsel4
flist=0
g=FALSE
IF EXIST(fsel$)=TRUE THEN
g=TRUE
OPEN "I",#1,fsel$
IF LOF(#1)>0 THEN
g=TRUE
WHILE EOF(#1)=FALSE
INPUT #1,a$
nf$=a$+CHR$(0)
op$=LEFT$(a$,LEN(a$)-3)
a=GEMDOS(78,L:VARPTR(nf$),0)
IF a=0 THEN
dta=GEMDOS(47)
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel7
WHILE GEMDOS(79)=0
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel7
WEND
ENDIF
WEND
ENDIF
CLOSE #1
ENDIF
IF g=FALSE THEN
nf$=op$+"*.*"+CHR$(0)
a=GEMDOS(78,L:VARPTR(nf$),0)
IF a=0 THEN
dta=GEMDOS(47)
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel
WHILE GEMDOS(79)=0
pdta=dta+30
b$=""
REPEAT
a=PEEK(pdta)
b$=b$+CHR$(a)
INC pdta
UNTIL a=0
@getsel7
WEND
ENDIF
ENDIF
nfk=0
IF flist>=fsl THEN
DIM dbank$(flist)
DIM dbank2$(flist)
ELSE
DIM dbank$(fsl)
DIM dbank2$(fsl)
ENDIF
RETURN
'
> PROCEDURE getsel7
LOCAL g,a$
g=FALSE
a$=RIGHT$(b$,5)
a$=LEFT$(a$,LEN(a$)-1)
IF a$=".S16" THEN
g=TRUE
ENDIF
IF a$=".S24" THEN
g=TRUE
ENDIF
IF a$=".WAV" THEN
g=TRUE
ENDIF
IF a$=".AU" THEN
g=TRUE
ENDIF
IF a$=".SND" THEN
g=TRUE
ENDIF
IF a$=".SMP" THEN
g=TRUE
ENDIF
IF a$=".AVR" THEN
g=TRUE
ENDIF
IF a$=".AIF" THEN
g=TRUE
ENDIF
IF a$=".SD" THEN
g=TRUE
ENDIF
IF g=TRUE THEN
INC flist
ENDIF
RETURN
'
> PROCEDURE fsnrset
.| Ruft auf  : clearfsel,getsel2
.| Aufruf in : button-2,newfsel-2,
@clearfsel
@getsel2
RETURN
'
> PROCEDURE fsbutset
LOCAL a
IF mfsz<>0 THEN
a=mfsz-fsz
IF a>=1 AND a<=15 THEN
IF a=1 THEN
obj=fsbut1&
ENDIF
IF a=2 THEN
obj=fsbut2&
ENDIF
IF a=3 THEN
obj=fsbut3&
ENDIF
IF a=4 THEN
obj=fsbut4&
ENDIF
IF a=5 THEN
obj=fsbut5&
ENDIF
IF a=6 THEN
obj=fsbut6&
ENDIF
IF a=7 THEN
obj=fsbut7&
ENDIF
IF a=8 THEN
obj=fsbut8&
ENDIF
IF a=9 THEN
obj=fsbut9&
ENDIF
IF a=10 THEN
obj=fsbut10&
ENDIF
IF a=11 THEN
obj=fsbut11&
ENDIF
IF a=12 THEN
obj=fsbut12&
ENDIF
IF a=13 THEN
obj=fsbut13&
ENDIF
IF a=14 THEN
obj=fsbut14&
ENDIF
IF a=15 THEN
obj=fsbut15&
ENDIF
@setbutton(obj,1)
nfk=a
mfsz=fsz+nfk
nfk2=obj
ENDIF
ENDIF
RETURN
'
> PROCEDURE fscalc
LOCAL a
IF fsmplay=FALSE THEN
fsz=flist/fsmax*fsz2
IF fsz2>fsmax-fstep THEN
fsz2=fsmax-fstep
@setslide2(fsslide&,fssldbut&,fsmax,fsz2,fstep)
ENDIF
IF fsz>(flist-15) THEN
fsz=flist-15
ENDIF
ELSE
fsz=wurl/fsmax*fsz2
IF fsz2>fsmax-fstep THEN
fsz2=fsmax-fstep
@setslide2(fsslide&,fssldbut&,fsmax,fsz2,fstep)
ENDIF
IF fsz>(wurl-15) THEN
fsz=wurl-15
ENDIF
ENDIF
IF fsz<0 THEN
fsz=0
ENDIF
fsz=ROUND(fsz)
RETURN
'
> PROCEDURE fselslidset
@slidelen(fsslide&,fssldbut&,v,fsbr)
IF flist=0 THEN
fbbut=fsbr
ELSE
fbbut=INT(fsbr/flist*fsl)  ! Buttonbreite
ENDIF
IF fbbut>fsbr THEN
fbbut=fsbr
ENDIF
fsmax=fsbr                 ! Breite des Sliders
IF flist<=fsl THEN
fstep=0      ! Schrittweite des Sliders
fsplus=0         ! Einzelschritt
ELSE
fstep=fsmax/flist*fsl      ! Schrittweite des Sliders
fsplus=fsmax/flist         ! Einzelschritt
ENDIF
@slideinit(fsslide&,fssldbut&,fsmax,fbbut,fsz)
@setslide(fsslide&,fssldbut&,fsmax,fbbut,fsz)
fsz=0
fsz2=0
RETURN
'
> PROCEDURE mboxslidset
@slidelen(fsslide&,fssldbut&,v,fsbr)
IF wurl=0 THEN
fbbut=fsbr
ELSE
fbbut=INT(fsbr/wurl*fsl)  ! Buttonbreite
ENDIF
IF fbbut>fsbr THEN
fbbut=fsbr
ENDIF
fsmax=fsbr                 ! Breite des Sliders
IF wurl<=fsl THEN
fstep=0      ! Schrittweite des Sliders
fsplus=0         ! Einzelschritt
ELSE
fstep=fsmax/wurl*fsl      ! Schrittweite des Sliders
fsplus=fsmax/wurl         ! Einzelschritt
ENDIF
@slideinit(fsslide&,fssldbut&,fsmax,fbbut,fsz)
@setslide(fsslide&,fssldbut&,fsmax,fbbut,fsz)
fsz=0
fsz2=0
RETURN
'
> PROCEDURE ntstbut
n=0
IF obj=fsbut1& THEN
n=1
ENDIF
IF obj=fsbut2& THEN
n=2
ENDIF
IF obj=fsbut3& THEN
n=3
ENDIF
IF obj=fsbut4& THEN
n=4
ENDIF
IF obj=fsbut5& THEN
n=5
ENDIF
IF obj=fsbut6& THEN
n=6
ENDIF
IF obj=fsbut7& THEN
n=7
ENDIF
IF obj=fsbut8& THEN
n=8
ENDIF
IF obj=fsbut9& THEN
n=9
ENDIF
IF obj=fsbut10& THEN
n=10
ENDIF
IF obj=fsbut11& THEN
n=11
ENDIF
IF obj=fsbut12& THEN
n=12
ENDIF
IF obj=fsbut13& THEN
n=13
ENDIF
IF obj=fsbut14& THEN
n=14
ENDIF
IF obj=fsbut15& THEN
n=15
ENDIF
RETURN
'
> PROCEDURE fselinsert
IF wurl<lmax4 THEN
INC wurl
mbank$(wurl)=dbank$(fsz+nfk)
mbank2$(wurl)=dbank2$(fsz+nfk)
ELSE
@alerts(19)
ENDIF
RETURN
'
> PROCEDURE fseldelete
IF fsmplay=TRUE THEN
~@xrsrc_gaddr(0,nr,zu%)
IF wurl>0 THEN
obj=OBJC_FIND(zu%,0,10,x,y)
n=mfsz-fsz
obj=fsbut1&+n-1
IF n>0 AND (mboxa+n)<=wurl THEN
@setbutton(obj,1)
PAUSE 10
@setbutton(obj,0)
ENDIF
obj=nobj
IF n>0 AND (mboxa+n)<=wurl AND wurl<=lmax4 THEN
a=0
mbank$(mboxa+n)=""
mbank2$(mboxa+n)=""
IF (mboxa+n)<wurl THEN
FOR i=mboxa+n TO wurl
mbank$(i)=mbank$(i+1)
mbank2$(i)=mbank2$(i+1)
NEXT i
mbank$(wurl)=""
mbank2$(wurl)=""
ENDIF
DEC wurl
ENDIF
ENDIF
ENDIF
fsz=0
fsz2=0
@mboxslidset
@clearfsel
@getsel2
@fselinit
RETURN
'
> PROCEDURE fselinit
actfsel=0
mfsz=0
nfk=0
fsz=0
fsz2=0
RETURN
'
> PROCEDURE fselswitch
@fselinit
IF fsmplay=FALSE THEN
fsmplay=TRUE
@mboxslidset
@readpos(fsotxt&)
@buttbh(fsotxt&,nx,ny)
IF bigfoot=FALSE THEN
@setpos(fsotxt&,5,by)
@setbuttbh(fsotxt&,618,ny)
ELSE
@setpos(fsotxt&,10,by)
@setbuttbh(fsotxt&,917,ny)
ENDIF
@readpos(fsexit&)
IF bigfoot=FALSE THEN
@setpos(fsexit&,570,by)
ELSE
@setpos(fsexit&,874,by)
ENDIF
@textfeld(nfseltxt&,"Musicbox"+CHR$(0),1)
IF EXIST(wfil$) AND wfil$<>"" THEN
a$="MUSICBOX-DATEI -->"+wfil$
IF LEN(a$)>50 THEN
a$="..."+RIGHT$(a$,47)
ENDIF
a$=a$+CHR$(0)
ELSE
a$=CHR$(0)
ENDIF
@textfeld(fsotxt&,a$,1)
@hidetree2(fsins&,TRUE)
@hidetree2(fsdel&,FALSE)
@hidetree2(fsordner&,TRUE)
@hidetree2(fsadd&,TRUE)
@hidetree2(fsload&,FALSE)
@hidetree2(fssave&,FALSE)
@flagbutton(fsexit&,1031)
@flagbutton(fsok&,0)
@hidetree2(fsok&,TRUE)
@hidetree(fsnew&,TRUE,fselbox&)
@rsc_state(nr,fsordner&,3,TRUE)
@rsc_state(nr,fsadd&,3,TRUE)
@rsc_state(nr,fsnew&,3,TRUE)
ELSE
fsmplay=FALSE
IF wurload=TRUE THEN
wurload=FALSE
ENDIF
@fselslidset
@readpos(fsotxt&)
@buttbh(fsotxt&,nx,ny)
IF bigfoot=FALSE THEN
@setpos(fsotxt&,179,by)
@setbuttbh(fsotxt&,444,ny)
ELSE
@setpos(fsotxt&,222,by)
@setbuttbh(fsotxt&,705,ny)
ENDIF
@readpos(fsexit&)
IF bigfoot=FALSE THEN
@setpos(fsexit&,512,by)
ELSE
@setpos(fsexit&,810,by)
ENDIF
IF nfil$<>"" THEN
@textfeld(fsotxt&,nfil$,1)
ENDIF
@textfeld(nfseltxt&,"Audioselector"+CHR$(0),1)
@hidetree2(fsins&,FALSE)
@hidetree2(fsdel&,TRUE)
@hidetree2(fsordner&,FALSE)
@hidetree2(fsadd&,FALSE)
@hidetree2(fsload&,TRUE)
@hidetree2(fsnew&,FALSE)
@flagbutton(fsexit&,1029)
@flagbutton(fsok&,1031)
@hidetree2(fsok&,FALSE)
@hidetree(fssave&,TRUE,fselbox&)
@rsc_state(nr,fsordner&,3,FALSE)
@rsc_state(nr,fsadd&,3,FALSE)
@rsc_state(nr,fsnew&,3,FALSE)
ENDIF
@clearfsel
@getsel2
'        nfk=0
RETURN
'
> PROCEDURE loadfsel
LOCAL fsv,a,i
@fileselect(lfw$+"*."+mbox$,setn$+"."+mbox$,"LOAD MUSICBOX:")
IF pret<>0 AND pbutt=1 THEN
IF EXIST(fil$) THEN
OPEN "I",#1,fil$
INPUT #1,fsv$              !  "STARTRACK-MUSICBOX V2.0"  Versionskontrolle
IF MID$(fsv$,LEN(fsv$)-3,1)="V" THEN
fsv=VAL(RIGHT$(fsv$,3))
ELSE
fsv=0
ENDIF
IF fsv<2 THEN
INPUT #1,wurl
FOR n=1 TO wurl
INPUT #1,mbank$(n)
INPUT #1,mbank2$(n)
NEXT n
ELSE
REPEAT
EXIT IF EOF(#1)
INPUT #1,a$
@changelowkey2
IF INSTR(a$,"entrys")<>0 THEN
@delsourcekey
wurl=VAL(a$)
ENDIF
IF INSTR(a$,"name")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-4)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax4>=b THEN
mbank$(b)=a$+CHR$(0)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"path")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-4)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax4>=b THEN
mbank2$(b)=a$+CHR$(0)
ENDIF
ENDIF
ENDIF
UNTIL EOF(#1)
ENDIF
CLOSE #1
wfil$=fil$
a$="MUSICBOX-DATEI -->"+wfil$
IF LEN(a$)>50 THEN
a$="..."+RIGHT$(a$,47)
ENDIF
a$=a$+CHR$(0)
@textfeld(fsotxt&,a$,1)
IF wurl<lmax4 THEN
FOR n=wurl+1 TO lmax4
mbank$(n)=""
mbank2$(n)=""
NEXT n
ENDIF
fsz=0
fsz2=0
@mboxslidset
@clearfsel
@getsel2
ENDIF
ENDIF
RETURN
'
> PROCEDURE savefsel
IF wurl>0 THEN
@fileselect(lfw$+"*."+mbox$,setn$+"."+mbox$,"SAVE MUSICBOX:")
IF pret<>0 AND pbutt=1 THEN
OPEN "O",#1,fil$
PRINT #1,"STARTRACK-MUSICBOX V2.0"           ! Versionskontrolle
PRINT #1
PRINT #1,"entrys="+STR$(wurl)
IF wurl>0 THEN
FOR i=1 TO wurl
PRINT #1
a$=mbank$(i)
a=INSTR(a$,CHR$(0))
IF a<>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
PRINT #1,"name"+STR$(i)+"="+a$
a$=mbank2$(i)
a=INSTR(a$,CHR$(0))
IF a<>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
PRINT #1,"path"+STR$(i)+"="+a$
NEXT i
ENDIF
CLOSE #1
wfil$=fil$
a$="MUSICBOX-DATEI -->"+wfil$
IF LEN(a$)>50 THEN
a$="..."+RIGHT$(a$,47)
ENDIF
a$=a$+CHR$(0)
@textfeld(fsotxt&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE killfsel
IF fsmplay=FALSE THEN
@alerts(20)
IF g=1 THEN
IF dbank$(fsz+nfk)<>"" AND nfk<>0 THEN
dfil$=dbank2$(fsz+nfk)
@headart2(dfil$)
IF sfileart<>0 THEN
IF EXIST(dfil$) AND dfil$<>"" THEN
KILL dfil$
ENDIF
dfil2$=LEFT$(dfil$,RINSTR(dfil$,"."))+"INF"
IF EXIST(dfil2$) AND dfil$<>"" THEN
KILL dfil2$
ENDIF
dfil2$=LEFT$(dfil$,RINSTR(dfil$,"."))+"PBF"
IF EXIST(dfil2$) AND dfil$<>"" THEN
KILL dfil2$
ENDIF
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@clearfsel
fsz=0
fsz2=0
@getsel6
@getsel5
@fselslidset
@getsel2
ENDIF
ENDIF
ENDIF
ELSE
@alerts(21)
IF g=1 THEN
FOR i=1 TO wurl
mbank$(i)=""
mbank2$(i)=""
NEXT i
wurl=0
fsz=0
fsz2=0
@mboxslidset
@clearfsel
@getsel2
wfil$=""
a$=CHR$(0)
@textfeld(fsotxt&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE fselup
IF fsz2>0 THEN
xfsz=fsz
@slideup2(fsslide&,fssldbut&,fsmax,fsplus,fsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@fscalc
IF actfsel>0 THEN
actfsel=actfsel-xfsz+fsz
mfsz=actfsel
ENDIF
@fsbutset
@getsel2
ENDIF
ENDIF
RETURN
'
> PROCEDURE fseldown
IF fsz2+0.00001<(fsmax-fstep) THEN
xfsz=fsz
@slidedwn2(fsslide&,fssldbut&,fsmax,fstep,fsplus,fsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@fscalc
IF actfsel>0 THEN
actfsel=actfsel-xfsz+fsz
mfsz=actfsel
ENDIF
@fsbutset
@getsel2
ENDIF
ENDIF
RETURN
'
> PROCEDURE fselplay
IF obj=fswait& THEN
@setbutton(fsplay&,1)
ENDIF
IF nr=fsel& AND (obj=fswait& AND pwait=FALSE) THEN
pwait=TRUE
ENDIF
fsobj=obj
IF fsmplay=FALSE THEN
IF dbank$(actfsel)<>"" AND nfk<>0 THEN
vfil$=dbank2$(actfsel)
ELSE
vfil$=""
ENDIF
IF EXIST(vfil$) AND vfil$<>"" THEN
over=0
l=0
fil2$=fil$
fil$=vfil$
@tstfile
playpos=head
anspiel=plead*hz*mbit        ! 10 Sekunden anzuspielende Sektoren
handle=GEMDOS(61,L:VARPTR(vfil$),0)
IF handle>0 THEN
IF sectors>anspiel AND fsobj=fslplay& THEN
sectors=anspiel
ENDIF
@maschrufb5
~GEMDOS(62,handle)
ENDIF
fil$=fil2$
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(fsobj,0)
ENDIF
ENDIF
IF fsmplay=TRUE THEN
jz=0
fsz=0
fsz2=0
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@clearfsel
@getsel2
FOR iz=1 TO wurl
IF mbank$(iz)<>"" THEN
vfil$=mbank2$(iz)
ELSE
vfil$=""
ENDIF
IF EXIST(vfil$) AND vfil$<>"" THEN
INC jz
IF jz=1 THEN
@setbutton(fsbut1&,1)
ENDIF
IF jz=2 THEN
@setbutton(fsbut1&,0)
@setbutton(fsbut2&,1)
ENDIF
IF jz=3 THEN
@setbutton(fsbut2&,0)
@setbutton(fsbut3&,1)
ENDIF
IF jz=4 THEN
@setbutton(fsbut3&,0)
@setbutton(fsbut4&,1)
ENDIF
IF jz=5 THEN
@setbutton(fsbut4&,0)
@setbutton(fsbut5&,1)
ENDIF
IF jz=6 THEN
@setbutton(fsbut5&,0)
@setbutton(fsbut6&,1)
ENDIF
IF jz=7 THEN
@setbutton(fsbut6&,0)
@setbutton(fsbut7&,1)
ENDIF
IF jz=8 THEN
@setbutton(fsbut7&,0)
@setbutton(fsbut8&,1)
ENDIF
IF jz=9 THEN
@setbutton(fsbut8&,0)
@setbutton(fsbut9&,1)
ENDIF
IF jz=10 THEN
@setbutton(fsbut9&,0)
@setbutton(fsbut10&,1)
ENDIF
IF jz=11 THEN
@setbutton(fsbut10&,0)
@setbutton(fsbut11&,1)
ENDIF
IF jz=12 THEN
@setbutton(fsbut11&,0)
@setbutton(fsbut12&,1)
ENDIF
IF jz=13 THEN
@setbutton(fsbut12&,0)
@setbutton(fsbut13&,1)
ENDIF
IF jz=14 THEN
@setbutton(fsbut13&,0)
@setbutton(fsbut14&,1)
ENDIF
IF jz>14 THEN
IF iz<wurl THEN
INC fsz
@slidedwn2(fsslide&,fssldbut&,fsmax,fstep,fsplus,fsz2,slflg)
@clearfsel
@getsel2
@setbutton(fsbut14&,1)
ELSE
INC fsz
@setbutton(fsbut14&,0)
@setbutton(fsbut15&,1)
ENDIF
ENDIF
over=0
l=0
fil2$=fil$
fil$=vfil$
@tstfile
playpos=head
anspiel=plead*hz*mbit        ! 10 Sekunden anzuspielende Sektoren
handle=GEMDOS(61,L:VARPTR(vfil$),0)
IF handle>0 THEN
IF sectors>anspiel AND fsobj=fslplay& THEN
sectors=anspiel
ENDIF
@maschrufb5
~GEMDOS(62,handle)
ENDIF
fil$=fil2$
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
EXIT IF fsbreak=TRUE
NEXT iz
fsbreak=FALSE
a$=SPACE$(11)+CHR$(0)
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(fstime&,a$,1)
fsz=0
@setslide(fsslide&,fssldbut&,fsmax,5,fsz)
@clearfsel
@getsel2
@fselinit
ENDIF
@setbutton(fsobj,0)
@setbutton(fsplay&,0)
RETURN
'
> PROCEDURE newfsel
.| Glob. Var.: vornr#,nr#,fsel&,wurload#,zu%,fsmax#,lmax4#,fsslide&
.|     fssldbut&,fsz#,fsload&,fssave&,k#,wurl#,vop$,op$,vnam$,nam$,vfil$
.|     fil$,fsmplay#,fsmatic&,obj#,popup&,zuadr#,buttadr#,but#,objadr#
.|     objflag#,fshelp&,fsins&,buttflag#,fsdel&,a#,i#,fsordner&,fsadd&
.|     fsnew&,fsclf&,lfw$,mbox$,pret#,pbutt#,g#,dfil$,dfil2$,fsplay&,handle#
.|     playpos#,l#,sectors#,flen#,anspiel#,over#,fil2$,jz#,iz#,fsbut1&
.|     fsbut2&,fsbut3&,fsbut4&,fsbut5&,fsbut6&,fsbut7&,fsbut8&,fsbut9&
.|     fsbut10&,fsbut11&,fsbut12&,fsbut13&,fsbut14&,fsel$,ordner$,ext$
.|     fssldup&,slflg#,fsslddwn&,fsbut15&,fsexit&,fsok&,k2#
.| Felder    : wurlnr#(),dbank$(),dbank2$()
.| Ruft auf  : xrsrc_gaddr,slideinit,rsc_draw,setslide,setbutton,markhlp
.|     getsel5,rsc_do,mousek,readbutton,helptxt,clearfsel,getsel2,fileselect
.|     rsc_back,maschinit5,digout,maschruf5,slideup,fsnrset,slidedwn,getsel3
.| Aufruf in : ldhlp-1,
LOCAL j,g,x,y,k,v1,v2,v3,v4,nobj,ofil$,nx,ny
vornr=nr
nr=fsel&
~@xrsrc_gaddr(0,nr,zu%)
nfk=0
nfil$=""
vop$=op$
vnam$=nam$
vfil$=fil$
fsmplay=FALSE
fsbreak=FALSE
@hidetree2(fsload&,TRUE)
@hidetree2(fssave&,TRUE)
@hidetree2(fsdel&,TRUE)
@hidetree2(fsins&,FALSE)
@hidetree2(fsordner&,FALSE)
@hidetree2(fsadd&,FALSE)
@hidetree2(fsnew&,FALSE)
@hidetree2(fsok&,FALSE)
@readpos(fsotxt&)
@buttbh(fsotxt&,nx,ny)
IF bigfoot=FALSE THEN
@setpos(fsotxt&,179,by)
@setbuttbh(fsotxt&,444,ny)
ELSE
@setpos(fsotxt&,222,by)
@setbuttbh(fsotxt&,705,ny)
ENDIF
@readpos(fsexit&)
IF bigfoot=FALSE THEN
@setpos(fsexit&,512,by)
ELSE
@setpos(fsexit&,810,by)
ENDIF
@flagbutton(fstxt1&,0)
@flagbutton(fstxt2&,0)
@flagbutton(fstxt3&,0)
@flagbutton(fstxt4&,0)
@flagbutton(fstxt5&,0)
@flagbutton(fstxt6&,0)
@flagbutton(fstxt7&,0)
@flagbutton(fstxt8&,0)
@flagbutton(fstxt9&,0)
@flagbutton(fstxt10&,0)
@flagbutton(fstxt11&,0)
@flagbutton(fstxt12&,0)
@flagbutton(fstxt13&,0)
@flagbutton(fstxt14&,0)
@flagbutton(fstxt15&,0)
@flagbutton(fsexit&,1029)
@flagbutton(fsok&,1031)
@flagbutton(tfsearch&,0)
@hidetree2(tfsearch&,TRUE)
@textfeld2(nr,nfseltxt&,"Audioselector"+CHR$(0),1)
vshading=shading
shading=TRUE
dopix=TRUE
@busy_mouse
@analog
@digout(TRUE)
fsl=15                     ! Anzahl der lines
@fselinit
IF maxcol<>2 THEN
@textcolor(fsel&,fstxt1&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt2&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt3&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt4&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt5&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt6&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt7&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt8&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt9&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt10&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt11&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt12&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt13&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt14&,1,1,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt15&,1,1,3)  !text,rahmen,fill
ENDIF
@getsel6
@getsel5
@fselslidset
@getsel2
@setbutton(fsmatic&,0)
dopix=FALSE
shading=vshading
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
@readbutton(obj)
IF obj=fshelp& THEN
IF fsmplay=FALSE THEN
@helptxt("HYPER-FILESELECTOR")
ELSE
@helptxt("MUSICBOX")
ENDIF
ENDIF
IF obj=fsins& AND buttflag<>8 THEN
@fselinsert
PAUSE 3
@setbutton(fsins&,0)
ENDIF
IF obj=fsdel& AND buttflag<>8 THEN
@fseldelete
PAUSE 3
@setbutton(fsdel&,0)
ENDIF
IF obj=fsmatic& THEN
@fselswitch
ENDIF
IF obj=fsload& AND buttflag<>8 THEN
@loadfsel
PAUSE 3
@setbutton(fsload&,0)
ENDIF
IF obj=fssave& AND buttflag<>8 THEN
@savefsel
PAUSE 3
@setbutton(fssave&,0)
ENDIF
IF obj=fsclf& THEN
@killfsel
PAUSE 3
@setbutton(fsclf&,0)
ENDIF
IF obj=fswait& OR obj=fsplay& OR obj=fslplay& THEN
@fselplay
ENDIF
IF fsmplay=FALSE AND tfselm=FALSE THEN
IF obj=fsnew& AND buttflag<>8 THEN
OPEN "O",#1,fsel$
CLOSE #1
@setbutton(fsnew&,0)
fsmplay=FALSE
@setbutton(fsmatic&,0)
@clearfsel
fsz=0
fsz2=0
@getsel6
@getsel5
@fselslidset
@getsel2
ENDIF
IF obj=fsadd& AND buttflag<>8 THEN
IF EXIST(fsel$)=FALSE THEN
OPEN "O",#1,fsel$
CLOSE #1
ENDIF
OPEN "U",#1,fsel$
a=LOF(#1)
SEEK #1,a
PRINT #1,ordner$+"*.*"
CLOSE #1
@setbutton(fsadd&,0)
fsmplay=FALSE
@setbutton(fsmatic&,0)
@clearfsel
fsz=0
fsz2=0
@getsel6
@getsel5
@fselslidset
@getsel2
ENDIF
IF obj=fsordner& AND buttflag<>8 THEN
fsmplay=FALSE
@setbutton(fsmatic&,0)
@fileselect(op$+"*."+ext$,"","PATH:")
@setbutton(obj,0)
IF pret<>0 AND pbutt=1 THEN
op$=ordner$
ENDIF
ENDIF
ENDIF
IF obj=fssldup& THEN
@fselup
@setbutton(fssldup&,0)
ENDIF
IF obj=fsslddwn& THEN
@fseldown
@setbutton(fsslddwn&,0)
ENDIF
IF fsmplay=FALSE THEN
@ntstbut
IF n>0 THEN
actfsel=fsz+n
@getsel3
nfk=n
mfsz=fsz+nfk
ENDIF
ELSE
@ntstbut
IF n>0 THEN
@setbutton(obj,0)
ENDIF
ENDIF
IF obj=fsstop& OR obj=fsend& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=fsexit& OR obj=fsok& OR nfk<>0
IF flist>=nfk THEN
IF nfk<>0 THEN
IF dbank$(nfk)="" THEN
@setbutton(obj,0)
@getsel3
nfk=0
ENDIF
ENDIF
ELSE
@setbutton(obj,0)
ENDIF
IF nfk=0 AND obj=fsok& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=fsexit& OR (nfk<>0 AND obj=fsok& AND mfsz<=flist)
IF obj<>0 THEN
@setbutton(obj,0)
ENDIF
IF nfk2<>0 THEN
@setbutton(nfk2,0)
ENDIF
IF fsmplay=FALSE AND obj=fsok& AND dbank$(nfk)<>"" AND nfk<>0 THEN
fil$=dbank2$(fsz+nfk)
nam$=dbank$(fsz+nfk)
a=RINSTR(fil$,nam$)
ordner$=LEFT$(fil$,a-1)
pret=1
pbutt=1
ELSE
pret=0
pbutt=0
ENDIF
@rsc_back(nr)
@digout(FALSE)
nr=vornr
obj=0
'  op$=vop$
'  nam$=vnam$
'  fil$=vfil$
RETURN
'
> PROCEDURE searchcom(v)
LOCAL a,i2,i3,a$,a2$,b$,c$,src$
IF trkcom$(v)="" THEN
b$=trkpath$(v)
b$=LEFT$(b$,RINSTR(b$,"."))+"INF"+CHR$(0)
IF EXIST(b$)=TRUE THEN
OPEN "I",#2,b$
@loadloops(FALSE)
c$=src1$
d$=src2$
CLOSE #2
a$=""
IF c$<>"" AND c$<>CHR$(0) THEN
IF RIGHT$(c$,1)=CHR$(0) THEN
c$=LEFT$(c$,LEN(c$)-1)
ENDIF
a$=c$
ENDIF
IF d$<>"" AND d$<>CHR$(0) THEN
IF RIGHT$(d$,1)=CHR$(0) THEN
d$=LEFT$(d$,LEN(d$)-1)
ENDIF
IF LEN(a$)>0 THEN
a$=a$+","
ENDIF
a$=a$+d$
ENDIF
IF LEN(a$)>60 THEN
a$=LEFT$(a$,60)
ENDIF
trkcom$(v)=a$
ENDIF
ENDIF
RETURN
'
> PROCEDURE tfsgetsel1
LOCAL i,fz,i3
ERASE trktnr()
DIM trktnr(tflist)     ! Nummer in der Fileliste
fz=0
IF sabc=FALSE THEN
FOR i=1 TO trkvmax
a=trkpnt(i)
IF a<>0 THEN
REPEAT
IF trkfn$(a)<>"" AND trkch(a)<>0 THEN
INC fz
trktnr(fz)=a
a=trknext(a)
ENDIF
UNTIL a=0 OR trkch(a)=0 OR a>tflist
ENDIF
NEXT i
ELSE
'
'
ENDIF
tflist=fz
FOR i=1 TO tflist
i3=trktnr(i)
@searchcom(i3)
NEXT i
RETURN
'
> PROCEDURE tfsgetsel2
LOCAL i,j,gl,i3
IF tflist>0 THEN
j=tfsz+1
IF j+14>tflist THEN
j=tflist-14
ENDIF
IF j<1 THEN
j=1
ENDIF
i3=tfsz
gl=j+14
IF tflist<(j+14) THEN
gl=tflist-j+1
ENDIF
IF gl<1 THEN
gl=1
ENDIF
FOR i=j TO gl
IF i<=tflist THEN
i3=trktnr(i)
b$=trkfn$(i3)+CHR$(0)
IF LEN(b$)>13 THEN
b$=LEFT$(b$,12)+CHR$(0)
ENDIF
IF i=j THEN
@textfeld(fsbut1&,b$,1)
ENDIF
IF i=j+1 THEN
@textfeld(fsbut2&,b$,1)
ENDIF
IF i=j+2 THEN
@textfeld(fsbut3&,b$,1)
ENDIF
IF i=j+3 THEN
@textfeld(fsbut4&,b$,1)
ENDIF
IF i=j+4 THEN
@textfeld(fsbut5&,b$,1)
ENDIF
IF i=j+5 THEN
@textfeld(fsbut6&,b$,1)
ENDIF
IF i=j+6 THEN
@textfeld(fsbut7&,b$,1)
ENDIF
IF i=j+7 THEN
@textfeld(fsbut8&,b$,1)
ENDIF
IF i=j+8 THEN
@textfeld(fsbut9&,b$,1)
ENDIF
IF i=j+9 THEN
@textfeld(fsbut10&,b$,1)
ENDIF
IF i=j+10 THEN
@textfeld(fsbut11&,b$,1)
ENDIF
IF i=j+11 THEN
@textfeld(fsbut12&,b$,1)
ENDIF
IF i=j+12 THEN
@textfeld(fsbut13&,b$,1)
ENDIF
IF i=j+13 THEN
@textfeld(fsbut14&,b$,1)
ENDIF
IF i=j+14 THEN
@textfeld(fsbut15&,b$,1)
ENDIF
'
a$=trkcom$(i3)
a2$="000"+STR$(trkch(i3))
a$="T"+RIGHT$(a2$,3)+" "+a$
IF bigfoot=FALSE THEN
nfstl=60
ELSE
nfstl=98
ENDIF
IF LEN(a$)>nfstl THEN
a$=LEFT$(a$,nfstl)
ENDIF
a$=a$+CHR$(0)
IF i=j THEN
@textfeld(fstxt1&,a$,1)
ENDIF
IF i=j+1 THEN
@textfeld(fstxt2&,a$,1)
ENDIF
IF i=j+2 THEN
@textfeld(fstxt3&,a$,1)
ENDIF
IF i=j+3 THEN
@textfeld(fstxt4&,a$,1)
ENDIF
IF i=j+4 THEN
@textfeld(fstxt5&,a$,1)
ENDIF
IF i=j+5 THEN
@textfeld(fstxt6&,a$,1)
ENDIF
IF i=j+6 THEN
@textfeld(fstxt7&,a$,1)
ENDIF
IF i=j+7 THEN
@textfeld(fstxt8&,a$,1)
ENDIF
IF i=j+8 THEN
@textfeld(fstxt9&,a$,1)
ENDIF
IF i=j+9 THEN
@textfeld(fstxt10&,a$,1)
ENDIF
IF i=j+10 THEN
@textfeld(fstxt11&,a$,1)
ENDIF
IF i=j+11 THEN
@textfeld(fstxt12&,a$,1)
ENDIF
IF i=j+12 THEN
@textfeld(fstxt13&,a$,1)
ENDIF
IF i=j+13 THEN
@textfeld(fstxt14&,a$,1)
ENDIF
IF i=j+14 THEN
@textfeld(fstxt15&,a$,1)
ENDIF
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE tfsgetsel3
LOCAL i3
IF tnfk<>0 AND tnfk2<>0 AND obj<>tnfk2 THEN
@setbutton(tnfk2,0)
ENDIF
IF (tnfk+tfsz)>tflist THEN
@setbutton(obj,0)
tnfk=0
ENDIF
IF obj=tnfk2 AND tnfk<>0 THEN
IF (tnfk+tfsz)<=tflist THEN
i3=trktnr(tnfk+tfsz)
IF trkch(i3)<>0 THEN
@setbutton(obj,1)
ENDIF
ENDIF
ENDIF
tnfk2=obj
RETURN
'
> PROCEDURE tfsgetsel4
IF (tfso2+tfsz)<=tflist THEN
@trkcomin
tnfk2=tfso2
tmfsz2=tfsz+tnfk2
ELSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE tfsgetsel5
IF (tfso+tfsz)<=tflist THEN
@tfsgetsel3
tnfk=tfso
tmfsz=tfsz+tnfk
ELSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE tfsbutset
LOCAL a
IF tmfsz<>0 THEN
a=tmfsz-tfsz
IF a>=1 AND a<=15 THEN
IF a=1 THEN
obj=fsbut1&
ENDIF
IF a=2 THEN
obj=fsbut2&
ENDIF
IF a=3 THEN
obj=fsbut3&
ENDIF
IF a=4 THEN
obj=fsbut4&
ENDIF
IF a=5 THEN
obj=fsbut5&
ENDIF
IF a=6 THEN
obj=fsbut6&
ENDIF
IF a=7 THEN
obj=fsbut7&
ENDIF
IF a=8 THEN
obj=fsbut8&
ENDIF
IF a=9 THEN
obj=fsbut9&
ENDIF
IF a=10 THEN
obj=fsbut10&
ENDIF
IF a=11 THEN
obj=fsbut11&
ENDIF
IF a=12 THEN
obj=fsbut12&
ENDIF
IF a=13 THEN
obj=fsbut13&
ENDIF
IF a=14 THEN
obj=fsbut14&
ENDIF
IF a=15 THEN
obj=fsbut15&
ENDIF
@setbutton(obj,1)
tnfk=a
tmfsz=tfsz+tnfk
tnfk2=obj
ENDIF
ENDIF
RETURN
'
> PROCEDURE tfscalc
tfsz=tflist/tfsmax*tfsz2
IF tfsz2>tfsmax-tfstep THEN
tfsz2=tfsmax-tfstep
@setslide2(fsslide&,fssldbut&,tfsmax,tfsz2,tfstep)
ENDIF
IF tfsz>(tflist-14) THEN
tfsz=tflist-15
ENDIF
IF tfsz<0 THEN
tfsz=0
ENDIF
tfsz=ROUND(tfsz)
RETURN
'
> PROCEDURE fselsearchup
IF tfsz2>0 THEN
xfsz=tfsz
@slideup2(fsslide&,fssldbut&,tfsmax,tfsplus,tfsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@tfscalc
IF tmfsz>0 THEN
tmfsz=tmfsz-xfsz+tfsz
ENDIF
@tfsbutset
@tfsgetsel2
ENDIF
ENDIF
RETURN
'
> PROCEDURE fselsearchdown
xfsz=tfsz
@slidedwn2(fsslide&,fssldbut&,tfsmax,tfstep,tfsplus,tfsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@tfscalc
IF tmfsz>0 THEN
tmfsz=tmfsz-xfsz+tfsz
ENDIF
@tfsbutset
@tfsgetsel2
ENDIF
RETURN
'
> PROCEDURE tfsearch
LOCAL j
@testcopyright
vop$=op$
vnam$=enam$
vfil$=efil$
tfobj=obj
IF trkz>0 THEN
vornr=nr
nr=fsel&
tfselm=TRUE
~@xrsrc_gaddr(0,nr,zu%)
tnfk=0
tfsz=0
tfsz2=0
@hidetree2(fstime&,TRUE)
@hidetree2(fsins&,TRUE)
@hidetree2(fsmatic&,TRUE)
@hidetree2(fsdel&,TRUE)
@hidetree2(fsload&,TRUE)
@hidetree2(fssave&,TRUE)
@hidetree2(fsclf&,TRUE)
@hidetree2(fsend&,TRUE)
@hidetree2(fswait&,TRUE)
@hidetree2(fsstop&,TRUE)
@hidetree2(fsplay&,TRUE)
@hidetree2(fslplay&,TRUE)
@hidetree2(fsordner&,TRUE)
@hidetree2(fsadd&,TRUE)
@hidetree2(fsnew&,TRUE)
@hidetree2(fsotxt&,TRUE)
@hidetree2(tfsabc&,FALSE)
@hidetree2(tfsearch&,FALSE)
@hidetree2(fsok&,TRUE)
@flagbutton(fstxt1&,1089)
@flagbutton(fstxt2&,1089)
@flagbutton(fstxt3&,1089)
@flagbutton(fstxt4&,1089)
@flagbutton(fstxt5&,1089)
@flagbutton(fstxt6&,1089)
@flagbutton(fstxt7&,1089)
@flagbutton(fstxt8&,1089)
@flagbutton(fstxt9&,1089)
@flagbutton(fstxt10&,1089)
@flagbutton(fstxt11&,1089)
@flagbutton(fstxt12&,1089)
@flagbutton(fstxt13&,1089)
@flagbutton(fstxt14&,1089)
@flagbutton(fstxt15&,1089)
@flagbutton(fsexit&,1029)
@flagbutton(fsok&,0)
@flagbutton(tfsearch&,1031)
@textfeld2(nr,nfseltxt&,"Trackfinder"+CHR$(0),1)
IF maxcol<>2 THEN
@textcolor(fsel&,fstxt1&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt2&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt3&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt4&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt5&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt6&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt7&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt8&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt9&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt10&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt11&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt12&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt13&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt14&,1,4,3)  !text,rahmen,fill
@textcolor(fsel&,fstxt15&,1,4,3)  !text,rahmen,fill
ENDIF
@readpos(fsexit&)
IF bigfoot=FALSE THEN
@setpos(fsexit&,496,by)
ELSE
@setpos(fsexit&,786,by)
ENDIF
vshading=shading
shading=TRUE
dopix=TRUE
tflist=trkz
@slidelen(fsslide&,fssldbut&,v,tfsbr)
tmfsz=0
tfsl=15                         ! Anzahl der lines
tflist2=tflist
IF tflist2<tfsl THEN
tflist2=tfsl
ENDIF
tfbbut=INT(tfsbr/tflist2*tfsl)   ! Buttonbreite
tfsmax=tfsbr                     ! Breite des Sliders
tfstep=tfsmax/tflist2*tfsl       ! Schrittweite des Sliders
tfsplus=tfsmax/tflist2           ! Einzelschritt
@slideinit(fsslide&,fssldbut&,tfsmax,tfbbut,tfsz)
@setslide(fsslide&,fssldbut&,tfsmax,tfbbut,tfsz)
@markhlp
@busy_mouse
@clearfsel
@tfsgetsel1
@tfsgetsel2
dopix=FALSE
shading=vshading
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@rsc_draw(nr,0)
@rsc_state(nr,fsordner&,3,TRUE)
@rsc_state(nr,fsadd&,3,TRUE)
@rsc_state(nr,fsnew&,3,TRUE)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
@readbutton(obj)
IF obj=fshelp& THEN
@helptxt("TRACK-SEARCH")
ENDIF
IF obj=fssldup& THEN
@fselsearchup
@setbutton(fssldup&,0)
ENDIF
IF obj=fsslddwn& THEN
@fselsearchdown
@setbutton(fsslddwn&,0)
ENDIF
IF obj=tfsabc& THEN
@tfselabc
ENDIF
IF obj=fsbut1& THEN
tfso=1
@tfsgetsel5
ENDIF
IF obj=fsbut2& THEN
tfso=2
@tfsgetsel5
ENDIF
IF obj=fsbut3& THEN
tfso=3
@tfsgetsel5
ENDIF
IF obj=fsbut4& THEN
tfso=4
@tfsgetsel5
ENDIF
IF obj=fsbut5& THEN
tfso=5
@tfsgetsel5
ENDIF
IF obj=fsbut6& THEN
tfso=6
@tfsgetsel5
ENDIF
IF obj=fsbut7& THEN
tfso=7
@tfsgetsel5
ENDIF
IF obj=fsbut8& THEN
tfso=8
@tfsgetsel5
ENDIF
IF obj=fsbut9& THEN
tfso=9
@tfsgetsel5
ENDIF
IF obj=fsbut10& THEN
tfso=10
@tfsgetsel5
ENDIF
IF obj=fsbut11& THEN
tfso=11
@tfsgetsel5
ENDIF
IF obj=fsbut12& THEN
tfso=12
@tfsgetsel5
ENDIF
IF obj=fsbut13& THEN
tfso=13
@tfsgetsel5
ENDIF
IF obj=fsbut14& THEN
tfso=14
@tfsgetsel5
ENDIF
IF obj=fsbut15& THEN
tfso=15
@tfsgetsel5
ENDIF
IF obj=fstxt1& THEN
tfso2=1
@tfsgetsel4
ENDIF
IF obj=fstxt2& THEN
tfso2=2
@tfsgetsel4
ENDIF
IF obj=fstxt3& THEN
tfso2=3
@tfsgetsel4
ENDIF
IF obj=fstxt4& THEN
tfso2=4
@tfsgetsel4
ENDIF
IF obj=fstxt5& THEN
tfso2=5
@tfsgetsel4
ENDIF
IF obj=fstxt6& THEN
tfso2=6
@tfsgetsel4
ENDIF
IF obj=fstxt7& THEN
tfso2=7
@tfsgetsel4
ENDIF
IF obj=fstxt8& THEN
tfso2=8
@tfsgetsel4
ENDIF
IF obj=fstxt9& THEN
tfso2=9
@tfsgetsel4
ENDIF
IF obj=fstxt10& THEN
tfso2=10
@tfsgetsel4
ENDIF
IF obj=fstxt11& THEN
tfso2=11
@tfsgetsel4
ENDIF
IF obj=fstxt12& THEN
tfso2=12
@tfsgetsel4
ENDIF
IF obj=fstxt13& THEN
tfso2=13
@tfsgetsel4
ENDIF
IF obj=fstxt14& THEN
tfso2=14
@tfsgetsel4
ENDIF
IF obj=fstxt15& THEN
tfso2=15
@tfsgetsel4
ENDIF
UNTIL obj=fsexit& OR obj=tfsearch& OR tnfk<>0
IF tnfk=0 AND obj=fsearch& THEN
@setbutton(obj,0)
ENDIF
IF obj=tfsearch& AND NOT (tnfk<>0 AND tmfsz<=tflist) THEN
@setbutton(tfsearch&,0)
ENDIF
UNTIL obj=fsexit& OR (tnfk<>0 AND obj=tfsearch& AND tmfsz<=tflist)
IF obj=tfsearch& THEN
@makesearch
ENDIF
IF obj<>0 THEN
@setbutton(obj,0)
ENDIF
IF tnfk2<>0 THEN
@setbutton(tnfk2,0)
ENDIF
@hidetree2(fstime&,FALSE)
@hidetree2(fsins&,FALSE)
@hidetree2(fsmatic&,FALSE)
@hidetree2(fsdel&,FALSE)
@hidetree2(fsload&,FALSE)
@hidetree2(fssave&,FALSE)
@hidetree2(fsclf&,FALSE)
@hidetree2(fsend&,FALSE)
@hidetree2(fswait&,FALSE)
@hidetree2(fsstop&,FALSE)
@hidetree2(fsplay&,FALSE)
@hidetree2(fslplay&,FALSE)
@hidetree2(fsordner&,FALSE)
@hidetree2(fsadd&,FALSE)
@hidetree2(fsnew&,FALSE)
@hidetree2(fsotxt&,FALSE)
@hidetree2(tfsabc&,TRUE)
@hidetree2(tfsearch&,TRUE)
@hidetree2(fsok&,FALSE)
@rsc_state(nr,fsordner&,3,FALSE)
@rsc_state(nr,fsadd&,3,FALSE)
@rsc_state(nr,fsnew&,3,FALSE)
@readpos(fsexit&)
IF bigfoot=FALSE THEN
@setpos(fsexit&,520,by)
ELSE
@setpos(fsexit&,810,by)
ENDIF
@rsc_back(nr)
nr=vornr
@wischwasch
IF obj=tfsearch& THEN
@makesearch2
ENDIF
ENDIF
@setbutton(tfobj,0)
obj=0
op$=vop$
enam$=vnam$
efil$=vfil$
tfselm=FALSE
RETURN
'
> PROCEDURE trkcomin
LOCAL to,a,am$,i3
@testcopyright
to=tfso2+tfsz
mrkobj=obj
vorvornr=vornr
vornr=nr
@rsc_back(nr)
@wischwasch
nr=trkcomin&
i3=trktnr(to)
a$=trkcom$(i3)
IF LEN(a$)>60 THEN
a$=LEFT$(a$,60)+CHR$(0)
ENDIF
a$=a$+CHR$(0)
@editfeld2(nr,trkctxin&,a$)
@rsc_draw(nr,0)
@wischwasch
@markhlp
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>trkctxin&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=trkchlp& THEN
@helptxt("TRACK-KOMMENTAR")
ENDIF
UNTIL obj=trkcexit& OR obj=trkcok&
IF obj=trkcok& THEN
timedraw=TRUE
editread(trkctxin&)
a=INSTR(a$,CHR$(0))
IF a>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
IF LEN(a$)>60 THEN
a$=LEFT$(a$,60)
ENDIF
trkcom$(i3)=a$
ENDIF
@setbutton(obj,0)
xobj=obj
edit_obj&=0
obj&=0
obj=0
@restaura2
@rsc_draw(nr,0)
IF xobj=trkcok& THEN
a$=trkcom$(i3)+CHR$(0)
@textfeld(mrkobj,a$,1)
ENDIF
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
edit_obj&=0
obj&=0
obj=0
RETURN
'
> PROCEDURE tfselabc
IF sabc=FALSE THEN
sabc=TRUE
@setbutton(obj,1)
ELSE
sabc=FALSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE restaura
.| Ruft auf  : restaura3,restaura4
.| Aufruf in : button-2,fade_it-2,smpkhlp-2,smpmhlp-2,smpihlp-2,zoomhelp-1
.|     smpl-2,smpr-2,edhandler2-1,rubbermax-1,zoomcalc-1,do_smpedit-3
.|     trash-1,negate-1,lrchange-1,smpplay-1,record3-2,
'  @rsc_back(nr)
@restaura3
@restaura4
RETURN
'
> PROCEDURE blkrestaura
.| Glob. Var.: nr#,smpedit&,winh#
.| Ruft auf  : restaura3,restaura4
.| Aufruf in : normalize-1,smpcut-1,resample-1,conmix-1,mono-1,negate-1
.|     lrchange-1,
LOCAL bnr
nr=smpedit&
IF BTST(winh,smpedit&)=TRUE THEN
@editselect
@restaura3
@restaura4
ENDIF
nr=blkfunc&
@editselect
@restaura3
@restaura4
RETURN
'
> PROCEDURE restaura2
.| Glob. Var.: nr#,vornr#,winh#
.| Ruft auf  : rsc_back
.| Aufruf in : smptime-1,movefrag-1,smpsave-1,sampleinf-1,arrsmpr-1
.|     arrdelay-1,arrmname-1,virtual-1,abackup-1,makeaback-1,time_edit-1
.|     make-1,setupdat-1,midi-1,do_dsp-1,
@rsc_back(nr)
nr=vornr
@wischwasch
IF BTST(winh,nr)=TRUE THEN
'    @restaura3
'    @restaura4
ENDIF
RETURN
'
> PROCEDURE restaura2b
.| Glob. Var.: nr#
.| Ruft auf  : rsc_back
.| Aufruf in : do_main-1,fade-1,do_arrange-1,do_trakker-1,do_blkf-1
.|     do_info-1,do_loop-1,do_peak-1,
@rsc_back(nr)
@wischwasch
RETURN
'
> PROCEDURE restaura3
.| Glob. Var.: nr#,smp16&,i#
.| Ruft auf  : rsc_redraw_obj
.| Aufruf in : restaura-1,blkrestaura-2,sampleinf-1,
IF nr=smp16& THEN
i=7
ELSE
i=5
ENDIF
@wischwasch
@rsc_redraw_obj(nr,0)
@wischwasch
RETURN
'
> PROCEDURE restaura4
.| Glob. Var.: nr#,smpedit&,cs#,ce#,sblock#,smppmark&,sloop#,smploop&
.| Ruft auf  : curve,markprod3,setbutton
.| Aufruf in : smpsave-1,restaura-1,blkrestaura-2,smpload-1,
IF nr=smpedit& THEN
@curve(cs,ce)
@markprod3
@getcurve
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF sloop!=FALSE THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
ENDIF
@wischwasch
RETURN
'
> PROCEDURE restaura4b
IF nr=smpedit& THEN
@curve(cs,ce)
@markprod3b
@getcurve
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF sloop!=FALSE THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
ENDIF
@wischwasch
RETURN
'
> PROCEDURE restaura5
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF sloop!=FALSE THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
RETURN
'
> PROCEDURE smpload
.| Glob. Var.: mrkobj#,memlmrk#,meml#,secmrk#,sec#,anfloadx#,smplen#,abz#
.|     vmem#,lready#,savexit&,smpnam$,pathda#,nr#,smpedit&,cs#,ce#,extclock#
.|     hz#,a$,popups&,rate32&,rate&,rate44&,rate48&,smpload&
.| Ruft auf  : ldhlp,fnamwrite,curve,restaura4,textfeld,adlow,admid,adhigh
.|     setbutton
.| Aufruf in : drop2-1,do_smpedit-1,
IF ldtrk3=FALSE THEN
mrkobj=0
memlmrk=meml
secmrk=sec
@ldhlp
IF anfloadx<>0 AND anfloadx<>-1 AND (smplen-abz)<=vmem AND lready=1 AND mrkobj<>savexit& THEN
IF smpnam$<>"" AND pathda=TRUE THEN
@fnamwrite
IF nr=smpedit& THEN
IF edclr=TRUE AND virtex=FALSE THEN
@restaura3
@restaura4b
ENDIF
ENDIF
@fliphz
@fliphz2
cueorig$=efil$
ENDIF
ELSE
IF pathda=FALSE THEN
IF nr=smpedit& THEN
IF edclr=TRUE AND virtex=FALSE THEN
@restaura3
@restaura4b
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF nr=smpedit& THEN
IF neufsel=FALSE THEN
@setbutton(smpload&,0)
ELSE
@setbutton(smpdbank&,0)
ENDIF
ENDIF
edclr=FALSE
virtex=FALSE
RETURN
'
> PROCEDURE marksearch
.| Glob. Var.: markfull#,loopz#,markfre#
.| Felder    : loops#(),loope#()
.| Aufruf in : findblock-1,sampleinf-2,
LOCAL ex,i
markfull=FALSE
ex=FALSE
FOR i=1 TO loopz
IF ((loops%(i,1)=0 AND loops%(i,2)=0 AND loops%(i,3)=0 AND loops%(i,4)=0) OR (loops%(i,1)=-1 AND loops%(i,2)=-1 AND loops%(i,3)=-1 AND loops%(i,4)=-1)) AND ex=FALSE THEN
markfre=i
ex=TRUE
ENDIF
EXIT IF ex=TRUE
NEXT i
IF ex=FALSE THEN
markfre=1
markfull=TRUE
ENDIF
RETURN
'
> PROCEDURE blkltest
.| Glob. Var.: bpos#,master#,bstart#,loopz#,dist#,ce#,cs#,blks#,conc#,meml#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp
.| Aufruf in : ldhlp-1,conspace-1,coninsert-1,
@markhlp
bpos=0
IF sms=0 THEN
bstart=0
ENDIF
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
bstart=loops%(sms,sms2)
ENDIF
dist=ce-cs
IF blks=1 THEN
bpos=bstart
ENDIF
'
conc=0
IF sms>0 AND sms<=loopz AND sms2<>0 AND loops%(sms,1)<>-1 THEN
conc=loops%(sms,1)
ENDIF
'
'  conc=bstart
bstart=bstart+meml
bstart=INT(bstart/mbit)*mbit
RETURN
'
> PROCEDURE fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
.| Glob. Var.: pret#,pbutt#
.| Ruft auf  : ain
.| Aufruf in : fileselect-1,
LPOKE ADDRIN,fs_iinpath%
LPOKE ADDRIN+4,fs_iinsel%
LPOKE ADDRIN+8,fs_iinlabel%
@ain(91,0,2,3,0)
pret=GINTOUT(0)
pbutt=GINTOUT(1)
RETURN
'
> PROCEDURE ain(g0%,g2%,g4%,g6%,g8%)
.| Aufruf in : fsel_exinput-1,
DPOKE GCONTRL,g0%
DPOKE GCONTRL+2,g2%
DPOKE GCONTRL+4,g4%
DPOKE GCONTRL+6,g6%
DPOKE GCONTRL+8,g8%
GEMSYS
RETURN
'
> PROCEDURE fileselect(a$,b$,c$)
.| Glob. Var.: fs_iinpath%,fs_iinsel%,fs_iinlabel%,a#,ordner$,nam$,fil$
.| Ruft auf  : fsel_exinput
.| Aufruf in : fadesave-1,fadeload-1,smpsave-1,newfsel-3,ldhlp-1,trakload-1
.|     hardfs-1,arrload-1,arrsave-1,make-1,fseldef-1,coninsert-1,smpplay-1
.|     record3-1,
@testcopyright
~GRAF_MOUSE(256,0)                              ! Hidem
'  ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
a$=a$+CHR$(0)+SPACE$(100)
fs_iinpath%=VARPTR(a$)
b$=b$+CHR$(0)+SPACE$(100)
fs_iinsel%=VARPTR(b$)
c$=c$+CHR$(0)+SPACE$(100)
fs_iinlabel%=VARPTR(c$)
@fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
a=INSTR(a$,CHR$(0))
a$=LEFT$(a$,a-1)
a=INSTR(b$,CHR$(0))
b$=LEFT$(b$,a-1)
a=RINSTR(a$,"\")
IF LEN(a$)=0 THEN
ordner$=""
ELSE
ordner$=LEFT$(a$,a)
ENDIF
IF LEN(b$)=0 THEN
nam$=""
fil$=""
ELSE
nam$=b$
fil$=ordner$+b$
ENDIF
IF nr=fsel& THEN
@rsc_back(nr)
@rsc_draw(nr,0)
ENDIF
'  @rsc_put(ab,rscx&(nr),rscy&(nr),1)
'  @rsc_redraw_obj(nr,0)
REPEAT
UNTIL @mousek=0
@wischwasch
RETURN
'
> PROCEDURE markset
.| Glob. Var.: markfre#,sms#,sme#,ah#,ah2#,nr#,smpedit&,t$,loopz#
.| Felder    : loope#(),loops#()
.| Ruft auf  : selblksbut,selblkebut,markhlp6,markhlp3
.| Aufruf in : sampleinf-1,
LOCAL j
IF markfre=i THEN
sms=i
loops%(sms,1)=ah2
loops%(sms,2)=ah
IF nr=smpedit& THEN
@edmarkset(sms)
FOR j=1 TO 4
@marktextsel(j)
@markhlp6(loops%(sms,j))
NEXT j
FOR j=1 TO 4
@markhlp3(sms,j,loops%(sms,j))
NEXT j
ENDIF
ENDIF
RETURN
'
> PROCEDURE ldhztest   ! énderung am 13.9.98 wegen flipphz
.| Glob. Var.: extclock#,per#,hz#,nr#,smp16&,a$,popups&,ad32&,rate2&,ad44&
.|     ad48&,retime#,hzm#,sblock#,sret#,smpedit&,fileart#,smppmark&
.| Ruft auf  : textfeld,adlow,admid,adhigh,setbutton
.| Aufruf in : ldhlp-6,ldhead-1,
hz=per
edhz=hz      ! neu sei 13.9.98
@fliphz
@fliphz2
'
IF per<>8000 AND per<>11025 AND per<>12000 AND per<>16000 AND per<>16538 AND per<>22050 AND per<>24000 AND per<>33075 AND per<>66150 AND per<>128 AND per<>192 AND per<>256 AND per<>384 AND per<>32000 AND per<>44100 AND per<>48000 THEN
IF per<>88200 AND per<>96000 THEN
retime=1
per=@hzanalye(per)
hz=per
hzm=hz
ENDIF
ENDIF
'  sblock=0
'  sret=0
IF nr=smpedit& AND (fileart=5 OR fileart=4) THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE writehzm
.| Glob. Var.: retime#,hz#,hzm#,p$,nr#,smpedit&,smprate&,smp16&
.| Ruft auf  : textfeld,deladbutt
.| Aufruf in : ldready-1,
IF retime=1 THEN
hz=hzm
p$=STR$(hzm/1000)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
IF nr=smp16& THEN
@fliphz
ENDIF
ELSE
p$="    "+CHR$(0)
IF nr=smpedit& THEN
@textfeld(smprate&,p$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE sdload
.| Glob. Var.: loded#,ea#,eb#,ret#,hdl#,al$,head#,datx#,samlen#,mdat%,hbuf#
.|     a#,ar$,g#,ec#,fil$
.| Ruft auf  : maschinit37,maschruf37
.| Aufruf in : ldhlp-2,
loded=FALSE
IF ea=TRUE AND eb=TRUE THEN
ret=0
hdl=GEMDOS(61,L:VARPTR(al$),0)
~GEMDOS(66,L:head,hdl,0)
@maschruf37(datx,datx+samlen,mdat%+2048,mdat%+hbuf-mbit,hdl,ret)
a=GEMDOS(62,hdl)
IF ret=(datx+samlen) THEN
ret=0
hdl=GEMDOS(61,L:VARPTR(ar$),0)
~GEMDOS(66,L:head,hdl,0)
@maschruf37(datx+2,datx+samlen+2,mdat%+2048,mdat%+hbuf-mbit,hdl,ret)
~GEMDOS(62,hdl)
IF ret<>datx+samlen+2 THEN
@alerts(22)
loded=FALSE
ELSE
loded=TRUE
IF ec=FALSE THEN
a=RINSTR(fil$,".")
fil$=LEFT$(fil$,a-2)+RIGHT$(fil$,LEN(fil$)-a+1)
ENDIF
ENDIF
ELSE
loded=FALSE
@alerts(22)
ENDIF
ELSE
@alerts(23)
loded=FALSE
ENDIF
RETURN
'
> PROCEDURE blkupdate
LOCAL j
IF nr=smpedit& THEN
@makehz
@sethertz
FOR j=1 TO 4
IF loops%(sms,j)<>-1 THEN
@marktextsel(j)
IF memc=0 OR cached=FALSE OR drawnew2=TRUE THEN
@markhlp6(loops%(sms,j))
ENDIF
ENDIF
NEXT j
ENDIF
RETURN
'
> PROCEDURE findblock
.| Glob. Var.: sa#,se#,ah2#,bpos#,ah#,vmem#,sret#,a#,sblock#,markfre#
.|     markfull#,sms#,sme#,nr#,smpedit&,loopz#
.| Felder    : loope#(),loops#()
.| Ruft auf  : marksearch,markhlp3
.| Aufruf in : ldhlp-1,sampleinf-1,
LOCAL a
ah4=se2
ah3=sa2
ah2=se
ah=sa
nomark1=FALSE
IF ah2<>-1 THEN
IF blockpos=FALSE THEN
ah2=se+bpos
ELSE
ah2=se-bpos2
ENDIF
IF ah2<0 OR ah2>vmem THEN
nomark1=TRUE
ENDIF
ENDIF
IF ah<>-1 THEN
IF blockpos=FALSE THEN
ah=sa+bpos
ELSE
ah=sa-bpos2
ENDIF
IF ah<0 OR ah>vmem THEN
nomark1=TRUE
ENDIF
ENDIF
IF nomark1=TRUE THEN
ah2=-1
ah=-1
ELSE
sblock=1
ENDIF
nomark2=FALSE
IF ah3<>-1 THEN
IF blockpos=FALSE THEN
ah3=sa2+bpos
ELSE
ah3=sa2-bpos2
ENDIF
IF ah3<0 OR ah3>vmem THEN
nomark2=TRUE
ENDIF
ENDIF
IF ah4<>-1 THEN
IF blockpos=FALSE THEN
ah4=se2+bpos
ELSE
ah4=se2-bpos2
ENDIF
IF ah4<0 OR ah4>vmem THEN
nomark2=TRUE
ENDIF
ENDIF
IF nomark2=TRUE THEN
ah3=-1
ah4=-1
ELSE
sblock=1
ENDIF
IF ah2<ah AND ah2<>-1 AND ah<>-1 THEN
sret=1                ! RÅckwÑrts-Loop
a=ah2
ah2=ah
ah=a
ENDIF
IF blks=0 THEN
sms=1
ENDIF
IF ah=-1 AND ah2=-1 AND ah3=-1 AND ah4=-1 THEN
nomark=TRUE
ELSE
nomark=FALSE
ENDIF
loops%(markfre,1)=ah
loops%(markfre,2)=ah2
loops%(markfre,3)=ah3
loops%(markfre,4)=ah4
IF LEN(ah$)>25 THEN
ah$=LEFT$(ah$,25)
ENDIF
edmtxt$(markfre)=ah$
'  IF nr=smpedit& THEN
'  @markhlp3(markfre,1,loops%(markfre,1))
'  @markhlp3(markfre,2,loops%(markfre,2))
'  @markhlp3(markfre,3,loops%(markfre,3))
'  @markhlp3(markfre,4,loops%(markfre,4))
' ENDIF
RETURN
'
> PROCEDURE ldready
.| Glob. Var.: sms#,loopz#,sme#,cached#,loded#,lz#,path$,fil$,smpnam$,bnam$
.| Ruft auf  : selblksbut,selblkebut,writehzm
.| Aufruf in : ldhlp-7,
IF sms>0 AND sms<=loopz AND nr=smpedit& THEN
@edmarkset(sms)
ENDIF
cached=FALSE
loded=TRUE
lz=1
path$=fil$
smpnam$=bnam$
@writehzm
RETURN
'
> PROCEDURE fileart
head=0
fileart=0
abz=DPEEK(datx)
abz2=LPEEK(datx)
IF abz=&HF07E THEN
head=20   ! HeaderlÑnge fÅr S16-Files
fileart=1
IF RIGHT$(fil$,4)=".S16" THEN
@setbitrate16
ENDIF
IF RIGHT$(fil$,4)=".S24" THEN
@setbitrate24
ENDIF
ENDIF
IF abz2=&H32424954 THEN
head=128   ! HeaderlÑnge fÅr AVR-Files
fileart=2
ENDIF
IF abz2=&H52494646 THEN
head=44   ! HeaderlÑnge fÅr WAV-Files
fileart=3
ENDIF
IF abz2=&H2E736E64 THEN
head=28   ! HeaderlÑnge fÅr AU und SND-Files
fileart=4
ENDIF
abz=head
IF abz2=&H538000C THEN
head=1336 ! HeaderlÑnge fÅr SD-Files
fileart=5
IF virtld=FALSE THEN
ln=ln*2
ENDIF
abz=head*2+8
ENDIF
IF abz2=&HF07E0001 THEN
head=296 ! HeaderlÑnge fÅr Avalon SMP-Files
fileart=6
IF virtld=FALSE THEN
ln=ln*2
ENDIF
abz=head*2+8
ENDIF
IF abz2=&H464F524D THEN
head=54+458   ! HeaderlÑnge fÅr AIFF-Files
fileart=7
ENDIF
RETURN
'
> PROCEDURE fileart2
IF fileart=6 THEN
SEEK #1,LOF(#1)-head
ENDIF
BGET #1,datx,head
IF fileart=6 THEN
SEEK #1,20
ENDIF
RETURN
'
> PROCEDURE setpeakblks
pkdb=ROUND(db16)                ! dB-Auflîsung
pkt=pkdb/LOG10(65535)
'
pkg0=ROUND(10^((pkdb-48)/pkt)/2)   ! BinÑr-Grenzen
pkg1=ROUND(10^((pkdb-24)/pkt)/2)
pkg2=ROUND(10^((pkdb-12)/pkt)/2)
pkg3=ROUND(10^((pkdb-8)/pkt)/2)
pkg4=ROUND(10^((pkdb-6)/pkt)/2)
pkg5=ROUND(10^((pkdb-4)/pkt)/2)
pkg6=ROUND(10^((pkdb-3)/pkt)/2)
pkg7=ROUND(10^((pkdb-2)/pkt)/2)
pkg8=ROUND(10^((pkdb-1)/pkt)/2)
pkg9=ROUND(10^((pkdb-0)/pkt)/2)
pkdb0=ROUND(pkt*LOG10(pkg0*2))     ! dB-Grenzen
pkdb1=ROUND(pkt*LOG10(pkg1*2))
pkdb2=ROUND(pkt*LOG10(pkg2*2))
pkdb3=ROUND(pkt*LOG10(pkg3*2))
pkdb4=ROUND(pkt*LOG10(pkg4*2))
pkdb5=ROUND(pkt*LOG10(pkg5*2))
pkdb6=ROUND(pkt*LOG10(pkg6*2))
pkdb7=ROUND(pkt*LOG10(pkg7*2))
pkdb8=ROUND(pkt*LOG10(pkg8*2))
pkdb9=ROUND(pkt*LOG10(pkg9*2))
RETURN
'
> PROCEDURE setbitrate16
dig24=FALSE
mbit=4
aufloes=db16       ! dB-Aufloesung der Wandler (16Bit)
IF demo=FALSE THEN
~XBIOS(xbs,28,0)
ENDIF
IF rscda=TRUE THEN
IF nr=smpedit& THEN
IF bigfoot=TRUE THEN
a$=@rsc_text$(popups&,bitp16&)
@textfeld(resolu&,a$,1)
ELSE
@textfeld(resolu&,"16 BIT"+CHR$(0),1)
ENDIF
ELSE
IF bigfoot=TRUE THEN
a$=@rsc_text$(popups&,bitp16&)
@textfeld2(smpedit&,resolu&,a$,1)
ELSE
@textfeld2(smpedit&,resolu&,"16 BIT"+CHR$(0),1)
ENDIF
ENDIF
ENDIF
IF ext$="S16" OR ext$="S24" THEN
ext$="S16"
ENDIF
IF ext2$="S16" OR ext2$="S24" THEN
ext2$="S16"
ENDIF
RETURN
'
> PROCEDURE setbitrate24
dig24=TRUE
mbit=6
aufloes=db24       ! dB-Aufloesung der Wandler (16Bit)
matrix=FALSE
rmo8=FALSE
mixdsp=FALSE
IF demo=FALSE THEN
~XBIOS(xbs,28,1)
ENDIF
IF rscda=TRUE THEN
IF nr=smpedit& THEN
IF bigfoot=TRUE THEN
a$=@rsc_text$(popups&,bitp24&)
@textfeld(resolu&,a$,1)
ELSE
@textfeld(resolu&,"24 BIT"+CHR$(0),1)
ENDIF
ELSE
IF bigfoot=TRUE THEN
a$=@rsc_text$(popups&,bitp24&)
@textfeld2(smpedit&,resolu&,a$,1)
ELSE
@textfeld2(smpedit&,resolu&,"24 BIT"+CHR$(0),1)
ENDIF
ENDIF
ENDIF
IF ext$="S16" OR ext$="S24" THEN
ext$="S24"
ENDIF
IF ext2$="S16" OR ext2$="S24" THEN
ext2$="S24"
ENDIF
RETURN
'
> PROCEDURE ldhlp
.| Glob. Var.: loded#,inf#,virtual#,rett#,virt$,virt2$,virtld#,blockld#
.|     mrkobj#,obj#,savexit&,retime#,shlp#,lready#,cs#,ce#,vmem#,head#,x#,y#
.|     w#,h#,neufsel#,op$,ext$,pathda#,fil$,pret#,pbutt#,datx#,mdat%,ln#
.|     mlen#,blks#,anfloadx#,meml#,mt#,bstart#,memh#,fileart#,abz#,abz2#
.|     ln2#,lded#,danf#,vfileart#,vhead#,vhbldstrt#,hbldlen#,a#,tst1#,per#
.|     samlen#,ec#,al$,ar$,ea#,eb#,bnam$,nam$,smplen#,sblock#,j#,sa#,se#,nr#
.|     smpedit&,smppmark&,okmark#,sms#,sme#,vlmin#,lmin#,vlma#,lma#,tst2#
.|     dazu#,tst3#,tst4#,tst5#,tst6#,dmagic#,ov#,la#,sret#,ah#,bpos#,ah2#
.|     x2#,y2#,ldlen#,perm#,x3#,y3#,x4#,y4#,hz#,hzm#,b#,l#,smrk#,big#
.|     virtcurve#,maxcwert#,profln#,profhz#,vtst#,mbs#,vorln#,lz#,hard&
.|     vmeml#,vmemh#,hrd#,vce#,vcs#,virtex#,g#,lmax3#,vmbs#,zoomp#
.| Felder    : bloops#(),bloope#(),mblocks#(),mblocke#(),mblockp$()
.| Ruft auf  : infhol,blklfrag,maschinit,newfsel,fileselect,busy_mouse
.|     blkltest,markdel,clsed,markhlp,ldhztest,sampleinf,findblock,setbutton
.|     sdload,maschinit38,maschruf38,ldready,maschinit28,maschruf28,makehz
.|     maschruf,ldhead,virtual,ldhlp,hardproof,infrett,fnamwrite,zslidecalc
.| Aufruf in : smpload-1,ldhlp-2,
lsret=sret
loded=FALSE
inf=FALSE
'
IF NOT ((virtld=TRUE AND (blockld=TRUE OR virtual=TRUE)) OR (virtld=FALSE AND blockld=FALSE AND virtual=FALSE)) THEN
@alerts(65)
IF g=1 THEN
trashalert=TRUE
@trash
trashalert=FALSE
ENDIF
ENDIF
'
@infhol
IF virtual=FALSE AND rett=TRUE THEN
IF EXIST(virt$)=TRUE AND EXIST(virt2$)=TRUE THEN
KILL virt$
KILL virt2$
ENDIF
rett=FALSE
ENDIF
IF (virtld=TRUE AND (blockld=TRUE OR virtual=TRUE)) OR (virtld=FALSE AND blockld=FALSE AND virtual=FALSE) THEN
IF virtld=FALSE THEN
IF ldtrk=FALSE THEN
IF neufsel=FALSE THEN
@blklfrag
mrkobj=obj
ELSE
blks=0
ENDIF
ELSE
obj=savall&
mrkobj=obj
ENDIF
ENDIF
IF obj<>savexit& THEN
retime=0
shlp=0
lready=0
cs=0
ce=vmem
head=20   ! HeaderlÑnge fÅr S16-Files
x=100
y=100
w=400
h=400
IF virtld=FALSE THEN
IF ldtrk=FALSE THEN
IF neufsel=TRUE THEN
@newfsel
ELSE
@fileselect(op$+"*."+ext$,"","LOAD SAMPLE:")
ENDIF
ELSE
pbutt=1
pret=1
ENDIF
ENDIF
@busy_mouse
pathda=EXIST(fil$)
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pathda=TRUE AND pret<>0 AND pbutt=1 THEN
datx=mdat%
OPEN "I",#1,fil$
IF virtld=FALSE THEN
ln=LOF(#1)
viln=ln
ELSE
virtln=viln
ENDIF
BGET #1,datx,4
CLOSE #1
@blkltest
IF (virtld=FALSE AND (ln-head)<=mlen) OR blockld=TRUE THEN
IF blks=0 THEN
anfloadx=meml
mt=INT(mlen/mbit)*mbit
ELSE
anfloadx=bstart
mt=memh-bstart
ENDIF
ELSE
IF blks=0 OR virtual=TRUE THEN
anfloadx=meml
mt=INT(mlen/mbit)*mbit
ELSE
anfloadx=bstart
mt=memh-bstart
ENDIF
ENDIF
@fileart
ldhead=head
ldfileart=fileart
IF anfloadx<>0 AND anfloadx<>-1 AND (ln-abz)<=mt THEN
lready=1
ln2=ln
IF blks=0 AND virtld=FALSE AND virtual=FALSE THEN      ! virtld,virtual ist NEU !!!
@markdel
ELSE
'            blks=1    ! NEU
ENDIF
ln=ln2
datx=((INT(anfloadx/mbit))*mbit)+mbit
OPEN "I",#1,fil$
@fileart2
lded=1
IF blks=0 THEN
@clsed
ENDIF
danf=datx
IF blockld=TRUE AND virtld=TRUE THEN
fileart=vfileart
head=vhead
SEEK #1,vhbldstrt+head
ln=hbldlen
ENDIF
'
IF fileart=7 THEN                   ! AIFF-Format
@markhlp
a=datx
ldlen=LPEEK(danf+22)                          ! Sample Len in Worten
per=DPEEK(danf+30)     ! Sample-Rate
tst1=LPEEK(danf+8)     ! AIFF-Kennung
tst2=LPEEK(danf+12)    ! COMM-Kennung
tst3=DPEEK(danf+20)    ! Channels
tst4=LPEEK(danf+38)    ! SSND-Kennung
tst5=DPEEK(danf+26)    ! Bits
IF tst5=16 THEN
@setbitrate16
ENDIF
IF tst5=24 THEN
@setbitrate24
ENDIF
IF tst1=&H41494646 AND tst2=&H434F4D4D AND tst3=2 AND tst4=&H53534E44 AND (tst5=16 OR tst5=24) THEN
@ldhztest
sblock=0
sret=0
IF nr=smpedit& THEN
@setbutton(smppmark&,0)
ENDIF
okmark=0
sms=1
sms2=0
samlen=ln-head
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
enam$=nam$
efil$=fil$
vlmin=lmin
vlma=lma
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=6 THEN          ! Avalon SMP-Format
@markhlp
a=datx
tst1=DPEEK(danf+76)    ! Bits
IF tst1=16 THEN
per=LPEEK(danf+72)     ! Sample-Rate
@ldhztest
samlen=LPEEK(danf+92)*mbit ! datasize
ln=samlen
bloops%(7,1)=LPEEK(danf+32)
bloops%(7,2)=LPEEK(danf+64)
bloops%(6,1)=LPEEK(danf+28)
bloops%(6,2)=LPEEK(danf+60)
bloops%(5,1)=LPEEK(danf+24)
bloops%(5,2)=LPEEK(danf+56)
bloops%(4,1)=LPEEK(danf+20)
bloops%(4,2)=LPEEK(danf+52)
bloops%(3,1)=LPEEK(danf+16)
bloops%(3,2)=LPEEK(danf+48)
bloops%(2,1)=LPEEK(danf+12)
bloops%(2,2)=LPEEK(danf+44)
bloops%(1,1)=LPEEK(danf+8)
bloops%(1,2)=LPEEK(danf+40)
ec=FALSE
a=RINSTR(fil$,".")
al$=LEFT$(fil$,a-2)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
a=RINSTR(fil$,".")
ar$=LEFT$(fil$,a-2)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ea=EXIST(al$)
eb=EXIST(ar$)
IF ea=FALSE OR eb=FALSE THEN
IF EXIST(fil$)=TRUE THEN
al$=fil$
ar$=fil$
ea=TRUE
eb=TRUE
ec=TRUE
ENDIF
ENDIF
bnam$=nam$
smplen=ln
IF ec=FALSE THEN
a=RINSTR(nam$,".")
bnam$=LEFT$(nam$,a-2)+RIGHT$(nam$,LEN(nam$)-a+1)
ENDIF
head=20
@sampleinf
IF inf=TRUE THEN
enam$=nam$
efil$=fil$
sblock=0
FOR j=1 TO 7
IF bloops%(j,1)<>-1 THEN
sa=bloops%(j,1)*mbit
ELSE
sa=-1
ENDIF
IF bloops%(j,2)<>-1 THEN
se=bloops%(j,2)*mbit
ELSE
se=-1
ENDIF
sa2=-1
se2=-1
ah$=""
markfre=j
@findblock
NEXT j
FOR j=8 TO loopz
loops%(j,1)=-1
loops%(j,2)=-1
loops%(j,3)=-1
loops%(j,4)=-1
NEXT j
sms=1
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
IF sblock=0 THEN
okmark=0
sms=1
sms2=0
ENDIF
vlmin=lmin
vlma=lma
CLOSE #1
@sdload
@maschruf38(datx,datx+samlen)
@ldready
ELSE
CLOSE #1
ENDIF
ENDIF
ENDIF
'
IF fileart=5 THEN          ! SD-Format
@markhlp
a=datx
per=LPEEK(danf+1020)     ! Sample-Rate
@ldhztest
samlen=LPEEK(danf+148)*2 ! datasize
okmark=0
sms=1
sms2=0
ln=samlen
ec=FALSE
a=RINSTR(fil$,".")
al$=LEFT$(fil$,a-2)+"L"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
a=RINSTR(fil$,".")
ar$=LEFT$(fil$,a-2)+"R"+RIGHT$(fil$,LEN(fil$)-a+1)+CHR$(0)
ea=EXIST(al$)
eb=EXIST(ar$)
IF ea=FALSE OR eb=FALSE THEN
IF EXIST(fil$)=TRUE THEN
al$=fil$
ar$=fil$
ea=TRUE
eb=TRUE
ec=TRUE
ENDIF
ENDIF
bnam$=nam$
IF ec=FALSE THEN
a=RINSTR(nam$,".")
bnam$=LEFT$(nam$,a-2)+RIGHT$(nam$,LEN(nam$)-a+1)
ENDIF
smplen=ln
@sampleinf
IF inf=TRUE THEN
enam$=nam$
efil$=fil$
vlmin=lmin
vlma=lma
CLOSE #1
@sdload
@ldready
ELSE
CLOSE #1
ENDIF
ENDIF
'
IF fileart=4 THEN        ! AU-Format
@markhlp
a=datx
tst1=LPEEK(danf+12)    ! dataformat
tst2=LPEEK(danf+20)    ! channelcount
IF tst1=3 AND tst2=2 THEN
per=LPEEK(danf+16)    ! Sample-Rate
@ldhztest
samlen=LPEEK(danf+8)        ! datasize
okmark=0
sms=1
sms2=0
dazu=LPEEK(danf+4)-28       !datalocation
IF dazu>0 THEN
BGET #1,datx,dazu
ENDIF
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
enam$=nam$
efil$=fil$
vlmin=0
vlma=0
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=3 THEN        ! WAV-Format
@markhlp
a=datx
tst1=LPEEK(danf+8)     ! "WAVE"
tst2=LPEEK(danf+12)    ! "fmt "
tst3=PEEK(danf+20)     ! format
tst4=PEEK(danf+22)     ! channels
tst5=PEEK(danf+32)     ! align
tst6=PEEK(danf+34)     ! bps
IF tst6=16 THEN
@setbitrate16
ENDIF
IF tst6=24 THEN
@setbitrate24
ENDIF
IF tst1=&H57415645 AND tst2=&H666D7420 AND tst3=1 AND tst4=2 AND (tst5=4 OR tst5=6) AND (tst6=16 OR tst6=24) THEN
per=PEEK(danf+24)+256*PEEK(danf+25)    ! Sample-Rate
@ldhztest
dmagic=&H64617461
IF LPEEK(danf+36)=dmagic THEN
samlen=PEEK(danf+40)+256*PEEK(danf+41)+65536*PEEK(danf+42)+&H1000000*PEEK(danf+43)
ov=danf+36
ELSE
ov=40
REPEAT
dazu=PEEK(danf+ov)+256*PEEK(danf+ov+1)+65536*PEEK(danf+ov+2)+&H1000000*PEEK(danf+ov+3)
head=head+dazu+8
ov=4
IF ln>=head THEN
BGET #1,datx,dazu+8
IF LPEEK(danf+dazu)=dmagic THEN
samlen=PEEK(danf+dazu+4)+256*PEEK(danf+dazu+5)+65536*PEEK(danf+dazu+6)+&H1000000*PEEK(danf+dazu+7)
ENDIF
ENDIF
UNTIL LPEEK(danf+dazu)=dmagic OR ln<head
ov=danf+dazu
ENDIF
okmark=0
sms=1
sms2=0
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
IF LPEEK(ov)=dmagic THEN
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
enam$=nam$
efil$=fil$
vlmin=0
vlma=0
BGET #1,datx,samlen
@maschruf28(datx,samlen)
@ldready
ENDIF
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=2 THEN        ! AVR-Format
@markhlp
a=datx
tst1=DPEEK(danf+12)    ! mode
tst2=DPEEK(danf+14)    ! resolution
IF tst2=16 THEN
@setbitrate16
ENDIF
IF tst2=24 THEN
@setbitrate24
ENDIF
tst3=DPEEK(danf+16)    ! sign
IF tst1=&HFFFF AND (tst2=16 OR tst2=24) AND tst3=&HFFFF THEN
per=DPEEK(danf+24)    ! Sample-Rate
@ldhztest
la=DPEEK(danf+18)                           ! Loop ?
sblock=0
sret=0
IF la=&HFFFF THEN
sblock=1
ENDIF
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
samlen=LPEEK(danf+26)*2
IF sblock=1 THEN
lmin=LPEEK(danf+30)*2                          ! Sustain Loop-Start
lma=LPEEK(danf+34)*2                           ! Sustain Loop-End
IF lma<lmin THEN
sret=1                ! RÅckwÑrts-Loop
a=lmin
lmin=lma
lma=a
ENDIF
ah=lmin+bpos
ah=INT(ah)
ah2=lma+bpos
ah2=INT(ah2)
IF ah>vmem THEN
ah=vmem
ENDIF
IF ah2>vmem THEN
ah2=vmem
ENDIF
ELSE
okmark=0
sms=1
sms2=0
ENDIF
IF (ln-head)<samlen THEN
samlen=(ln-head)
ENDIF
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
enam$=nam$
efil$=fil$
vlmin=lmin
vlma=lma
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ELSE
fileart=0    ! unbekannt
head=0
CLOSE #1
OPEN "I",#1,fil$
ENDIF
ENDIF
'
IF fileart=1 THEN                   ! S16-Format
IF RIGHT$(fil$,4)=".S16" THEN
@setbitrate16
ENDIF
IF RIGHT$(fil$,4)=".S24" THEN
@setbitrate24
ENDIF
@markhlp
a=datx
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
x2=DPEEK(danf+10)                          ! Sample Len in Worten
y2=PEEK(danf+12)                           ! Sample Len in Worten
ldlen=(x2*256+y2)*2
per=INT(10^9/(x*65536+y))
per=@hzanalye(per)
perm=per
@ldhztest
la=PEEK(danf+19)                           ! Loop-Art
sblock=1
IF la=0 THEN
sret=0
ENDIF
IF la=1 THEN
sret=1
ENDIF
IF la=&H7F THEN
sblock=0
ENDIF
IF nr=smpedit& THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
IF sblock=1 THEN
x3=PEEK(danf+13)                           ! Sustain Loop-Start
y3=DPEEK(danf+14)                          ! Sustain Loop-Start
lmin=x3*65536+y3
x4=DPEEK(danf+16)                          ! Sustain Loop-End
y4=PEEK(danf+18)                           ! Sustain Loop-End
lma=x4*256+y4
ah=lmin+bpos
ah=INT(ah)
ah2=lma+bpos
ah2=INT(ah2)
IF ah>vmem THEN
ah=vmem
ENDIF
IF ah2>vmem THEN
ah2=vmem
ENDIF
ELSE
okmark=0
sms=1
sms2=0
ENDIF
samlen=ln-head
bnam$=nam$
smplen=samlen
@sampleinf
IF inf=TRUE THEN
enam$=nam$
efil$=fil$
vlmin=lmin
vlma=lma
BGET #1,datx,samlen
@ldready
ENDIF
CLOSE #1
ENDIF
'
IF fileart=0 THEN              ! Rohdaten-Format
samlen=ln-head
bnam$=nam$
smplen=samlen
@makehz
per=hz
@sampleinf
IF inf=TRUE THEN
enam$=nam$
efil$=fil$
vlmin=0
vlma=0
BGET #1,datx+head,samlen
@ldready
a=datx
okmark=0
sms=1
sms2=0
hzm=hz
ENDIF
CLOSE #1
ENDIF
IF inf=TRUE THEN
a=datx
IF blks=0 THEN
b=meml
l=memh-meml
shlp=1
smrk=meml+(ln-head)
smrk=INT(smrk/mbit)*mbit
ELSE
shlp=0
b=bstart
l=memh-bstart
ENDIF
IF big=0 THEN
@maschruf1
ENDIF
IF vmem<=mlen AND virtual=FALSE AND blockld=FALSE THEN
@copyloops
ENDIF
IF vmem<=mlen AND (virtual=TRUE OR blockld=TRUE) THEN
virtual=FALSE
blockld=FALSE
virtld=FALSE
virtcurve=FALSE
maxcwert=0
ce=mlen
cs=0
vmem=INT(mlen/mbit)*mbit
ENDIF
IF virtual=FALSE AND blockld=FALSE THEN
profln=ln
profhz=hz
ENDIF
ENDIF
ELSE
vhead=head
vfileart=fileart
vtst=TRUE
bnam$=nam$
smplen=ln
per=0
@ldhead
IF per=0 THEN
@makehz
per=hz
ENDIF
@sampleinf
vtst=FALSE
IF inf=TRUE THEN
enam$=nam$
efil$=fil$
@virtual
IF blockld=TRUE THEN
IF blks=0 THEN
mbs=0
ENDIF
ln=mt-mbit
obj=mrkobj
virtld=TRUE
@ldhlp
virtld=FALSE
vorln=ln
lz=1
vmem=INT(mlen/mbit)*mbit
bpos2=vhbldstrt
blockpos=TRUE
@copyloops
blockpos=FALSE
ENDIF
IF virtual=TRUE THEN
mbs=0
IF nr=smpedit& THEN
@setbutton(hard&,1)
ENDIF
vmem=ln-head
vmeml=0
vmemh=mt
hrd=1
@hardproof
ln=mt
obj=mrkobj
'              blks=0        ! NEU
virtld=TRUE
@ldhlp
virtld=FALSE
IF blks=0 THEN
@markdel      ! NEU
@clsed        ! NEU
ENDIF
ln=vmem
vce=0
vcs=0
lz=1
@copyloops
ENDIF
IF virtex=TRUE THEN
@infrett
ENDIF
ENDIF
ENDIF
IF inf=FALSE THEN
@infrett
ENDIF
@fnamwrite
ENDIF
ENDIF
ENDIF
obj=0
blockld=FALSE
IF loded=TRUE AND virtual=FALSE THEN
INC mbs
IF blks=1 THEN
mblocks(mbs)=bstart-meml
mblocke(mbs)=bstart+samlen-meml
ELSE
mbs=1
mblocks(mbs)=0
mblocke(mbs)=samlen
ENDIF
mblockp$(mbs)=fil$
IF mbs>lmax3 THEN
mbs=1
ENDIF
vmbs=mbs
ENDIF
IF loded=TRUE THEN
zoomp=0
@zslidecalc
ENDIF
IF inf=FALSE THEN
@infrett
ENDIF
IF sret<>lsret THEN
IF BTST(winh,loop&)=TRUE THEN
lnr=nr
nr=loop&
@editselect
IF nr=loop& THEN
@loopbut(lsret,0)
@loopbut(sret,1)
ENDIF
nr=lnr
@editselect
ENDIF
ENDIF
RETURN
'
> PROCEDURE infrett
.| Glob. Var.: per#,vper#,path$,vpath$,smpnam$,vsmpnam$,smplen#,vsmplen#
.|     mrkdatum$,vmrkdatum$,retime#,vretime#,ordner$,vordner$,cs#,vorcs#,ce#
.|     vorce#,i#,loopz#,bloopz#,sblock#,vsblock#,lz#,vlz#,mbs#,vmbs#,sms#
.|     vsms#,sme#,vsme#,master#,vmaster#,zoomp#,vzoomp#,srollp#,vscrollp#
.|     sloop#,vsloop#,mamidi#,vmamidi#,loded#
.| Felder    : loops#(),vloops#(),loope#(),vloope#(),bloops#(),vbloops#()
.|     bloope#(),vbloope#()
.| Ruft auf  : makehz
.| Aufruf in : ldhlp-3,sampleinf-1,
dig24=vdig24
IF dig24=FALSE THEN
@setbitrate16
ELSE
@setbitrate24
ENDIF
per=vper
path$=vpath$
smpnam$=vsmpnam$
smplen=vsmplen
ordner$=vordner$
mrkdatum$=vmrkdatum$
retime=vretime
IF retime=1 THEN
@makehz
ENDIF
cs=vorcs
ce=vorce
FOR i=1 TO loopz
loops%(i,1)=vloops%(i,1)
loops%(i,2)=vloops%(i,2)
NEXT i
FOR i=1 TO bloopz
bloops%(i,1)=vbloops%(i,1)
bloops%(i,2)=vbloops%(i,2)
NEXT i
sblock=vsblock
sloop!=vsloop!
mamidi=vmamidi
lz=vlz
mbs=vmbs
sms=vsms
sms2=vsms2
zoomp=vzoomp
srollp=vscrollp
loded=FALSE
RETURN
'
> PROCEDURE infhol
.| Glob. Var.: vper#,per#,vpath$,path$,vsmpnam$,smpnam$,vsmplen#,smplen#
.|     vordner$,ordner$,vmrkdatum$,mrkdatum$,vretime#,retime#,vorcs#,cs#
.|     vorce#,ce#,i#,loopz#,bloopz#,vsblock#,sblock#,vsloop#,sloop#,vmamidi#
.|     mamidi#,vlz#,lz#,vmbs#,mbs#,vsms#,sms#,vsme#,sme#,vmaster#,master#
.|     vzoomp#,zoomp#,vsrollp#,scrollp#
.| Felder    : vloops#(),loops#(),vloope#(),loope#(),vbloops#(),bloops#()
.|     vbloope#(),bloope#()
.| Aufruf in : smpsave-1,ldhlp-1,record4-1,
vdig24=dig24
vper=per
vpath$=path$
vsmpnam$=smpnam$
vsmplen=smplen
vordner$=ordner$
vmrkdatum$=mrkdatum$
vretime=retime
vorcs=cs
vorce=ce
FOR i=1 TO loopz
vloops%(i,1)=loops%(i,1)
vloops%(i,2)=loops%(i,2)
NEXT i
FOR i=1 TO bloopz
vbloops%(i,1)=bloops%(i,1)
vbloops%(i,2)=bloops%(i,2)
NEXT i
vsblock=sblock
vsloop!=sloop!
vmamidi=mamidi
vlz=lz
vmbs=mbs
vsms=sms
vsms2=sms2
vzoomp=zoomp
vsrollp=scrollp
RETURN
'
> PROCEDURE makedatum
.| Glob. Var.: mrkdatum$
.| Aufruf in : smpsave-1,smpinfbutt-1,record4-1,
LOCAL d$
d$=DATE$
mrkdatum$=LEFT$(d$,LEN(d$)-4)+RIGHT$(d$,2)+"  "+LEFT$(TIME$,5)+CHR$(0)
RETURN
'
> PROCEDURE smpinfbutt
.| Glob. Var.: obj#,bnam$,smpnam$,fil$,path$,mbs#,virtual#,smplen#,vmem#
.|     per#,hz#,infbutt#
.| Ruft auf  : setbutton,makedatum,makehz,sampleinf
.| Aufruf in : do_smpedit-1,
LOCAL d$
@setbutton(obj,0)
vsmplen=smplen
bnam$=smpnam$
fil$=path$
IF mbs=0 AND virtual=FALSE THEN
smplen=vmem
l=vmem
@makedatum
@makehz
per=hz
ENDIF
IF virtual=TRUE THEN
l=vmem
smplen=vmem
ENDIF
infbutt=TRUE
infm$=infname$
@sampleinf
smplen=vsmplen
infbutt=FALSE
RETURN
'
> PROCEDURE loadloops(ldloop)
LOCAL i,ll
INPUT #2,v$              !  "STARTRACK-INF V1.0"  Versionskontrolle
iv=0
IF INSTR(v$,"STARTRACK-INF")<>0 THEN
a=INSTR(v$," V")
IF a<>0 THEN
iv=VAL(RIGHT$(v$,LEN(v$)-a-1))
ENDIF
ENDIF
IF iv=0 THEN
CLOSE #2
OPEN "I",#2,b$
ENDIF
IF iv=0 THEN
FOR i=1 TO bloopz
IF ldloop=TRUE THEN
INPUT #2,bloops%(i,1)
INPUT #2,bloops%(i,2)
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
ELSE
INPUT #2,ll
INPUT #2,ll
ENDIF
NEXT i
IF ldloop=TRUE THEN
FOR i=bloopz+1 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
NEXT i
ELSE
src1$=""
src2$=""
ENDIF
ENDIF
IF iv=1.2 THEN
@inftexts
IF ldloop=TRUE THEN
comm$=src1$
src$=src2$
ENDIF
ENDIF
IF iv>=2 THEN
@infnewtexts
IF ldloop=TRUE THEN
@getnewloops
comm$=src1$
src$=src2$
ENDIF
ENDIF
IF iv>=1 AND iv<=1.2 THEN
IF iv>=1.1 THEN
INPUT #2,mloopz
IF mloopz>loopz THEN
mloopz=loopz
ENDIF
ELSE
mloopz=100
IF loopz>mloopz AND ldloop=TRUE THEN
FOR i=mloopz+1 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
ENDIF
ENDIF
FOR i=1 TO mloopz
IF ldloop=TRUE THEN
INPUT #2,bloops%(i,1)
INPUT #2,bloops%(i,2)
INPUT #2,bloops%(i,3)
INPUT #2,bloops%(i,4)
ELSE
INPUT #2,ll
INPUT #2,ll
INPUT #2,ll
INPUT #2,ll
ENDIF
c$=""
REPEAT
INPUT #2,a$
IF a$<>CHR$(0) THEN
c$=c$+a$
ENDIF
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
c$=c$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
IF LEN(c$)>25 THEN
c$=LEFT$(c$,25)
ENDIF
IF ldloop=TRUE THEN
vedmtxt$(i)=c$
ENDIF
NEXT i
IF ((loopz>mloopz AND loopz>100) OR iv=1.1) AND ldloop=TRUE THEN
FOR i=100 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
ENDIF
IF iv=1 OR iv=1.1 THEN
@inftexts
ENDIF
ENDIF
RETURN
'
> PROCEDURE inflooptext(i,j,jj)
IF bloops%(i,j)<>-1 THEN
IF tedart=0 THEN
hsec=INT(bloops%(i,j)/hz*100)
@htimeset2
ELSE
a$=STR$(bloops%(i,j))
@formatsmp
ENDIF
ELSE
a$=CHR$(0)
ENDIF
@textfeld(jj,a$+CHR$(0),1)
RETURN
'
> PROCEDURE inflooptext2(i,j,jj)
IF loops%(i,j)<>-1 THEN
IF tedart=0 THEN
hsec=INT(loops%(i,j)/hz*100)
@htimeset2
ELSE
a$=STR$(loops%(i,j))
@formatsmp
ENDIF
ELSE
a$=CHR$(0)
ENDIF
@textfeld(jj,a$+CHR$(0),1)
RETURN
'
> PROCEDURE sampleinf
.| Glob. Var.: virtld#,vornr#,nr#,smpinf&,infbutt#,sinfcomm&,sinfsrc&,isave#
.|     sinfname&,bnam$,smplen#,per#,sinflen&,sinfrate&,fil$,mdat2%,mrkdatum$
.|     sinfdate&,fileart#,i#,bloopz#,lma#,vtst#,sblock#,lmin#,c$,src$,b$
.|     ordner$,inf$,j#,markfull#,sa#,se#,scr$,sinfsus1&,sinfsus2&,sinfrel1&
.|     sinfrel2&,sinfl1&,sinfl2&,sinfl3&,sinfl4&,sinfl5&,sinfl6&,sinfl7&
.|     sinfl8&,sinfl9&,sinfl10&,sinfl11&,sinfl12&,l#,hz#,xlmin#,xlma#,obj#
.|     popup&,zu%,zuadr#,edit_obj&,buttadr#,but#,objadr#,objflag#,sinhelp&
.|     sinfexit&,sinfok&,inf#,head#,mlen#,blockld#,blks#,meml#,memh#
.|     commtxt$,srctxt$,infname$
.| Felder    : bloops#(),bloope#(),loops#(),loope#()
.| Ruft auf  : rsc_draw,editfeld,markhlp,textfeld,marksearch,findblock
.|     markset,blocklook,markhlp7,rsc_do,xrsrc_gaddr,mousek,helptxt
.|     busy_mouse,maschinit9,maschruf9,infrett,editread,setbutton,restaura2
.|     rsc_back,restaura3
.| Aufruf in : smpsave-1,ldhlp-8,smpinfbutt-1,record4-1,
LOCAL a,b,t,d,m,day,a$,f$,vcs,vce,vln,t$,d$
@testcopyright
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
edclr=FALSE
IF virtld=FALSE THEN
IF ldtrk2=FALSE THEN
vornr=nr
nr=smpinf&
@editfeld2(nr,sinfcomm&,CHR$(0))
@editfeld2(nr,sinfsrc&,CHR$(0))
ENDIF
vshading=shading
shading=TRUE
dopix=TRUE
@busy_mouse
IF isave=FALSE THEN
IF ldtrk2=FALSE THEN
IF per=0 THEN
per=hz
ENDIF
a$=bnam$+CHR$(0)
IF LEN(a$)>33 THEN
a$=RIGHT$(a$,33)+CHR$(0)
ENDIF
@textfeld(sinfname&,a$,1)
hsec=INT(smplen/per/mbit*100)
htimeset2
b$=a$
a$=STR$(INT(smplen/mbit))
@formatsmp
a$=a$+" samples = "+b$
IF LEN(a$)>33 THEN
a$=STR$(INT(smplen/mbit))
@formatsmp
a$=a$+"/"+b$
ENDIF
IF LEN(a$)>33 THEN
a$=STR$(INT(smplen/mbit))
@formatsmp
a$=a$+" samples"+CHR$(0)
ENDIF
IF LEN(a$)>33 THEN
a$=RIGHT$(a$,33)+CHR$(0)
ENDIF
@textfeld(sinflen&,a$,1)
a$=STR$(INT(per/100)/10)+" KHz"+CHR$(0)
@textfeld(sinfrate&,a$,1)
ENDIF
IF infbutt=FALSE THEN
f$=fil$+CHR$(0)
a=GEMDOS(61,L:VARPTR(f$),0)
IF a>=0 THEN
~GEMDOS(87,L:mdat%,a,0)
b=GEMDOS(62,a)
t=DPEEK(mdat%)
d=DPEEK(mdat%+2)
day=(d AND 31)
d=(d AND (65535-31))
d=SHR(d,5)
m=(d AND 15)
d=80+SHR(d,4)
IF d>99 THEN
d=d-100
ENDIF
d$=RIGHT$("0"+STR$(d),2)
a$=STR$(day)+"."+STR$(m)+"."+d$
t=SHR(t,5)
d=(t AND 63)
d$=RIGHT$("0"+STR$(d),2)
t=SHR(t,6)
t$=RIGHT$("0"+STR$(t),2)
a$=a$+"  "+t$+":"+d$+CHR$(0)
mrkdatum$=a$
IF ldtrk2=FALSE THEN
@textfeld(sinfdate&,a$,1)
ENDIF
ELSE
IF ldtrk2=FALSE THEN
a$=CHR$(0)
@textfeld(sinfdate&,a$,1)
ENDIF
ENDIF
ELSE
IF ldtrk2=FALSE THEN
@textfeld(sinfdate&,mrkdatum$,1)
ENDIF
ENDIF
IF infbutt=FALSE THEN
IF fileart<>6 THEN
FOR i=1 TO bloopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
NEXT i
IF lma>0 AND vtst=FALSE AND sblock=1 THEN
bloops%(1,1)=INT(lmin/mbit)
bloops%(1,2)=INT(lma/mbit)
ENDIF
ENDIF
comm$=""
src$=""
a=RINSTR(bnam$,".")
infm$=ordner$+LEFT$(bnam$,a)+inf$
infname$=infm$
exi=FALSE
IF EXIST(infm$)=TRUE THEN
exi=TRUE
OPEN "I",#2,infm$
@loadloops(TRUE)
comm$=src1$
src$=src2$
IF fileart<>6 THEN
IF iv=0 THEN
a=bloopz
ELSE
a=loopz
ENDIF
FOR j=1 TO a
IF blks=0 THEN
markfre=j
ELSE
markfre=j+sms
ENDIF
IF bloops%(j,1)<>-1 THEN
sa=bloops%(j,1)*mbit
ELSE
sa=-1
ENDIF
IF bloops%(j,2)<>-1 THEN
se=bloops%(j,2)*mbit
ELSE
se=-1
ENDIF
IF bloops%(j,3)<>-1 THEN
sa2=bloops%(j,3)*mbit
ELSE
sa2=-1
ENDIF
IF bloops%(j,4)<>-1 THEN
se2=bloops%(j,4)*mbit
ELSE
se2=-1
ENDIF
ah$=vedmtxt$(j)
IF LEN(ah$)>25 THEN
ah$=LEFT$(ah$,25)
ENDIF
'              @findblock
EXIT IF markfre=loopz
NEXT j
'
IF loopz>a THEN
FOR j=a+1 TO loopz
loops%(j,1)=-1
loops%(j,2)=-1
loops%(j,3)=-1
loops%(j,4)=-1
NEXT j
ENDIF
'
IF blks=0 THEN
sms=1
ENDIF
IF nr=smpedit& THEN
@markhlp3(markfre,1,loops%(sms,1))
@markhlp3(markfre,2,loops%(sms,2))
@markhlp3(markfre,3,loops%(sms,3))
@markhlp3(markfre,4,loops%(sms,4))
ENDIF
ENDIF
CLOSE #2
ELSE
IF (fileart=1 OR fileart=2) AND sblock=1 THEN
@marksearch
@markset
ENDIF
ENDIF
'
ENDIF
IF ldtrk2=FALSE THEN
@inflooptext(1,1,sinfsus1&)
@inflooptext(1,2,sinfsus2&)
IF fileart=6 OR exi=TRUE OR infbutt=TRUE THEN
IF exi=TRUE OR (infbutt=TRUE AND EXIST(infm$)=TRUE) THEN
@editfeld(sinfcomm&,comm$+CHR$(0))
@editfeld(sinfsrc&,src$+CHR$(0))
ELSE
@editfeld(sinfcomm&,CHR$(0))
@editfeld(sinfsrc&,CHR$(0))
ENDIF
@inflooptext(1,3,sinfrel1&)
@inflooptext(1,4,sinfrel2&)
@inflooptext(2,1,sinfl1&)
@inflooptext(2,2,sinfl2&)
@inflooptext(3,1,sinfl3&)
@inflooptext(3,2,sinfl4&)
@inflooptext(4,1,sinfl5&)
@inflooptext(4,2,sinfl6&)
@inflooptext(5,1,sinfl7&)
@inflooptext(5,2,sinfl8&)
@inflooptext(6,1,sinfl9&)
@inflooptext(6,2,sinfl10&)
@inflooptext(7,1,sinfl11&)
@inflooptext(7,2,sinfl12&)
ELSE
@editfeld(sinfcomm&,CHR$(0))
@editfeld(sinfsrc&,CHR$(0))
@textfeld(sinfrel1&,CHR$(0),1)
@textfeld(sinfrel2&,CHR$(0),1)
@textfeld(sinfl1&,CHR$(0),1)
@textfeld(sinfl2&,CHR$(0),1)
@textfeld(sinfl3&,CHR$(0),1)
@textfeld(sinfl4&,CHR$(0),1)
@textfeld(sinfl5&,CHR$(0),1)
@textfeld(sinfl6&,CHR$(0),1)
@textfeld(sinfl7&,CHR$(0),1)
@textfeld(sinfl8&,CHR$(0),1)
@textfeld(sinfl9&,CHR$(0),1)
@textfeld(sinfl10&,CHR$(0),1)
@textfeld(sinfl11&,CHR$(0),1)
@textfeld(sinfl12&,CHR$(0),1)
ENDIF
ENDIF
ELSE
@blocklook
d$=DATE$
d$=LEFT$(d$,LEN(d$)-4)+RIGHT$(d$,2)
IF ldtrk2=FALSE THEN
a$=bnam$+CHR$(0)
IF LEN(a$)>33 THEN
a$=RIGHT$(a$,33)+CHR$(0)
ENDIF
@textfeld(sinfname&,a$,1)
hsec=INT(l/hz/mbit*100)
@htimeset2
b$=a$
a$=STR$(INT(l/mbit))
@formatsmp
a$=a$+" samples = "+b$
IF LEN(a$)>33 THEN
a$=STR$(INT(l/mbit))
@formatsmp
a$=a$+"/"+b$
ENDIF
IF LEN(a$)>33 THEN
a$=STR$(INT(l/mbit))
@formatsmp
a$=a$+" samples"+CHR$(0)
ENDIF
IF LEN(a$)>33 THEN
a$=RIGHT$(a$,33)+CHR$(0)
ENDIF
@textfeld(sinflen&,a$+CHR$(0),1)
@textfeld(sinfrate&,STR$(INT(hz/100)/10)+" kHz"+CHR$(0),1)
@textfeld(sinfdate&,d$+"  "+LEFT$(TIME$,5)+CHR$(0),1)
ENDIF
'
IF virtual=TRUE THEN
@editfeld(sinfcomm&,comm$+CHR$(0))
@editfeld(sinfsrc&,src$+CHR$(0))
ENDIF
'
IF sblock=1 THEN
xlmin=lmin
xlma=lma
@markhlp7
'        bloops%(1,1)=INT(lmin/mbit)
'        bloops%(1,2)=INT(lma/mbit)
IF ldtrk2=FALSE THEN
@inflooptext(1,1,sinfsus1&)
@inflooptext(1,2,sinfsus2&)
ENDIF
lmin=xlmin
lma=xlma
ELSE
FOR i=1 TO bloopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
IF ldtrk2=FALSE THEN
@textfeld(sinfsus1&,CHR$(0),1)
@textfeld(sinfsus2&,CHR$(0),1)
ENDIF
ENDIF
IF ldtrk2=FALSE THEN
a=RINSTR(fil$,".")
infm$=LEFT$(fil$,a)+inf$
infname$=infm$
@textfeld(sinfrel1&,CHR$(0),1)
@textfeld(sinfrel2&,CHR$(0),1)
@inflooptext2(1,3,sinfrel1&)
@inflooptext2(1,4,sinfrel2&)
@inflooptext2(2,1,sinfl1&)
@inflooptext2(2,2,sinfl2&)
@inflooptext2(3,1,sinfl3&)
@inflooptext2(3,2,sinfl4&)
@inflooptext2(4,1,sinfl5&)
@inflooptext2(4,2,sinfl6&)
@inflooptext2(5,1,sinfl7&)
@inflooptext2(5,2,sinfl8&)
@inflooptext2(6,1,sinfl9&)
@inflooptext2(6,2,sinfl10&)
@inflooptext2(7,1,sinfl11&)
@inflooptext2(7,2,sinfl12&)
ENDIF
ENDIF
shading=vshading
dopix=FALSE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF ldtrk2=FALSE THEN
IF infbutt=TRUE THEN
@rsc_draw(nr,0)    ! sollte 5 sein
ELSE
@rsc_draw(nr,0)
ENDIF
@markhlp
edit_obj&=0
next_obj&=0
obj=0
obj&=0
REPEAT
REPEAT
obj=@rsc_do(nr,obj,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>sinfcomm& AND obj<>sinfsrc&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=sinfhelp& THEN
@helptxt("SAMPLE-INFO")
ENDIF
UNTIL obj=sinfexit& OR obj=sinfok&
IF obj=sinfok& THEN
binfname$=infname$
commtxt$=comm$
srctxt$=src$
edclr=TRUE
inf=TRUE
IF infbutt=FALSE THEN
@busy_mouse
ENDIF
IF ((virtld=FALSE AND (smplen-head)<=mlen) OR blockld=TRUE) AND blks=0 AND infbutt=FALSE AND isave=FALSE THEN
@maschruf9(meml,memh)
ENDIF
ELSE
inf=FALSE
IF infbutt=FALSE THEN
infm$=""
infname$=binfname$
comm$=commtxt$
src$=srctxt$
@infrett
ENDIF
ENDIF
ENDIF
ELSE
inf=TRUE
ENDIF
IF ldtrk2=FALSE THEN
IF (isave=TRUE OR infbutt=TRUE) AND inf=TRUE THEN
@editread(sinfcomm&)
commtxt$=a$+CHR$(0)
@editread(sinfsrc&)
srctxt$=a$+CHR$(0)
infname$=infm$
@infchange
ENDIF
IF virtld=FALSE THEN
@setbutton(obj,0)
ENDIF
IF infbutt=TRUE THEN
@restaura2
ELSE
IF virtld=FALSE THEN
@rsc_back(nr)
nr=vornr
IF edclr=TRUE THEN
'        @restaura3
ENDIF
ENDIF
ENDIF
ENDIF
IF ldtrk2=TRUE THEN
inf=TRUE
ENDIF
IF inf=TRUE AND virtld=TRUE THEN
edclr=TRUE
ENDIF
obj=0
RETURN
'
> PROCEDURE copyloops       ! Marker von Loadbuffer in Markerbuffer kopieren
LOCAL a
IF fileart<>6 THEN
IF iv=0 THEN
a=bloopz
ELSE
a=loopz
ENDIF
markfre=0
FOR j=1 TO a
IF blks=0 OR virtual=TRUE THEN
INC markfre
ELSE
markfre=j+sms
ENDIF
IF bloops%(j,1)<>-1 THEN
sa=bloops%(j,1)*mbit
ELSE
sa=-1
ENDIF
IF bloops%(j,2)<>-1 THEN
se=bloops%(j,2)*mbit
ELSE
se=-1
ENDIF
IF bloops%(j,3)<>-1 THEN
sa2=bloops%(j,3)*mbit
ELSE
sa2=-1
ENDIF
IF bloops%(j,4)<>-1 THEN
se2=bloops%(j,4)*mbit
ELSE
se2=-1
ENDIF
ah$=vedmtxt$(j)
IF LEN(ah$)>25 THEN
ah$=LEFT$(ah$,25)
ENDIF
@findblock
IF nomark=TRUE AND blockpos=TRUE THEN
DEC markfre
ENDIF
EXIT IF markfre=loopz
NEXT j
ENDIF
RETURN
'
> PROCEDURE infsave
.| Glob. Var.: blks#,meml#,blksa#,blkse#,infname$,sector#,loopz#,bloopz#
.|     commtxt$,srctxt$
.| Felder    : loops#(),loope#()
.| Ruft auf  : nomem
.| Aufruf in : smpsave-1,record4-1,
LOCAL m,m2,a,b,i,b1,b2,b3,b4
IF virtual=FALSE THEN
IF blks=0 THEN
m=0
m2=INT(meml/mbit)
ELSE
m=INT((blksa-meml)/mbit)
m2=INT((blkse-meml)/mbit)
ENDIF
ELSE
m=0
m2=INT(vmem/mbit)
ENDIF
IF infbutt=TRUE THEN
FOR i=1 TO loopz
FOR j=1 TO 4
IF loops%(i,j)=-1 THEN
bloops%(i,j)=-1
ELSE
bloops%(i,j)=INT(loops%(i,j)/mbit)
ENDIF
NEXT j
NEXT i
ENDIF
a=ASC(LEFT$(infname$,1))-64
IF @dfree(a)>sector THEN
OPEN "O",#2,infname$
binfname$=infname$
PRINT #2,"STARTRACK-INF V2.0"           ! Versionskontrolle
PRINT #2
a$="source="+commtxt$
a=INSTR(a$,CHR$(0))
IF a<>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
PRINT #2,a$+"|"
a$="comment="+srctxt$
a=INSTR(a$,CHR$(0))
IF a<>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
PRINT #2,a$+"|"
a$="loopcount="+STR$(loopz)
PRINT #2,a$
PRINT #2
PRINT #2,"samplerate="+STR$(hz)
PRINT #2
@putpart(drvsrec)   ! aufgenommene Partitionen
PRINT #2,a$
PRINT #2,b$
FOR i=1 TO loopz
b1=INT(loops%(i,1)/mbit)-m
IF b1<m OR b1>m2 THEN
b1=-1
ENDIF
b2=INT(loops%(i,2)/mbit)-m
IF b2<m OR b2>m2 THEN
b2=-1
ENDIF
b3=INT(loops%(i,3)/mbit)-m
IF b3<m OR b3>m2 THEN
b3=-1
ENDIF
b4=INT(loops%(i,4)/mbit)-m
IF b4<m OR b4>m2 THEN
b4=-1
ENDIF
IF b1<>-1 OR b2<>-1 OR b3<>-1 OR b4<>-1 OR edmtxt$(i)<>"" THEN
PRINT #2
ENDIF
IF b1<>-1 THEN
PRINT #2,"loopstart"+STR$(i)+"="+STR$(b1)
ENDIF
IF b2<>-1 THEN
PRINT #2,"loopend"+STR$(i)+"="+STR$(b2)
ENDIF
IF b3<>-1 THEN
PRINT #2,"loopintro"+STR$(i)+"="+STR$(b3)
ENDIF
IF b4<>-1 THEN
PRINT #2,"looprelease"+STR$(i)+"="+STR$(b4)
ENDIF
IF edmtxt$(i)<>"" THEN
a$="loopcomment"+STR$(i)+"="+edmtxt$(i)
PRINT #2,a$+"|"
ENDIF
NEXT i
CLOSE #2
keym=FALSE
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE infload
a=RINSTR(fil$,".")
b$=LEFT$(fil$,a)+inf$
infname$=b$
IF EXIST(infname$) THEN
OPEN "I",#2,b$
INPUT #2,v$              !  "STARTRACK-INF V1.0"  Versionskontrolle
iv=0
IF INSTR(v$,"STARTRACK-INF")<>0 THEN
a=INSTR(v$," V")
IF a<>0 THEN
iv=VAL(RIGHT$(v$,LEN(v$)-a-1))
ENDIF
ENDIF
IF iv=0 THEN
CLOSE #2
OPEN "I",#2,b$
ENDIF
IF iv=0 THEN
FOR i=1 TO bloopz
INPUT #2,bloops%(i,1)
INPUT #2,bloops%(i,2)
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
NEXT i
FOR i=bloopz+1 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
NEXT i
ENDIF
IF iv=1.2 THEN
@inftexts
ENDIF
IF iv>=2 THEN
@infnewtexts
@getnewloops
ENDIF
IF iv=1 OR iv=1.1 OR iv=1.2 THEN
IF iv>=1.1 THEN
INPUT #2,mloopz
IF mloopz>loopz THEN
mloopz=loopz
ENDIF
ELSE
mloopz=100
IF loopz>100 THEN
FOR i=101 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
ENDIF
ENDIF
FOR i=1 TO mloopz
INPUT #2,bloops%(i,1)
INPUT #2,bloops%(i,2)
INPUT #2,bloops%(i,3)
INPUT #2,bloops%(i,4)
c$=""
REPEAT
INPUT #2,a$
IF a$<>CHR$(0) THEN
c$=c$+a$
ENDIF
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
c$=c$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
IF LEN(c$)>25 THEN
c$=LEFT$(c$,25)
ENDIF
vedmtxt$(i)=c$
NEXT i
ENDIF
IF iv=1 OR iv=1.1 THEN
@inftexts
ENDIF
CLOSE #2
ENDIF
keym=FALSE
RETURN
'
> PROCEDURE inftexts
src1$=""
REPEAT
INPUT #2,a$
IF a$<>CHR$(0) THEN
src1$=src1$+a$
ENDIF
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
src1$=src1$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
src2$=""
REPEAT
INPUT #2,a$
IF a$<>CHR$(0) THEN
src2$=src2$+a$
ENDIF
IF a$<>"" AND RIGHT$(a$,1)<>CHR$(0) THEN
src2$=src2$+","
ENDIF
UNTIL a$="" OR RIGHT$(a$,1)=CHR$(0)
RETURN
'
> PROCEDURE infnewtexts
LOCAL z
z=0
REPEAT
EXIT IF EOF(#2)
INPUT #2,a$
@changelowkey2
IF INSTR(a$,"source")<>0 THEN
INC z
@delsourcekey
src1$=a$
IF RIGHT$(a$,1)<>"|" THEN
REPEAT
EXIT IF EOF(#2)
INPUT #2,a$
src1$=src1$+","+a$
UNTIL RIGHT$(a$,1)="|"
ENDIF
src1$=LEFT$(src1$,LEN(src1$)-1)+CHR$(0)
ENDIF
IF INSTR(a$,"comment")<>0 THEN
INC z
@delsourcekey
src2$=a$
IF RIGHT$(a$,1)<>"|" THEN
REPEAT
EXIT IF EOF(#2)
INPUT #2,a$
src2$=src2$+","+a$
UNTIL RIGHT$(a$,1)="|"
ENDIF
src2$=LEFT$(src2$,LEN(src2$)-1)+CHR$(0)
ENDIF
IF INSTR(a$,"loopcount")<>0 THEN
INC z
@delsourcekey
mloopz=VAL(a$)
ENDIF
IF INSTR(a$,"samplerate")<>0 THEN
INC z
@delsourcekey
hz=VAL(a$)
ENDIF
IF INSTR(a$,"partitions")<>0 THEN
@changelowkey
INC z
@delsourcekey
drvsrec=@getpart
ENDIF
IF INSTR(a$,"partitionmode")<>0 THEN
@changelowkey
INC z
@delsourcekey
IF a$="true" THEN
partact=TRUE
ELSE
partact=FALSE
ENDIF
ENDIF
UNTIL z=6 OR EOF(#2)
RETURN
'
> PROCEDURE getnewloops
LOCAL i,a$,c$,a,b
FOR i=1 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
vedmtxt$(i)=""
NEXT i
REPEAT
EXIT IF EOF(#2)
INPUT #2,a$
@changelowkey2
IF INSTR(a$,"loopstart")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-9)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF loopz>=b THEN
bloops%(b,1)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"loopend")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-7)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF loopz>=b THEN
bloops%(b,2)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"loopintro")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-9)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF loopz>=b THEN
bloops%(b,3)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"looprelease")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-11)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF loopz>=b THEN
bloops%(b,4)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"loopcomment")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-11)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
c$=a$
IF RIGHT$(a$,1)<>"|" THEN
REPEAT
EXIT IF EOF(#2)
INPUT #2,a$
c$=c$+","+a$
UNTIL RIGHT$(a$,1)="|"
ENDIF
IF loopz>=b THEN
c$=LEFT$(c$,LEN(c$)-1)
vedmtxt$(b)=c$
ENDIF
ENDIF
ENDIF
UNTIL EOF(#2)
RETURN
'
> PROCEDURE infsave2
IF keym=TRUE THEN
FOR i=kms+1 TO loopz
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
@alerts(62)
IF g=1 THEN
@infsave3
ENDIF
'    sms=1
'    sms2=0
'    vsms=0
IF virtual=FALSE AND nr<>smpedit& THEN
FOR i=1 TO kms
bloops%(i,1)=-1
bloops%(i,2)=-1
bloops%(i,3)=-1
bloops%(i,4)=-1
NEXT i
ELSE
IF g=1 THEN
FOR i=1 TO kms
FOR j=1 TO 4
IF loops%(i,j)<>-1 THEN
bloops%(i,j)=loops%(i,j)/mbit
ENDIF
IF bloops%(i,j)<>-1 THEN
loops%(i,j)=bloops%(i,j)*mbit
ENDIF
NEXT j
NEXT i
ELSE
IF EXIST(infname$) THEN
fil$=infname$
@infload
kms=0
ENDIF
ENDIF
ENDIF
IF nr=smpedit& THEN
a$=STR$(sms)+CHR$(0)
@textfeld(edmnr&,a$,1)
@setslide(edmslide&,edmbut&,loopz,5,vsms)
'      @markhlp3(sms,sms2,bloops%(sms,sms2))
'      @edmarkdel
ENDIF
ENDIF
RETURN
'
> PROCEDURE infsave3
LOCAL m,m2,a,b,i
a=ASC(LEFT$(infname$,1))-64
IF @dfree(a)>sector THEN
OPEN "O",#2,infname$
PRINT #2,"STARTRACK-INF V2.0"           ! Versionskontrolle
IF hdr=TRUE THEN
PRINT #2
a$="source="+vcomm$
a=INSTR(a$,CHR$(0))
IF a<>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
PRINT #2,a$+"|"
a$="comment="+vsrc$
a=INSTR(a$,CHR$(0))
IF a<>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
PRINT #2,a$+"|"
a$="loopcount="+STR$(loopz)
PRINT #2,a$
PRINT #2
PRINT #2,"samplerate="+STR$(hz)
PRINT #2
@putpart(drvsrec)   ! aufgenommene Partitionen
PRINT #2,a$
PRINT #2,b$
FOR i=1 TO loopz
b1=INT(bloops%(i,1)/mbit)
b2=INT(bloops%(i,2)/mbit)
b3=INT(bloops%(i,3)/mbit)
b4=INT(bloops%(i,4)/mbit)
IF b1<>-1 OR b2<>-1 OR b3<>-1 OR b4<>-1 OR vedmtxt$(i)<>"" THEN
PRINT #2
ENDIF
IF b1<>-1 THEN
PRINT #2,"loopstart"+STR$(i)+"="+STR$(b1)
ENDIF
IF b2<>-1 THEN
PRINT #2,"loopend"+STR$(i)+"="+STR$(b2)
ENDIF
IF b3<>-1 THEN
PRINT #2,"loopintro"+STR$(i)+"="+STR$(b3)
ENDIF
IF b4<>-1 THEN
PRINT #2,"looprelease"+STR$(i)+"="+STR$(b4)
ENDIF
IF vedmtxt$(i)<>"" THEN
PRINT #2,"loopcomment"+STR$(i)+"="+vedmtxt$(i)+"|"
ENDIF
NEXT i
ELSE
PRINT #2
a$="source="+comm$+"|"
PRINT #2,a$
a$="comment="+src$+"|"
PRINT #2,a$
a$="loopcount="+STR$(loopz)
PRINT #2,a$
PRINT #2
PRINT #2,"samplerate="+STR$(hz)
PRINT #2
@putpart(drvsrec)   ! aufgenommene Partitionen
PRINT #2,a$
PRINT #2,b$
IF virtual=FALSE THEN
FOR i=1 TO loopz
b=INT(bloops%(i,1)/mbit)
IF b<>-1 THEN
PRINT #2,"loopstart"+STR$(i)+"="+STR$(b)
ENDIF
b=INT(bloops%(i,2)/mbit)
IF b<>-1 THEN
PRINT #2,"loopend"+STR$(i)+"="+STR$(b)
ENDIF
b=INT(bloops%(i,3)/mbit)
IF b<>-1 THEN
PRINT #2,"loopintro"+STR$(i)+"="+STR$(b)
ENDIF
b=INT(bloops%(i,4)/mbit)
IF b<>-1 THEN
PRINT #2,"looprelease"+STR$(i)+"="+STR$(b)
ENDIF
IF edmtxt$(i)<>"" THEN
PRINT #2,"loopcomment"+STR$(i)+"="+edmtxt$(i)+"|"
ENDIF
NEXT i
ELSE
FOR i=1 TO loopz
b=INT(loops%(i,1)/mbit)
IF b<>-1 THEN
PRINT #2,"loopstart"+STR$(i)+"="+STR$(b)
ENDIF
b=INT(loops%(i,2)/mbit)
IF b<>-1 THEN
PRINT #2,"loopend"+STR$(i)+"="+STR$(b)
ENDIF
b=INT(loops%(i,3)/mbit)
IF b<>-1 THEN
PRINT #2,"loopintro"+STR$(i)+"="+STR$(b)
ENDIF
b=INT(loops%(i,4)/mbit)
IF b<>-1 THEN
PRINT #2,"looprelease"+STR$(i)+"="+STR$(b)
ENDIF
IF edmtxt$(i)<>"" THEN
PRINT #2,"loopcomment"+STR$(i)+"="+edmtxt$(i)+"|"
ENDIF
NEXT i
ENDIF
ENDIF
CLOSE #2
keym=FALSE
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE infchange
LOCAL a
IF infbutt=TRUE THEN
vblks=blks
blks=0
IF EXIST(fil$) THEN
a=RINSTR(fil$,".")
IF a>0 THEN
IF LEFT$(fil$,a)=LEFT$(infname$,a) THEN
IF hdp=FALSE THEN
comm$=commtxt$
src$=srctxt$
ELSE
srctxt$=vsrc$
commtxt$=vcomm$
FOR i=1 TO loopz
edmtxt$(i)=vedmtxt$(i)
NEXT i
ENDIF
@infsave
ENDIF
ENDIF
ENDIF
blks=vblks
kms=0
ENDIF
RETURN
'
> PROCEDURE ldhead
.| Glob. Var.: datx#,mdat%,fil$,f#,abz#,abz2#,head#,fileart#,danf#,tst1#
.|     per#,vhz#,tst2#,tst3#,tst4#,tst5#,tst6#,x#,y#,hz#
.| Ruft auf  : makehz,ldhztest
.| Aufruf in : ldhlp-1,trakload-1,hardfs-1,
head=0
tbmin=0
tbmax=0
tblock=0
datx=mdat%
OPEN "I",#1,fil$
f=LOF(#1)
BGET #1,datx,4
abz=DPEEK(datx)
abz2=LPEEK(datx)
IF abz=&HF07E THEN
head=20   ! HeaderlÑnge fÅr S16-Files
fileart=1
ENDIF
IF abz2=&H32424954 THEN
head=128   ! HeaderlÑnge fÅr AVR-Files
fileart=2
ENDIF
IF abz2=&H52494646 THEN
head=44   ! HeaderlÑnge fÅr WAV-Files
fileart=3
ENDIF
IF abz2=&H2E736E64 THEN
head=28   ! HeaderlÑnge fÅr AU und SND-Files
fileart=4
ENDIF
IF abz2=&H538000C THEN
head=1336 ! HeaderlÑnge fÅr SD-Files
fileart=5
ENDIF
IF abz2=&HF07E0001 THEN
head=296 ! HeaderlÑnge fÅr Avalon SMP-Files
fileart=6
ENDIF
IF abz2=&H464F524D THEN
head=54+458 ! HeaderlÑnge fÅr AIFF-Files
fileart=7
ENDIF
IF head>4 THEN
IF fileart<>6 THEN
BGET #1,datx+4,head-4
ELSE
SEEK #1,LOF(#1)-head
BGET #1,datx,head
ENDIF
ENDIF
CLOSE #1
danf=datx
IF fileart=7 THEN        ! AIFF-Format
tst1=LPEEK(danf+8)     ! AIFF-Kennung
tst2=LPEEK(danf+12)    ! COMM-Kennung
tst3=DPEEK(danf+20)    ! Channels
tst4=LPEEK(danf+38)    ! SSND-Kennung
tst5=DPEEK(danf+26)    ! Bits
IF tst5=16 THEN
@setbitrate16
ENDIF
IF tst5=24 THEN
@setbitrate24
ENDIF
'
IF tst1=&H41494646 AND tst2=&H434F4D4D AND tst3=2 AND tst4=&H53534E44 AND (tst5=16 OR tst5=24) THEN
per=DPEEK(danf+30)     ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=@hzanalye(per)
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=6 THEN        ! Avalon SMP-Format
tst1=DPEEK(danf+76)    ! Bits
IF tst1=16 THEN
per=LPEEK(danf+72)     ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=@hzanalye(per)
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=5 THEN        ! SD-Format
per=LPEEK(danf+1020)   ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=@hzanalye(per)
ENDIF
vhz=per
ENDIF
IF fileart=4 THEN        ! AU-Format
tst1=LPEEK(danf+12)    ! dataformat
tst2=LPEEK(danf+20)    ! channelcount
IF tst1=3 AND tst2=2 THEN
per=LPEEK(danf+16)    ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=@hzanalye(per)
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=3 THEN        ! WAV-Format
tst1=LPEEK(danf+8)     ! "WAVE"
tst2=LPEEK(danf+12)    ! "fmt "
tst3=PEEK(danf+20)     ! format
tst4=PEEK(danf+22)     ! channels
tst5=PEEK(danf+32)     ! align
tst6=PEEK(danf+34)     ! bps
IF tst6=16 THEN
@setbitrate16
ENDIF
IF tst6=24 THEN
@setbitrate24
ENDIF
IF tst1=&H57415645 AND tst2=&H666D7420 AND tst3=1 AND tst4=2 AND tst5=4 AND (tst6=16 OR tst6=24) THEN
per=PEEK(danf+24)+256*PEEK(danf+25)    ! Sample-Rate
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=@hzanalye(per)
ENDIF
vhz=per
ENDIF
ENDIF
IF fileart=2 THEN        ! AVR-Format
tst1=DPEEK(danf+12)    ! mode
tst2=DPEEK(danf+14)    ! resolution
IF tst2=16 THEN
@setbitrate16
ENDIF
IF tst2=24 THEN
@setbitrate24
ENDIF
tst3=DPEEK(danf+16)    ! sign
IF tst1=&HFFFF AND (tst2=16 OR tst2=24) AND tst3=&HFFFF THEN
per=DPEEK(danf+24)    ! Sample-Rate
la=DPEEK(danf+18)                           ! Loop ?
IF la=&HFFFF THEN
tblock=1
tbmin=LPEEK(danf+30)*2                          ! Sustain Loop-Start
tbmax=LPEEK(danf+34)*2                           ! Sustain Loop-End
ENDIF
ENDIF
IF per<>32000 AND per<>44100 AND per<>48000 THEN
per=@hzanalye(per)
ENDIF
vhz=per
ENDIF
IF fileart=1 THEN                   ! S16-Format
IF RINSTR(fil$,".")<>0
IF RINSTR(fil$,".S24")<>0 THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
ENDIF
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
la=PEEK(danf+19)                          ! Loop-Art
IF la<>&H7F THEN
tblock=1
x3=PEEK(danf+13)                           ! Sustain Loop-Start
y3=DPEEK(danf+14)                          ! Sustain Loop-Start
tbmin=x3*65536+y3
x4=DPEEK(danf+16)                          ! Sustain Loop-End
y4=PEEK(danf+18)                           ! Sustain Loop-End
tbmax=x4*256+y4
ENDIF
IF x=0 AND y=0 THEN
@makehz
per=hz
ELSE
per=INT(10^9/(x*65536+y))
per=@hzanalye(per)
ENDIF
per=@hzanalye(per)
IF per<>32000 AND per<>44100 AND per<>48000 THEN
@ldhztest
ENDIF
vhz=per
ENDIF
IF fileart=0 THEN
vhz=@hzanalye(hz)
ENDIF
RETURN
'
> PROCEDURE clsed
.| Glob. Var.: nr#,smpedit&,smptsa&,smptsb&,smptsc&,smptsd&,smptse&
.|     smptsava&,smptea&,smpteb&,smptec&,smpted&,smptee&,smptsavb&,hacksa&
.|     hacksb&,hacksc&,hacksd&,hackse&,hackss&,hackea&,hackeb&,hackec&
.|     hacked&,hackee&,hackes&,smpsta&,smpstb&,smpstc&,smpstd&,smpste&
.|     smpsavl&,smpea&,smpeb&,smpec&,smped&,smpee&,smpsavr&,sms#,sme#
.|     master#,sblock#,smppmark&,sloop#,smploop&,a$,popups&,smpmark&,mover&
.|     smark#
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : ldhlp-2,smpedit-2,trash-2,memtovirt-1,memtovirt2-1,record2-1,
LOCAL hac$,mem$
mem$=SPACE$(14)+CHR$(0)
IF nr=smpedit& THEN
@textfeld(edmtxt&,mem$,1)
@textfeld(edmtims&,mem$,1)
@textfeld(edmtime&,mem$,1)
@textfeld(edmtimi&,mem$,1)
@textfeld(edmtimr&,mem$,1)
@setbutton(edmbuts&,0)
@setbutton(edmbute&,0)
@setbutton(edmbuti&,0)
@setbutton(edmbutr&,0)
ENDIF
sms=1
sms2=0
sblock=0
blks=0
IF nr=smpedit& THEN
@setbutton(smppmark&,0)
IF sloop!=TRUE THEN
@setbutton(smploop&,1)
ELSE
@setbutton(smploop&,0)
ENDIF
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
ENDIF
smark=3
RETURN
'
> PROCEDURE curvetest(cs,ce)
.| Glob. Var.: zoomstop#
.| Aufruf in : zoomhelp-1,smpr-1,
zoomstop=FALSE
LOCAL xm,len,stp,bs
xm=617
len=ce-cs
stp=(INT(len/xm))
stp=(INT((stp+1)/mbit)*mbit)
bs=0
IF stp=0 THEN
stp=mbit
IF len>xm*mbit THEN
bs=len/xm/mbit
ELSE
bs=xm*mbit/len
ENDIF
ENDIF
IF bs>7 THEN
zoomstop=TRUE
ENDIF
RETURN
'
> PROCEDURE writeyproz
.| Glob. Var.: max#,yzoom#,wyzoom#,rubmax#,rp0&,lp0&,lp20&,lm20&,rp20&,rm20&
.|     lp40&,lm40&,rp40&,rm40&,lp60&,lm60&,rp60&,rm60&,lp80&,lm80&,rp80&
.|     rm80&,byzoom#
.| Ruft auf  : textfeld
.| Aufruf in : rubbermax-1,curve-2,smpedit-1,
LOCAL a,m,b$
IF max=0 OR (yzoom=FALSE AND wyzoom=FALSE) THEN
m=32767
ELSE
m=max
ENDIF
IF wyzoom=TRUE THEN
m=rubmax
ENDIF
a=100/32767*m
b$=" 0-"+CHR$(0)
@textfeld(rp0&,b$,1)
@textfeld(lp0&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*2))+"-",3)+CHR$(0)
@textfeld(lp20&,b$,1)
@textfeld(lm20&,b$,1)
@textfeld(rp20&,b$,1)
@textfeld(rm20&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*4))+"-",3)+CHR$(0)
@textfeld(lp40&,b$,1)
@textfeld(lm40&,b$,1)
@textfeld(rp40&,b$,1)
@textfeld(rm40&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*6))+"-",3)+CHR$(0)
@textfeld(lp60&,b$,1)
@textfeld(lm60&,b$,1)
@textfeld(rp60&,b$,1)
@textfeld(rm60&,b$,1)
b$=RIGHT$(" "+STR$(INT(a/10*8))+"-",3)+CHR$(0)
@textfeld(lp80&,b$,1)
@textfeld(lm80&,b$,1)
@textfeld(rp80&,b$,1)
@textfeld(rm80&,b$,1)
b$=RIGHT$("  "+STR$(INT(a)),3)+CHR$(0)
@textfeld(lr100&,b$,1)
byzoom=yzoom
RETURN
'
> PROCEDURE getcurve
ym1=ay&+41+8          ! Y-Locator erste Box
ym2=ym2+ym1+3         ! Y-Locator zweite Box
LOCAL x,y,b,h
IF nr=smpedit& THEN
IF windcache=TRUE THEN
@windowtest
@markhlp
@calc_editboxes1
IF bigfoot=FALSE THEN
x=ax&+23-1          ! X-Locator
y=ay&+41-8          ! Y-Locator erste Box
b=xm+3              ! Breite der Box
h=ym*2+24              ! Hîhe der Box
ELSE
x=ax&+31            ! X-Locator
y=ay&+40            ! Y-Locator erste Box
b=xm+4              ! Breite der Box
h=ym*2+43           ! Hîhe der Box
ENDIF
lmcurv=b*h*planes&/8
~GRAF_MOUSE(256,0)                              ! Hidem
IF shading=FALSE AND dopix=FALSE THEN
memc=@rsc_get2(x,y,b,h,memc)
ENDIF
IF ((x+b)>xwidth OR (y+h)>ywidth) THEN
drawnew2=TRUE
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ELSE
drawnew2=TRUE
cached=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE putcsize
IF bigfoot=FALSE THEN
x=ax&+23-1          ! X-Locator
y=ay&+41-8          ! Y-Locator erste Box
b=xm+3              ! Breite der Box
h=ym*2+24              ! Hîhe der Box
ELSE
x=ax&+31            ! X-Locator
y=ay&+40            ! Y-Locator erste Box
b=xm+4              ! Breite der Box
h=ym*2+43           ! Hîhe der Box
ENDIF
IF nr=smpedit& THEN
IF (x+b)>xwidth OR (y+h)>ywidth THEN
drawnew2=TRUE
ELSE
IF drawnew2=TRUE THEN
credraw=TRUE
@curve(cs,ce)
@blkupdate
credraw=FALSE
@getcurve
ENDIF
drawnew2=FALSE
ENDIF
ELSE
drawnew2=FALSE
ENDIF
RETURN
'
> PROCEDURE putcurve
LOCAL x,y,b,h
IF nr=smpedit& THEN
@windowtest
@markhlp
@edit_timetxt
IF windcache=TRUE THEN
@putcsize
IF (x1+b1)>=x AND x1<=x+b AND (y1+h1)>=y AND y1<=y+h THEN
mx=x1
my=y1
mx1=x1-x
my1=y1-y
IF x1<x THEN
mx1=0
mx=x
ENDIF
IF y1<y THEN
my1=0
my=y
ENDIF
mb1=b1
mh1=h1
IF x1<x THEN
mb1=(x1+b1)-x
ENDIF
IF y1<y THEN
mh1=(y1+h1)-y
ENDIF
IF mb1>b THEN
mb1=b
ENDIF
IF mh1>h THEN
mh1=h
ENDIF
IF mx+mb1>x+b THEN
mb1=(x+b)-mx
ENDIF
IF my+mh1>y+h THEN
mh1=(y+h)-my
ENDIF
'
IF mx+mb1>xwidth THEN
mb1=xwidth-mx
ENDIF
IF my+mh1>ywidth THEN
mh1=ywidth-my
ENDIF
IF mx>=x AND my>=y AND mx1>=0 AND my1>=0 AND mb1>0 AND mh1>0 THEN
IF shading=FALSE AND dopix=FALSE THEN
~GRAF_MOUSE(256,0)                              ! Hidem
@rsc_putblock(memc,mx,my,mx1,my1,mb1,mh1)
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
ENDIF
ELSE
drawnew2=TRUE
cached=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE curve(cs,ce)
@windowtest
@markhlp
@calc_editboxes2
xmc=xm              ! Breite der Box
ymc=ym              ! Hîhe der Box
mtrak=FALSE
trc=0               ! Tracker-Cache-ZÑhler
IF tcach(trc)=TRUE AND trkmax(trc)>0 THEN
max=trkmax(trc)
ELSE
max=32767
trkmax(trc)=max
ENDIF
IF trkmemr=TRUE AND cached=FALSE THEN
@getmem
trkmemr=FALSE
ENDIF
IF shading=FALSE AND dopix=FALSE THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
'
@edit_timetxt
'
@undercurve(cs,ce,0,xmc,xmc)
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
'
tcach(trc)=TRUE
IF trkmem(1)=0 THEN
trkmem(1)=trkmem(0)+xmc*8
ENDIF
RETURN
'
> PROCEDURE mcurve(cs,ce,xmc,ymc,cxd,ym1,ym2,tcs,tce,glen)
LOCAL vvirtual
@windowtest
@markhlp
'  cs    ! Anfang-Samples
'  ce    ! Ende Samples
'  xmc   ! Breite der Box
'  ymc   ! Hîhe der Box
'  cxd   ! X-Locator
'  ym1   ! Y-Locator erste Box
'  ym2   ! Y-Locator zweite Box
'  tcs   ! Darstellungsanfang
'  tce   ! Darstellungsende
'  glen  ! gesamtzahl der zu berechnenden Pixel
mtrak=TRUE
vvirtual=virtual
virtual=FALSE
IF tcach(trc)=TRUE AND trkmax(trc)>0 THEN
max=trkmax(trc)
ELSE
max=32767
trkmax(trc)=max
ENDIF
IF shading=FALSE AND dopix=FALSE THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
@undercurve(cs,ce,tcs,tce,glen)
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
virtual=vvirtual
RETURN
'
> PROCEDURE undercurve(cs,ce,ccs,cce,ccg)
.| Glob. Var.: zoomstop#,grids#,maxcol#,xd#,ym1#,xm#,ym#,ym2#,mbs#,col#,ax#
.|     bx#,yline#,virtcurve#,virtual#,maxcwert#,mlen#,vce#,vcs#,cached#,wa#
.|     vmem#,wb#,stp#,j#,m1#,m2#,m3#,m4#,cwertep1#,cwertep2#,cwertem1#
.|     cwertem2#,max#,max2#,ldlen#,mrkp$,virtpath$,meml#,yd#,sline#,bs#,ci#
.|     am#,y2#,yzoom#,aa#,wyzoom#,rubmax#,aam#
.| Felder    : mblocks#(),mblocke#(),cachep1#(),cachep2#(),cachem1#()
.|     cachem2#()
.| Ruft auf  : markhlp,maschinit31,maschruf31,writeyproz,drawcurve,markhlp3
.| Aufruf in : message-2,restaura4-1,smpload-2,smpedit-1,time_edit-1
.|     record2-1,
LOCAL c$,s,e,l,y,len,adr,i,a,z,m,k,d,xdi,ydi
zoomstop=FALSE
GRAPHMODE 1
'
' COLORS: 0=weiss,1=schwarz,2=rot,3=grÅn,4=blau,5=cyan,6=gelb,7=magenta,8=hellgrau
'         9=dunkelgrau,10=dunkelrot,11=dunkelgrÅn,12=dunkelblau,13=dunkelcyan,14=dunkelgelb,15=dunkelmagenta
'
IF grids=1 AND mtrak=FALSE THEN
IF maxcol<=2 THEN
DEFFILL 0,1,8
ELSE
DEFFILL 9,1,9
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX cxd+1,ym1,cxd+xmc,ym1+ymc
PBOX cxd+1,ym2,cxd+xmc,ym2+ymc
IF mbs>0 THEN
col=1
FOR i=1 TO mbs
INC col
ax=mblocks(i)
bx=mblocke(i)
IF (ce-cs)>0 AND (bx-ax)>0 THEN
IF ax<cs AND bx>cs THEN
ax=cs
ENDIF
IF bx>ce AND ax>=cs AND ax<=ce THEN
bx=ce
ENDIF
IF ax>=cs AND ax<=ce AND bx>=cs AND bx<=ce AND (ce-cs)>0 AND (bx-ax)>0 THEN
ax=ax-cs
ax=ax/(ce-cs)*xmc
bx=bx-cs
bx=bx/(ce-cs)*xmc
IF maxcol<=2 THEN
DEFFILL 1,3,col
IF col=13 THEN
col=1
ENDIF
ELSE
IF col=8 THEN
col=10
ENDIF
IF col=16 THEN
col=2
ENDIF
DEFFILL col,1,8
ENDIF
PBOX cxd+ax+1,ym1,cxd+bx,ym1+ymc
PBOX cxd+ax+1,ym2,cxd+bx,ym2+ymc
ENDIF
ENDIF
NEXT i
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
IF yline=TRUE AND mtrak=FALSE THEN
~GRAF_MOUSE(256,0)                              ! Hidem
DEFLINE 2
GRAPHMODE 3
q=(ym+3)/10
'
LINE cxd+1,ym1-1+q,cxd+xmc,ym1-1+q
LINE cxd+1,ym1-1+q*2,cxd+xmc,ym1-1+q*2
LINE cxd+1,ym1-1+q*3,cxd+xmc,ym1-1+q*3
LINE cxd+1,ym1-1+q*4,cxd+xmc,ym1-1+q*4
LINE cxd+1,ym1-1+q*6,cxd+xmc,ym1-1+q*6
LINE cxd+1,ym1-1+q*7,cxd+xmc,ym1-1+q*7
LINE cxd+1,ym1-1+q*8,cxd+xmc,ym1-1+q*8
LINE cxd+1,ym1-1+q*9,cxd+xmc,ym1-1+q*9
LINE cxd+1,ym2-1+q,cxd+xmc,ym2-1+q
LINE cxd+1,ym2-1+q*2,cxd+xmc,ym2-1+q*2
LINE cxd+1,ym2-1+q*3,cxd+xmc,ym2-1+q*3
LINE cxd+1,ym2-1+q*4,cxd+xmc,ym2-1+q*4
LINE cxd+1,ym2-1+q*6,cxd+xmc,ym2-1+q*6
LINE cxd+1,ym2-1+q*7,cxd+xmc,ym2-1+q*7
LINE cxd+1,ym2-1+q*8,cxd+xmc,ym2-1+q*8
LINE cxd+1,ym2-1+q*9,cxd+xmc,ym2-1+q*9
GRAPHMODE 1
DEFLINE 1
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
virtcurve=FALSE
IF virtual=TRUE AND maxcwert>0 THEN
IF ce-cs>mlen THEN
IF pbufda=TRUE THEN
IF cached=FALSE THEN
@makepbuf
vce=0
vcs=0
virtcurve=TRUE
cached=TRUE
wa=0
IF ce>0 THEN
wb=maxcwert
ELSE
wb=0
ENDIF
wa=INT(wa)
wb=INT(wb)
stp=(wb-wa)/ccg
j=0
max=0
i=wa+1
'
tma=trkmem(trc)
IF trc=0 AND trkg(trc)<>(ccg+1) AND trkz>0 THEN
glen=ccg+1
@trksprint
ENDIF
trkg(trc)=ccg+1
' Reihenfolge des Caches: p1,m1,p2,m2 jeweils Word-Grîûe
'
REPEAT
INC j
IF j<=ccg THEN
a=LPEEK(cwertep1+INT(i)*4)
IF max<a AND a>0 THEN
max=a
ENDIF
DPOKE tma+(j-1)*8,a
a=LPEEK(cwertep2+INT(i)*4)
IF max<a AND a>0 THEN
max=a
ENDIF
DPOKE tma+(j-1)*8+4,a
a=LPEEK(cwertem1+INT(i)*4)
IF max<a AND a>0 THEN
max=a
ENDIF
DPOKE tma+(j-1)*8+2,a
a=LPEEK(cwertem2+INT(i)*4)
IF max<a AND a>0 THEN
max=a
ENDIF
DPOKE tma+(j-1)*8+6,a
ENDIF
i=i+stp
UNTIL i>=wb
trkmax(trc)=max
ENDIF
ENDIF
ELSE
IF cs<vcs OR ce>vce OR vce=0 THEN
IF cs<vcs THEN
IF mlen>ce-cs AND ce-mlen>=0 THEN
ldlen=mlen
ELSE
ldlen=ce-cs
ENDIF
virtcurve=FALSE
cached=FALSE
vce=ce
vcs=ce-ldlen
IF vcs=0 THEN
ldlen=mlen
vce=mlen
ENDIF
OPEN "I",#1,virtpath$
'          OPEN "I",#1,mrkp$    ! falsch ?
SEEK #1,vcs+head
ELSE
IF mlen>ce-cs AND vmem-cs>=mlen THEN
ldlen=mlen
ELSE
ldlen=ce-cs
ENDIF
IF cs+ldlen>vmem THEN
ldlen=vmem-cs
ENDIF
virtcurve=FALSE
cached=FALSE
vcs=cs
vce=cs+ldlen
OPEN "I",#1,virtpath$
SEEK #1,cs+head
ENDIF
BGET #1,meml,ldlen
IF fileart=3 THEN
@maschruf28(meml,ldlen)   ! swap to wave
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
CLOSE #1
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
xdi=cxd+1   ! X-Locator fÅr Mittellinien
ydi=ym1+ymc/2   ! Mittellinie erste Box
ydi2=ym2+ymc/2  ! Mittellinie zweite Box
len=ce-cs
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~WIND_UPDATE(3)                                    ! BEG_UPDATE
LINE xdi-1,ydi,xdi+xmc,ydi
LINE xdi-1,ydi2,xdi+xmc,ydi2
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~WIND_UPDATE(2)                                    ! BEG_UPDATE
stp=(INT(len/ccg))
stp=(INT((stp+1)/mbit)*mbit)
COLOR 0
l=xdi
y=ydi
IF virtcurve=FALSE THEN
IF stp=0 THEN
stp=len/ccg
ENDIF
adr=meml
ELSE
adr=0
ENDIF
COLOR 1
IF cached=FALSE THEN
ci=0
max=0
tma=trkmem(trc)
IF trc=0 AND trkg(trc)<>(ccg+1) AND trkz>0 THEN
glen=ccg+1
@trksprint
ENDIF
trkg(trc)=ccg+1
FOR v=adr+cs TO adr+ce-stp STEP stp
i=INT(v/mbit)*mbit
@maschruf31
IF max<a AND a>0 THEN
max=a
ENDIF
IF max<am AND am>0 THEN
max=am
ENDIF
INC ci
IF ci<=ccg THEN
DPOKE tma+(ci-1)*8,a
ENDIF
IF ci<=ccg THEN
DPOKE tma+(ci-1)*8+2,am
ENDIF
NEXT v
ci=0
l=xdi
FOR v=adr+cs TO adr+ce-stp STEP stp
i=INT(v/mbit)*mbit+(mbit/2)
@maschruf31
IF max<a AND a>0 THEN
max=a
ENDIF
IF max<am AND am>0 THEN
max=am
ENDIF
INC ci
IF ci<=ccg THEN
DPOKE tma+(ci-1)*8+4,a
ENDIF
IF ci<=ccg THEN
DPOKE tma+(ci-1)*8+6,am
ENDIF
NEXT v
trkmax(trc)=max
cached=TRUE
ENDIF
@buildcurve
~GRAF_MOUSE(257,0)                              ! Showm
RETURN
'
> PROCEDURE edit_timetxt
LOCAL i,f,vf,xdv,ttxlin,ttyd,tg,edyd,edxlin
IF bigfoot=TRUE THEN
@markhlp
@findaxe
f=cs/mbit/hz*framez              ! x-timetext offset
xdv=0
IF (f/axestm)<>INT(f/axestm) THEN
vf=axestm+(f/axestm)*axestm
xdv=axestl/axestm*(vf-f)         ! x-axelocation offset
f=vf
ENDIF
IF bigfoot=FALSE THEN
edxlin=xdv+ax&+22     ! x-axelocation
ELSE
edxlin=xdv+ax&+31
ENDIF
i=0
REPEAT
IF maxcol=2 OR dreidim=0 THEN
COLOR 1
ELSE
COLOR 0
ENDIF
IF (xdv+axestl*i)<=xm THEN
IF bigfoot=FALSE THEN
LINE edxlin+axestl*i,ay&+45,edxlin+axestl*i,ay&+49
ELSE
LINE edxlin+axestl*i,ay&+68,edxlin+axestl*i,ay&+72
ENDIF
ENDIF
INC i
UNTIL (xdv+axestl*(i-1))>xm OR axeover=TRUE
IF bigfoot=FALSE THEN
edyd=43   ! y-textlocation
tg=43     ! textgrenze zum rechten rand
ELSE
edyd=68
tg=22
ENDIF
i=0
REPEAT
IF (xdv+axestl*i+tg)<=xm THEN
hsec=f+i*axestm
@htimeset3
IF i/2=INT(i/2) THEN
c=0
ELSE
c=6
ENDIF
IF bigfoot=FALSE THEN
@bigtext3(edxlin+25+axestl*i,ay&+edyd,1,a$,0,c)
ELSE
@bigtext3(edxlin+15+axestl*i,ay&+edyd,1,a$,0,c)
ENDIF
ENDIF
INC i
UNTIL (xdv+axestl*(i-1)+tg)>xm OR axeover=TRUE
axeover=FALSE
ENDIF
RETURN
'
> PROCEDURE findaxe
LOCAL s,smax,st,stm,stl
IF hz=0 THEN
hz=44100
ENDIF
s=INT((ce-cs)/mbit/hz*framez)
axeover=FALSE
IF s<1 THEN
s=1
axeover=TRUE
ENDIF
smax=10                    ! max 10 Einteilungs-Striche auf der Zeitachse
st=s/smax                  ! Block in 100tel
stm=1                      ! Timescale
IF framez=24 THEN
IF st>1 THEN              ! 100tel sec-scales
stm=2
ENDIF
IF st>2 THEN              ! 100tel sec-scales
stm=4
ENDIF
IF st>4 THEN              ! 100tel sec-scales
stm=6
ENDIF
IF st>6 THEN              ! 100tel sec-scales
stm=8
ENDIF
IF st>8 THEN
stm=12
ENDIF
IF st>12 THEN
stm=24
ENDIF
ENDIF
IF framez=25 THEN
IF st>1 THEN              ! 100tel sec-scales
stm=5
ENDIF
IF st>5 THEN              ! 100tel sec-scales
stm=25
ENDIF
ENDIF
IF framez=30 THEN
IF st>1 THEN              ! 100tel sec-scales
stm=2
ENDIF
IF st>2 THEN              ! 100tel sec-scales
stm=5
ENDIF
IF st>5 THEN              ! 100tel sec-scales
stm=10
ENDIF
IF st>10 THEN              ! 100tel sec-scales
stm=15
ENDIF
IF st>15 THEN
stm=30
ENDIF
ENDIF
IF framez=75 THEN
IF st>1 THEN              ! 100tel sec-scales
stm=5
ENDIF
IF st>5 THEN              ! 100tel sec-scales
stm=15
ENDIF
IF st>15 THEN              ! 100tel sec-scales
stm=75
ENDIF
ENDIF
IF framez=100 THEN
IF st>1 THEN              ! 100tel sec-scales
stm=2
ENDIF
IF st>2 THEN              ! 100tel sec-scales
stm=5
ENDIF
IF st>5 THEN              ! 100tel sec-scales
stm=10
ENDIF
IF st>10 THEN              ! 100tel sec-scales
stm=20
ENDIF
IF st>20 THEN
stm=25
ENDIF
IF st>25 THEN
stm=50
ENDIF
IF st>50 THEN
stm=100
ENDIF
ENDIF
stm=@findaxes(stm,st,1)    ! sec-scales
stm=@findaxes(stm,st,60)   ! min-scales
stm=@findaxes(stm,st,3600) ! h-scales
axestl=xm/s*stm               ! Pixel pro block
axestm=stm
RETURN
'
> FUNCTION findaxes(stm,st,t)
IF st>framez*1*t THEN
stm=framez*2*t
ENDIF
IF st>framez*2*t THEN
stm=framez*5*t
ENDIF
IF st>framez*5*t THEN
stm=framez*10*t
ENDIF
IF st>framez*10*t THEN
stm=framez*20*t
ENDIF
IF st>framez*20*t THEN
stm=framez*30*t
ENDIF
IF st>framez*30*t THEN
stm=framez*60*t
ENDIF
IF st>framez*60*t THEN
stm=framez*60*2*t
ENDIF
RETURN stm
ENDFUNC
'
> PROCEDURE buildcurve
istp=1
cstp=1
IF INT((ce-cs)/mbit)<=xmc THEN
IF vertline=TRUE AND linkdot=FALSE AND spacefill=FALSE THEN
istp=(4/stp)
cstp=xmc/(xmc/istp)
ENDIF
IF vertline=TRUE AND linkdot=TRUE AND spacefill=FALSE THEN
istp2=(4/stp)
cstp2=xmc/(xmc/istp2)
ENDIF
ENDIF
IF mtrak=FALSE THEN
@writeyproz
ENDIF
l=xdi
l2=l
y2=y
tma=trkmem(trc)
FOR i=ccs TO cce STEP istp
ir=INT(i)
IF l<=(xmc+xdi) THEN
a=DPEEK(tma+ir*8)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aa=INT(a/max*ymc/2)
ELSE
aa=INT(a/32767*ymc/2)
ENDIF
IF wyzoom=TRUE THEN
aa=INT(a/rubmax*ymc/2)
IF aa>ymc/2 THEN
aa=ymc/2
ENDIF
ENDIF
ELSE
aa=0
ENDIF
a=ydi-aa
am=DPEEK(tma+ir*8+2)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aam=INT(am/max*ymc/2)
ELSE
aam=INT(am/32767*ymc/2)
ENDIF
IF wyzoom=TRUE THEN
aam=INT(am/rubmax*ymc/2)
'
'
'   fehlerhaftes dragging
'
'
'
IF aam>ymc/2 THEN
aam=ymc/2
ENDIF
ENDIF
ELSE
aam=0
ENDIF
am=aam+ydi
IF INT((ce-cs)/mbit)<=xmc THEN
IF linkdot=TRUE AND spacefill=FALSE THEN
IF l>=xdi+cstp THEN
IF a<>ydi THEN
LINE l-cstp,y2,l,a
y2=a
ELSE
LINE l-cstp,y2,l,am
y2=am
ENDIF
ELSE
IF a<>ydi THEN
'              LINE l,y2,l,a
y2=a
ELSE
'              LINE l,y2,l,am
y2=am
ENDIF
ENDIF
IF vertline=TRUE THEN
REPEAT
IF l2<l THEN
l2=l2+cstp2
ENDIF
UNTIL l2>=l
IF INT(l2)=l THEN
LINE l2,a,l2,am
ENDIF
ENDIF
ELSE
LINE l,a,l,am
ENDIF
ELSE
LINE l,a,l,am
ENDIF
ENDIF
l=l+cstp
NEXT i
l=xdi
l2=l
y=ydi2
y2=y
FOR i=ccs TO cce STEP istp
ir=INT(i)
IF l<=(xmc+xdi) THEN
a=DPEEK(tma+ir*8+4)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aa=INT(a/max*ymc/2)
ELSE
aa=INT(a/32767*ymc/2)
ENDIF
IF wyzoom=TRUE THEN
aa=INT(a/rubmax*ymc/2)
IF aa>ymc/2 THEN
aa=ymc/2
ENDIF
ENDIF
ELSE
aa=0
ENDIF
a=ydi2-aa
am=DPEEK(tma+ir*8+6)
IF max>0 THEN
IF yzoom=TRUE OR wyzoom=TRUE THEN
aam=INT(am/max*ymc/2)
ELSE
aam=INT(am/32767*ymc/2)
ENDIF
IF wyzoom=TRUE THEN
aam=INT(am/rubmax*ymc/2)
IF aam>ymc/2 THEN
aam=ymc/2
ENDIF
ENDIF
ELSE
aam=0
ENDIF
am=aam+ydi2
IF INT((ce-cs)/mbit)<=xmc THEN
IF linkdot=TRUE AND spacefill=FALSE THEN
IF l>=xdi+cstp THEN
IF a<>ydi2 THEN
LINE l-cstp,y2,l,a
y2=a
ELSE
LINE l-cstp,y2,l,am
y2=am
ENDIF
ELSE
IF a<>ydi2 THEN
'              LINE l,y2,l,a   !!
y2=a
ELSE
'              LINE l,y2,l,am  !!
y2=am
ENDIF
ENDIF
IF vertline=TRUE THEN
REPEAT
IF l2<l THEN
l2=l2+cstp2
ENDIF
UNTIL l2>=l
IF INT(l2)=l THEN
LINE l2,a,l2,am
ENDIF
ENDIF
ELSE
LINE l,a,l,am
ENDIF
ELSE
LINE l,a,l,am
ENDIF
ENDIF
l=l+cstp
NEXT i
IF mtrak=FALSE AND cupdate=FALSE THEN
@markhlp3(9998,0,cs)
@markhlp3(9999,0,ce)
ENDIF
RETURN
'
> PROCEDURE adjustresmp
.| Glob. Var.: adjrsmp#,adjresmp#
.| Aufruf in : resample-1,
IF adjresmp=FALSE THEN
adjresmp=TRUE
IF aretime=1 THEN
retime=aretime
ENDIF
ELSE
adjresmp=FALSE
aretime=retime
retime=0
ENDIF
@resmptxt
RETURN
'
> PROCEDURE resmptxt
.| Glob. Var.: sblock#,len#,mlen#,resorig#,resoth#,c2#,c1#,a$,resmplen&,hz#
.|     resmpsec&,resmpfac&
.| Ruft auf  : textfeld
.| Aufruf in : resample-6,
@editread(restxt&)
resorig=VAL(a$)
@editread(resother&)
resoth=VAL(a$)
IF LEN(a$)=3 THEN
resorig=resorig/10
ENDIF
IF LEN(a$)=3 THEN
resoth=resoth/10
ENDIF
IF resorig>0 THEN
IF sblock=0 THEN
IF virtual=FALSE THEN
len=INT(mlen/resorig*resoth/mbit)
ELSE
len=INT(vmem/resorig*resoth/mbit)
ENDIF
ELSE
len=INT((c2-c1)/resorig*resoth/mbit)
ENDIF
ELSE
len=0
ENDIF
a$=STR$(len)+" samples"+CHR$(0)
@textfeld(resmplen&,a$,1)
len=INT(len/hz*1000)/1000
IF adjresmp=FALSE THEN
hsec=INT(len*100)
ELSE
hsec=INT(len/resoth*resorig*100)
ENDIF
@htimeset
a$="TIME "+a$
'  a$=STR$(len)+" sec"+CHR$(0)
@textfeld(resmpsec&,a$,1)
IF resorig>0 THEN
len=((resoth/resorig)*100)
ELSE
len=0
ENDIF
len=INT(len+1.0E-07)/100
a$="Factor "+STR$(len)+CHR$(0)
@textfeld(resmpfac&,a$,1)
RETURN
'
> PROCEDURE resample
.| Glob. Var.: makecurve#,vorvornr#,vornr#,nr#,resample&,resorig#,hz#,db$
.|     restxt&,resoth#,resother&,sblock#,c2#,c1#,sms#,sme#,adjresmp#
.|     adjresmp&,obj#,popup&,zu%,zuadr#,edit_obj&,resl1&,resl2&,resl3&
.|     resr1&,resr2&,resr3&,res32&,res44&,res48&,helprsmp&,resok&,resexit&
.|     noresok#,a$,i#,a#,g#,resmp&
.| Ruft auf  : makehz,rsc_draw,markhlp,editfeld,textfeld,blocklook,resmptxt
.|     setbutton,rsc_do,xrsrc_gaddr,resl,resr,adjustresmp,resoth32,resoth44
.|     resoth48,helptxt,editread,makeresmp,rsc_back,blkrestaura
.| Aufruf in : do_blkf-1,
@testcopyright
makecurve=0
vorvornr=vornr
vornr=nr
nr=resample&
@makehz
resorig=INT(hz/100)
db$=RIGHT$("000"+STR$(resorig),3)+CHR$(0)
resorig=resorig/10
resoth=32
a$=@rsc_text$(popups&,rate32&)
@textfeld2(nr,resmpsel&,a$,1)
@editfeld2(nr,restxt&,db$)
db$=RIGHT$("000"+STR$(INT(resoth*10)),3)+CHR$(0)
@editfeld2(nr,resother&,db$)
IF adjresmp=TRUE THEN
@setbutton3(adjresmp&,1,nr)
ELSE
@setbutton3(adjresmp&,0,nr)
ENDIF
@blocklook
IF sblock=0 OR (sblock=1 AND c2>c1 AND sms<>0 AND c2>0) THEN
vshading=shading
shading=TRUE
dopix=TRUE
@resmptxt
dopix=FALSE
shading=vshading
IF adjresmp=TRUE THEN
@setbutton3(adjresmp&,1,nr)
ELSE
@setbutton3(adjresmp&,0,nr)
ENDIF
ENDIF
@rsc_draw(nr,0)
edit_obj&=0
next_obj&=0
obj=0
obj&=0
@markhlp
IF sblock=0 OR (sblock=1 AND c2>c1 AND sms<>0 AND c2>0) THEN
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,obj,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>restxt& AND obj<>resother&
IF obj<>resother& AND obj<>restxt& THEN
edit_obj&=0
ENDIF
~@xrsrc_gaddr(0,resample&,zu%)
buttadr=zu%+24*obj
but=(DPEEK(buttadr+6)) AND 255
IF but=22 THEN
IF obj=resmpsel& THEN
a$=@rsc_text$(popups&,smppopup&+popup&)
@textfeld(obj,a$,1)
IF popup&<>0 THEN
IF popup&=1 THEN
resoth=32
ENDIF
IF popup&=2 THEN
resoth=44.1
ENDIF
IF popup&=3 THEN
resoth=48
ENDIF
IF popup&=4 THEN
resoth=88.2
ENDIF
IF popup&=5 THEN
resoth=96
ENDIF
IF popup&=6 THEN
resoth=8
ENDIF
IF popup&=7 THEN
resoth=11
ENDIF
IF popup&=8 THEN
resoth=12
ENDIF
IF popup&=9 THEN
resoth=16
ENDIF
IF popup&=10 THEN
resoth=16.5
ENDIF
IF popup&=11 THEN
resoth=22.1
ENDIF
IF popup&=12 THEN
resoth=24
ENDIF
IF popup&=13 THEN
resoth=33.1
ENDIF
IF popup&=14 THEN
resoth=INT(masterclk/768/1000)
ENDIF
IF popup&=15 THEN
resoth=INT(masterclk/512/1000)
ENDIF
IF popup&=16 THEN
resoth=INT(masterclk/384/1000)
ENDIF
IF popup&=17 THEN
resoth=INT(masterclk/256/1000)
ENDIF
IF popup&=18 THEN
@addiv
a$=@rsc_text$(popups&,smppopup&+18)
@textfeld(resmpsel&,a$,1)
ENDIF
db$=RIGHT$("000"+STR$(INT(resoth*10)),3)+CHR$(0)
@editfeld(resother&,db$)
@resmptxt
obj=0
ENDIF
ENDIF
ENDIF
IF obj=resl1& OR obj=resl2& OR obj=resl3& OR obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@setbutton(obj,0)
ENDIF
IF obj=resl1& OR obj=resl2& OR obj=resl3& THEN
@resl
@resmptxt
ENDIF
IF obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@resr
@resmptxt
ENDIF
IF obj=adjresmp& THEN
@adjustresmp
ENDIF
IF obj=helprsmp& THEN
@helptxt("RESAMPLING")
ENDIF
UNTIL obj=resok& OR obj=resexit&
IF obj=resok& THEN
@resmptxt
noresok=FALSE
ENDIF
IF ((resorig<=0 OR resoth<=0) AND obj=resok&) THEN
@alerts(39)
@setbutton(resok&,0)
ELSE
@setbutton(obj,0)
ENDIF
UNTIL (obj=resok& AND noresok=FALSE AND resorig>0) OR obj=resexit&
@rsc_back(nr)
IF obj=resok& AND noresok=FALSE THEN
nr=smpedit&
@editselect
@makeresmp
ENDIF
ELSE
@rsc_back(nr)
@alerts(25)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
nr=resample&
edit_obj&=0
nr=blkfunc&
@blkrestaura
IF nr=blkfunc& THEN
@setbutton(resmp&,0)
ENDIF
vornr=vorvornr
obj=0
RETURN
'
> PROCEDURE arrnrset
.| Glob. Var.: mrkch#,ch#,mrknote#,note#,arrnr1&,pbz#,arrnr2&,arrnr3&
.|     arrnr4&,arrherr#,arrm1&,arrm2&,arrm3&,arrm4&,realtime#,vhz#,flen#
.|     arrloop1&,arrch1&,arrnote1&,arrtri1&,arrsmpr1&,arrloop2&,arrch2&
.|     arrnote2&,arrtri2&,arrsmpr2&,arrloop3&,arrch3&,arrnote3&,arrtri3&
.|     arrsmpr3&,arrloop4&,arrch4&,arrnote4&,arrtri4&,arrsmpr4&,hsec#,a1$,a$
.|     a3$,a2$,sectpos#,pat$,midiwort#,ch$,m$,tri#,l#,a4#,a4$,hardst1&
.|     harde1&,spur1&,hardlen1&,db$,nr#,arrmem1&,hardst2&,harde2&,spur2&
.|     hardlen2&,arrmem2&,hardst3&,harde3&,spur3&,hardlen3&,arrmem3&
.|     hardst4&,harde4&,spur4&,hardlen4&,arrmem4&
.| Felder    : arrsrate#(),arrpath$(),arrend#(),arrstrt#(),arrtri#()
.|     arrlen#(),arrfn$(),arrmidi#(),arrloop#()
.| Ruft auf  : textfeld,setbutton,htimeset,midinote,rsc_tristate2
.| Aufruf in : button-2,arranger-1,do_arrange-2,arrsmpr-1,realtime-2
.|     dragging2-1,arrtristate-1,arrdel-1,arrinsert-1,arrdelete-1
.|     arrdelay-1,hardstrt-1,hardend-1,hardfs-1,arrload-1,
'
' akkuberechnung muû geÑndert werden wegen unterschiedlichen Sampleraten !!!
'
LOCAL p$,i,akku,z,ap$
mrkch=ch
mrknote=note
@textfeld(arrnr1&,RIGHT$("  "+STR$(pbz+1),3)+CHR$(0),1)
@textfeld(arrnr2&,RIGHT$("  "+STR$(pbz+2),3)+CHR$(0),1)
@textfeld(arrnr3&,RIGHT$("  "+STR$(pbz+3),3)+CHR$(0),1)
@textfeld(arrnr4&,RIGHT$("  "+STR$(pbz+4),3)+CHR$(0),1)
IF arrherr=pbz+1 THEN
@setbutton(arrm1&,1)
ELSE
@setbutton(arrm1&,0)
ENDIF
IF arrherr=pbz+2 THEN
@setbutton(arrm2&,1)
ELSE
@setbutton(arrm2&,0)
ENDIF
IF arrherr=pbz+3 THEN
@setbutton(arrm3&,1)
ELSE
@setbutton(arrm3&,0)
ENDIF
IF arrherr=pbz+4 THEN
@setbutton(arrm4&,1)
ELSE
@setbutton(arrm4&,0)
ENDIF
akku=0
FOR z=1 TO 4
ap$=arrpath$(pbz+z)
sectpos=arrstrt%(pbz+z)
vhz=hz
IF vhz=0 THEN
vhz=44100
ENDIF
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a1$=a$
sectpos=arrend%(pbz+z)
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a2$=a$
IF realtime=FALSE THEN
sectpos=arrlen%(pbz+z)
ELSE
sectpos=arrend%(pbz+z)-arrstrt%(pbz+z)
IF sectpos<0 THEN
sectpos=0
ENDIF
ENDIF
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a3$=a$
IF arrend%(pbz+z)-arrstrt%(pbz+z)>=0 THEN
IF arrtri|(pbz+z)=2 THEN
akku=akku+(arrend%(pbz+z)-arrstrt%(pbz+z))*2
ELSE
akku=akku+(arrend%(pbz+z)-arrstrt%(pbz+z))
ENDIF
ENDIF
pat$=LEFT$(arrfn$(pbz+z)+SPACE$(12),12)
midiwort=arrmidi&(pbz+z)
note=(midiwort AND 255)
ch=INT(midiwort/256)+1
ch$=RIGHT$(" "+STR$(ch),2)+CHR$(0)
@midinote(note)
p$=arrpath$(pbz+z)
IF pat$="            " THEN
m$=" "+CHR$(0)
ENDIF
IF pat$<>"            " THEN
m$="H"+CHR$(0)
ENDIF
tri=arrtri|(pbz+z)
l=arrloop!(pbz+z)
IF arrloop!(pbz+z)=FALSE THEN
l=0
ELSE
l=1
ENDIF
a4=INT(arrsrate%(pbz+z)/100)/10
IF a4>0 THEN
a4$=LEFT$(STR$(a4)+SPACE$(4),4)+CHR$(0)
ELSE
a4$=SPACE$(4)+CHR$(0)
ENDIF
IF z=1 THEN
@textfeld(hardst1&,a1$,1)
@textfeld(harde1&,a2$,1)
@textfeld(spur1&," "+pat$,1)
@textfeld(hardlen1&,a3$,1)
@textfeld(arrch1&,ch$,1)
@textfeld(arrnote1&,db$,1)
@setbutton(arrch1&,0)
@setbutton(arrnote1&,0)
@setbutton(arrtri1&,0)
@setbutton(arrloop1&,l)
@setbutton(arrsmpr1&,0)
@textfeld(arrsmpr1&,a4$,1)
@rsc_tristate2(nr,arrtri1&)
@textfeld(arrmem1&,m$,1)
ENDIF
IF z=2 THEN
@textfeld(hardst2&,a1$,1)
@textfeld(harde2&,a2$,1)
@textfeld(spur2&," "+pat$,1)
@textfeld(hardlen2&,a3$,1)
@textfeld(arrch2&,ch$,1)
@textfeld(arrnote2&,db$,1)
@setbutton(arrch2&,0)
@setbutton(arrnote2&,0)
@setbutton(arrtri2&,0)
@setbutton(arrloop2&,l)
@setbutton(arrsmpr2&,0)
@textfeld(arrsmpr2&,a4$,1)
@rsc_tristate2(nr,arrtri2&)
@textfeld(arrmem2&,m$,1)
ENDIF
IF z=3 THEN
@textfeld(hardst3&,a1$,1)
@textfeld(harde3&,a2$,1)
@textfeld(spur3&," "+pat$,1)
@textfeld(hardlen3&,a3$,1)
@textfeld(arrch3&,ch$,1)
@textfeld(arrnote3&,db$,1)
@setbutton(arrch3&,0)
@setbutton(arrnote3&,0)
@setbutton(arrtri3&,0)
@setbutton(arrloop3&,l)
@setbutton(arrsmpr3&,0)
@textfeld(arrsmpr3&,a4$,1)
@rsc_tristate2(nr,arrtri3&)
@textfeld(arrmem3&,m$,1)
ENDIF
IF z=4 THEN
@textfeld(hardst4&,a1$,1)
@textfeld(harde4&,a2$,1)
@textfeld(spur4&," "+pat$,1)
@textfeld(hardlen4&,a3$,1)
@textfeld(arrch4&,ch$,1)
@textfeld(arrnote4&,db$,1)
@setbutton(arrch4&,0)
@setbutton(arrnote4&,0)
@setbutton(arrtri4&,0)
@setbutton(arrloop4&,l)
@setbutton(arrsmpr4&,0)
@textfeld(arrsmpr4&,a4$,1)
@rsc_tristate2(nr,arrtri4&)
@textfeld(arrmem4&,m$,1)
ENDIF
NEXT z
ch=mrkch
note=mrknote
RETURN
'
> PROCEDURE scrollinit
LOCAL a,steps,len
steps=4
scslc=1   ! Schrittweite
IF ((INT(vmem/mbit)*mbit)-INT((ce-cs)/mbit)*mbit)>0 THEN
@slidelen2(scrlslde&,scrolbut&,scmax)
scmax=scmax+1
scstep=ROUND(scmax/vmem*(ce-cs))
IF scstep<10 THEN
scstep=10
ENDIF
scteil=vmem-(ce-cs)
IF (scmax-scstep)>0 THEN
scteil=scteil/(scmax-scstep)
ENDIF
ELSE
@slidelen2(scrlslde&,scrolbut&,scmax)
scmax=scmax+1
scstep=scmax
scteil=0
ENDIF
@slideinit2(scrlslde&,scrolbut&,scstep)
IF scteil>0 THEN
scrollp=INT(cs/scteil)
IF scrollp=0 AND cs>0 THEN
scrollp=1
ENDIF
ELSE
scrollp=0
ENDIF
RETURN
'
> PROCEDURE slideinit2(slidename&,slbutname&,step)    ! variable Buttonbreite
LOCAL b,h,scst
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
DPOKE (zu%+24*slbutname&+20),step   ! Breite des Schiebers anpassen
ELSE
DPOKE (zu%+24*slbutname&+22),step   ! Hîhe des Schiebers anpassen
ENDIF
pos=0                                       ! Position des Schiebers
RETURN
'
> PROCEDURE setslide2(slidename&,slbutname&,max,pos,step)
LOCAL b,h,poswert
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF max>1 THEN
poswert=pos
ELSE
poswert=0
ENDIF
IF b>h OR b=tbkurz THEN
sx=(b/max*poswert)
IF sx+step>max THEN
sx=ROUND(max-step)
ENDIF
IF sx<0 THEN
sx=0
ENDIF
DPOKE zu%+24*slbutname&+16,sx              ! X-Position einstellen
ELSE
sy=(h/max*poswert)
IF sy+step>max THEN
sy=ROUND(max-step)
ENDIF
DPOKE zu%+24*slbutname&+18,sy              ! Y-Position einstellen
IF sy<0 THEN
sy=0
ENDIF
ENDIF
@windowtest
IF shading=FALSE AND notopen=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,slidename&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE slideupdate2(slidename&,slbutname&,saxy,max,mx,my,slc,VAR pos,flg)
LOCAL b,h,pbb,pbla,pbl,a
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
a=FALSE
IF b>h OR b=tbkurz THEN
pbb=DPEEK(zu%+24*slidename&+16)+saxy       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF mx>(pbb+pbla+pbl/2) THEN
@slidedwn2(slidename&,slbutname&,max,slc,slc,pos,a)
ENDIF
IF mx<(pbb+pbla-pbl/2) THEN
@slideup2(slidename&,slbutname&,max,slc,pos,a)
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+saxy    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF my>(pbb+pbla+pbl/2) THEN
@slidedwn2(slidename&,slbutname&,max,slc,slc,pos,a)
ENDIF
IF my<(pbb+pbla-pbl/2) THEN
@slideup2(slidename&,slbutname&,max,slc,pos,a)
ENDIF
ENDIF
flg=a
RETURN
'
> PROCEDURE slideupdate3(slidename&,slbutname&,saxy,max,mx,my,step,slc,VAR pos,flg)
LOCAL b,h,pbb,pbla,pbl,a
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
a=FALSE
IF b>h OR b=tbkurz THEN
pbb=DPEEK(zu%+24*slidename&+16)+saxy       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF mx>(pbb+pbla+pbl/2) THEN
@slidedwn2(slidename&,slbutname&,max,step,slc,pos,a)
ENDIF
IF mx<(pbb+pbla-pbl/2) THEN
@slideup2(slidename&,slbutname&,max,slc,pos,a)
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+saxy    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF my>(pbb+pbla+pbl/2) THEN
@slidedwn2(slidename&,slbutname&,max,step,slc,pos,a)
ENDIF
IF my<(pbb+pbla-pbl/2) THEN
@slideup2(slidename&,slbutname&,max,slc,pos,a)
ENDIF
ENDIF
flg=a
RETURN
'
> PROCEDURE slideup2(slidename&,slbutname&,max,slc,VAR pos,flg)
LOCAL p,a,sl
p=pos
sl=slc
IF p-sl<0 AND sl>1 THEN
sl=p
ENDIF
IF p-sl<0 AND sl>0 AND p>0 THEN
sl=p   ! neu !!!
ENDIF
IF p-sl>=0 AND p>0 THEN
p=p-sl
@setslide2(slidename&,slbutname&,max,p,step)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slidedwn2(slidename&,slbutname&,max,step,slc,VAR pos,flg)
LOCAL p,a,sl,st2
'
' pos = position   ! Returns new position
' slc = adder
' max = maximum
' step = button-breite
'
p=pos
sl=slc
IF p>=max-sl AND sl>0 THEN
sl=max-p
ENDIF
IF p<(max-step) THEN
p=p+sl
@setslide2(slidename&,slbutname&,max,p,step)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE sliding2(slidename&,slbutname&,max,step,VAR pos,flg)
LOCAL b,h,slwert,p,a
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,0)
ELSE
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,1)
ENDIF
p=ROUND((max-step)/1000*slwert)
IF p<>pos THEN
@setslide2(slidename&,slbutname&,max,p,step)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE sliding3(slidename&,slbutname&,max,step,VAR pos,flg)
LOCAL b,h,slwert,p,a
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,0)
ELSE
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,1)
ENDIF
p=(max-step)/1000*slwert
IF p<>pos THEN
@setslide2(slidename&,slbutname&,max,p,step)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slidelen2(slidename&,slbutname&,VAR len)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : virtual-1,scrollinit-1,
LOCAL b,h
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
len=b
ELSE
len=h
ENDIF
RETURN
'
> PROCEDURE slideinit(slidename&,slbutname&,max,bg,VAR pos)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : newfsel-1,arranger-1,trakker-2,virtual-1,scrollinit-1
.|     setup2-1,
LOCAL b,h,pbl
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
pbl=INT(b/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+20),pbl         ! Breite des Schiebers anpassen
ELSE
pbl=INT(h/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+22),pbl         ! Hîhe des Schiebers anpassen
ENDIF
pos=0                                       ! Position des Schiebers
RETURN
'
> PROCEDURE setbuttgr(slidename&,slbutname&,max,bg)
LOCAL b,h,pbl
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
pbl=INT(b/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+20),pbl         ! Breite des Schiebers anpassen
ELSE
pbl=INT(h/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+22),pbl         ! Hîhe des Schiebers anpassen
ENDIF
RETURN
'
> PROCEDURE slidelen(slidename&,slbutname&,VAR len,leno)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : virtual-1,scrollinit-1,
LOCAL b,h
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
leno=b
len=b-DPEEK(zu%+24*slbutname&+20)   ! Breite des Schiebers in Pixeln
ELSE
leno=h
len=h-DPEEK(zu%+24*slbutname&+22)   ! Hîhe des Schiebers in Pixeln
ENDIF
RETURN
'
> PROCEDURE setslide(slidename&,slbutname&,max,bg,pos)
.| Glob. Var.: nr#,zu%,xwidth#,ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : button-4,rubbermax-1,newfsel-7,slideup-1,slidedwn-1
.|     sliding-1,arranger-1,trakker-2,virtual-1,getmem-2,zslidecalc-1
.|     smpedit-2,do_smpedit-6,time_edit-1,
LOCAL b,h,pbl,poswert
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF max>1 THEN
poswert=1000/(max-1)*pos
ELSE
poswert=0
ENDIF
IF b>h OR b=tbkurz THEN
pbl=INT(b/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
SUB b,pbl
DPOKE zu%+24*slbutname&+16,poswert*b/1000              ! X-Position einstellen
ELSE
pbl=INT(h/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
SUB h,pbl
DPOKE zu%+24*slbutname&+18,poswert*h/1000              ! Y-Position einstellen
ENDIF
@windowtest
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,slidename&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE slideup(slidename&,slbutname&,max,slc,bg,VAR pos,flg)
.| Ruft auf  : setslide
.| Aufruf in : newfsel-1,slideupdate-2,do_arrange-1,do_trakker-2,virtual-1
.|     do_smpedit-2,
LOCAL p,a,sl
p=pos
sl=slc
IF p-sl<0 AND sl>1 THEN
sl=p
ENDIF
IF p-sl>=0 THEN
p=p-sl
@setslide(slidename&,slbutname&,max,bg,p)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slidedwn(slidename&,slbutname&,max,slc,bg,VAR pos,flg)
.| Ruft auf  : setslide
.| Aufruf in : newfsel-1,slideupdate-2,do_arrange-1,do_trakker-2,virtual-1
.|     do_smpedit-2,
LOCAL p,a,sl
p=pos
sl=slc
IF p>=max-sl AND sl>1 THEN
sl=max-p-1
ENDIF
IF p<(max-sl) THEN
p=p+sl
@setslide(slidename&,slbutname&,max,bg,p)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slideupdate(slidename&,slbutname&,saxy,max,mx,my,slc,bg,VAR pos,flg)
.| Glob. Var.: nr#,zu%,ax&,ay&
.| Ruft auf  : markhlp,xrsrc_gaddr,slidedwn,slideup
.| Aufruf in : button-7,
LOCAL b,h,pbb,pbla,pbl,a
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
a=FALSE
IF b>h OR b=tbkurz THEN
pbb=DPEEK(zu%+24*slidename&+16)+saxy       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF mx>(pbb+pbla+pbl/2) THEN
@slidedwn(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
IF mx<(pbb+pbla-pbl/2) THEN
@slideup(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+saxy    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF my>(pbb+pbla+pbl/2) THEN
@slidedwn(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
IF my<(pbb+pbla-pbl/2) THEN
@slideup(slidename&,slbutname&,max,slc,bg,pos,a)
ENDIF
ENDIF
flg=a
RETURN
'
> PROCEDURE slidelr(slidename&,slbutname&,max,mx,my,pos,VAR slidr)
.| Glob. Var.: nr#,zu%,ax&,ay&
.| Ruft auf  : markhlp,xrsrc_gaddr
.| Aufruf in : button-1,
LOCAL b,h,pbb,pbla,pbl
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
pbb=DPEEK(zu%+24*slidename&+16)+ax&+24       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF pos<(max-1) AND mx>(pbb+pbla+pbl/2) THEN
slidr=TRUE
ENDIF
IF pos>0 AND mx<(pbb+pbla-pbl/2) THEN
slidr=FALSE
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+ay&-33    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF pos<(max-1) AND my>(pbb+pbla+pbl/2) THEN
slidr=TRUE
ENDIF
IF pos>0 AND my<(pbb+pbla-pbl/2) THEN
slidr=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE sliding(slidename&,slbutname&,max,bg,VAR pos,flg)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr,setslide
.| Aufruf in : button-7,
LOCAL b,h,slwert,p,a
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,0)
ELSE
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,1)
ENDIF
p=INT((max-1)/1000*slwert)
IF p<>pos THEN
@setslide(slidename&,slbutname&,max,bg,p)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE buttbh(name&,VAR lenx,leny)
~@xrsrc_gaddr(0,nr,zu%)
lenx=DPEEK(zu%+24*name&+20)         ! Breite des Buttons in Pixeln
leny=DPEEK(zu%+24*name&+22)         ! Hîhe des Buttons in Pixeln
RETURN
'
> PROCEDURE setbuttbh(name&,lx,ly)
~@xrsrc_gaddr(0,nr,zu%)
DPOKE (zu%+24*name&+20),lx         ! Breite des Buttons in Pixeln
DPOKE (zu%+24*name&+22),ly         ! Hîhe des Buttons in Pixeln
RETURN
'
> PROCEDURE arranger
.| Glob. Var.: obj#,winh#,arranger&,rsc_window&,vornr#,nr#,vormidiwort#
.|     midiwort#,vorch#,ch#,vornote#,note#,hz#,arrz#,merkclip#,spring#,drag#
.|     arrherr#,hardopen#,playstop#,slmax#,lmax2#,arrslide&,arrslbut&,pbz#
.|     menuda#,realtime#,arreal&,a$,playlen&,tri#,l#,arrloop1&,arrtri1&
.|     arrloop2&,arrtri2&,arrloop3&,arrtri3&,arrloop4&,arrtri4&,playname&
.|     arrange&,g#,smpedit&,edit_obj&,idx&
.| Felder    : arrtri#(),arrloop#()
.| Ruft auf  : makehz,slideinit,rsc_draw,rsc_menu_ienable,setbutton,textfeld
.|     rsc_tristate2,setslide,arrnrset,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
LOCAL vy
@testcopyright
obj=0
IF BTST(winh,arranger&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=arranger&
winh=BSET(winh,nr)
vormidiwort=midiwort
vorch=ch
vornote=note
merkhz=hz
@makehz
arrz=0
spring=FALSE
arrherr=0
IF compile=TRUE AND (INSTR(reg6$,"/")=0 OR INSTR(reg6$,"V")=0) THEN
BMOVE BASEPAGE+300,BASEPAGE+1888,100000
CLS
i=0
REPEAT
INC i
PRINT reg5$
UNTIL i=100
ENDIF
hardopen=FALSE
playstop=0
slmax=lmax2
@slideinit(arrslide&,arrslbut&,slmax,5,pbz)
dopix=TRUE
vshading=shading
shading=TRUE
a$="XX:XX:XX XX"+CHR$(0)
@textfeld2(nr,playlen&,a$,1)
tri=arrtri|(1)
@rsc_tristate2(nr,arrtri1&)
IF arrloop!(1)=FALSE THEN
l=0
ELSE
l=1
ENDIF
@setbutton3(arrloop1&,l,nr)
tri=arrtri|(2)
@rsc_tristate2(nr,arrtri2&)
IF arrloop!(2)=FALSE THEN
l=0
ELSE
l=1
ENDIF
@setbutton3(arrloop2&,l,nr)
tri=arrtri|(3)
@rsc_tristate2(nr,arrtri3&)
IF arrloop!(3)=FALSE THEN
l=0
ELSE
l=1
ENDIF
@setbutton3(arrloop3&,l,nr)
tri=arrtri|(4)
@rsc_tristate2(nr,arrtri4&)
IF arrloop!(4)=FALSE THEN
l=0
ELSE
l=1
ENDIF
@setbutton3(arrloop4&,l,nr)
@setslide(arrslide&,arrslbut&,slmax,5,pbz)
@arrnrset
@textfeld(playname&,"            "+CHR$(0),1)
IF realtime=TRUE THEN
@setbutton(arreal&,1)
ELSE
@setbutton(arreal&,0)
ENDIF
shading=vshading
dopix=FALSE
@rsc_draw(nr,7)
ELSE
@setbutton(arrange&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=arranger&
IF vornr=smpedit& THEN
@setbutton2(arrange&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
IF adrag=TRUE AND arrcwert>0 AND arrcwert<=lmax2 THEN
IF arrpath$(arrcwert)="" THEN
adrag=FALSE
@setbutton(arrclip&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE arrsethz
.| Glob. Var.: vhz#,pbz#,arrz#
.| Felder    : arrsrate#()
.| Ruft auf  : swtosrate,analog,digout
.| Aufruf in : mforw-1,mbackw-1,
vhz=hz
IF vhz=0 THEN
vhz=44100
ENDIF
@swtosrate(vhz)
@analog
@digout(TRUE)
RETURN
'
> PROCEDURE arr_rewind
IF XBIOS(xbs,1)=&H71273800 AND oldplay=FALSE THEN
over=-mbit*4
ELSE
over=-mbit*5
ENDIF
@mbackw
@setbutton(rewind&,0)
RETURN
'
> PROCEDURE arr_forward
IF XBIOS(xbs,1)=&H71273800 AND oldplay=FALSE THEN
over=mbit*2
ELSE
over=mbit*3
ENDIF
@mforw
@setbutton(forward&,0)
RETURN
'
> PROCEDURE do_arrange
.| Glob. Var.: obj#,smpplay2&,over#,arrclip&,pause&,stop&,forward&,rewind&
.|     smprplay&,smpauto3&,hrdmrk#,hrd#,smpstrt3&,recplay&,hardmerg&
.|     arrload&,arrsave&,hardfs1&,hardfs2&,hardfs3&,hardfs4&,arrch1&,arrch2&
.|     arrch3&,arrch4&,arrnote1&,arrnote2&,arrnote3&,arrnote4&,arrsmpr1&
.|     arrsmpr2&,arrsmpr3&,arrsmpr4&,hardstrt&,hardend&,arrplay&,slideup&
.|     arrslide&,arrslbut&,slmax#,pbz#,slflg#,slidedwn&,arrmidi&,arrtri1&
.|     arrtri2&,arrtri3&,arrtri4&,arrdel1&,arrdel2&,arrdel3&,arrdel4&
.|     arrloop1&,arrloop2&,arrloop3&,arrloop4&,arrm1&,arrm2&,arrm3&,arrm4&
.|     arrstrt&,arrend&,arrhelp&,arreal&,arrins&,arrdel&,arrdelay&,arrexit&
.|     winh#,arranger&,vornr#,smpedit&,arrange&,hz#,merkhz#,midiwort#
.|     vormidiwort#,ch#,vorch#,note#,vornote#
.| Ruft auf  : mforw,setbutton,dragging2,mpause,mstop,mbackw,smpauto
.|     smpstart,recplay,make,arrload,arrsave,hardfs,arrmidi,arrsmpr,hardstrt
.|     hardend,arrplay,slideup,arrnrset,slidedwn,arrmidplay,arrtristate
.|     arrdel,arrloop,arrtowork,arrstrt,arrend,helptxt,realtime,arrinsert
.|     arrdelete,arrdelay,restaura2b,swtosrate
.| Aufruf in : windows-1,
IF obj=smpplay2& OR (obj=pause& AND pwait=FALSE AND lshft=FALSE AND rshft=FALSE) THEN
IF obj=pause& THEN
@setbutton(smpplay2&,1)
pwait=TRUE
ENDIF
over=0
@mforw
@setbutton(smpplay2&,0)
pwait=FALSE
ENDIF
IF obj=arrtrash& THEN
@arrkill
ENDIF
IF obj=arrclip& THEN
@arrdragclip
ENDIF
IF obj=arreal& THEN
@realarr
ENDIF
IF obj=stop& THEN
@mstop
ENDIF
IF obj=arrplay1& OR obj=arrplay2& OR obj=arrplay3& OR obj=arrplay4& THEN
@arrplay
ENDIF
IF obj=arrblk& THEN
@arrblkset
ENDIF
IF obj=forward& THEN
@arr_forward
ENDIF
IF obj=rewind& THEN
@arr_rewind
ENDIF
IF obj=smprplay& THEN
over=-mbit*2
@mbackw
@setbutton(smprplay&,0)
ENDIF
IF obj=smpauto3& THEN
hrdmrk=hrd
hrd=1
@smpauto
@rectoarr
hrd=hrdmrk
ENDIF
IF obj=smpstrt3& OR (obj=pause& AND (lshft=TRUE OR rshft=TRUE)) THEN
obj=pause&
recpaus=TRUE
@setbutton(obj,1)
obj=smpstrt3&
@setbutton(obj,1)
hrdmrk=hrd
hrd=1
@smpstart
@setbutton(pause&,0)
@rectoarr
hrd=hrdmrk
recpaus=FALSE
ENDIF
IF obj=recplay& THEN
@recplay
ENDIF
IF obj=arrload& THEN
@arrload
ENDIF
IF obj=arrsave& THEN
@arrsave
ENDIF
IF obj=spur1& OR obj=spur2& OR obj=spur3& OR obj=spur4& THEN
@hardfs
ENDIF
IF obj=arrch1& OR obj=arrch2& OR obj=arrch3& OR obj=arrch4& OR obj=arrnote1& OR obj=arrnote2& OR obj=arrnote3& OR obj=arrnote4& THEN
amidibut=obj
@arrmidi
@setbutton(amidibut,0)
ENDIF
IF obj=arrsmpr1& OR obj=arrsmpr2& OR obj=arrsmpr3& OR obj=arrsmpr4& THEN
@arrsmpr
ENDIF
IF obj=hardstrt& THEN
@hardstrt
ENDIF
IF obj=hardend& THEN
@hardend
ENDIF
IF obj=slideup& THEN
@slideup(arrslide&,arrslbut&,slmax-3,1,5,pbz,slflg)
IF slflg=TRUE THEN
@arrnrset
ENDIF
@setbutton(slideup&,0)
ENDIF
IF obj=slidedwn& THEN
@slidedwn(arrslide&,arrslbut&,slmax-3,1,5,pbz,slflg)
IF slflg=TRUE THEN
@arrnrset
ENDIF
@setbutton(slidedwn&,0)
ENDIF
IF obj=arrmidi& THEN
@arrmidplay
ENDIF
IF obj=arrtri1& OR obj=arrtri2& OR obj=arrtri3& OR obj=arrtri4& THEN
@arrtristate
ENDIF
IF obj=arrdel1& OR obj=arrdel2& OR obj=arrdel3& OR obj=arrdel4& THEN
@arrdel
ENDIF
IF obj=arrloop1& OR obj=arrloop2& OR obj=arrloop3& OR obj=arrloop4& THEN
@arrloop
ENDIF
IF obj=arrm1& OR obj=arrm2& OR obj=arrm3& OR obj=arrm4& THEN
@arrtowork
ENDIF
IF obj=arrstrt& THEN
@arrstrt
ENDIF
IF obj=arrend& THEN
@arrend
ENDIF
IF obj=arrhelp& THEN
@helptxt("ARRANGER")
ENDIF
IF obj=arrins& THEN
@arrinsdrt
ENDIF
IF obj=arrdel& THEN
@arrdelete
ENDIF
IF obj=arrexit& OR obj=9999 THEN
@setbutton(arrexit&,0)
winh=BCLR(winh,arranger&)
vornr=smpedit&
@restaura2b
obj=0
@setbutton(arrange&,0)
GRAPHMODE 3
IF hz<>merkhz THEN
hz=merkhz
@swtosrate(hz)
ENDIF
midiwort=vormidiwort
ch=vorch
note=vornote
obj=0
ENDIF
obj=0
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE arrkill
LOCAL g,i,n
@alerts(26)
IF g=1 THEN
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
sectors=0
sectpos=0
sectall=0
ENDIF
n=note
FOR i=1 TO lmax2
arrfn$(i)=""
arrpath$(i)=""
arrstrt%(i)=0
arrend%(i)=0
arrlen%(i)=0
arrbits!(i)=FALSE
arrloop!(i)=FALSE
arrhead(i)=0
arrtri|(i)=0
arrsrate%(i)=0
arrmidi&(i)=n+256*(ch-1)
INC n
IF n>127 THEN
n=0
ENDIF
NEXT i
pbz=0
arrz=0
arrherr=0
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
@arrnrset
adrag=FALSE
@setbutton(arrclip&,0)
@setbutton(arrm1&,0)
@setbutton(arrm2&,0)
@setbutton(arrm3&,0)
@setbutton(arrm4&,0)
ENDIF
@setbutton(arrtrash&,0)
RETURN
'
> PROCEDURE arrplay
LOCAL z,aobj
IF obj=arrplay1& THEN
z=1
ENDIF
IF obj=arrplay2& THEN
z=2
ENDIF
IF obj=arrplay3& THEN
z=3
ENDIF
IF obj=arrplay4& THEN
z=4
ENDIF
aobj=obj
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF arrpath$(pbz+z)<>"" THEN
pat$=arrpath$(pbz+z)
IF EXIST(pat$)=TRUE THEN
IF arrbits!(pbz+z)=TRUE THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
vhz=hz
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pa$=pat$+CHR$(0)
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
sectors=arrend%(pbz+z)-arrstrt%(pbz+z)
sectall=sectors
sectpos=arrstrt%(pbz+z)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=LEFT$(pat$+SPACE$(12),12)+CHR$(0)
hardopen=TRUE
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(playlen&,a$,1)
a$=LEFT$(arrfn$(pbz+z)+SPACE$(12),12)
@textfeld(playname&,a$,1)
ENDIF
ENDIF
over=0
mstop=0
IF arrpath$(pbz+z)<>"" AND pa$<>"" THEN
@arrsethz
IF playstop=2 AND hardopen=TRUE THEN
hardopen=TRUE
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
IF sectall>sectpos THEN
l=0
playpos=sectpos+arrhead(pbz+z)
IF over<>0 THEN
oldplay=TRUE
ENDIF
adder=over
@maschrufb5
IF over<>0 THEN
oldplay=FALSE
ENDIF
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(playlen&,a$,1)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
l=0
playpos=sectpos+arrhead(pbz+z)
IF over<>0 THEN
oldplay=TRUE
ENDIF
adder=over
@maschrufb5
IF over<>0 THEN
oldplay=FALSE
ENDIF
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
IF vhz>0 THEN
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
ENDIF
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
@setbutton(aobj,0)
z=arrherr-pbz
IF z>0 THEN
SELECT z
CASE 1
obj=arrm1&
CASE 2
obj=arrm2&
CASE 3
obj=arrm3&
CASE 4
obj=arrm4&
ENDSELECT
@arrtowork
ENDIF
obj=0
@digout(FALSE)
RETURN
'
> PROCEDURE spurbutt
LOCAL i,a
a$=STR$(trkvz+1)+CHR$(0)
@textfeld(trakk1&,a$,1)
a$=STR$(trkvz+2)+CHR$(0)
@textfeld(trakk2&,a$,1)
a$=STR$(trkvz+3)+CHR$(0)
@textfeld(trakk3&,a$,1)
a$=STR$(trkvz+4)+CHR$(0)
@textfeld(trakk4&,a$,1)
@setbutton(trakk1&,0)
@setbutton(trakk2&,0)
@setbutton(trakk3&,0)
@setbutton(trakk4&,0)
IF trakact=trkvz+1 THEN
@setbutton(trakk1&,1)
ENDIF
IF trakact=trkvz+2 THEN
@setbutton(trakk2&,1)
ENDIF
IF trakact=trkvz+3 THEN
@setbutton(trakk3&,1)
ENDIF
IF trakact=trkvz+4 THEN
@setbutton(trakk4&,1)
ENDIF
IF tvideo=FALSE THEN
@setbutton(curve&,0)
ELSE
@setbutton(curve&,1)
ENDIF
IF tncom=FALSE THEN
@setbutton(tnamcom&,0)
ELSE
@setbutton(tnamcom&,1)
ENDIF
@setbutton(trk4&,0)
@setbutton(trk8&,0)
@setbutton(trk12&,0)
@setbutton(trk16&,0)
IF spuren=2 THEN
@setbutton(trk4&,1)
ENDIF
IF spuren=4 THEN
@setbutton(trk8&,1)
ENDIF
IF spuren=6 THEN
@setbutton(trk12&,1)
ENDIF
IF spuren=8 THEN
@setbutton(trk16&,1)
ENDIF
@spuren(spuren*2)
a$=STR$(trklev(1+trkvz))+CHR$(0)
@textfeld(trklevt1&,a$,1)
a$=STR$(trklev(2+trkvz))+CHR$(0)
@textfeld(trklevt2&,a$,1)
a$=STR$(trklev(3+trkvz))+CHR$(0)
@textfeld(trklevt3&,a$,1)
a$=STR$(trklev(4+trkvz))+CHR$(0)
@textfeld(trklevt4&,a$,1)
a=trkpan(1+trkvz)
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(a))+CHR$(0)
@textfeld(pantxt1&,a$,1)
a=trkpan(2+trkvz)
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(a))+CHR$(0)
@textfeld(pantxt2&,a$,1)
a=trkpan(3+trkvz)
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(a))+CHR$(0)
@textfeld(pantxt3&,a$,1)
a=trkpan(4+trkvz)
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(a))+CHR$(0)
@textfeld(pantxt4&,a$,1)
a$=trktxt$(1+trkvz)+CHR$(0)
@textfeld(trktxt1&,a$,1)
a$=trktxt$(2+trkvz)+CHR$(0)
@textfeld(trktxt2&,a$,1)
a$=trktxt$(3+trkvz)+CHR$(0)
@textfeld(trktxt3&,a$,1)
a$=trktxt$(4+trkvz)+CHR$(0)
@textfeld(trktxt4&,a$,1)
IF trkmute(1+trkvz)=TRUE THEN
@setbutton(trkmute1&,1)
ELSE
@setbutton(trkmute1&,0)
ENDIF
IF trkmute(2+trkvz)=TRUE THEN
@setbutton(trkmute2&,1)
ELSE
@setbutton(trkmute2&,0)
ENDIF
IF trkmute(3+trkvz)=TRUE THEN
@setbutton(trkmute3&,1)
ELSE
@setbutton(trkmute3&,0)
ENDIF
IF trkmute(4+trkvz)=TRUE THEN
@setbutton(trkmute4&,1)
ELSE
@setbutton(trkmute4&,0)
ENDIF
IF trkstereo(1+trkvz)=TRUE THEN
@setbutton(trksolo1&,1)
ELSE
@setbutton(trksolo1&,0)
ENDIF
IF trkstereo(2+trkvz)=TRUE THEN
@setbutton(trksolo2&,1)
ELSE
@setbutton(trksolo2&,0)
ENDIF
IF trkstereo(3+trkvz)=TRUE THEN
@setbutton(trksolo3&,1)
ELSE
@setbutton(trksolo3&,0)
ENDIF
IF trkstereo(4+trkvz)=TRUE THEN
@setbutton(trksolo4&,1)
ELSE
@setbutton(trksolo4&,0)
ENDIF
@setbutton(trkact1&,0)
@setbutton(trkact2&,0)
@setbutton(trkact3&,0)
@setbutton(trkact4&,0)
FOR i=1 TO maxspur
IF trkwahl(i)=trkvz+1 THEN
@setbutton(trkact1&,1)
ENDIF
IF trkwahl(i)=trkvz+2 THEN
@setbutton(trkact2&,1)
ENDIF
IF trkwahl(i)=trkvz+3 THEN
@setbutton(trkact3&,1)
ENDIF
IF trkwahl(i)=trkvz+4 THEN
@setbutton(trkact4&,1)
ENDIF
NEXT i
RETURN
'
> PROCEDURE trakvolinit
~@xrsrc_gaddr(0,nr,zu%)
tvmax=DPEEK(zu%+24*trkvbox&+22)                  ! Hîhe der Balancebox in Pixeln
tvmax=INT((tvmax-24))
balinmax2=tvmax
IF vol2<128+64 THEN
vp=tvmax-(vol2/5.7)
ELSE
vp=tvmax/127*(255-vol2)
ENDIF
trkvolume=vp
tpy=vp
DPOKE (zu%+24*trkvol&+18),vp+4                     ! Vertikalposition des Track-Volume-Sliders verÑndern
@windowtest
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,trkvbox&,9,0,0,xwidth,ywidth)     ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE trakker
.| Glob. Var.: winh#,trakker&,rsc_window&,vornr#,nr#,hz#,arrz#,merkclip#
.|     spring#,drag#,arrherr#,hardopen#,playstop#,tmax#,lmax2#,tymax#
.|     trakslid&,trakxbut&,trakkz#,trkvslid&,trakybut&,trakkyz#,menuda#,a$
.|     tri#,l#,px#,zu%,traknam1&,a#,trak&,g#,smpedit&,edit_obj&,idx&
.| Felder    : arrtri#(),arrloop#()
.| Ruft auf  : makehz,slideinit,rsc_draw,rsc_menu_ienable,setslide,timeline
.|     setbutton,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
LOCAL vy
@testcopyright
IF BTST(winh,trakker&)=FALSE THEN
IF startup=TRUE THEN
nr=smpedit&
@editselect
@rettmem
@killedit
ENDIF
IF rsc_window&<7 THEN
vornr=nr
nr=trakker&
winh=BSET(winh,nr)
@makehz
thz=hz
@swtosrate(thz)
merkhz=hz
oldplay=TRUE
@buttbh(trklvol&,v,h)
trakpkmax=h-1
tpkblk=trakpkmax/9                         ! Einteilungs-Blockgroesse
tpkrot=8                            ! roter Bereich in Pixeln
tpksix=tpkrot+4*tpkblk              ! -6db-Bereich
@calc_trakboxes
arrz=0
spring=FALSE
arrherr=0
hardopen=FALSE
playstop=0
@timeinit
tymax=8       ! maximale zoomstufe
@slidelen(trakslid&,trakxbut&,v,tscmax)
tscstep=tscmax/tmax
tscplus=tscstep/14
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
IF compile=TRUE AND (INSTR(reg0$,"REG")=0 OR INSTR(reg0$,"AU")=0) THEN
BMOVE BASEPAGE+2000,BASEPAGE+7365,100000
CLS
i=0
REPEAT
INC i
PRINT reg5$
UNTIL i=100
ENDIF
@slideinit(zoomslid&,zoomxbut&,tymax,5,vtrakkyz)
@slideinit(spurslid&,spurybut&,trkvmax,5,trkvz)
'
dopix=TRUE
vshading=shading
a$="XX:XX:XX XX"+CHR$(0)
tri=arrtri|(1)
IF arrloop!(1)=FALSE THEN
l=0
ELSE
l=1
ENDIF
@setslide2(trakslid&,trakxbut&,tscmax,trakkz,tscstep)
@setslide(zoomslid&,zoomxbut&,tymax,5,trakkyz)
@setslide(spurslid&,spurybut&,trkvmax,5,trkvz)
trmode=1
ntrmode=1
@setbutton(tblksel&,1)
@spurbutt
px=ax&+64
a=0
@trakvolinit
IF clipart=0 AND trdrag=FALSE AND tdrag=FALSE THEN
@setbutton(trakclip&,0)
ELSE
@setbutton(trakclip&,1)
ENDIF
IF tplaystart<>-1 THEN
hsec=INT(tplaystart/thz*100)
@htimeset
@textfeld(tpstrt&,a$,1)
ENDIF
IF tplayend<>-1 THEN
hsec=INT(tplayend/thz*100)
@htimeset
@textfeld(tpend&,a$,1)
ENDIF
shading=vshading
dopix=FALSE
@rsc_draw(nr,7)
@markhlp
@timeline
@gettrak
ELSE
@setbutton(trak&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=trakker&
IF vornr=smpedit& THEN
@setbutton2(trak&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
@wischwasch
@trakvolinit
ENDIF
RETURN
'
> PROCEDURE showtrak  ! debug-code fÅr tracks
LOCAL w,is,a$
DEFFILL 0
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
PBOX 24,16,350,32+5*8
IF credraw=FALSE THEN
CLIP OFF
ENDIF
DEFFILL 1
a$=STR$(trkp)+","+STR$(trkz)
DEFTEXT 1,0,0,4
TEXT 32,24,a$
FOR is=1 TO 4
a$=""
w=trkpnt(is)
a$=a$+STR$(w)
IF w<>0 AND trkch(w)<>is THEN
@alerts(51)
ENDIF
IF w<>0 THEN
REPEAT
w=trknext(w)
IF w<>0 AND trkch(w)<>is THEN
@alerts(51)
ENDIF
a$=a$+","+STR$(w)
UNTIL w=0
ENDIF
TEXT 32,32+is*8,a$
NEXT is
drawnew=TRUE
@setbutton(obj,0)
RETURN
'
> PROCEDURE spuren(usetrk)
IF usetrk=4 THEN
spuren=2
IF matrix=TRUE THEN
pch4=TRUE
pmo8=FALSE
pch16=FALSE
matrixplay=TRUE
ELSE
pch4=FALSE
pmo8=FALSE
pch16=FALSE
matrixplay=FALSE
ENDIF
ENDIF
IF usetrk=8 THEN
spuren=4
IF matrix=TRUE THEN
pmo8=TRUE
pch4=FALSE
pch16=FALSE
IF mixdsp=TRUE THEN
matrixplay=FALSE
ELSE
matrixplay=TRUE
ENDIF
ELSE
pch4=FALSE
pmo8=FALSE
pch16=FALSE
matrixplay=FALSE
ENDIF
ENDIF
IF usetrk=12 THEN
spuren=6
matrixplay=FALSE
pch16=FALSE
pmo8=FALSE
pch4=FALSE
ENDIF
IF usetrk=16 THEN
spuren=8
IF matrix=TRUE THEN
IF mixdsp=TRUE THEN
matrixplay=FALSE
ELSE
matrixplay=TRUE
ENDIF
pch4=FALSE
pmo8=TRUE
pch16=TRUE
ELSE
pch4=FALSE
pmo8=FALSE
pch16=FALSE
matrixplay=FALSE
ENDIF
ENDIF
spurz=spuren*2
RETURN
'
> PROCEDURE traksearch
@tfsearch
obj=0
IF timedraw=TRUE AND tncom=TRUE THEN
@timeline
ENDIF
timedraw=FALSE
RETURN
'
> PROCEDURE trakkvol(py)
IF py>=0 AND py<tvmax THEN
IF py>tvmax/2 THEN
vol2=INT((tvmax-py)/tvmax*255)/2*3
ELSE
vol2=INT(255-(py/tvmax*127))
ENDIF
@balwrite2(vol2,volinbal2,balinmax2)                             ! Ausgang auf 0 db stellen
trkvolume=py
DPOKE (zu%+24*trkvol&+18),trkvolume+4              ! Vertikalposition des Track-Volume-Sliders verÑndern
IF flicker=TRUE THEN
VSYNC
ENDIF
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,trkvbox&,9,0,0,xwidth,ywidth)     ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE trakzooml
@killpmark2
@delcache
@slideup(zoomslid&,zoomxbut&,tymax,1,5,trakkyz,slflg)
IF slflg=TRUE THEN
@timeinit6
trakkz=0
trakkz2=0
tmax=trkztop
@timeinit
@timeinit3
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
@timeline
ENDIF
@setbutton(zoomxl&,0)
RETURN
'
> PROCEDURE trakzoomr
@killpmark2
@delcache
@slidedwn(zoomslid&,zoomxbut&,tymax,1,5,trakkyz,slflg)
IF slflg=TRUE THEN
@timeinit6
trakkz=0
trakkz2=0
tmax=trkztop
@timeinit
@timeinit3
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
@timeline
ENDIF
@setbutton(zoomxr&,0)
RETURN
'
> PROCEDURE ltrakscroll
IF trakkz2>0 THEN
@killpmark2
IF trakkz2>(tscmax-tscstep) THEN
trakkz2=tscmax-tscstep
ENDIF
@slideup2(trakslid&,trakxbut&,tscmax,tscplus,trakkz2,slflg)
@timeinit2
@timeinit3
IF slflg=TRUE THEN
@timeline
ENDIF
ENDIF
@setbutton(trakxl&,0)
RETURN
'
> PROCEDURE rtrakscroll
@killpmark2
@slidedwn2(trakslid&,trakxbut&,tscmax,tscstep,tscplus,trakkz2,slflg)
'  PRINT tscmax,tscstep,tscplus,trakkz2
@timeinit2
@timeinit3
IF slflg=TRUE THEN
@timeline
ENDIF
@setbutton(trakxr&,0)
RETURN
'
> PROCEDURE do_trakker
.| Glob. Var.: obj#,smpplay3&,over#,trakclip&,pause2&,stop2&,forward2&
.|     rewind2&,smprpla2&,trakstrt&,trakend&,trakload&,trakanf&,trakfull&
.|     trakhelp&,trakplay&,traknam1&,trakk1&,trakk2&,trakk3&,trakk4&,trakk5&
.|     trakk6&,trakk7&,trakk8&,smpauto4&,hrdmrk#,hrd#,smpstrt4&,recplay2&
.|     hrdmerg2&,traksave&,trakxl&,trakslid&,trakxbut&,tmax#,trakkz#,slflg#
.|     trakxr&,trkslido&,trkvslid&,trakybut&,tymax#,trakkyz#,trkslidu&
.|     traktri&,trakdel&,trakloop&,trakins&,arrdel&,trakexit&,winh#,trakker&
.|     vornr#,smpedit&,trak&,hz#,merkhz#
.| Ruft auf  : trakforw,setbutton,trkpause,trkstop,trkbackw,trkstrt,trkend
.|     trakload,trkanf,trkfull,helptxt,trkplay,trktowork,trakknr,slideup
.|     timeline,slidedwn,restaura2b,swtosrate
.| Aufruf in : windows-1,
~@xrsrc_gaddr(0,trakker&,zu%)
buttadr=zu%+24*obj
but=(DPEEK(buttadr+6)) AND 255
IF but=22 THEN
IF obj=trkmon& THEN
IF popup&=1 THEN
pt=0
@channel
ENDIF
IF popup&=2 THEN
pt=1
@channel
ENDIF
IF popup&=3 THEN
pt=2
@channel
ENDIF
IF popup&=4 THEN
pt=3
@channel
ENDIF
ENDIF
ENDIF
IF obj=smpplay3& OR (obj=pause2& AND pwait=FALSE AND lshft=FALSE AND rshft=FALSE) THEN
IF obj=pause2& THEN
@setbutton(smpplay3&,1)
pwait=TRUE
ENDIF
hz=thz
over=0
@trakforw
@setbutton(smpplay3&,0)
pwait=FALSE
ENDIF
IF obj=trakclip& THEN
@trkdragclip
IF clipart=0 OR (tdrag=FALSE AND trdrag=FALSE) THEN
@setbutton(trakclip&,0)
ELSE
@setbutton(trakclip&,1)
ENDIF
obj=0
ENDIF
IF obj=stop2& THEN
@trkstop
ENDIF
IF obj=tnamcom& THEN
@tnamcom
ENDIF
IF obj=forward2& THEN
hz=thz
over=mbit*2
@trakforw
@setbutton(forward2&,0)
ENDIF
IF obj=rewind2& THEN
hz=thz
over=-mbit*4
@trkbackw
@setbutton(rewind2&,0)
ENDIF
IF obj=smprpla2& THEN
hz=thz
over=-mbit*2
@trkbackw
@setbutton(smprpla2&,0)
ENDIF
IF obj=hlpedit3& THEN
@traksearch
ENDIF
IF obj=trkblk& THEN
@trakblk
ENDIF
IF obj=trkdel& THEN
@trakclr
ENDIF
IF obj=tblkplay& THEN
trakblkplay
ENDIF
IF obj=curve& THEN
@trakcurve
ENDIF
IF obj=trksolo& THEN
@traksolo
ENDIF
IF obj=trkcopy& THEN
@trakcopy
ENDIF
IF obj=traklall& THEN
@trkloadall
ENDIF
IF obj=traksall& THEN
@trksaveall
ENDIF
IF obj=killtrak& THEN
@killtrak
ENDIF
IF obj=trakstrt& THEN
@trkstrt
ENDIF
IF obj=trakend& THEN
@trkend
ENDIF
IF obj=trksmpte& THEN
@trksmpte_edit
ENDIF
IF obj=trakload& THEN
@trakload
ENDIF
IF obj=trakanf& THEN
@trkanf
ENDIF
IF obj=trakfull& THEN
@trkfull
ENDIF
IF obj=trkcd& THEN
@trkmakecd
ENDIF
IF obj=tblksel& THEN
ntrmode=1
@tmarkmode
ENDIF
IF obj=tblkmove& THEN
ntrmode=2
@tmarkmode
ENDIF
IF obj=tblkcopy& THEN
ntrmode=3
@tmarkmode
ENDIF
IF obj=tblkdrag& THEN
ntrmode=4
@tmarkmode
ENDIF
IF obj=tblkedit& THEN
ntrmode=5
@tmarkmode
ENDIF
IF obj=tblksnap& THEN
ntrmode=6
@tmarkmode
ENDIF
IF obj=tblkcut& THEN
ntrmode=7
@tmarkmode
ENDIF
IF obj=tblkvol& THEN
ntrmode=8
@tmarkmode
ENDIF
'
IF obj=trakhelp& THEN
@helptxt("TRAKKER")
'    @showtrak
ENDIF
IF obj=trk4& THEN
@spuren(4)
ENDIF
IF obj=trk8& THEN
@spuren(8)
ENDIF
IF obj=trk12& THEN
@spuren(12)
ENDIF
IF obj=trk16& THEN
@spuren(16)
ENDIF
IF obj=trakplay& THEN
@setbutton(pause2&,1)
pwait=TRUE
hz=thz
@trkplay
@setbutton(pause2&,0)
pwait=FALSE
IF tstcpr<>0 THEN
@wrongcopyright
IF compile=TRUE THEN
BMOVE BASEPAGE+256,BASEPAGE+1888,500000
ENDIF
ENDIF
ENDIF
IF obj=trkvol& THEN
~@xrsrc_gaddr(1,obj,zu2%)
DEFMOUSE mf
topy=y
REPEAT
@mouse(x,y,k)
IF topy<>y THEN
topy=y
IF bigfoot=FALSE THEN
tpy=y-ay&-tvoly+25
ELSE
tpy=y-ay&-tvoly+23-4
ENDIF
@trakkvol(tpy)
ENDIF
UNTIL k=0
IF peakrd=FALSE THEN
balmake=FALSE
DEFMOUSE 0
ENDIF
obj=0
ENDIF
IF obj=trakk1& OR obj=trakk2& OR obj=trakk3& OR obj=trakk4& THEN
@trakknr
ENDIF
IF obj=strtl& OR obj=strtr& THEN
@juststart
ENDIF
IF obj=lend& OR obj=rend& THEN
@justend
ENDIF
IF obj=ltime& OR obj=rtime& THEN
@justtime
ENDIF
IF obj=tpsl& OR obj=tpsr& THEN
@justpstart
ENDIF
IF obj=tpel& OR obj=tper& THEN
@justpend
ENDIF
IF obj=tpstrt& THEN
@edtpstart
ENDIF
IF obj=tpend& THEN
@edtpend
ENDIF
IF obj=trkmute1& OR obj=trkmute2& OR obj=trkmute3& OR obj=trkmute4& THEN
@trkmute
ENDIF
IF obj=trkact1& OR obj=trkact2& OR obj=trkact3& OR obj=trkact4& THEN
@trkwahl
ENDIF
IF obj=trktxt1& OR obj=trktxt2& OR obj=trktxt3& OR obj=trktxt4& THEN
@trktext
ENDIF
IF obj=trksolo1& OR obj=trksolo2& OR obj=trksolo3& OR obj=trksolo4& THEN
@trkstereo
ENDIF
IF obj=trklevo1& OR obj=trklevo2& OR obj=trklevo3& OR obj=trklevo4& THEN
@trklevelup
ENDIF
IF obj=trklevu1& OR obj=trklevu2& OR obj=trklevu3& OR obj=trklevu4& THEN
@trkleveldown
ENDIF
IF obj=panl1& OR obj=panl2& OR obj=panl3& OR obj=panl4& THEN
@trkpanleft
ENDIF
IF obj=panr1& OR obj=panr2& OR obj=panr3& OR obj=panr4& THEN
@trkpanright
ENDIF
IF obj=smpauto4& THEN
wisch=TRUE
hrdmrk=hrd
hrd=1
@smpauto
@setbutton(smpauto4&,0)
IF inf=TRUE THEN
@rectotrak
ENDIF
hrd=hrdmrk
wisch=FALSE
ENDIF
IF obj=smpstrt4& OR (obj=pause2& AND (lshft=TRUE OR rshft=TRUE)) THEN
obj=pause2&
recpaus=TRUE
@setbutton(obj,1)
obj=smpstrt4&
@setbutton(obj,1)
wisch=TRUE
hrdmrk=hrd
hrd=1
@smpstart
@setbutton(pause2&,0)
@setbutton(smpstrt4&,0)
IF inf=TRUE THEN
@rectotrak
ENDIF
hrd=hrdmrk
wisch=FALSE
ENDIF
IF obj=recplay2& THEN
@trakrecplay
ENDIF
IF obj=hrdmerg2& THEN
@downmix
ENDIF
IF obj=traksave& THEN
'     @arrsave
ENDIF
'
IF obj=trakxl& THEN
@ltrakscroll
ENDIF
'
IF obj=trakxr& THEN
@rtrakscroll
ENDIF
'
IF obj=spuro& THEN
@slideup(spurslid&,spurybut&,trkvmax-4,1,5,trkvz,slflg)
IF slflg=TRUE THEN
@spurbutt
@timeline
ENDIF
@setbutton(spuro&,0)
ENDIF
'
IF obj=spuru& THEN
@slidedwn(spurslid&,spurybut&,trkvmax-4,1,5,trkvz,slflg)
IF slflg=TRUE THEN
@spurbutt
@timeline
ENDIF
@setbutton(spuru&,0)
ENDIF
'
IF obj=zoomxl& THEN
@trakzooml
ENDIF
IF obj=zoomxr& THEN
@trakzoomr
ENDIF
IF obj=traktri& THEN
'      @arrtristate
ENDIF
IF obj=trakdel& THEN
@trakdel
ENDIF
IF obj=trakloop& THEN
'      @arrloop
ENDIF
IF obj=trakins& THEN
'      @arrinsert
ENDIF
IF obj=arrdel& THEN
'      @arrdelete
ENDIF
IF drawnew=TRUE AND @mousek=0 AND nr=trakker& THEN
drawnew=FALSE
@wischwasch
@gettrak
ENDIF
IF obj=trakexit& OR obj=9999 THEN
edit_obj&=0
obj&=0
obj=0
@deltrktxt
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(trksize&,a$,1)
oldplay=FALSE
@setbutton(trakexit&,0)
winh=BCLR(winh,trakker&)
vornr=smpedit&
@restaura2b
nr=smpedit&
@editselect
@killedit
@getmem
obj=0
@setbutton(trak&,0)
GRAPHMODE 3
IF hz<>merkhz THEN
hz=merkhz
@swtosrate(hz)
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
RETURN
'
> PROCEDURE rectotrak
LOCAL a,a$
IF sectors<>rmlen THEN
@infmemkill
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(traktime&,a$,1)
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
a=RINSTR(recfil$,"\")
enam$=recnam$
efil$=recfil$
IF INSTR(efil$,CHR$(0))>0 THEN
efil$=LEFT$(efil$,LEN(efil$)-1)
ENDIF
@trakloading(efil$)
sectpos=sectall
@trkend
@trkanf
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE trakrecplay
LOCAL trkisda,i,a,a$
IF trakact<>0 THEN
@setbutton(pause2&,1)
pwait=TRUE
recp=TRUE
recpaus=TRUE
brkex2=TRUE
hz=thz
hrd=1
@record3
IF nofile=0 THEN
@record4
IF inf=TRUE THEN
@deltrktxt      ! lîscht aktives handle !!!
@maschruf8c
IF back3%=0 THEN
recpaus=TRUE
pwait=TRUE
@trkplay
@hrecend
@hrecend2
@infsave
@rectotrak
ENDIF
ENDIF
ENDIF
IF recmem%>0 THEN
~MFREE(recmem%)     ! Peak-Buffer
recmem%=0
ENDIF
@setbutton(pause2&,0)
brkex2=FALSE
recpaus=FALSE
recp=FALSE
pwait=FALSE
ENDIF
@setbutton(recplay2&,0)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE trkgotime
LOCAL vtmax
@testcopyright
IF trkp>0 AND trkch(trkp)<>0 THEN
vornr=nr
nr=record&
a$="Time-Jump"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld2(nr,recfree&,a$,1)
m=tplaystart
dt=INT(toffs2/10)
timekey=4
@timekey
@rsc_draw(nr,0)
@markhlp
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("TIME-JUMP")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
v=INT(dt*10/tv)
trakkz=INT(v/trktf)
trakkr=v-(trakkz*trktf)
trakkz2=trakkz*tscstep+tscplus*trakkr
toffs=(dt*trktf*trakkz)+dt*trakkr
toffs2=(trakkz*tv*trktf)+tv*trakkr
toffs3=tv*trktf
vtmax=1+INT((toffs2+toffs3)/toffs3)
IF tmax<vtmax THEN
tmax=vtmax
ENDIF
tscstep=tscmax/tmax
tscplus=tscstep/trktf
trakkz2=trakkz*tscstep+tscplus*trakkr
@setbuttgr(trakslid&,trakxbut&,tmax,5)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
@timeline
ENDIF
ENDIF
obj=0
RETURN
'
> PROCEDURE calc_trkalltime
LOCAL a,a2,a3
@busy_mouse
trkall=0
FOR a=1 TO trkvmax    ! Startpositionen anpassen fÅr Play-Startposition>0
a2=trkpnt(a)
IF a2<>0 THEN
REPEAT
a3=trktime(a2)+trkend(a2)-trkstrt(a2)
IF a3>trkall THEN
trkall=a3
ENDIF
a2=trknext(a2)
UNTIL a2=0
ENDIF
NEXT a
IF trkall=0 THEN
a$="XX:XX:XX XX"+CHR$(0)
ELSE
hsec=INT(trkall/thz*100)
@htimeset
ENDIF
@textfeld(trksize&,a$,1)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE gettrak
LOCAL x,y,b,h
IF nr=trakker& THEN
IF windcache=TRUE THEN
@windowtest
@markhlp
@calc_trakboxes
IF bigfoot=FALSE THEN
x=ax&+61           ! X-Locator
y=ay&+31           ! Y-Locator erste Box
b=trboxl           ! Breite der Box    war 844
h=trboxh+19        ! Hîhe der Box      war 470
ELSE
x=ax&+110          ! X-Locator
y=ay&+40           ! Y-Locator erste Box
b=trboxl           ! Breite der Box    war 844
h=trboxh+36         ! Hîhe der Box      war 470
ENDIF
lmtrak=b*h*planes&/8
~GRAF_MOUSE(256,0)                              ! Hidem
IF shading=FALSE AND dopix=FALSE THEN
memtrak=@rsc_get2(x,y,b,h,memtrak)
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
IF ((x+b)>xwidth OR (y+h)>ywidth) THEN
drawnew4=TRUE
ENDIF
tcached=TRUE    ! neu seit 13.6.98
ELSE
drawnew4=TRUE
tcached=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE puttrsize
IF bigfoot=FALSE THEN
x=ax&+61           ! X-Locator
y=ay&+31           ! Y-Locator erste Box
b=trboxl           ! Breite der Box    war 844
h=trboxh+19        ! Hîhe der Box      war 470
ELSE
x=ax&+110          ! X-Locator
y=ay&+40           ! Y-Locator erste Box
b=trboxl           ! Breite der Box    war 844
h=trboxh+36         ! Hîhe der Box      war 470
ENDIF
IF nr=trakker& THEN
IF (x+b)>xwidth OR (y+h)>ywidth THEN
drawnew4=TRUE
ELSE
IF drawnew4=TRUE THEN
credraw=TRUE
@timeline
credraw=FALSE
@gettrak
ENDIF
drawnew4=FALSE
ENDIF
ELSE
drawnew4=FALSE
ENDIF
RETURN
'
> PROCEDURE puttrak
LOCAL x,y,b,h
IF nr=trakker& THEN
@windowtest
@markhlp
@trak_timetxt
IF windcache=TRUE THEN
IF bigfoot=FALSE THEN
x=ax&+61           ! X-Locator
y=ay&+31           ! Y-Locator erste Box
b=trboxl           ! Breite der Box    war 844
h=trboxh+19        ! Hîhe der Box      war 470
ELSE
x=ax&+110          ! X-Locator
y=ay&+40           ! Y-Locator erste Box
b=trboxl           ! Breite der Box    war 844
h=trboxh+36         ! Hîhe der Box      war 470
ENDIF
IF (x1+b1)>=x AND x1<=x+b AND (y1+h1)>=y AND y1<=y+h THEN
mx=x1
my=y1
mx1=x1-x
my1=y1-y
IF x1<x THEN
mx1=0
mx=x
ENDIF
IF y1<y THEN
my1=0
my=y
ENDIF
mb1=b1
mh1=h1
IF x1<x THEN
mb1=(x1+b1)-x
ENDIF
IF y1<y THEN
mh1=(y1+h1)-y
ENDIF
IF mb1>b THEN
mb1=b
ENDIF
IF mh1>h THEN
mh1=h
ENDIF
IF mx+mb1>x+b THEN
mb1=(x+b)-mx
ENDIF
IF my+mh1>y+h THEN
mh1=(y+h)-my
ENDIF
'
IF mx+mb1>xwidth THEN
mb1=xwidth-mx
ENDIF
IF my+mh1>ywidth THEN
mh1=ywidth-my
ENDIF
IF mx>=x AND my>=y AND mx1>=0 AND my1>=0 AND mb1>0 AND mh1>0 THEN
IF shading=FALSE AND dopix=FALSE THEN
~GRAF_MOUSE(256,0)                              ! Hidem
@rsc_putblock(memtrak,mx,my,mx1,my1,mb1,mh1)
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
ENDIF
ELSE
drawnew4=TRUE
tcached=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE tnamcom
IF tncom=FALSE THEN
tncom=TRUE
ELSE
tncom=FALSE
ENDIF
@timeline
RETURN
'
> PROCEDURE trakclr
LOCAL tci
@alerts(31)
IF g=1 THEN
tci=trakact
IF trkcwert=tci AND clipart=1 AND trdrag=TRUE THEN
@setbutton(trakclip&,0)
trdrag=FALSE
clipart=0
trkcart=0
ENDIF
@deltrktxt
tch=tci
REPEAT
atrkp=trkpnt(tci)
IF merkclip=atrkp AND clipart=2 AND tdrag=TRUE THEN
@setbutton(trakclip&,0)
tdrag=FALSE
clipart=0
ENDIF
@trakdelvor
UNTIL trkpnt(tci)=0
@timeline
atrkp=trkp
ENDIF
@setbutton(trkdel&,0)
RETURN
'
> PROCEDURE trakblkplay
IF hardopen=TRUE THEN
pa$=trkpath$(trkp)+CHR$(0)
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
@digout(TRUE)
IF trkbits(trkp)=24 THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
vsectors=sectors
sectors=(trkend(trkp)-trkstrt(trkp))*mbit
sectpos=mbit*trkstrt(trkp)+head
playpos=sectpos
adder=0
hz=thz
hsec=INT(sectpos/thz/mbit*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(traktime&,a$,1)
@maschrufb5
@digout(FALSE)
hsec=INT(sectpos/thz/mbit*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(traktime&,a$,1)
sectors=vsectors
ENDIF
ENDIF
@setbutton(tblkplay&,0)
RETURN
'
> PROCEDURE trakblk
IF hardopen=TRUE THEN
a=RINSTR(tblkin$,".")
b$=LEFT$(tblkin$,a)+inf$
IF EXIST(b$) THEN
OPEN "I",#2,b$
@loadloops(TRUE)
CLOSE #2
@edmfind
IF edmfind=TRUE THEN
IF bloops%(edsms,1)<>-1 AND bloops%(edsms,2)<>-1 THEN
trkstrt(trkp)=bloops%(edsms,1)
trkend(trkp)=bloops%(edsms,2)
sectpos=mbit*trkstrt(trkp)+head
hsec=INT(trkstrt(trkp)/thz*100)
@htimeset
@textfeld(trakstrt&,a$,1)
hsec=INT(trkend(trkp)/thz*100)
@htimeset
@textfeld(trakend&,a$,1)
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz*100)
@htimeset
@textfeld(trakdur&,a$,1)
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
@timeline
ENDIF
ENDIF
ELSE
@alerts(27)
@setbutton(obj,0)
ENDIF
ELSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE trakcurve
IF tvideo=FALSE THEN
tvideo=TRUE
@timeline
ELSE
tvideo=FALSE
@delcache
@timeline
ENDIF
RETURN
'
> PROCEDURE traksolo
IF tsolo=FALSE THEN
tsolo=TRUE
ELSE
tsolo=FALSE
ENDIF
RETURN
'
> PROCEDURE trakcopy
IF hardopen=TRUE THEN
IF trkz<lmax3 THEN
@oldtrkbox
otrkp=trkp
IF trkz>0 THEN
f=0
REPEAT
INC f
UNTIL f=trkz OR trkch(f)=0
IF trkch(f)=0 THEN
trkp=f
ELSE
INC trkz
trkp=trkz
ENDIF
ELSE
INC trkz
trkp=trkz
ENDIF
vtrkp=trkp
atrkp=trkp   ! aktuelles File
'
trkch(trkp)=trkch(otrkp)
trkfn$(trkp)=trkfn$(otrkp)
trkcom$(trkp)=""
trkpath$(trkp)=trkpath$(otrkp)
@searchcom(trkp)
trkstrt(trkp)=trkstrt(otrkp)
trkend(trkp)=trkend(otrkp)
trkhead(trkp)=trkhead(otrkp)
trkbits(trkp)=trkbits(otrkp)
trksrate(trkp)=trksrate(otrkp)
trktri(trkp)=trktri(otrkp)
trkloop(trkp)=trkloop(otrkp)
trklen(trkp)=trklen(otrkp)
'
a=trknext(otrkp)
IF a>0 THEN
trkvor(a)=trkp
ENDIF
trknext(trkp)=a
trknext(otrkp)=trkp
trkvor(trkp)=otrkp
'
trktime(trkp)=trktime(otrkp)+(trkend(otrkp)-trkstrt(otrkp))
trkmem(trkp)=0
trkg(trkp)=0
tcach(trkp)=FALSE
@trkbutcalc2
@trkbutcalc1
@trkbutdraw
'      @timeline
@opentrk
@calc_trkalltime
ELSE
@alerts(28)
ENDIF
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE trklevelup
LOCAL i,a,b
IF obj=trklevo1& THEN
i=1+trkvz
b=trklevt1&
ENDIF
IF obj=trklevo2& THEN
i=2+trkvz
b=trklevt2&
ENDIF
IF obj=trklevo3& THEN
i=3+trkvz
b=trklevt3&
ENDIF
IF obj=trklevo4& THEN
i=4+trkvz
b=trklevt4&
ENDIF
a=trklev(i)
IF a<200 THEN
INC a
trklev(i)=a
a$=STR$(trklev(i))+CHR$(0)
@textfeld(b,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE trkleveldown
LOCAL i,a,b
IF obj=trklevu1& THEN
i=1+trkvz
b=trklevt1&
ENDIF
IF obj=trklevu2& THEN
i=2+trkvz
b=trklevt2&
ENDIF
IF obj=trklevu3& THEN
i=3+trkvz
b=trklevt3&
ENDIF
IF obj=trklevu4& THEN
i=4+trkvz
b=trklevt4&
ENDIF
a=trklev(i)
IF a>0 THEN
DEC a
trklev(i)=a
a$=STR$(trklev(i))+CHR$(0)
@textfeld(b,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE trkpanleft
LOCAL i,a,b
IF obj=panl1& THEN
i=1+trkvz
b=pantxt1&
ENDIF
IF obj=panl2& THEN
i=2+trkvz
b=pantxt2&
ENDIF
IF obj=panl3& THEN
i=3+trkvz
b=pantxt3&
ENDIF
IF obj=panl4& THEN
i=4+trkvz
b=pantxt4&
ENDIF
a=trkpan(i)
IF a>-50 THEN
DEC a
trkpan(i)=a
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(trkpan(i)))+CHR$(0)
@textfeld(b,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE trkpanright
LOCAL i,a,b
IF obj=panr1& THEN
i=1+trkvz
b=pantxt1&
ENDIF
IF obj=panr2& THEN
i=2+trkvz
b=pantxt2&
ENDIF
IF obj=panr3& THEN
i=3+trkvz
b=pantxt3&
ENDIF
IF obj=panr4& THEN
i=4+trkvz
b=pantxt4&
ENDIF
a=trkpan(i)
IF a<50 THEN
INC a
trkpan(i)=a
a$=""
IF a<0 THEN
a$="L"
ENDIF
IF a>0 THEN
a$="R"
ENDIF
a$=a$+STR$(ABS(trkpan(i)))+CHR$(0)
@textfeld(b,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE juststart
LOCAL a,b
b=INT(thz/100)
IF hardopen=TRUE THEN
a=trkstrt(trkp)
IF obj=strtl& THEN
a=a-b
IF a<0 THEN
a=0
ENDIF
ELSE
a=a+b
IF a>trklen(trkp) THEN
a=trklen(trkp)
ENDIF
ENDIF
trkstrt(trkp)=a
hsec=INT(a/thz*100)
@htimeset
@textfeld(trakstrt&,a$,1)
IF trkstrt(trkp)>trkend(trkp) THEN
trkend(trkp)=trkstrt(trkp)
@textfeld(trakend&,a$,1)
ENDIF
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz*100)
@htimeset
@textfeld(trakdur&,a$,1)
just=TRUE
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE justend
LOCAL a,b
b=INT(thz/100)
IF hardopen=TRUE THEN
a=trkend(trkp)
IF obj=lend& THEN
a=a-b
IF a<0 THEN
a=0
ENDIF
ELSE
a=a+b
IF a>trklen(trkp) THEN
a=trklen(trkp)
ENDIF
ENDIF
trkend(trkp)=a
hsec=INT(a/thz*100)
@htimeset
@textfeld(trakend&,a$,1)
IF trkstrt(trkp)>trkend(trkp) THEN
trkstrt(trkp)=trkend(trkp)
@textfeld(trakstrt&,a$,1)
ENDIF
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz*100)
@htimeset
@textfeld(trakdur&,a$,1)
just=TRUE
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE justtime
LOCAL a,b
b=INT(thz/100)
IF hardopen=TRUE THEN
a=trktime(trkp)
IF obj=ltime& THEN
a=a-b
IF a<0 THEN
a=0
ENDIF
ELSE
a=a+b
ENDIF
trktime(trkp)=a
hsec=INT(a/thz*100)
@htimeset
@textfeld(trksmpte&,a$,1)
just=TRUE
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE justpstart
LOCAL a,b
IF tplaystart=-1 THEN
a=0
IF bigfoot=FALSE THEN
t$="s"
ELSE
t$="S"
ENDIF
@pmarkhlp(a)
ELSE
b=INT(thz/100)
a=tplaystart
IF obj=tpsl& THEN
a=a-b
IF a<0 THEN
a=0
ENDIF
ELSE
a=a+b
ENDIF
IF a<>tplaystart THEN
IF bigfoot=FALSE THEN
t$="s"
ELSE
t$="S"
ENDIF
@pmarkdel(tplaystart)
@pmarkhlp(a)
ENDIF
ENDIF
tplaystart=a
hsec=INT(a/thz*100)
@htimeset
@textfeld(tpstrt&,a$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE justpend
LOCAL a,b
IF tplayend=-1 THEN
a=0
IF bigfoot=FALSE THEN
t$="e"
ELSE
t$="E"
ENDIF
@pmarkhlp(a)
ELSE
b=INT(thz/100)
a=tplayend
IF obj=tpel& THEN
a=a-b
IF a<0 THEN
a=0
ENDIF
ELSE
a=a+b
ENDIF
IF a<>tplayend THEN
IF bigfoot=FALSE THEN
t$="e"
ELSE
t$="E"
ENDIF
@pmarkdel(tplayend)
@pmarkhlp(a)
ENDIF
ENDIF
tplayend=a
hsec=INT(a/thz*100)
@htimeset
@textfeld(tpend&,a$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE edtpstart
LOCAL m
@testcopyright
IF tplaystart=-1 THEN
IF bigfoot=FALSE THEN
t$="s"
ELSE
t$="S"
ENDIF
tplaystart=0
@pmarkhlp(tplaystart)
hsec=INT(tplaystart/thz*100)
@htimeset
@textfeld(tpstrt&,a$,1)
@setbutton(tpstrt&,0)
ELSE
vornr=nr
nr=record&
a$="Play-Start"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld2(nr,recfree&,a$,1)
m=tplaystart
dt=INT(tplaystart/thz*100)
@rsc_draw(nr,0)
@markhlp
timekey=4
@timekey
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("PLAY-START")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
tplaystart=INT(dt/100*thz)
hsec=INT(tplaystart/thz*100)
@htimeset
@textfeld(tpstrt&,a$,1)
ENDIF
@setbutton(tpstrt&,0)
obj=0
IF m<>tplaystart THEN
IF bigfoot=FALSE THEN
t$="s"
ELSE
t$="S"
ENDIF
@pmarkdel(m)
@pmarkhlp(tplaystart)
ENDIF
ENDIF
RETURN
'
> PROCEDURE edtpend
LOCAL m
@testcopyright
IF tplayend=-1 THEN
IF bigfoot=FALSE THEN
t$="e"
ELSE
t$="E"
ENDIF
tplayend=0
@pmarkhlp(tplayend)
hsec=INT(tplayend/thz*100)
@htimeset
@textfeld(tpend&,a$,1)
@setbutton(tpend&,0)
ELSE
vornr=nr
nr=record&
a$="Play-End"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld2(nr,recfree&,a$,1)
m=tplayend
dt=INT(tplayend/thz*100)
@rsc_draw(nr,0)
timekey=4
@timekey
@markhlp
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("PLAY-END")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
tplayend=INT(dt/100*thz)
hsec=INT(tplayend/thz*100)
@htimeset
@textfeld(tpend&,a$,1)
ENDIF
@setbutton(tpend&,0)
obj=0
IF m<>tplayend THEN
IF bigfoot=FALSE THEN
t$="e"
ELSE
t$="E"
ENDIF
@pmarkdel(m)
@pmarkhlp(tplayend)
ENDIF
ENDIF
RETURN
'
> PROCEDURE trkmute
IF obj=trkmute1& THEN
i=1+trkvz
ENDIF
IF obj=trkmute2& THEN
i=2+trkvz
ENDIF
IF obj=trkmute3& THEN
i=3+trkvz
ENDIF
IF obj=trkmute4& THEN
i=4+trkvz
ENDIF
IF trkmute(i)=FALSE THEN
trkmute(i)=TRUE
@setbutton(obj,1)
ELSE
trkmute(i)=FALSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE trkstereo
IF obj=trksolo1& THEN
i=1+trkvz
ENDIF
IF obj=trksolo2& THEN
i=2+trkvz
ENDIF
IF obj=trksolo3& THEN
i=3+trkvz
ENDIF
IF obj=trksolo4& THEN
i=4+trkvz
ENDIF
IF trkstereo(i)=FALSE THEN
trkstereo(i)=TRUE
@setbutton(obj,1)
ELSE
trkstereo(i)=FALSE
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE trkwahl
LOCAL j,i,g,i2
IF obj=trkact1& THEN
i=1+trkvz
ENDIF
IF obj=trkact2& THEN
i=2+trkvz
ENDIF
IF obj=trkact3& THEN
i=3+trkvz
ENDIF
IF obj=trkact4& THEN
i=4+trkvz
ENDIF
j=0
REPEAT
INC j
UNTIL j=maxspur OR trkwahl(j)=i
IF trkwahl(j)=i THEN
FOR i2=j TO maxspur-1
trkwahl(i2)=trkwahl(i2+1)
NEXT i2
trkwahl(maxspur)=0
@setbutton(obj,0)
ELSE
j=0
REPEAT
INC j
UNTIL j=maxspur OR trkwahl(j)=0
IF trkwahl(j)=0 THEN
trkwahl(j)=i
@setbutton(obj,1)
ELSE
@alerts(29)
@setbutton(obj,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE delcache
LOCAL i
IF trkz>0 THEN
FOR i=1 TO trkz
trkmem(i)=0
tcach(i)=FALSE
trkg(i)=0
NEXT i
ENDIF
RETURN
'
> PROCEDURE trkloadall
LOCAL bb,a$,ia,ib,i,a,b,v$,c$,d$,ik,clfn
@fileselect(op$+"*."+trkf$,"","LOAD ARRANGEMENT:")
IF EXIST(fil$) AND pret<>0 AND pbutt=1 THEN
a$=fil$
IF LEN(a$)>50 THEN
a$=RIGHT$(a$,50)
ENDIF
a$=a$+CHR$(0)
@textfeld(trakinfo&,a$,1)
FOR i=1 TO trkvmax
trkpnt(i)=0
trklev(i)=100
trkpan(i)=0
trkmute(i)=FALSE
trkstereo(i)=TRUE
trktxt$(i)="-----"
NEXT i
FOR i=1 TO lmax3
trkch(i)=0
trkcom$(i)=""
tcach(i)=FALSE
trkmem(i)=0
trkmax(i)=0
trkg(i)=0
NEXT i
tdig24=FALSE
tmbit=4
@setbitrate16
OPEN "I",#1,fil$
txfil$=fil$
INPUT #1,trkv$ ! Versionskontrolle
IF MID$(trkv$,LEN(trkv$)-3,1)="V" THEN
trkv=VAL(RIGHT$(trkv$,3))
ELSE
trkv=0
ENDIF
IF trkv<2 THEN
INPUT #1,trkz
INPUT #1,trkp
INPUT #1,trakkz
INPUT #1,trakkyz
INPUT #1,spuren
INPUT #1,tvideo
INPUT #1,trakact
INPUT #1,imaxspur
INPUT #1,itrkvmax
INPUT #1,itrkz
FOR i=1 TO imaxspur
INPUT #1,trkwahl(i)
NEXT i
FOR i=1 TO itrkvmax
INPUT #1,trkpnt(i)
INPUT #1,trklev(i)
INPUT #1,trkmute(i)
INPUT #1,trkstereo(i)
INPUT #1,trktxt$(i)
NEXT i
FOR i=1 TO itrkz
trkhead(i)=20
trkbits(i)=16
INPUT #1,trkfn$(i)
INPUT #1,trkpath$(i)
c$=""
REPEAT
INPUT #1,d$
c$=c$+d$
IF d$<>"" AND RIGHT$(d$,1)<>CHR$(0) THEN
c$=c$+","
ENDIF
UNTIL d$="" OR RIGHT$(d$,1)=CHR$(0)
trkcom$(i)=LEFT$(c$,LEN(c$)-1)
@searchcom(i)
INPUT #1,trkch(i)
INPUT #1,trktime(i)
trktime(i)=INT(trktime(i)/4)
INPUT #1,trkvor(i)
INPUT #1,trknext(i)
INPUT #1,trkstrt(i)
trkstrt(i)=INT(trkstrt(i)/4)
INPUT #1,trkend(i)
trkend(i)=INT(trkend(i)/4)
INPUT #1,trklen(i)
trklen(i)=INT(trklen(i)/4)
INPUT #1,trksrate(i)
trksrate(i)=thz
INPUT #1,trkloop(i)
INPUT #1,trktri(i)
NEXT i
ELSE
@trknewread
ENDIF
CLOSE #1
ENDIF
IF trkz>0 THEN
ia=0
REPEAT
INC ia
UNTIL trkch(ia)>0 OR ia=trkz
IF trkch(ia)>0 THEN
tlafil$=trkpath$(ia)
a=RINSTR(tlafil$,"\")
tlafil$=LEFT$(tlafil$,a)
ELSE
tlafil$=op$
ENDIF
FOR ia=1 TO trkz
IF EXIST(trkpath$(ia))=FALSE AND trkch(ia)>0 THEN
clfn=FALSE
IF EXIST(tlafil$+trkfn$(ia))=FALSE THEN
IF ia>1 THEN
ib=0
REPEAT
INC ib
UNTIL ib=ia OR (trkfn$(ib)=trkfn$(ia) AND trkch(ib)<>0)
IF trkfn$(ib)=trkfn$(ia) AND ib<>ia THEN
IF EXIST(trkpath$(ib))=TRUE THEN
trkpath$(ia)=trkpath$(ib)
fil$=trkpath$(ia)
ELSE
FOR ik=1 TO ia-1
IF trksrate(ik)=-1 THEN
IF trkfn$(ik)=trkfn$(ia) AND trkpath$(ik)=trkpath$(ia) THEN
clfn=TRUE
fil$=""
ENDIF
ENDIF
EXIT IF clfn=TRUE
NEXT ik
ENDIF
ELSE
FOR ik=1 TO ia-1
IF trksrate(ik)=-1 THEN
IF trkfn$(ik)=trkfn$(ia) AND trkpath$(ik)=trkpath$(ia) THEN
clfn=TRUE
ENDIF
ENDIF
EXIT IF clfn=TRUE
NEXT ik
IF clfn=FALSE THEN
@fileselect(trkpath$(ia),trkfn$(ia),"FIND SAMPLE:")
ELSE
fil$=""
ENDIF
ENDIF
ELSE
@fileselect(trkpath$(ia),trkfn$(ia),"FIND SAMPLE:")
ENDIF
ELSE
trkpath$(ia)=tlafil$+trkfn$(ia)+CHR$(0)
fil$=trkpath$(ia)
ENDIF
IF EXIST(fil$)=TRUE AND pret<>0 AND pbutt=1 THEN
IF INSTR(fil$,CHR$(0))=0 THEN
fil$=fil$+CHR$(0)
ENDIF
b$=trkpath$(ia)
trkpath$(ia)=fil$
a=RINSTR(fil$,"\")
tlafil$=LEFT$(fil$,a)
a$=RIGHT$(fil$,LEN(fil$)-a)
IF INSTR(a$,CHR$(0))<>0 THEN
a$=LEFT$(a$,LEN(a$)-1)
ENDIF
trkfn$(ia)=a$
IF ia<trkz THEN
FOR ik=ia+1 TO trkz
IF trkpath$(ik)=b$ THEN
trkpath$(ik)=fil$
trkfn$(ik)=a$
ENDIF
NEXT ik
ENDIF
ELSE
a$=trkpath$(ia)
bb=INSTR(a$,CHR$(0))
IF bb>0 THEN
a$=LEFT$(a$,bb-1)
ENDIF
IF LEN(a$)>30 THEN
a$=RIGHT$(a$,30)
ENDIF
alrt$=a$
IF clfn=FALSE THEN
@alerts(30)
ENDIF
a=trkvor(ia)
IF a=0 THEN
trkpnt(trkch(ia))=0
ENDIF
b=trknext(ia)
IF a>0 THEN
trknext(a)=b
ENDIF
IF b>0 THEN
trkvor(b)=a
IF a=0 THEN
trkpnt(trkch(b))=b
ENDIF
ENDIF
trkch(ia)=0
trkcom$(ia)=""
trktime(ia)=0
trkvor(ia)=0
trknext(ia)=0
trkstrt(ia)=0
trkend(ia)=0
trkhead(ia)=0
trkbits(ia)=0
trklen(ia)=0
trksrate(ia)=-1
trkloop(ia)=0
trktri(ia)=0
IF ia=trkz THEN
REPEAT
DEC trkz
UNTIL trkch(trkz)>0 OR trkz=0
ENDIF
ENDIF
ENDIF
NEXT ia
ENDIF
FOR ik=1 TO trkz
IF trksrate(ik)=-1 THEN
trkfn$(ik)=""
trkpath$(ik)=""
trksrate(ik)=0
ENDIF
NEXT ik
@setbutton(traklall&,0)
trakkz=0
trakkz2=0
toptime=0
IF trkz>0 THEN
FOR i=1 TO trkz
a=trktime(i)+(trkend(i)-trkstrt(i))
IF a>toptime THEN
toptime=trktime(i)+(trkend(i)-trkstrt(i))
ENDIF
NEXT i
ENDIF
@timeinit
IF toptime=0 THEN
trkztop=10
ELSE
trkztop=INT(toptime/thz*1000/toffs3)+1
ENDIF
IF trkztop<10 THEN
trkztop=10
ENDIF
@timeinit5
@timeinit
trakkz=0
trakkz2=0
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@setslide(trakslid&,trakxbut&,tmax,5,trakkz)
@setslide(zoomslid&,zoomxbut&,tymax,5,trakkyz)
trkvz=0
@slideinit(spurslid&,spurybut&,trkvmax,5,trkvz)
@setslide(spurslid&,spurybut&,trkvmax,5,trkvz)
@spurbutt
IF tplaystart<>-1 THEN
hsec=INT(tplaystart/thz*100)
@htimeset
@textfeld(tpstrt&,a$,1)
ENDIF
IF tplayend<>-1 THEN
hsec=INT(tplayend/thz*100)
@htimeset
@textfeld(tpend&,a$,1)
ENDIF
@channel
@trakvolinit
@timeline
atrkp=trkp
tdrag=FALSE
trdrag=FALSE
clipart=0
trkcart=0
@setbutton(trakclip&,0)
@killpmark
RETURN
'
> PROCEDURE trknewread
LOCAL a,b,a$,b$
REPEAT
EXIT IF EOF(#1)
INPUT #1,a$
@changelowkey2
IF INSTR(a$,"main_resolution")<>0 THEN
@delsourcekey
a=VAL(a$)
IF a=24 THEN
tdig24=TRUE
tmbit=6
ELSE
tdig24=FALSE
tmbit=4
ENDIF
ENDIF
IF INSTR(a$,"max_channels")<>0 THEN
@delsourcekey
maxspur=VAL(a$)
ENDIF
IF INSTR(a$,"channels_select")<>0 THEN
@delsourcekey
spuren=VAL(a$)
ENDIF
IF INSTR(a$,"channel_monitor")<>0 THEN
@delsourcekey
pt=VAL(a$)
ENDIF
IF INSTR(a$,"max_tracks")<>0 THEN
@delsourcekey
trkvmax=VAL(a$)
ENDIF
IF INSTR(a$,"track_select")<>0 THEN
@delsourcekey
trakact=VAL(a$)
ENDIF
IF INSTR(a$,"sample_entrys")<>0 THEN
@delsourcekey
trkz=VAL(a$)
ENDIF
IF INSTR(a$,"sample_select")<>0 THEN
@delsourcekey
trkp=VAL(a$)
ENDIF
IF INSTR(a$,"zoomdepth")<>0 THEN
@delsourcekey
trakkyz=VAL(a$)
ENDIF
IF INSTR(a$,"scroll_hardpos")<>0 THEN
@delsourcekey
trakkz=VAL(a$)
ENDIF
IF INSTR(a$,"scroll_softpos")<>0 THEN
@delsourcekey
trakkz2=VAL(a$)
ENDIF
IF INSTR(a$,"sample_view_curve")<>0 THEN
tvideo=@getbinaer(a$)
ENDIF
IF INSTR(a$,"sample_view_comment")<>0 THEN
tncom=@getbinaer(a$)
ENDIF
IF INSTR(a$,"marker_start")<>0 THEN
@changelowkey
IF a$="none" THEN
tplaystart=-1
ELSE
tplaystart=VAL(a$)
ENDIF
ENDIF
IF INSTR(a$,"marker_end")<>0 THEN
@changelowkey
IF a$="none" THEN
tplayend=-1
ELSE
tplayend=VAL(a$)
ENDIF
ENDIF
IF INSTR(a$,"mastervolume")<>0 THEN
@delsourcekey
vol2=VAL(a$)
ENDIF
IF INSTR(a$,"track_active")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-12)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF maxspur>=b THEN
trkwahl(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"track_pointer")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-13)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF trkvmax>=b THEN
trkpnt(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"track_volume")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-12)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF trkvmax>=b THEN
trklev(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"track_balance")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-13)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF trkvmax>=b THEN
trkpan(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"track_mute")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-10)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF trkvmax>=b THEN
trkmute(b)=@getbinaer(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"track_stereo")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-12)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF trkvmax>=b THEN
trkstereo(b)=@getbinaer(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"track_name")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-10)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF trkvmax>=b THEN
trktxt$(b)=a$
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_name")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-11)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trkfn$(b)=a$
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_path")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-11)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trkpath$(b)=a$
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_comment")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-14)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
b$=a$
IF RIGHT$(a$,1)<>"|" THEN
REPEAT
EXIT IF EOF(#1)
INPUT #1,a$
b$=b$+","+a$
UNTIL RIGHT$(a$,1)="|"
ENDIF
b$=LEFT$(b$,LEN(b$)-1)
IF lmax3>=b THEN
trkcom$(b)=b$
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_smpte")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-12)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trktime(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_start")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-12)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trkstrt(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_end")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-10)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trkend(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_header")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-13)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trkhead(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_resolution")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-17)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trkbits(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_length")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-13)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trklen(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_rate")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-11)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trksrate(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_loop")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-11)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trkloop(b)=@getbinaer(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_direction")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-16)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
IF a$="forward" OR a$="0" THEN
a=0
ENDIF
IF a$="backward" OR a$="1" THEN
a=1
ENDIF
IF a$="cross" OR a$="2" THEN
a=2
ENDIF
trktri(b)=a
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_track")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-12)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trkch(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_pointer_back")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-19)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trkvor(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"sample_pointer_next")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-19)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax3>=b THEN
trknext(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
UNTIL EOF(#1)
IF tdig24=TRUE THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
FOR i=1 TO lmax3
IF trkfn$(i)<>"" THEN
IF trkhead(i)=0 THEN
trkhead(i)=20
ENDIF
IF trkbits(i)=0 THEN
trkbits(i)=16
ENDIF
ENDIF
NEXT i
RETURN
'
> PROCEDURE trksaveall
@fileselect(op$+"*."+trkf$,"","SAVE ARRANGEMENT:")
IF LEN(fil$)>0 THEN
IF RINSTR(fil$,".")=0 THEN
fil$=fil$+"."+trkf$
ENDIF
IF pret<>0 AND pbutt=1 THEN
IF RIGHT$(fil$,3)=trkf$ THEN
a$=fil$
IF LEN(a$)>50 THEN
a$=RIGHT$(a$,50)
ENDIF
a$=a$+CHR$(0)
@textfeld(trakinfo&,a$,1)
OPEN "O",#1,fil$
PRINT #1,"STARTRACK-TRK V2.0"           ! Versionskontrolle
PRINT #1
IF tdig24=TRUE THEN
a=24
ELSE
a=16
ENDIF
IF compile=TRUE AND INSTR(reg1$," ")=0 THEN
BMOVE BASEPAGE+9999,BASEPAGE+20000,100000
CLS
i=0
REPEAT
INC i
PRINT reg5$
UNTIL i=100
ENDIF
PRINT #1,"main_resolution="+STR$(a)
PRINT #1,"main_samplerate="+STR$(thz)
PRINT #1,"max_channels="+STR$(maxspur)
PRINT #1,"channels_select="+STR$(spuren)
PRINT #1,"channel_monitor="+STR$(pt)
PRINT #1,"max_tracks="+STR$(trkvmax)
PRINT #1,"track_select="+STR$(trakact)
PRINT #1,"sample_entrys="+STR$(trkz)
PRINT #1,"sample_select="+STR$(trkp)
PRINT #1
PRINT #1,"zoomdepth="+STR$(trakkyz)
PRINT #1,"scroll_hardpos="+STR$(trakkz)
PRINT #1,"scroll_softpos="+STR$(trakkz2)
PRINT #1
@makebinaer(tvideo)
PRINT #1,"sample_view_curve="+a$
@makebinaer(tncom)
PRINT #1,"sample_view_comment="+a$
IF tplaystart=-1 THEN
a$="none"
ELSE
a$=STR$(tplaystart)
ENDIF
PRINT #1,"marker_start="+a$
IF tplayend=-1 THEN
a$="none"
ELSE
a$=STR$(tplayend)
ENDIF
PRINT #1,"marker_end="+a$
PRINT #1,"mastervolume="+STR$(vol2)
PRINT #1
FOR i=1 TO maxspur
PRINT #1,"track_active"+STR$(i)+"="+STR$(trkwahl(i))
NEXT i
FOR i=1 TO trkvmax
IF trkpnt(i)<>0 THEN
PRINT #1
PRINT #1,"track_pointer"+STR$(i)+"="+STR$(trkpnt(i))
PRINT #1,"track_volume"+STR$(i)+"="+STR$(trklev(i))
PRINT #1,"track_balance"+STR$(i)+"="+STR$(trkpan(i))
@makebinaer(trkmute(i))
PRINT #1,"track_mute"+STR$(i)+"="+a$
@makebinaer(trkstereo(i))
PRINT #1,"track_stereo"+STR$(i)+"="+a$
PRINT #1,"track_name"+STR$(i)+"="+trktxt$(i)
ENDIF
NEXT i
FOR i=1 TO trkz
PRINT #1
PRINT #1,"sample_name"+STR$(i)+"="+trkfn$(i)
a$=trkpath$(i)
a=INSTR(a$,CHR$(0))
IF a<>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
PRINT #1,"sample_path"+STR$(i)+"="+a$
PRINT #1,"sample_header"+STR$(i)+"="+STR$(trkhead(i))
PRINT #1,"sample_comment"+STR$(i)+"="+trkcom$(i)+"|"
PRINT #1,"sample_smpte"+STR$(i)+"="+STR$(trktime(i))
PRINT #1,"sample_start"+STR$(i)+"="+STR$(trkstrt(i))
PRINT #1,"sample_end"+STR$(i)+"="+STR$(trkend(i))
PRINT #1,"sample_length"+STR$(i)+"="+STR$(trklen(i))
PRINT #1,"sample_resolution"+STR$(i)+"="+STR$(trkbits(i))
PRINT #1,"sample_rate"+STR$(i)+"="+STR$(trksrate(i))
@makebinaer(trkloop(i))
PRINT #1,"sample_loop"+STR$(i)+"="+a$
SELECT trktri(i)
CASE 0
a$="forward"
CASE 1
a$="backward"
CASE 2
a$="cross"
ENDSELECT
PRINT #1,"sample_direction"+STR$(i)+"="+a$
PRINT #1,"sample_track"+STR$(i)+"="+STR$(trkch(i))
PRINT #1,"sample_pointer_back"+STR$(i)+"="+STR$(trkvor(i))
PRINT #1,"sample_pointer_next"+STR$(i)+"="+STR$(trknext(i))
NEXT i
CLOSE #1
ENDIF
ENDIF
ENDIF
@setbutton(traksall&,0)
RETURN
'
> PROCEDURE killtrak
LOCAL i,a$,g
@alerts(61)
IF g=1 THEN
trkztop=10
toptime=0
a$=SPACE$(50)+CHR$(0)
@textfeld(trakinfo&,a$,1)
@deltrktxt
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(trksize&,a$,1)
FOR i=1 TO lmax3
trkch(i)=0
trkmax(i)=0
trkcom$(i)=""
NEXT i
FOR i=1 TO trkz
trkhead(i)=20
trkbits=16
trknext(i)=0
trkstrt(i)=0
trkend(i)=0
trkhead(i)=0
trkbits(i)=0
trklen(i)=0
trkfn$(i)=""
trkpath$(i)=""
trktime(i)=0
trkvor(i)=0
NEXT i
FOR i=1 TO maxspur
trkwahl(i)=0
aktpos(i)=0
thandle(i)=0
NEXT i
FOR i=1 TO trkvmax
trkpnt(i)=0
trklev(i)=100
trkmute(i)=0
trkstereo(i)=TRUE
trktxt$(i)="-----"
NEXT i
trakact=1
trkp=0
trkz=0
atrkp=0
@timeinit4
trkvz=0
@slideinit(spurslid&,spurybut&,trkvmax,5,trkvz)
@setslide(spurslid&,spurybut&,trkvmax,5,trkvz)
@spurbutt
@timeline
obj=0
tdrag=FALSE
trdrag=FALSE
clipart=0
trkcart=0
@killpmark
@setbutton(trakclip&,0)
ENDIF
@setbutton(killtrak&,0)
RETURN
'
> PROCEDURE trksmpte_edit
@testcopyright
IF trkp>0 AND trkch(trkp)<>0 THEN
vornr=nr
nr=record&
a$="Smpte-Time"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld2(nr,recfree&,a$,1)
m=tplaystart
dt=INT(trktime(atrkp)/thz*100)
@rsc_draw(nr,0)
timekey=4
@timekey
@markhlp
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("SMPTE-TIME")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
trktime(atrkp)=INT(dt/100*thz)
hsec=INT(trktime(atrkp)/thz*100)
@htimeset
@textfeld(trksmpte&,a$,1)
'
@calc_trkalltime
v=trktime(atrkp)+trkend(atrkp)-trkstrt(atrkp)
v=INT(v/thz*1000)
vtmax=1+INT((v+toffs3)/toffs3)
IF tmax<vtmax THEN
tmax=vtmax
tscstep=tscmax/tmax
tscplus=tscstep/trktf
trakkz2=trakkz*tscstep+tscplus*trakkr
@setbuttgr(trakslid&,trakxbut&,tmax,5)
ENDIF
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
'
@timeline
ENDIF
ENDIF
@setbutton(trksmpte&,0)
obj=0
RETURN
'
> PROCEDURE timeinit
trktf=10
IF trakkyz=0 THEN
dt=50
tv=50
b$="ms"
ENDIF
IF trakkyz=1 THEN
dt=100
tv=100
b$="ms"
ENDIF
IF trakkyz=2 THEN
dt=500
tv=500
b$="ms"
ENDIF
IF trakkyz=3 THEN
dt=1
tv=1000
b$="s"
ENDIF
IF trakkyz=4 THEN
dt=5
tv=5000
b$="s"
ENDIF
IF trakkyz=5 THEN
dt=10
tv=10000
b$="s"
ENDIF
IF trakkyz=6 THEN
dt=1
tv=1000*60
b$="m"
ENDIF
IF trakkyz=7 THEN
dt=5
tv=1000*60*5
b$="m"
ENDIF
IF trakkyz=8 THEN
dt=10
tv=1000*60*10
b$="m"
ENDIF
toffs=dt*trktf*trakkz
toffs2=tv*trktf*trakkz
toffs3=tv*trktf
IF tmax<10 THEN
tmax=10
ENDIF
tscstep=tscmax/tmax
tscplus=tscstep/trktf
RETURN
'
> PROCEDURE timeinit2
LOCAL a,a2
IF trakkz2=0 THEN
a=0
ELSE
a2=((tscmax-tscstep)/trakkz2)
IF a2=0 THEN
a2=1
ENDIF
a=(tmax-1)/a2
ENDIF
trakkz=INT(a+0.001)
IF trakkz>(tmax-1) THEN
trakkz=tmax-1
ENDIF
trakkr=ROUND((a-trakkz)*trktf)
IF trakkr<0 THEN
trakkr=0
ENDIF
toffs=(dt*trktf*trakkz)+dt*trakkr
toffs2=(trakkz*tv*trktf)+tv*trakkr
toffs3=tv*trktf
' PRINT trakkz,trakkr
RETURN
'
> PROCEDURE timeinit3
IF trakkz=(tmax-1) THEN
INC tmax
@timeinit
@timeinit2
trakkz2=trakkz*tscstep
@setbuttgr(trakslid&,trakxbut&,tmax,5)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
ENDIF
RETURN
'
> PROCEDURE timeinit4
trakkz=0
trakkr=0
trakkz2=0
trkztop=10
tmax=trkztop
@timeinit
@timeinit3
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
RETURN
'
> PROCEDURE timeinit5
tmax=trkztop
@timeinit
trakkz=0
trakkz2=0
trakkr=0
@slideinit(trakslid&,trakxbut&,tmax,5,vtrakkz)
@setslide(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
RETURN
'
> PROCEDURE timeinit6
@timeinit
IF toptime=0 THEN
trkztop=10
ELSE
trkztop=INT(toptime/thz*1000/toffs3)+1
ENDIF
IF trkztop<10 THEN
trkztop=10
ENDIF
RETURN
'
> PROCEDURE makesearch
LOCAL a,v
trkp=trktnr(tmfsz)
atrkp=trkp
vtrkp=trkp
a=trktime(trkp)
v=INT(a/thz*1000/tv)
trakkz=INT(v/trktf)
trakkr=v-(trakkz*trktf)
trakkz2=trakkz*tscstep+tscplus*trakkr
toffs=(dt*trktf*trakkz)+dt*trakkr
toffs2=(trakkz*tv*trktf)+tv*trakkr
toffs3=tv*trktf
trakact=trkch(trkp)
trkvz=trakact-1
RETURN
'
> PROCEDURE makesearch2
@spurbutt
@setslide2(trakslid&,trakxbut&,tscmax,trakkz2,tscstep)
@setslide(spurslid&,spurybut&,trkvmax,5,trkvz)
@timeline
@opentrk
RETURN
'
> PROCEDURE trak_timetxt
LOCAL i
@markhlp
IF bigfoot=FALSE THEN
ttxlin=ax&+dix+32
ELSE
ttxlin=ax&+dix+32
ENDIF
FOR i=0 TO 10
IF maxcol=2 OR dreidim=0 THEN
COLOR 1
ELSE
COLOR 0
ENDIF
IF bigfoot=FALSE THEN
LINE ttxlin+trxstp*i,ay&+45,ttxlin+trxstp*i,ay&+49
ELSE
LINE ttxlin+trxstp*i,ay&+69,ttxlin+trxstp*i,ay&+73
ENDIF
NEXT i
IF bigfoot=FALSE THEN
ttyd=42
ELSE
ttyd=68
ENDIF
IF trakkyz>5 THEN
t$=STR$(toffs)+b$
@bigtext3(ttxlin+trxstp*0,ay&+ttyd,1,t$,0,0)
t$=STR$(toffs+dt)+b$
@bigtext3(ttxlin+trxstp*1,ay&+ttyd,1,t$,0,6)
t$=STR$(toffs+dt*2)+b$
@bigtext3(ttxlin+trxstp*2,ay&+ttyd,1,t$,0,0)
t$=STR$(toffs+dt*3)+b$
@bigtext3(ttxlin+trxstp*3,ay&+ttyd,1,t$,0,6)
t$=STR$(toffs+dt*4)+b$
@bigtext3(ttxlin+trxstp*4,ay&+ttyd,1,t$,0,0)
t$=STR$(toffs+dt*5)+b$
@bigtext3(ttxlin+trxstp*5,ay&+ttyd,1,t$,0,6)
t$=STR$(toffs+dt*6)+b$
@bigtext3(ttxlin+trxstp*6,ay&+ttyd,1,t$,0,0)
t$=STR$(toffs+dt*7)+b$
@bigtext3(ttxlin+trxstp*7,ay&+ttyd,1,t$,0,6)
t$=STR$(toffs+dt*8)+b$
@bigtext3(ttxlin+trxstp*8,ay&+ttyd,1,t$,0,0)
t$=STR$(toffs+dt*9)+b$
@bigtext3(ttxlin+trxstp*9,ay&+ttyd,1,t$,0,6)
t$=STR$(toffs+dt*10)+b$
@bigtext3(ttxlin+trxstp*10,ay&+ttyd,1,t$,0,0)
ELSE
hsec=toffs2/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*0,ay&+ttyd,2,t$,1,0)
IF bigfoot=FALSE AND rscw&(trakker&)<800 THEN
t$="     "
ELSE
hsec=(toffs2+(tv*1))/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
ENDIF
@bigtext3(ttxlin+trxstp*1,ay&+ttyd,2,t$,1,6)
hsec=(toffs2+(tv*2))/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*2,ay&+ttyd,2,t$,1,0)
IF bigfoot=FALSE AND rscw&(trakker&)<800 THEN
t$="     "
ELSE
hsec=(toffs2+(tv*3))/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
ENDIF
@bigtext3(ttxlin+trxstp*3,ay&+ttyd,2,t$,1,6)
hsec=(toffs2+(tv*4))/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*4,ay&+ttyd,2,t$,1,0)
IF bigfoot=FALSE AND rscw&(trakker&)<800 THEN
t$="     "
ELSE
hsec=(toffs2+(tv*5))/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
ENDIF
@bigtext3(ttxlin+trxstp*5,ay&+ttyd,2,t$,1,6)
hsec=(toffs2+(tv*6))/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*6,ay&+ttyd,2,t$,1,0)
IF bigfoot=FALSE AND rscw&(trakker&)<800 THEN
t$="     "
ELSE
hsec=(toffs2+(tv*7))/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
ENDIF
@bigtext3(ttxlin+trxstp*7,ay&+ttyd,2,t$,1,6)
hsec=(toffs2+(tv*8))/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*8,ay&+ttyd,2,t$,1,0)
IF bigfoot=FALSE AND rscw&(trakker&)<800 THEN
t$="     "
ELSE
hsec=(toffs2+(tv*9))/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
ENDIF
@bigtext3(ttxlin+trxstp*9,ay&+ttyd,2,t$,1,6)
hsec=(toffs2+(tv*10))/10
@htimeset2                                  ! zeit
a$=LEFT$(a$,LEN(a$)-1)
t$=LEFT$(a$+SPACE$(11),11)
@bigtext3(ttxlin+trxstp*10,ay&+ttyd,2,t$,1,0)
ENDIF
RETURN
'
> PROCEDURE timeline
.| Glob. Var.: nr#,zu%,traknam1&,trakbox2&,xwidth#,ywidth#,trakkyz#,dt#,tv#
.|     b$,toffs#,trakkz#,toffs2#,a$,timeline&,vtrkp#,trkp#,trkz#,notrk#,t#
.|     trkc#,dv#,dv2#,trkbut#,d#,flen#
.| Felder    : trkch#(),trktime#(),trkend#(),trkstrt#(),trkfn$(),trksrate#()
.|     trkpnt#(),trknext#()
.| Ruft auf  : xrsrc_gaddr,hidetree2,textfeld,trkbutcalc2,trkbutcalc1
.|     hidetree
.| Aufruf in : button-4,trakker-1,do_trakker-4,
LOCAL i,j,t,d,dv,dv2,t$,sl$
IF nr=trakker& THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
@windowtest
ENDIF
IF cupdate=FALSE AND shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,trakbox2&,9,0,0,xwidth,ywidth)     ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
~@xrsrc_gaddr(0,nr,zu%)
@timeinit
@timeinit2
@trak_timetxt
vtrkp=trkp
IF trkz>0 THEN
@calc_trkalltime
FOR i=trkvz+1 TO trkvz+4
notrk=FALSE
t=0
trkc=0
REPEAT
INC t
IF trkch(t)=i AND trkvor(t)=0 THEN
INC trkc
ENDIF
UNTIL t=trkz OR (trkch(t)=i AND trkvor(t)=0)
IF trkch(t)=i THEN
dv=trktime(t)
dv2=trkend(t)-trkstrt(t)
d=dv2                   ! Auflîsung in ms
trkp=t
REPEAT
extrk=FALSE
@trkbutcalc2
@trkbutcalc1
IF extrk=TRUE OR notrk=TRUE THEN
trkp=trknext(trkp)
ENDIF
UNTIL trkp=0 OR notrk=FALSE OR trkz=trkp
IF notrk=FALSE THEN
IF trkc=1 THEN
'            trkpnt(i)=t
ENDIF
@trkbutdraw     ! neu
ELSE
trkc=0
ENDIF
notrk=FALSE
IF trknext(t)<>0 THEN
REPEAT
t=trknext(t)
INC trkc
dv=trktime(t)
dv2=trkend(t)-trkstrt(t)
d=dv2                  ! Auflîsung in ms
trkp=t
REPEAT
extrk=FALSE
@trkbutcalc2
@trkbutcalc1
IF extrk=TRUE OR notrk=TRUE THEN
trkp=trknext(trkp)
ENDIF
UNTIL trkp=0 OR notrk=FALSE OR trkz=trkp
IF notrk=FALSE THEN
IF trkc=1 THEN
'                trkpnt(i)=t
ENDIF
@trkbutdraw     ! neu
ELSE
trkc=0
ENDIF
notrk=FALSE
UNTIL trknext(t)=0 OR trktime(t)>=((toffs2+toffs3)*(thz/1000))
ENDIF
ENDIF
NEXT i
ENDIF
trkp=vtrkp
IF trkmem(trkp)=0 AND trkch(trkp)=0 THEN  ! letzter teil ab and neu
trkp=trkz
vtrkp=trkp
ENDIF
@tplaymark
IF credraw=FALSE THEN
CLIP OFF
ENDIF
@gettrak
ENDIF
RETURN
'
> PROCEDURE timeline2
LOCAL i,j,t,d,dv,dv2,t$,sl$
hsec=INT(trktime(atrkp)/thz*100)
@htimeset
@textfeld(trksmpte&,a$,1)
@timeline
RETURN
'
> PROCEDURE tractdraw
'  PRINT atrkp
@pmarkhlp2
IF trkp<>0 THEN
IF trkpath$(trkp)<>"MEMORY" AND trkpath$(trkp)<>"" THEN
sectpos=mbit*trkstrt(trkp)+head
hsec=INT(trkstrt(trkp)/thz*100)
@htimeset
@textfeld(trakstrt&,a$,1)
s=trkend(trkp)
hsec=INT(s/thz*100)
@htimeset
@textfeld(trakend&,a$,1)
hsec=INT((mbit*trkend(trkp)-sectpos)/thz/mbit*100)
@htimeset
@textfeld(trakdur&,a$,1)
s=trklen(trkp)
hsec=INT(s/thz*100)
@htimeset
@textfeld(traklen&,a$,1)
hsec=INT(trktime(trkp)/thz*100)
@htimeset
@textfeld(trksmpte&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE trakbutset(bs)
LOCAL t
IF trakact=1+trkvz THEN
t=trakk1&
ENDIF
IF trakact=2+trkvz THEN
t=trakk2&
ENDIF
IF trakact=3+trkvz THEN
t=trakk3&
ENDIF
IF trakact=4+trkvz THEN
t=trakk4&
ENDIF
@setbutton(t,bs)
RETURN
'
> PROCEDURE trakknr
.| Glob. Var.: trakact#,trakk1&,trakk2&,trakk3&,trakk4&,trakk5&,trakk6&
.|     trakk7&,trakk8&,obj#
.| Ruft auf  : setbutton
.| Aufruf in : do_trakker-1,
LOCAL t,tobj
IF obj=trakk1& THEN
t=1+trkvz
ENDIF
IF obj=trakk2& THEN
t=2+trkvz
ENDIF
IF obj=trakk3& THEN
t=3+trkvz
ENDIF
IF obj=trakk4& THEN
t=4+trkvz
ENDIF
tobj=obj
IF trakact<>0 THEN
IF trakact=t THEN
@trkdragin
ELSE
@trakbutset(0)
ENDIF
ENDIF
trakact=t
@setbutton(tobj,1)
RETURN
'
> PROCEDURE alltrakcopy(otc,ntc)
LOCAL az,atcex,mtrkp
az=0
mtrkp=0
atcex=FALSE
REPEAT
IF az=0 THEN
otrkp=trkpnt(otc)
ELSE
otrkp=trknext(otrkp)
ENDIF
INC az
IF otrkp<>0 THEN
IF trkz<lmax3 THEN
@oldtrkbox
'    otrkp=trkp
IF trkz>0 THEN
f=0
REPEAT
INC f
UNTIL f=trkz OR trkch(f)=0
IF trkch(f)=0 THEN
trkp=f
ELSE
INC trkz
trkp=trkz
ENDIF
ELSE
INC trkz
trkp=trkz
ENDIF
vtrkp=trkp
atrkp=trkp   ! aktuelles File
IF az=1 THEN
trkpnt(ntc)=trkp
ENDIF
trkch(trkp)=ntc
trkfn$(trkp)=trkfn$(otrkp)
trkcom$(trkp)=trkcom$(otrkp)
trkpath$(trkp)=trkpath$(otrkp)
'    @searchcom(trkp)
trkstrt(trkp)=trkstrt(otrkp)
trkend(trkp)=trkend(otrkp)
trkhead(trkp)=trkhead(otrkp)
trkbits(trkp)=trkbits(otrkp)
trksrate(trkp)=trksrate(otrkp)
trktri(trkp)=trktri(otrkp)
trkloop(trkp)=trkloop(otrkp)
trklen(trkp)=trklen(otrkp)
trktime(trkp)=trktime(otrkp)
trkmem(trkp)=0
trkg(trkp)=0
tcach(trkp)=FALSE
IF trkvor(otrkp)=0 THEN
trkvor(trkp)=0
ENDIF
IF trknext(otrkp)=0 THEN
trknext(trkp)=0
atcex=TRUE
ENDIF
'
IF mtrkp<>0 THEN
trknext(mtrkp)=trkp
trkvor(trkp)=mtrkp
ENDIF
mtrkp=trkp
'
@trkbutcalc2
@trkbutcalc1
@trkbutdraw
'      @timeline
ELSE
@alerts(28)
atcex=TRUE
ENDIF
ENDIF
UNTIL atcex=TRUE
@opentrk
RETURN
'
> PROCEDURE trakload
notrk=FALSE
IF trakact<>0 THEN
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(traktime&,a$,1)
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF neufsel=TRUE THEN
@newfsel
ELSE
@fileselect(op$+"*."+ext$,"","LOAD TRACK-FILE:")
ENDIF
@trakloading(fil$)
ELSE
@alerts(32)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE trakloading(fil$)
IF EXIST(fil$) THEN
@busy_mouse
@ldhead
tblkin$=fil$
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
sectors=f-head
sectall=sectors
sectpos=head
hardopen=TRUE
hsec=INT(sectall/thz/mbit*100)
@htimeset
@textfeld(traklen&,a$+CHR$(0),1)
a4$=LEFT$(STR$(INT(thz/100)/10)+SPACE$(4),4)+CHR$(0)
a$=nam$+CHR$(0)
IF trkz<lmax3 THEN
@oldtrkbox
IF trkz>0 THEN
f=0
REPEAT
INC f
UNTIL f=trkz OR trkmem(f)=0
IF trkmem(f)=0 THEN
trkp=f
ELSE
INC trkz
trkp=trkz
ENDIF
ELSE
INC trkz
trkp=trkz
ENDIF
vtrkp=trkp
atrkp=trkp   ! aktuelles File
dv=0
dv2=0
IF trkpnt(trakact)=0 THEN
trkpnt(trakact)=trkp
ENDIF
t=trkpnt(trakact)
IF trkch(t)=trakact THEN
t2=t
REPEAT
t2=trknext(t2)
IF t2<>0 THEN
t=t2
ENDIF
dv=trktime(t)
dv2=trkend(t)-trkstrt(t)
UNTIL (trkch(t)=trakact AND trknext(t)=0)
ENDIF
IF trkch(t)=trakact AND trknext(t)=0 THEN
trknext(t)=trkp
trkvor(trkp)=t
ENDIF
butnam$=a$
a$="*"+CHR$(0)  ! Startobj
@textfeld(trakname&,nam$+CHR$(0),1)
tl=72
d=dv2                    ! Auflîsung in ms
trktime(trkp)=dv+d
trksrate(trkp)=thz
a$=fil$
IF LEN(a$)>51 THEN
a=RINSTR(a$,"\")
IF a>0 THEN
REPEAT
a=INSTR(a$,"\")
a$=right$(LEN(a$)-a+1)
UNTIL LEN(a$)<=48 OR a=0
a$=a$+"..."
ELSE
a$="..."+RIGHT$(a$,48)
ENDIF
ENDIF
a$=a$+CHR$(0)
@textfeld(trakinfo&,a$,1)
trkpath$(trkp)=fil$+CHR$(0)
trkfn$(trkp)=nam$
trkcom$(trkp)=""
@searchcom(trkp)
trklen(trkp)=INT(sectall/mbit)
trkch(trkp)=trakact
trkhead(trkp)=head
IF dig24=FALSE THEN
trkbits(trkp)=16
ELSE
trkbits(trkp)=24
ENDIF
@trkbutcalc2
@trkbutcalc1
@trkbutdraw
@opentrk
ELSE
@alerts(28)
ENDIF
ENDIF
RETURN
'
> PROCEDURE traksethz
.| Glob. Var.: vhz#,trkp#
.| Felder    : trksrate#()
.| Ruft auf  : swtosrate,analog,digout
.| Aufruf in : trakforw-1,trkbackw-1,
'  thz=trksrate(trkp)
'  IF thz=0 THEN
'  thz=44100
' ENDIF
'  @swtosrate(thz)
@analog
@digout(TRUE)
RETURN
'
> PROCEDURE normplay1
xdig24=dig24
vfileart=fileart
vpch16=pch16
vpch4=pch4
pmo8=FALSE
pch16=FALSE
pch4=FALSE
IF trkbits(trkp)=24 THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
IF INSTR(trkfn$(trkp),".WAV")<>0 THEN
fileart=3
ELSE
fileart=1
ENDIF
RETURN
'
> PROCEDURE normplay2
pch16=vpch16
pch4=vpch4
dig24=xdig24
fileart=vfileart
IF dig24=TRUE THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
pmo8=FALSE
RETURN
'
> PROCEDURE trakforw
.| Glob. Var.: trkp#,pa$,vhz#,playstop#,hardopen#,handle#,sectall#,sectpos#
.|     sectors#,l#,playpos#,flen#,back%,hsec#,traktime&,a$,nr#
.| Felder    : trkpath$(),trksrate#()
.| Ruft auf  : traksethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_trakker-2,
@normplay1
IF trkpath$(trkp)<>"" AND pa$<>"" THEN
'    @traksethz
'    vhz=trksrate(trkp)
IF playstop=2 AND hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
@analog
@digout(TRUE)
'        @swtosrate(vhz)
IF sectall>sectpos THEN
sectors=sectall-sectpos
l=0
playpos=sectpos
adder=over
hz=thz
@maschrufb5
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
ENDIF
@digout(FALSE)
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
hsec=INT((sectpos-head)/thz/mbit*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(traktime&,a$,1)
IF handle>0 THEN
@analog
@digout(TRUE)
'          @swtosrate(vhz)
l=0
sectpos=head    ! neu !
playpos=sectpos
sectors=sectall-sectpos
adder=over
hz=thz
@maschrufb5
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
@digout(FALSE)
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
IF thz>0 THEN
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
ENDIF
@normplay2
DEFMOUSE 0
RETURN
'
> PROCEDURE trkbackw
.| Glob. Var.: trkp#,pa$,vhz#,playstop#,hardopen#,sectpos#,sectors#,l#
.|     playpos#,flen#,back%,handle#,sectall#,hsec#,traktime&,a$,nr#
.| Felder    : trkpath$(),trksrate#()
.| Ruft auf  : traksethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_trakker-2,
@normplay1
IF trkpath$(trkp)<>"" AND pa$<>"" THEN
'    @traksethz
'    vhz=trksrate(trkp)
IF playstop=2 AND hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
@analog
@digout(TRUE)
'      @swtosrate(vhz)
IF sectpos>0 THEN
sectors=sectpos
l=0
playpos=sectpos
adder=over
hz=thz
@maschrufb5
IF sectpos>0 THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos<head THEN
sectpos=head
ENDIF
ENDIF
@digout(FALSE)
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF sectpos=0 OR sectpos=head THEN
sectpos=sectall
ENDIF
playpos=sectpos
hsec=INT((sectpos-head)/thz/mbit*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(traktime&,a$,1)
IF handle>0 THEN
@analog
@digout(TRUE)
'          @swtosrate(vhz)
sectors=sectpos
l=0
playpos=sectpos
hz=thz
@maschrufb5
IF sectpos>0 THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
@digout(FALSE)
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
hsec=INT((sectpos-head)/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
@normplay2
DEFMOUSE 0
RETURN
'
> PROCEDURE trkstop
.| Glob. Var.: handle#,playstop#,hardopen#,a$,trakname&,stop2&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : do_trakker-1,
~GEMDOS(62,handle)
'  playstop=1
'  handle=0
'  hardopen=FALSE
'  a$=SPACE$(12)
'  @textfeld(trakname&,a$,1)
IF XBIOS(xbs,1)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
intplay=FALSE
ENDIF
REPEAT
UNTIL @mousek=0
PAUSE 3
@setbutton(stop2&,0)
@setbutton(tblkplay&,0)
RETURN
'
> PROCEDURE trkstrt
.| Glob. Var.: trkp#,sectpos#,hsec#,flen#,vhz#,trakstrt&,a$
.| Felder    : trkstrt#()
.| Ruft auf  : htimeset,textfeld,setbutton,trkbutcalc1
.| Aufruf in : do_trakker-1,
LOCAL v4,q
@testcopyright
IF trkp>0 AND trkch(trkp)<>0 THEN
~GRAF_MKSTATE(v,v,v,v4)
IF v4=0 THEN
IF trkbits(trkp)=24 THEN
q=6
ELSE
q=4
ENDIF
trkstrt(trkp)=INT((sectpos-head)/q)
hsec=INT((sectpos-head)/thz/q*100)
@htimeset
@textfeld(trakstrt&,a$,1)
IF trkstrt(trkp)>trkend(trkp) THEN
trkend(trkp)=trkstrt(trkp)
@textfeld(trakend&,a$,1)
ENDIF
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz*100)
@htimeset
@textfeld(trakdur&,a$,1)
@setbutton(trakstrt&,0)
@trkbutcalc1
'  @trkbutdraw
@timeline
ELSE
vornr=nr
nr=record&
a$="Track-Start"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
mmax=trklen(trkp)/thz*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld2(nr,recfree&,a$,1)
m=trkstrt(trkp)
dt=INT(m/thz*100)
@rsc_draw(nr,0)
@markhlp
timekey=4
@timekey
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("TRACK-START")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
trkstrt(trkp)=INT(dt/100*thz)
hsec=INT(trkstrt(trkp)/thz*100)
@htimeset
@textfeld(trakstrt&,a$,1)
IF trkstrt(trkp)>trkend(trkp) THEN
trkend(trkp)=trkstrt(trkp)
@textfeld(trakend&,a$,1)
ENDIF
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz*100)
@htimeset
@textfeld(trakdur&,a$,1)
@setbutton(trakstrt&,0)
@trkbutcalc1
@timeline
ELSE
@setbutton(trakstrt&,0)
ENDIF
obj=0
ENDIF
ELSE
@setbutton(trakstrt&,0)
ENDIF
RETURN
'
> PROCEDURE trakdelvor
LOCAL i,j,len
IF tch<>trkch(atrkp) AND atrkp<>0 THEN
trkpnt(tch)=0
atrkp=0
@alerts(51)
ENDIF
IF atrkp<>0 AND tch=trkch(atrkp) THEN
IF atrkp<trkz THEN
a=trkmem(atrkp)
b=trkmem(atrkp)+trkg(atrkp)*8
IF a>0 AND b>0 THEN
dtrc=b-a
topmem=trkmem(trkz)+trkg(trkz)*8
len=topmem-dtrc-trkmem(0)
IF len>0 THEN
BMOVE b,a,len
ENDIF
FOR i=atrkp+1 TO trkz
IF trkmem(i)>0 THEN
trkmem(i)=(trkmem(i)-dtrc)
ENDIF
NEXT i
ENDIF
ENDIF
IF trkvor(atrkp)=0 THEN
a=trknext(atrkp)
trkpnt(trkch(atrkp))=a
ENDIF
trkch(atrkp)=0
trktime(atrkp)=0
trkmax(atrkp)=0
trkmem(atrkp)=0
trkg(atrkp)=0
tcach(atrkp)=0
trkfn$(atrkp)=""
trkcom$(atrkp)=""
trkpath$(atrkp)=""
trkstrt(atrkp)=0
trkend(atrkp)=0
trkhead(atrkp)=0
trkbits(atrkp)=0
trksrate(atrkp)=0
trktri(atrkp)=0
trkloop(atrkp)=0
trklen(atrkp)=0
trktime(atrkp)=0
a=trkvor(atrkp)
b=trknext(atrkp)
IF a<>0 THEN
trknext(a)=b
ENDIF
IF b<>0 THEN
trkvor(b)=a
ENDIF
trknext(atrkp)=0
trkvor(atrkp)=0
trkch(atrkp)=0
IF atrkp=trkz THEN
REPEAT
DEC trkz
UNTIL trkch(trkz)>0 OR trkz=0
ENDIF
ENDIF
RETURN
'
> PROCEDURE deltrktxt
LOCAL r
a$=SPACE$(12)+CHR$(0)
@textfeld(trakname&,a$,1)
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(trakstrt&,a$,1)
@textfeld(trakend&,a$,1)
@textfeld(trakdur&,a$,1)
@textfeld(traklen&,a$,1)
@textfeld(trksmpte&,a$,1)
hsec=0
@htimeset
@textfeld(traktime&,a$,1)
IF hardopen=TRUE THEN
r=GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
RETURN
'
> PROCEDURE trakdel
LOCAL a$
IF trkch(atrkp)=trkcwert AND trdrag=TRUE AND clipart=1 THEN
IF trkpnt(trkcwert)<>0 THEN
IF trknext(trkpnt(trkcwert))=0 THEN
@setbutton(trakclip&,0)
trdrag=FALSE
clipart=0
trkcart=0
ENDIF
ENDIF
ENDIF
IF atrkp=merkclip AND tdrag=TRUE AND clipart=2 THEN
@setbutton(trakclip&,0)
tdrag=FALSE
clipart=0
ENDIF
@deltrktxt
IF atrkp<>0 THEN
tch=trkch(atrkp)
@trakdelvor
ENDIF
IF atrkp<>0 THEN
@timeline
atrkp=trkp
ENDIF
@calc_trkalltime
@setbutton(trakdel&,0)
RETURN
'
> PROCEDURE trkbutcalc1    ! Breite
.| Glob. Var.: a#,trkp#,b#,c#,flen#,tv#,d#,toffs2#,px#,nr#,zu%,trkbut#
.|     trakbox2&,xwidth#,ywidth#,notrk#
.| Felder    : trkstrt#(),trkend#(),trksrate#(),trktime#(),trknext#()
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : timeline-2,trkstrt-1,trkend-1,
IF trkp>0 AND trkch(trkp)<>0 THEN
@markhlp
a=trkstrt(trkp)
b=trkend(trkp)
c=b-a
IF c<1 THEN
c=1
ENDIF
c=INT((c/thz*1000))
d=trktime(trkp)/thz*1000
IF toffs2>0 THEN
d=d-toffs2
ENDIF
IF d<0 THEN
IF d+c>=0 THEN
c=c+d
d=0
ENDIF
ENDIF
c=INT((c*trxstp/tv))
IF c<6 THEN   ! vorher 72
c=6
ENDIF
IF d>=0 THEN
d=INT((d/tv*trxstp))
ENDIF
IF c<=0 THEN
extrk=TRUE
ENDIF
IF d<=dig AND d>=0 AND c>0 AND trkp<>0 AND extrk=FALSE THEN
~@xrsrc_gaddr(0,nr,zu%)
IF c+d>dig THEN
c=dig-d
ENDIF
'    DPOKE (zu%+24*trkbut+20),c                         ! Breite des Objekts verÑndern
tr_b=c
'    ~WIND_UPDATE(1)                                    ! BEG_UPDATE
'    ~OBJC_DRAW(zu%,trakbox2&,9,0,0,xwidth,ywidth)     ! neu zeichnen
'    ~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
notrk=TRUE
ENDIF
ENDIF
RETURN
'
> PROCEDURE trkbutcalc2    ! X-Position
IF trkp>0 AND trkch(trkp)<>0 THEN
@markhlp
d=trktime(trkp)/thz*1000
IF toffs2>0 THEN
d=d-toffs2
ENDIF
a=trkstrt(trkp)
b=trkend(trkp)
c=b-a
c=INT((c/thz*1000))
IF d<0 THEN
IF d+c>=0 THEN
d=0
ENDIF
ENDIF
c=INT((c*trxstp/tv))
IF c<6 THEN   ! vorher 72
c=6
ENDIF
d=INT(d*trxstp/tv)
IF d<0 THEN
extrk=TRUE
ENDIF
IF d<=dig AND d>=0 AND c>0 AND trkp<>0 AND extrk=FALSE THEN
~@xrsrc_gaddr(0,nr,zu%)
IF c+d+tl>dig THEN
c=dig-d
ENDIF
'    DPOKE (zu%+24*(trkbut)+16),d                       ! X-Position des Objekts verÑndern
tr_x=d
ELSE
notrk=TRUE
ENDIF
ENDIF
RETURN
'
> PROCEDURE tcvorclr
LOCAL i,i2,a,b
FOR i=1 TO trc-1
IF tcach(i)=TRUE AND trkg(i)>0 THEN
z=z+trkg(i)*8
a=trkmem(i)+trkg(i)*8
b=trkmem(i)
IF a>0 AND b>0 AND (topmem-a)<>0 THEN
BMOVE a,b,topmem-a
topmem=topmem-(a-b)
ENDIF
tcach(i)=FALSE
trkg(i)=0
IF i<trkz THEN
FOR i2=i+1 TO trkz
IF trkmem(i2)>0 THEN
trkmem(i2)=trkmem(i2)-(a-b)   ! Datenverschiebung
ENDIF
NEXT i2
ENDIF
ENDIF
EXIT IF z>dtr
NEXT i
RETURN
'
> PROCEDURE tcnachclr
LOCAL i,i2,a,b
FOR i=trc+1 TO trkz
IF tcach(i)=TRUE AND trkg(i)>0 THEN
z=z+trkg(i)*8
a=trkmem(i)+trkg(i)*8
b=trkmem(i)
IF a>0 AND b>0 AND (topmem-a)<>0 THEN
BMOVE a,b,topmem-a
topmem=topmem-(a-b)
ENDIF
tcach(i)=FALSE
trkg(i)=0
IF i<trkz THEN
FOR i2=i+1 TO trkz
IF trkmem(i2)>0 THEN
trkmem(i2)=trkmem(i2)-(a-b)   ! Datenverschiebung
ENDIF
NEXT i2
ENDIF
ENDIF
EXIT IF z>dtr
NEXT i
RETURN
'
> PROCEDURE tcachclr
LOCAL g
z=0
dtr=(glen*8)-(trkg(trc)*8)
IF trkz>1 THEN
IF trc>1 THEN
@tcvorclr
IF z<=dtr THEN
@tcnachclr
ENDIF
ELSE
@tcnachclr
ENDIF
IF z>dtr THEN
notrkmem=FALSE
@trksprint
ELSE
@alerts(33)
ENDIF
ENDIF
RETURN
'
> PROCEDURE trksprint
LOCAL tm,i,a
IF trc=0 AND trkz>0 THEN
dtrc=(glen*8)-(trkg(trc)*8)
tm=trkz+1
REPEAT
DEC tm
UNTIL trkmem(tm)>0
topmem=trkmem(tm)+trkg(tm)*8
IF (topmem-trkmem(0)+dtrc)>tmlen THEN
notrkmem=TRUE
tcach(trc)=0
ELSE
notrkmem=FALSE
ENDIF
IF notrkmem=FALSE THEN
FOR i=trc+1 TO trkz
IF trkmem(i)>0 THEN
trkmem(i)=trkmem(i)+dtrc   ! Datenverschiebung
ENDIF
NEXT i
a=trkmem(trc)+trkg(trc)*8
IF a>0 AND dtrc<>0 AND (topmem-a)>0 THEN
BMOVE a,a+dtrc,topmem-a
ENDIF
ENDIF
ENDIF
IF cached=FALSE THEN
IF trc>0 THEN
trc2=trc
REPEAT
DEC trc2
trkmem(trc)=trkmem(trc2)+trkg(trc2)*8
UNTIL trkmem(trc)<>0
IF trc<trkz THEN
dtrc=(glen*8)-(trkg(trc)*8)
tm=trkz+1
REPEAT
DEC tm
UNTIL trkmem(tm)>0
topmem=trkmem(tm)+trkg(tm)*8
IF (topmem-trkmem(0)+dtrc)>tmlen THEN
notrkmem=TRUE
tcach(trc)=0
ELSE
notrkmem=FALSE
ENDIF
IF notrkmem=FALSE THEN
FOR i=trc+1 TO trkz
IF trkmem(i)>0 THEN
trkmem(i)=trkmem(i)+dtrc   ! Datenverschiebung
ENDIF
NEXT i
a=trkmem(trc)+trkg(trc)*8
IF a>0 AND dtrc<>0 AND (topmem-a)>0 THEN
BMOVE a,a+dtrc,topmem-a
ENDIF
'          PRINT "(trkp,trkz,topmem,a,e,l):",trc,trkz,topmem,a,a+dtrc,topmem-a
ENDIF
ELSE
IF ((trkmem(trkz)+glen*8)-trkmem(0))>tmlen THEN
notrkmem=TRUE
tcach(trc)=0
ELSE
notrkmem=FALSE
ENDIF
ENDIF
ENDIF
ENDIF
IF notrkmem=TRUE THEN
@tcachclr
ENDIF
RETURN
'
> PROCEDURE trkbutdraw
LOCAL i,a,b,c,h,a2,a3,tx,ty,l,ss,tcs,tce,txtl,ax$
trknocach=FALSE
@markhlp
GRAPHMODE 1
DEFLINE 1
IF trkmem(vtrkp)=0 AND trkch(vtrkp)=0 THEN    ! letzter Teil ab and neu
vtrkp=trkz
ENDIF
IF trkch(trkp)>0 AND trkp>0 THEN
IF maxcol=2 THEN
DEFFILL 0,1,0
ELSE
DEFFILL 8,1,8
ENDIF
IF trkp=vtrkp THEN
IF maxcol=2 THEN
DEFLINE 4
COLOR 1
ELSE
COLOR 2
ENDIF
IF hardopen=FALSE THEN
@opentrk2
ENDIF
ELSE
COLOR 1
ENDIF
tx=tr_x+dix
ty=(trkch(trkp)-trkvz-1)*(trhb+trhd)+trhs
trkx(trkp)=tx
trkb(trkp)=tr_b
tx=tx+ax&+32
ty=ty+ay&+14
IF tncom=FALSE THEN
ax$=trkfn$(trkp)
ELSE
IF trkcom$(trkp)<>"" THEN
ax$=trkcom$(trkp)
ELSE
ax$=trkfn$(trkp)
ENDIF
ENDIF
IF trkch(trkp)>0 AND trkp>0 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
PBOX tx,ty,tx+tr_b,ty+trhb
BOX tx,ty,tx+tr_b,ty+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
DEFLINE 1
l=(trkend(trkp)-trkstrt(trkp))*mbit
a=trkstrt(trkp)
b=trkend(trkp)
c=b-a
c=INT((c/thz*1000))
glen=INT((c*trxstp/tv))+1              ! Gesamt-Pixelzahl
ss=trktime(trkp)/thz*1000
tcs=0
IF ss<toffs2 THEN
tcs=INT((toffs2-ss)/tv*trxstp)                 ! Startpixel
ENDIF
tce=tcs+tr_b-1                   ! Endpixel
IF glen>4 AND tvideo=TRUE THEN
trc=trkp
vcached=cached
IF trc>0 THEN
IF trkg(trc)<>glen OR glen=0 THEN
tcach(trc)=FALSE
ENDIF
cached=tcach(trc)
ELSE
cached=FALSE
ENDIF
@trksprint
IF cached=FALSE THEN
fil$=trkpath$(trkp)
s=RINSTR(fil$,".")
c$=LEFT$(fil$,s)+peak$+CHR$(0)
pbfyes=EXIST(c$)
IF l<=mlen THEN
IF pbfyes=TRUE AND (l/mbit/512)>glen AND glen>0 THEN
@pbfcaching
ELSE
IF (l/mbit/512)>(glen*2) AND glen>0 THEN
@pbfcaching
ELSE
b$=trkpath$(trkp)
b=VARPTR(b$)
h=GEMDOS(61,L:b,0)
a=GEMDOS(66,L:trkstrt(trkp)*mbit,h,0)
a2=GEMDOS(63,h,L:l,L:meml)
a3=GEMDOS(62,h)
ENDIF
ENDIF
ELSE
IF (l/mbit/512)>glen THEN
@pbfcaching
ELSE
a=mbit*trkstrt(trkp)+(l/glen*tcs)
b=mbit*trkstrt(trkp)+(l/glen*tce)
a=INT(a/mbit)*mbit
b=INT(b/mbit)*mbit
c=b-a
IF c<mlen THEN
b$=trkpath$(trkp)
i=VARPTR(b$)
h=GEMDOS(61,L:i,0)
v=GEMDOS(66,L:a,h,0)
a2=GEMDOS(63,h,L:c,L:meml)
a3=GEMDOS(62,h)
l=c
tce=tce-tcs
tcs=0
vglen=glen
glen=tce
trknocach=TRUE
trkg(trkp)=glen
ELSE
@pbfcaching
ENDIF
ENDIF
ENDIF
ENDIF
@mcurve(0,l,tr_b-2,trhc-2,tx+1,ty+trht,ty+trhc+trht,tcs,tce,glen-1)
IF trknocach=FALSE THEN
tcach(trc)=cached
cached=vcached
ELSE
trkg(trkp)=vglen
cached=FALSE
glen=0
@trksprint
tcach(trc)=FALSE
trkg(trc)=0
ENDIF
ENDIF
IF trkch(trkp)>0 AND trkp>0 THEN
IF bigfoot=FALSE THEN
txtl=INT((tr_b-2)/6)
ELSE
txtl=INT((tr_b-2)/8)
ENDIF
IF txtl>0 THEN
IF LEN(ax$)>txtl THEN
ax$=LEFT$(ax$,txtl)
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
COLOR 1
GRAPHMODE 1
IF bigfoot=FALSE THEN
DEFTEXT 1,0,0,4
TEXT tx+1,ty+5,ax$
LINE tx+1,ty+7,tx+1+LEN(ax$)*6,ty+7
LINE tx+1+LEN(ax$)*6,ty+7,tx+1+LEN(ax$)*6,ty+1
ELSE
DEFTEXT 1,0,0,6
TEXT tx+1,ty+7,ax$
LINE tx+1,ty+9,tx+1+LEN(ax$)*8,ty+9
LINE tx+1+LEN(ax$)*8,ty+9,tx+1+LEN(ax$)*8,ty+1
DEFTEXT 1,0,0,4
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE openpbf
OPEN "I",#2,c$
pbuf=LOF(#2)
CLOSE #2
nopeakmem=FALSE
IF peakmemda=TRUE THEN
~MFREE(peakmem%)
ENDIF
peakmem%=@malloc(pbuf,1)     ! Peak-Buffer
IF peakmem%<=0 THEN
nopeakmem=TRUE
ELSE
peakmemda=TRUE
ENDIF
RETURN
'
> PROCEDURE workpbf
LOCAL adr,s1,s2,m,c,c2,stp,z,vi,j,i,i2
IF mlen>=pbuf AND nopeakmem=FALSE AND pbuf>0 THEN
pbm$=c$+CHR$(0)
tma=trkmem(trkp)
a=trkstrt(trkp)*mbit
b=trkend(trkp)*mbit
IF a=0 THEN
s1=a
ELSE
s1=INT(pbuf/(trklen(trkp)*mbit/a))
s1=INT(s1/8)*8
ENDIF
IF b=trklen(trkp)*mbit THEN
s2=pbuf
ELSE
s2=INT(pbuf/(trklen(trkp)*mbit/b))
s2=INT(s2/8)*8
ENDIF
m=s2-s1
IF pmemisda=FALSE THEN
handle=GEMDOS(61,L:VARPTR(pbm$),0)
~GEMDOS(66,L:s1,handle,0)     ! SEEK
~GEMDOS(63,handle,L:m,L:peakmem%)
~GEMDOS(62,handle)
ENDIF
s1=s1+peakmem%
s2=s2+peakmem%
c=(b-a)/mbit/thz*1000
c2=INT((c*trxstp/tv))              ! Gesamt-Pixelzahl
IF c2>0 THEN
stp=(s2-s1)/c2
ELSE
stp=0
ENDIF
IF stp<=0 THEN
stp=8
ENDIF
pbufda=FALSE
cached=TRUE
werte=c2
z=0
IF werte>0 THEN
vi=peakmem%
max=0
FOR j=1 TO werte
@busy_mouse
i=INT(vi/8)*8           !neu
i2=INT((vi+stp)/8)*8           !neu
IF i2=i THEN
i2=i+8
ENDIF
adr=XBIOS(xbs,301,L:i,L:i2)
a=DPEEK(adr)
am=DPEEK(adr+2)
IF a>max THEN
max=a
ENDIF
IF am>max THEN
max=am
ENDIF
DPOKE (tma+z*8+4),a
DPOKE (tma+z*8+6),am
a=DPEEK(adr+4)
am=DPEEK(adr+6)
IF a>max THEN
max=a
ENDIF
IF am>max THEN
max=am
ENDIF
DPOKE (tma+z*8),a
DPOKE (tma+z*8+2),am
vi=vi+stp
INC z
NEXT j
trkmax(trkp)=max
tcach(trkp)=TRUE
trkg(trkp)=werte+1
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
RETURN
'
> PROCEDURE pbfcaching
IF pbfyes=TRUE THEN
pmemisda=FALSE
@openpbf
@workpbf
ELSE
@makepbf
IF nomem=FALSE THEN
@workpbf
pmemisda=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE makepbf
LOCAL m2,l,z,m,bw,v,handle,anf,anf2,fg
fg=2048
IF dig24=TRUE THEN
fg=3072
ENDIF
nopeakmem=FALSE
'  head=20
z=head
OPEN "I",#6,fil$
l=LOF(#6)
CLOSE #6
pbuf=INT(l/fg*8)
pbuf=pbuf+sector
lq=INT(l/fg)*fg
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>(pbuf+sector) THEN
IF peakmemda=TRUE THEN
~MFREE(peakmem%)
ENDIF
peakmem%=@malloc(pbuf,1)     ! Peak-Buffer
IF peakmem%<=0 THEN
nopeakmem=TRUE
ELSE
peakmemda=TRUE
ENDIF
IF nopeakmem=FALSE THEN
anf=peakmem%
anf2=anf
a$=fil$+CHR$(0)
handle=GEMDOS(61,L:VARPTR(a$),0)
m2=INT(mlen/fg)*fg
v=GEMDOS(66,L:z,handle,0)     ! SEEK
REPEAT
@busy_mouse
IF (lq-m2)>=0 THEN
m=m2
ELSE
m=lq
ENDIF
bw=GEMDOS(63,handle,L:m,L:meml)
lq=lq-m
i=meml
stp=fg
'
IF fileart=3 THEN
@maschruf28(meml,m)
ENDIF
'
FOR j=meml TO (meml+m-fg) STEP fg
i=j
@maschruf31
DPOKE anf2,a
DPOKE anf2+2,am
i=j+mbit/2
@maschruf31
DPOKE anf2+4,a
DPOKE anf2+6,am
anf2=anf2+8
NEXT j
UNTIL lq<=0
~GEMDOS(62,handle)
s=RINSTR(fil$,".")
b$=LEFT$(fil$,s)+peak$+CHR$(0)
handle=GEMDOS(60,L:VARPTR(b$),0)
m=anf2-anf
bw=GEMDOS(64,handle,L:m,L:anf)
~GEMDOS(62,handle)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pbuf=m
pmemisda=TRUE
ENDIF
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE oldtrkbox
LOCAL a,b,vcx,vcy,vcb
IF trkp>0 AND trkch(trkp)>0 THEN                  ! rote Umrandung vom vorherigen Kasten entfernen
vcx=xd+trkx(trkp)
vcy=yd+(trkch(trkp)-trkvz-1)*(trhb+trhd)+trhs
vcb=trkb(trkp)
a=trktime(trkp)/thz*1000
b=a+((trkend(trkp)-trkstrt(trkp))/thz*1000)
IF a<(toffs2+toffs3) AND b>toffs2 AND trkch(trkp)>trkvz AND trkch(trkp)<(trkvz+5) THEN
GRAPHMODE 1
COLOR 1
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
BOX vcx,vcy,vcx+vcb,vcy+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
ENDIF
RETURN
'
> PROCEDURE searchtrak
LOCAL a,b,t
tfound=FALSE
IF winmove=FALSE THEN
@mouse(x,y,v)
IF x>=xd+dix AND x<=xd+dix+dig AND y>=yd+trhs AND y<=yd+trhs+4*(trhb+trhd) THEN
t=0
IF y>=yd+trhs AND y<=yd+trhs+trhb THEN
t=trkvz+1
ENDIF
IF y>=yd+trhs+(trhb+trhd) AND y<=yd+trhs+(trhb+trhd)+trhb THEN
t=trkvz+2
ENDIF
IF y>=yd+trhs+2*(trhb+trhd) AND y<=yd+trhs+2*(trhb+trhd)+trhb THEN
t=trkvz+3
ENDIF
IF y>=yd+trhs+3*(trhb+trhd) AND y<=yd+trhs+3*(trhb+trhd)+trhb THEN
t=trkvz+4
ENDIF
IF t<>0 AND trkpnt(t)<>0 THEN
i=trkpnt(t)
REPEAT
cx=xd+trkx(i)
cb=trkb(i)
a=trktime(i)/thz*1000
b=a+((trkend(i)-trkstrt(i))/thz*1000)
IF x>=cx AND x<=cx+cb AND a<(toffs2+toffs3) AND b>toffs2 THEN
tfound=TRUE
cy=yd+(trkch(i)-trkvz-1)*(trhb+trhd)+trhs
ENDIF
EXIT IF tfound=TRUE
i=trknext(i)
UNTIL i=0 OR tfound=TRUE
ENDIF
IF tfound=TRUE THEN
@oldtrkbox
trkp=i
IF maxcol=2 THEN                                  ! ab hier rote Umrandung fÅr neuen Kasten zeichnen
COLOR 1
DEFLINE 4
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
BOX cx,cy,cx+cb,cy+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
DEFLINE 1
ELSE
COLOR 2
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
BOX cx,cy,cx+cb,cy+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
COLOR 1
@gettrak
ENDIF
ENDIF
ENDIF
winmove=FALSE
RETURN
'
> PROCEDURE searchkeytrak(direction)
LOCAL a,b,vcx,vcy,vcb,oldstrt,tcx,tcd,tch,ti,tcm
'
' Direction 1(links),2(rechts),3(oben),4(unten)
'
tfound=FALSE
@markhlp
IF trkp=0 AND trkz>0 THEN
trkp=1
ENDIF
IF trkp>0 AND trkch(trkp)>0 THEN                  ! rote Umrandung vom vorherigen Kasten entfernen
oldstrt=trktime(trkp)/thz*1000
tcm=oldstrt
tcx=-1
FOR i=1 TO trkz
a=trktime(i)/thz*1000
b=a+((trkend(i)-trkstrt(i))/thz*1000)
IF direction=2 AND a>oldstrt AND (a<tcx OR tcx=-1) AND trkch(trkp)=trkch(i) THEN
tfound=TRUE
tcx=a
ti=i
ENDIF
IF direction=1 AND a<oldstrt AND (a>tcx OR tcx=-1) AND trkch(trkp)=trkch(i) THEN
tfound=TRUE
tcx=a
ti=i
ENDIF
IF direction=3 AND a<(toffs+toffs3) AND b>toffs2 AND trkch(i)<trkch(trkp) AND (trkch(i)>=tch OR tcx=-1) THEN
IF trkch(i)>tch OR tcx=-1 THEN
tfound=TRUE
tcd=ABS(oldstrt-a)
tcx=a
tch=trkch(i)
ti=i
ELSE
IF (ABS(oldstrt-a)<tcd OR tcx=-1) THEN
tfound=TRUE
tcd=ABS(oldstrt-a)
tcx=a
tch=trkch(i)
ti=i
ENDIF
ENDIF
ENDIF
IF direction=4 AND a<(toffs+toffs3) AND b>toffs2 AND trkch(i)>trkch(trkp) AND (trkch(i)<=tch OR tcx=-1) THEN
IF trkch(i)<tch OR tcx=-1 THEN
tfound=TRUE
tcd=ABS(oldstrt-a)
tcx=a
tch=trkch(i)
ti=i
ELSE
IF (ABS(oldstrt-a)<tcd OR tcx=-1) THEN
tfound=TRUE
tcd=ABS(oldstrt-a)
tcx=a
tch=trkch(i)
ti=i
ENDIF
ENDIF
ENDIF
NEXT i
IF tfound=TRUE THEN
IF trkch(ti)<=trkvz THEN
trkvz=trkch(ti)-1
vtrkvz=trkvz
@setslide(spurslid&,spurybut&,trkvmax-4,5,trkvz)
@spurbutt
@timeline
ENDIF
IF trkch(ti)>trkvz+4 THEN
trkvz=trkch(ti)-4
vtrkvz=trkvz
@setslide(spurslid&,spurybut&,trkvmax-4,5,trkvz)
@spurbutt
@timeline
ENDIF
cx=xd+trkx(ti)
cy=yd+(trkch(ti)-trkvz-1)*(trhb+trhd)+trhs
cb=trkb(ti)
a=trktime(ti)/thz*1000
b=a+((trkend(ti)-trkstrt(ti))/thz*1000)
@oldtrkbox
trkp=ti
IF trkch(ti)>0 AND a<(toffs2+toffs3) AND b>toffs2 AND trkch(ti)>trkvz AND trkch(ti)<trkvz+5 THEN
IF maxcol=2 THEN                                  ! ab hier rote Umrandung fÅr neuen Kasten zeichnen
COLOR 1
DEFLINE 4
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
BOX cx,cy,cx+cb,cy+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
DEFLINE 1
ELSE
COLOR 2
~GRAF_MOUSE(256,0)                              ! Hidem
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
BOX cx,cy,cx+cb,cy+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
COLOR 1
ENDIF
@gettrak
ENDIF
ENDIF
RETURN
'
> PROCEDURE trakmoving
LOCAL k,x,v,v2,b,t,a,tf,cv,vx,vmx,xxx,vmy,y2,vy,cyw,xmaxx,c,c2,tstat4,ddd,l
ddd=0
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
~GRAF_MKSTATE(x,v,k,v2)
IF (x>=cx AND x<=cx+cb AND v>=cy AND v<=cy+trhb) THEN
GRAPHMODE 1
~GRAF_MOUSE(256,0)                              ! Hidem
trm2=@rsc_get(cx,cy,cb+1,trhb+1)         ! leere Box
trm1=@rsc_get(cx,cy,cb+1,trhb+1)           ! trm1=Kurveninhalt
IF maxcol=2 OR dreidim=0 THEN
DEFFILL 0,1,0
ELSE
DEFFILL smpblkcol,1,smpblkcol
ENDIF
COLOR 1
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
PBOX cx,cy,cx+cb,cy+trhb
IF credraw=FALSE THEN
CLIP OFF
ENDIF
GRAPHMODE 3
trm2=@rsc_get2(cx,cy,cb+1,trhb+1,trm2)         ! leere Box
@rsc_put(trm1,cx,cy,1)                            ! Kurveninhalt neuzeichnen
@mouse(x,v,k)
vmx=x
vx=x
xxx=cx
vmy=y
vcyw=trkch(atrkp)-trkvz
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
vy=y2
vy2=y
cv=trktime(atrkp)
REPEAT
@mouse(x,y,k)
IF x>xwidth-40 THEN
x=xwidth-40
ENDIF
cyw=trkch(atrkp)-trkvz+INT((y-vmy)/10)
IF cyw<1 THEN
cyw=1
ENDIF
IF cyw>4 THEN
cyw=4
ENDIF
xmaxx=xd+dig+dix
IF (x>=xd+dix AND x<=xmaxx) THEN
IF x<>vx OR cyw<>vcyw THEN
b=x-vmx
c=INT(cv+((thz/1000*tv/trxstp)*b))
c2=trktime(atrkp)
IF c>=0 THEN
IF c2<>c THEN
trktime(atrkp)=c
hsec=INT(trktime(atrkp)/thz*100)
@htimeset
@textfeld(trksmpte&,a$,1)
ENDIF
IF cyw<>vcyw THEN
vcyw=cyw
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
ENDIF
vxxx=cx+(vx-vmx)
IF vxxx<xd+dix THEN
vxxx=xd+dix
ENDIF
@rsc_put(trm2,vxxx,vy,1)            ! vorher geretteten Inhalt an alte Position zeichnen
xxx=cx+(x-vmx)
bbb=cb+1
xs=0
IF xxx+bbb>xmaxx THEN
bbb=xmaxx-xxx
ENDIF
IF xxx<(xd+dix) THEN
xs=(xd+dix)-xxx
bbb=(cb+1)-xs
xxx=xd+dix
ENDIF
trm2=@rsc_get2(xxx,y2,bbb,trhb+1,trm2)   ! Inhalt der neuen Position retten
@rsc_put2(trm1,xxx,y2,1,xs,bbb)                     ! Inhalt Kurve neuzeichnen
vx=x
vy=y2
vy2=y
ELSE
IF c<0 THEN
c=0
ENDIF
ENDIF
ENDIF
ENDIF
UNTIL k=0
'    @rsc_put(trm2,xxx,vy,1)   ! wegdamit
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
a=trkvor(atrkp)
b=trknext(atrkp)
c=trkch(atrkp)
IF a>0 THEN
trknext(a)=b
ENDIF
IF b>0 THEN
trkvor(b)=a
ENDIF
trknext(atrkp)=0
trkvor(atrkp)=0
trkch(atrkp)=vcyw+trkvz
t=0
tf=FALSE
REPEAT
INC t
UNTIL t=trkz OR (trkch(t)=(vcyw+trkvz) AND trkvor(t)=0 AND t<>atrkp)
IF (trkch(t)=(vcyw+trkvz) AND trkvor(t)=0 AND t<>atrkp) THEN
trkpnt(vcyw+trkvz)=t
tf=TRUE
ENDIF
IF tf=FALSE THEN
t=atrkp
trkpnt(vcyw+trkvz)=t
ENDIF
IF a=0 AND c<>(vcyw+trkvz) THEN
trkpnt(c)=b   ! neu
ENDIF
REPEAT
a=trktime(t)
IF a<=trktime(atrkp) THEN
vt=t
t=trknext(t)
ENDIF
UNTIL a>trktime(atrkp) OR t=0
IF t=0 THEN
IF vt<>atrkp THEN
trknext(vt)=atrkp
trkvor(atrkp)=vt
ENDIF
trknext(atrkp)=0
ELSE
a=trkvor(t)
trkvor(atrkp)=a
trknext(atrkp)=t
IF a>0 THEN
trknext(a)=atrkp
ENDIF
trkvor(t)=atrkp
ENDIF
IF trkvor(atrkp)=0 THEN
trkpnt(vcyw+trkvz)=atrkp    ! neu
ENDIF
IF v4=1 OR v4=2 THEN
IF v4=2 THEN
gs=trkvor(atrkp)
IF gs>0 THEN
gs=trktime(gs)+trkend(gs)-trkstrt(gs)
ENDIF
trktime(atrkp)=gs
ELSE
ge=trknext(atrkp)
IF ge>0 THEN
ge=trktime(ge)-(trkend(atrkp)-trkstrt(atrkp))
trktime(atrkp)=ge
ENDIF
ENDIF
REPEAT
UNTIL @mousek=0
ENDIF
@timeline2
~MFREE(trm2)
~MFREE(trm1)
@drawbutton(trakclip&)
ENDIF
RETURN
'
> PROCEDURE trakcopydrag
LOCAL k,x,v,v2,b,t,a,tf,cv,vx,vmx,xxx,vmy,y2,vy,cyw,xmaxx,c,c2
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
~GRAF_MKSTATE(x,v,k,v2)
IF (x>=cx AND x<=cx+cb AND v>=cy AND v<=cy+trhb) THEN
GRAPHMODE 1
~GRAF_MOUSE(256,0)                              ! Hidem
trm2=@rsc_get(cx,cy,cb+1,trhb+1)         ! leere Box
trm1=@rsc_get(cx,cy,cb+1,trhb+1)           ! trm1=Kurveninhalt
@rsc_put(trm2,cx,cy,1)
@mouse(x,v,k)
vmx=x
vx=x
xxx=cx
vmy=y
vcyw=trkch(atrkp)-trkvz
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
vy=y2
vy2=y
cv=trktime(atrkp)
tdragm=FALSE
REPEAT
@mouse(x,y,k)
IF x>xwidth-40 THEN
x=xwidth-40
ENDIF
cyw=trkch(atrkp)-trkvz+INT((y-vmy)/10)
IF cyw<1 THEN
cyw=1
ENDIF
IF cyw>4 THEN
cyw=4
ENDIF
xmaxx=xd+dig+dix
IF (x>=xd+dix AND x<=xmaxx) THEN
IF x<>vx OR cyw<>vcyw THEN
b=x-vmx
c=INT(cv+((thz/1000*tv/trxstp)*b))
c2=trktime(atrkp)
IF c>=0 THEN
IF c2<>c THEN
trktime(atrkp)=c
hsec=INT(trktime(atrkp)/thz*100)
@htimeset
@textfeld(trksmpte&,a$,1)
ENDIF
IF cyw<>vcyw THEN
vcyw=cyw
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
ENDIF
vxxx=cx+(vx-vmx)
IF vxxx<xd+dix THEN
vxxx=xd+dix
ENDIF
@rsc_put(trm2,vxxx,vy,1)            ! vorher geretteten Inhalt an alte Position zeichnen
xxx=cx+(x-vmx)
bbb=cb+1
xs=0
IF xxx+bbb>xmaxx THEN
bbb=xmaxx-xxx
ENDIF
IF xxx<(xd+dix) THEN
xs=(xd+dix)-xxx
bbb=(cb+1)-xs
xxx=xd+dix
ENDIF
trm2=@rsc_get2(xxx,y2,bbb,trhb+1,trm2)   ! Inhalt der neuen Position retten
@rsc_put2(trm1,xxx,y2,1,xs,bbb)                     ! Inhalt Kurve neuzeichnen
vx=x
vy=y2
vy2=y
ELSE
IF c<0 THEN
c=0
ENDIF
ENDIF
ENDIF
ENDIF
UNTIL k=0
'    @rsc_put(trm2,xxx,vy,1)   weg damit
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
@trakmove
IF notrkmov=FALSE THEN
trktime(otrkp)=cv
IF trkpnt(vcyw+trkvz)=0 AND trkvor(atrkp)=0 THEN
trkpnt(vcyw+trkvz)=atrkp
ENDIF
t=trkpnt(vcyw+trkvz)
ELSE
trktime(atrkp)=cv
ENDIF
IF notrkmov=FALSE THEN
REPEAT
a=trktime(t)
IF a<=trktime(atrkp) THEN
vt=t
t=trknext(t)
ENDIF
UNTIL a>trktime(atrkp) OR t=0
IF t=0 THEN
IF vt<>atrkp THEN
trknext(vt)=atrkp
trkvor(atrkp)=vt
ENDIF
trknext(atrkp)=0
ELSE
a=trkvor(t)
trkvor(atrkp)=a
trknext(atrkp)=t
IF a>0 THEN
trknext(a)=atrkp
ENDIF
trkvor(t)=atrkp
ENDIF
ENDIF
IF trkvor(atrkp)=0 THEN
trkpnt(vcyw+trkvz)=atrkp    ! neu
ENDIF
@timeline2
~MFREE(trm2)
~MFREE(trm1)
@drawbutton(trakclip&)
ENDIF
RETURN
'
> PROCEDURE trakdrag
LOCAL k,x,v,v2,b,t,a,tf,cv,vx,vmx,xxx,vmy,y2,vy,cyw,xmaxx,c,c2,tstat4,ddd,l
vtdrag=tdrag
IF tdrag2=TRUE THEN
cb=rcb
trhb=rtrhb
cx=rcx
cy=rcy
ENDIF
IF tdrag=FALSE AND trdrag=FALSE THEN
clipart=0
trkcart=0
ENDIF
ddd=0
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
~GRAF_MKSTATE(x,v,k,v4)
IF tdrag=FALSE THEN
tdrag2=FALSE
ENDIF
IF (x>=cx AND x<=cx+cb AND v>=cy AND v<=cy+trhb) OR tdrag2=TRUE THEN
trg2=@rsc_get(cx,cy,cb+1,trhb+1)         ! leere Box
GRAPHMODE 1
~GRAF_MOUSE(256,0)                              ! Hidem
IF tdrag2=FALSE THEN
IF tdbz1=0 THEN
trg1=@rsc_get(cx,cy,cb+1,trhb+1)           ! trg1=Kurveninhalt
trgb1=@rsc_get(cx,cy,cb+1,trhb+1)           ! trg1=Kurveninhalt
tdbz1=1
rcb=cb
rtrhb=trhb
rcx=cx
rcy=cy
ELSE
~MFREE(trg1)
trg1=@rsc_get(cx,cy,cb+1,trhb+1)           ! trg1=Kurveninhalt
ENDIF
ENDIF
trg2=@rsc_get2(cx,cy,cb+1,trhb+1,trg2)         ! leere Box
IF tdrag2=FALSE THEN
@rsc_put(trg2,cx,cy,1)
ENDIF
@mouse(x,v,k)
IF tdrag2=TRUE THEN
vmx=xd+dix+5
cx=vmx-5
ELSE
vmx=x
ENDIF
vx=x
xxx=cx
vmy=y
vcyw=trkch(atrkp)-trkvz
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
vy=y2
vy2=y
IF tdrag2=TRUE THEN
cv=(toffs2/1000*thz)
tcv2=trktime(atrkp)
ELSE
cv=trktime(atrkp)
ENDIF
tdragm=FALSE
REPEAT
@mouse(x,y,k)
IF x>xwidth-40 THEN
x=xwidth-40
ENDIF
IF tdrag2=TRUE THEN
cyw=1+INT((y-vmy)/10)
ELSE
cyw=trkch(atrkp)-trkvz+INT((y-vmy)/10)
ENDIF
IF tdrag2=TRUE THEN     ! drag2=TRUE bedeutet CLIP-Dragging
tstat4=FALSE           ! tstat4=FALSE bedeutet Rasterung
IF cyw<1 THEN
cyw=1
tstat4=TRUE
ENDIF
IF cyw>4 THEN
cyw=4
ENDIF
ELSE
tstat4=TRUE
ENDIF
xmaxx=xd+dig+dix
IF (x>=xd+dix AND x<=xmaxx) THEN
IF (x<>vx OR (cyw<>vcyw AND tstat4=FALSE) OR (y<>vy2 AND tstat4=TRUE)) THEN
b=x-vmx
c=INT(cv+((thz/1000*tv/trxstp)*b))
c2=trktime(atrkp)
IF c>=0 THEN
IF c2<>c AND tdrag2=TRUE THEN
trktime(atrkp)=c
hsec=INT(trktime(atrkp)/thz*100)
@htimeset
@textfeld(trksmpte&,a$,1)
ENDIF
IF cyw<>vcyw OR tstat4=TRUE THEN
vcyw=cyw
IF tstat4=TRUE THEN
vcyw=-1
y2=yd+y-vmy+32
IF y2<(yd-20) THEN
y2=yd-20
ENDIF
ELSE
y2=yd+(vcyw-1)*(trhb+trhd)+trhs
ENDIF
ENDIF
vxxx=cx+(vx-vmx)
IF vxxx<xd+dix THEN
vxxx=xd+dix
ENDIF
IF (ddd>0 AND tdrag2=TRUE) OR tdrag2=FALSE THEN
@rsc_put(trg2,vxxx,vy,1)            ! vorher geretteten Inhalt an alte Position zeichnen
ENDIF
IF tdrag2=TRUE THEN
ddd=1
ENDIF
xxx=cx+(x-vmx)
bbb=cb+1
xs=0
IF xxx+bbb>xmaxx THEN
bbb=xmaxx-xxx
ENDIF
IF xxx<(xd+dix) THEN
xs=(xd+dix)-xxx
bbb=(cb+1)-xs
xxx=xd+dix
ENDIF
trg2=@rsc_get2(xxx,y2,bbb,trhb+1,trg2)   ! Inhalt der neuen Position retten
@rsc_put2(trg1,xxx,y2,1,xs,bbb)                     ! Inhalt Kurve neuzeichnen
vx=x
vy=y2
vy2=y
ELSE
IF c<0 THEN
c=0
ENDIF
ENDIF
IF tstat4=TRUE AND tdrag2=FALSE THEN
fobj=OBJC_FIND(zu%,0,10,xxx,y2)
IF fobj=trakclip& THEN
@readbutton(trakclip&)
IF trkp<>0 THEN
IF clipart=0 AND buttflag=0 THEN
@setbutton(trakclip&,1)
ENDIF
IF clipart<>0 AND buttflag=1 AND tdragm=FALSE THEN
@setbutton(trakclip&,0)
PAUSE 2
@setbutton(trakclip&,1)
ENDIF
tdragm=TRUE
ENDIF
ENDIF
IF fobj<>trakclip& AND tdragm=TRUE THEN
tdragm=FALSE
@readbutton(trakclip&)
IF clipart=0 AND buttflag<>0 THEN
@setbutton(trakclip&,0)
ENDIF
IF clipart<>0 AND buttflag<>1 THEN
@setbutton(trakclip&,1)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
UNTIL k=0
'    @rsc_put(trg2,xxx,vy,1)    ! weg damit
GRAPHMODE 1
~GRAF_MOUSE(257,0)                              ! Showm
IF tstat4=TRUE AND tdrag2=FALSE THEN
trktime(atrkp)=cv
IF fobj=trakclip& AND tdragm=TRUE THEN
@setbutton(trakclip&,0)
FOR i=0 TO 2
PAUSE 2
@setbutton(trakclip&,0)
PAUSE 2
@setbutton(trakclip&,1)
NEXT i
merkclip=atrkp
clipart=2
trkcart=5
dvt=cx
ENDIF
IF tdragm=TRUE THEN
tdrag=TRUE
trdrag=FALSE
trdrag2=FALSE
ENDIF
ENDIF
IF tstat4=FALSE AND tdrag2=TRUE THEN
@trakmove
IF notrkmov=FALSE THEN
trktime(otrkp)=tcv2
IF trkpnt(vcyw+trkvz)=0 AND trkvor(atrkp)=0 THEN
trkpnt(vcyw+trkvz)=atrkp
ENDIF
t=trkpnt(vcyw+trkvz)
REPEAT
a=trktime(t)
IF a<=trktime(atrkp) THEN
vt=t
t=trknext(t)
ENDIF
UNTIL a>trktime(atrkp) OR t=0
IF t=0 THEN
IF vt<>atrkp THEN
trknext(vt)=atrkp
trkvor(atrkp)=vt
ENDIF
trknext(atrkp)=0
ELSE
a=trkvor(t)
trkvor(atrkp)=a
trknext(atrkp)=t
IF a>0 THEN
trknext(a)=atrkp
ENDIF
trkvor(t)=atrkp
ENDIF
IF trkvor(atrkp)=0 THEN
trkpnt(vcyw+trkvz)=atrkp    ! neu
ENDIF
ELSE
trktime(atrkp)=cv
ENDIF
ENDIF
IF tstat4=TRUE AND tdrag2=TRUE THEN
trktime(atrkp)=tcv2
ENDIF
@timeline2
@busy_mouse
IF tstat4=TRUE AND tdrag2=FALSE AND fobj=trakclip& AND tdragm=TRUE THEN
l=@rsc_len(cb+1,trhb+1)
IF tdbz1=1 THEN
~MFREE(trgb1)
trgb1=@rsc_get(cx,cy,cb+1,trhb+1)         ! richtige Box -> retten
rcb=cb
rtrhb=trhb
rcx=cx
rcy=cy
i2=trg1
FOR i=trgb1 TO trgb1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
ELSE
'      tdrag=TRUE
'      trdrag=FALSE
'      trdrag2=FALSE
cb=rcb
trhb=rtrhb
cx=rcx
cy=rcy
l=@rsc_len(cb+1,trhb+1)
IF tdbz1=1 THEN
~MFREE(trg1)
trg1=@rsc_get(cx,cy,cb+1,trhb+1)         ! falsche Box -> zurÅckholen
i2=trgb1
FOR i=trg1 TO trg1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
~MFREE(trg2)
@drawbutton(trakclip&)
ENDIF
RETURN
'
> PROCEDURE trakmove
notrkmov=FALSE
IF trkz<lmax3 THEN
otrkp=atrkp
@oldtrkbox
IF trkz>0 THEN
f=0
REPEAT
INC f
UNTIL f=trkz OR trkch(f)=0
IF trkch(f)=0 THEN
trkp=f
ELSE
INC trkz
trkp=trkz
ENDIF
ELSE
INC trkz
trkp=trkz
ENDIF
vtrkp=trkp
atrkp=trkp   ! aktuelles File
'
trkch(trkp)=vcyw+trkvz
trkfn$(trkp)=trkfn$(otrkp)
trkcom$(trkp)=""
trkpath$(trkp)=trkpath$(otrkp)
@searchcom(trkp)
trkstrt(trkp)=trkstrt(otrkp)
trkend(trkp)=trkend(otrkp)
trkhead(trkp)=trkhead(otrkp)
trkbits(trkp)=trkbits(otrkp)
trksrate(trkp)=trksrate(otrkp)
trktri(trkp)=trktri(otrkp)
trkloop(trkp)=trkloop(otrkp)
trklen(trkp)=trklen(otrkp)
trktime(trkp)=trktime(otrkp)
trkmem(trkp)=0
trkg(trkp)=0
tcach(trkp)=FALSE
'    @trkbutcalc2
'    @trkbutcalc1
'    @trkbutdraw
@opentrk
ELSE
@alerts(28)
notrkmov=TRUE
ENDIF
RETURN
'
> PROCEDURE trkend
.| Glob. Var.: trkp#,sectpos#,hsec#,flen#,vhz#,trakend&,a$
.| Felder    : trkend#()
.| Ruft auf  : htimeset,textfeld,setbutton,trkbutcalc1
.| Aufruf in : do_trakker-1,
LOCAL q,v4
@testcopyright
IF trkp>0 AND trkch(trkp)<>0 THEN
~GRAF_MKSTATE(v,v,v,v4)
IF v4=0 THEN
IF trkbits(trkp)=24 THEN
q=6
ELSE
q=4
ENDIF
trkend(trkp)=INT(sectpos/q)
hsec=INT(trkend(trkp)/thz*100)
@htimeset
@textfeld(trakend&,a$,1)
IF trkend(trkp)<trkstrt(trkp) THEN
trkstrt(trkp)=trkend(trkp)
@textfeld(trakstrt&,a$,1)
ENDIF
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz*100)
@htimeset
@textfeld(trakdur&,a$,1)
@setbutton(trakend&,0)
@trkbutcalc1
'  @textfeld(trkbut,butnam$,1)
'  @trkbutdraw
@timeline
ELSE
vornr=nr
nr=record&
a$="Track-End"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
mmax=trklen(trkp)/thz*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld2(nr,recfree&,a$,1)
m=trkend(trkp)
dt=INT(m/thz*100)
@rsc_draw(nr,0)
@markhlp
timekey=4
@timekey
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("TRACK-END")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
trkend(trkp)=INT(dt/100*thz)
hsec=INT(trkend(trkp)/thz*100)
@htimeset
@textfeld(trakend&,a$,1)
IF trkstrt(trkp)>trkend(trkp) THEN
trkstrt(trkp)=trkend(trkp)
@textfeld(trakstrt&,a$,1)
ENDIF
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz*100)
@htimeset
@textfeld(trakdur&,a$,1)
@setbutton(trakend&,0)
@trkbutcalc1
@timeline
ELSE
@setbutton(trakend&,0)
ENDIF
obj=0
ENDIF
ELSE
@setbutton(trakend&,0)
ENDIF
RETURN
'
> PROCEDURE trkanf
.| Glob. Var.: handle#,pa$,sectpos#,hsec#,flen#,vhz#,traktime&,a$,playpos#
.|     g#,trakanf&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_trakker-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=head
hsec=INT((sectpos-head)/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
playpos=sectpos
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=head
hsec=INT((sectpos-head)/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
IF handle<0 THEN
@alerts(34)
handle=0
ENDIF
@setbutton(trakanf&,0)
RETURN
'
> PROCEDURE trkfull
.| Glob. Var.: handle#,pa$,sectpos#,sectall#,hsec#,flen#,vhz#,traktime&,a$
.|     playpos#,g#,trakfull&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_trakker-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=sectall
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
playpos=sectpos
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=sectall
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
ENDIF
IF handle<0 THEN
@alerts(34)
handle=0
ENDIF
@setbutton(trakfull&,0)
RETURN
'
> PROCEDURE opentrk
atrkp=trkp   ! aktuelles File
@opentrk2
RETURN
'
> PROCEDURE opentrk2
.| Glob. Var.: t#,lmax3#,a#,toffs2#,j#,b#,trkp#,hardopen#,handle#,playstop#
.|     pat$,vhz#,pa$,f#,sectors#,flen#,sectall#,sectpos#,hsec#,trakstrt&,a$
.|     s#,trakend&,traklen&,trksmpte&,g#,g2#,traktime&,trakname&
.| Felder    : trkch#(),trkpnt#(),trknext#(),trkpath$(),trksrate#()
.|     trkstrt#(),trkend#(),trklen#(),trktime#(),trkfn$()
.| Ruft auf  : htimeset,textfeld
.| Aufruf in : trakload-1,trktowork-1,
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF trkpath$(trkp)<>"MEMORY" AND trkpath$(trkp)<>"" THEN
pat$=trkpath$(trkp)
tblkin$=pat$
'    vhz=trksrate(trkp)
'    hz=vhz
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pa$=pat$+CHR$(0)
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
a$=trkpath$(trkp)
IF LEN(a$)>51 THEN
a=RINSTR(a$,"\")
IF a>0 THEN
REPEAT
a=INSTR(a$,"\")
a$=right$(LEN(a$)-a+1)
UNTIL LEN(a$)<=48 OR a=0
a$=a$+"..."
ELSE
a$="..."+RIGHT$(a$,48)
ENDIF
ENDIF
a$=a$+CHR$(0)
@textfeld(trakinfo&,a$,1)
head=trkhead(trkp)
sectors=f-head
sectall=sectors
sectpos=mbit*trkstrt(trkp)+head
hsec=INT(trkstrt(trkp)/thz*100)
@htimeset
@textfeld(trakstrt&,a$,1)
s=trkend(trkp)
hsec=INT(s/thz*100)
@htimeset
@textfeld(trakend&,a$,1)
hsec=INT((trkend(trkp)-trkstrt(trkp))/thz*100)
@htimeset
@textfeld(trakdur&,a$,1)
s=trklen(trkp)
hsec=INT(s/thz*100)
@htimeset
@textfeld(traklen&,a$,1)
hsec=INT(trktime(trkp)/thz*100)
@htimeset
@textfeld(trksmpte&,a$,1)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=LEFT$(pat$+SPACE$(12),12)+CHR$(0)
hardopen=TRUE
hsec=INT(sectpos/thz/mbit*100)
@htimeset
@textfeld(traktime&,a$,1)
a$=LEFT$(trkfn$(trkp)+SPACE$(12),12)
@textfeld(trakname&,a$,1)
ENDIF
RETURN
'
> PROCEDURE arrsmpr
.| Glob. Var.: obj#,arrsmpr1&,arrsmpr2&,arrsmpr3&,arrsmpr4&,pbz#,mrkobj#
.|     vorvornr#,vornr#,nr#,resample&,zu%,versatz#,a$,string#,rsmptxt1&,it#
.|     rsmptxt2&,resorig#,db$,restxt&,resoth#,resother&,popup&,zuadr#,x#,y#
.|     v3#,buttadr#,but#,resl1&,resl2&,resl3&,resr1&,resr2&,resr3&,objadr#
.|     objflag#,res32&,res44&,res48&,helprsmp&,resok&,resexit&,noresok#,a#
.|     edit_obj&
.| Felder    : arrpath$(),arrsrate#()
.| Ruft auf  : xrsrc_gaddr,rsc_draw,editfeld,textfeld,rsc_do,mouse,setbutton
.|     resl,resr,resoth32,resoth44,resoth48,helptxt,editread,restaura2
.|     arrnrset
.| Aufruf in : do_arrange-1,
LOCAL i,j,myi
@testcopyright
IF obj=arrsmpr1& THEN
i=1
ENDIF
IF obj=arrsmpr2& THEN
i=2
ENDIF
IF obj=arrsmpr3& THEN
i=3
ENDIF
IF obj=arrsmpr4& THEN
i=4
ENDIF
myi=i
IF arrpath$(pbz+myi)<>"" THEN
mrkobj=obj
vorvornr=vornr
vornr=nr
'    @rsc_back(nr)
nr=resample&
~@xrsrc_gaddr(0,resample&,zu%)
zuadr=zu%
versatz=1
a$=" Samplerate "
string=LPEEK(LPEEK(zu%+24*rsmptxt1&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
@hidetree2(adjresmp&,TRUE)
@hidetree2(resmpsec&,TRUE)
@hidetree2(resmplen&,TRUE)
@hidetree2(resmpfac&,TRUE)
resorig=INT(arrsrate%(pbz+myi)/100)
db$=RIGHT$("000"+STR$(resorig),3)+CHR$(0)
@editfeld2(nr,restxt&,db$)
resoth=INT(arrsrate%(pbz+myi)/100)/10
db$=RIGHT$("000"+STR$(INT(resoth*10)),3)+CHR$(0)
@editfeld2(nr,resother&,db$)
@rsc_draw(nr,0)
edit_obj&=0
next_obj&=0
obj=0
obj&=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,obj,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1 AND obj<>restxt& AND obj<>resother&
IF obj<>resother& AND obj<>restxt& THEN
edit_obj&=0
ENDIF
~@xrsrc_gaddr(0,resample&,zu%)
buttadr=zu%+24*obj
but=(DPEEK(buttadr+6)) AND 255
IF but=22 THEN
IF obj=resmpsel& THEN
a$=@rsc_text$(popups&,smppopup&+popup&)
@textfeld(obj,a$,1)
IF popup&<>0 THEN
IF popup&=1 THEN
resoth=32
ENDIF
IF popup&=2 THEN
resoth=44.1
ENDIF
IF popup&=3 THEN
resoth=48
ENDIF
IF popup&=4 THEN
resoth=88.2
ENDIF
IF popup&=5 THEN
resoth=96
ENDIF
IF popup&=6 THEN
resoth=8
ENDIF
IF popup&=7 THEN
resoth=11
ENDIF
IF popup&=8 THEN
resoth=12
ENDIF
IF popup&=9 THEN
resoth=16
ENDIF
IF popup&=10 THEN
resoth=16.5
ENDIF
IF popup&=11 THEN
resoth=22.1
ENDIF
IF popup&=12 THEN
resoth=24
ENDIF
IF popup&=13 THEN
resoth=33.1
ENDIF
IF popup&=14 THEN
resoth=INT(masterclk/768/1000)
ENDIF
IF popup&=15 THEN
resoth=INT(masterclk/512/1000)
ENDIF
IF popup&=16 THEN
resoth=INT(masterclk/384/1000)
ENDIF
IF popup&=17 THEN
resoth=INT(masterclk/256/1000)
ENDIF
IF popup&=18 THEN
@addiv
a$=@rsc_text$(popups&,smppopup&+18)
@textfeld(resmpsel&,a$,1)
ENDIF
db$=RIGHT$("000"+STR$(INT(resoth*10)),3)+CHR$(0)
@editfeld(resother&,db$)
@resmptxt
obj=0
ENDIF
ENDIF
ENDIF
IF obj=resl1& OR obj=resl2& OR obj=resl3& OR obj=resr1& OR obj=resr2& OR obj=resr3& THEN
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=resl1& OR obj=resl2& OR obj=resl3& THEN
@resl
ENDIF
IF obj=resr1& OR obj=resr2& OR obj=resr3& THEN
@resr
ENDIF
IF obj=helprsmp& THEN
@helptxt("ARRANGE-SAMPLERATE")
ENDIF
UNTIL obj=resok& OR obj=resexit&
IF obj=resok& THEN
@editread(resother&)
noresok=FALSE
ENDIF
@setbutton(obj,0)
UNTIL (obj=resok& AND noresok=FALSE) OR obj=resexit&
IF obj=resok& AND noresok=FALSE THEN
resoth=VAL(a$)*100
arrsrate%(pbz+myi)=resoth
resoth=INT(resoth/100)/10
ENDIF
@hidetree2(adjresmp&,FALSE)
@hidetree2(resmpsec&,FALSE)
@hidetree2(resmplen&,FALSE)
@hidetree2(resmpfac&,FALSE)
@restaura2
~@xrsrc_gaddr(0,resample&,zu%)
a$="  Resample  "
string=LPEEK(LPEEK(zu%+24*rsmptxt1&+12))
FOR it=1 TO LEN(a$)
POKE string+it-1+(versatz-1),ASC(MID$(a$,it,1))
NEXT it
vornr=vorvornr
@setbutton(mrkobj,0)
@arrnrset
ELSE
@setbutton(obj,0)
ENDIF
obj=0
edit_obj&=0
i=myi
RETURN
'
> PROCEDURE arrstrt
.| Glob. Var.: handle#,pa$,sectpos#,hsec#,flen#,vhz#,playlen&,a$,playpos#,g#
.|     arrstrt&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_arrange-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=0
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
playpos=sectpos
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=0
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
IF handle<0 THEN
@alerts(34)
handle=0
ENDIF
@setbutton(arrstrt&,0)
RETURN
'
> PROCEDURE arrend
.| Glob. Var.: handle#,pa$,sectpos#,sectall#,hsec#,flen#,vhz#,playlen&,a$
.|     playpos#,g#,arrend&
.| Ruft auf  : htimeset,textfeld,setbutton
.| Aufruf in : do_arrange-1,
IF handle=0 THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
ENDIF
IF handle>=0 THEN
sectpos=sectall
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
playpos=sectpos
handle=GEMDOS(61,L:VARPTR(pa$),0)
sectpos=sectall
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
IF handle<0 THEN
@alerts(34)
handle=0
ENDIF
@setbutton(arrend&,0)
RETURN
'
> PROCEDURE arrblkset
IF hardopen=TRUE THEN
IF arrpath$(pbz+hardtype)<>"" THEN
pat$=arrpath$(pbz+hardtype)
IF EXIST(pat$)=TRUE THEN
tblkin$=pat$
a=RINSTR(tblkin$,".")
b$=LEFT$(tblkin$,a)+inf$
IF EXIST(b$) THEN
OPEN "I",#2,b$
@loadloops(TRUE)
CLOSE #2
@edmfind
IF edmfind=TRUE THEN
IF bloops%(edsms,1)<>-1 AND bloops%(edsms,2)<>-1 THEN
sectpos=bloops%(edsms,2)*mbit
@hardend
sectpos=bloops%(edsms,1)*mbit
@hardstrt
ENDIF
ENDIF
ELSE
@alerts(27)
@setbutton(obj,0)
ENDIF
ENDIF
ENDIF
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE arrtowork
.| Glob. Var.: spring#,obj#,arrm1&,hardtype#,arrherr#,pbz#,arrm2&,arrm3&
.|     arrm4&,hardopen#,handle#,playstop#,pat$,vhz#,arrz#,pa$,f#,sectors#
.|     flen#,sectall#,sectpos#,g#,g2#,hsec#,playlen&,a$,playname&
.| Felder    : arrpath$(),arrsrate#(),arrstrt#(),arrfn$()
.| Ruft auf  : dragging1,htimeset,textfeld
.| Aufruf in : do_arrange-1,dragging2-1,
IF obj=arrm1& THEN
hardtype=1
arrherr=pbz+1
ENDIF
IF obj=arrm2& THEN
hardtype=2
arrherr=pbz+2
ENDIF
IF obj=arrm3& THEN
hardtype=3
arrherr=pbz+3
ENDIF
IF obj=arrm4& THEN
hardtype=4
arrherr=pbz+4
ENDIF
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
IF arrpath$(pbz+hardtype)<>"" THEN
pat$=arrpath$(pbz+hardtype)
IF EXIST(pat$)=TRUE THEN
vhz=hz
arrz=hardtype
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
pa$=pat$+CHR$(0)
OPEN "I",#1,pat$
f=LOF(#1)
CLOSE #1
sectors=f
sectall=sectors
sectpos=arrstrt%(pbz+hardtype)
REPEAT
g=INSTR(pat$,"\")
IF g>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g))
ENDIF
g2=INSTR(pat$,":")
IF g2>0 THEN
pat$=RIGHT$(pat$,(LEN(pat$)-g2))
ENDIF
UNTIL g=0 AND g2=0
pat$=LEFT$(pat$+SPACE$(12),12)+CHR$(0)
hardopen=TRUE
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
a$=LEFT$(arrfn$(pbz+hardtype)+SPACE$(12),12)
@textfeld(playname&,a$,1)
ENDIF
ENDIF
IF spring=FALSE THEN
@arrdragin
ENDIF
RETURN
'
> PROCEDURE arrtristate
.| Glob. Var.: obj#,arrtri1&,z#,arrtri2&,arrtri3&,arrtri4&,tri#,pbz#,nr#
.|     realtime#
.| Felder    : arrtri#()
.| Ruft auf  : rsc_tristate,mousek,arrnrset
.| Aufruf in : do_arrange-1,
IF obj=arrtri1& THEN
z=1
ENDIF
IF obj=arrtri2& THEN
z=2
ENDIF
IF obj=arrtri3& THEN
z=3
ENDIF
IF obj=arrtri4& THEN
z=4
ENDIF
tri=arrtri|(pbz+z)
@rsc_tristate(nr,obj)
REPEAT
UNTIL @mousek=0
arrtri|(pbz+z)=tri
RETURN
'
> PROCEDURE arrmidi
.| Glob. Var.: mrkch#,ch#,mrknote#,note#,obj#,arrnote1&,arrch1&,arrmz#
.|     arrnote2&,arrch2&,arrnote3&,arrch3&,arrnote4&,arrch4&,z#,pbz#,ch$
.|     midiwort#,db$
.| Felder    : arrmidi#()
.| Ruft auf  : midi,textfeld
.| Aufruf in : do_arrange-1,
mrkch=ch
mrknote=note
IF obj=arrnote1& OR obj=arrch1& THEN
arrmz=1
ENDIF
IF obj=arrnote2& OR obj=arrch2& THEN
arrmz=2
ENDIF
IF obj=arrnote3& OR obj=arrch3& THEN
arrmz=3
ENDIF
IF obj=arrnote4& OR obj=arrch4& THEN
arrmz=4
ENDIF
z=arrmidi&(pbz+arrmz)
note=(z AND 255)
ch=INT(z/256)+1
@midi
ch$=RIGHT$(" "+STR$(ch),2)+CHR$(0)
arrmidi&(pbz+arrmz)=midiwort
IF arrmz=1 THEN
@textfeld(arrch1&,ch$,1)
@textfeld(arrnote1&,db$,1)
ENDIF
IF arrmz=2 THEN
@textfeld(arrch2&,ch$,1)
@textfeld(arrnote2&,db$,1)
ENDIF
IF arrmz=3 THEN
@textfeld(arrch3&,ch$,1)
@textfeld(arrnote3&,db$,1)
ENDIF
IF arrmz=4 THEN
@textfeld(arrch4&,ch$,1)
@textfeld(arrnote4&,db$,1)
ENDIF
ch=mrkch
note=mrknote
RETURN
'
> PROCEDURE arrmidplay
.| Glob. Var.: a#,meml#,b#,memh#,sret#,c#,adm#,ad#,arrmidi&
.| Ruft auf  : wait,analog,maschruf18b,digin,digital,setbutton
.| Aufruf in : do_arrange-1,
@wait
a=meml
b=memh
IF sret=1 THEN
c=a
a=b-mbit
b=c
ENDIF
adm=ad
IF adm=0 THEN
@analog
ENDIF
IF (sret=0 OR sret=2) AND a<b THEN
@maschruf18b
@digin
ENDIF
IF sret=1 AND a>b THEN
@maschruf18b
@digin
ENDIF
IF adm=0 THEN
@digital
ENDIF
@setbutton(arrmidi&,0)
RETURN
'
> PROCEDURE arrdel
.| Glob. Var.: obj#,arrdel1&,arrdel2&,arrdel3&,arrdel4&,pbz#,a$,a2$,a3$,a4$
.|     tri#,arrsmpr1&,arrch1&,arrnote1&,arrtri1&,arrmem1&,spur1&,hardst1&
.|     harde1&,hardlen1&,arrloop1&,nr#,arrsmpr2&,arrch2&,arrnote2&,arrtri2&
.|     arrmem2&,spur2&,hardst2&,harde2&,hardlen2&,arrloop2&,arrsmpr3&
.|     arrch3&,arrnote3&,arrtri3&,arrmem3&,spur3&,hardst3&,harde3&,hardlen3&
.|     arrloop3&,arrsmpr4&,arrch4&,arrnote4&,arrtri4&,arrmem4&,spur4&
.|     hardst4&,harde4&,hardlen4&,arrloop4&,realtime#
.| Felder    : arrfn$(),arrpath$(),arrstrt#(),arrend#(),arrlen#(),arrloop#()
.|     arrtri#(),arrsrate#()
.| Ruft auf  : textfeld,setbutton,rsc_tristate2,arrnrset
.| Aufruf in : do_arrange-1,
LOCAL z,i
IF obj=arrdel1& THEN
z=1
ENDIF
IF obj=arrdel2& THEN
z=2
ENDIF
IF obj=arrdel3& THEN
z=3
ENDIF
IF obj=arrdel4& THEN
z=4
ENDIF
IF arrherr=pbz+z THEN
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
sectors=0
sectpos=0
sectall=0
ENDIF
ENDIF
arrfn$(pbz+z)=""
arrpath$(pbz+z)=""
arrstrt%(pbz+z)=0
arrend%(pbz+z)=0
arrlen%(pbz+z)=0
arrloop!(pbz+z)=FALSE
arrtri|(pbz+z)=0
arrsrate%(pbz+z)=0
arrbits!(pbz+z)=FALSE
arrhead(pbz+z)=0
IF arrherr=pbz+z THEN
arrherr=0
ENDIF
hsec=0
@htimeset
a2$=a$
a$="            "+CHR$(0)
a3$=" "+CHR$(0)
a4$=SPACE$(4)+CHR$(0)
tri=0
IF z=1 THEN
@textfeld(arrsmpr1&,a4$,1)
@setbutton(arrch1&,0)
@setbutton(arrnote1&,0)
@setbutton(arrtri1&,0)
@textfeld(arrmem1&,a3$,1)
@textfeld(spur1&," "+a$,1)
@textfeld(hardst1&,a2$,1)
@textfeld(harde1&,a2$,1)
@textfeld(hardlen1&,a2$,1)
@setbutton(arrloop1&,0)
@rsc_tristate2(nr,arrtri1&)
ENDIF
IF z=2 THEN
@textfeld(arrsmpr2&,a4$,1)
@setbutton(arrch2&,0)
@setbutton(arrnote2&,0)
@setbutton(arrtri2&,0)
@textfeld(arrmem2&,a3$,1)
@textfeld(spur2&," "+a$,1)
@textfeld(hardst2&,a2$,1)
@textfeld(harde2&,a2$,1)
@textfeld(hardlen2&,a2$,1)
@setbutton(arrloop2&,0)
@rsc_tristate2(nr,arrtri2&)
ENDIF
IF z=3 THEN
@textfeld(arrsmpr3&,a4$,1)
@setbutton(arrch3&,0)
@setbutton(arrnote3&,0)
@setbutton(arrtri3&,0)
@textfeld(arrmem3&,a3$,1)
@textfeld(spur3&," "+a$,1)
@textfeld(hardst3&,a2$,1)
@textfeld(harde3&,a2$,1)
@textfeld(hardlen3&,a2$,1)
@setbutton(arrloop3&,0)
@rsc_tristate2(nr,arrtri3&)
ENDIF
IF z=4 THEN
@textfeld(arrsmpr4&,a4$,1)
@setbutton(arrch4&,0)
@setbutton(arrnote4&,0)
@setbutton(arrtri4&,0)
@textfeld(arrmem4&,a3$,1)
@textfeld(spur4&," "+a$,1)
@textfeld(hardst4&,a2$,1)
@textfeld(harde4&,a2$,1)
@textfeld(hardlen4&,a2$,1)
@setbutton(arrloop4&,0)
@rsc_tristate2(nr,arrtri4&)
ENDIF
i=arrherr-pbz
IF i>0 AND i<5 AND arrherr<>0 THEN
SELECT i
CASE 1
@setbutton(arrm1&,1)
CASE 2
@setbutton(arrm2&,1)
CASE 3
@setbutton(arrm3&,1)
CASE 4
@setbutton(arrm4&,1)
ENDSELECT
ENDIF
@setbutton(obj,0)
IF adrag=TRUE AND arrcwert>0 AND arrcwert<=lmax2 THEN
IF arrpath$(arrcwert)="" THEN
adrag=FALSE
@setbutton(arrclip&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE arrinsdrt
.| Glob. Var.: arrherr#,lmax2#,arrins&
.| Felder    : arrpath$(),arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#()
.| Ruft auf  : busy_mouse,arrnrset,hardwahl,setbutton
.| Aufruf in : do_arrange-1,
LOCAL s,i,a1,a2,g
IF arrherr<>0 THEN
s=arrherr
a1=0
a2=0
IF s<lmax2 THEN
i=lmax2+1
@busy_mouse
REPEAT
DEC i
UNTIL arrpath$(i)<>"" OR i=s
IF arrpath$(i)<>"" THEN
a2=i
ENDIF
IF a2=0 THEN
@alerts(35)
ENDIF
IF a2=lmax2 THEN
@alerts(36)
ENDIF
IF a2<>0 AND a2<>lmax2 THEN
i=s-1
REPEAT
INC i
UNTIL arrpath$(i)<>"" OR i=lmax2
IF arrpath$(i)<>"" THEN
a1=i
ENDIF
FOR i=a2 TO a1 STEP -1
arrpath$(i+1)=arrpath$(i)
arrfn$(i+1)=arrfn$(i)
arrstrt%(i+1)=arrstrt%(i)
arrend%(i+1)=arrend%(i)
arrlen%(i+1)=arrlen%(i)
arrmidi&(i+1)=arrmidi&(i)
arrloop!(i+1)=arrloop!(i)
arrbits!(i+1)=arrbits!(i)
arrhead(i+1)=arrhead(i)
arrtri|(i+1)=arrtri|(i)
arrsrate%(i+1)=arrsrate%(i)
NEXT i
arrpath$(a1)=""
arrfn$(a1)=""
arrstrt%(a1)=0
arrend%(a1)=0
arrlen%(a1)=0
arrmidi&(a1)=0
arrloop!(a1)=FALSE
arrbits!(a1)=FALSE
arrhead(a1)=0
arrtri|(a1)=0
arrsrate%(a1)=0
@arrnrset
ENDIF
ENDIF
ELSE
@hardwahl
ENDIF
@setbutton(arrins&,0)
IF adrag=TRUE AND arrcwert>0 AND arrcwert<=lmax2 THEN
IF arrpath$(arrcwert)="" THEN
adrag=FALSE
@setbutton(arrclip&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE arrdelete
.| Glob. Var.: arrherr#,lmax2#,arrdel&
.| Felder    : arrpath$(),arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#()
.| Ruft auf  : busy_mouse,arrnrset,hardwahl,setbutton
.| Aufruf in : do_arrange-1,
LOCAL s,i,a1,a2
IF arrherr<>0 THEN
s=arrherr
a1=0
a2=0
arrpath$(s)=""
arrfn$(s)=""
arrstrt%(s)=0
arrend%(s)=0
arrlen%(s)=0
arrmidi&(s)=0
arrloop!(s)=FALSE
arrbits!(s)=FALSE
arrhead(s)=0
arrtri|(s)=0
arrsrate%(s)=0
IF s<lmax2 THEN
i=s
@busy_mouse
REPEAT
INC i
UNTIL arrpath$(i)<>"" OR i=lmax2
IF arrpath$(i)<>"" THEN
a1=i
ENDIF
IF a1<>0 THEN
i=lmax2+1
REPEAT
DEC i
UNTIL arrpath$(i)<>"" OR i=1
IF arrpath$(i)<>"" THEN
a2=i
ENDIF
FOR i=a1 TO a2
arrpath$(i-1)=arrpath$(i)
arrfn$(i-1)=arrfn$(i)
arrstrt%(i-1)=arrstrt%(i)
arrend%(i-1)=arrend%(i)
arrlen%(i-1)=arrlen%(i)
arrmidi&(i-1)=arrmidi&(i)
arrloop!(i-1)=arrloop!(i)
arrbits!(i-1)=arrbits!(i)
arrhead(i-1)=arrhead(i)
arrtri|(i-1)=arrtri|(i)
arrsrate%(i-1)=arrsrate%(i)
NEXT i
arrpath$(a2)=""
arrfn$(a2)=""
arrstrt%(a2)=0
arrend%(a2)=0
arrlen%(a2)=0
arrmidi&(a2)=0
arrloop!(a2)=FALSE
arrbits!(a2)=FALSE
arrhead(a2)=0
arrtri|(a2)=0
arrsrate%(a2)=0
ENDIF
ENDIF
@arrnrset
ELSE
@hardwahl
ENDIF
@setbutton(arrdel&,0)
IF adrag=TRUE AND arrcwert>0 AND arrcwert<=lmax2 THEN
IF arrpath$(arrcwert)="" THEN
adrag=FALSE
@setbutton(arrclip&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE hardwahl
.| Aufruf in : arrinsert-1,arrdelete-1,arrdelay-1,
LOCAL g
@alerts(38)
RETURN
'
> PROCEDURE trktext
LOCAL to,a
@testcopyright
IF obj=trktxt1& THEN
to=1
ENDIF
IF obj=trktxt2& THEN
to=2
ENDIF
IF obj=trktxt3& THEN
to=3
ENDIF
IF obj=trktxt4& THEN
to=4
ENDIF
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=trknamin&
a$=trktxt$(trkvz+to)+CHR$(0)
IF LEN(a$)>6 THEN
a$=LEFT$(a$,5)+CHR$(0)
ENDIF
@editfeld2(nr,trktxtin&,a$)
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>trktxtin&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=trktxhlp& THEN
@helptxt("TRACK-NAME")
ENDIF
UNTIL obj=trktxex& OR obj=trktxok&
IF obj=trktxok& THEN
editread(trktxtin&)
a=INSTR(a$,CHR$(0))
IF a>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
trktxt$(trkvz+to)=a$
ENDIF
@setbutton(obj,0)
@restaura2
IF obj=trktxok& THEN
a$=trktxt$(trkvz+to)+CHR$(0)
@textfeld(mrkobj,a$,1)
ENDIF
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE arrmname
.| Glob. Var.: mrkobj#,obj#,vorvornr#,vornr#,nr#,arrmname&,pbz#,hardtype#,a$
.|     mp$,a#,memname&,popup&,zu%,zuadr#,x#,y#,v3#,edit_obj&,buttadr#,but#
.|     objadr#,objflag#,amhelp&,amexit&,amok&,spur1&,spur2&,spur3&,spur4&
.| Felder    : arrfn$()
.| Ruft auf  : rsc_draw,markhlp,editfeld,rsc_do,xrsrc_gaddr,mouse,helptxt
.|     editread,setbutton,restaura2,textfeld
.| Aufruf in : trakload-1,hardfs-1,
@testcopyright
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=arrmname&
a$=arrfn$(pbz+hardtype)+CHR$(0)
IF LEN(a$)>12 THEN
a$=LEFT$(a$,12)
ENDIF
@editfeld2(nr,memname&,a$)
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1 AND obj<>memname&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=amhelp& THEN
@helptxt("ARRANGE-NAME")
ENDIF
UNTIL obj=amexit& OR obj=amok&
IF obj=amok& THEN
editread(memname&)
arrfn$(pbz+hardtype)=a$
ENDIF
@setbutton(obj,0)
@restaura2
IF obj=amok& THEN
a$=LEFT$(arrfn$(pbz+hardtype)+"            ",12)+CHR$(0)
IF hardtype=1 THEN
@textfeld(spur1&," "+a$,1)
ENDIF
IF hardtype=2 THEN
@textfeld(spur2&," "+a$,1)
ENDIF
IF hardtype=3 THEN
@textfeld(spur3&," "+a$,1)
ENDIF
IF hardtype=4 THEN
@textfeld(spur4&," "+a$,1)
ENDIF
ENDIF
obj=mrkobj
vornr=vorvornr
RETURN
'
> PROCEDURE arrloop
.| Glob. Var.: obj#,arrloop1&,z#,arrloop2&,arrloop3&,arrloop4&,pbz#
.| Felder    : arrloop#()
.| Aufruf in : do_arrange-1,
IF obj=arrloop1& THEN
z=1
ENDIF
IF obj=arrloop2& THEN
z=2
ENDIF
IF obj=arrloop3& THEN
z=3
ENDIF
IF obj=arrloop4& THEN
z=4
ENDIF
IF arrloop!(pbz+z)=FALSE THEN
arrloop!(pbz+z)=TRUE
ELSE
arrloop!(pbz+z)=FALSE
ENDIF
RETURN
'
> PROCEDURE wait
.| Aufruf in : trkplay-1,arrmidplay-1,arrplay-1,smpplay-1,smpauto-2
.|     smpstart-1,
LOCAL v,v2,v3,v4
REPEAT
~WIND_UPDATE(3)
~GRAF_MKSTATE(v,v2,v3,v4)
~WIND_UPDATE(2)
REPEAT
IF INP?(2)=TRUE THEN
~INP(2)
ENDIF
IF INP?(3)=TRUE THEN
~INP(3)
ENDIF
IF INP?(1)=TRUE THEN
~INP(1)
ENDIF
UNTIL INP?(2)=FALSE AND INP?(1)=FALSE AND INP?(3)=FALSE
UNTIL v3=0 AND v4=0
RETURN
'
> PROCEDURE swtosrate(swhz)
.| Glob. Var.: extclock#
.| Ruft auf  : adlow,admid,adhigh
.| Aufruf in : maschruf18b-3,arrsethz-1,do_arrange-1,do_trakker-1
.|     traksethz-1,trakforw-2,trkbackw-2,trkplay-3,arrplay-3,mforw-2
.|     mbackw-2,make-1,
LOCAL holdhz
holdhz=hz
hz=swhz
@fliphz
@fliphz2
hz=holdhz
RETURN
'
> PROCEDURE hardstrt
.| Glob. Var.: pbz#,arrz#,sectpos#,realtime#,hsec#,flen#,vhz#,hardtype#
.|     hardopen#,hardst1&,a$,hardst2&,hardst3&,hardst4&,hardstrt&
.| Felder    : arrstrt#()
.| Ruft auf  : htimeset,textfeld,arrnrset,setbutton
.| Aufruf in : do_arrange-1,
LOCAL z
z=arrherr-pbz
arrstrt%(arrherr)=sectpos
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a2$=a$
IF realtime=FALSE THEN
hsec=INT(arrlen%(arrherr)/vhz/mbit*100)
ELSE
hsec=INT((arrend%(arrherr)-arrstrt%(arrherr))/vhz/mbit*100)
IF hsec<0 THEN
hsec=0
ENDIF
ENDIF
@htimeset
IF z=1 AND hardopen=TRUE THEN
@textfeld(hardst1&,a2$,1)
@textfeld(hardlen1&,a$,1)
ENDIF
IF z=2 AND hardopen=TRUE THEN
@textfeld(hardst2&,a2$,1)
@textfeld(hardlen2&,a$,1)
ENDIF
IF z=3 AND hardopen=TRUE THEN
@textfeld(hardst3&,a2$,1)
@textfeld(hardlen3&,a$,1)
ENDIF
IF z=4 AND hardopen=TRUE THEN
@textfeld(hardst4&,a2$,1)
@textfeld(hardlen4&,a$,1)
ENDIF
@setbutton(hardstrt&,0)
RETURN
'
> PROCEDURE hardend
.| Glob. Var.: pbz#,arrz#,sectpos#,realtime#,hsec#,flen#,vhz#,hardtype#
.|     hardopen#,harde1&,a$,harde2&,harde3&,harde4&,hardend&
.| Felder    : arrend#()
.| Ruft auf  : htimeset,textfeld,arrnrset,setbutton
.| Aufruf in : do_arrange-1,
LOCAL z
z=arrherr-pbz
arrend%(arrherr)=sectpos
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
a2$=a$
IF realtime=FALSE THEN
hsec=INT(arrlen%(arrherr)/vhz/mbit*100)
ELSE
hsec=INT((arrend%(arrherr)-arrstrt%(arrherr))/vhz/mbit*100)
IF hsec<0 THEN
hsec=0
ENDIF
ENDIF
@htimeset
IF z=1 AND hardopen=TRUE THEN
@textfeld(harde1&,a2$,1)
@textfeld(hardlen1&,a$,1)
ENDIF
IF z=2 AND hardopen=TRUE THEN
@textfeld(harde2&,a2$,1)
@textfeld(hardlen2&,a$,1)
ENDIF
IF z=3 AND hardopen=TRUE THEN
@textfeld(harde3&,a2$,1)
@textfeld(hardlen3&,a$,1)
ENDIF
IF z=4 AND hardopen=TRUE THEN
@textfeld(harde4&,a2$,1)
@textfeld(hardlen4&,a$,1)
ENDIF
@setbutton(hardend&,0)
RETURN
'
> PROCEDURE rectoarr
IF sectors<>rmlen THEN
FOR i=1 TO lmax2
EXIT IF arrpath$(i)=""
NEXT i
IF arrpath$(i)="" THEN
pbz=INT(i/4)*4
hardtype=i-pbz
arrherr=pbz+hardtype
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
@setslide(arrslide&,arrslbut&,slmax,5,pbz)
@arrnrset
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
@hardfs2
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE hardfs
.| Glob. Var.: obj#,hardfs1&,hardtype#,hardfs2&,hardfs3&,hardfs4&,pbz#,a$
.|     playlen&,arrherr#,hardopen#,handle#,playstop#,op$,ext$,fil$,nr#
.|     sectors#,f#,flen#,sectall#,sectpos#,hsec#,vhz#,mz$,a4$,spur1&,nam$
.|     hardlen1&,arrmem1&,arrsmpr1&,spur2&,hardlen2&,arrmem2&,arrsmpr2&
.|     spur3&,hardlen3&,arrmem3&,arrsmpr3&,spur4&,hardlen4&,arrmem4&
.|     arrsmpr4&,arrz#,pat$,pa$,playname&
.| Felder    : arrpath$(),arrfn$(),arrlen#(),arrsrate#()
.| Ruft auf  : textfeld,fileselect,rsc_redraw_obj,busy_mouse,ldhead,htimeset
.|     arrnrset,arrmname,setbutton
.| Aufruf in : do_arrange-1,
IF obj=spur1& THEN
hardtype=1
ENDIF
IF obj=spur2& THEN
hardtype=2
ENDIF
IF obj=spur3& THEN
hardtype=3
ENDIF
IF obj=spur4& THEN
hardtype=4
ENDIF
IF arrpath$(pbz+hardtype)="" THEN
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
IF obj=spur1& THEN
arrherr=pbz+1
ENDIF
IF obj=spur2& THEN
arrherr=pbz+2
ENDIF
IF obj=spur3& THEN
arrherr=pbz+3
ENDIF
IF obj=spur4& THEN
arrherr=pbz+4
ENDIF
IF hardopen=TRUE THEN
~GEMDOS(62,handle)
playstop=1
handle=0
hardopen=FALSE
ENDIF
@fileselect(op$+"*."+ext$,"","ARRANGE-FILE:")
@hardfs2
ELSE
@arrmname
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE hardfs2
IF EXIST(fil$) THEN
@busy_mouse
@ldhead
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
sectors=f
sectall=sectors
sectpos=0
hardopen=TRUE
IF realtime=FALSE THEN
hsec=INT(sectall/vhz/mbit*100)
ELSE
hsec=0
ENDIF
@htimeset
mz$="H"+CHR$(0)
a4$=LEFT$(STR$(INT(vhz/100)/10)+SPACE$(4),4)+CHR$(0)
IF obj=spur1& THEN
@textfeld(spur1&," "+nam$+CHR$(0),1)
@textfeld(hardlen1&,a$,1)
@textfeld(arrmem1&,mz$,1)
@textfeld(arrsmpr1&,a4$,1)
ENDIF
IF obj=spur2& THEN
@textfeld(spur2&," "+nam$+CHR$(0),1)
@textfeld(hardlen2&,a$,1)
@textfeld(arrmem2&,mz$,1)
@textfeld(arrsmpr2&,a4$,1)
ENDIF
IF obj=spur3& THEN
@textfeld(spur3&," "+nam$+CHR$(0),1)
@textfeld(hardlen3&,a$,1)
@textfeld(arrmem3&,mz$,1)
@textfeld(arrsmpr3&,a4$,1)
ENDIF
IF obj=spur4& THEN
@textfeld(spur4&," "+nam$+CHR$(0),1)
@textfeld(hardlen4&,a$,1)
@textfeld(arrmem4&,mz$,1)
@textfeld(arrsmpr4&,a4$,1)
ENDIF
arrz=hardtype
pat$=fil$
pa$=pat$+CHR$(0)
arrbits!(pbz+arrz)=dig24
arrhead(pbz+arrz)=head
arrpath$(pbz+arrz)=fil$+CHR$(0)
arrfn$(pbz+arrz)=nam$
arrlen%(pbz+arrz)=sectall-head
arrsrate%(pbz+arrz)=vhz
a$=LEFT$(nam$+SPACE$(12),12)
@textfeld(playname&,a$,1)
@arrnrset
z=arrz
ENDIF
RETURN
'
> PROCEDURE virtleft
@slideup2(vslider&,vslbut&,lslide,1,hbz,slflg)
IF slflg=TRUE THEN
vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
@blkart
ENDIF
RETURN
'
> PROCEDURE virtright
@slidedwn2(vslider&,vslbut&,lslide,hbreit,1,hbz,slflg)
IF slflg=TRUE THEN
vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
@blkart
ENDIF
RETURN
'
> PROCEDURE virtplay
@blkproof
@blockcalc
a$=fil$+CHR$(0)
handle=GEMDOS(61,L:VARPTR(a$),0)
IF handle>0 THEN
playpos=vhbldstrt+head
sectors=hbldlen
over=0
@digout(TRUE)
l=0
vvhz=hz
hz=vhz
@makehz
@maschrufb5
@digout(FALSE)
~GEMDOS(62,handle)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
hz=vvhz
@makehz
ENDIF
@setbutton(virtplay&,0)
RETURN
'
> PROCEDURE virtual
.| Glob. Var.: vornr#,nr#,virtual&,vslider&,vslbut&,lslide#,lslideo#,hbg#
.|     hbz#,a$,mt#,vblkmlen&,smplen#,vblkvlen&,vhbldstrt#,tedart#,vseconds&
.|     vsamples&,virtwfile#,virtwork&,virtdir&,obj#,popup&,zu%,zuadr#
.|     vblkstrt&,edit_obj&,next_obj&,buttadr#,but#,objadr#,objflag#,x#,y#
.|     v3#,virthelp&,vlslide&,slflg#,vrslide&,vtedart#,notedok#,virtplay&
.|     handle#,fil$,playpos#,sectors#,hbldlen#,flen#,over#,l#,virtbloc&
.|     virtno&,virtok&,virtex#,blockld#,virtual#
.| Ruft auf  : slidelen,slideinit,rsc_draw,setslide,blockcalc,textfeld
.|     blkart,setbutton,rsc_do,xrsrc_gaddr,mouse,helptxt,slideup,slidedwn
.|     blkproof,maschinit5,digout,maschruf5,restaura2
.| Aufruf in : ldhlp-1,
LOCAL vvhz
@testcopyright
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF ldtrk=FALSE THEN
vvtedart=tedart
vornr=nr
nr=virtual&
@slidelen(vslider&,vslbut&,v,lslide)
hbreit=(lslide/smplen*mt)            ! Einteilungsanzahl
hbz=0
@slideinit2(vslider&,vslbut&,hbreit)
@editmask2(nr,vblkstrt&,"9999999999"+CHR$(0),"_.___.___.___"+CHR$(0))
@editfeld2(nr,vblkstrt&,"0000000000"+CHR$(0))
@blockcalc
a$=STR$(INT(mt/mbit))
@formatsmp
a$="MEM "+RIGHT$(SPACE$(13)+a$,13)
@textfeld2(nr,vblkmlen&,a$,1)
a$=STR$(INT(smplen/mbit))
@formatsmp
a$="LEN "+RIGHT$(SPACE$(13)+a$,13)
@textfeld2(nr,vblkvlen&,a$,1)
'
vshading=shading
shading=TRUE
dopix=TRUE
@setslide2(vslider&,vslbut&,lslide,hbz,hbreit)
vhbldstrt=0
tedart=1
@blkart
IF tedart=0 THEN
@setbutton(vseconds&,1)
@setbutton(vsamples&,0)
ELSE
@setbutton(vsamples&,1)
@setbutton(vseconds&,0)
ENDIF
IF virtwfile=TRUE THEN
@setbutton(virtwork&,1)
@setbutton(virtdir&,0)
ELSE
@setbutton(virtwork&,0)
@setbutton(virtdir&,1)
ENDIF
shading=vshading
dopix=FALSE
@wischwasch
@rsc_draw(nr,0)
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,obj,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>vblkstrt&
edit_obj&=0
next_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=virthelp& THEN
@helptxt("VIRTUAL")
ENDIF
IF obj=virtwork& THEN
virtwfile=TRUE
ENDIF
IF obj=virtdir& THEN
virtwfile=FALSE
ENDIF
IF obj=vlslide& THEN
@virtleft
@setbutton(vlslide&,0)
ENDIF
IF obj=vrslide& THEN
@virtright
@setbutton(vrslide&,0)
ENDIF
IF obj=vsamples& THEN
vtedart=1
IF vtedart<>tedart THEN
a$=STR$(INT(mt/mbit))
@formatsmp
a$="MEM "+RIGHT$(SPACE$(13)+a$,13)
@textfeld(vblkmlen&,a$,1)
a$=STR$(INT(smplen/mbit))
@formatsmp
a$="LEN "+RIGHT$(SPACE$(13)+a$,13)
@textfeld(vblkvlen&,a$,1)
@editmask(vblkstrt&,virtbox3&,"9999999999"+CHR$(0),"_.___.___.___"+CHR$(0))
@blkproof
IF notedok=FALSE THEN
tedart=vtedart
@blkart
ELSE
@setbutton(vseconds&,1)
@setbutton(vsamples&,0)
ENDIF
ENDIF
ENDIF
IF obj=vseconds& THEN
vtedart=0
IF vtedart<>tedart THEN
hsec=INT(mt/mbit/hz*100)
@htimeset2
a$="MEM "+RIGHT$(SPACE$(13)+a$,13)
@textfeld(vblkmlen&,a$,1)
hsec=INT(smplen/mbit/hz*100)
@htimeset2
a$="LEN "+RIGHT$(SPACE$(13)+a$,13)
@textfeld(vblkvlen&,a$,1)
@editmask(vblkstrt&,virtbox3&,"99999999"+CHR$(0),"__:__:__ __"+CHR$(0))
@blkproof
IF notedok=FALSE THEN
tedart=vtedart
@blkart
ELSE
@setbutton(vseconds&,0)
@setbutton(vsamples&,1)
ENDIF
ENDIF
ENDIF
IF obj=virtplay& THEN
@virtplay
ENDIF
IF obj=virtstop& THEN
@setbutton(virtstop&,0)
ENDIF
UNTIL obj=virtbloc& OR obj=virtno& OR obj=virtok&
virtex=FALSE
IF obj=virtbloc& THEN
blockld=FALSE
@blkproof
@blockcalc
mt=hbldlen
ELSE
blockld=FALSE
ENDIF
IF obj=virtok& THEN
virtual=TRUE
ELSE
virtual=FALSE
ENDIF
IF obj=virtno& THEN
virtex=TRUE
ENDIF
PAUSE 3
@setbutton(obj,0)
@restaura2
@wischwasch
tedart=vvtedart
ELSE
virtual=TRUE
ENDIF
obj=0
RETURN
'
> PROCEDURE blkart
.| Glob. Var.: tedart#,u#,vhbldstrt#,hz#,a$,vblkstrt&
.| Ruft auf  : editfeld
.| Aufruf in : button-2,virtual-5,
LOCAL u,i
IF tedart=0 THEN
hsec=INT(vhbldstrt/mbit/hz*100)
@htimeset2
u=LEN(a$)
b$=a$
a$=""
FOR i=1 TO u
IF MID$(b$,i,1)<>":" AND MID$(b$,i,1)<>" " THEN
a$=a$+MID$(b$,i,1)
ENDIF
NEXT i
ELSE
u=INT(vhbldstrt/mbit)
a$=RIGHT$("0000000000"+STR$(u),10)+CHR$(0)
ENDIF
@editfeld(vblkstrt&,a$)
RETURN
'
> PROCEDURE blkproof
.| Glob. Var.: vblkstrt&,notedok#,a$,i#,a#,vhbldstrt#,tedart#,hz#,smplen#,g#
.|     blockld#
.| Ruft auf  : editread
.| Aufruf in : virtual-4,
@editread(vblkstrt&)
notedok=FALSE
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF (a<48 OR a>57) AND a<>46 THEN
notedok=TRUE
ENDIF
IF (i=1 OR i=8) AND a=46 THEN
notedok=TRUE
ENDIF
NEXT i
ELSE
notedok=TRUE
ENDIF
IF notedok=FALSE THEN
IF tedart=0 THEN
IF LEN(a$)=8 THEN
tiwert=VAL(LEFT$(a$,2))*360000+VAL(MID$(a$,3,2))*6000+VAL(MID$(a$,5,2))*100+VAL(MID$(a$,7,2))
ENDIF
IF LEN(a$)=8 AND tiwert<(24*60*60*100) THEN
vhbldstrt=tiwert/100*hz*mbit
ELSE
notedok=TRUE
ENDIF
ELSE
vhbldstrt=VAL(a$)
vhbldstrt=vhbldstrt*mbit
ENDIF
vhbldstrt=INT(vhbldstrt/mbit)*mbit
IF vhbldstrt<0 OR vhbldstrt>smplen OR notedok=TRUE THEN
notedok=TRUE
@alerts(39)
ENDIF
ENDIF
IF notedok=FALSE THEN
blockld=TRUE
ENDIF
RETURN
'
> PROCEDURE blockcalc
.| Glob. Var.: hbldlen#,mt#,vhbldstrt#,smplen#,hbg#,hbz#
.| Aufruf in : virtual-3,
hbldlen=INT(mt/mbit)*mbit
IF vhbldstrt=0 THEN
vhbldstrt=INT((smplen/lslide*hbz)/mbit)*mbit
ENDIF
IF vhbldstrt+hbldlen>smplen THEN
hbldlen=smplen-vhbldstrt
ENDIF
RETURN
'
> PROCEDURE hardproof
.| Glob. Var.: fil$
.| Ruft auf  : rettmem,hardproof2
.| Aufruf in : ldhlp-1,
IF EXIST(fil$)=TRUE THEN
@rettmem
@hardproof2
ENDIF
RETURN
'
> PROCEDURE makepbuf
LOCAL glen,s1,s2,z,i,j,a,am,ia,ib,adr
IF cs=0 THEN
s1=peakmem%
ELSE
IF vmem>0 THEN
s1=INT(peakmem%+(pbuf/(vmem/cs)))
ENDIF
s1=INT(s1/mbit)*mbit
ENDIF
IF ce=vmem THEN
s2=peakmem%+pbuf
ELSE
IF vmem>0 THEN
s2=INT(peakmem%+(pbuf/(vmem/ce)))
ENDIF
s2=INT(s2/mbit)*mbit
ENDIF
stp=(s2-s1)/xm
IF stp=0 THEN
stp=8
ENDIF
z=INT((s2-s1)/stp+stp)
pbufda=TRUE
IF cwerte1>0 THEN
~MFREE(cwert)
cwert=0
ENDIF
cwerte1=@malloc((z+xm)*16,1)
IF cwerte1>0 THEN
cwert=cwerte1
cwertep1=INT((cwerte1+2)/2)*2
cwertep2=cwerte1+((z+xm)*4)
cwertem1=cwerte1+((z+xm)*8)
cwertem2=cwerte1+((z+xm)*12)
werte=INT((s2-s1)/stp)
z=0
IF werte>0 THEN
glen=werte*stp
IF cs=0 THEN
i=peakmem%
ELSE
i=s1
ENDIF
FOR j=1 TO werte
ia=INT(i/8)*8           !neu
ib=INT((i+stp)/8)*8     !neu
adr=XBIOS(xbs,301,L:ia,L:ib)
@busy_mouse
INC z
a=DPEEK(adr+4)
am=DPEEK(adr+6)
LPOKE (cwertep1+z*4),a
LPOKE (cwertem1+z*4),am
a=DPEEK(adr)
am=DPEEK(adr+2)
LPOKE (cwertep2+z*4),a
LPOKE (cwertem2+z*4),am
i=i+stp
NEXT j
maxcwert=z
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE hardproof2
.| Glob. Var.: fil$,virtpath$,virtln#,stp#,mlen#,xm#,cwerte1#,cwert#
.|     cwertep1#,cwertep2#,cwertem1#,cwertem2#,i#,meml#,werte#,a#,am#
.|     maxcwert#,g#,virtual#,virtcurve#
.| Ruft auf  : busy_mouse,maschinit31,maschruf31,trash
.| Aufruf in : hardproof-1,memtovirt-1,memtovirt2-1,
LOCAL j,z,hl,glen,dh
pbufda=FALSE
IF EXIST(fil$)=TRUE THEN
'
virtpath$=fil$
s=RINSTR(fil$,".")
a$=LEFT$(fil$,s)+peak$+CHR$(0)
IF EXIST(a$)=TRUE THEN
OPEN "I",#2,a$
pbuf=LOF(#2)
CLOSE #2
nopeakmem=FALSE
IF peakmemda=TRUE THEN
~MFREE(peakmem%)
ENDIF
peakmem%=@malloc(pbuf,1)     ! Peak-Buffer
IF peakmem%<=0 THEN
nopeakmem=TRUE
ELSE
peakmemda=TRUE
ENDIF
IF mlen>=pbuf AND nopeakmem=FALSE AND pbuf>0 THEN
pbm$=a$
BLOAD pbm$,peakmem%
@makepbuf
ENDIF
ELSE
nomem=FALSE
@makepbf
IF nomem=FALSE THEN
@makepbuf
ENDIF
ENDIF
'
IF pbufda=FALSE THEN
@busy_mouse
virtpath$=fil$
OPEN "I",#1,fil$
virtln=LOF(#1)
hl=virtln-2
stp=(INT(mlen/xm))
stp=(INT((stp+1)/mbit)*mbit)
z=INT(hl/stp+stp)
IF cwert>0 THEN
~MFREE(cwert)
cwert=0
ENDIF
cwerte1=@malloc((z+xm)*16,1)
IF cwerte1>0 THEN
cwert=cwerte1
cwertep1=INT((cwerte1+2)/2)*2
cwertep2=cwerte1+((z+xm)*4)
cwertem1=cwerte1+((z+xm)*8)
cwertem2=cwerte1+((z+xm)*12)
z=0
REPEAT
i=meml
IF hl<=mlen
glen=hl
ELSE
glen=mlen
ENDIF
werte=INT(glen/stp)
IF werte>0 THEN
glen=werte*stp
hl=hl-glen
BGET #1,meml,glen
FOR j=1 TO werte
@maschruf31
@busy_mouse
INC z
LPOKE (cwertep1+z*4),a
LPOKE (cwertem1+z*4),am
i=i+2
@maschruf31
LPOKE (cwertep2+z*4),a
LPOKE (cwertem2+z*4),am
i=i-2
i=i+stp
NEXT j
ENDIF
UNTIL hl<stp
CLOSE #1
maxcwert=z
ELSE
virtual=FALSE
virtcurve=FALSE
@trash
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE hardproof3
.| Glob. Var.: fil$,virtln#
.| Aufruf in : fade_it-1,smpcut-2,virtmove-1,virtcopy-1,virtins-1,mono-1
.|     negate-1,lrchange-1,makenorm-1,makeresmp-1,
OPEN "I",#1,fil$
virtln=LOF(#1)
CLOSE #1
RETURN
'
> PROCEDURE wischwasch
LOCAL xevnt&,key&,xflags&,xtim&,mx&,my&,mb&,shift&,c
IF rscda=TRUE THEN
IF rsc_handle%(nr)<1000                             ! Fenster Dialog ?
xflags&=&X110000                                      ! ...zus. MESSAGE-Events
xtim&=4   ! EVENT-TIMER in msec
REPEAT
xevnt&=EVNT_MULTI(xflags&,2,1,1,0,0,0,0,0,0,0,0,0,0,0,xtim&,mx&,my&,mb&,shift&,key&,c)
IF BTST(xevnt&,4) THEN
@message
ENDIF
UNTIL BTST(xevnt&,4)=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE meldung_on(m$)
@testcopyright
@wischwasch
meldnr=nr
nr=meldung&
cupdate=TRUE
@textfeld2(meldung&,meldtxt&,m$,1)
cupdate=FALSE
@rsc_draw(nr,5)
RETURN
'
> PROCEDURE meldung_off
@rsc_back(nr)
nr=meldnr
@wischwasch
RETURN
'
> PROCEDURE rettmem
.| Glob. Var.: profhz#,hz#,smpnam$,path$,lfw$,a#,virt2$,sector#,vsmpnam$
.|     vpath$,vsmplen#,vhz#,vsblock#,vsloop#,vmamidi#,vsms#,vsme#,vmaster#
.|     vper#,vmrkdatum$,vretime#,vordner$,vorcs#,vorce#,vlz#,vzoomp#
.|     vscrollp#,i#,loopz#,bloopz#,vlmin#,vlma#,vmbs#,virt$,mlen#,meml#
.| Felder    : vloops#(),vloope#(),vbloops#(),vbloope#(),mblocks#()
.|     mblocke#(),mblockp$()
.| Ruft auf  : busy_mouse,nomem
.| Aufruf in : smpkhlp-1,smpmhlp-5,smpihlp-1,hardproof-1,arrload-1
.|     coninsert-1,
IF ldtrk=FALSE THEN
@busy_mouse
IF profhz=0 AND hz<>0 THEN
profhz=hz
ENDIF
IF profhz=0 THEN
profhz=44100
ENDIF
IF smpnam$="" THEN
IF dig24=FALSE THEN
smpnam$="MEMORY.S16"
ELSE
smpnam$="MEMORY.S24"
ENDIF
ENDIF
IF path$="" THEN
path$=lfw$+smpnam$
ENDIF
a=ASC(LEFT$(virt2$,1))-64
@makehz
vhz=hz
IF virt2$=virtm2$ THEN
@alerts(41)
ELSE
@alerts(40)
IF g=1 THEN
virtm2$=virt2$
ENDIF
ENDIF
IF g=1 THEN
IF @dfree(a)>sector THEN
rettfound=TRUE
@alerts2(1)
@meldung_on(m$)
OPEN "O",#4,virt2$
PRINT #4,vsmpnam$
PRINT #4,vpath$
PRINT #4,vsmplen
PRINT #4,vhz
PRINT #4,vsblock
PRINT #4,vsloop!
PRINT #4,vmamidi
PRINT #4,vsms
PRINT #4,vsms2
PRINT #4,vper
PRINT #4,vmrkdatum$
PRINT #4,vretime
PRINT #4,vordner$
PRINT #4,vorcs
PRINT #4,vorce
PRINT #4,vlz
PRINT #4,vzoomp
PRINT #4,vscrollp
FOR i=1 TO loopz
PRINT #4,vloops%(i,1)
NEXT i
FOR i=1 TO loopz
PRINT #4,vloops%(i,2)
NEXT i
FOR i=1 TO bloopz
PRINT #4,vbloops%(i,1)
PRINT #4,vbloops%(i,2)
NEXT i
PRINT #4,vlmin
PRINT #4,vlma
PRINT #4,vmbs
IF vmbs>0 THEN
FOR i=1 TO vmbs
PRINT #4,mblocks(i)
PRINT #4,mblocke(i)
PRINT #4,mblockp$(i)
NEXT i
ENDIF
CLOSE #4
a=ASC(LEFT$(virt$,1))-64
IF @dfree(a)>=mlen THEN
BSAVE virt$,meml,mlen
ELSE
@nomem
rettfound=FALSE
ENDIF
@meldung_off
ELSE
@nomem
rettfound=FALSE
ENDIF
ELSE
rettfound=FALSE
ENDIF
ENDIF
RETURN
'
> PROCEDURE getmem
.| Glob. Var.: virt2$,smpnam$,path$,smplen#,hz#,sblock#,sloop#,mamidi#,sms#
.|     sme#,master#,per#,mrkdatum$,retime#,ordner$,cs#,ce#,lz#,zoomp#
.|     scrollp#,i#,loopz#,bloopz#,vlmin#,vlma#,mbs#,zomslide&,zoombutt&
.|     zmax#,scrlslde&,scrolbut&,scmax#,virt$,meml#,cached#
.| Felder    : loops#(),loope#(),bloops#(),bloope#(),mblocks#(),mblocke#()
.|     mblockp$()
.| Ruft auf  : zslidecalc,scrollinit,setslide
.| Aufruf in : trash-2,
LOCAL a
IF EXIST(virt2$)=TRUE AND rettfound=TRUE THEN
@alerts2(2)
@meldung_on(m$)
OPEN "I",#8,virt2$
INPUT #8,smpnam$
INPUT #8,path$
INPUT #8,smplen
INPUT #8,hz
INPUT #8,sblock
INPUT #8,sloop!
INPUT #8,mamidi
INPUT #8,sms
INPUT #8,sms2
INPUT #8,per
INPUT #8,mrkdatum$
INPUT #8,retime
INPUT #8,ordner$
INPUT #8,cs
INPUT #8,ce
INPUT #8,lz
INPUT #8,zoomp
INPUT #8,scrollp
FOR i=1 TO loopz
INPUT #8,loops%(i,1)
NEXT i
FOR i=1 TO loopz
INPUT #8,loops%(i,2)
NEXT i
FOR i=1 TO bloopz
INPUT #8,bloops%(i,1)
INPUT #8,bloops%(i,2)
NEXT i
INPUT #8,vlmin
INPUT #8,vlma
INPUT #8,mbs
IF mbs>0 THEN
FOR i=1 TO mbs
INPUT #8,mblocks(i)
INPUT #8,mblocke(i)
INPUT #8,mblockp$(i)
NEXT i
ENDIF
CLOSE #8
'    KILL virt2$
IF EXIST(virt$)=TRUE THEN
OPEN "I",#8,virt$
a=LOF(#8)
BGET #8,meml,a
CLOSE #8
'      KILL virt$
cached=FALSE
ENDIF
@meldung_off
IF trkmemr=FALSE THEN
@zslidecalc
@scrollinit
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
ENDIF
ENDIF
IF pbufda=TRUE THEN
pbufda=FALSE
ENDIF
RETURN
'
> PROCEDURE arrclentrys
FOR i=1 TO lmax2
arrfn$(i)=""
arrpath$(i)=""
arrstrt%(i)=0
arrend%(i)=0
arrlen%(i)=0
arrsrate%(i)=0
arrloop!(i)=FALSE
arrbits!(i)=FALSE
arrhead(i)=0
arrtri|(i)=0
NEXT i
RETURN
'
> PROCEDURE arrload
.| Glob. Var.: arrup$,lfw$,fil$,pret#,pbutt#,rett#,lmax2#,smpnam$,path$
.|     smplen#,hz#,sblock#,sloop#,sms#,sme#,master#,loopz#,mbs#,mlen#,meml#
.|     cached#,pbz#,arrz#,a$,playlen&,arrload&,obj#
.| Felder    : arrfn$(),arrpath$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#(),loops#(),loope#(),mblocks#()
.|     mblocke#(),mblockp$()
.| Ruft auf  : fileselect,rettmem,busy_mouse,textfeld,arrnrset,setbutton
.| Aufruf in : do_arrange-1,
LOCAL i,a,b,p$,g,arrv$,arrv
g=RINSTR(arrup$,"\")
@fileselect(lfw$+"*."+RIGHT$(arrup$,3),RIGHT$(arrup$,LEN(arrup$)-g),"ARRANGE-LOAD:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
IF EXIST(fil$) THEN
rett=TRUE
@busy_mouse
@arrclentrys
OPEN "I",#5,fil$
INPUT #5,arrv$          ! Versionskontrolle
IF MID$(arrv$,LEN(arrv$)-3,1)="V" THEN
arrv=VAL(RIGHT$(arrv$,3))
ELSE
arrv=0
ENDIF
IF arrv>=2 THEN
REPEAT
EXIT IF EOF(#5)
INPUT #5,a$
@changelowkey2
IF INSTR(a$,"max_entrys")<>0 THEN
@delsourcekey
lmax2=VAL(a$)
ENDIF
IF INSTR(a$,"main_samplerate")<>0 THEN
@delsourcekey
arrhz=VAL(a$)
vhz=arrhz
hz=arrhz
@swtosrate(vhz)
ENDIF
IF INSTR(a$,"name")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-4)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax2>=b THEN
arrfn$(b)=a$
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"path")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-4)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax2>=b THEN
arrpath$(b)=a$
IF LEN(a$)>0 THEN
arrpath$(b)=arrpath$(b)+CHR$(0)
ENDIF
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"start")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-5)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax2>=b THEN
arrstrt%(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"end")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-3)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax2>=b THEN
arrend%(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"length")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-6)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax2>=b THEN
arrlen%(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"samplerate")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-10)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax2>=b THEN
arrsrate%(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"midi_channel")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-12)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax2>=b THEN
arrmidi&(b)=(arrmidi&(b) AND &HFF)+(VAL(a$)-1)*256
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"midi_note")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-9)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax2>=b THEN
IF LEN(a$)<3 THEN
a$=LEFT$(a$,1)+" "+RIGHT$(a$,1)
ENDIF
arrmidi&(b)=(arrmidi&(b) AND &HFF00)+@midivalue(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"loop")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-4)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
IF lmax2>=b THEN
arrloop!(b)=@getbinaer(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"direction")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-9)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax2>=b THEN
IF a$="forward" OR a$="0" THEN
a=0
ENDIF
IF a$="backward" OR a$="1" THEN
a=1
ENDIF
IF a$="cross" OR a$="2" THEN
a=2
ENDIF
arrtri|(b)=a
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"header_len")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-10)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF lmax2>=b THEN
arrhead(b)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"bitdepth")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-8)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF VAL(a$)=24 THEN
a=TRUE
ELSE
a=FALSE
ENDIF
IF lmax2>=b THEN
arrbits!(b)=a
ENDIF
ENDIF
ENDIF
UNTIL EOF(#5)
ENDIF
CLOSE #5
FOR i=1 TO lmax2
IF arrpath$(i)<>"" THEN
IF arrbits!(i)=TRUE THEN
a=6
ELSE
a=4
ENDIF
arrstrt%(i)=arrstrt%(i)*a
arrend%(i)=arrend%(i)*a
arrlen%(i)=arrlen%(i)*a
ENDIF
NEXT i
arrz=0
a$="XX:XX:XX XX"+CHR$(0)
@textfeld(playlen&,a$,1)
@arrnrset
adrag=FALSE
@setbutton(arrclip&,0)
ENDIF
ENDIF
@setbutton(arrload&,0)
obj=0
RETURN
'
> PROCEDURE arrsteil
.| Glob. Var.: i#,lmax2#,smpnam$,path$,smplen#,profhz#,sblock#,sloop#,sms#
.|     sme#,master#,loopz#,mbs#
.| Felder    : arrfn$(),arrpath$(),arrstrt#(),arrend#(),arrlen#(),arrmidi#()
.|     arrloop#(),arrtri#(),arrsrate#(),loops#(),loope#(),mblocks#()
.|     mblocke#(),mblockp$()
.| Aufruf in : arrsave-1,makeaback-1,
LOCAL a,a$
PRINT #5,"STARTRACK-MIDI V2.0"           ! Versionskontrolle
PRINT #5
PRINT #5,"max_entrys="+STR$(lmax2)
PRINT #5,"main_samplerate="+STR$(vhz)
FOR i=1 TO lmax2
IF arrpath$(i)<>"" THEN
PRINT #5
PRINT #5,"name"+STR$(i)+"="+arrfn$(i)
a$=arrpath$(i)
a=INSTR(a$,CHR$(0))
IF a<>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
IF arrbits!(i)=TRUE THEN
a=6
ELSE
a=4
ENDIF
PRINT #5,"path"+STR$(i)+"="+a$
PRINT #5,"start"+STR$(i)+"="+STR$(INT(arrstrt%(i)/a))
PRINT #5,"end"+STR$(i)+"="+STR$(INT(arrend%(i)/a))
PRINT #5,"length"+STR$(i)+"="+STR$(INT(arrlen%(i)/a))
IF arrbits!(i)=TRUE THEN
a=24
ELSE
a=16
ENDIF
PRINT #5,"bitdepth"+STR$(i)+"="+STR$(a)
PRINT #5,"header_len"+STR$(i)+"="+STR$(arrhead(i))
PRINT #5,"samplerate"+STR$(i)+"="+STR$(arrsrate%(i))
a=arrmidi&(i)
b=INT(a/256)
a=a-b*256
@midinote(a)
db$=LEFT$(db$,LEN(db$)-1)
IF INSTR(db$," ")<>0 THEN
db$=LEFT$(db$,1)+RIGHT$(db$,1)
ENDIF
PRINT #5,"midi_channel"+STR$(i)+"="+STR$(b+1)
PRINT #5,"midi_note"+STR$(i)+"="+db$
@makebinaer(arrloop!(i))
PRINT #5,"loop"+STR$(i)+"="+a$
SELECT arrtri|(i)
CASE 0
a$="forward"
CASE 1
a$="backward"
CASE 2
a$="cross"
ENDSELECT
PRINT #5,"direction"+STR$(i)+"="+a$
ENDIF
NEXT i
RETURN
'
> PROCEDURE arrsave
.| Glob. Var.: virtual#,mbs#,arrup$,lfw$,fil$,pret#,pbutt#,a#,sector#
.|     arrsave&
.| Ruft auf  : busy_mouse,fileselect,arrsteil,nomem,setbutton
.| Aufruf in : do_arrange-1,
LOCAL p$,g,g2
@busy_mouse
IF virtual=TRUE THEN
mbs=0
ENDIF
g=RINSTR(arrup$,"\")
@fileselect(lfw$+"*."+RIGHT$(arrup$,3),RIGHT$(arrup$,LEN(arrup$)-g),"ARRANGE-SAVE:")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+RIGHT$(arrup$,4)
ELSE
IF RIGHT$(fil$,4)<>RIGHT$(arrup$,4) THEN
fil$=LEFT$(fil$,g2)+RIGHT$(arrup$,3)
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>=sector THEN
OPEN "O",#5,fil$
@arrsteil
CLOSE #5
ELSE
@nomem
ENDIF
ENDIF
@setbutton(arrsave&,0)
RETURN
'
> PROCEDURE recplay
.| Glob. Var.: recplay&
.| Ruft auf  : setbutton
.| Aufruf in : do_arrange-1,
@setbutton(recplay&,0)
RETURN
'
> PROCEDURE mstop
.| Glob. Var.: handle#,playstop#,hardopen#,a$,playname&,stop&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : do_arrange-1,
~GEMDOS(62,handle)
IF XBIOS(xbs,1)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
intplay=FALSE
ELSE
playstop=1
@mstop2
ENDIF
REPEAT
UNTIL @mousek=0
PAUSE 3
@digout(FALSE)
@setbutton(stop&,0)
RETURN
'
> PROCEDURE mstop2
handle=0
hardopen=FALSE
a$=SPACE$(12)
@textfeld(playname&,a$,1)
IF XBIOS(xbs,1)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
@digout(FALSE)
intplay=FALSE
ENDIF
RETURN
'
> PROCEDURE mforw
.| Glob. Var.: pbz#,arrz#,pa$,playstop#,hardopen#,handle#,vhz#,sectall#
.|     sectpos#,sectors#,l#,playpos#,flen#,back%,hsec#,playlen&,a$,nr#
.| Felder    : arrpath$()
.| Ruft auf  : arrsethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_arrange-2,
mstop=0
IF arrpath$(pbz+arrz)<>"" AND pa$<>"" THEN
IF arrbits!(pbz+z)=TRUE THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
@arrsethz
IF playstop=2 AND hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
IF sectall>sectpos THEN
sectors=sectall-sectpos
l=0
playpos=sectpos+arrhead(pbz+z)
IF over<>0 THEN
oldplay=TRUE
ENDIF
adder=over
@maschrufb5
IF over<>0 THEN
oldplay=FALSE
ENDIF
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(playlen&,a$,1)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
sectors=sectall-sectpos
l=0
playpos=sectpos+arrhead(pbz+z)
IF over<>0 THEN
oldplay=TRUE
ENDIF
adder=over
@maschrufb5
IF over<>0 THEN
oldplay=FALSE
ENDIF
IF sectpos<sectall THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos>sectall THEN
sectpos=sectall
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
IF vhz>0 THEN
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
@textfeld(playlen&,a$,1)
ENDIF
ENDIF
DEFMOUSE 0
@digout(FALSE)
RETURN
'
> PROCEDURE mbackw
.| Glob. Var.: pbz#,arrz#,pa$,playstop#,hardopen#,vhz#,sectpos#,sectors#,l#
.|     playpos#,flen#,back%,handle#,sectall#,hsec#,playlen&,a$,nr#
.| Felder    : arrpath$()
.| Ruft auf  : arrsethz,maschinit5,digout,swtosrate,maschruf5,htimeset
.|     textfeld,rsc_redraw_obj
.| Aufruf in : do_arrange-2,
mstop=0
adder=over
'  IF over<>-mbit*2 THEN
oldplay=TRUE
' ENDIF
IF arrpath$(pbz+arrz)<>"" AND pa$<>"" THEN
IF arrbits!(pbz+z)=TRUE THEN
@setbitrate24
ELSE
@setbitrate16
ENDIF
@arrsethz
IF playstop=2 AND hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
@digout(TRUE)
@swtosrate(vhz)
IF sectpos>0 THEN
sectors=sectpos
l=0
playpos=sectpos+arrhead(pbz+z)
@maschrufb5
IF sectpos>0 THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
ENDIF
IF playstop=0 OR playstop=1 THEN
IF hardopen=TRUE THEN
handle=GEMDOS(61,L:VARPTR(pa$),0)
IF sectpos=0 THEN
sectpos=sectall
ENDIF
playpos=sectpos+arrhead(pbz+z)
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(playlen&,a$,1)
IF handle>0 THEN
@digout(TRUE)
@swtosrate(vhz)
sectors=sectpos
l=0
playpos=sectpos+arrhead(pbz+z)
@maschrufb5
IF sectpos>0 THEN
sectpos=sectpos+back%    ! Wichtig !!!
ENDIF
IF sectpos<0 THEN
sectpos=0
ENDIF
IF XBIOS(xbs,1)<>&H71273800 OR oldplay=TRUE THEN
@digout(FALSE)
ENDIF
playstop=2
ENDIF
ELSE
@rsc_redraw_obj(nr,0)
ENDIF
ENDIF
hsec=INT(sectpos/vhz/mbit*100)
@htimeset
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(playlen&,a$,1)
ENDIF
IF over<>-mbit*2 THEN
oldplay=FALSE
ENDIF
DEFMOUSE 0
@digout(FALSE)
RETURN
'
> PROCEDURE htimeset       ! Zeitausgabe in h,m,s,frames (digits)
LOCAL a,b,h$
'
hsec=hsec/100*framez
'
hh=INT(hsec/framez/60/60)
hrest=hsec-(hh*framez*60*60)
hm=INT(hrest/framez/60)
hrest=hrest-(hm*framez*60)
hs=INT(hrest/framez)
hms=INT(hrest-(hs*framez))
IF hms>=framez THEN
hms=framez-1
ENDIF
IF hh<10 THEN
a$=CHR$(16)+CHR$(hh+16)+":"
ELSE
h$=STR$(hh)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=CHR$(a)+CHR$(b)+":"
ENDIF
IF hm<10 THEN
a$=a$+CHR$(16)+CHR$(hm+16)+":"
ELSE
h$=STR$(hm)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=a$+CHR$(a)+CHR$(b)+":"
ENDIF
IF hs<10 THEN
a$=a$+CHR$(16)+CHR$(hs+16)+" "
ELSE
h$=STR$(hs)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=a$+CHR$(a)+CHR$(b)+" "
ENDIF
IF hms<10 THEN
a$=a$+CHR$(16)+CHR$(hms+16)+CHR$(0)
ELSE
h$=STR$(hms)
a=ASC(LEFT$(h$,1))-32
b=ASC(RIGHT$(h$,1))-32
a$=a$+CHR$(a)+CHR$(b)+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE htimeset2      ! Zeitausgabe in h,m,s,frames (normal)
.| Glob. Var.: hh#,hsec#,hrest#,hm#,hs#,hms#,a$
.| Aufruf in : maschruf2-1,maschruf3-2,maschruf3b-2,maschruf5-1
.|     maschruf5c-1,maschruf8b-2,arrnrset-9,trakload-1,trakforw-2
.|     trkbackw-2,trkstrt-1,trkend-1,trkanf-2,trkfull-2,trkplay-13
.|     opentrk-5,arrstrt-2,arrend-2,arrtowork-1,arrplay-13,hardstrt-1
.|     hardend-1,hardfs-1,mforw-2,mbackw-2,
'
hsec=hsec/100*framez
'
hh=INT(hsec/framez/60/60)
hrest=hsec-(hh*framez*60*60)
hm=INT(hrest/framez/60)
hrest=hrest-(hm*framez*60)
hs=INT(hrest/framez)
hms=INT(hrest-(hs*framez))
IF hms>=framez THEN
hms=framez-1
ENDIF
IF hh<10 THEN
a$="0"+STR$(hh)+":"
ab$="0"+STR$(hh)
ELSE
a$=STR$(hh)+":"
ab$=STR$(hh)
ENDIF
IF hm<10 THEN
a$=a$+"0"+STR$(hm)+":"
ab$=ab$+"0"+STR$(hm)
ELSE
a$=a$+STR$(hm)+":"
ab$=ab$+STR$(hm)
ENDIF
IF hs<10 THEN
a$=a$+"0"+STR$(hs)+" "
ab$=ab$+"0"+STR$(hs)
ELSE
a$=a$+STR$(hs)+" "
ab$=ab$+STR$(hs)
ENDIF
IF hms<10 THEN
a$=a$+"0"+STR$(hms)+CHR$(0)
ab$=ab$+"0"+STR$(hms)+CHR$(0)
ELSE
a$=a$+STR$(hms)+CHR$(0)
ab$=ab$+STR$(hms)+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE htimeset3      ! Zeitausgabe in h,m,s,frames (normal)
.| Glob. Var.: hh#,hsec#,hrest#,hm#,hs#,hms#,a$
.| Aufruf in : maschruf2-1,maschruf3-2,maschruf3b-2,maschruf5-1
.|     maschruf5c-1,maschruf8b-2,arrnrset-9,trakload-1,trakforw-2
.|     trkbackw-2,trkstrt-1,trkend-1,trkanf-2,trkfull-2,trkplay-13
.|     opentrk-5,arrstrt-2,arrend-2,arrtowork-1,arrplay-13,hardstrt-1
.|     hardend-1,hardfs-1,mforw-2,mbackw-2,
'
hh=INT(hsec/framez/60/60)
hrest=hsec-(hh*framez*60*60)
hm=INT(hrest/framez/60)
hrest=hrest-(hm*framez*60)
hs=INT(hrest/framez)
hms=INT(hrest-(hs*framez))
IF hms>=framez THEN
hms=framez-1
ENDIF
IF hh<10 THEN
a$="0"+STR$(hh)+":"
ab$="0"+STR$(hh)
ELSE
a$=STR$(hh)+":"
ab$=STR$(hh)
ENDIF
IF hm<10 THEN
a$=a$+"0"+STR$(hm)+":"
ab$=ab$+"0"+STR$(hm)
ELSE
a$=a$+STR$(hm)+":"
ab$=ab$+STR$(hm)
ENDIF
IF hs<10 THEN
a$=a$+"0"+STR$(hs)+" "
ab$=ab$+"0"+STR$(hs)
ELSE
a$=a$+STR$(hs)+" "
ab$=ab$+STR$(hs)
ENDIF
IF hms<10 THEN
a$=a$+"0"+STR$(hms)+CHR$(0)
ab$=ab$+"0"+STR$(hms)+CHR$(0)
ELSE
a$=a$+STR$(hms)+CHR$(0)
ab$=ab$+STR$(hms)+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE zoomcalc
.| Glob. Var.: xm#,vmem#,zmax#,zoomp#,ce#,cs#,nr#,smpedit&,scrolm#,cached#
.| Ruft auf  : makepnt,restaura
.| Aufruf in : button-2,do_smpedit-2,
LOCAL grenz,stufen,dazu
grenz=xm/2
stufen=LOG(vmem-grenz)/zmax
dazu=INT((EXP(stufen*(zmax-zoomp))+grenz)/mbit)*mbit
IF zoomp=0 THEN
cs=0
ce=vmem
ELSE
ce=INT((cs+dazu)/mbit)*mbit
IF ce>vmem THEN
cs=INT((vmem-dazu)/mbit)*mbit
ce=vmem
ENDIF
IF cs<0 THEN
cs=0
ENDIF
ENDIF
IF nr=smpedit& THEN
@makepnt
ENDIF
scrolm=ce-cs
cached=FALSE
@restaura
RETURN
'
> PROCEDURE zslidecalc
.| Glob. Var.: xm#,vmem#,zmax#,ce#,cs#,zoomp#,nr#,smpedit&,zomslide&
.|     zoombutt&,a$
.| Ruft auf  : setslide,textbutt,makepnt
.| Aufruf in : zoomhelp-1,smpl-1,smpr-1,rubbermax-1,ldhlp-1,getmem-1
.|     smpedit-1,do_smpedit-2,trash-1,
LOCAL grenz,stufen
grenz=xm/2
IF vmem-grenz>0 THEN
stufen=LOG(vmem-grenz)/zmax
IF ((ce-cs)-grenz)>0 THEN
zoomp=zmax-ROUND((LOG((ce-cs)-grenz))/stufen)
ELSE
zoomp=zmax-1
ENDIF
ELSE
zoomp=0
ENDIF
IF zoomp>zmax-1 THEN
zoomp=zmax-1
ENDIF
IF nr=smpedit& THEN
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@makepnt
ENDIF
RETURN
'
> PROCEDURE maketime
.| Glob. Var.: uhr#,tim$,nr#,smpedit&,clock&,aback#,btim$,btime#
.| Ruft auf  : textfeld,makeaback
.| Aufruf in : rsc_do-1,windows-1,smpedit-1,markhandler-1,
LOCAL a,b,c,d,ha1
'
@markhlp
GRAPHMODE 1
'
IF uhr=TRUE THEN
IF tim$<>TIME$ THEN
tim$=TIME$
IF nr=smpedit& THEN
@textfeld(clock&,TIME$,1)
ENDIF
IF aback=TRUE THEN
a=VAL(MID$(tim$,4,2))
b=VAL(MID$(btim$,4,2))
c=VAL(RIGHT$(tim$,2))
d=VAL(RIGHT$(btim$,2))
IF a<b THEN
a=a+60
ENDIF
IF c<d THEN
c=c+60
b=b+1
ENDIF
b=a-b
c=c-d
IF (b*60+c)>=btime*60 THEN
@makeaback
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE makepnt
.| Glob. Var.: nr#,smpedit&,pnt#,ce#,cs#,xm#,pntc#,a$,pntprsmp&
.| Ruft auf  : textfeld
.| Aufruf in : zoomcalc-1,zslidecalc-1,smpedit-1,do_smpedit-2,
IF nr=smpedit& THEN
pnt=INT((ce-cs)/mbit)
IF pnt>0 THEN
IF pnt<=xm THEN
pntc=xm/pnt
pntc=INT(pntc*10)/10
a$=STR$(pntc)
IF LEN(a$)>7 THEN
a$=LEFT$(a$,7)
ENDIF
a$=a$+":1"
ELSE
pntc=INT(pnt/xm)
a$="1:"+STR$(pntc)
IF LEN(a$)>9 THEN
a$=LEFT$(a$,9)
ENDIF
ENDIF
a$=a$+CHR$(0)
@textfeld(pntprsmp&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE abackup
.| Glob. Var.: vornr#,nr#,abackup&,winh#,menuda#,a$,btime#,abacktxt&,aback#
.|     aback&,abacknam#,abacknam&,vbtime#,vaback#,vaback2#,vabacknam#,obj#
.|     popup&,zu%,zuadr#,buttadr#,but#,objadr#,objflag#,abackhlp&,abackr1&
.|     abackr2&,abackl1&,abackl2&,abackex&,abackok&,tim$,btim$,clock&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,textfeld,setbutton,rsc_do
.|     xrsrc_gaddr,mousek,helptxt,setaback,abacknam,abackr,abackl,restaura2
.| Aufruf in : do_smpedit-1,
@testcopyright
vornr=nr
nr=abackup&
'
a$=RIGHT$("00"+STR$(btime),2)+CHR$(0)
@textfeld2(nr,abacktxt&,a$,1)
IF aback=TRUE THEN
@setbutton3(aback&,1,nr)
ELSE
@setbutton3(aback&,0,nr)
ENDIF
IF abacknam=TRUE THEN
@setbutton3(abacknam&,1,nr)
ELSE
@setbutton3(abacknam&,0,nr)
ENDIF
vbtime=btime
vaback=aback
vaback2=aback
vabacknam=abacknam
@rsc_draw(nr,0)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=abackhlp& THEN
@helptxt("BACKUP")
ENDIF
IF obj=aback& THEN
@setaback
ENDIF
IF obj=abacknam& THEN
@abacknam
ENDIF
IF obj=abackr1& OR obj=abackr2& THEN
@abackr
ENDIF
IF obj=abackl1& OR obj=abackl2& THEN
@abackl
ENDIF
UNTIL obj=abackex& OR obj=abackok&
@setbutton(obj,0)
IF obj=abackex& THEN
btime=vbtime
aback=vaback
abacknam=vabacknam
ELSE
tim$=TIME$
btim$=TIME$
aback=vaback2
ENDIF
@restaura2
IF aback=FALSE THEN
@setbutton(clock&,0)
ELSE
@setbutton(clock&,1)
ENDIF
obj=0
RETURN
'
> PROCEDURE setaback
.| Glob. Var.: vaback2#
.| Aufruf in : abackup-1,
IF vaback2=FALSE THEN
vaback2=TRUE
ELSE
vaback2=FALSE
ENDIF
RETURN
'
> PROCEDURE abacknam
.| Glob. Var.: abacknam#
.| Aufruf in : abackup-1,
IF abacknam=FALSE THEN
abacknam=TRUE
ELSE
abacknam=FALSE
ENDIF
RETURN
'
> PROCEDURE abackr
.| Glob. Var.: obj#,abackr1&,x#,btime#,a$,abacktxt&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : abackup-1,
IF obj=abackr1& THEN
x=1
ELSE
x=5
ENDIF
IF btime<(61-x) THEN
btime=btime+x
a$=RIGHT$("00"+STR$(btime),2)+CHR$(0)
@textfeld(abacktxt&,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE abackl
.| Glob. Var.: obj#,abackl1&,x#,btime#,a$,abacktxt&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : abackup-1,
IF obj=abackl1& THEN
x=1
ELSE
x=5
ENDIF
IF btime>x THEN
btime=btime-x
a$=RIGHT$("00"+STR$(btime),2)+CHR$(0)
@textfeld(abacktxt&,a$,1)
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE write(w$,zeile)
.| Glob. Var.: xd#,yd#
.| Ruft auf  : markhlp
.| Aufruf in : makeaback-4,
LOCAL ready,v
ready=FALSE
REPEAT
ax&=rscx&(nr)
ay&=rscy&(nr)
~GRAF_MOUSE(256,0)                              ! Hidem
~WIND_UPDATE(1)                                    ! BEG_UPDATE
GRAPHMODE 2
IF bigfoot=FALSE THEN
DEFTEXT 1,0,0,4
TEXT ax&+22,ay&+92+zeile*8,w$
ELSE
DEFTEXT 1,0,0,13
TEXT ax&+25,ay&+100+zeile*16,w$
ENDIF
DEFTEXT 1,0,0,4
GRAPHMODE 1
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~GRAF_MOUSE(257,0)                              ! Showm
ready=TRUE
UNTIL ready=TRUE
drawnew=TRUE
RETURN
'
> PROCEDURE makeaback
.| Glob. Var.: mrkobj#,obj#,vvorvornr#,vorvornr#,vornr#,nr#,inftxt&,winh#
.|     menuda#,btim$,mbs#,path$,ext2$,abacknam#,a$,lfw$,aback$,virtual#,a#
.|     mlen#,meml#,arp$,aback2$,sector#
.| Felder    : mblockp$()
.| Ruft auf  : rsc_draw,rsc_menu_ienable,write,arrsteil,restaura2
.| Aufruf in : maketime-1,
LOCAL b$
@testcopyright
mrkobj=obj
vvorvornr=vorvornr
vorvornr=vornr
vornr=nr
nr=inftxt&
'
'
@rsc_draw(nr,0)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
btim$=TIME$
IF mbs>0 THEN
b$=mblockp$(mbs)
ELSE
b$=path$
ENDIF
IF b$="" OR INSTR(b$,":")=0 OR INSTR(b$,"\")=0 THEN
b$="MEMORY."+ext2$
ENDIF
IF abacknam=TRUE THEN
a$=b$
IF EXIST(a$)=FALSE THEN
a$=lfw$+aback$
ENDIF
ELSE
a$=lfw$+aback$
ENDIF
IF virtual=FALSE THEN
a=ASC(LEFT$(a$,1))-64
IF @dfree(a)>=mlen THEN
b$=a$
IF bigfoot=FALSE THEN
IF LEN(b$)>40 THEN
b$="..."+RIGHT$(b$,40-3)
ENDIF
ELSE
IF LEN(b$)>26 THEN
b$="..."+RIGHT$(b$,26-3)
ENDIF
ENDIF
@write("MEM-Backup:   "+b$,0)
IF abacknam=TRUE AND EXIST(a$)=TRUE THEN
OPEN "U",#5,a$
ELSE
OPEN "O",#5,a$
ENDIF
BPUT #5,meml,mlen
CLOSE #5
ELSE
@alerts3(1)
PAUSE 50
ENDIF
ENDIF
IF abacknam=TRUE THEN
a$=arp$
IF a$="" THEN
a$=aback2$
ENDIF
IF EXIST(a$)=FALSE THEN
a$=aback2$
ENDIF
ELSE
a$=aback2$
ENDIF
a=ASC(LEFT$(a$,1))-64
IF @dfree(a)>=sector THEN
b$=a$
IF bigfoot=FALSE THEN
IF LEN(b$)>40 THEN
b$="..."+RIGHT$(b$,40-3)
ENDIF
ELSE
IF LEN(b$)>26 THEN
b$="..."+RIGHT$(b$,26-3)
ENDIF
ENDIF
@write("ARR-Backup:   "+b$,1)
IF abacknam=TRUE AND EXIST(a$)=TRUE THEN
OPEN "U",#5,a$
ELSE
OPEN "O",#5,a$
ENDIF
@arrsteil
CLOSE #5
ELSE
@alerts3(2)
PAUSE 50
ENDIF
@restaura2
obj=0
vornr=vorvornr
vorvornr=vvorvornr
RETURN
'
> PROCEDURE sethertz
.| Glob. Var.: extclock#,nr#,smpedit&,hz#,a$,popups&,rate32&,rate&,rate44&
.|     rate48&,smp16&,ad32&,rate2&,ad44&,ad48&
.| Ruft auf  : textfeld,adlow,admid,adhigh,fliphz
.| Aufruf in : edhandler3-3,smpedit-1,setupdat-1,setup2-1,smpauto-1
.|     smpstart-1,edhandler-3,
@fliphz
@fliphz2
RETURN
'
> PROCEDURE smpedit
.| Glob. Var.: nr#,smpedit&,obj#,menuda#,winh#,freez#,i#,info&,blkfunc&
.|     smp16&,peak&,arranger&,trakker&,loop&,editfade&,cs#,ce#,vmem#,lz#
.|     ldlen#,cutp#,blks#,fadericht#,admrk#,ad#,max#,zomslide&,zoombutt&
.|     zmax#,zoomp#,scrlslde&,scrolbut&,scmax#,scrollp#,a$,aback#,clock&
.|     freemem&,popups&,smpmark&,mover&,ch#,note#,midiwort#,min$,min#
.|     mintext&,mamidi#,midi&,sms#,sme#,okmark#,lded#,datx#,sblock#
.|     smppmark&,mrcs#,mrce#,mrzoom#,mrscroll#,away#,gohome#
.| Ruft auf  : rsc_menu_ienable,setup,info,blkfunc,main,peak,arranger
.|     trakker,loopwahl,fade,rsc_draw,setup2,winbuttset,zslidecalc
.|     scrollinit,writeyproz,makepnt,setslide,textbutt,markhlp,setbutton
.|     textfeld,markhlp3,makehz,sethertz,markdel,clsed,fnamwrite,curve
.|     markprod3,maketime,windows
.| Aufruf in : HAUPTPROGRAMM-1,
nr=smpedit&
obj=0
IF away=FALSE THEN
winh=BSET(winh,nr)
'
sms=1   ! vorlÑufig
'
vien=TRUE
ien=FALSE
IF freez=TRUE THEN
FOR i=31 TO 0 STEP -1
obj=0
IF BTST(winh,i)=TRUE AND i<>smpedit& THEN
IF i=info& THEN
winh=BCLR(winh,i)
@info
ENDIF
IF i=smp16& THEN
winh=BCLR(winh,i)
@main
ENDIF
IF i=blkfunc& THEN
winh=BCLR(winh,i)
@blkfunc
ENDIF
IF i=peak& THEN
winh=BCLR(winh,i)
@peak
ENDIF
IF i=arranger& THEN
winh=BCLR(winh,i)
@arranger
ENDIF
IF i=trakker& THEN
winh=BCLR(winh,i)
@trakker
ENDIF
IF i=loop& THEN
winh=BCLR(winh,i)
@loopwahl
ENDIF
IF i=dspedit& THEN
winh=BCLR(winh,i)
@dspwahl
ENDIF
IF i=editfade& THEN
winh=BCLR(winh,i)
@fade
ENDIF
IF i=wmode& THEN
winh=BCLR(winh,i)
@workmode
ENDIF
ENDIF
NEXT i
ENDIF
nr=smpedit&
@testcopyright
vshading=shading
shading=TRUE
dopix=TRUE
@setplaychannels
IF nosetload=FALSE AND prgversion>=1.2 THEN          ! Versionskontrolle
notopen=TRUE
@calc_editsize
notopen=FALSE
ENDIF
IF public=TRUE THEN
~@xrsrc_gaddr(0,dropdown&,zu%)
~OBJC_DELETE(zu%,ddhost&-1)
~OBJC_DELETE(zu%,ddhost&)
~OBJC_DELETE(zu%,ddmix&)
@dropentrys(ddsetup&-1,12)
ENDIF
@winbuttset
IF aback=TRUE THEN
@setbutton3(clock&,1,nr)
ENDIF
a$="FRE "+STR$(FRE())+CHR$(0)
@textfeld2(nr,freemem&,a$,1)
a$=@rsc_text$(popups&,smpmark&)
@textfeld2(nr,mover&,a$,1)
IF mamidi=0 THEN
@setbutton3(midi&,0,nr)
ELSE
@setbutton3(midi&,1,nr)
ENDIF
IF dig24=FALSE THEN
IF bigfoot=TRUE THEN
a$=@rsc_text$(popups&,bitp16&)
@textfeld2(nr,resolu&,a$,1)
ELSE
@textfeld2(nr,resolu&,"16 BIT"+CHR$(0),1)
ENDIF
ELSE
IF bigfoot=TRUE THEN
a$=@rsc_text$(popups&,bitp24&)
@textfeld2(nr,resolu&,a$,1)
ELSE
@textfeld2(nr,resolu&,"24 BIT"+CHR$(0),1)
ENDIF
ENDIF
IF bigfoot=TRUE THEN
hsec=0
@htimeset
@textfeld2(nr,editime&,a$,1)
ENDIF
@setup2
@write_int(0)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
'
cs=0
ce=vmem
lz=1
ldlen=0
cutp=0
blks=0
admrk=ad
startup=TRUE
@zslidecalc
@scrollinit
max=32767
@writeyproz
@makepnt
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
'
@slideinit(edmslide&,edmbut&,loopz,5,vsms)
@setslide(edmslide&,edmbut&,loopz,5,vsms)
@edmarkset(vsms+1)
'
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@markhlp
@markhlp3(9998,0,cs)
@markhlp3(9999,0,ce)
midiwort=(ch-1)*256+note
'    @makehz
'    @sethertz
@minwrite
@sourcein
markmode=1
nmarkmode=1
@setbutton(swmark&,1)
IF sms<>0 THEN
okmark=1
ENDIF
@markdel
@clsed
IF NOT (lded=0 AND okmark=0) THEN
IF DPEEK(datx)=&HF07E OR okmark=1 THEN
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
ENDIF
@fnamwrite
ENDIF
IF (lded=1 AND DPEEK(datx)=&HF07E) OR okmark=1 THEN
@markprod3
ENDIF
@maketime
'
shading=vshading
dopix=FALSE
'
@rsc_draw(nr,7)
IF fcall=TRUE THEN
freez=TRUE         ! wegen Setup-Save
ENDIF
smpedda=TRUE
windowda=TRUE
'
IF menuda=TRUE THEN
@rsc_menu_ienable(TRUE)
ENDIF
'
@curve(cs,ce)
@getcurve
mrcs=cs
mrce=ce
mrzoom=zoomp
mrscroll=scrollp
edhz=hz
IF away=FALSE THEN
@windows
ENDIF
ELSE
@goodbye
ENDIF
RETURN
'
> PROCEDURE edmarkdel
LOCAL j
IF sms2<>0 THEN
FOR j=1 TO 4
IF loops%(sms,j)<>-1 THEN
@markhlp8(sms,j,loops%(sms,j))
ENDIF
NEXT j
ENDIF
FOR j=1 TO 4
@selblkstxt(j,CHR$(0))
NEXT j
@textfeld(edmtxt&,CHR$(0),1)
IF sms2<>0 THEN
@selblkshak(sms2,0)
ELSE
@setbutton(edmbuts&,0)
@setbutton(edmbute&,0)
@setbutton(edmbuti&,0)
@setbutton(edmbutr&,0)
ENDIF
RETURN
'
> PROCEDURE edmarksearch
LOCAL j,j2
j2=0
IF sms<>0 THEN
FOR j=4 TO 1 STEP -1    ! muû wieder auf 4 statt 2
IF loops%(sms,j)<>-1 THEN
j2=j
ENDIF
NEXT j
ENDIF
sms2=j2
@selblkshak(sms2,1)
RETURN
'
> PROCEDURE edslidemove(es)
@makehz
@sethertz
@edmarkdel
sms=es
@edmarksearch
@edmarkset(es)
RETURN
'
> PROCEDURE edmarkset(es)
LOCAL j
@makehz
@sethertz
'  @edmarkdel
sms=es
a$=STR$(sms)+CHR$(0)
@textfeld(edmnr&,a$,1)
a$=edmtxt$(sms)+CHR$(0)
IF LEN(a$)>25 THEN
a$=LEFT$(a$,25)+CHR$(0)
ENDIF
@textfeld(edmtxt&,a$,1)
vsms=sms-1
@setslide(edmslide&,edmbut&,loopz,5,vsms)
'  @edmarksearch
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
FOR j=1 TO 4
IF loops%(sms,j)<>-1 THEN
@marktextsel(j)
@markhlp6(loops%(sms,j))
@markhlp3(sms,j,loops%(sms,j))
ENDIF
NEXT j
ENDIF
RETURN
'
> PROCEDURE edmarkset2(o,es,i2)
LOCAL j,j2
IF loops%(es,i2)<>-1 AND i2<>0 THEN
@markhlp8(es,i2,o)
ENDIF
IF i2<>sms2 AND sms2<>0 THEN
@selblkshak(sms2,0)
@selblkshak(i2,1)
ENDIF
sms2=i2
IF es>0 AND es<=loopz AND i2<>0 THEN
IF loops%(es,i2)<>-1 THEN
@marktextsel(i2)
@markhlp6(loops%(es,i2))
@markhlp3(es,i2,loops%(es,i2))
ENDIF
ENDIF
RETURN
'
> PROCEDURE edmtextin
LOCAL a
@testcopyright
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=mrktxtin&
a$=edmtxt$(sms)
IF LEN(a$)>25 THEN
a$=LEFT$(a$,25)+CHR$(0)
ENDIF
a$=a$+CHR$(0)
@editfeld2(nr,mtex&,a$)
@rsc_draw(nr,0)
@wischwasch
@markhlp
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1 AND obj<>mtex&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=mtexhelp& THEN
@helptxt("MARKER-TEXT")
ENDIF
UNTIL obj=mtexex& OR obj=mtexok&
IF obj=mtexok& THEN
editread(mtex&)
a=INSTR(a$,CHR$(0))
IF a>0 THEN
a$=LEFT$(a$,a-1)
ENDIF
IF bigfoot=FALSE THEN
IF LEN(a$)>25 THEN
a$=LEFT$(a$,25)
ENDIF
ELSE
IF LEN(a$)>25 THEN
a$=LEFT$(a$,25)
ENDIF
ENDIF
edmtxt$(sms)=a$
ENDIF
@setbutton(obj,0)
edit_obj&=0
obj&=0
@restaura2
IF obj=mtexok& THEN
a$=edmtxt$(sms)+CHR$(0)
@textfeld(mrkobj,a$,1)
ENDIF
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
edit_obj&=0
obj&=0
RETURN
'
> PROCEDURE edmftim(a)
IF tedart=0 THEN
IF vornr=trakker& THEN
hsec=a/thz*100
ENDIF
IF vornr=arranger& THEN
hsec=a/vhz*100
ENDIF
IF vornr=cuelist& OR nr=cuelist& THEN
hsec=a/mbit/hz*100
ENDIF
@htimeset
ELSE
IF vornr=trakker& OR vornr=arranger& THEN
sc=INT(a)
ENDIF
IF vornr=cuelist& OR nr=cuelist& THEN
sc=INT(a/mbit)
ENDIF
a$=STR$(sc)
@formatsmp
a$=a$+CHR$(0)
ENDIF
RETURN
'
> PROCEDURE edmfsetnr(es)
LOCAL a1,a2,a3,a4,a5$
a$=STR$(es)+CHR$(0)
@textfeld(mrkfnr&,a$,1)
IF vornr=trakker& OR vornr=arranger& THEN
a1=bloops%(es,1)
a2=bloops%(es,2)
a3=bloops%(es,3)
a4=bloops%(es,4)
a5$=vedmtxt$(es)
ENDIF
IF vornr=cuelist& THEN
a1=loops%(es,1)
a2=loops%(es,2)
a3=-1
a4=-1
a5$=edmtxt$(es)
ENDIF
IF a1<>-1 THEN
@edmftim(a1)
ELSE
a$=CHR$(0)
ENDIF
@textfeld(mrkftims&,a$,1)
IF a2<>-1 THEN
@edmftim(a2)
ELSE
a$=CHR$(0)
ENDIF
@textfeld(mrkftime&,a$,1)
IF a3<>-1 THEN
@edmftim(a3)
ELSE
a$=CHR$(0)
ENDIF
@textfeld(mrkftimi&,a$,1)
IF a4<>-1 THEN
@edmftim(a4)
ELSE
a$=CHR$(0)
ENDIF
@textfeld(mrkftimr&,a$,1)
a$=a5$+CHR$(0)
IF LEN(a$)>25 THEN
a$=LEFT$(a$,25)+CHR$(0)
ENDIF
@textfeld(mrkftxt&,a$,1)
RETURN
'
> PROCEDURE mrkfslidemove(es)
@makehz
@sethertz
edsms=es
@edmfsetnr(es)
RETURN
'
> PROCEDURE edmfind
LOCAL a
@testcopyright
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=mrkfind&
vshading=shading
shading=TRUE
dopix=TRUE
@markhlp
@slideinit(mrkfslid&,mrkfbut&,loopz,5,vedsms)
@setslide(mrkfslid&,mrkfbut&,loopz,5,vedsms)
edsms=1
@edmfsetnr(edsms)
dopix=FALSE
shading=vshading
@rsc_draw(nr,0)
@wischwasch
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF obj=mrkfhelp& THEN
@helptxt("MARKER-WAHL")
ENDIF
IF obj=mrkfup& THEN
@slideup(mrkfslid&,mrkfbut&,loopz,1,5,vedsms,slflg)
IF slflg=TRUE THEN
@mrkfslidemove(vedsms+1)
ENDIF
@setbutton(mrkfup&,0)
ENDIF
IF obj=mrkfdown& THEN
@slidedwn(mrkfslid&,mrkfbut&,loopz,1,5,vedsms,slflg)
IF slflg=TRUE THEN
@mrkfslidemove(vedsms+1)
ENDIF
@setbutton(mrkfdown&,0)
ENDIF
UNTIL obj=mrkfex& OR obj=mrkfok&
@setbutton(obj,0)
@restaura2
IF obj=mrkfok& THEN
edmfind=TRUE
ELSE
edmfind=FALSE
ENDIF
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE indrag(sobj,dobj,dobj2,masterbox,xtd,ytd,txb,tyb,clipnr,eda,VAR dragart,dragvar)
LOCAL z,bx,by,tdragm
tdragm=FALSE
mobj2=sobj
@markhlp
xd=ax&
yd=ay&
~@xrsrc_gaddr(0,nr,zu%)
@readpos(sobj)
GRAPHMODE 3
@mouse(vmp,vmp2,v3)
vm=vmp
vm2=vmp2
~GRAF_MOUSE(256,0)                              ! Hidem
@buttbh(masterbox,mxb,myb)
ag=@rsc_get2(xd+bx+xtd,yd+by+ytd,txb,tyb,eda)
ag2=@rsc_get(xd+bx+xtd,yd+by+ytd,txb,tyb)
@rsc_put(ag2,xd+bx+xtd,yd+by+ytd,1)
REPEAT
@mouse(v,v2,k)
IF k=1 AND (v<>vm OR v2<>vm2) THEN
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
ag2=@rsc_get2(xd+bx+xtd+(v-vmp),yd+by+ytd+(v2-vmp2),txb,tyb,ag2)
@rsc_put(ag,xd+bx+xtd+(v-vmp),yd+by+ytd+(v2-vmp2),1)
vm=v
vm2=v2
ENDIF
fobj=OBJC_FIND(zu%,0,10,v,v2)
IF fobj=dobj OR fobj=dobj2 THEN
@readbutton(fobj)
IF dragart=0 AND buttflag=0 THEN
@setbutton(fobj,1)
ENDIF
IF dragart<>0 AND buttflag=1 AND tdragm=FALSE THEN
@setbutton(fobj,0)
PAUSE 4
@setbutton(fobj,1)
ENDIF
tdragm=TRUE
mdobj=fobj
ENDIF
IF fobj<>dobj AND fobj<>dobj2 AND tdragm=TRUE THEN
tdragm=FALSE
@readbutton(mdobj)
IF dragart=0 AND buttflag<>0 THEN
@setbutton(mdobj,0)
ENDIF
IF dragart<>0 AND buttflag<>1 THEN
@setbutton(mdobj,1)
ENDIF
ENDIF
UNTIL k=0
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
~GRAF_MOUSE(257,0)                              ! Showm
IF (fobj=dobj OR fobj=dobj2) AND tdragm=TRUE THEN
@setbutton(fobj,0)
FOR i=0 TO 2
PAUSE 2
@setbutton(fobj,0)
PAUSE 2
@setbutton(fobj,1)
NEXT i
dragart=clipnr
ENDIF
GRAPHMODE 3
IF tdragm=TRUE THEN
dragvar=TRUE
ENDIF
~MFREE(ag2)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE dragdestok
dragdok=FALSE
IF nr=smpedit& THEN
IF dobj=edmnr& AND edcart=1 THEN
dragdok=TRUE
ENDIF
IF (dobj=edmbuts& OR dobj=edmbute& OR dobj=edmbuti& OR dobj=edmbutr&) AND edcart>1 THEN
dragdok=TRUE
ENDIF
ENDIF
IF nr=arranger& THEN
IF ((dobj=arrm1& AND arrcok1=TRUE) OR (dobj=arrm2& AND arrcok2=TRUE) OR (dobj=arrm3& AND arrcok3=TRUE) OR (dobj=arrm4& AND arrcok4=TRUE)) AND arrcart<>0 THEN
dragdok=TRUE
ENDIF
ENDIF
IF nr=trakker& THEN
IF ((dobj=trakk1& AND trkcok1=TRUE) OR (dobj=trakk2& AND trkcok2=TRUE) OR (dobj=trakk3& AND trkcok3=TRUE) OR (dobj=trakk4& AND trkcok4=TRUE)) AND trkcart<>0 THEN
dragdok=TRUE
ENDIF
ENDIF
RETURN
'
> PROCEDURE dragdestdel
IF nr=smpedit& AND edcart>1 AND edcart<6 THEN
@setbutton(edmbuts&,0)
@setbutton(edmbute&,0)
@setbutton(edmbuti&,0)
@setbutton(edmbutr&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(arrm1&,0)
@setbutton(arrm2&,0)
@setbutton(arrm3&,0)
@setbutton(arrm4&,0)
ENDIF
IF nr=trakker& THEN
@setbutton(trakk1&,0)
@setbutton(trakk2&,0)
@setbutton(trakk3&,0)
@setbutton(trakk4&,0)
ENDIF
RETURN
'
> PROCEDURE outdrag(sobj,masterbox,xtd,ytd,txb,tyb,dragart,eda,VAR dragvar)
LOCAL z,bx,by
IF dragart<>0 THEN
@markhlp
tdrag2=FALSE
xd=ax&
yd=ay&
~@xrsrc_gaddr(0,nr,zu%)
@readpos(sobj)
GRAPHMODE 3
@mouse(vmp,vmp2,v3)
vm=vmp
vm2=vmp2
~GRAF_MOUSE(256,0)                              ! Hidem
@buttbh(masterbox,mxb,myb)
ag2=@rsc_get(xd+bx+xtd,yd+by+ytd,txb,tyb)
@rsc_put(ag2,xd+bx+xtd,yd+by+ytd,1)
REPEAT
@mouse(v,v2,k)
IF k=1 AND (v<>vm OR v2<>vm2) THEN
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
ag2=@rsc_get2(xd+bx+xtd+(v-vmp),yd+by+ytd+(v2-vmp2),txb,tyb,ag2)
@rsc_put(eda,xd+bx+xtd+(v-vmp),yd+by+ytd+(v2-vmp2),1)
vm=v
vm2=v2
ENDIF
dobj=OBJC_FIND(zu%,0,10,v,v2)
@dragdestok
IF dragdok=TRUE THEN
@readbutton(dobj)
IF buttflag=0 THEN
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
@setbutton(dobj,1)
ag2=@rsc_get2(xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),txb,tyb,ag2)
tdrag2=TRUE
mobj=dobj
ENDIF
ENDIF
IF dragdok=FALSE AND tdrag2=TRUE THEN
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
@setbutton(mobj,0)
@dragdestdel
ag2=@rsc_get2(xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),txb,tyb,ag2)
@rsc_put(eda,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
tdrag2=FALSE
ENDIF
UNTIL k=0
@rsc_put(ag2,xd+bx+xtd+(vm-vmp),yd+by+ytd+(vm2-vmp2),1)
~GRAF_MOUSE(257,0)                              ! Showm
IF tdrag2=TRUE THEN
@setbutton(mobj2,0)
@setbutton(mobj,1)
FOR i=0 TO 2
PAUSE 2
@setbutton(mobj,0)
PAUSE 2
@setbutton(mobj,1)
NEXT i
dragvar=TRUE
ENDIF
GRAPHMODE 3
ENDIF
~MFREE(ag2)
GRAPHMODE 1
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE dragedm
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by
dmobj=obj
'  edcart=0
'  edcart2=0
@readpos(editbox&)
drmx=bx
drmy=by
@readpos(editbox3&)
drmx=drmx+bx+1
drmy=drmy+by-35
@buttbh(dmobj,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
z=0
IF dmobj=edmnr& THEN
z=1
ENDIF
IF dmobj=edmbuts& THEN
z=2
ENDIF
IF dmobj=edmbute& THEN
z=3
ENDIF
IF dmobj=edmbuti& THEN
z=4
ENDIF
IF dmobj=edmbutr& THEN
z=5
ENDIF
IF z>1 AND z<6 THEN
@readpos(edmbox&)
drmx=drmx+bx
drmy=drmy+by
ENDIF
edcart2=1
IF z=1 THEN
IF edaz1=0 THEN
@readpos(dmobj)
eda1=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
edab1=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
eda=eda1
edaz1=1
ELSE
eda=eda1
ENDIF
ENDIF
IF z>1 AND z<6 THEN
IF edaz2=0 THEN
@readpos(dmobj)
eda2=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
edab2=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
eda=eda2
edaz2=1
ELSE
eda=eda2
ENDIF
ENDIF
vedcart=edcart
vidrag=idrag
IF idrag=FALSE THEN
edcart=0
ENDIF
idrag=FALSE
@indrag(dmobj,flyer&,trash&,editbox7&,drmx,drmy,drtxb,drtyb,z,eda,edcart,idrag)
IF fobj=flyer& THEN
IF edcart<>0 AND idrag=TRUE THEN
edcwert=sms
ENDIF
IF edcart=1 AND idrag=TRUE THEN
edcwertx1=loops%(sms,1)
edcwertx2=loops%(sms,2)
edcwertx3=loops%(sms,3)
edcwertx4=loops%(sms,4)
edcwertx$=edmtxt$(sms)
ENDIF
IF edcart>1 AND edcart<6 AND idrag=TRUE THEN
edcwert2=loops%(sms,edcart-1)
ENDIF
IF edcart>1 AND edcart<6 THEN
@setbutton(dmobj,1)
ENDIF
ENDIF
IF fobj=trash& THEN
IF edcart=1 AND idrag=TRUE THEN
@markhlp
@edmarkdel
FOR j=1 TO 4
loops%(sms,j)=-1
NEXT j
edmtxt$(sms)=""
ENDIF
IF edcart>1 AND edcart<6 AND idrag=TRUE THEN
o=loops%(sms,edcart-1)
@markhlp
loops%(sms,edcart-1)=-1
@markhlp8(sms,edcart-1,o)
@selblkshak(edcart-1,0)
@edmarksearch
ENDIF
edcart=vedcart
@setbutton(trash&,0)
idrag=FALSE
ENDIF
IF edcart=1 OR dmobj=edmnr& THEN
@setbutton(edmnr&,0)
ENDIF
IF idrag=FALSE AND vidrag=TRUE THEN                  ! zurÅckholen
idrag=TRUE
IF edaz1=1 AND edcart=1 THEN
@buttbh(edmnr&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=edab1
FOR i=eda1 TO eda1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
IF edaz2=1 AND edcart>1 AND edcart<6 THEN
@buttbh(edmbuts&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=edab2
FOR i=eda2 TO eda2+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
ELSE                                            ! retten
IF edaz1=1 AND edcart=1 THEN
@buttbh(edmnr&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=eda1
FOR i=edab1 TO edab1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
IF edaz2=1 AND edcart>1 AND edcart<6 THEN
@buttbh(edmbuts&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=eda2
FOR i=edab2 TO edab2+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
ENDIF
edcart2=0
@markhlp
@drawbutton(flyer&)
@setbutton(trash&,0)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE clipdel
edcart=0
edcart2=0
edcart3=0
idrag=FALSE
IF nr=smpedit& THEN
@setbutton(flyer&,0)
ELSE
@setbutton3(flyer&,0,smpedit&)
ENDIF
RETURN
'
> PROCEDURE dragedclip
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by,o
IF ((edcart=1 AND edaz1=1) OR (edcart>1 AND edcart<6 AND edaz2=1)) AND idrag=TRUE THEN
dmobj=obj
@readpos(editbox&)
drmx=bx
drmy=by
IF edcart=1 THEN
@buttbh(edmnr&,drtxb,drtyb)
ENDIF
IF edcart>1 AND edcart<6 THEN
drmy=drmy-25
@buttbh(edmbuts&,drtxb,drtyb)
SELECT sms2
CASE 1
@setbutton(edmbuts&,0)
CASE 2
@setbutton(edmbute&,0)
CASE 3
@setbutton(edmbuti&,0)
CASE 4
@setbutton(edmbutr&,0)
ENDSELECT
ENDIF
drtxb=drtxb+3
drtyb=drtyb+2
idrag2=FALSE
edcart3=1
IF edcart=1 THEN
eda=eda1
ENDIF
IF edcart>1 AND edcart<6 THEN
eda=eda2
ENDIF
@outdrag(flyer&,editbox7&,drmx,drmy,drtxb,drtyb,edcart,eda,idrag2)
@markhlp
IF edcart=0 AND dmobj=flyer& AND idrag=FALSE THEN
@setbutton(flyer&,0)
ENDIF
IF edcart>1 AND edcart<6 THEN
@setbutton(edmbuts&,0)
@setbutton(edmbute&,0)
@setbutton(edmbuti&,0)
@setbutton(edmbutr&,0)
ENDIF
IF edcart=1 AND idrag2=TRUE THEN
@makehz
@sethertz
@edmarkdel
loops%(sms,1)=edcwertx1
loops%(sms,2)=edcwertx2
loops%(sms,3)=edcwertx3
loops%(sms,4)=edcwertx4
edmtxt$(sms)=edcwertx$
@edmarksearch
@edmarkset(sms)
@setbutton(edmnr&,0)
ENDIF
IF edcart>1 AND edcart<6 AND idrag2=TRUE THEN
@makehz
@sethertz
IF dobj=edmbuts& THEN
sms2=1
ENDIF
IF dobj=edmbute& THEN
sms2=2
ENDIF
IF dobj=edmbuti& THEN
sms2=3
ENDIF
IF dobj=edmbutr& THEN
sms2=4
ENDIF
o=loops%(sms,sms2)
@markhlp
loops%(sms,sms2)=edcwert2
@edmarkset2(o,sms,sms2)
ENDIF
IF edcart>1 AND edcart<6 THEN
SELECT sms2
CASE 1
@setbutton(edmbuts&,1)
CASE 2
@setbutton(edmbute&,1)
CASE 3
@setbutton(edmbuti&,1)
CASE 4
@setbutton(edmbutr&,1)
ENDSELECT
ENDIF
edcart3=0
@markhlp
ELSE
@setbutton(obj,0)
ENDIF
@drawbutton(flyer&)
@setbutton(trash&,0)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE arrdragin
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by
IF arrpath$(arrherr)<>"" THEN
dmobj=obj
@readpos(arrbox3&)
drmx=bx+1
drmy=by-35
@buttbh(dmobj,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
z=0
IF dmobj=arrm1& THEN
z=1
ENDIF
IF dmobj=arrm2& THEN
z=2
ENDIF
IF dmobj=arrm3& THEN
z=3
ENDIF
IF dmobj=arrm4& THEN
z=4
ENDIF
arrcart2=1
IF bbarrz1=0 THEN
@readpos(dmobj)
bbarr1=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
eda=bbarr1
bbarrz1=1
ELSE
eda=bbarr1
ENDIF
vadrag=adrag
IF adrag=FALSE THEN
arrcart=0
ENDIF
adrag=FALSE
'
@indrag(dmobj,arrclip&,arrclip&,arrbox&,drmx,drmy,drtxb,drtyb,z,eda,arrcart,adrag)
'
IF fobj=arrclip& THEN
IF arrcart<>0 AND adrag=TRUE THEN
arrcwert=arrherr
arrcwert2$=arrfn$(arrherr)
arrcwert3$=arrpath$(arrherr)
arrcwert4=arrstrt%(arrherr)
arrcwert5=arrend%(arrherr)
arrcwert6=arrlen%(arrherr)
'      arrcwert7=arrmidi&(arrherr)
arrcwert8!=arrloop!(arrherr)
arrcwert9=arrtri|(arrherr)
arrcwert10=arrsrate%(arrherr)
arrcwert11=arrbits!(arrherr)
arrcwert12=arrhead(arrherr)
ENDIF
ENDIF
'
IF adrag=FALSE AND vadrag=TRUE THEN
adrag=TRUE
ENDIF
arrcart2=0
@markhlp
ENDIF
@drawbutton(arrclip&)
'
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE arrdragclip
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by,o,a
IF arrcart<>0 AND adrag=TRUE AND bbarrz1=1 AND arrpath$(arrcwert)<>"" THEN
dmobj=obj
drmx=0
drmy=-32
@buttbh(arrm1&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
adrag2=FALSE
arrcart3=1
eda=bbarr1
IF arrpath$(pbz+1)="" THEN
arrcok1=TRUE
ELSE
arrcok1=FALSE
ENDIF
IF arrpath$(pbz+2)="" THEN
arrcok2=TRUE
ELSE
arrcok2=FALSE
ENDIF
IF arrpath$(pbz+3)="" THEN
arrcok3=TRUE
ELSE
arrcok3=FALSE
ENDIF
IF arrpath$(pbz+4)="" THEN
arrcok4=TRUE
ELSE
arrcok4=FALSE
ENDIF
@setbutton(arrm1&,0)
@setbutton(arrm2&,0)
@setbutton(arrm3&,0)
@setbutton(arrm4&,0)
@outdrag(arrclip&,arrbox&,drmx,drmy,drtxb,drtyb,arrcart,eda,adrag2)
IF arrcart=0 AND dmobj=arrclip& AND adrag=FALSE THEN
@setbutton(arrclip&,0)
ENDIF
IF arrcart<>0 AND adrag2=TRUE THEN
IF dobj=arrm1& THEN
z=1
ENDIF
IF dobj=arrm2& THEN
z=2
ENDIF
IF dobj=arrm3& THEN
z=3
ENDIF
IF dobj=arrm4& THEN
z=4
ENDIF
arrfn$(pbz+z)=arrcwert2$
arrpath$(pbz+z)=arrcwert3$
arrstrt%(pbz+z)=arrcwert4
arrend%(pbz+z)=arrcwert5
arrlen%(pbz+z)=arrcwert6
'      arrmidi&(pbz+z)=arrcwert7
arrloop!(pbz+z)=arrcwert8!
arrtri|(pbz+z)=arrcwert9
arrsrate%(pbz+z)=arrcwert10
arrbits!(pbz+z)=arrcwert11
arrhead(pbz+z)=arrcwert12
obj=mobj
'      @setbutton(arrclip&,0)
spring=TRUE
@markhlp
obj=dobj
@arrtowork
spring=FALSE
@arrnrset
obj=0
ENDIF
arrcart3=0
@markhlp
a=arrherr-pbz
SELECT a
CASE 1
@setbutton(arrm1&,1)
CASE 2
@setbutton(arrm2&,1)
CASE 3
@setbutton(arrm3&,1)
CASE 4
@setbutton(arrm4&,1)
ENDSELECT
ELSE
'    adrag=FALSE
@setbutton(obj,0)
ENDIF
@drawbutton(arrclip&)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE trkdragin
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by,i,i2,l
IF trkpnt(trakact)<>0 THEN
dmobj=obj
@readpos(trakbox2&)
drmx=bx+1
drmy=by-35
z=0
IF dmobj=trakk1& THEN
z=1
tbxd=trkbx1&
ENDIF
IF dmobj=trakk2& THEN
z=2
tbxd=trkbx2&
ENDIF
IF dmobj=trakk3& THEN
z=3
tbxd=trkbx3&
ENDIF
IF dmobj=trakk4& THEN
z=4
tbxd=trkbx4&
ENDIF
@readpos(tbxd)
drmx=drmx+bx
drmy=drmy+by
@buttbh(dmobj,drtxb,drtyb)
drtxb=drtxb+2
drtyb=drtyb+2
trkcart2=1
IF bbtrkz1=0 THEN
@readpos(dmobj)
bbtrk1=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
bbtrkb1=@rsc_get(ax&+bx+drmx,ay&+by+drmy,drtxb,drtyb)
eda=bbtrk1
bbtrkz1=1
ELSE
eda=bbtrk1
ENDIF
vtrdrag=trdrag
IF trdrag=FALSE AND tdrag=FALSE THEN
trkcart=0
ENDIF
trdrag=FALSE
'
@indrag(dmobj,trakclip&,trakclip&,trakbox&,drmx,drmy,drtxb,drtyb,z,eda,trkcart,trdrag)
'
IF fobj=trakclip& THEN
IF trkcart<>0 AND trdrag=TRUE THEN
tdrag=FALSE
tdrag2=FALSE
trkcwert=trakact
clipart=1
ENDIF
ENDIF
IF trdrag=FALSE AND vtrdrag=TRUE THEN
trdrag=TRUE
tdrag=FALSE
tdrag2=FALSE
@buttbh(trakk1&,drtxb,drtyb)
drtxb=drtxb+2
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=bbtrkb1
FOR i=bbtrk1 TO bbtrk1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ELSE
@buttbh(trakk1&,drtxb,drtyb)
drtxb=drtxb+2
drtyb=drtyb+2
l=@rsc_len(drtxb,drtyb)
i2=bbtrk1
FOR i=bbtrkb1 TO bbtrkb1+l-1
POKE i,PEEK(i2)
INC i2
NEXT i
ENDIF
trkcart2=0
@markhlp
ENDIF
@drawbutton(trakclip&)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE trkdragclip
LOCAL mx,my,drmx,drmy,drtxb,drtyb,bx,by,o
IF clipart=1 THEN
IF trkcart<>0 AND trdrag=TRUE AND bbtrkz1=1 AND trkpnt(trkcwert)<>0 THEN
dmobj=obj
@readpos(trakbox3&)
drmx=bx+1
drmy=by-35
@buttbh(trakk1&,drtxb,drtyb)
drtxb=drtxb+3
drtyb=drtyb+2
trdrag2=FALSE
trkcart3=1
eda=bbtrk1
IF trkpnt(trkvz+1)=0 THEN
trkcok1=TRUE
ELSE
trkcok1=FALSE
ENDIF
IF trkpnt(trkvz+2)=0 THEN
trkcok2=TRUE
ELSE
trkcok2=FALSE
ENDIF
IF trkpnt(trkvz+3)=0 THEN
trkcok3=TRUE
ELSE
trkcok3=FALSE
ENDIF
IF trkpnt(trkvz+4)=0 THEN
trkcok4=TRUE
ELSE
trkcok4=FALSE
ENDIF
@setbutton(trakk1&,0)
@setbutton(trakk2&,0)
@setbutton(trakk3&,0)
@setbutton(trakk4&,0)
@outdrag(trakclip&,trakbox&,drmx,drmy,drtxb,drtyb,trkcart,eda,trdrag2)
IF trkcart=0 AND dmobj=trakclip& AND trdrag=FALSE AND tdrag=FALSE THEN
@setbutton(trakclip&,0)
ENDIF
IF trkcart<>0 AND trdrag2=TRUE THEN
IF dobj=trakk1& THEN
z=1
ENDIF
IF dobj=trakk2& THEN
z=2
ENDIF
IF dobj=trakk3& THEN
z=3
ENDIF
IF dobj=trakk4& THEN
z=4
ENDIF
trakact=trkvz+z
@markhlp
@alltrakcopy(trkcwert,trakact)
obj=dobj
'        @setbutton(trakclip&,0)
obj=0
ENDIF
trkcart3=0
@markhlp
ELSE
'    trdrag=FALSE
'        @setbutton(trakclip&,0)
ENDIF
@trakbutset(1)
ENDIF
IF clipart=2 AND tdrag=TRUE THEN
tdrag2=TRUE
atrkp=merkclip
@trakdrag
tdrag2=FALSE
ENDIF
@drawbutton(trakclip&)
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE edleftscroll
IF scteil=0 THEN
sdif=0
ELSE
sdif=scmax/vmem*((ce-cs)/4)
ENDIF
@slideup2(scrlslde&,scrolbut&,scmax,sdif,scrollp,slflg)
IF slflg=TRUE THEN
scrolm=ce-cs
cs=ROUND(scrollp*scteil)
ce=ROUND(scrolm+scrollp*scteil)
IF ce>vmem THEN
ce=vmem
cs=vmem-scrolm
ENDIF
cs=INT(cs/mbit)*mbit
ce=INT(ce/mbit)*mbit
cached=FALSE
@restaura
ENDIF
RETURN
'
> PROCEDURE edrightscroll
IF scteil=0 THEN
sdif=0
ELSE
sdif=scmax/vmem*((ce-cs)/4)
ENDIF
@slidedwn2(scrlslde&,scrolbut&,scmax,scstep,sdif,scrollp,slflg)
IF slflg=TRUE THEN
scrolm=ce-cs                ! Bereichgrîûe
a=ROUND(scrolm+scrollp*scteil)
IF a<=vmem THEN
ce=a
cs=ROUND(scrollp*scteil)
ELSE
cs=ROUND(vmem-scrolm)
ce=vmem
ENDIF
cs=INT(cs/mbit)*mbit
ce=INT(ce/mbit)*mbit
cached=FALSE
@restaura
ENDIF
RETURN
'
> PROCEDURE edleftzoom
@slideup(zomslide&,zoombutt&,zmax,1,16,zoomp,slflg)
IF slflg=TRUE THEN
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@zoomcalc
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
ENDIF
RETURN
'
> PROCEDURE edrightzoom
@slidedwn(zomslide&,zoombutt&,zmax,1,16,zoomp,slflg)
IF slflg=TRUE THEN
a$=RIGHT$(" "+STR$(zoomp),2)+CHR$(0)
@textbutt(zomslide&,zoombutt&,a$,1)
@zoomcalc
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
ENDIF
RETURN
'
> PROCEDURE zoomtopixel
ce=cs+(xm*mbit)-1
IF ce>vmem THEN
ce=INT(vmem/mbit)*mbit
cs=ce-(xm*mbit)+1
ENDIF
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
@scrollinit
@setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
@setbutton(pixzoom&,0)
cached=FALSE
@restaura
RETURN
'
> PROCEDURE do_smpedit
.| Glob. Var.: smpedit&,zu%,buttadr#,obj#,but#,rate&,digana#,a$,popups&
.|     smppopup&,popup&,mover&,popmark&,smpl1&,smpl2&,smpl3&,smpr1&,smpr2&
.|     smpr3&,objflag#,zuadr#,smpcblk&,pixzoom&,ce#,cs#,xm#,vmem#,zomslide&
.|     zoombutt&,zmax#,zoomp#,scrlslde&,scrolbut&,scmax#,scrollp#,cached#
.|     zooml&,slflg#,zoomr&,lscroll&,scslc#,scteil#,scrolm#,rscroll&,a#
.|     swdsp&,smplen&,smpsec&,blocfunc&,smpfile&,clock&,trak&,smpanf&
.|     smpend&,smpmid&,smpload&,smpsta&,smpstb&,smpstc&,smpstd&,smpste&
.|     smpea&,smpeb&,smpec&,smped&,smpee&,smpsave&,smpplay&,smppmark&
.|     smploop&,peaksw2&,hard&,virtual#,blkstore&,loopart&,loopauto&,edmidi&
.|     edfade&,midi&,smpsavl&,smpsavr&,smpauto2&,smpstrt2&,monitor&,arrange&
.|     setuper&,edsmp16&,infoicon&,trash&,coptoarr&,smptsa&,smptsb&,smptsc&
.|     smptsd&,smptse&,smptsava&,smptea&,smpteb&,smptec&,smpted&,smptee&
.|     smptsavb&,cstxt&,cetxt&,smpedhlp&,smpexit&,mrce#,mrcs#,mrzoom#
.|     mrscroll#
.| Ruft auf  : xrsrc_gaddr,textfeld,adlow,fnamwrite,admid,adhigh,ext32l
.|     ext44l,ext48l,ext32h,ext44h,ext48h,ext256,ext384,smpmark,smpzoom
.|     smpscrol,smpkopie,smpmove,smpinsert,smpmerge,makefade,setbutton,smpl
.|     smpr,smpcblkplay,zslidecalc,setslide,makepnt,scrollinit,restaura
.|     slideup,textbutt,zoomcalc,slidedwn,dspwahl,smplen,smpsec,blkfunc
.|     smpinfbutt,abackup,trakker,smpanf,smpend,smpmid,smpload,smpstx,smpex
.|     smpsave,smpplay,smppmark,smploop,peak,harddisk,blkstore,loopwahl
.|     loopauto,midi,fade,machmidi,smpsts,smpes,smpauto,smpstart,monitor
.|     arranger,setupdat,main,info,trash,copytoarr,time_edit,helptxt
.| Aufruf in : windows-1,
~@xrsrc_gaddr(0,smpedit&,zu%)
buttadr=zu%+24*obj
but=(DPEEK(buttadr+6)) AND 255
IF but=22 THEN
IF obj=resolu& THEN
g=0
@trash
IF g=1 THEN
IF popup&=1 THEN
@setbitrate16
ELSE
@setbitrate24
ENDIF
tdig24=dig24   ! fÅr Tracker
tmbit=mbit     ! fÅr Tracker
@fnamwrite
@hztext
@restaura3
cached=FALSE
credraw=TRUE
@curve(cs,ce)
@blkupdate
credraw=FALSE
@getcurve
ELSE
IF dig24=FALSE THEN
a$=@rsc_text$(popups&,bitp16&)
ELSE
a$=@rsc_text$(popups&,bitp24&)
ENDIF
@textfeld(resolu&,a$,1)
ENDIF
ENDIF
IF obj=rate& AND digana=TRUE THEN
@testsrate
IF (retime=0 OR (retime=1 AND tstsr=FALSE)) THEN
a$=@rsc_text$(popups&,smppopup&+popup&)
@textfeld(obj,a$,1)
IF popup&<>0 THEN
IF popup&=1 THEN
@adlow
@fnamwrite
ENDIF
IF popup&=2 THEN
@admid
@fnamwrite
ENDIF
IF popup&=3 THEN
@adhigh
@fnamwrite
ENDIF
IF popup&=4 THEN
@admid96
@fnamwrite
ENDIF
IF popup&=5 THEN
@adhigh96
@fnamwrite
ENDIF
IF popup&=6 THEN
@ad8
@fnamwrite
ENDIF
IF popup&=7 THEN
@ad11
@fnamwrite
ENDIF
IF popup&=8 THEN
@ad12
@fnamwrite
ENDIF
IF popup&=9 THEN
@ad16
@fnamwrite
ENDIF
IF popup&=10 THEN
@ad17
@fnamwrite
ENDIF
IF popup&=11 THEN
@ad22
@fnamwrite
ENDIF
IF popup&=12 THEN
@ad24
@fnamwrite
ENDIF
IF popup&=13 THEN
@ad33
@fnamwrite
ENDIF
IF popup&=14 THEN
@adexth2
@fnamwrite
ENDIF
IF popup&=15 THEN
@adextl2
@fnamwrite
ENDIF
IF popup&=16 THEN
@adexth1
@fnamwrite
ENDIF
IF popup&=17 THEN
@adextl1
@fnamwrite
ENDIF
IF popup&=18 THEN
@addiv
@fnamwrite
ENDIF
@kickstart
obj=0
ENDIF
ENDIF
ENDIF
IF obj=mover& THEN
a$=@rsc_text$(popups&,popmark&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@smpmark
ENDIF
IF popup&=2 THEN
@smpzoom
ENDIF
IF popup&=3 THEN
@smpscrol
ENDIF
IF popup&=4 THEN
@smpkopie
ENDIF
IF popup&=5 THEN
@smpmove
ENDIF
IF popup&=6 THEN
@smpinsert
ENDIF
IF popup&=7 THEN
@smpmerge
ENDIF
IF popup&=8 THEN
@makefade
ENDIF
obj=0
ENDIF
ENDIF
IF nr=smpedit& AND obj=smpexit& THEN
leaveprog=TRUE
ENDIF
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& OR obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@setbutton(obj,1)
PAUSE 1
@setbutton(obj,0)
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=smpl1& OR obj=smpl2& OR obj=smpl3& THEN
@smpl
ENDIF
IF obj=smpr1& OR obj=smpr2& OR obj=smpr3& THEN
@smpr
ENDIF
IF obj=smpcblk& THEN
@smpcblkplay
@setbutton(smpcblk&,0)
ENDIF
IF obj=disk& THEN
@diskmenu
ENDIF
IF obj=pixzoom& THEN
@zoomtopixel
ENDIF
IF obj=zooml& THEN
@edleftzoom
@setbutton(zooml&,0)
ENDIF
IF obj=zoomr& THEN
@edrightzoom
@setbutton(zoomr&,0)
ENDIF
IF obj=lscroll& THEN
@edleftscroll
@setbutton(lscroll&,0)
ENDIF
IF obj=rscroll& THEN
@edrightscroll
@setbutton(rscroll&,0)
ENDIF
IF obj=edmup& THEN
@slideup(edmslide&,edmbut&,loopz,1,5,vsms,slflg)
IF slflg=TRUE THEN
@edslidemove(vsms+1)
ENDIF
@setbutton(edmup&,0)
ENDIF
IF obj=edmdown& THEN
@slidedwn(edmslide&,edmbut&,loopz,1,5,vsms,slflg)
IF slflg=TRUE THEN
@edslidemove(vsms+1)
ENDIF
@setbutton(edmdown&,0)
ENDIF
IF obj=edmtxt& THEN
@edmtextin
ENDIF
IF obj=edmnr& THEN
k=@mousek
IF k=1 THEN
@dragedm
ELSE
vsms=@marknrinp(sms)
ENDIF
ENDIF
IF obj=csmintex& THEN
cs=0
cached=FALSE
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
mrscroll=scrollp
@restaura
ENDIF
IF obj=cemaxtex& THEN
ce=vmem
cached=FALSE
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
mrscroll=scrollp
@restaura
ENDIF
IF obj=swmark& THEN
nmarkmode=1
@setmarkmode
ENDIF
IF obj=swblk& THEN
nmarkmode=2
@setmarkmode
ENDIF
IF obj=scrubs& THEN
nmarkmode=3
@setmarkmode
ENDIF
IF obj=swsearch& THEN
nmarkmode=4
@setmarkmode
ENDIF
IF obj=swyzoom& THEN
nmarkmode=5
@setmarkmode
ENDIF
IF obj=swclick& THEN
nmarkmode=6
@setmarkmode
ENDIF
IF obj=swdraw& THEN
nmarkmode=7
@setmarkmode
ENDIF
IF bigfoot=TRUE THEN
IF obj=edcue& THEN
@cuelist
ENDIF
IF obj=edpart& THEN
@partfsel
ENDIF
ENDIF
IF obj=swdsp& THEN
@setbutton(obj,1)
@dspwahl
ENDIF
IF obj=smplen& THEN
@smplen
ENDIF
IF obj=smpsec& THEN
@smpsec
ENDIF
IF obj=blocfunc& THEN
@setbutton(obj,1)
@blkfunc
ENDIF
IF obj=smpfile& THEN
@smpinfbutt
ENDIF
IF obj=clock& THEN
@abackup
ENDIF
IF obj=trak& THEN
@setbutton(obj,1)
@trakker
ENDIF
IF obj=flyer& THEN
@dragedclip
ENDIF
IF obj=smpanf& THEN
@smpanf
ENDIF
IF obj=smpend& THEN
@smpend
ENDIF
IF obj=smpmid& THEN
@smpmid
ENDIF
IF obj=smpload& THEN
@smpload
ENDIF
IF obj=smpdbank& THEN
vneufsel=neufsel
neufsel=TRUE
@smpload
neufsel=vneufsel
ENDIF
IF obj=edmbuts& THEN
@smpstx(sms,1)
@dragedm
ENDIF
IF obj=edmbute& THEN
@smpstx(sms,2)
@dragedm
ENDIF
IF obj=edmbuti& THEN
@smpstx(sms,3)
@dragedm
ENDIF
IF obj=edmbutr& THEN
@smpstx(sms,4)
@dragedm
ENDIF
IF obj=smpsave& THEN
@smpsave
ENDIF
IF obj=smpstrt2& OR (obj=smpwait& AND (lshft=TRUE OR rshft=TRUE)) THEN
obj=smpwait&
recpaus=TRUE
@setbutton(obj,1)
obj=smpstrt2&
@setbutton(obj,1)
@smpstart
@rectocurve
recpaus=FALSE
@setbutton(smpwait&,0)
ENDIF
IF obj=smpplay& OR (obj=smpwait& AND pwait=FALSE AND lshft=FALSE AND rshft=FALSE) THEN
IF obj=smpwait& THEN
@setbutton(smpplay&,1)
pwait=TRUE
ENDIF
@smpplay
pwait=FALSE
ENDIF
IF obj=smppmark& THEN
@smppmark
ENDIF
IF obj=smploop& THEN
@smploop
ENDIF
IF obj=peaksw2& THEN
@setbutton(obj,1)
@peak
ENDIF
IF obj=hard& THEN
IF virtual=FALSE THEN
@harddisk
ELSE
@setbutton(hard&,1)
ENDIF
ENDIF
IF obj=blkstore& THEN
@blkstore
ENDIF
IF obj=loopart& THEN
@setbutton(obj,1)
@loopwahl
ENDIF
IF obj=loopauto& THEN
@loopauto
ENDIF
IF obj=edmidi& THEN
@setbutton(obj,1)
@midi
ENDIF
IF obj=edfade& THEN
@setbutton(obj,1)
@fade
ENDIF
IF obj=midi& THEN
@machmidi
ENDIF
IF obj=smpauto2& THEN
@smpauto
IF breakrec=FALSE THEN
@rectocurve
ENDIF
ENDIF
IF obj=wmodes& THEN
@setbutton(obj,1)
@workmode
ENDIF
IF obj=recplay3& THEN
@smpstart
ENDIF
IF obj=arrange& THEN
@setbutton(obj,1)
@arranger
ENDIF
IF obj=setuper& THEN
@setupdat
ENDIF
IF obj=edsmp16& THEN
@setbutton(obj,1)
@main
ENDIF
IF obj=infoicon& THEN
@setbutton(obj,1)
@info
ENDIF
IF obj=trash& THEN
@trash
ENDIF
IF obj=coptoarr& THEN
'    @copytoarr
ENDIF
IF obj=edmtims& OR obj=edmtime& OR obj=edmtimi& OR obj=edmtimr& OR obj=cstxt& OR obj=cetxt& THEN
@time_edit
@setbutton(obj,0)
ENDIF
IF obj=smpedhlp& THEN
@helptxt("EDITOR")
ENDIF
IF obj=smpstop& THEN
@setbutton(smpstop&,0)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj<>smpexit& OR nr<>smpedit& THEN
'    obj=0
but=0
popup&=0
ENDIF
IF nr=smpedit& AND (ce-cs)<>(mrce-mrcs) AND obj<>smpexit& AND mrzoom=zoomp THEN
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
ENDIF
IF nr=smpedit& AND (ce<>mrce OR cs<>mrcs) AND mrscroll=scrollp THEN
@scrollinit
@setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
mrscroll=scrollp
ENDIF
IF nr=smpedit& AND obj=smpexit& THEN
cached=FALSE
@setbutton(smpexit&,0)
ENDIF
IF drawnew=TRUE THEN
drawnew=FALSE
@getcurve
ENDIF
RETURN
'
> PROCEDURE edscrolljump
LOCAL vtmax
@testcopyright
IF NOT (cs=0 AND ce=vmem) THEN
vornr=nr
IF tedart=1 THEN
nr=timeed&
ELSE
a$="Scroll-Jump"+CHR$(0)
nr=record&
@textfeld2(record&,timemeld&,a$,1)
ENDIF
vshading=shading
shading=TRUE
dopix=TRUE
IF tedart=1 THEN
s=cs
@tedart
ELSE
mmax=INT(vmem/hz/mbit*100)
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld2(nr,recfree&,a$,1)
timekey=4
@timekey
dt=INT(cs/hz/mbit*100)
ENDIF
shading=vshading
dopix=FALSE
@rsc_draw(nr,0)
@markhlp
IF tedart=1 THEN
t=0
s=cs
REPEAT
UNTIL @mousek=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1 AND obj<>tedtxt&
edit_obj&=0
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=tedhelp& THEN
@helptxt("EDIT-SAMPLES")
ENDIF
IF obj=tedok& THEN
@tedproof
ENDIF
IF obj=tedmin& THEN
s=0
@tedart
ENDIF
IF obj=tedmax& THEN
s=vmem
@tedart
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=tedexit& OR obj=tedok& OR obj=tedmin& OR obj=tedmax& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=tedexit& OR (obj=tedok& AND notedok=FALSE)
@restaura2
IF obj=tedok& THEN
dif=ce-cs
cs=s
ce=dif+cs
IF ce>vmem THEN
cs=vmem-dif
ce=vmem
ENDIF
cs=INT(cs/mbit)*mbit
ce=INT(ce/mbit)*mbit
scrollp=INT(cs/scteil)
cached=FALSE
@setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
mrscroll=scrollp
@restaura
ENDIF
ELSE
REPEAT
@timeinp(mmax,dt)
IF obj=rechelp& THEN
@helptxt("SCROLL-JUMP")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
dif=ce-cs
cs=INT(dt/100*hz)*mbit
ce=dif+cs
IF ce>vmem THEN
cs=vmem-dif
ce=vmem
ENDIF
cs=INT(cs/mbit)*mbit
ce=INT(ce/mbit)*mbit
scrollp=INT(cs/scteil)
cached=FALSE
@setslide2(scrlslde&,scrolbut&,scmax,scrollp,scstep)
mrscroll=scrollp
@restaura
ENDIF
ENDIF
ENDIF
obj=0
RETURN
'
> PROCEDURE setmarkmode
@getmarkmode
@setbutton(omark,0)
markmode=nmarkmode
@setbutton(obj,1)
RETURN
'
> PROCEDURE getmarkmode
IF markmode=1 THEN
omark=swmark&
ENDIF
IF markmode=2 THEN
omark=swblk&
ENDIF
IF markmode=3 THEN
omark=scrubs&
ENDIF
IF markmode=4 THEN
omark=swsearch&
ENDIF
IF markmode=5 THEN
omark=swyzoom&
ENDIF
IF markmode=6 THEN
omark=swclick&
ENDIF
IF markmode=7 THEN
omark=swdraw&
ENDIF
RETURN
'
> PROCEDURE gettrmode
IF trmode=1 THEN
otmark=tblksel&
ENDIF
IF trmode=2 THEN
otmark=tblkmove&
ENDIF
IF trmode=3 THEN
otmark=tblkcopy&
ENDIF
IF trmode=4 THEN
otmark=tblkdrag&
ENDIF
IF trmode=5 THEN
otmark=tblkedit&
ENDIF
IF trmode=6 THEN
otmark=tblksnap&
ENDIF
IF trmode=7 THEN
otmark=tblkcut&
ENDIF
IF trmode=8 THEN
otmark=tblkvol&
ENDIF
RETURN
'
> PROCEDURE tmarkmode
@gettrmode
@setbutton(otmark,0)
trmode=ntrmode
@setbutton(obj,1)
RETURN
'
> PROCEDURE killdisk
@headart2(fil$)
IF sfileart<>0 THEN
@killpbfinf(fil$)
ENDIF
RETURN
'
> PROCEDURE rendisk
@editread(dskedit&)
IF a$<>"" THEN
a$=a$+"."+RIGHT$(fil$,(LEN(fil$)-RINSTR(fil$,".")))
ofil$=fil$
fil$=ordner$+a$
@headart2(fil$)
IF sfileart<>0 THEN
IF EXIST(ofil$) AND ofil$<>"" THEN
NAME ofil$ AS fil$
ENDIF
dfil2$=LEFT$(ofil$,RINSTR(ofil$,"."))+"INF"
dfil3$=LEFT$(fil$,RINSTR(fil$,"."))+"INF"
IF EXIST(dfil2$) AND dfil2$<>"" THEN
NAME dfil2$ AS dfil3$
ENDIF
dfil2$=LEFT$(ofil$,RINSTR(ofil$,"."))+"PBF"
dfil3$=LEFT$(fil$,RINSTR(fil$,"."))+"PBF"
IF EXIST(dfil2$) AND dfil2$<>"" THEN
NAME dfil2$ AS dfil3$
ENDIF
ENDIF
fil$=ofil$
ELSE
@alerts(42)
ENDIF
RETURN
'
> PROCEDURE copyfile(source$,dest$,bfadr,bfsize)
LOCAL l,rhand,whand,cpmem
OPEN "I",#5,source$
l=LOF(#5)
CLOSE #5
IF bfsize>l THEN
bfsize=l
ENDIF
rhand=GEMDOS(61,L:VARPTR(source$),0)    ! open input-sample
whand=GEMDOS(60,L:VARPTR(dest$),0)      ! open write-sample
REPEAT
~GEMDOS(63,rhand,L:bfsize,L:bfadr)    ! read input-sample
@busy_mouse
~GEMDOS(64,whand,L:bfsize,L:bfadr)    ! read input-sample
@busy_mouse
l=l-bfsize
IF l<bfsize THEN
bfsize=l
ENDIF
UNTIL l=0
~GEMDOS(62,rhand)                       ! close input-sample
~GEMDOS(62,whand)                       ! close write-sample
RETURN
'
> PROCEDURE changedisk
LOCAL ofil$,cpmem,m1,m2,cpstart
@editread(dskedit&)
IF a$<>"" THEN
a$=a$+"."+RIGHT$(fil$,(LEN(fil$)-RINSTR(fil$,".")))+CHR$(0)
ofil$=fil$+CHR$(0)
fil$=ordner$+a$
@headart2(fil$)
IF sfileart<>0 THEN
IF EXIST(ofil$) AND ofil$<>"" THEN
IF gemvers>=&H1900 THEN
m1=@mxalloc(-1,1)  ! TT-RAM
m2=@mxalloc(-1,0)  ! ST-RAM
ELSE
m1=MALLOC(-1)      ! ST-RAM
m2=0
ENDIF
IF m1>m2 THEN
cpmem=m1          ! grîûter freier Block
ELSE
cpmem=m2          ! grîûter freier Block
ENDIF
IF cpmem>&H100000 THEN
cpmem=&H100000
ENDIF
IF cpmem>32768 THEN
cpstart=@malloc(cpmem,0)
@copyfile(ofil$,fil$,cpstart,cpmem)
dfil2$=LEFT$(ofil$,RINSTR(ofil$,"."))+"INF"+CHR$(0)
dfil3$=LEFT$(fil$,RINSTR(fil$,"."))+"INF"+CHR$(0)
IF EXIST(dfil2$) AND dfil2$<>"" THEN
@copyfile(dfil2$,dfil3$,cpstart,cpmem)
ENDIF
dfil2$=LEFT$(ofil$,RINSTR(ofil$,"."))+"PBF"+CHR$(0)
dfil3$=LEFT$(fil$,RINSTR(fil$,"."))+"PBF"+CHR$(0)
IF EXIST(dfil2$) AND dfil2$<>"" THEN
@copyfile(dfil2$,dfil3$,cpstart,cpmem)
ENDIF
~MFREE(cpstart)
cpstart=0
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ELSE
@nomem
ENDIF
ENDIF
ENDIF
ELSE
@alerts(42)
ENDIF
@setbutton(dskopie&,0)
RETURN
'
> PROCEDURE diskmenu
LOCAL pathda,g
@testcopyright
mrkobj=obj
vorvornr=vornr
vornr=nr
IF neufsel=TRUE THEN
@newfsel
ELSE
@fileselect(op$+"*."+ext$,"","FIND:")
ENDIF
pathda=EXIST(fil$)
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pathda=TRUE AND pret<>0 AND pbutt=1 THEN
nr=disked&
a$=nam$+CHR$(0)
@textfeld2(nr,dskedtxt&,a$,1)
@editfeld2(nr,dskedit&,CHR$(0))
@rsc_draw(nr,0)
@markhlp
REPEAT
UNTIL @mousek=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1 AND obj<>dskedtxt&
edit_obj&=0
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=dskill& THEN
@killdisk
ENDIF
IF obj=dskren& THEN
@rendisk
ENDIF
IF obj=dskopie& THEN
@changedisk
ENDIF
IF obj=dskedhlp& THEN
@helptxt("DISK-FUNKTIONEN")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=dskedex& OR obj=dskill& OR obj=dskren& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=dskedex& OR obj=dskill& OR obj=dskren& OR obj=dskopie&
@restaura2
ENDIF
obj=mrkobj
IF nr=smpedit& THEN
@setbutton(obj,0)
ENDIF
vornr=vorvornr
RETURN
'
> PROCEDURE time_edit
LOCAL notedok,robj,o,mrkobj,vorvornr,vornr
@testcopyright
mrkobj=obj
vorvornr=vornr
vornr=nr
IF tedart=1 THEN
nr=timeed&
ELSE
a$="Marker-Time"+CHR$(0)
nr=record&
@textfeld2(record&,timemeld&,a$,1)
ENDIF
@makehz
t=0
IF obj=edmtims& THEN
t=1
ENDIF
IF obj=edmtime& THEN
t=2
ENDIF
IF obj=edmtimi& THEN
t=3
ENDIF
IF obj=edmtimr& THEN
t=4
ENDIF
IF t<>0 AND sms>0 AND sms<=loopz THEN
s=loops%(sms,t)
o=s
ENDIF
IF obj=cstxt& THEN
s=cs
t=98
ENDIF
IF obj=cetxt& THEN
s=ce
t=99
ENDIF
IF s=-1 THEN
s=0
ENDIF
vshading=shading
shading=TRUE
dopix=TRUE
IF tedart=1 THEN
@tedart
ELSE
u=INT(s/hz/mbit*100)
mmax=INT(vmem/hz/mbit*100)
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld(recfree&,a$,1)
timekey=4
@timekey
ENDIF
shading=vshading
dopix=FALSE
@rsc_draw(nr,0)
@markhlp
IF tedart=1 THEN
REPEAT
UNTIL @mousek=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1 AND obj<>tedtxt&
edit_obj&=0
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=tedhelp& THEN
@helptxt("EDIT-SAMPLES")
ENDIF
IF obj=tedok& THEN
@tedproof
ENDIF
IF obj=tedmin& THEN
s=0
@tedart
ENDIF
IF obj=tedmax& THEN
s=vmem
@tedart
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=tedexit& OR obj=tedok& OR obj=tedmin& OR obj=tedmax& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=tedexit& OR (obj=tedok& AND notedok=FALSE)
ELSE
REPEAT
REPEAT
@timeinp(mmax,u)
IF obj=rechelp& THEN
@helptxt("EDIT-SAMPLETIME")
ENDIF
UNTIL obj<>rechelp&
edit_obj&=0
IF obj=recok& THEN
s=u/100*hz*mbit
s=INT(s/mbit)*mbit
notedok=FALSE
IF s<0 OR s>vmem OR (t=98 AND s>=ce) OR (t=99 AND s<=cs) THEN
notedok=TRUE
@setbutton(obj,0)
@alerts(39)
ENDIF
ENDIF
UNTIL obj=recexit& OR (obj=recok& AND notedok=FALSE)
ENDIF
IF (obj=tedok& AND tedart=1) OR (obj=recok& AND tedart=0) THEN
IF t>0 AND t<5 AND sms>0 AND sms<=loopz THEN
loops%(sms,t)=s
ENDIF
IF t=98 THEN
cs=s
cached=FALSE
ENDIF
IF t=99 THEN
ce=s
cached=FALSE
ENDIF
ENDIF
@restaura2
IF ((obj=tedok& AND tedart=1) OR (obj=recok& AND tedart=0)) AND t>0 AND t<5 THEN
@edmarkset2(o,sms,t)
ENDIF
obj=mrkobj
IF nr=smpedit& THEN
@setbutton(obj,0)
ENDIF
vornr=vorvornr
IF (t=98 OR t=99) AND nr=smpedit& THEN
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
mrscroll=scrollp
@restaura
ENDIF
RETURN
'
> PROCEDURE tedart
.| Glob. Var.: tedart#,u#,s#,hz#,a$,tedtxt&
.| Ruft auf  : editfeld
.| Aufruf in : time_edit-3,
u=INT(s/mbit)
a$=RIGHT$("0000000000"+STR$(u),10)
a$=a$+CHR$(0)
@editfeld(tedtxt&,a$)
RETURN
'
> PROCEDURE tedproof
.| Glob. Var.: tedtxt&,notedok#,a$,i#,a#,s#,tedart#,hz#,vmem#,g#
.| Ruft auf  : editread
.| Aufruf in : time_edit-3,
@editread(tedtxt&)
notedok=FALSE
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF (a<48 OR a>57) AND a<>46 THEN
notedok=TRUE
ENDIF
IF (i=1 OR i=8) AND a=46 THEN
notedok=TRUE
ENDIF
NEXT i
ELSE
notedok=TRUE
ENDIF
IF notedok=FALSE THEN
s=VAL(a$)
s=s*mbit
s=INT(s/mbit)*mbit
IF s<0 OR s>vmem OR (t=98 AND s>=ce) OR (t=99 AND s<=cs) THEN
notedok=TRUE
@setbutton(obj,0)
@alerts(39)
ENDIF
ENDIF
RETURN
'
> PROCEDURE make                  ! von mehreren Samples die Sampleraten umrechnen und zu einem File zusammenfÅgen
.| Glob. Var.: mrkobj#,obj#,vorvornr#,vornr#,nr#,arrmake&,make$,maketxt&,hz#
.|     a$,popups&,make32&,makerate&,make44&,make48&,popup&,smpedit&,zu%
.|     zuadr#,buttadr#,but#,objflag#,makefsel&,op$,ext$,vext$,fil$,pret#
.|     pbutt#,nam$,makehelp&,makeok&,makexit&,i#,lmax2#,flen#,okay#,a2#
.|     virt$,mlen#,meml#,vln#,anf#,bytes#,len#,start#,virtp$,virtfile$
.| Felder    : arrpath$(),arrend#(),arrstrt#(),arrtri#(),arrsrate#()
.| Ruft auf  : rsc_draw,markhlp,makehz,textfeld,swtosrate,mousek,rsc_do
.|     xrsrc_gaddr,adlow,admid,adhigh,fileselect,rsc_back,helptxt,setbutton
.|     busy_mouse,arr_resmp,maschinit29,maschruf29,maschinit9,maschruf9
.|     nomem,restaura2
.| Aufruf in : do_arrange-1,
LOCAL mhz,nomem,a,b,c,d,e,mrkhz,vm
mrkobj=obj
vorvornr=vornr
vornr=nr
nr=arrmake&
vshading=shading
shading=TRUE
dopix=TRUE
@makehz
make$="             "
@textfeld(maketxt&,make$,1)
mhz=2
IF hz=32000 THEN
a$=@rsc_text$(popups&,make32&)
@textfeld(makerate&,a$,1)
mhz=1
ENDIF
IF hz=44100 THEN
a$=@rsc_text$(popups&,make44&)
@textfeld(makerate&,a$,1)
mhz=2
ENDIF
IF hz=48000 THEN
a$=@rsc_text$(popups&,make48&)
@textfeld(makerate&,a$,1)
mhz=3
ENDIF
@swtosrate(hz)
dopix=FALSE
shading=vshading
@rsc_draw(nr,0)
@markhlp
REPEAT
UNTIL @mousek=0
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(0,smpedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=(DPEEK(buttadr+6)) AND 255
UNTIL but<>0
IF obj=makerate& THEN
a$=@rsc_text$(popups&,popmake&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
mhz=1
@adlow
ENDIF
IF popup&=2 THEN
mhz=2
@admid
ENDIF
IF popup&=3 THEN
mhz=3
@adhigh
ENDIF
ENDIF
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zuadr+8)
IF obj=makefsel& THEN
@fileselect(op$+"*."+ext$,"","MAKEFILE:")
vext$=ext$
IF vext$="*" THEN
IF dig24=FALSE THEN
vext$="S16"
ELSE
vext$="S24"
ENDIF
ENDIF
IF RINSTR(fil$,".")=0 THEN
fil$=fil$+"."+vext$
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 THEN
@textfeld(maketxt&,nam$+CHR$(0),1)
ENDIF
ENDIF
IF obj=makehelp& THEN
@helptxt("MAKE")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF obj=makeok& OR obj=makexit& OR obj=makefsel& OR obj=makehelp& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=makexit& OR (obj=makeok& AND fil$<>"" AND nam$<>"")
IF obj=makeok& THEN
IF mhz=1 THEN
mhz=32000
ENDIF
IF mhz=2 THEN
mhz=44100
ENDIF
IF mhz=3 THEN
mhz=48000
ENDIF
b=0
nomem=FALSE
@busy_mouse
FOR i=1 TO lmax2
e=0
IF arrpath$(i)<>"" THEN
e=(arrend%(i)-arrstrt%(i))
IF arrtri|(i)=2 THEN
e=e+(arrend%(i)-arrstrt%(i))
ENDIF
nomem=TRUE
ENDIF
IF arrsrate%(i)<>mhz AND arrpath$(i)<>"" THEN
nomem=TRUE
mrkhz=arrsrate%(i)
e=e/mrkhz*mhz
ENDIF
b=b+e
NEXT i
@busy_mouse
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>=b THEN
okay=TRUE
ENDIF
IF nomem=TRUE AND okay=TRUE THEN
a2=ASC(LEFT$(virt$,1))-64
c=mlen
IF a=a2 THEN
c=mlen+b
ENDIF
IF @dfree(a2)>=c THEN
okay=TRUE
ELSE
okay=FALSE
ENDIF
BSAVE virt$,meml,mlen
ENDIF
IF okay=TRUE THEN
OPEN "O",#1,fil$
FOR i=1 TO lmax2
@busy_mouse
a$=arrpath$(i)
'
IF a$<>"" THEN
OPEN "I",#2,a$
IF arrtri|(i)=0 OR arrtri|(i)=2 THEN
vln=(arrend%(i)-arrstrt%(i))
anf=arrstrt%(i)
SEEK #2,anf
bytes=INT(mlen/mbit)*mbit
IF arrsrate%(i)<>mhz THEN
@arr_resmp
ELSE
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #2,meml,bytes
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
IF vln>0 THEN
BGET #2,meml,vln
BPUT #1,meml,vln
ENDIF
ENDIF
ENDIF
IF arrtri|(i)=1 OR arrtri|(i)=2 THEN
vln=(arrend%(i)-arrstrt%(i))
bytes=INT(mlen/(mbit*2))*mbit
len=bytes
start=arrend%(i)
IF arrsrate%(i)<>mhz THEN
CLOSE #1
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>=vln THEN
virtp$=CHR$(a+64)+":\"+virtfile$
OPEN "O",#1,virtp$
ELSE
okay=FALSE
ENDIF
ENDIF
IF okay=TRUE THEN
REPEAT
IF vln<len THEN
len=vln
ENDIF
start=start-len
SEEK #2,start
BGET #2,meml,len
@maschruf29(meml,meml+len)
BPUT #1,meml+len,len
vln=vln-len
UNTIL vln<1
IF arrsrate%(i)<>mhz THEN
CLOSE #1
CLOSE #2
OPEN "U",#1,fil$
SEEK #1,LOF(#1)
OPEN "I",#2,virtp$
vln=LOF(#2)
anf=0
bytes=INT(mlen/mbit)*mbit
@arr_resmp
ENDIF
ENDIF
ENDIF
CLOSE #2
IF arrsrate%(i)<>mhz AND (arrtri|(i)=1 OR arrtri|(i)=2) AND okay=TRUE THEN
KILL virtp$
ENDIF
ENDIF
NEXT i
CLOSE #1
IF nomem=TRUE AND EXIST(virt$)=TRUE THEN
BLOAD virt$,meml
KILL virt$
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF okay=FALSE AND obj<>makexit& THEN
@nomem
ENDIF
ENDIF
@restaura2
obj=mrkobj
@setbutton(obj,0)
vornr=vorvornr
RETURN
'
> PROCEDURE arr_resmp
.| Glob. Var.: f#,mhz#,e#,i#,bedarf#,okay#,drittel#,memh#,meml#,a#,fil$,vln#
.|     seekz#,anf#,bytes#,mlen#,b#,c#,d#,back%
.| Felder    : arrsrate#()
.| Ruft auf  : maschinit16,maschruf16
.| Aufruf in : make-4,
f=INT(mhz/100)
e=INT(arrsrate%(i)/100)
bedarf=f/e
okay=FALSE
drittel=(memh-meml)/(e+f)*e
drittel=INT(drittel/mbit)*mbit
IF drittel>=mbit*4 THEN
drittel=drittel-(mbit*2)
ENDIF
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>=vln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
seekz=anf
REPEAT
IF vln>=bytes THEN
IF bedarf<=1 THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=drittel
ENDIF
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
SEEK #2,seekz
IF bytes>3 THEN
BGET #2,meml,bytes
a=meml
b=meml+bytes
IF bedarf<=1 THEN
c=meml
ELSE
c=meml+bytes
ENDIF
d=memh
@maschruf16(a,b,c,d,e,f)
back%=INT(back%/mbit)*mbit
BPUT #1,c,back%-c
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
ENDIF
RETURN
'
> PROCEDURE info
.| Glob. Var.: winh#,info&,rsc_window&,vornr#,nr#,menuda#,infoicon&,g#
.|     smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,markhlp,setbutton,setbutton2
.|     rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
IF BTST(winh,info&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=info&
@setcopyright
@rsc_draw(nr,7)
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
ELSE
@setbutton(infoicon&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=info&
IF vornr=smpedit& THEN
@setbutton2(infoicon&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE setcopyright
IF XBIOS(xbs,1)=&H71273800 THEN
a=XBIOS(xbs,2)
a$=""
REPEAT
b=PEEK(a)
IF b<>0 THEN
a$=a$+CHR$(b)
ENDIF
INC a
UNTIL b=0
IF LEN(drvtyp$)>15 THEN
drvtyp$=LEFT$(drvtyp$,15)
ENDIF
a$=drvtyp$+"-AUDIODRIVER "+a$+CHR$(0)
@textfeld2(info&,cpyrdrv&,a$,1)
@textfeld2(info&,cpyright&,reg6$,1)
@hidetree3(info&,cpyright&,FALSE)
ENDIF
RETURN
'
> PROCEDURE testcopyright
LOCAL ac$
@readfeld2(info&,cpyright&)
IF rf$<>reg6$ THEN
INC tstcpr
ENDIF
@hidetree3(info&,inforeg0&,FALSE)
@hidetree3(info&,inforeg1&,FALSE)
@hidetree3(info&,inforeg2&,FALSE)
@hidetree3(info&,inforeg3&,FALSE)
@hidetree3(info&,inforeg4&,FALSE)
@readfeld3(info&,inforeg0&)
IF rf$<>reg0$+CHR$(0) THEN
INC tstcpr
ENDIF
@readfeld3(info&,inforeg1&)
IF rf$<>reg1$+CHR$(0) THEN
INC tstcpr
ENDIF
@readfeld3(info&,inforeg2&)
IF rf$<>reg2$+CHR$(0) THEN
INC tstcpr
ENDIF
@readfeld3(info&,inforeg3&)
IF rf$<>reg3$+CHR$(0) THEN
INC tstcpr
ENDIF
@readfeld3(info&,inforeg4&)
IF rf$<>reg4$+CHR$(0) THEN
INC tstcpr
ENDIF
'
~@xrsrc_gaddr(0,info&,dzu%)
nkind=(DPEEK(dzu%+24*inforeg0&))
IF nkind<>20 THEN
INC tstcpr
ENDIF
nkind=(DPEEK(dzu%+24*inforeg1&))
IF nkind<>21 THEN
INC tstcpr
ENDIF
nkind=(DPEEK(dzu%+24*inforeg2&))
IF nkind<>22 THEN
INC tstcpr
ENDIF
nkind=(DPEEK(dzu%+24*inforeg3&))
IF nkind<>23 THEN
INC tstcpr
ENDIF
nkind=(DPEEK(dzu%+24*inforeg4&))
IF nkind<>0 THEN
INC tstcpr
ENDIF
nkind2=(DPEEK(dzu%+24*inforeg5&+2))
nkind3=(DPEEK(dzu%+24*inforeg5&+4))
IF nkind2<>1 OR nkind3<>23 THEN
INC tstcpr
ENDIF
nkind2=(DPEEK(dzu%+24*inforeg6&+2))
nkind3=(DPEEK(dzu%+24*inforeg6&+4))
IF nkind2<>1 OR nkind3<>23 THEN
INC tstcpr
ENDIF
IF tstcpr<>0 THEN
@wrongcopyright
ENDIF
RETURN
'
> PROCEDURE do_info
.| Glob. Var.: obj#,zu%,objflag#,helpinfo&,infoexit&,winh#,info&,nr#
.|     smpedit&,infoicon&
.| Ruft auf  : xrsrc_gaddr,helptxt,setbutton,restaura2b
.| Aufruf in : windows-1,
~@xrsrc_gaddr(1,obj,zu%)
objflag=DPEEK(zu%+8)
IF obj=helpinfo& THEN
@helptxt("PROGRAMM-INFO")
ENDIF
IF obj=infoexit& OR obj=9999 THEN
@nonstop4
winh=BCLR(winh,info&)
@setbutton(infoexit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(infoicon&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE nonstop1
nonhz=hz
IF demo=FALSE THEN
vfil$=nonstop$+CHR$(0)
IF EXIST(vfil$) THEN
nonstop=TRUE
nofound=FALSE
playpos=0
over=0
l=0
fil2$=fil$
fil$=vfil$
tmin=0
head=0
@tstfile
nper=per
handle=GEMDOS(61,L:VARPTR(vfil$),0)
IF handle=0 THEN
nonstop=FALSE
ELSE
playpos=head+tmin
sectors=tmax-tmin
g=8
mb=sectors
'
nonstm=@malloc(sectors,1)         ! Buffer fÅr Tracker-Caches
'
IF nonstm>0 THEN
endcount=sectors-playpos
v=GEMDOS(66,L:playpos,handle,0)     ! SEEK
bw=GEMDOS(63,handle,L:sectors,L:nonstm)
ELSE
nonstop=FALSE
ENDIF
ENDIF
ELSE
nonstop=FALSE
nofound=TRUE
ENDIF
ELSE
nonstop=FALSE
ENDIF
RETURN
'
> PROCEDURE nonstop2
IF intplay=FALSE AND nofound=FALSE AND nonstop=FALSE THEN
@nonstop1
ENDIF
IF intplay=FALSE AND nonstop=TRUE THEN
@nonstop3
ENDIF
RETURN
'
> PROCEDURE nonstop3
LOCAL p,b$,g
' HARDDISK-PLAY second generation fÅr "nonstop"
'
IF demo=FALSE AND sectors>0 THEN
IF XBIOS(xbs,1)=&H71273800 THEN
vdig24=dig24
@setbitrate16
nbypmode=bypmode
hz=nper
@fliphz2
@analog
@digout(TRUE)
recback=XBIOS(xbs,122,0,L:nonstm,L:nonstm+sectors,L:0,0,1)
@write_int(1)
intplay=TRUE
peakint=FALSE
peakexit=recback+8    ! Break-Flag
ENDIF
ENDIF
RETURN
'
> PROCEDURE nonstop4
IF nonstop=TRUE THEN
intplay=FALSE
@write_int(0)
hz=nonhz
@fliphz2
@digout(nbypmode)
~GEMDOS(62,handle)
fil$=fil2$
@digout(FALSE)
~MFREE(nonstm)
nonstm=0
nofound=FALSE
nonstop=FALSE
dig24=vdig24
IF dig24=FALSE THEN
@setbitrate16
ELSE
@setbitrate24
ENDIF
ENDIF
RETURN
'
> PROCEDURE rebuild
.| Glob. Var.: nr#,smpedit&,extclock#,hz#,a$,popups&,rate32&,rate&,rate44&
.|     rate48&,sloop#,smploop&,sblock#,smppmark&,mamidi#,midi&,sms#,sme#
.| Ruft auf  : fnamwrite,textfeld,adlow,admid,adhigh,fliphz,setbutton
.|     selblksbut,selblkebut
.| Aufruf in : trash-2,
@fnamwrite
IF nr=smpedit& THEN
@fliphz
@fliphz2
IF sloop!=FALSE THEN
@setbutton(smploop&,0)
ELSE
@setbutton(smploop&,1)
ENDIF
IF sblock=0 THEN
@setbutton(smppmark&,0)
ELSE
@setbutton(smppmark&,1)
ENDIF
IF mamidi=0 THEN
@setbutton(midi&,0)
ELSE
@setbutton(midi&,1)
ENDIF
@edmarkset(sms)
ENDIF
RETURN
'
> PROCEDURE trashvirt
op$=rop$
virtual=FALSE
virtcurve=FALSE
virtld=FALSE
blockld=FALSE
cached=FALSE
@markhlp
maxcwert=0
ce=mlen
cs=0
vmem=INT(mlen-1)
@infmemkill
'
IF rettfound=FALSE THEN
@maschruf9(meml,memh)   ! Delete Memory
ENDIF
'
@markdel
@clsed
@busy_mouse
IF ldtrk=FALSE THEN
@getmem
ENDIF
IF hz=0 THEN
@makehz
ENDIF
IF smplen=0 THEN
smplen=mlen
ENDIF
IF path$="" OR INSTR(path$,":")=0 OR INSTR(path$,"\")=0 THEN
smpnam$="MEMORY."+ext2$
path$=lfw$+smpnam$
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
hrd=0
IF nr=smpedit& THEN
@setbutton(hard&,0)
ENDIF
@rebuild
RETURN
'
> PROCEDURE infmemkill
infname$=""
b$=""
IF dig24=FALSE THEN
fil$=s$+"MEMORY.S16"
bnam$="MEMORY.S16"
ELSE
fil$=s$+"MEMORY.S24"
bnam$="MEMORY.S24"
ENDIF
enam$=bnam$
efil$=fil$
loded=FALSE
vpath$=fil$
path$=vpath$
vsmpnam$=bnam$
smpnam$=vsmpnam$
vordner$=s$
ordner$=s$
@infmemkill2
RETURN
'
> PROCEDURE infmemkill2
LOCAL i,j
commtxt$=CHR$(0)
srctxt$=CHR$(0)
comm$=""
src$=""
FOR i=1 TO bloopz
FOR j=1 TO 4
bloops%(i,j)=-1
vbloops%(i,j)=-1
NEXT j
NEXT i
RETURN
'
> PROCEDURE trash
.| Glob. Var.: mbs#,zoomp#,v#,v2#,v3#,v4#,virtual#,g#,op$,rop$,virtcurve#
.|     virtld#,blockld#,cached#,maxcwert#,ce#,mlen#,cs#,vmem#,hz#,smplen#
.|     path$,smpnam$,ext2$,lfw$,hrd#,nr#,smpedit&,hard&,rett#,meml#,memh#,i#
.|     lmax2#,lz#,trash&
.| Felder    : arrpath$(),arrfn$(),arrstrt#(),arrend#(),arrlen#(),arrloop#()
.|     arrtri#()
.| Ruft auf  : smph3,markhlp,markdel,clsed,busy_mouse,getmem,makehz
.|     setbutton,rebuild,blocklook,maschinit9,maschruf9,zslidecalc,restaura
.| Aufruf in : hardproof2-1,do_smpedit-1,
'  LOCAL g
IF ldtrk3=FALSE THEN
mbs=0
zoomp=0
IF trashalert=FALSE THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4=1 OR v4=2 THEN   ! linke oder rechte Shift
@smph3
ENDIF
ELSE
v4=0
ENDIF
IF v4<>1 AND v4<>2 THEN
IF virtual=TRUE THEN
IF trashalert=FALSE THEN
@alerts(43)
IF g=1 THEN
@trashvirt
ENDIF
ELSE
@trashvirt
g=1
ENDIF
ELSE
IF trashalert=FALSE THEN
IF rett=TRUE THEN
@alerts(44)
ELSE
@alerts(45)
ENDIF
ELSE
g=1
ENDIF
IF g=1 THEN
@infmemkill
cached=FALSE
@markhlp
@blocklook
@maschruf9(meml,memh)   ! Delete Memory
@markdel
@clsed
ENDIF
IF rett=TRUE AND g=1 THEN
rett=FALSE
@busy_mouse
@getmem
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
IF g=1 THEN
@rebuild
ENDIF
ENDIF
lz=1
zoomp=0
IF g=1 THEN
@zslidecalc
@restaura
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@setbutton(trash&,0)
RETURN
'
> PROCEDURE sourcein
IF nr=smp16& THEN
IF dighead=TRUE THEN
@setbutton(digmark&,1)
ELSE
@setbutton(digmark&,0)
ENDIF
ENDIF
IF dspw=0 THEN
@dspoff
ENDIF
IF dspw=1 THEN
@dspin
ENDIF
IF dspw=2 THEN
@dspout
ENDIF
IF digsource=0 THEN
@opto
ENDIF
IF digsource=1 THEN
@coax
ENDIF
IF digsource=2 THEN
@aesebu
ENDIF
IF empha=FALSE THEN
@emphoff
ENDIF
IF empha=TRUE THEN
@emphon
ENDIF
IF scmsw=0 THEN
@scmsno
ENDIF
IF scmsw=1 THEN
@scmsone
ENDIF
IF scmsw=2 THEN
@scmsfree
ENDIF
IF proffm=FALSE THEN
proffm=TRUE
@consumer
ENDIF
IF proffm=TRUE THEN
proffm=FALSE
@profess
ENDIF
IF bridge=FALSE THEN
bridge=TRUE
ELSE
bridge=FALSE
ENDIF
@digibridge
bfadericht=fadericht
IF fadewin=-1 THEN
@infade
ENDIF
IF fadewin=0 THEN
@infade
@fadelinear
ENDIF
IF fadewin=1 THEN
@infade
@fadesquare
ENDIF
IF fadewin=2 THEN
@infade
@fadexp
ENDIF
IF fadewin=3 THEN
@infade
@fadesqrt
ENDIF
IF fadewin=4 THEN
@infade
@fadelog
ENDIF
IF fadewout=0 THEN
@ausfade
@fadelinear
ENDIF
IF fadewout=-1 THEN
@ausfade
ENDIF
IF fadewout=1 THEN
@ausfade
@fadesquare
ENDIF
IF fadewout=2 THEN
@ausfade
@fadexp
ENDIF
IF fadewout=3 THEN
@ausfade
@fadesqrt
ENDIF
IF fadewout=4 THEN
@ausfade
@fadelog
ENDIF
fadericht=bfadericht
IF fadericht=0 THEN
@infade
ELSE
@ausfade
ENDIF
IF ad=0 THEN
@digital
ELSE
@analog
ENDIF
RETURN
'
> PROCEDURE setupdat
.| Glob. Var.: vornr#,nr#,setup&,obj#,popup&,zu%,zuadr#,x#,y#,v3#,lenmall&
.|     edit_obj&,buttadr#,but#,objadr#,objflag#,timeset&,setshow&,posy&
.|     vertline&,frec&,zerosnap&,zoomy&,linkdot&,freeze&,spacefil&,menuset&
.|     sync&,extclock#,fseldef&,secl&,secr&,flip&,dreide&,grid&,sram&
.|     mallmax&,recl&,recr&,tresl&,tresr&,setsave&,setload&,wavset&,avrset&
.|     sndset&,auset&,smpset&,allset&,sdset&,sets16&,sethelp&,setexit&
.|     setok&,a$,memmx#,digana#,vdigana#,op$,vop$,fastrec#,vfastrec#,menuda#
.|     vmenuda#,flen#,vflen#,sramda#,vsramda#,min#,vmin#,mallmax#,vmallmax#
.|     th#,vth#,dreidim#,vdreidim#,grids#,vgrid#,ext$,vext$,flipp#,vflipp#
.|     uhr#,vuhr#,show#,vshow#,yline#,vyline#,vertline#,vvertline#,linkdot#
.|     vlinkdot#,spacefill#,vspacefill#,zsnap#,vzsnap#,yzoom#,vyzoom#,freez#
.|     vfreez#,smpedit&,setuper&,clock&,showxy&,stl#
.| Ruft auf  : rsc_draw,markhlp,setdat,rsc_do,xrsrc_gaddr,mouse,timeset
.|     showset,setyline,vertline,fastrec,zerosnap,yautozoom,linkdot,freeze
.|     spacefill,menuset,sync,fseldef,secbutt,flipp,dreide,grid,sram,mallmax
.|     recbutt,tresbutt,setsave,setload,extender,helptxt,editread,setbutton
.|     restaura2,textfeld,smpfree,write_reglow,makehz,sethertz
.| Aufruf in : drop2-1,do_smpedit-1,
@testcopyright
vornr=nr
nr=setup&
vshading=shading
shading=TRUE
dopix=TRUE
@setdat
dopix=FALSE
shading=vshading
vemula2=emula
vneufsel=neufsel
vvol=vol
vvol2=vol2
vvolinbal=volinbal
vvolinbal2=volinbal2
vad=ad
vhz=hz
vdigsource=digsource
vproffm=proffm
vscmsw=scmsw
vempha=empha
vbridge=bridge
vdspw=dspw
vnote=note
vch=ch
vrecmax=recmax
vblkrmax=blkrmax
vfadewin=fadewin
vfadewout=fadewout
vfadericht=fadericht
vspc=spc
vnorma=norma
vdb=db
vresoth=resoth
vadjresmp=adjresmp
vrealtime=realtime
@rsc_draw(nr,0)
@markhlp
'
REPEAT
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1 AND obj<>lenmall&
edit_obj&=0
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
UNTIL but<>0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
IF but=22 THEN
IF obj=setform& AND digana=TRUE THEN
a$=@rsc_text$(popups&,popform&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
IF dig24=FALSE THEN
vext$="S16"
ELSE
vext$="S24"
ENDIF
ENDIF
IF popup&=2 THEN
vext$="WAV"
ENDIF
IF popup&=3 THEN
vext$="AVR"
ENDIF
IF popup&=4 THEN
vext$="AIF"
ENDIF
IF popup&=5 THEN
vext$="SND"
ENDIF
IF popup&=6 THEN
vext$="SD"
ENDIF
IF popup&=7 THEN
vext$="AU"
ENDIF
IF popup&=8 THEN
vext$="SMP"
ENDIF
IF popup&=9 THEN
vext$="*"
ENDIF
ENDIF
ENDIF
IF obj=timeset& THEN
@timeset
ENDIF
IF obj=viewset& THEN
@viewset
ENDIF
IF obj=setshow& THEN
@showset
ENDIF
IF obj=emulset& THEN
@emulset
ENDIF
IF obj=posy& THEN
@setyline
ENDIF
IF obj=vertline& THEN
@vertline
ENDIF
IF obj=frec& THEN
@flickerfix
ENDIF
IF obj=zerosnap& THEN
@zerosnap
ENDIF
IF obj=zoomy& THEN
@yautozoom
ENDIF
IF obj=linkdot& THEN
@linkdot
ENDIF
IF obj=freeze& THEN
@freeze
ENDIF
IF obj=spacefil& THEN
@spacefill
ENDIF
IF obj=menuset& THEN
@menuset
ENDIF
IF obj=sync& THEN
IF extclock=FALSE THEN
@sync
ENDIF
ENDIF
IF obj=fseldef& THEN
@fseldef
ENDIF
IF obj=secl& OR obj=secr& THEN
@secbutt
ENDIF
IF obj=flip& THEN
@flipp
ENDIF
IF obj=rmaxim& THEN
@setrecmax
ENDIF
IF obj=viewcalc& THEN
@setviewcache
ENDIF
IF obj=setblmax& THEN
@setblkrmax
ENDIF
IF obj=dreide& THEN
@dreide
ENDIF
IF obj=grid& THEN
@grid
ENDIF
'    IF obj=sram& THEN
'    @sram
'  ENDIF
IF obj=nfsbut& THEN
@fselwahl
ENDIF
IF obj=mallmax& THEN
@mallmax
ENDIF
IF obj=recl& OR obj=recr& THEN
@recbutt
ENDIF
IF obj=tresl& OR obj=tresr& THEN
@tresbutt
ENDIF
IF obj=setsave& THEN
@setsave
ENDIF
IF obj=setload& THEN
@setload
@setdat
ENDIF
IF obj=sethelp& THEN
@helptxt("SETUP")
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
UNTIL obj=setexit& OR obj=setok&
IF obj=setexit& THEN
vol=vvol
vol2=vvol2
volinbal=vvolinbal
volinbal2=vvolinbal2
ad=vad
hz=vhz
digsource=vdigsource
proffm=vproffm
scmsw=vscmsw
empha=vempha
bridge=vbridge
dspw=vdspw
note=vnote
ch=vch
fadewin=vfadewin
fadewout=vfadewout
fadericht=vfadericht
spc=vspc
norma=vnorma
db=vdb
resoth=vresoth
adjresmp=vadjresmp
realtime=vrealtime
@sourcein
ENDIF
IF obj=setok& THEN
@editread(lenmall&)
memmx=INT(1024*VAL(a$))
digana=vdigana
op$=vop$
flicker=vflicker
menuda=vmenuda
flen=vflen
sramda=vsramda
min=vmin
recmax=vrecmax
recpkc=vrecpkc
@setrecpkc
blkrmax=vblkrmax
rtime=min*60*100
mallmax=vmallmax
th=vth
dreidim=vdreidim
grids=vgrid
ext$=vext$
flipp=vflipp
uhr=vuhr
tedart=vtedart
show=vshow
emula=vemula
yline=vyline
vertline=vvertline
linkdot=vlinkdot
spacefill=vspacefill
beeper=vbeeper
yzoom=vyzoom
freez=vfreez
neufsel=vneufsel
IF vemula2<>emula THEN
@emulset2
ENDIF
ENDIF
IF extclock=TRUE THEN
digana=TRUE
ENDIF
@setbutton(obj,0)
@restaura2
obj=0
IF nr=smpedit& THEN
@setbutton(setuper&,0)
@textfeld(clock&,SPACE$(8)+CHR$(0),1)
@textfeld(showxy&,SPACE$(13)+CHR$(0),1)
@smpfree
@minwrite
ENDIF
IF digana=FALSE AND demo=FALSE THEN
~XBIOS(xbs,20,ad)         ! Analog oder Digitaleingang benutzen
~XBIOS(xbs,21,digsource)  ! Opto,Koax oder AESEBU benutzen
~XBIOS(xbs,23,0)          ! Taktrate=spdif
ENDIF
@makehz
@sethertz
RETURN
'
> PROCEDURE setload
.| Glob. Var.: setup$,vol#,memmx#,digana#,op$,flen#,sramda#,min#,mallmax#
.|     th#,dreidim#,grids#,ext$,flipp#,uhr#,show#,aback#,abacknam#,btime#
.|     yline#,vertline#,linkdot#,spacefill#,zsnap#,yzoom#,fastrec#,menuda#
.|     freez#,winh#,ctree#,i#,lfw$,back#,backnam#,rop$,obj#,setload&,nr#
.|     setup&
.| Felder    : rx#(),ry#()
.| Ruft auf  : busy_mouse,fadeset,setbutton
.| Aufruf in : HAUPTPROGRAMM-1,setupdat-1,
newmem=FALSE
'
mislide=TRUE      ! Midi-Controller
mcc=7             ! Midi-Control-Channel (Preset of Peavey PC1600x)
recpkc=TRUE       ! Peakberechnung wÑhrend der Aufnahme
psec=6            ! AbschwÑchwert-Verzîgerung Peakmeter in 100tel Sekunden
prest=0.96        ! AbschwÑchwert Peakmeter relativ zum bisherigen Wert
pschwell=5        ! Schwellwert zur Erkennung von abfallendem Peakwert
playch=3          ! WiedergabekanÑle (l/r/stereo)
zsnap=TRUE        ! Zero Xsnap
beeper=FALSE      ! Record-Beeper
plead=10          ! sec play-anspielzeit
mwmin=&H20000     ! Mindest-Samplespeicher
tmlen=&H200000    ! 2 MB-Tracker-Cache
mrest=&H40000     ! Mindestrest-Speicher fÅr andere Applikationen
lmax=100          ! Feldgrîûe fÅr SCROLL
lmax2=100         ! Feldgrîûe fÅr ARRANGER
lmax3=500         ! Feldgrîûe fÅr TRAKKER-Files und loaded-Samples im Editor
lmax4=100         ! Feldgrîûe fÅr File-Datenbank
trkvmax=100       ! Feldgrîûe fÅr Anzahl virtuelle Spuren
hzkey=FALSE            ! blockiere Samplerate bei Virtual-Load
'
@maxhdsec
IF EXIST(setup$) THEN
@busy_mouse
OPEN "I",#1,setup$
INPUT #1,setv$              !  "STARTRACK-SETUP V1.0"  Versionskontrolle
IF MID$(setv$,LEN(setv$)-3,1)="V" THEN
prgversion=VAL(RIGHT$(setv$,3))
ELSE
prgversion=0
ENDIF
IF prgversion<2 THEN
INPUT #1,language
INPUT #1,vol
INPUT #1,vol2
INPUT #1,volinbal
INPUT #1,volinbal2
INPUT #1,balinmax
INPUT #1,ad
INPUT #1,hz
INPUT #1,digsource
INPUT #1,proffm
INPUT #1,scmsw
INPUT #1,empha
INPUT #1,bridge
INPUT #1,dspw
INPUT #1,note
INPUT #1,ch
INPUT #1,fadewin
INPUT #1,fadewout
INPUT #1,fadericht
INPUT #1,tedart
INPUT #1,spc
INPUT #1,norma
INPUT #1,db
INPUT #1,resoth
INPUT #1,adjresmp
INPUT #1,realtime
INPUT #1,deltime
INPUT #1,memmx
INPUT #1,digana
INPUT #1,op$
INPUT #1,flen
IF flen>4 OR flen=0 THEN
flen=2
ENDIF
INPUT #1,sramda
INPUT #1,min
INPUT #1,mallmax
INPUT #1,th
INPUT #1,dreidim
INPUT #1,grids
INPUT #1,ext$
INPUT #1,flipp
INPUT #1,uhr
INPUT #1,show
INPUT #1,aback
INPUT #1,abacknam
INPUT #1,btime
INPUT #1,yline
INPUT #1,vertline
INPUT #1,linkdot
INPUT #1,spacefill
INPUT #1,zsnap
INPUT #1,yzoom
INPUT #1,flicker
INPUT #1,menuda
INPUT #1,freez
INPUT #1,winh
IF freez=FALSE THEN
winh=0
ENDIF
INPUT #1,neufsel
IF prgversion>=1.1 THEN          ! Versionskontrolle
INPUT #1,adat
INPUT #1,fmclk
INPUT #1,bigram
INPUT #1,dig24
tdig24=dig24
IF dig24=TRUE THEN
tmbit=6
mbit=6
ELSE
tmbit=4
mbit=4
ENDIF
INPUT #1,mod96
INPUT #1,rch4
INPUT #1,rmo8
INPUT #1,matrix
INPUT #1,mixdsp
INPUT #1,synchertz
INPUT #1,pcg
INPUT #1,emula
INPUT #1,mtc
INPUT #1,sendsmpte
INPUT #1,framez
INPUT #1,smptestrt
ENDIF
IF prgversion<1.2 THEN          ! Versionskontrolle
INPUT #1,ctree
FOR i=0 TO ctree
INPUT #1,rx(i)
INPUT #1,ry(i)
NEXT i
ELSE
FOR i=0 TO 31
rx(i)=0
ry(i)=0
rb(i)=0
rh(i)=0
NEXT i
INPUT #1,rx(smpedit&)
INPUT #1,ry(smpedit&)
INPUT #1,rx(info&)
INPUT #1,ry(info&)
INPUT #1,rx(smp16&)
INPUT #1,ry(smp16&)
INPUT #1,rx(blkfunc&)
INPUT #1,ry(blkfunc&)
INPUT #1,rx(peak&)
INPUT #1,ry(peak&)
INPUT #1,rx(arranger&)
INPUT #1,ry(arranger&)
INPUT #1,rx(trakker&)
INPUT #1,ry(trakker&)
INPUT #1,rx(loop&)
INPUT #1,ry(loop&)
INPUT #1,rx(dspedit&)
INPUT #1,ry(dspedit&)
INPUT #1,rx(editfade&)
INPUT #1,ry(editfade&)
INPUT #1,rx(wmode&)
INPUT #1,ry(wmode&)
INPUT #1,rx(plugin&)
INPUT #1,ry(plugin&)
INPUT #1,rx(mixer&)
INPUT #1,ry(mixer&)
FOR i=13 TO 31
INPUT #1,v
INPUT #1,v
NEXT i
INPUT #1,rb(smpedit&)
INPUT #1,rh(smpedit&)
INPUT #1,rb(info&)
INPUT #1,rh(info&)
INPUT #1,rb(smp16&)
INPUT #1,rh(smp16&)
INPUT #1,rb(blkfunc&)
INPUT #1,rh(blkfunc&)
INPUT #1,rb(peak&)
INPUT #1,rh(peak&)
INPUT #1,rb(arranger&)
INPUT #1,rh(arranger&)
INPUT #1,rb(trakker&)
INPUT #1,rh(trakker&)
INPUT #1,rb(loop&)
INPUT #1,rh(loop&)
INPUT #1,rb(dspedit&)
INPUT #1,rh(dspedit&)
INPUT #1,rb(editfade&)
INPUT #1,rh(editfade&)
INPUT #1,rb(wmode&)
INPUT #1,rh(wmode&)
INPUT #1,rb(plugin&)
INPUT #1,rh(plugin&)
INPUT #1,rb(mixer&)
INPUT #1,rh(mixer&)
FOR i=13 TO 31
INPUT #1,v
INPUT #1,v
NEXT i
ENDIF
INPUT #1,hpath$
IF prgversion>=1.3 THEN          ! Versionskontrolle
INPUT #1,phold
INPUT #1,recmax
ENDIF
ELSE
@newsetload
ENDIF
CLOSE #1
nosetload=FALSE
ELSE
FOR i=0 TO 31
rx(i)=0
ry(i)=0
rb(i)=0
rh(i)=0
NEXT i
prgversion=0
nosetload=TRUE
'
recpkc=TRUE            ! Samplecache wÑhrend Aufnahme berechnen
recmax=TRUE            ! maximale AufnahmelÑnge
blkrmax=FALSE          ! maximale Blockgrîûe bei Aufnahme und Wiedergabe
playch=3               ! Wiedergabe links/rechts/stereo
phold=3                ! Peakhold-Time (0-15)
neufsel=FALSE          ! neuen older alten Fileselektor benutzen ?
digsource=0            ! Digitalanschluû-Art
proffm=FALSE           ! Consumer/Profi-Mode
scmsw=0                ! SCMS-Copymanagement (0..2)
empha=FALSE            ! Emphasis
bridge=FALSE           ! Digitalkonvertierung umgehen
dspw=0                 ! DSP none/in/out
note=36                ! Midi-Note
ch=1                   ! Midi-Kanal
fadewin=0              ! Fader-Art Einblendung
fadewout=0             ! Fader-Art Ausblendung
fadericht=0            ! Fader-Richtung
tedart=0               ! Art der Zeitangabe in Samples oder Sekunden
aback=0                ! Auto-Backup
abacknam=0             ! Original-Filenamen fÅr Auto-Backup
hz=44100               ! Sample-Rate
vol=128+64             ! volume-control A/D
vol2=128+64            ! volume-control D/A
balinmax=24            ! halbe Breite des Balance-Reglers
volinbal=0             ! Stellung des A/D-Balance-Reglers
volinbal2=0            ! Stellung des D/A-Balance-Reglers
ad=1                   ! Analog-Eingang benutzen
memmx=&H80000          ! Wenn mallmax=FALSE,dann memmx-Speicher anfordern
newmem=-1
digana=TRUE            ! wenn TRUE, dann DIGITAL->ANALOG-Umschaltung bei Wiedergabe
op$=lfw$               ! Default-Zugriffspfad
flen=12                ! Sektorblîcke (* max.sektorlÑnge)
sramda=FALSE           ! wenn TRUE, dann SRAM vorhanden
min=4                  ! RECORD-Aufnahmezeit in Minuten
rtime=min*60*100
mallmax=FALSE          ! TRUE, wenn maximalen Speicher anfordern
th=257                 ! Schwelle fÅr AUTO-RECORD
dreidim=1              ! 3D-OberflÑche
grids=1                ! Hintergrundmuster fÅr Wellenfenster
dighead=FALSE          ! DAT-Startmarker
flipp=TRUE             ! Einstellung fÅr Copy/move-Auswahlleiste
uhr=TRUE               ! Uhrzeitanzeige
show=TRUE              ! Anzeige der Position in Samples
back=FALSE             ! Auto-Backup
backnam=FALSE          ! Original-Filenamen fÅr Auto-Backup
btime=5                ! Backup-Zeitlimit
yline=TRUE             ! Vertikale Markierung im Wellenfenster
vertline=TRUE          ! Darstellung der Samples als Pegel
linkdot=TRUE           ! Verbindung der Samples durch Linie
spacefill=TRUE         ! FÅllung der Samples
zsnap=TRUE             ! Suchen von Nullpunkten
beeper=FALSE           ! Aufnahme-Beep ja/nein
yzoom=FALSE            ! Autozoom fÅr Samples
flicker=FALSE          ! VSYNC fÅr flimmerfreien Redraw
menuda=TRUE            ! MenÅzeile
freez=TRUE             ! Fensterpositionen merken und Fenster automatisch îffnen
spc=3                  ! Space-Time
norma=1                ! Normalize Adjust/Auto
db=-6                  ! Normalize-Wert -6dB
resoth=48              ! Resampling-Wert 48kHz
adjresmp=FALSE         ! Adjust resample-rate
realtime=FALSE         ! Echtzeit fÅr Arranger
'
adat=FALSE             ! ADAT-synchronize
fmclk=FALSE            ! Falconclock (weniger Sampleraten anbieten)
bigram=FALSE           ! DSP 128K oder 32K
dig24=FALSE            ! 16 oder 24Bit
mbit=4                 ! Bytes pro Stereosample
tdig24=dig24
tmbit=mbit
IF dig24=FALSE THEN
ext$="S16"             ! Fileextender fÅr Soundfiles
ELSE
ext$="S24"             ! Fileextender fÅr Soundfiles
ENDIF
mod96=FALSE            ! Wiedergabe mit highsampling(88.2/96 kHz)
rch4=FALSE             ! Vierkanal-Aufnahme
rmo8=FALSE             ! Achtkanal-Aufnahme
matrix=TRUE            ! Play Åber Matrix
mixdsp=FALSE           ! Play Åber DSP and mix
synchertz=24576000     ! External Masterclock
pcg=FALSE              ! Programm. Clockgenerator
emula=FALSE            ! Falcon TOS-Emulation
mtc=FALSE              ! Midi-Timecode Synchronize
sendsmpte=FALSE        ! MTC-Code senden ja/nein
framez=25              ! SMPTE-Frames
smptestrt=0            ! Startoffset SMPTE
'
winh=0
hpath$=op$+"1STGUIDE.IDX"  ! Pfad des Helpfile-Systems
ENDIF
IF dig24=FALSE THEN
mbit=4
tmbit=mbit
tdig24=dig24
aufloes=db16
ELSE
mbit=6
tmbit=mbit
tdig24=dig24
aufloes=db24
ENDIF
IF spacefill=FALSE AND vertline=FALSE AND linkdot=FALSE THEN
spacefill=TRUE
ENDIF
IF balinmax=0 THEN
balinmax=19
ENDIF
@fadeset
@emulset2
@mtcsetup
rop$=op$
IF pcg=TRUE THEN
a=INT(synchertz/512)
@setpcg(a)
ENDIF
IF obj=setload& AND nr=setup& THEN
@setbutton(obj,0)
@setrecpkc
nr=peak&
dopix=TRUE
~@xrsrc_gaddr(0,peak&,zu%)
balinmax=DPEEK(zu%+24*balbox&+20)                    ! Breite der Balancebox in Pixeln
balinmax=INT((balinmax-25)/2)
@balwrite(vol,volinbal,balinmax)
@balwrite2(vol2,volinbal2,balinmax)
@setplaychannels
@sourcein
nr=setup&
dopix=FALSE
ENDIF
rtime=min*60*100
RETURN
'
> PROCEDURE setrecpkc
IF demo=FALSE THEN
IF recpkc=TRUE THEN
~XBIOS(xbs,152,0)
ELSE
~XBIOS(xbs,152,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE maxhdsec
maxhdsec=8192
puninfo=LPEEK(1302)
ahdi=LPEEK(puninfo+82)
IF ahdi=&H41484449 THEN
maxhdsec=DPEEK(puninfo+92)
ENDIF
RETURN
'
> PROCEDURE setdat
.| Glob. Var.: extclock#,digana#,vmenuda#,menuda#,vfastrec#,fastrec#
.|     vdigana#,vop$,op$,vflen#,flen#,vsramda#,sramda#,vmin#,min#,vmallmax#
.|     mallmax#,vth#,th#,vdreidim#,dreidim#,vgrid#,grids#,vext$,ext$,vflipp#
.|     flipp#,vuhr#,uhr#,vshow#,show#,vyline#,yline#,vvertline#,vertline#
.|     vlinkdot#,linkdot#,vspacefill#,spacefill#,vzsnap#,zsnap#,vyzoom#
.|     yzoom#,vfreez#,freez#,oop$,a#,fseltxt&,f$,seclen&,recm&,tdb#,aufloes#
.|     tdb$,tresdb&,sdset&,avrset&,sndset&,auset&,smpset&,sets16&,wavset&
.|     allset&,sync&,dreide&,frec&,posy&,menuset&,zoomy&,grid&,freeze&,sram&
.|     flip&,setshow&,zerosnap&,timeset&,linkdot&,vertline&,spacefil&
.|     mallmax&,a$,memmx#,lenmall&
.| Ruft auf  : textfeld,setbutton,editfeld
.| Aufruf in : setupdat-2,
~GRAF_MOUSE(256,0)                              ! Hidem
IF extclock=TRUE THEN
digana=TRUE
ENDIF
vneufsel=neufsel
vmenuda=menuda
vflicker=flicker
vdigana=digana
vop$=op$
vflen=flen
vsramda=sramda
vmin=min
vmallmax=mallmax
vrecpkc=recpkc
vth=th
vdreidim=dreidim
vgrid=grids
vext$=ext$
vflipp=flipp
vtedart=tedart
vuhr=uhr
vshow=show
vemula=emula
vyline=yline
vvertline=vertline
vlinkdot=linkdot
vspacefill=spacefill
vbeeper=beeper
vyzoom=yzoom
vfreez=freez
IF LEN(op$)>57 THEN
oop$=RIGHT$(op$,57)
a=INSTR(oop$,"\")
oop$=RIGHT$(oop$,LEN(oop$)-(a-1))
ELSE
oop$=op$
ENDIF
@textfeld(fseltxt&,oop$+CHR$(0),1)
'
@maxhdsec
f$="("+STR$(maxhdsec)+")"+CHR$(0)
@textfeld(maxhd&,f$,1)
f$=RIGHT$(SPACE$(5)+STR$(flen),5)+CHR$(0)
@textfeld(seclen&,f$,1)
'
f$=RIGHT$(SPACE$(5)+STR$(min),5)+CHR$(0)
@textfeld(recm&,f$,1)
tdb=th
IF dig24=TRUE THEN
tdb=SHL(tdb,8)
ENDIF
tdb=20*LOG10(tdb*2)
tdb=tdb-aufloes
tdb=INT(tdb*1000)/1000
tdb$=STR$(tdb)+CHR$(0)
@textfeld(tresdb&,tdb$,1)
IF ext$="SD" THEN
a$=@rsc_text$(popups&,setsd&)
ENDIF
IF ext$="AVR" THEN
a$=@rsc_text$(popups&,setavr&)
ENDIF
IF ext$="AIF" THEN
a$=@rsc_text$(popups&,setaif&)
ENDIF
IF ext$="SND" THEN
a$=@rsc_text$(popups&,setsnd&)
ENDIF
IF ext$="AU" THEN
a$=@rsc_text$(popups&,setau&)
ENDIF
IF ext$="SMP" THEN
a$=@rsc_text$(popups&,setsmp&)
ENDIF
IF ext$="S16" OR ext$="S24" THEN
a$=@rsc_text$(popups&,sets16&)
ENDIF
IF ext$="WAV" THEN
a$=@rsc_text$(popups&,setwav&)
ENDIF
IF ext$="*" THEN
a$=@rsc_text$(popups&,setall&)
ENDIF
@textfeld(setform&,a$,1)
IF digana=FALSE THEN
IF extclock=TRUE THEN
@setbutton(sync&,9)
ELSE
@setbutton(sync&,1)
ENDIF
ELSE
IF extclock=TRUE THEN
@setbutton(sync&,8)
ELSE
@setbutton(sync&,0)
ENDIF
ENDIF
IF tedart=1 THEN
@setbutton(viewset&,1)
ELSE
@setbutton(viewset&,0)
ENDIF
IF dreidim=1 THEN
@setbutton(dreide&,1)
ELSE
@setbutton(dreide&,0)
ENDIF
IF recmax=TRUE THEN
@setbutton(rmaxim&,0)
ELSE
@setbutton(rmaxim&,1)
ENDIF
IF recpkc=TRUE THEN
@setbutton(viewcalc&,1)
ELSE
@setbutton(viewcalc&,0)
ENDIF
IF blkrmax=TRUE THEN
@setbutton(setblmax&,0)
ELSE
@setbutton(setblmax&,1)
ENDIF
IF flicker=FALSE THEN
@setbutton(frec&,0)
ELSE
@setbutton(frec&,1)
ENDIF
IF yline=TRUE THEN
@setbutton(posy&,1)
ELSE
@setbutton(posy&,0)
ENDIF
IF menuda=TRUE THEN
@setbutton(menuset&,1)
ELSE
@setbutton(menuset&,0)
ENDIF
IF yzoom=TRUE THEN
@setbutton(zoomy&,1)
ELSE
@setbutton(zoomy&,0)
ENDIF
IF grids=1 THEN
@setbutton(grid&,1)
ELSE
@setbutton(grid&,0)
ENDIF
IF freez=TRUE THEN
@setbutton(freeze&,1)
ELSE
@setbutton(freeze&,0)
ENDIF
'  IF sramda=TRUE THEN
'  @setbutton(sram&,1)
' ELSE
'  @setbutton(sram&,0)
' ENDIF
IF neufsel=TRUE THEN
@setbutton(nfsbut&,1)
ELSE
@setbutton(nfsbut&,0)
ENDIF
IF flipp=TRUE THEN
@setbutton(flip&,1)
ELSE
@setbutton(flip&,0)
ENDIF
IF show=TRUE THEN
@setbutton(setshow&,1)
ELSE
@setbutton(setshow&,0)
ENDIF
IF emula=TRUE THEN
@setbutton(emulset&,1)
ELSE
@setbutton(emulset&,0)
ENDIF
IF beeper=TRUE THEN
@setbutton(zerosnap&,1)
ELSE
@setbutton(zerosnap&,0)
ENDIF
IF uhr=TRUE THEN
@setbutton(timeset&,1)
ELSE
@setbutton(timeset&,0)
ENDIF
IF linkdot=TRUE THEN
@setbutton(linkdot&,1)
ELSE
@setbutton(linkdot&,0)
ENDIF
IF vertline=TRUE THEN
@setbutton(vertline&,1)
ELSE
@setbutton(vertline&,0)
ENDIF
IF spacefill=TRUE THEN
@setbutton(spacefil&,1)
ELSE
@setbutton(spacefil&,0)
ENDIF
IF mallmax=FALSE THEN
@setbutton(mallmax&,1)
ELSE
@setbutton(mallmax&,0)
ENDIF
a$=STR$(INT(memmx/1024))+CHR$(0)
@editfeld(lenmall&,a$)
~GRAF_MOUSE(257,0)                              ! Hidem
RETURN
'
> PROCEDURE makebinaer(b)
@delsourcekey
IF b=FALSE THEN
a$="false"
ELSE
a$="true"
ENDIF
RETURN
'
> FUNCTION getbinaer(a$)
LOCAL a
@delsourcekey
IF a$="false" THEN
a=FALSE
ELSE
a=TRUE
ENDIF
RETURN a
ENDFUNC
'
> FUNCTION getbinaer2(a$)
LOCAL a
@delsourcekey
IF a$="false" THEN
a=0
ELSE
a=1
ENDIF
RETURN a
ENDFUNC
'
> PROCEDURE newsetload
REPEAT
EXIT IF EOF(#1)
INPUT #1,a$
@changelowkey2
IF INSTR(a$,"firstcall")<>0 THEN
fcall=@getbinaer(a$)
ENDIF
IF INSTR(a$,"language")<>0 THEN
@delsourcekey
speak$=a$
ENDIF
IF INSTR(a$,"memory_size")<>0 THEN
@delsourcekey
a=INSTR(a$,"$")
IF a<>0 THEN
a$="&H"+RIGHT$(a$,LEN(a$)-a)
ENDIF
memmx=VAL(a$)
ENDIF
IF INSTR(a$,"memory_min_size")<>0 THEN
@delsourcekey
a=INSTR(a$,"$")
IF a<>0 THEN
a$="&H"+RIGHT$(a$,LEN(a$)-a)
ENDIF
mwmin=VAL(a$)
ENDIF
IF INSTR(a$,"memory_min_rest")<>0 THEN
@delsourcekey
a=INSTR(a$,"$")
IF a<>0 THEN
a$="&H"+RIGHT$(a$,LEN(a$)-a)
ENDIF
mrest=VAL(a$)
ENDIF
IF INSTR(a$,"tracker_cache")<>0 THEN
@delsourcekey
a=INSTR(a$,"$")
IF a<>0 THEN
a$="&H"+RIGHT$(a$,LEN(a$)-a)
ENDIF
tmlen=VAL(a$)
ENDIF
IF INSTR(a$,"filesel_max_entrys")<>0 THEN
@delsourcekey
lmax4=VAL(a$)
ENDIF
IF INSTR(a$,"tracker_max_tracks")<>0 THEN
@delsourcekey
trkvmax=VAL(a$)
ENDIF
IF INSTR(a$,"peak_fall_delay")<>0 THEN
@delsourcekey
psec=VAL(a$)
ENDIF
IF INSTR(a$,"peak_fall_relation")<>0 THEN
@delsourcekey
prest=VAL(a$)
ENDIF
IF INSTR(a$,"peak_fall_limit")<>0 THEN
@delsourcekey
pschwell=VAL(a$)
ENDIF
IF INSTR(a$,"peakrec_calc")<>0 THEN
recpkc=@getbinaer(a$)
ENDIF
IF INSTR(a$,"tracker_max_entrys")<>0 THEN
@delsourcekey
lmax3=VAL(a$)
ENDIF
IF INSTR(a$,"arranger_max_entrys")<>0 THEN
@delsourcekey
lmax2=VAL(a$)
ENDIF
IF INSTR(a$,"zoomdepth_max_entrys")<>0 THEN
@delsourcekey
lmax=VAL(a$)
ENDIF
IF INSTR(a$,"memory_max")<>0 THEN
mallmax=@getbinaer(a$)
ENDIF
IF INSTR(a$,"default_path")<>0 THEN
@delsourcekey
op$=a$
ENDIF
IF INSTR(a$,"samplefile_extension")<>0 THEN
@delsourcekey
ext$=a$
ENDIF
IF INSTR(a$,"help_path")<>0 THEN
@delsourcekey
hpath$=a$
ENDIF
IF INSTR(a$,"window_3d")<>0 THEN
dreidim=@getbinaer2(a$)
ENDIF
IF INSTR(a$,"window_flickerfix")<>0 THEN
flicker=@getbinaer(a$)
ENDIF
IF INSTR(a$,"window_freeze")<>0 THEN
freez=@getbinaer(a$)
ENDIF
IF INSTR(a$,"window_open")<>0 THEN
@delsourcekey
a=INSTR(a$,"x")
IF a<>0 THEN
a$="&X"+RIGHT$(a$,LEN(a$)-a)
ENDIF
winh=VAL(a$)
ENDIF
IF INSTR(a$,"program_menu")<>0 THEN
menuda=@getbinaer(a$)
ENDIF
IF INSTR(a$,"new_filesel")<>0 THEN
neufsel=@getbinaer(a$)
ENDIF
IF INSTR(a$,"emulate_cookie")<>0 THEN
emula=@getbinaer(a$)
ENDIF
IF INSTR(a$,"hardcursor")<>0 THEN
hardcursor=@getbinaer(a$)
ENDIF
IF INSTR(a$,"sample_resolution")<>0 THEN
@delsourcekey
a=VAL(a$)
IF a=24 THEN
dig24=TRUE
tmbit=6
ELSE
dig24=FALSE
tmbit=4
ENDIF
tdig24=dig24
ENDIF
IF INSTR(a$,"color_curve_out")<>0 THEN
@delsourcekey
smpwcol=VAL(a$)
ENDIF
IF INSTR(a$,"play_channel_select")<>0 THEN
@delsourcekey
playch=VAL(a$)
ENDIF
IF INSTR(a$,"color_curve_in")<>0 THEN
@delsourcekey
smpblkcol=VAL(a$)
ENDIF
IF INSTR(a$,"volume_ad")<>0 THEN
@delsourcekey
vol=VAL(a$)
ENDIF
IF INSTR(a$,"balance_ad")<>0 THEN
@delsourcekey
volinbal=VAL(a$)
ENDIF
IF INSTR(a$,"volume_da")<>0 THEN
@delsourcekey
vol2=VAL(a$)
ENDIF
IF INSTR(a$,"balance_da")<>0 THEN
@delsourcekey
volinbal2=VAL(a$)
ENDIF
IF INSTR(a$,"samplerate")<>0 THEN
@delsourcekey
hz=VAL(a$)
ENDIF
IF INSTR(a$,"lock_loadrate")<>0 THEN
@delsourcekey
hzkey=VAL(a$)
ENDIF
IF INSTR(a$,"input_source")<>0 THEN
@delsourcekey
ad=VAL(a$)
ENDIF
IF INSTR(a$,"digital_source")<>0 THEN
@delsourcekey
digsource=VAL(a$)
ENDIF
IF INSTR(a$,"digital_mode")<>0 THEN
proffm=@getbinaer(a$)
ENDIF
IF INSTR(a$,"digital_copy")<>0 THEN
@delsourcekey
scmsw=VAL(a$)
ENDIF
IF INSTR(a$,"digital_filter")<>0 THEN
empha=@getbinaer(a$)
ENDIF
IF INSTR(a$,"digital_bridge")<>0 THEN
bridge=@getbinaer(a$)
ENDIF
IF INSTR(a$,"digital_startmarker")<>0 THEN
dighead=@getbinaer(a$)
ENDIF
IF INSTR(a$,"digital_synchronize")<>0 THEN
digana=@getbinaer(a$)
IF digana=TRUE THEN
digana=FALSE
ELSE
digana=TRUE
ENDIF
ENDIF
IF INSTR(a$,"dsp_source")<>0 THEN
@delsourcekey
dspw=VAL(a$)
ENDIF
IF INSTR(a$,"dsp_bigram")<>0 THEN
bigram=@getbinaer(a$)
ENDIF
IF INSTR(a$,"play_hispeed")<>0 THEN
mod96=@getbinaer(a$)
ENDIF
IF INSTR(a$,"record_quadro")<>0 THEN
rch4=@getbinaer(a$)
ENDIF
IF INSTR(a$,"record_adat")<>0 THEN
rmo8=@getbinaer(a$)
ENDIF
IF INSTR(a$,"matrix_out")<>0 THEN
matrix=@getbinaer(a$)
ENDIF
IF INSTR(a$,"dsp_mixout")<>0 THEN
mixdsp=@getbinaer(a$)
ENDIF
IF INSTR(a$,"sampleview_lines")<>0 THEN
yline=@getbinaer(a$)
ENDIF
IF INSTR(a$,"sampleview_grid")<>0 THEN
grid=@getbinaer2(a$)
ENDIF
IF INSTR(a$,"sampleview_autozoom")<>0 THEN
yzoom=@getbinaer(a$)
ENDIF
IF INSTR(a$,"sampleview_snap")<>0 THEN
zsnap=@getbinaer(a$)
ENDIF
IF INSTR(a$,"sampleview_macro_amplitudes")<>0 THEN
vertline=@getbinaer(a$)
ENDIF
IF INSTR(a$,"sampleview_macro_linkdot")<>0 THEN
linkdot=@getbinaer(a$)
ENDIF
IF INSTR(a$,"sampleview_macro_fill")<>0 THEN
spacefill=@getbinaer(a$)
ENDIF
IF INSTR(a$,"samplepos_view")<>0 THEN
show=@getbinaer(a$)
ENDIF
IF INSTR(a$,"clock")<>0 THEN
uhr=@getbinaer(a$)
ENDIF
IF INSTR(a$,"function_flip")<>0 THEN
flipp=@getbinaer(a$)
ENDIF
IF INSTR(a$,"midistart_note")<>0 THEN
@delsourcekey
IF LEN(a$)<3 THEN
a$=LEFT$(a$,1)+" "+RIGHT$(a$,1)
ENDIF
note=@midivalue(a$)
ENDIF
IF INSTR(a$,"midistart_channel")<>0 THEN
@delsourcekey
ch=VAL(a$)
ENDIF
IF INSTR(a$,"midi_controller")<>0 THEN
mislide=@getbinaer(a$)
ENDIF
IF INSTR(a$,"midi_control_channel")<>0 THEN
@delsourcekey
mcc=VAL(a$)
ENDIF
IF INSTR(a$,"sync_adat")<>0 THEN
adat=@getbinaer(a$)
ENDIF
IF INSTR(a$,"sync_mtc")<>0 THEN
mtc=@getbinaer(a$)
ENDIF
IF INSTR(a$,"send_mtc")<>0 THEN
sendsmpte=@getbinaer(a$)
ENDIF
IF INSTR(a$,"frame_time")<>0 THEN
@delsourcekey
framez=VAL(a$)
ENDIF
IF INSTR(a$,"mtc_timestart")<>0 THEN
@delsourcekey
smptestrt=VAL(a$)
ENDIF
IF INSTR(a$,"clock_falcon")<>0 THEN
fmclk=@getbinaer(a$)
ENDIF
IF INSTR(a$,"external_clock")<>0 THEN
@delsourcekey
synchertz=VAL(a$)
ENDIF
IF INSTR(a$,"external_pcg")<>0 THEN
pcg=@getbinaer(a$)
ENDIF
IF INSTR(a$,"viewtime")<>0 THEN
tedart=@getbinaer2(a$)
IF tedart=1 THEN
tedart=0
ELSE
tedart=1
ENDIF
ENDIF
IF INSTR(a$,"spacetime")<>0 THEN
@delsourcekey
spc=VAL(a$)
ENDIF
IF INSTR(a$,"arranger_time")<>0 THEN
realtime=@getbinaer(a$)
ENDIF
IF INSTR(a$,"record_time")<>0 THEN
@delsourcekey
min=VAL(a$)
ENDIF
IF INSTR(a$,"peakhold_time")<>0 THEN
@delsourcekey
phold=VAL(a$)
ENDIF
IF INSTR(a$,"record_max_timesize")<>0 THEN
recmax=@getbinaer(a$)
ENDIF
IF INSTR(a$,"record_beeper")<>0 THEN
beeper=@getbinaer(a$)
ENDIF
IF INSTR(a$,"play_lead-in")<>0 THEN
@delsourcekey
plead=VAL(a$)
ENDIF
IF INSTR(a$,"fade_in")<>0 THEN
@delsourcekey
fadewin=VAL(a$)
ENDIF
IF INSTR(a$,"fade_out")<>0 THEN
@delsourcekey
fadewout=VAL(a$)
ENDIF
IF INSTR(a$,"fade_direction")<>0 THEN
fadericht=@getbinaer2(a$)
ENDIF
IF INSTR(a$,"normalize_auto")<>0 THEN
norma=@getbinaer2(a$)
ENDIF
IF INSTR(a$,"decibel")<>0 THEN
@delsourcekey
db=VAL(a$)
ENDIF
IF INSTR(a$,"resample_rate")<>0 THEN
@delsourcekey
resoth=VAL(a$)
ENDIF
IF INSTR(a$,"resample_adjust")<>0 THEN
adjresmp=@getbinaer(a$)
ENDIF
IF INSTR(a$,"record_autostart")<>0 THEN
@delsourcekey
th=VAL(a$)
ENDIF
IF INSTR(a$,"transfer_blocks")<>0 THEN
@delsourcekey
flen=VAL(a$)
IF flen>1000 OR flen=0 THEN
flen=2
ENDIF
ENDIF
IF INSTR(a$,"max_blksize")<>0 THEN
blkrmax=@getbinaer(a$)
ENDIF
IF INSTR(a$,"backup_auto")<>0 THEN
aback=@getbinaer(a$)
ENDIF
IF INSTR(a$,"backup_newname")<>0 THEN
abacknam=@getbinaer(a$)
ENDIF
IF INSTR(a$,"backup_time")<>0 THEN
@delsourcekey
btime=VAL(a$)
ENDIF
IF INSTR(a$,"editor_posx")<>0 THEN
@delsourcekey
rx(smpedit&)=VAL(a$)
ENDIF
IF INSTR(a$,"editor_posy")<>0 THEN
@delsourcekey
ry(smpedit&)=VAL(a$)
ENDIF
IF INSTR(a$,"info_posx")<>0 THEN
@delsourcekey
rx(info&)=VAL(a$)
ENDIF
IF INSTR(a$,"info_posy")<>0 THEN
@delsourcekey
ry(info&)=VAL(a$)
ENDIF
IF INSTR(a$,"connect_posx")<>0 THEN
@delsourcekey
rx(smp16&)=VAL(a$)
ENDIF
IF INSTR(a$,"connect_posy")<>0 THEN
@delsourcekey
ry(smp16&)=VAL(a$)
ENDIF
IF INSTR(a$,"block_posx")<>0 THEN
@delsourcekey
rx(blkfunc&)=VAL(a$)
ENDIF
IF INSTR(a$,"block_posy")<>0 THEN
@delsourcekey
ry(blkfunc&)=VAL(a$)
ENDIF
IF INSTR(a$,"peakmeter_posx")<>0 THEN
@delsourcekey
rx(peak&)=VAL(a$)
ENDIF
IF INSTR(a$,"peakmeter_posy")<>0 THEN
@delsourcekey
ry(peak&)=VAL(a$)
ENDIF
IF INSTR(a$,"arranger_posx")<>0 THEN
@delsourcekey
rx(arranger&)=VAL(a$)
ENDIF
IF INSTR(a$,"arranger_posy")<>0 THEN
@delsourcekey
ry(arranger&)=VAL(a$)
ENDIF
IF INSTR(a$,"tracker_posx")<>0 THEN
@delsourcekey
rx(trakker&)=VAL(a$)
ENDIF
IF INSTR(a$,"tracker_posy")<>0 THEN
@delsourcekey
ry(trakker&)=VAL(a$)
ENDIF
IF INSTR(a$,"loop_posx")<>0 THEN
@delsourcekey
rx(loop&)=VAL(a$)
ENDIF
IF INSTR(a$,"loop_posy")<>0 THEN
@delsourcekey
ry(loop&)=VAL(a$)
ENDIF
IF INSTR(a$,"dsp_posx")<>0 THEN
@delsourcekey
rx(dspedit&)=VAL(a$)
ENDIF
IF INSTR(a$,"dsp_posy")<>0 THEN
@delsourcekey
ry(dspedit&)=VAL(a$)
ENDIF
IF INSTR(a$,"fade_posx")<>0 THEN
@delsourcekey
rx(editfade&)=VAL(a$)
ENDIF
IF INSTR(a$,"fade_posy")<>0 THEN
@delsourcekey
ry(editfade&)=VAL(a$)
ENDIF
IF INSTR(a$,"workmode_posx")<>0 THEN
@delsourcekey
rx(wmode&)=VAL(a$)
ENDIF
IF INSTR(a$,"workmode_posy")<>0 THEN
@delsourcekey
ry(wmode&)=VAL(a$)
ENDIF
IF INSTR(a$,"cuelist_posx")<>0 THEN
@delsourcekey
rx(cuelist&)=VAL(a$)
ENDIF
IF INSTR(a$,"cuelist_posy")<>0 THEN
@delsourcekey
ry(cuelist&)=VAL(a$)
ENDIF
IF INSTR(a$,"plugin_posx")<>0 THEN
@delsourcekey
rx(plugin&)=VAL(a$)
ENDIF
IF INSTR(a$,"plugin_posy")<>0 THEN
@delsourcekey
ry(plugin&)=VAL(a$)
ENDIF
IF INSTR(a$,"mixer_posx")<>0 THEN
@delsourcekey
rx(mixer&)=VAL(a$)
ENDIF
IF INSTR(a$,"mixer_posy")<>0 THEN
@delsourcekey
ry(mixer&)=VAL(a$)
ENDIF
IF INSTR(a$,"editor_width")<>0 THEN
@delsourcekey
rb(smpedit&)=VAL(a$)
ENDIF
IF INSTR(a$,"editor_height")<>0 THEN
@delsourcekey
rh(smpedit&)=VAL(a$)
ENDIF
IF INSTR(a$,"peakmeter_width")<>0 THEN
@delsourcekey
rb(peak&)=VAL(a$)
ENDIF
IF INSTR(a$,"peakmeter_height")<>0 THEN
@delsourcekey
rh(peak&)=VAL(a$)
ENDIF
IF INSTR(a$,"tracker_width")<>0 THEN
@delsourcekey
rb(trakker&)=VAL(a$)
ENDIF
IF INSTR(a$,"tracker_height")<>0 THEN
@delsourcekey
rh(trakker&)=VAL(a$)
ENDIF
UNTIL EOF(#1)
IF flen=0 THEN
flen=2
ENDIF
IF freez=FALSE THEN
winh=0
ENDIF
IF dig24=TRUE THEN
tmbit=6
mbit=6
ELSE
tmbit=4
mbit=4
ENDIF
RETURN
'
> PROCEDURE setsave
.| Glob. Var.: lenmall&,a$,memmx#,a#,setup$,vfreez#,winh#,sector#,vol#
.|     vdigana#,vop$,vflen#,vsramda#,vmin#,vmallmax#,vth#,vdreidim#,vgrid#
.|     vext$,vflipp#,vuhr#,vshow#,aback#,abacknam#,btime#,vyline#,vvertline#
.|     vlinkdot#,vspacefill#,vzsnap#,vyzoom#,vfastrec#,vmenuda#,btree#,i#
.|     obj#
.| Felder    : rscx&(),rscy&()
.| Ruft auf  : busy_mouse,editread,nomem,setbutton
.| Aufruf in : setupdat-1,
@busy_mouse
@editread(lenmall&)
memmx=INT(1024*VAL(a$))
a=ASC(LEFT$(setup$,1))-64
IF @dfree(a)>=sector THEN
OPEN "O",#1,setup$
PRINT #1,"STARTRACK-SETUP V2.0"           ! Versionskontrolle
PRINT #1
PRINT #1,"language="+speak$
PRINT #1,"firstcall=false"
PRINT #1
PRINT #1,"memory_size=$"+HEX$(memmx)
@makebinaer(vmallmax)
PRINT #1,"memory_max="+a$
PRINT #1,"memory_min_size=$"+HEX$(mwmin)
PRINT #1,"memory_min_rest=$"+HEX$(mrest)
PRINT #1,"tracker_cache=$"+HEX$(tmlen)
PRINT #1
PRINT #1,"zoomdepth_max_entrys="+STR$(lmax)
PRINT #1,"arranger_max_entrys="+STR$(lmax2)
PRINT #1,"tracker_max_entrys="+STR$(lmax3)
PRINT #1,"tracker_max_tracks="+STR$(trkvmax)
PRINT #1,"filesel_max_entrys="+STR$(lmax4)
PRINT #1
PRINT #1,"default_path="+vop$
PRINT #1,"samplefile_extension="+vext$
PRINT #1,"help_path="+hpath$
@makebinaer(vdreidim)
PRINT #1,"window_3d="+a$
@makebinaer(vflicker)
PRINT #1,"window_flickerfix="+a$
@makebinaer(vfreez)
PRINT #1,"window_freeze="+a$
a$="x"+BIN$(winh)
PRINT #1,"window_open="+a$
@makebinaer(vmenuda)
PRINT #1,"program_menu="+a$
@makebinaer(vneufsel)
PRINT #1,"new_filesel="+a$
@makebinaer(hardcursor)
PRINT #1,"hardcursor="+a$
PRINT #1,"color_curve_out="+STR$(smpwcol)
PRINT #1,"color_curve_in="+STR$(smpblkcol)
@makebinaer(vemula)
PRINT #1,"emulate_cookie="+a$
IF dig24=FALSE THEN
a$="16"
ELSE
a$="24"
ENDIF
PRINT #1,"sample_resolution="+a$
PRINT #1
PRINT #1,"peak_fall_delay="+STR$(psec)
PRINT #1,"peak_fall_relation="+STR$(prest)
PRINT #1,"peak_fall_limit="+STR$(pschwell)
@makebinaer(vrecpkc)
PRINT #1,"peakrec_calc="+a$
PRINT #1
PRINT #1,"volume_ad="+STR$(vvol)
PRINT #1,"balance_ad="+STR$(vvolinbal)
PRINT #1,"volume_da="+STR$(vvol2)
PRINT #1,"balance_da="+STR$(vvolinbal2)
PRINT #1,"play_channel_select="+STR$(playch)
PRINT #1,"samplerate="+STR$(vhz)
@makebinaer(hzkey)
PRINT #1,"lock_loadrate="+a$
PRINT #1,"input_source="+STR$(vad)
PRINT #1,"digital_source="+STR$(vdigsource)
@makebinaer(vproffm)
PRINT #1,"digital_mode="+a$
PRINT #1,"digital_copy="+STR$(vscmsw)
@makebinaer(vempha)
PRINT #1,"digital_filter="+a$
@makebinaer(vbridge)
PRINT #1,"digital_bridge="+a$
@makebinaer(dighead)
PRINT #1,"digital_startmarker="+a$
IF digana=FALSE THEN
a$="true"
ELSE
a$="false"
ENDIF
PRINT #1,"digital_synchronize="+a$
PRINT #1,"dsp_source="+STR$(vdspw)
@makebinaer(bigram)
PRINT #1,"dsp_bigram="+a$
'
PRINT #1
@makebinaer(mod96)
PRINT #1,"play_hispeed="+a$
@makebinaer(rch4)
PRINT #1,"record_quadro="+a$
@makebinaer(rmo8)
PRINT #1,"record_adat="+a$
@makebinaer(matrix)
PRINT #1,"matrix_out="+a$
@makebinaer(mixdsp)
PRINT #1,"dsp_mixout="+a$
'
PRINT #1
@makebinaer(vyline)
PRINT #1,"sampleview_lines="+a$
@makebinaer(vgrid)
PRINT #1,"sampleview_grid="+a$
@makebinaer(vyzoom)
PRINT #1,"sampleview_autozoom="+a$
@makebinaer(vvertline)
PRINT #1,"sampleview_macro_amplitudes="+a$
@makebinaer(vlinkdot)
PRINT #1,"sampleview_macro_linkdot="+a$
@makebinaer(vspacefill)
PRINT #1,"sampleview_macro_fill="+a$
@makebinaer(vshow)
PRINT #1,"samplepos_view="+a$
@makebinaer(vuhr)
PRINT #1,"clock="+a$
@makebinaer(vflipp)
PRINT #1,"function_flip="+a$
'
PRINT #1
@midinote(vnote)
db$=LEFT$(db$,LEN(db$)-1)
IF INSTR(db$," ")<>0 THEN
db$=LEFT$(db$,1)+RIGHT$(db$,1)
ENDIF
PRINT #1,"midistart_channel="+STR$(vch)
PRINT #1,"midistart_note="+db$
@makebinaer(mislide)
PRINT #1,"midi_controller="+a$
PRINT #1,"midi_control_channel="+STR$(mcc)
PRINT #1
@makebinaer(adat)
PRINT #1,"sync_adat="+a$
@makebinaer(mtc)
PRINT #1,"sync_mtc="+a$
@makebinaer(sendsmpte)
PRINT #1,"send_mtc="+a$
PRINT #1,"frame_time="+STR$(framez)
PRINT #1,"mtc_timestart="+STR$(smptestrt)
@makebinaer(fmclk)
PRINT #1,"clock_falcon="+a$
PRINT #1,"external_clock="+STR$(synchertz)
@makebinaer(pcg)
PRINT #1,"external_pcg="+a$
'
PRINT #1
IF tedart=FALSE THEN
a$="true"
ELSE
a$="false"
ENDIF
PRINT #1,"viewtime="+a$
PRINT #1,"spacetime="+STR$(vspc)
@makebinaer(vrealtime)
PRINT #1,"arranger_time="+a$
PRINT #1,"record_time="+STR$(vmin)
PRINT #1,"peakhold_time="+STR$(phold)
@makebinaer(vrecmax)
PRINT #1,"record_max_timesize="+a$
@makebinaer(vbeeper)
PRINT #1,"record_beeper="+a$
PRINT #1,"play_lead-in="+STR$(plead)
'
PRINT #1
PRINT #1,"fade_in="+STR$(vfadewin)
PRINT #1,"fade_out="+STR$(vfadewout)
@makebinaer(vfadericht)
PRINT #1,"fade_direction="+a$
@makebinaer(vnorma)
PRINT #1,"normalize_auto="+a$
PRINT #1,"decibel="+STR$(vdb)
PRINT #1,"resample_rate="+STR$(vresoth)
@makebinaer(vadjresmp)
PRINT #1,"resample_adjust="+a$
PRINT #1,"record_autostart="+STR$(vth)
PRINT #1,"transfer_blocks="+STR$(vflen)
@makebinaer(vblkrmax)
PRINT #1,"max_blksize="+a$
@makebinaer(aback)
PRINT #1,"backup_auto="+a$
@makebinaer(abacknam)
PRINT #1,"backup_newname="+a$
PRINT #1,"backup_time="+STR$(btime)
'
PRINT #1
PRINT #1,"editor_posx="+STR$(rscx&(smpedit&))
PRINT #1,"editor_posy="+STR$(rscy&(smpedit&))
PRINT #1,"info_posx="+STR$(rscx&(info&))
PRINT #1,"info_posy="+STR$(rscy&(info&))
PRINT #1,"connect_posx="+STR$(rscx&(smp16&))
PRINT #1,"connect_posy="+STR$(rscy&(smp16&))
PRINT #1,"block_posx="+STR$(rscx&(blkfunc&))
PRINT #1,"block_posy="+STR$(rscy&(blkfunc&))
PRINT #1,"peakmeter_posx="+STR$(rscx&(peak&))
PRINT #1,"peakmeter_posy="+STR$(rscy&(peak&))
PRINT #1,"arranger_posx="+STR$(rscx&(arranger&))
PRINT #1,"arranger_posy="+STR$(rscy&(arranger&))
PRINT #1,"tracker_posx="+STR$(rscx&(trakker&))
PRINT #1,"tracker_posy="+STR$(rscy&(trakker&))
PRINT #1,"loop_posx="+STR$(rscx&(loop&))
PRINT #1,"loop_posy="+STR$(rscy&(loop&))
PRINT #1,"dsp_posx="+STR$(rscx&(dspedit&))
PRINT #1,"dsp_posy="+STR$(rscy&(dspedit&))
PRINT #1,"fade_posx="+STR$(rscx&(editfade&))
PRINT #1,"fade_posy="+STR$(rscy&(editfade&))
PRINT #1,"workmode_posx="+STR$(rscx&(wmode&))
PRINT #1,"workmode_posy="+STR$(rscy&(wmode&))
PRINT #1,"plugin_posx="+STR$(rscx&(plugin&))
PRINT #1,"plugin_posy="+STR$(rscy&(plugin&))
PRINT #1,"cuelist_posx="+STR$(rscx&(cuelist&))
PRINT #1,"cuelist_posy="+STR$(rscy&(cuelist&))
PRINT #1,"mixer_posx="+STR$(rscx&(mixer&))
PRINT #1,"mixer_posy="+STR$(rscy&(mixer&))
'
PRINT #1
PRINT #1,"editor_width="+STR$(rscw&(smpedit&))
PRINT #1,"editor_height="+STR$(rsch&(smpedit&))
PRINT #1,"peakmeter_width="+STR$(rscw&(peak&))
PRINT #1,"peakmeter_height="+STR$(rsch&(peak&))
PRINT #1,"tracker_width="+STR$(rscw&(trakker&))
PRINT #1,"tracker_height="+STR$(rsch&(trakker&))
PRINT #1
'
CLOSE #1
ELSE
@nomem
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE menuset
.| Glob. Var.: vmenuda#
.| Aufruf in : setupdat-1,
IF vmenuda=TRUE THEN
vmenuda=FALSE
ELSE
vmenuda=TRUE
ENDIF
RETURN
'
> PROCEDURE freeze
.| Glob. Var.: vfreez#
.| Aufruf in : setupdat-1,
IF vfreez=TRUE THEN
vfreez=FALSE
ELSE
vfreez=TRUE
ENDIF
RETURN
'
> PROCEDURE flickerfix
.| Glob. Var.: vfastrec#
.| Aufruf in : setupdat-1,
IF vflicker=TRUE THEN
vflicker=FALSE
ELSE
vflicker=TRUE
ENDIF
RETURN
'
> PROCEDURE yautozoom
.| Glob. Var.: vyzoom#
.| Aufruf in : setupdat-1,
IF vyzoom=TRUE THEN
vyzoom=FALSE
ELSE
vyzoom=TRUE
ENDIF
RETURN
'
> PROCEDURE setyline
.| Glob. Var.: vyline#
.| Aufruf in : setupdat-1,
IF vyline=TRUE THEN
vyline=FALSE
ELSE
vyline=TRUE
ENDIF
RETURN
'
> PROCEDURE zerosnap
.| Glob. Var.: vzsnap#
.| Aufruf in : setupdat-1,
IF vbeeper=TRUE THEN
vbeeper=FALSE
ELSE
vbeeper=TRUE
ENDIF
RETURN
'
> PROCEDURE vertline
.| Glob. Var.: vvertline#,vspacefill#,vlinkdot#,spacefil&
.| Ruft auf  : setbutton
.| Aufruf in : setupdat-1,
IF vvertline=TRUE THEN
vvertline=FALSE
ELSE
vvertline=TRUE
ENDIF
IF vspacefill=FALSE AND vvertline=FALSE AND vlinkdot=FALSE THEN
vspacefill=TRUE
@setbutton(spacefil&,1)
ENDIF
RETURN
'
> PROCEDURE linkdot
.| Glob. Var.: vlinkdot#,vspacefill#,vvertline#,spacefil&
.| Ruft auf  : setbutton
.| Aufruf in : setupdat-1,
IF vlinkdot=TRUE THEN
vlinkdot=FALSE
ELSE
vlinkdot=TRUE
ENDIF
IF vspacefill=FALSE AND vvertline=FALSE AND vlinkdot=FALSE THEN
vspacefill=TRUE
@setbutton(spacefil&,1)
ENDIF
RETURN
'
> PROCEDURE spacefill
.| Glob. Var.: vspacefill#,vvertline#,vlinkdot#,spacefil&
.| Ruft auf  : setbutton
.| Aufruf in : setupdat-1,
IF vspacefill=TRUE THEN
vspacefill=FALSE
ELSE
vspacefill=TRUE
ENDIF
IF vspacefill=FALSE AND vvertline=FALSE AND vlinkdot=FALSE THEN
vspacefill=TRUE
@setbutton(spacefil&,1)
ENDIF
RETURN
'
> PROCEDURE sync
.| Glob. Var.: vdigana#
.| Aufruf in : setupdat-1,
IF vdigana=TRUE THEN
vdigana=FALSE
ELSE
vdigana=TRUE
ENDIF
RETURN
'
> PROCEDURE viewset
IF vtedart=1 THEN
vtedart=0
ELSE
vtedart=1
ENDIF
RETURN
'
> PROCEDURE dreide
.| Glob. Var.: vdreidim#
.| Aufruf in : setupdat-1,
IF vdreidim=1 THEN
vdreidim=0
ELSE
vdreidim=1
ENDIF
RETURN
'
> PROCEDURE setrecmax
IF vrecmax=TRUE THEN
vrecmax=FALSE
ELSE
vrecmax=TRUE
ENDIF
RETURN
'
> PROCEDURE setviewcache
IF vrecpkc=TRUE THEN
vrecpkc=FALSE
ELSE
vrecpkc=TRUE
ENDIF
RETURN
'
> PROCEDURE setblkrmax
IF vblkrmax=TRUE THEN
vblkrmax=FALSE
ELSE
vblkrmax=TRUE
ENDIF
RETURN
'
> PROCEDURE realarr
IF realtime=TRUE THEN
realtime=FALSE
ELSE
realtime=TRUE
ENDIF
@arrnrset
RETURN
'
> PROCEDURE grid
.| Glob. Var.: vgrid#
.| Aufruf in : setupdat-1,
IF vgrid=1 THEN
vgrid=0
ELSE
vgrid=1
ENDIF
RETURN
'
> PROCEDURE fseldef
.| Glob. Var.: ab#,nr#,vop$,ext$,ordner$,pret#,pbutt#,a#,fseltxt&,obj#
.| Felder    : rscx&(),rscy&(),rscw&(),rsch&()
.| Ruft auf  : rsc_get,fileselect,rsc_put,busy_mouse,textfeld,setbutton
.| Aufruf in : setupdat-1,
~GRAF_MOUSE(256,0)                              ! Hidem
abfsel=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
@fileselect(vop$+"*."+ext$,"","PATH:")
@rsc_put(abfsel,rscx&(nr),rscy&(nr),1)
@busy_mouse
~MFREE(abfsel)
IF ordner$<>"" AND pret<>0 AND pbutt=1 THEN
IF LEN(ordner$)>57 THEN
ordner$=RIGHT$(ordner$,57)
a=INSTR(ordner$,"\")
ordner$=RIGHT$(ordner$,LEN(ordner$)-(a-1))
ENDIF
@textfeld(fseltxt&,ordner$+CHR$(0),1)
vop$=ordner$
ENDIF
@setbutton(obj,0)
RETURN
'
> PROCEDURE secbutt
.| Glob. Var.: obj#,secl&,vflen#,secr&,f$,seclen&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : setupdat-1,
IF obj=secl& AND vflen>1 THEN
vflen=vflen-1
ENDIF
IF obj=secr& AND vflen<1000 THEN
vflen=vflen+1
ENDIF
f$=RIGHT$(SPACE$(5)+STR$(vflen),5)+CHR$(0)
@textfeld(seclen&,f$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE flipp
.| Glob. Var.: vflipp#
.| Aufruf in : setupdat-1,
IF vflipp=FALSE THEN
vflipp=TRUE
ELSE
vflipp=FALSE
ENDIF
RETURN
'
> PROCEDURE showset
.| Glob. Var.: vshow#
.| Aufruf in : setupdat-1,
IF vshow=FALSE THEN
vshow=TRUE
ELSE
vshow=FALSE
ENDIF
RETURN
'
> PROCEDURE emulset
IF vemula=FALSE THEN
vemula=TRUE
ELSE
vemula=FALSE
ENDIF
RETURN
'
> PROCEDURE emulset2
IF demo=FALSE THEN
IF emula=TRUE THEN
~XBIOS(xbs,160,1)
ELSE
~XBIOS(xbs,160,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE timeset
.| Glob. Var.: vuhr#
.| Aufruf in : setupdat-1,
IF vuhr=FALSE THEN
vuhr=TRUE
ELSE
vuhr=FALSE
ENDIF
RETURN
'
> PROCEDURE midislider
IF mislide=FALSE THEN
mislide=TRUE
ELSE
mislide=FALSE
ENDIF
RETURN
'
> PROCEDURE flipptest
.| Glob. Var.: flipp#,smark#,nr#,smpedit&,a$,popups&,smpmark&,mover&
.| Ruft auf  : textfeld
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-1,smpr-1,edhandler2-2,
IF flipp=TRUE AND smark<>3 THEN
smark=3
IF nr=smpedit& THEN
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE sram
.| Glob. Var.: vsramda#
.| Aufruf in : setupdat-1,
IF vsramda=FALSE THEN
vsramda=TRUE
ELSE
vsramda=FALSE
ENDIF
RETURN
'
> PROCEDURE fselwahl
IF vneufsel=FALSE THEN
vneufsel=TRUE
ELSE
vneufsel=FALSE
ENDIF
RETURN
'
> PROCEDURE recbutt
.| Glob. Var.: obj#,recl&,vmin#,recr&,f$,recm&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : setupdat-1,
IF obj=recl& AND vmin>1 THEN
DEC vmin
ENDIF
IF obj=recr& AND vmin<100 THEN
INC vmin
ENDIF
f$=RIGHT$(SPACE$(5)+STR$(vmin),5)+CHR$(0)
@textfeld(recm&,f$,1)
@setbutton(obj,0)
RETURN
'
> PROCEDURE mallmax
.| Glob. Var.: vmallmax#
.| Aufruf in : setupdat-1,
IF vmallmax=TRUE THEN
vmallmax=FALSE
ELSE
vmallmax=TRUE
ENDIF
RETURN
'
> PROCEDURE tresbutt
.| Glob. Var.: obj#,tresl&,vth#,tresr&,tdb#,aufloes#,tdb$,tresdb&
.| Ruft auf  : textfeld,setbutton
.| Aufruf in : setupdat-1,
IF obj=tresl& AND vth>199 THEN
vth=vth-100
ENDIF
IF obj=tresr& AND vth<32668 THEN
vth=vth+100
ENDIF
tdb=vth
tdb=20*LOG10(tdb*2)
tdb=tdb-96.32
tdb=INT(tdb*1000)/1000
tdb$=STR$(tdb)+CHR$(0)
@textfeld(tresdb&,tdb$,1)
setbutton(obj,0)
RETURN
'
> PROCEDURE timecorr
.| Glob. Var.: i#,loopz#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp3
.| Aufruf in : do_blkf-1,
LOCAL j
FOR j=1 TO 4
IF loops%(sms,j)<>-1 THEN
@markhlp3(sms,j,loops%(sms,j))
ENDIF
NEXT j
RETURN
'
> PROCEDURE markdel
.| Glob. Var.: smplen#,vmem#,i#,loopz#,smark#,nr#,smpedit&,a$,popups&
.|     smpmark&,mover&,master#
.| Felder    : loops#(),loope#()
.| Ruft auf  : textfeld,fnamwrite
.| Aufruf in : ldhlp-2,smpedit-2,trash-2,memtovirt-1,memtovirt2-1,record2-1,
LOCAL i,j
smplen=vmem
retime=0
aretime=0
FOR i=1 TO loopz
FOR j=1 TO 4
loops%(i,j)=-1
NEXT j
edmtxt$(i)=""
NEXT i
smark=3
IF nr=smpedit& THEN
a$=@rsc_text$(popups&,smpmark&)
@textfeld(mover&,a$,1)
ENDIF
sms=0
sms2=0
@fnamwrite
@clipdel
RETURN
'
> PROCEDURE smpstx(es,i2)
sms2=i2
@marktextsel(i2)
sms=es
IF loops%(es,i2)=-1 THEN
@markhlp
loops%(es,i2)=0
@markhlp2
@markhlp3(es,sms2,loops%(es,i2))
ELSE
@markhlp4(loops%(es,i2))
ENDIF
RETURN
'
> PROCEDURE smph1
.| Glob. Var.: master#,loopz#,x#
.| Felder    : loops#(),loope#()
.| Aufruf in : smpanf-1,smpend-1,smpmid-1,smpl-2,smpr-2,edhandler2-1,
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
x=loops%(sms,sms2)
ENDIF
RETURN
'
> PROCEDURE smph3
.| Glob. Var.: master#,loopz#,sms#,a#,sme#
.| Felder    : loops#(),loope#()
.| Ruft auf  : markhlp8,selblkshak,textfeld,selblksbut,selblkehak,selblkebut
.|     testsme,testsms,smpstx,smpex,smpsts,smpes
.| Aufruf in : trash-1,
LOCAL j
IF sms>0 AND sms<=loopz AND sms2<>0 THEN
@markhlp8(sms,sms2,loops%(sms,sms2))
loops%(sms,sms2)=-1
sms2=0
ENDIF
sms=0
@testsms
IF sms>0 AND sms<=loopz THEN
FOR j=1 TO 4
@smpstx(sms,j)
NEXT j
@edmarkset(sms)
ENDIF
RETURN
'
> PROCEDURE testsms
.| Glob. Var.: i#,loopz#,master#
.| Felder    : loops#()
.| Aufruf in : smph3-2,
FOR i=loopz TO 1 STEP -1
IF loops%(i,1)<>-1 THEN
sms=i
ENDIF
NEXT i
RETURN
'
> PROCEDURE markhlp4(bx)
.| Glob. Var.: cs#,ce#,xm#,xd#,stay1#,stay2#,t$
.| Aufruf in : smpstx-1,smpsts-1,smpex-1,smpes-1,
LOCAL cx
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE cx+xd,stay1,cx+xd,stay2
LINE cx+xd,stay1,cx+xd,stay2
IF bigfoot=FALSE THEN
DEFTEXT 1,0,0,4
ELSE
DEFTEXT 1,0,0,11
ENDIF
TEXT cx+xd-2,stay1-1,t$
TEXT cx+xd-2,stay1-1,t$
DEFTEXT 1,0,0,4
IF credraw=FALSE THEN
CLIP OFF
ENDIF
GRAPHMODE 3
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
ENDIF
RETURN
'
> PROCEDURE markhlp6(bx)
.| Glob. Var.: cs#,ce#,xm#,xd#,stay1#,stay2#,t$
.| Ruft auf  : markhlp
.| Aufruf in : markprod3-4,edhandler2-1,markset-2,
LOCAL cx
@markhlp
IF bx>=cs AND bx<=ce AND (ce-cs)>0 THEN
cx=bx-cs
cx=cx/(ce-cs)*xm
~GRAF_MOUSE(256,0)                              ! Hidem
COLOR 1
GRAPHMODE 3
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
LINE cx+xd,stay1,cx+xd,stay2
IF bigfoot=FALSE THEN
DEFTEXT 1,0,0,4
ELSE
DEFTEXT 1,0,0,11
ENDIF
TEXT cx+xd-2,stay1-1,t$
DEFTEXT 1,0,0,4
IF credraw=FALSE THEN
CLIP OFF
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
drawnew=TRUE
ENDIF
RETURN
'
> PROCEDURE setadatp
IF demo=FALSE OR falcon=TRUE THEN
~XBIOS(&H8A,0,7)
~XBIOS(&H8A,2,7) ! fÅr ADAT-Play den GPIO auf 111 setzen
ENDIF
RETURN
'
> PROCEDURE setadatr
IF demo=FALSE OR falcon=TRUE THEN
~XBIOS(&H8A,0,7)
~XBIOS(&H8A,2,5) ! fÅr ADAT-Rec den GPIO auf 101 setzen
ENDIF
RETURN
'
> PROCEDURE pcgsetup
a=INT(synchertz/512)
@setpcg(a)
a$=STR$(a)
IF LEN(a$)>5 THEN
a$=RIGHT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@editfeld(syncsrte&,a$)
RETURN
'
> PROCEDURE setpcg(chz)  ! chz=764-96000 Hz (mehr mîglich, aber nicht empfohlen)
IF demo=FALSE OR falcon=TRUE THEN
~XBIOS(&H8A,0,7)
~XBIOS(&H8A,2,0) ! fÅr ADAT-Play den GPIO auf 111 setzen
ENDIF
'
pcgout=FALSE
ref=12.5*1000^2
'
@clockcalc(ref,chz)
'
IF pcgout=TRUE THEN
CLS
PRINT "f_vco","(50-150 MHz)",freqvco
PRINT "mux","(0-7)",mux
PRINT "P","(4-130)",p
PRINT "Q","(3-129)",q
PRINT
PRINT "sampleraten-wunsch:",chz
PRINT "tatsÑchliche samplerate:",freqhz
ENDIF
'
@progword(p,1,mux,q,index)
@sendcontrol(&X1111000000101)
@sendprotocol(pw)
@sendcontrol(&X1111000000000)
RETURN
'
> PROCEDURE clockcalc(freqref,chz)
freqout=chz*512
freqvco=freqout
mux=0
WHILE freqvco<(50*1000^2) AND mux<7
INC mux
freqvco=freqout*2^mux
WEND
faktor=freqvco/(freqref*2)
pv=3
p=3
q=3
REPEAT
INC pv
qv=INT(pv/faktor)
IF qv<3 THEN
qv=3
ENDIF
IF qv>129 THEN
qv=129
ENDIF
IF (ABS((pv/qv)-faktor))<=(ABS((p/q)-faktor)) THEN
p=pv
q=qv
ENDIF
INC qv
IF qv>129 THEN
qv=129
ENDIF
IF (ABS((pv/qv)-faktor))<=(ABS((p/q)-faktor)) THEN
p=pv
q=qv
ENDIF
UNTIL pv=130
ppm=INT((1000^2)*ABS((p/q)-faktor))
freqout=INT(2*freqref*(p/q))
pcgfreq=INT(freqout/(2^mux))
freqhz=INT(pcgfreq/512)
index=0
IF freqout>80*1000^2 THEN
index=&X1000
ENDIF
RETURN
'
> PROCEDURE progword(p,duty,mux,q,index)
pw=index+(q-2)*&X10000+mux*&X100000000000+duty*&X100000000000000+(p-3)*&X1000000000000000
RETURN
'
> PROCEDURE sendcontrol(cwv)
FOR i=0 TO 13
bit=(cwv AND 1)
cwv=SHR(cwv,1)
@sendbit(bit)
NEXT i
RETURN
'
> PROCEDURE sendprotocol(pwv)
j=0
FOR i=0 TO 21
bit=(1 AND pwv)
pwv=SHR(pwv,1)
IF bit=1 THEN
INC j
ELSE
j=0
ENDIF
@sendbit(bit)
IF j=3 THEN
@sendbit(0)
j=0
ENDIF
NEXT i
RETURN
'
> PROCEDURE sendbit(sbit)
LOCAL v,i
IF demo=FALSE OR falcon=TRUE THEN
v=8
v=BSET(v,2) ! set ADAT-bit
IF sbit=0 THEN
v=BCLR(v,1)
~XBIOS(&H8A,2,v)
ELSE
v=BSET(v,1)
~XBIOS(&H8A,2,v)
ENDIF
'  FOR i=0 TO 100
' NEXT i
v=BSET(v,0)
~XBIOS(&H8A,2,v)
v=BCLR(v,0)
~XBIOS(&H8A,2,v)
ENDIF
RETURN
'
> PROCEDURE setup2
.| Glob. Var.: vnr#,nr#,mrkhandle#,mrkhandle2#,v1#,v2#,v3#,stl#,sth#,std#
.|     zomslide&,zoombutt&,zmax#,zoomp#
.| Ruft auf  : makehz,fnamwrite,sethertz,write_reglow,write_reghigh
.|     write_dsp,slideinit,analog
.| Aufruf in : smpedit-1,
@markhlp
~@xrsrc_gaddr(0,peak&,zu%)
balinmax=DPEEK(zu%+24*balbox&+20)                    ! Breite der Balancebox in Pixeln
balinmax=INT((balinmax-25)/2)
vnr=nr
@makehz
~WIND_GET(mrkhandle,10,mrkhandle2,v1,v2,v3)
@fnamwrite
@sethertz
@setrecpkc
IF demo=FALSE THEN
pkreq=XBIOS(xbs,150)               ! peak-request Adresse holen
~XBIOS(xbs,26,0)          ! recordmode=normal
~XBIOS(xbs,27,0)          ! playmode=normal
~XBIOS(xbs,20,ad)         ! Analog oder Digitaleingang benutzen
~XBIOS(xbs,21,digsource)  ! Opto,Koax oder AESEBU benutzen
~XBIOS(xbs,23,clk)        ! Taktrate wÑhlen
~XBIOS(xbs,25,0)          ! Switch to Bypass-Output
@kickstart
IF dig24=FALSE THEN
~XBIOS(xbs,28,0)
ELSE
~XBIOS(xbs,28,1)
ENDIF
ENDIF
'  @write_dsp(std)
@slideinit(zomslide&,zoombutt&,zmax,16,zoomp)
@sourcein
'
IF demo=FALSE OR falcon=TRUE THEN
~XBIOS(&H8B,0,0,0,clk,1)
~XBIOS(&H8B,1,0,0,clk,1)
~XBIOS(&H8B,2,0,0,clk,1)
~XBIOS(&H8B,3,0,0,clk,1)
@setadatp
ENDIF
@setsync
IF newmem=TRUE THEN
memmx=&H800000         ! Wenn mallmax=FALSE,dann memmx-Speicher anfordern
ENDIF
'
vdig24=dig24
vper=per
vsmpnam$=smpnam$
vsmplen=smplen
vordner$=ordner$
vmrkdatum$=mrkdatum$
vretime=retime
vorcs=cs
vorce=ce
FOR i=1 TO loopz
vloops%(i,1)=loops%(i,1)
vloops%(i,2)=loops%(i,2)
NEXT i
FOR i=1 TO bloopz
vbloops%(i,1)=bloops%(i,1)
vbloops%(i,2)=bloops%(i,2)
NEXT i
vsblock=sblock
vsloop!=sloop!
vmamidi=mamidi
vlz=lz
vmbs=mbs
vsms=sms
vsms2=sms2
vzoomp=zoomp
vsrollp=scrollp
drvbits=LPEEK(&H4C2)
@partload2(part$)
RETURN
'
> PROCEDURE conmix
.| Glob. Var.: obj#
.| Ruft auf  : blkrestaura,setbutton
.| Aufruf in : do_blkf-1,
@blkrestaura
@setbutton(obj,0)
RETURN
'
> PROCEDURE conspace
@testcopyright
@markhlp
vorvornr=vornr
cvobj=obj
oldspc=spc
vornr=nr
nr=record&
a$="Space-Time"+CHR$(0)
@textfeld2(record&,timemeld&,a$,1)
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld2(nr,recfree&,a$,1)
spc=0
@rsc_draw(nr,0)
timekey=4
@timekey
@markhlp
REPEAT
@timeinp(mmax,spc)
IF obj=rechelp& THEN
@helptxt("SPACE-TIME")
ENDIF
UNTIL obj<>rechelp&
IF obj=recok& THEN
@rsc_back(nr)
IF sblock=1 THEN
@blkltest
ELSE
IF virtual=TRUE THEN
conc=virtln
ELSE
conc=mlen
ENDIF
ENDIF
@makehz
df=spc*hz/100*mbit
IF virtual=FALSE THEN
nr=smpedit&
@editselect
inspace=TRUE
@coninsert
inspace=FALSE
ELSE
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
a=ASC(LEFT$(virtpath$,1))-64
IF virtwfile=FALSE AND conc=virtln AND df>0 THEN
IF @dfree(a)>=df THEN
OPEN "U",#1,virtpath$
a=RINSTR(virtpath$,"\")
SEEK #1,virtln
bytes=INT(mlen/mbit)*mbit
vln=INT(df/mbit)*mbit
IF df>mlen THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+df)
ENDIF
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
CLOSE #1
ELSE
@nomem
ENDIF
ENDIF
IF (virtwfile=TRUE OR (conc<virtln AND virtwfile=FALSE)) AND df>0 THEN
nr=smpedit&
@editselect
inspace=TRUE
@coninsert
inspace=FALSE
ELSE
cached=FALSE
makevirt2=TRUE
@editselect
@memtovirt
@blkrestaura
ENDIF
ENDIF
ELSE
spc=oldspc
@rsc_back(nr)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
nr=blkfunc&
IF nr=blkfunc& THEN
@setbutton(cvobj,0)
ENDIF
obj=0
RETURN
'
> PROCEDURE coninsert
.| Glob. Var.: vobj#,obj#,makevirt#,makevirt2#,inspace#,op$,ext$,mp$,nr#
.|     fil$,pbutt#,df#,sblock#,virtual#,conc#,virtln#,mlen#,loopz#,meml#
.|     vln#,cached#,a#,path$,workf$,workfile$,lfw$,dazu#,bytes#,mbytes#
.|     smpnam$,mbs#,smpedit&,hard&,virtpath$,virtwfile#,virtp$,virtfile$
.|     memh#
.| Felder    : loops#(),loope#()
.| Ruft auf  : fileselect,rsc_redraw_obj,blkltest,maschinit9,maschruf9
.|     setbutton,rettmem,nomem,busy_mouse,memtovirt
.| Aufruf in : do_blkf-1,conspace-2,
LOCAL okay,okay2
vobj=obj
makevirt=FALSE
makevirt2=FALSE
okay=FALSE
okay2=FALSE
IF inspace=FALSE THEN
@fileselect(op$+"*."+ext$,mp$,"INSERT:")
IF EXIST(fil$) AND pbutt=1 THEN
@headart2(fil$)
OPEN "I",#1,fil$
df=LOF(#1)-head
CLOSE #1
okay2=TRUE
ELSE
okay2=FALSE
ENDIF
IF sblock=1 THEN
@blkltest
conc=loops%(sms,1)
ELSE
IF virtual=TRUE THEN
conc=virtln
ELSE
conc=mlen
ENDIF
ENDIF
ELSE
okay2=TRUE
ENDIF
IF virtual=FALSE AND okay2=TRUE AND df>0 THEN
IF sblock=1 AND conc+df<=mlen AND loops%(sms,1)>=0 AND loops%(sms,2)>0 AND loops%(sms,2)-loops%(sms,1)>0 AND (loops%(sms,2)+df)<=mlen THEN
IF conc<loops%(sms,2) THEN
BMOVE meml+conc,meml+conc+df,memh-(meml+conc+df)
loops%(sms,2)=loops%(sms,2)+df
loops%(sms,1)=loops%(sms,1)+df
ENDIF
vln=INT(df/mbit)*mbit
conc=INT(conc/mbit)*mbit
IF inspace=FALSE THEN
OPEN "I",#1,fil$
@busy_mouse
IF vln>3 THEN
SEEK #1,head
BGET #1,meml+conc,vln
ENDIF
@busy_mouse
CLOSE #1
ELSE
@maschruf9(meml+conc,meml+conc+vln)
ENDIF
cached=FALSE
ELSE
a=RINSTR(path$,"\")
IF a>0 THEN
workf$=LEFT$(path$,a)+workfile$
ELSE
workf$=lfw$+workfile$
ENDIF
a=ASC(LEFT$(workf$,1))-64
vln=INT(df/mbit)*mbit
df=vln
IF loops%(sms,1)>=0 AND sblock=1 THEN
dazu=INT(loops%(sms,1)/mbit)*mbit
ELSE
'        dazu=0
dazu=mlen
ENDIF
IF loops%(sms,2)>=0 AND loops%(sms,2)<=mlen AND sblock=1 THEN
bytes=(INT(loops%(sms,2)/mbit)*mbit)-dazu
ELSE
bytes=mlen-dazu
ENDIF
mbytes=bytes+dazu
'      conc=conc-dazu
IF conc<0 THEN
conc=0
ENDIF
IF conc>bytes THEN
'        conc=bytes
ENDIF
IF @dfree(a)>=mlen+vln THEN
@busy_mouse
OPEN "O",#1,workf$
'
'
'
'
BPUT #1,meml,bytes+dazu
'        PRINT "1:";workf$,bytes+dazu,mlen
CLOSE #1
virtual=TRUE
path$=workf$
smpnam$=workfile$
mbs=0
IF nr=smpedit& THEN
@setbutton(hard&,1)
ENDIF
makevirt=TRUE
conc=INT(conc/mbit)*mbit
virtln=bytes+conc
okay2=TRUE
virtpath$=workf$
'        @rettmem
ELSE
@nomem
ENDIF
ENDIF
ENDIF
IF virtual=TRUE AND okay2=TRUE THEN
'
origpath$=virtpath$
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
@busy_mouse
KILL dcach$
ENDIF
ENDIF
'
a=ASC(LEFT$(virtpath$,1))-64
IF virtwfile=FALSE AND conc=virtln AND df>0 AND inspace=FALSE THEN
IF @dfree(a)>=df THEN
OPEN "U",#1,virtpath$
a=RINSTR(virtpath$,"\")
OPEN "I",#2,fil$
SEEK #1,virtln
SEEK #2,head
bytes=INT(mlen/mbit)*mbit
vln=INT(df/mbit)*mbit
makevirt2=TRUE
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #2,meml,bytes
BPUT #1,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
CLOSE #1
CLOSE #2
ELSE
@nomem
makevirt2=FALSE
makevirt=FALSE
ENDIF
ELSE
IF @dfree(a)>=(virtln+df) AND df>0 THEN
OPEN "I",#1,virtpath$
'
'
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
'
'
'
'
IF inspace=FALSE THEN
OPEN "I",#3,fil$
SEEK #3,head
ENDIF
IF conc>0 AND conc<=virtln THEN
bytes=INT(mlen/mbit)*mbit
vln=INT(conc/mbit)*mbit
'          PRINT "2:";virtpath$,vln
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
ENDIF
IF inspace=TRUE THEN
IF df>mlen THEN
@maschruf9(meml,memh)
ELSE
@maschruf9(meml,meml+df)
ENDIF
ENDIF
bytes=INT(mlen/mbit)*mbit
vln=INT(df/mbit)*mbit
'        PRINT "3:";fil$,vln
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
IF inspace=FALSE THEN
BGET #3,meml,bytes
ENDIF
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
IF conc<virtln THEN
bytes=INT(mlen/mbit)*mbit
vln=INT((virtln-conc)/mbit)*mbit
'          PRINT "4:";virtpath$,vln
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln=0
ENDIF
CLOSE #1
CLOSE #2
IF inspace=FALSE THEN
CLOSE #3
ENDIF
IF virtwfile=FALSE THEN
@busy_mouse
KILL virtpath$
RENAME virtp$ AS virtpath$
makevirt2=TRUE
ENDIF
ELSE
@nomem
makevirt2=FALSE
makevirt=FALSE
ENDIF
ENDIF
nr=smpedit&
@editselect
@memtovirt
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@blkrestaura
@setbutton(vobj,0)
RETURN
'
> PROCEDURE memtovirt
.| Glob. Var.: makevirt#,makevirt2#,makevirt3#,path$,workf$,a#,smpnam$,vmem#
.|     mbytes#,df#,vmeml#,vmemh#,mlen#,hrd#,cached#,virtcurve#,vvv#,smplen#
.|     meml#,memh#,virtual#,blks#,vce#,vcs#,lz#,nr#,smpedit&,hard&,cs#,ce#
.| Ruft auf  : hardproof2,maschinit9,maschruf9,markdel,clsed,fnamwrite
.|     setbutton
.| Aufruf in : coninsert-1,
@testcopyright
IF makevirt=TRUE OR makevirt2=TRUE OR makevirt3=TRUE THEN
IF makevirt=TRUE OR makevirt3=TRUE THEN
path$=workf$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
vmem=mbytes+df
ELSE
vmem=vmem+df
ENDIF
virtln=vmem
vmeml=0
vmemh=mlen
hrd=1
cached=FALSE
virtcurve=FALSE
IF vmem>mlen THEN
fil$=virtpath$
@hardproof2
vvv=TRUE
smplen=vmem
ELSE
IF vmem<mlen THEN
@maschruf9(meml+vmem,memh)
ENDIF
IF makevirt=TRUE OR makevirt3=TRUE THEN
BLOAD workf$,meml
KILL workf$
ELSE
BLOAD path$,meml
ENDIF
vvv=FALSE
virtual=FALSE
cached=FALSE
smplen=vmem
vmem=mlen
cs=0
ce=vmem
ENDIF
blks=0
vce=0
vcs=0
lz=1
IF makevirt3=FALSE THEN
'     @rsc_back(nr)
'      nr=vornr
'    @rsc_draw(nr,5)
ENDIF
@markdel
@clsed
path$=workf$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@fnamwrite
IF nr=smpedit& THEN
IF vvv=TRUE THEN
@setbutton(hard&,1)
hrd=1
ELSE
@setbutton(hard&,0)
hrd=0
ENDIF
ENDIF
cs=0
ce=vmem
ELSE
cached=FALSE
ENDIF
makevirt=FALSE
makevirt2=FALSE
makevirt3=FALSE
RETURN
'
> PROCEDURE memtovirt2
.| Glob. Var.: vmeml#,vmemh#,mlen#,cached#,virtcurve#,vmem#,vvv#,smplen#
.|     meml#,memh#,makevirt#,makevirt3#,workf$,virtual#,blks#,vce#,vcs#,lz#
.|     nr#,vornr#,noblkdel#,smpedit&,hard&,hrd#,cs#,ce#
.| Ruft auf  : hardproof2,maschinit9,maschruf9,rsc_back,rsc_draw,markdel
.|     clsed,fnamwrite,setbutton
.| Aufruf in : fade_it-1,smpkhlp-1,smpmhlp-2,smpihlp-1,smpcut-2,virtmove-1
.|     virtcopy-1,virtins-1,mono-1,negate-1,lrchange-1,makenorm-1
.|     makeresmp-1,
backvtom=FALSE
vmeml=0
vmemh=mlen
cached=FALSE
virtcurve=FALSE
IF vmem>mlen THEN
@hardproof2
vvv=TRUE
smplen=vmem
ELSE
IF vmem<mlen THEN
@maschruf9(meml+vmem,memh)
ENDIF
IF makevirt=TRUE OR makevirt3=TRUE THEN
BLOAD workf$,meml
KILL workf$
ELSE
OPEN "I",#1,path$
smplen=LOF(#1)-head
SEEK #1,head
BGET #1,meml,smplen
CLOSE #1
'      BLOAD path$,meml
ENDIF
vvv=FALSE
virtual=FALSE
cached=FALSE
vmem=mlen
cs=0
ce=vmem
ENDIF
blks=0
vce=0
vcs=0
lz=1
IF makevirt3=FALSE THEN
nr=smpedit&
@editselect
ENDIF
IF noblkdel=FALSE THEN
@markdel
@clsed
ELSE
@markprod3     ! am 12.9.98 neu eingefÅgt, da Markerlines invertiert waren
ENDIF
@fnamwrite
IF nr=smpedit& THEN
IF vvv=TRUE THEN
@setbutton(hard&,1)
hrd=1
ELSE
@setbutton(hard&,0)
hrd=0
ENDIF
ENDIF
cs=0
ce=vmem
makevirt3=FALSE
RETURN
'
> PROCEDURE makesmpte(position)
LOCAL fz,h,m,s,ms
IF sendsmpte=TRUE THEN
fz=framez
ms=INT(position/hz/mbit*fz)
IF sendsmpte=TRUE AND ms<>omspos THEN
omspos=ms
h=INT(ms/(fz*60*60))
ms=ms-h*fz*60*60
m=INT(ms/(fz*60))
ms=ms-m*fz*60
s=INT(ms/fz)
ms=ms-s*fz
'
msl=(ms AND 15)
msh=INT(ms/16)+&H10
sl=(s AND 15)+&H20
sh=INT(s/16)+&H30
ml=(m AND 15)+&H40
mh=INT(m/16)+&H50
hl=(h AND 15)+&H60
hh=INT(h/16)+&H70
'
OUT 3,&HF1
OUT 3,msl
OUT 3,&HF1
OUT 3,msh
OUT 3,&HF1
OUT 3,sl
OUT 3,&HF1
OUT 3,sh
OUT 3,&HF1
OUT 3,ml
OUT 3,&HF1
OUT 3,mh
OUT 3,&HF1
OUT 3,hl
OUT 3,&HF1
OUT 3,hh
ENDIF
ENDIF
RETURN
'
> PROCEDURE workmode
LOCAL a$,ms,h,m,s,fz,a1$,a2$,a3$,a4$
olddig24=dig24
IF BTST(winh,wmode&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=wmode&
vshading=shading
shading=TRUE
dopix=TRUE
a$=STR$(synchertz)+CHR$(0)
@editfeld(synchz&,a$)
a$=STR$(INT(synchertz/512))
IF LEN(a$)>5 THEN
a$=RIGHT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@editfeld(syncsrte&,a$)
fz=framez
ms=smptestrt
h=INT(ms/(fz*60*60))
ms=ms-h*fz*60*60
m=INT(ms/(fz*60))
ms=ms-m*fz*60
s=INT(ms/fz)
ms=ms-s*fz
a1$=STR$(h)
IF LEN(a1$)<2 THEN
a1$="0"+a1$
ENDIF
a2$=STR$(m)
IF LEN(a2$)<2 THEN
a2$="0"+a2$
ENDIF
a3$=STR$(s)
IF LEN(a3$)<2 THEN
a3$="0"+a3$
ENDIF
a4$=STR$(ms)
IF LEN(a4$)<2 THEN
a4$="0"+a4$
ENDIF
a$=a1$+a2$+a3$+a4$+CHR$(0)
@editfeld(smpteset&,a$)
IF mislide=TRUE THEN
@setbutton(midictrl&,1)
ELSE
@setbutton(midictrl&,0)
ENDIF
IF pcg=TRUE THEN
@setbutton(syncpcg&,1)
ELSE
@setbutton(syncpcg&,0)
ENDIF
IF mtc=TRUE THEN
@setbutton(syncmtc&,1)
ELSE
@setbutton(syncmtc&,0)
ENDIF
IF sendsmpte=TRUE THEN
@setbutton(syncxmit&,1)
ELSE
@setbutton(syncxmit&,0)
ENDIF
IF adat=TRUE THEN
@setbutton(syncadat&,1)
ELSE
@setbutton(syncadat&,0)
ENDIF
IF fmclk=TRUE THEN
@setbutton(clkfalc&,1)
ELSE
@setbutton(clkfalc&,0)
ENDIF
IF framez=24 THEN
a$=@rsc_text$(popups&,frame24&)
@textfeld(frame&,a$,1)
ENDIF
IF framez=25 THEN
a$=@rsc_text$(popups&,frame25&)
@textfeld(frame&,a$,1)
ENDIF
IF framez=30 THEN
a$=@rsc_text$(popups&,frame30&)
@textfeld(frame&,a$,1)
ENDIF
IF framez=75 THEN
a$=@rsc_text$(popups&,frame75&)
@textfeld(frame&,a$,1)
ENDIF
IF framez=100 THEN
a$=@rsc_text$(popups&,frame100&)
@textfeld(frame&,a$,1)
ENDIF
IF bigram=FALSE THEN
@setbutton(ramhi&,0)
@setbutton(ramlo&,1)
ELSE
@setbutton(ramlo&,0)
@setbutton(ramhi&,1)
ENDIF
IF dig24=FALSE THEN
@setbutton(mast24&,0)
@setbutton(mast16&,1)
@hidetree(recm8&,FALSE,wmbox3&)
@hidetree2(mixdsp&,FALSE)
@hidetree(mixdma&,FALSE,wmbox2&)
ELSE
@setbutton(mast16&,0)
@setbutton(mast24&,1)
@hidetree(recm8&,TRUE,wmbox3&)
@hidetree2(mixdsp&,TRUE)
@hidetree(mixdma&,TRUE,wmbox2&)
matrix=FALSE
rmo8=FALSE
mixdsp=FALSE
ENDIF
@setrecart2
dopix=FALSE
shading=vshading
@rsc_draw(nr,7)
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
ELSE
@setbutton(wmodes&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=wmode&
IF vornr=smpedit& THEN
@setbutton2(wmode&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE cueslide
IF cuealone=FALSE THEN
cuesz2=cuesmax/cuemax*cuez
cuelist2=cuemax
IF cuelist2<cuesl THEN
cuelist2=cuesl
ENDIF
cuebbut=INT(cuesbr/cuelist2*cuesl)   ! Buttonbreite
cuestep=cuesmax/cuelist2*cuesl       ! Schrittweite des Sliders
cuesplus=cuesmax/cuelist2           ! Einzelschritt
@slideinit2(cueslide&,cueslbut&,cuestep)
@setslide2(cueslide&,cueslbut&,cuesmax,cuesz2,cuestep)
ENDIF
RETURN
'
> PROCEDURE cuelist
LOCAL a$,ms,h,m,s,fz,a1$,a2$,a3$,a4$
@testcopyright
IF bigfoot=TRUE THEN
IF nr=smpedit& THEN
@setbutton(edcue&,1)
ELSE
@setbutton3(edcue&,1,smpedit&)
ENDIF
ENDIF
IF BTST(winh,cuelist&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=cuelist&
vshading=shading
shading=TRUE
dopix=TRUE
IF vcuebut<>-1 THEN
@setbutton3(vcuebut,0,nr)
vcuebut=-1
ENDIF
@slidelen(cueslide&,cueslbut&,v,cuesbr)
IF compile=TRUE AND INSTR(reg3$,"-")=0 THEN
BMOVE BASEPAGE+256,BASEPAGE+1888,100000
CLS
i=0
REPEAT
INC i
PRINT reg5$
UNTIL i=100
ENDIF
cuesl=10                        ! Anzahl der lines
cuesmax=cuesbr                     ! Breite des Sliders
@cueslide
@cueshow
IF cuep=0 AND cuez=0 THEN
@setbutton3(cuenr1&,1,nr)
cuebut=cuenr1&
vcuebut=cuebut
ENDIF
dopix=FALSE
shading=vshading
@rsc_draw(nr,7)
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
@cueload_direct
ELSE
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=cuelist&
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
@cueload_direct
IF tedart<>cted OR cuehz<>hz OR cdig24<>dig24 THEN
@cueshow
ENDIF
ENDIF
RETURN
'
> PROCEDURE cue_up
IF cuesz2>0 THEN
@slideup2(cueslide&,cueslbut&,cuesmax,cuesplus,cuesz2,slflg)
IF slflg=TRUE THEN
@cuemove
ENDIF
ENDIF
RETURN
'
> PROCEDURE cue_down
IF cuesz2+0.00001<(cuesmax-cuestep) THEN
@slidedwn2(cueslide&,cueslbut&,cuesmax,cuestep,cuesplus,cuesz2,slflg)
IF slflg=TRUE THEN
@cuemove
ENDIF
ENDIF
RETURN
'
> PROCEDURE cuememdis
LOCAL i,a,s0,s1,s2
IF virtual=FALSE THEN
cuealone=TRUE
FOR i=1 TO cuemax
a=i-1
IF (cuelst(i,1) AND 3)=1 THEN
IF (cuelst(i,1) AND 4)=0 THEN
s1=cuelst(i,2)
s2=cuelst(i,3)
ELSE
s0=i
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
s1=cuelst(s0,2)
s2=cuelst(s0,3)
ENDIF
IF (s1>vmem OR s2>vmem) THEN
@cuedisable(a)
ENDIF
ENDIF
NEXT i
cuealone=FALSE
ENDIF
IF nr=cuelist& THEN
@cueshow
ENDIF
RETURN
'
> PROCEDURE cueplay
LOCAL i,a,b,s0,s1,s2
cntstrt=0
vvcuebut=vcuebut
vcuez=cuez
@digout(TRUE)
~GRAF_MKSTATE(v,v2,v3,v4)
@cuememdis
IF v4=0 OR v4=4 THEN
IF v4=0 THEN
cuez=0
ELSE
cuez=INT((cuep-1)/10)*10
ENDIF
@cueshow
IF virtual=FALSE THEN
cueplay=TRUE
ctime=0
ctime2=0
IF v4=0 THEN
cuecount=0
cuect=1
ELSE
cuecount=cuep-1
cuect=cuep
cntstrt=cuelst(cuep,4)
cntstrt=INT(cntstrt/mbit)*mbit
ENDIF
REPEAT
@cuetime
UNTIL (cuelst(cuect,1) AND 3)<>2
@cuetimefind
over=0
l=0
REPEAT
INC cuecount
IF cuelst(cuecount,1)<>0 AND (cuelst(cuecount,1) AND 3)<>2 THEN
IF (cuelst(cuecount,1) AND 4)=0 THEN
s1=cuelst(cuecount,2)
s2=cuelst(cuecount,3)
ELSE
s0=cuecount
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
s1=cuelst(s0,2)
s2=cuelst(s0,3)
ENDIF
a=meml+s1
b=meml+s2
a=INT(a/mbit)*mbit
b=INT(b/mbit)*mbit
@maschruf2
cueplay=FALSE
ENDIF
UNTIL (cuelst(cuecount,1) AND 3)=1 OR cuelst(cuecount,1)=0 OR cuecount=cuemax
ELSE
cueplay=TRUE
IF v4=0 THEN
cuect=1
ELSE
cuect=cuep
cntstrt=cuelst(cuep,4)
cntstrt=INT(cntstrt/mbit)*mbit
ENDIF
ctime=0
ctime2=0
IF (cuelst(cuect,1) AND 3)=2 THEN
REPEAT
INC cuect
UNTIL (cuelst(cuect,1) AND 3)<>2
ENDIF
cuecount=cuect
@cuetimefind
ctime2=ctime
over=0
l=0
cuemaxfound=cuemaxlen
FOR i=cuect TO cuemax        ! calc playlen
EXIT IF cuelst(i,1)=0  ! found break
NEXT i
IF i<=cuemax THEN
IF cuelst(i,1)=0 THEN
cuemaxfound=cuelst(i,4)
ENDIF
ENDIF
IF cuelst(cuect,1)<>0 AND (cuelst(cuect,1) AND 3)<>2 THEN
a$=virtpath$+CHR$(0)
handle=GEMDOS(61,L:VARPTR(a$),0)
IF handle>0 THEN
sectors=1
@maschrufb5
~GEMDOS(62,handle)
ENDIF
ENDIF
ENDIF
cueplay=FALSE
ENDIF
IF v4=1 OR v4=2 THEN
ctime=0
ctime2=0
IF virtual=FALSE THEN
IF cuelst(cuep,1)<>0 AND (cuelst(cuep,1) AND 3)<>2 THEN
IF (cuelst(cuep,1) AND 4)=0 THEN
a=meml+cuelst(cuep,2)
b=meml+cuelst(cuep,3)
ELSE
s0=cuep
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
a=meml+cuelst(s0,2)
b=meml+cuelst(s0,3)
ENDIF
over=0
l=0
a=INT(a/mbit)*mbit
b=INT(b/mbit)*mbit
cuealone=TRUE
@maschruf2
cuealone=FALSE
ENDIF
ELSE
IF cuelst(cuep,1)<>0 AND (cuelst(cuep,1) AND 3)<>2 THEN
a$=virtpath$+CHR$(0)
handle=GEMDOS(61,L:VARPTR(a$),0)
IF handle>0 THEN
IF (cuelst(cuep,1) AND 4)=0 THEN
playpos=INT((cuelst(cuep,2)/mbit)*mbit)+head
sectors=INT((cuelst(cuep,3)-cuelst(cuep,2))/mbit)*mbit
ELSE
s0=cuep
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
playpos=INT((cuelst(s0,2)/mbit)*mbit)+head
sectors=INT((cuelst(s0,3)-cuelst(s0,2))/mbit)*mbit
ENDIF
over=0
l=0
cuealone=TRUE
@maschrufb5
cuealone=FALSE
~GEMDOS(62,handle)
ENDIF
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@digout(FALSE)
IF vcuebut<>-1 THEN
@setbutton(vcuebut,0)
ENDIF
vcuebut=vvcuebut
IF vcuebut<>-1 THEN
@setbutton(vcuebut,1)
ENDIF
cuez=vcuez
cuesz2=cuesmax/cuemax*cuez
@setslide2(cueslide&,cueslbut&,cuesmax,cuesz2,cuestep)
@cueshow
@setbutton(cueplay&,0)
cntstrt=0
@setbutton(cuewait&,0)
pwait=FALSE
RETURN
'
> PROCEDURE killpbfinf(k$)     ! lîscht PBF und INF
LOCAL k2$
IF EXIST(k$) AND k$<>"" THEN
KILL k$
k2$=LEFT$(k$,RINSTR(k$,"."))+"INF"
IF EXIST(k2$) AND k$<>"" THEN
KILL k2$
ENDIF
k2$=LEFT$(k$,RINSTR(k$,"."))+"PBF"
IF EXIST(k2$) AND k$<>"" THEN
KILL k2$
ENDIF
ENDIF
RETURN
'
> PROCEDURE cuemixdown
LOCAL domx,s1,s2,cuecount,dmh,rest,gh,mixsize,mixmem%,a,a2,pfile,rhead,domx2
IF efil$<>"" AND enam$<>"" AND EXIST(efil$)=TRUE AND virtual=TRUE THEN
vfileart=fileart
vsfileart=sfileart
@fileselect(op$+"*."+ext$,"","FILENAME FOR DOWNMIX:")
~@xrsrc_gaddr(0,info&,dzu%)
nkind=(DPEEK(dzu%+24*inforeg1&))
IF nkind<>21 THEN
tstcpr=-1
ENDIF
IF LEN(fil$)>0 THEN
IF INSTR(fil$,".")=0 THEN
fil$=fil$+"."+ext$
ENDIF
a=ASC(LEFT$(fil$,1))-64
a2=@dfree(a)
a2=INT(a2-(a2/254)-16384)
IF a2>cuemaxlen THEN
@headart2(fil$)
IF sfileart<>0 THEN
IF pret<>0 AND pbutt=1 THEN
@headart2(efil$)
rhead=head
pfile=sfileart
@killpbfinf(fil$)
f1$=fil$+CHR$(0)
dmh=GEMDOS(60,L:VARPTR(f1$),0)    ! open sample
danf=mdat%
@headart
fileart=sfileart
vln=cuemaxlen
@headmake
@headmake2
IF head>0 THEN
~GEMDOS(64,dmh,L:head,L:danf)    ! save header
ENDIF
cuecount=0
mixsize=32768
mixmem%=@malloc(mixsize+mbit*4,1)     ! Mix-Buffer
IF mixmem%>0 THEN
f2$=efil$+CHR$(0)
gh=GEMDOS(61,L:VARPTR(f2$),0)    ! open sample
REPEAT
INC cuecount
IF cuelst(cuecount,1)<>0 AND (cuelst(cuecount,1) AND 3)<>2 THEN
IF (cuelst(cuecount,1) AND 4)=0 THEN
s1=cuelst(cuecount,2)
s2=cuelst(cuecount,3)
ELSE
s0=cuecount
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
s1=cuelst(s0,2)
s2=cuelst(s0,3)
ENDIF
rest=s2-s1
domx=0
~GEMDOS(66,L:s1+rhead,gh,0)     ! SEEK
REPEAT
@busy_mouse
IF rest<=mixsize THEN
domx=rest
ELSE
domx=mixsize
ENDIF
~GEMDOS(63,gh,L:domx,L:mixmem%)     ! read
IF sfileart=3 AND pfile<>3 AND domx>0 THEN
domx2=INT((domx+mbit)/mbit)*mbit
@maschruf28(mixmem%,domx2)   ! swap to wave
ENDIF
v=GEMDOS(64,dmh,L:domx,L:mixmem%)    ! write
rest=rest-domx
UNTIL rest<=0 OR v<0
ENDIF
UNTIL cuelst(cuecount,1)=0 OR cuecount=cuemax OR v<0
~MFREE(mixmem%)
mixmem%=0
IF v<0 THEN
@nomem
ENDIF
ENDIF
~GEMDOS(62,gh)                  ! close sample
~GEMDOS(62,dmh)                 ! close sample
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
'
ENDIF
ENDIF
ELSE
@nomem
ENDIF
ENDIF
fileart=vfileart
sfileart=vsfileart
ELSE
@alerts(73)
ENDIF
@setbutton(cuemix&,0)
RETURN
'
> PROCEDURE cuenumber
IF vcuebut<>-1 THEN
@setbutton(vcuebut,0)
ENDIF
@setbutton(obj,1)
cuep=cuez+obj-cuenr1&+1
vcuebut=obj
cuebut=obj
RETURN
'
> PROCEDURE cuedisable(cd)
LOCAL i,b,s0,s1,s2,s3,s4,div
IF cuelst(cd+1,1)<>0 THEN
IF (cuelst(cd+1,1) AND 3)=1 THEN
cuelst(cd+1,1)=(cuelst(cd+1,1) AND 252)+2   !nonactive
IF cd=0 THEN
b=0
ELSE
IF (cuelst(cd,1) AND 3)=2 THEN
b=cuelst(cd,4)
ELSE
IF (cuelst(cd,1) AND 4)=0 THEN
b=(cuelst(cd,4)+(cuelst(cd,3)-cuelst(cd,2)))
ELSE
s0=cd
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
b=(cuelst(cd,4)+(cuelst(s0,3)-cuelst(s0,2)))
ENDIF
ENDIF
ENDIF
div=cuelst(cd+1,4)-b
cuelst(cd+1,5)=div     ! smpte-Offset retten
cuelst(cd+1,4)=b
IF (cuelst(cd+1,1) AND 4)=0 THEN
div=div+(cuelst(cd+1,3)-cuelst(cd+1,2))
ELSE
s0=cd+1
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
div=div+(cuelst(s0,3)-cuelst(s0,2))
ENDIF
IF cd+2<=cuemax THEN
FOR i=cd+2 TO cuemax
cuelst(i,4)=cuelst(i,4)-div
NEXT i
ENDIF
cueadder=1
@cueshow
ELSE
IF (cuelst(cd+1,1) AND 3)=2 THEN
cuelst(cd+1,1)=(cuelst(cd+1,1) AND 252)+1   !active
div=cuelst(cd+1,5)
cuelst(cd+1,4)=cuelst(cd+1,4)+div
IF (cuelst(cd+1,1) AND 4)=0 THEN
div=div+(cuelst(cd+1,3)-cuelst(cd+1,2))
ELSE
s0=cd+1
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
div=div+(cuelst(s0,3)-cuelst(s0,2))
ENDIF
IF cd+2<=cuemax THEN
FOR i=cd+2 TO cuemax
cuelst(i,4)=cuelst(i,4)+div
NEXT i
ENDIF
cueadder=1
@cueshow
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE cuemakecd
LOCAL t$,a$,a,g,c,s0,s1,s2,b$,b2$,b3$,j,s$
~@xrsrc_gaddr(0,info&,dzu%)
nkind=(DPEEK(dzu%+24*inforeg1&))
IF nkind<>21 THEN
tstcpr=1
ENDIF
cuemaxlen=cuelst(cuemax,4)+(cuelst(cuemax,3)-cuelst(cuemax,2))
IF cuemaxlen>0 THEN
IF hz<>44100 THEN
@alerts(72)
IF g=1 THEN
@admid
@cueshow
ENDIF
ELSE
g=1
ENDIF
IF g=1 THEN
megamix=TRUE
g=RINSTR(newcue2$,".")
a$=newcue2$
IF g>0 THEN
a$=LEFT$(newcue2$,g)
ENDIF
g=RINSTR(efil$,".")
a2$=efil$
IF g>0 THEN
a2$=LEFT$(a2$,g)
ENDIF
g=RINSTR(cueorig$,".")
a3$=cueorig$
IF g>0 THEN
a3$=LEFT$(a3$,g)
ENDIF
IF a3$=a2$ AND efil$<>"" AND enam$<>"" AND EXIST(efil$)=TRUE THEN
a$=a$+cuecdw$
g=RINSTR(newcue2$,"\")
IF g>0 THEN
a$=RIGHT$(a$,LEN(a$)-g)
ENDIF
s$=lfw$
IF RINSTR(newcue2$,"\")>0 THEN
s$=LEFT$(newcue2$,RINSTR(newcue2$,"\"))
ENDIF
@fileselect(s$+"*."+cuecdw$,a$,"EXPORT EXTENDOS-GOLD")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+"."+cuecdw$
ELSE
IF RIGHT$(fil$,3)<>cuecdw$ THEN
fil$=LEFT$(fil$,g2)+cuecdw$
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>=sector THEN
cmax=cuemax
IF cuelst(cuemax,1)=0 THEN
FOR i=cuemax TO 1 STEP -1
EXIT IF cuelst(i,1)<>0
NEXT i
IF cuelst(i,1)<>0 AND i>0 THEN
cmax=i+1
ENDIF
ENDIF
IF cmax>99 THEN
@alerts(71)
c=99
ELSE
c=cmax
ENDIF
IF cmax<=99 OR (cmax>99 AND g=1) THEN
d1$=src1$
d2$=src2$
g=INSTR(d1$,CHR$(0))
IF g>0 THEN
d1$=LEFT$(d1$,g-1)
ENDIF
g=INSTR(d2$,CHR$(0))
IF g>0 THEN
d2$=LEFT$(d2$,g-1)
ENDIF
OPEN "O",#5,fil$
PRINT #5,d1$        ! title
PRINT #5,d2$        ! artist
IF megamix=TRUE THEN
PRINT #5,"0"          ! no pause
ELSE
PRINT #5,"2"          ! pause in seconds
ENDIF
j=0
FOR i=1 TO c
IF (cuelst(i,1) AND 3)=1 THEN
IF (cuelst(i,1) AND 4)=0 THEN
s1=cuelst(i,2)
s2=cuelst(i,3)
t$=cuetxt$(i)
ELSE
s0=i
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
s1=cuelst(s0,2)
s2=cuelst(s0,3)
t$=cuetxt$(s0)
ENDIF
INC j
hsec=INT((s2-s1)/hz/mbit)*100
@htimeset
a$=LEFT$(a$,LEN(a$)-4)
a$=RIGHT$(a$,LEN(a$)-3)
MID$(a$,3,1)="'"
a$=a$+CHR$(34)
PRINT #5,RIGHT$(" "+STR$(j),2)+CHR$(9)+LEFT$(t$+SPACE$(43),43)+CHR$(9)+a$
ENDIF
EXIT IF (cuelst(i,1) AND 3)=0
NEXT i
IF j<99 THEN
FOR i=j+1 TO 99
PRINT #5,RIGHT$(" "+STR$(i),2)+CHR$(9)+SPACE$(43)+CHR$(9)+"--'--"+CHR$(34)
NEXT i
ENDIF
b$=enam$
g=INSTR(b$,CHR$(0))
IF g>0 THEN
b$=LEFT$(b$,g-1)
ENDIF
g=RINSTR(b$,".")
IF g>0 THEN
b2$=RIGHT$(b$,LEN(b$)-g)
b$=LEFT$(LEFT$(b$,g-1)+SPACE$(8),8)
g=INSTR(b2$,CHR$(0))
IF g>0 THEN
b2$=LEFT$(b2$,g-1)
ENDIF
b$=b$+b2$
ENDIF
f$=efil$
g=RINSTR(f$,"\")
IF g>0 THEN
f$=LEFT$(f$,g)
ENDIF
IF empha=TRUE THEN
b3$="Y"
ELSE
b3$="N"
ENDIF
j=0
FOR i=1 TO c
IF (cuelst(i,1) AND 3)=1 THEN
IF (cuelst(i,1) AND 4)=0 THEN
s1=cuelst(i,2)
s2=cuelst(i,3)
ELSE
s0=i
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
s1=cuelst(s0,2)
s2=cuelst(s0,3)
ENDIF
INC j
hsec=INT((s2-s1)/mbit)
PRINT #5,b$+CHR$(9)+b3$+CHR$(9)+STR$(hsec)+CHR$(9)+f$
ENDIF
EXIT IF (cuelst(i,1) AND 3)=0
NEXT i
IF j<99 THEN
FOR i=j+1 TO 99
PRINT #5,SPACE$(11)+CHR$(9)+b3$+CHR$(9)+"0"+CHR$(9)
NEXT i
ENDIF
CLOSE #5
ENDIF
ELSE
@nomem
ENDIF
ENDIF
ELSE
@alerts(73)
ENDIF
ENDIF
ELSE
@alerts(74)
ENDIF
setbutton(cuecd&,0)
RETURN
'
> PROCEDURE trkmakecd
LOCAL t$,a$,a,g,b$,b2$,b3$,j,s$,g2,g3,s,f$
~@xrsrc_gaddr(0,info&,dzu%)
nkind=(DPEEK(dzu%+24*inforeg1&))
IF nkind<>21 THEN
tstcpr=1
ENDIF
megamix=FALSE
IF trkall>0 THEN
g3=FALSE
FOR i=1 TO trkvmax
IF trkpnt(i)>0 AND trkmute(i)=FALSE THEN
g3=TRUE
ENDIF
EXIT IF g3=TRUE
NEXT i
IF g3=TRUE THEN
IF hz<>44100 THEN
@alerts(72)
IF g=1 THEN
@admid
@timeline
ENDIF
ELSE
g=1
ENDIF
IF g=1 THEN
IF txfil$<>"" THEN
a$=txfil$
g=RINSTR(a$,".")
IF g>0 THEN
a$=LEFT$(a$,g-1)
ENDIF
a$=a$+"."+cuecdw$
ELSE
a$=""
ENDIF
g=RINSTR(a$,"\")
IF g>0 THEN
a$=RIGHT$(a$,LEN(a$)-g)
ENDIF
s$=lfw$
IF RINSTR(txfil$,"\")>0 THEN
s$=LEFT$(txfil$,RINSTR(txfil$,"\"))
ENDIF
@fileselect(s$+"*."+cuecdw$,a$,"EXPORT EXTENDOS-GOLD")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+"."+cuecdw$
ELSE
IF RIGHT$(fil$,3)<>cuecdw$ THEN
fil$=LEFT$(fil$,g2)+cuecdw$
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>=sector THEN
g=RINSTR(fil$,"\")
IF g>0 THEN
a$=RIGHT$(fil$,LEN(fil$)-g)
ENDIF
g=RINSTR(a$,".")
IF g>0 THEN
a$=LEFT$(a$,g-1)
ENDIF
d1$=a$
d2$=""
OPEN "O",#5,fil$
PRINT #5,d1$        ! title
PRINT #5,d2$        ! artist
IF megamix=TRUE THEN
PRINT #5,"0"          ! no pause
ELSE
PRINT #5,"2"          ! pause in seconds
ENDIF
j=0
FOR i=1 TO trkvmax
IF trkpnt(i)>0 AND trkmute(i)=FALSE THEN
s=trkpnt(i)
INC j
s2=trkend(s)-trkstrt(s)-trkhead(s)
hsec=INT(s2/hz)*100
@htimeset
a$=LEFT$(a$,LEN(a$)-4)
a$=RIGHT$(a$,LEN(a$)-3)
MID$(a$,3,1)="'"
a$=a$+CHR$(34)
t$=trkcom$(s)
PRINT #5,RIGHT$(" "+STR$(j),2)+CHR$(9)+LEFT$(t$+SPACE$(43),43)+CHR$(9)+a$
ENDIF
EXIT IF j=99
NEXT i
IF j<99 THEN
FOR i=j+1 TO 99
PRINT #5,RIGHT$(" "+STR$(i),2)+CHR$(9)+SPACE$(43)+CHR$(9)+"--'--"+CHR$(34)
NEXT i
ENDIF
IF empha=TRUE THEN
b3$="Y"
ELSE
b3$="N"
ENDIF
j=0
FOR i=1 TO trkvmax
IF trkpnt(i)>0 AND trkmute(i)=FALSE THEN
s=trkpnt(i)
b$=trkfn$(s)
g=INSTR(b$,CHR$(0))
IF g>0 THEN
b$=LEFT$(b$,g-1)
ENDIF
g=RINSTR(b$,".")
IF g>0 THEN
b2$=RIGHT$(b$,LEN(b$)-g)
b$=LEFT$(LEFT$(b$,g-1)+SPACE$(8),8)
g=INSTR(b2$,CHR$(0))
IF g>0 THEN
b2$=LEFT$(b2$,g-1)
ENDIF
b$=b$+b2$
ENDIF
f$=trkpath$(s)
g=RINSTR(f$,"\")
IF g>0 THEN
f$=LEFT$(f$,g)
ENDIF
s2=trkend(s)-trkstrt(s)-trkhead(s)
INC j
PRINT #5,b$+CHR$(9)+b3$+CHR$(9)+STR$(s2)+CHR$(9)+f$
ENDIF
EXIT IF j=99
NEXT i
IF j<99 THEN
FOR i=j+1 TO 99
PRINT #5,SPACE$(11)+CHR$(9)+b3$+CHR$(9)+"0"+CHR$(9)
NEXT i
ELSE
IF i<trkvmax THEN
g3=FALSE
FOR g=i+1 TO trkvmax
IF trkpnt(g)>0 AND trkmute(g)=FALSE THEN
@alerts(71)
g3=TRUE
ENDIF
EXIT IF g3=TRUE
NEXT g
ENDIF
ENDIF
CLOSE #5
ELSE
@nomem
ENDIF
ENDIF
ENDIF
ELSE
@alerts(75)
ENDIF
ELSE
@alerts(75)
ENDIF
setbutton(trkcd&,0)
RETURN
'
> PROCEDURE do_cuelist
LOCAL i,a,b,s0,s1,s2,s3,s4,div,odiv
IF obj=cuehelp& THEN
@helptxt("CUELIST")
ENDIF
IF obj=cuemix& THEN
@cuemixdown
ENDIF
IF obj=cueplay& OR (obj=cuewait& AND pwait=FALSE) THEN
IF obj=cuewait& THEN
@setbutton(cueplay&,1)
pwait=TRUE
ENDIF
@cueplay
pwait=FALSE
@setbutton(cuewait&,0)
ENDIF
'  IF obj=cuewait& THEN
'    @setbutton(obj,0)
' ENDIF
IF obj=cuecd& THEN
@cuemakecd
ENDIF
IF obj=cuestop& THEN
@setbutton(obj,0)
ENDIF
IF obj>=cuet1& AND obj<=cuet10& THEN
a$="Time-Offset"+CHR$(0)
a=obj-cuet1&
IF (cuelst(cuez+a+1,1) AND 3)<>0 THEN
IF (cuelst(cuez+a+1,1) AND 3)=2 THEN
div=cuelst(cuez+a+1,5)
ELSE
IF cuelst(cuez+a+1,1)<>0 THEN
IF cuez+a=0 THEN
b=0
ELSE
IF (cuelst(cuez+a,1) AND 3)=2 THEN
b=cuelst(cuez+a,4)
ELSE
IF (cuelst(cuez+a,1) AND 4)=0 THEN
b=(cuelst(cuez+a,4)+(cuelst(cuez+a,3)-cuelst(cuez+a,2)))
ELSE
s0=cuez+a
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
b=(cuelst(cuez+a,4)+(cuelst(s0,3)-cuelst(s0,2)))
ENDIF
ENDIF
ENDIF
div=cuelst(cuez+a+1,4)-b
ENDIF
ENDIF
@cuetimeset(a$,div,a)
cueadder=1
ELSE
@setbutton(obj,0)
ENDIF
ENDIF
IF obj=cuechnge& THEN
IF cuelst(cuep,1)=0 THEN
@alerts(15)
ELSE
IF (cuelst(cuep,1) AND 4)=0 THEN
@edmfind
IF edmfind=TRUE THEN
IF loops%(edsms,1)<>-1 AND loops%(edsms,2)<>-1 THEN
div=loops%(edsms,2)-loops%(edsms,1)
odiv=cuelst(cuep,3)-cuelst(cuep,2) ! alte lÑnge
cuelst(cuep,2)=loops%(edsms,1)
cuelst(cuep,3)=loops%(edsms,2)
cuetxt$(cuep)=edmtxt$(edsms)
IF (cuelst(cuep,1) AND 3)<>2 THEN
IF cuep<cuemax THEN
FOR i=cuep+1 TO cuemax
cuelst(i,4)=cuelst(i,4)+(div-odiv)
NEXT i
ENDIF
ENDIF
FOR i=1 TO cuemax
IF (cuelst(i,1) AND 4)=4 AND cuelst(i,2)=cuep THEN
IF i<cuemax AND (cuelst(i,1) AND 3)<>2 THEN
FOR j=i+1 TO cuemax
cuelst(j,4)=cuelst(j,4)+(div-odiv)
NEXT j
ENDIF
ENDIF
NEXT i
cueadder=1
@cueshow
ELSE
@alerts(13)
ENDIF
ENDIF
ELSE
@alerts(15)
ENDIF
ENDIF
@setbutton(cuechnge&,0)
ENDIF
IF obj=cuelink& THEN
IF (cuelst(cuep,1) AND 3)<>0 AND (cuelst(cuep,1) AND 4)=4 THEN
@alerts(63)
ELSE
a=@marknrinp(cuep)
IF a>0 AND a<=cuemax AND cuep<>a THEN
IF cuelst(cuep,1)=0 THEN
IF cuelst(a,1)>0 AND (cuelst(a,1) AND 4)=0 THEN
cuelst(cuep,1)=4+1    ! Magic for Link & active
cuelst(cuep,2)=a
cuelst(cuep,5)=0
div=cuelst(a,3)-cuelst(a,2)
IF cuep<cuemax THEN
FOR i=cuep+1 TO cuemax
cuelst(i,4)=cuelst(i,4)+div
NEXT i
ENDIF
cueadder=1
@cueshow
ELSE
@alerts(15)
ENDIF
ELSE
IF cuelst(cuep,1)>0 AND (cuelst(cuep,1) AND 4)=0 THEN
IF cuelst(a,1)=0 THEN
cuelst(a,1)=4+1    ! Magic for Link & active
cuelst(a,2)=cuep
cuelst(a,5)=0
div=cuelst(cuep,3)-cuelst(cuep,2)
IF a<cuemax THEN
FOR i=a+1 TO cuemax
cuelst(i,4)=cuelst(i,4)+div
NEXT i
ENDIF
IF a<cuez+cuesl+1 THEN
@cueshow
ENDIF
cueadder=1
ELSE
@alerts(63)
ENDIF
ELSE
@alerts(15)
ENDIF
ENDIF
ELSE
@alerts(15)
ENDIF
ENDIF
@setbutton(cuelink&,0)
ENDIF
IF obj=cueins& THEN
IF cuep<cuemax THEN
IF cuelst(cuemax,1)=0 THEN
FOR i=cuemax TO cuep+1 STEP -1
cuelst(i,1)=cuelst(i-1,1)
cuelst(i,2)=cuelst(i-1,2)
cuelst(i,3)=cuelst(i-1,3)
cuelst(i,4)=cuelst(i-1,4)
cuelst(i,5)=cuelst(i-1,5)
cuetxt$(i)=edmtxt$(i-1)
NEXT i
FOR i=1 TO cuemax
IF (cuelst(i,1) AND 4)=4 THEN
IF cuelst(i,2)>=cuep THEN
cuelst(i,2)=cuelst(i,2)+1
IF i>cuez AND i<cuez+cuesl+1 THEN
@cuetext(i,i-cuez-1)
ENDIF
ENDIF
ENDIF
NEXT i
cuelst(cuep,1)=0
cuelst(cuep,2)=0
cuelst(cuep,3)=0
cuelst(cuep,5)=0
cuetxt$(cuep)=""
IF cuep>1 THEN
IF (cuelst(cuep-1,1) AND 3)=2 THEN
cuelst(cuep,4)=cuelst(cuep-1,4)
ELSE
IF (cuelst(cuep-1,1) AND 4)=4 THEN
s0=cuep-1
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
cuelst(cuep,4)=cuelst(cuep-1,4)+(cuelst(s0,3)-cuelst(s0,2))
ELSE
cuelst(cuep,4)=cuelst(cuep-1,4)+(cuelst(cuep-1,3)-cuelst(cuep-1,2))
ENDIF
ENDIF
ELSE
cuelst(cuep,4)=0
ENDIF
cueadder=1
@cueshow
ELSE
@alerts(28)
ENDIF
ELSE
@alerts(15)
ENDIF
@setbutton(cueins&,0)
ENDIF
IF obj=cuedel& THEN
IF cuelst(cuep,1)=0 THEN
IF cuep<cuemax THEN
FOR i=cuep TO cuemax-1
cuelst(i,1)=cuelst(i+1,1)
cuelst(i,2)=cuelst(i+1,2)
cuelst(i,3)=cuelst(i+1,3)
cuelst(i,4)=cuelst(i+1,4)
cuelst(i,5)=cuelst(i+1,5)
cuetxt$(i)=edmtxt$(i+1)
NEXT i
cuelst(cuemax,1)=0
cuelst(cuemax,2)=0
cuelst(cuemax,3)=0
cuelst(cuemax,5)=0
cuetxt$(cuemax)=""
cueadder=1
IF (cuelst(cuemax-1,1) AND 3)=2 THEN
cuelst(cuemax,4)=cuelst(cuemax-1,4)
ELSE
IF (cuelst(cuemax-1,1) AND 4)=4 THEN
s0=cuemax-1
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
div=cuelst(s0,3)-cuelst(s0,2)
ELSE
div=cuelst(cuemax-1,3)-cuelst(cuemax-1,2)
ENDIF
cuelst(cuemax,4)=cuelst(cuemax-1,4)+div
ENDIF
FOR i=1 TO cuemax
IF (cuelst(i,1) AND 4)=4 THEN
IF cuelst(i,2)>=cuep THEN
cuelst(i,2)=cuelst(i,2)-1
IF i>cuez AND i<cuez+cuesl+1 THEN
@cuetext(i,i-cuez-1)
ENDIF
ENDIF
ENDIF
NEXT i
ENDIF
@cueshow
ELSE
IF (cuelst(cuep,1) AND 3)=2 THEN
cuelst(cuep,1)=0
cuelst(cuep,2)=0
cuelst(cuep,3)=0
cuelst(cuep,5)=0
cuetxt$(cuep)=""
cueadder=1
ELSE
IF (cuelst(cuep,1) AND 4)=0 THEN
div=cuelst(cuep,3)-cuelst(cuep,2)
ELSE
s0=cuep
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
div=cuelst(s0,3)-cuelst(s0,2)
ENDIF
IF cuep=1 THEN
s1=cuelst(cuep,4)  ! calc Offset
ELSE
s0=cuep-1
IF (cuelst(s0,1) AND 4)=0 THEN
s1=cuelst(cuep,4)-(cuelst(s0,4)+(cuelst(s0,3)-cuelst(s0,2)))
ELSE
s2=s0
REPEAT
s2=cuelst(s2,2)
UNTIL (cuelst(s2,1) AND 4)=0
s1=cuelst(cuep,4)-(cuelst(s0,4)+(cuelst(s2,3)-cuelst(s2,2)))
ENDIF
ENDIF
cuelst(cuep,1)=0
cuelst(cuep,2)=0
cuelst(cuep,3)=0
cuelst(cuep,5)=0
cuetxt$(cuep)=""
cueadder=1
IF cuep=1 THEN
cuelst(cuep,4)=0
ELSE
cuelst(cuep,4)=cuelst(cuep,4)-s1
ENDIF
IF cuep<cuemax THEN
FOR i=cuep+1 TO cuemax
cuelst(i,4)=cuelst(i,4)-div-s1
NEXT i
ENDIF
FOR i=1 TO cuemax
IF (cuelst(i,1) AND 4)=4 THEN
IF cuelst(i,2)=cuep THEN
s0=i
IF s0=1 THEN
s1=cuelst(s0,4)  ! calc Offset
ELSE
s3=s0-1
IF (cuelst(s3,1) AND 4)=0 THEN
s1=cuelst(s0,4)-(cuelst(s3,4)+(cuelst(s3,3)-cuelst(s3,2)))
ELSE
s2=s3
REPEAT
s2=cuelst(s2,2)
UNTIL (cuelst(s2,1) AND 4)=0
s1=cuelst(s0,4)-(cuelst(s3,4)+(cuelst(s2,3)-cuelst(s2,2)))
ENDIF
ENDIF
cuelst(s0,1)=0
cuelst(s0,2)=0
cuelst(s0,3)=0
cuetxt$(s0)=""
IF s0=1 THEN
cuelst(s0,4)=0
ELSE
cuelst(s0,4)=cuelst(s0,4)-s1
ENDIF
IF s0<cuemax THEN
FOR j=s0+1 TO cuemax
cuelst(j,4)=cuelst(j,4)-div-s1
NEXT j
ENDIF
ENDIF
ENDIF
NEXT i
ENDIF
IF cuep<cuez+cuesl+1 THEN
cueadder=1
@cueshow
ENDIF
ENDIF
@setbutton(cuedel&,0)
ENDIF
IF obj=cuekill& THEN
@cuekiller
@setbutton(cuekill&,0)
ENDIF
IF obj=cueload& THEN
@cueload
cueadder=1
ENDIF
IF obj=cuesave& THEN
@cuesave
ENDIF
IF obj>=cuenr1& AND obj<=cuenr10& THEN
@cuenumber
ENDIF
IF obj>=cuex1& AND obj<=cuex10& THEN
a=cuez+(obj-cuex1&)
@cuedisable(a)
@setbutton(obj,0)
ENDIF
IF obj=cueadd& THEN
cueorig$=efil$
IF cuep<>0 THEN
IF cuelst(cuep,1)=0 THEN
@edmfind
IF edmfind=TRUE THEN
IF loops%(edsms,1)<>-1 AND loops%(edsms,2)<>-1 THEN
div=loops%(edsms,2)-loops%(edsms,1)
cuelst(cuep,1)=1   !active
cuelst(cuep,5)=0
IF cuep=1 THEN
cuelst(cuep,4)=0
ENDIF
cuetxt$(cuep)=edmtxt$(edsms)
cuelst(cuep,2)=loops%(edsms,1)
cuelst(cuep,3)=loops%(edsms,2)
IF cuep<cuemax THEN
FOR i=cuep+1 TO cuemax
cuelst(i,4)=cuelst(i,4)+div
NEXT i
ENDIF
cueadder=1
IF cuep<cuez+cuesl+1 THEN
@cueshow
ENDIF
ELSE
@alerts(13)
ENDIF
ENDIF
ELSE
@alerts(63)
ENDIF
ELSE
@alerts(15)
ENDIF
@setbutton(cueadd&,0)
ENDIF
IF obj=cueslup& THEN
@cue_up
@setbutton(cueslup&,0)
ENDIF
IF obj=cuesldwn& THEN
@cue_down
@setbutton(cuesldwn&,0)
ENDIF
IF obj=cueok& OR obj=9999 THEN
winh=BCLR(winh,cuelist&)
@setbutton(cueok&,0)
@restaura2b
obj=0
nr=smpedit&
@editselect
IF bigfoot=TRUE THEN
@setbutton(edcue&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE cuetimeset(a$,cuediv,oa)
@testcopyright
vobj=obj
IF cuep>0 THEN
ocuediv=cuediv
cuediv=INT(cuediv/mbit/hz*100)
vornr=nr
nr=record&
@textfeld2(record&,timemeld&,a$,1)
mmax=24*60*60*100
hsec=mmax
@htimeset
a$="MAX.TIME: "+a$
@textfeld2(nr,recfree&,a$,1)
m=tplaystart
@rsc_draw(nr,0)
timekey=4
@timekey
@markhlp
REPEAT
@timeinp(mmax,cuediv)
IF obj=rechelp& THEN
@helptxt("CUE-OFFSET")
ENDIF
UNTIL obj<>rechelp&
@restaura2
IF obj=recok& THEN
cuediv=INT(cuediv/100*hz*mbit)
IF ocuediv<>cuediv THEN
div=cuediv-ocuediv
IF (cuelst(cuez+oa+1,1) AND 3)=2 THEN
cuelst(cuez+oa+1,5)=cuelst(cuez+oa+1,5)+div
ELSE
cuelst(cuez+oa+1,4)=cuelst(cuez+oa+1,4)+div
IF cuez+oa+2<=cuemax THEN
FOR i=cuez+oa+2 TO cuemax
cuelst(i,4)=cuelst(i,4)+div
NEXT i
ENDIF
ENDIF
@cueshow
ENDIF
ENDIF
ENDIF
@setbutton(vobj,0)
obj=0
RETURN
'
> PROCEDURE cuekiller
FOR i=1 TO cuemax
cuelst(i,1)=0
cuelst(i,2)=0
cuelst(i,3)=0
cuelst(i,4)=0
cuelst(i,5)=0
cuetxt$(cuep)=""
NEXT i
cueadder=0
cuez=0
cuep=1
@cueslide
@cueshow
RETURN
'
> PROCEDURE cueload
LOCAL i,a$,g,s$
g=RINSTR(newcue2$,".")
a$=newcue2$
IF g>0 THEN
a$=LEFT$(newcue2$,g)+cueext$
ENDIF
g=RINSTR(newcue2$,"\")
IF g>0 THEN
a$=RIGHT$(a$,LEN(a$)-g)
ENDIF
'
s$=lfw$
IF RINSTR(newcue2$,"\")>0 THEN
s$=LEFT$(newcue2$,RINSTR(newcue2$,"\"))
ENDIF
@fileselect(s$+"*."+cueext$,a$,"CUELIST-LOAD:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
IF EXIST(fil$) THEN
@busy_mouse
OPEN "I",#5,fil$
@cueinfread
CLOSE #5
newcue2$=fil$
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
@cueslide
@setbutton(cueload&,0)
obj=0
@cueshow
RETURN
'
> PROCEDURE cueload_direct
LOCAL i,g
IF nr=cuelist& AND path$<>newcue$ AND cueadder=0 THEN
g=RINSTR(path$,".")
newcue$=path$
IF g>0 THEN
newcue2$=LEFT$(path$,g)+cueext$
ENDIF
IF newcue2$<>"" AND LEN(newcue2$)>3 AND newcue$<>vnewcue$ THEN
IF EXIST(newcue2$) THEN
@busy_mouse
OPEN "I",#5,newcue2$
@cueinfread
CLOSE #5
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@cueslide
@cueshow
ELSE
@cuekiller
ENDIF
ENDIF
vnewcue$=newcue$
ENDIF
RETURN
'
> PROCEDURE cueinfread
INPUT #5,cuev$              !  "STARTRACK-PLUGCONFIG V2.0"  Versionskontrolle
IF MID$(cuev$,LEN(cuev$)-3,1)="V" THEN
cuev=VAL(RIGHT$(cuev$,3))
ELSE
cuev=0
ENDIF
IF cuev>=2 THEN
FOR i=1 TO cuemax
cuelst(i,1)=0
cuelst(i,2)=0
cuelst(i,3)=0
cuelst(i,4)=0
cuelst(i,5)=0
cuetxt$(cuep)=""
NEXT i
REPEAT
EXIT IF EOF(#5)
INPUT #5,a$
@changelowkey2
IF INSTR(a$,"original")<>0 THEN
@delsourcekey
cueorig$=a$
ENDIF
IF INSTR(a$,"max_entrys")<>0 THEN
@delsourcekey
cuemax=VAL(a$)
ENDIF
IF INSTR(a$,"page")<>0 THEN
@delsourcekey
cuez=VAL(a$)
ENDIF
IF INSTR(a$,"pointer")<>0 THEN
@delsourcekey
cuep=VAL(a$)
ENDIF
IF INSTR(a$,"status")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-6)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF cuemax>=b THEN
a=INSTR(a$,"x")
IF a<>0 THEN
a$="&X"+RIGHT$(a$,LEN(a$)-a)
ENDIF
cuelst(b,1)=VAL(a$)
ENDIF
ENDIF
ENDIF
cuetxt$(cuep)=edmtxt$(edsms)
IF INSTR(a$,"name")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-4)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF cuemax>=b THEN
cuetxt$(b)=a$
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"smpte")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-5)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF cuemax>=b THEN
cuelst(b,4)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"start")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-5)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF cuemax>=b THEN
cuelst(b,2)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"end")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-3)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF cuemax>=b THEN
cuelst(b,3)=VAL(a$)
ENDIF
ENDIF
ENDIF
IF INSTR(a$,"offset")<>0 THEN
a$=RIGHT$(a$,LEN(a$)-6)
a=INSTR(a$,"=")
IF a<>0 THEN
b=VAL(LEFT$(a$,a-1))
@delsourcekey
IF cuemax>=b THEN
cuelst(b,5)=VAL(a$)
ENDIF
ENDIF
ENDIF
UNTIL EOF(#5)
cmax=cuemax
IF cuelst(cuemax,1)=0 THEN
FOR i=cuemax TO 1 STEP -1
EXIT IF cuelst(i,1)<>0
NEXT i
IF cuelst(i,1)<>0 AND i>0 THEN
cmax=i+1
IF cmax<cuemax THEN
FOR i=cmax+1 TO cuemax
cuelst(i,4)=cuelst(cmax,4)
NEXT i
ENDIF
ENDIF
ENDIF
IF cuev>=2.1 THEN
FOR i=1 TO cuemax
cuelst(i,4)=cuelst(i,4)*mbit
cuelst(i,5)=cuelst(i,5)*mbit
IF (cuelst(i,1) AND 4)=0 THEN
cuelst(i,2)=cuelst(i,2)*mbit
cuelst(i,3)=cuelst(i,3)*mbit
ENDIF
NEXT i
ENDIF
ENDIF
@cuememdis
RETURN
'
> PROCEDURE cuesave
LOCAL i,a$,g
@busy_mouse
~@xrsrc_gaddr(0,info&,dzu%)
nkind=(DPEEK(dzu%+24*inforeg1&))
IF nkind<>21 THEN
tstcpr=1
ENDIF
g=RINSTR(newcue2$,".")
a$=newcue2$
IF g>0 THEN
a$=LEFT$(newcue2$,g)+cueext$
ENDIF
g=RINSTR(newcue2$,"\")
IF g>0 THEN
a$=RIGHT$(a$,LEN(a$)-g)
ENDIF
s$=lfw$
IF RINSTR(newcue2$,"\")>0 THEN
s$=LEFT$(newcue2$,RINSTR(newcue2$,"\"))
ENDIF
@fileselect(s$+"*."+cueext$,a$,"CUELIST-SAVE:")
g2=RINSTR(fil$,".")
IF g2=0 THEN
fil$=fil$+"."+cueext$
ELSE
IF RIGHT$(fil$,3)<>cueext$ THEN
fil$=LEFT$(fil$,g2)+cueext$
ENDIF
ENDIF
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
a=ASC(LEFT$(fil$,1))-64
IF @dfree(a)>=sector THEN
cmax=cuemax
IF cuelst(cuemax,1)=0 THEN
FOR i=cuemax TO 1 STEP -1
EXIT IF cuelst(i,1)<>0
NEXT i
IF cuelst(i,1)<>0 AND i>0 THEN
cmax=i+1
ENDIF
ENDIF
OPEN "O",#5,fil$
PRINT #5,"STARTRACK-CUELIST V2.1"           ! Versionskontrolle
PRINT #5
PRINT #5,"original="+efil$
PRINT #5,"max_entrys="+STR$(cuemax)
PRINT #5,"page="+STR$(cuez)
PRINT #5,"pointer="+STR$(cuep)
FOR i=1 TO cmax
PRINT #5
IF cuetxt$(i)<>"" THEN
PRINT #5,"name"+STR$(i)+"="+cuetxt$(i)
ENDIF
PRINT #5,"status"+STR$(i)+"=x"+BIN$(cuelst(i,1))
PRINT #5,"smpte"+STR$(i)+"="+STR$(INT(cuelst(i,4)/mbit))
IF (cuelst(i,1) AND 4)=0 THEN
PRINT #5,"start"+STR$(i)+"="+STR$(INT(cuelst(i,2)/mbit))
PRINT #5,"end"+STR$(i)+"="+STR$(INT(cuelst(i,3)/mbit))
ELSE
PRINT #5,"start"+STR$(i)+"="+STR$(INT(cuelst(i,2)))
PRINT #5,"end"+STR$(i)+"="+STR$(INT(cuelst(i,3)))
ENDIF
PRINT #5,"offset"+STR$(i)+"="+STR$(INT(cuelst(i,5)/mbit))
NEXT i
CLOSE #5
cueorig$=efil$
newcue2$=fil$
ELSE
@nomem
ENDIF
ENDIF
@setbutton(cuesave&,0)
RETURN
'
> PROCEDURE cuemove
IF cuealone=FALSE THEN
cuez=cuemax/cuesmax*cuesz2
IF cuesz2>cuesmax-cuestep THEN
cuesz2=cuesmax-cuestep
@setslide2(cueslide&,cueslbut&,cuesmax,cuesz2,cuestep)
ENDIF
IF cuez>(cuemax-cuesl+1) THEN
cuez=cuemax-cuesl
ENDIF
IF cuez<0 THEN
cuez=0
ENDIF
cuez=ROUND(cuez)
@cueshow
ENDIF
RETURN
'
> PROCEDURE cueshow
cted=tedart
cuehz=hz
cdig24=dig24
IF cuealone=FALSE THEN
IF vcuebut<>-1 THEN
@setbutton(vcuebut,0)
ENDIF
FOR i=cuez+1 TO cuez+cuesl
@cuetext(i,i-cuez-1)
IF i=cuep THEN
cuebut=cuenr1&+i-cuez-1
vcuebut=cuebut
@setbutton(cuebut,1)
ENDIF
NEXT i
cuemaxlen=cuelst(cuemax,4)+(cuelst(cuemax,3)-cuelst(cuemax,2))
@edmftim(cuemaxlen)
@textfeld(cuesize&,a$,1)
ENDIF
RETURN
'
> PROCEDURE cuetext(i,j)
LOCAL sl0
IF cuealone=FALSE THEN
IF j>=0 AND j<cuesl THEN
IF cuelst(i,1)=0 THEN
@textfeld(cuex1&+j,CHR$(0),1)
@textfeld(cuenr1&+j,STR$(i)+CHR$(0),1)
@textfeld(cuet1&+j,CHR$(0),1)
@textfeld(cues1&+j,CHR$(0),1)
@textfeld(cuee1&+j,CHR$(0),1)
@textfeld(cuel1&+j,CHR$(0),1)
ELSE
IF (cuelst(i,1) AND 3)=1 THEN   ! Magic for active
a$=CHR$(0)
ENDIF
IF (cuelst(i,1) AND 3)=2 THEN   ! Magic for non-active
a$="X"+CHR$(0)
ENDIF
@textfeld(cuex1&+j,a$,1)
@textfeld(cuenr1&+j,STR$(i)+CHR$(0),1)
IF (cuelst(i,1) AND 4)=0 THEN
@edmftim(cuelst(i,4))
@textfeld(cuet1&+j,a$,1)
@edmftim(cuelst(i,2))
@textfeld(cues1&+j,a$,1)
@edmftim(cuelst(i,3))
@textfeld(cuee1&+j,a$,1)
@edmftim(cuelst(i,3)-cuelst(i,2))
@textfeld(cuel1&+j,a$,1)
ELSE
@edmftim(cuelst(i,4))
@textfeld(cuet1&+j,a$,1)
@textfeld(cues1&+j,"LINK TO "+STR$(cuelst(i,2))+CHR$(0),1)
@textfeld(cuee1&+j,CHR$(0),1)
@edmftim(cuelst(cuelst(i,2),3)-cuelst(cuelst(i,2),2))
@textfeld(cuel1&+j,a$,1)
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE cuenext ! (for memplay)
LOCAL s0,s1,s2,a,b
IF cuealone=FALSE THEN
REPEAT
IF cuelst(cuecount,1)<>0 AND cuecount<=cuemax THEN
INC cuecount
ENDIF
IF cuecount>cuemax AND cueplay=TRUE THEN
LPOKE cueflag,0
cuecount=cuemax
ELSE
IF cuelst(cuecount,1)=0 AND cueplay=TRUE THEN
LPOKE cueflag,0
ENDIF
IF cuelst(cuecount,1)<>0 AND (cuelst(cuecount,1) AND 3)<>2 THEN
LPOKE cueflag,1
IF (cuelst(cuecount,1) AND 4)=0 THEN
s1=cuelst(cuecount,2)
s2=cuelst(cuecount,3)
ELSE
s0=cuecount
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
s1=cuelst(s0,2)
s2=cuelst(s0,3)
ENDIF
a=meml+s1
b=meml+s2
a=INT(a/mbit)*mbit
b=INT(b/mbit)*mbit
LPOKE cuestrt,a
LPOKE cueend,b
ENDIF
ENDIF
UNTIL cuecount=maxplug OR (cuelst(cuecount,1) AND 3)<>2
ENDIF
RETURN
'
> PROCEDURE cuenext2  ! (for hardplay)
LOCAL s0,s1,s2
IF cuealone=FALSE THEN
REPEAT
IF cuecount<=cuemax AND cueplay=TRUE THEN
IF cuelst(cuecount,1)=0 AND cueplay=TRUE THEN
cueplay=FALSE
ENDIF
IF cuelst(cuecount,1)<>0 AND (cuelst(cuecount,1) AND 3)<>2 THEN
IF (cuelst(cuecount,1) AND 4)=0 THEN
s1=cuelst(cuecount,2)
s2=cuelst(cuecount,3)
ELSE
s0=cuecount
REPEAT
s0=cuelst(s0,2)
UNTIL (cuelst(s0,1) AND 4)=0
s1=cuelst(s0,2)
s2=cuelst(s0,3)
ENDIF
playpos=INT(s1/mbit)*mbit+head
sectors=INT((s2-s1)/mbit)*mbit
vv=GEMDOS(66,L:playpos,handle,0)
ENDIF
ENDIF
IF cuelst(cuecount,1)<>0 AND cuecount<=cuemax THEN
INC cuecount
ENDIF
UNTIL cuecount=maxplug OR (cuelst(cuecount,1) AND 3)<>2
ENDIF
RETURN
'
> PROCEDURE cuetimefind
IF cuelst(cuect,1)<>0 AND (cuelst(cuect,1) AND 3)<>2 THEN
ctime=cuelst(cuect,4)
ENDIF
RETURN
'
> PROCEDURE cuetime
IF nr=cuelist& AND cuealone=FALSE THEN
IF ctime2>=ctime THEN
IF cuect<=cuemax AND cueplay=TRUE THEN
IF cuelst(cuect,1)<>0 THEN
IF (cuect-1)/cuesl=INT((cuect-1)/cuesl) THEN
cuesc=TRUE
cuez=cuect-1
ENDIF
IF cuesc=TRUE AND (cuelst(cuect,1) AND 3)<>2 THEN
cuesc=FALSE
cuesz2=cuesmax/cuemax*cuez
@setslide2(cueslide&,cueslbut&,cuesmax,cuesz2,cuestep)
@cueshow
ENDIF
IF (cuelst(cuect,1) AND 3)<>2 THEN
IF vcuebut<>-1 THEN
@setbutton(vcuebut,0)
ENDIF
IF cuect>cuez AND cuect<cuez+cuesl+1 THEN
@setbutton(cuenr1&+cuect-cuez-1,1)
vcuebut=cuenr1&+cuect-cuez-1
ENDIF
ENDIF
ENDIF
ENDIF
IF cuelst(cuect,1)<>0 AND cuect<=cuemax THEN
INC cuect
ENDIF
@cuetimefind
ENDIF
ENDIF
RETURN
'
> PROCEDURE partfsel
LOCAL a,i
@testcopyright
IF bigfoot=TRUE THEN
IF nr=smpedit& THEN
@setbutton(edpart&,1)
ELSE
@setbutton3(edpart&,1,smpedit&)
ENDIF
ENDIF
vornr=nr
nr=partsel&
vshading=shading
shading=TRUE
dopix=TRUE
FOR i=2 TO 31
IF BTST(drvsact,i)=TRUE THEN
@setbutton3(partc&+i-2,1,nr)
ELSE
IF BTST(drvbits,i)=TRUE THEN
@setbutton3(partc&+i-2,0,nr)
ENDIF
ENDIF
NEXT i
FOR i=2 TO 31
IF BTST(drvbits,i)=TRUE THEN
a$=RIGHT$("       "+STR$(INT(@dfree(i+1)/&H100000*100)/100),7)
IF MID$(a$,LEN(a$)-1,1)="." THEN
a$=RIGHT$(a$+"0",7)
ENDIF
IF INSTR(a$,".")=0 THEN
a$=RIGHT$(a$+".00",7)
ENDIF
a$=a$+CHR$(0)
@rsc_state(nr,partc&+i-2,3,FALSE)
ELSE
a$="-"+CHR$(0)
@rsc_state(nr,partc&+i-2,3,TRUE)
ENDIF
@textfeld2(nr,partfsc&+i-2,a$,1)
@busy_mouse
NEXT i
IF partact=TRUE THEN
@setbutton3(partact&,1,nr)
ELSE
@setbutton3(partact&,0,nr)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
dopix=FALSE
shading=vshading
@rsc_draw(nr,0)
@markhlp
vpartact=partact
vdrvsact=drvsact
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(1,obj,zu%)
IF obj>=partc& AND obj<=part6& THEN
a=obj-partc&+2
IF BTST(drvsact,a)=TRUE THEN
drvsact=BCLR(drvsact,a)
ELSE
drvsact=BSET(drvsact,a)
ENDIF
ENDIF
IF obj=partact& THEN
IF partact=TRUE THEN
partact=FALSE
ELSE
partact=TRUE
ENDIF
ENDIF
IF obj=partld& THEN
@partload
ENDIF
IF obj=partsav& THEN
@partsave
ENDIF
IF obj=parthelp& THEN
@helptxt("PARTITION-PLAY")
ENDIF
UNTIL obj=partok& OR obj=partexit&
IF obj=partexit& THEN
partact=vpartact
drvsact=vdrvsact
ENDIF
@setbutton(obj,0)
@restaura2
obj=0
IF bigfoot=TRUE THEN
IF nr=smpedit& THEN
@setbutton(edpart&,0)
ELSE
@setbutton3(edpart&,0,smpedit&)
ENDIF
ENDIF
RETURN
'
> PROCEDURE partload
LOCAL g
g=RINSTR(part$,"\")
@fileselect(lfw$+"*."+RIGHT$(part$,3),RIGHT$(part$,LEN(part$)-g),"PARTITION-LOAD:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
@partload2(fil$)
FOR i=2 TO 31
IF BTST(drvsact,i)=TRUE THEN
@setbutton(partc&+i-2,1)
ELSE
IF BTST(drvbits,i)=TRUE THEN
@setbutton(partc&+i-2,0)
ENDIF
ENDIF
NEXT i
IF partact=TRUE THEN
@setbutton(partact&,1)
ELSE
@setbutton(partact&,0)
ENDIF
ENDIF
@setbutton(partld&,0)
RETURN
'
> PROCEDURE changelowkey    ! Zeichenkette in Kleinschrift wandeln
LOCAL i,a
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
IF a>=ASC("A") AND a<=ASC("Z") THEN
MID$(a$,i,1)=CHR$(a+32)
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE changelowkey2   ! Zeichenkette bis " " oder "=" in Kleinschrift wandeln
LOCAL i,a
IF LEN(a$)>0 THEN
FOR i=1 TO LEN(a$)
a=ASC(MID$(a$,i,1))
EXIT IF a=ASC(" ") OR a=ASC("=")
IF a>=ASC("A") AND a<=ASC("Z") THEN
MID$(a$,i,1)=CHR$(a+32)
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE delsourcekey    ! Wertzuweisung ermitteln
LOCAL a
a=INSTR(a$,"=")
IF a<>0 THEN
a$=RIGHT$(a$,LEN(a$)-a)
ENDIF
IF LEN(a$)>0 THEN
REPEAT
IF LEFT$(a$,1)=" " THEN
a$=RIGHT$(a$,LEN(a$)-1)
ENDIF
UNTIL LEFT$(a$,1)<>" " OR LEN(a$)=0
ENDIF
RETURN
'
> PROCEDURE partload2(fil$)
LOCAL i,a,b
IF EXIST(fil$) THEN
@busy_mouse
OPEN "I",#5,fil$
INPUT #5,partv$          ! Versionskontrolle
IF INSTR(partv$,"STARTRACK-LFWSEL V")<>0 THEN
REPEAT
EXIT IF EOF(#5)
INPUT #5,a$              ! PARTITIONS:C...Z,1..6
@changelowkey
IF INSTR(a$,"partitionmode")<>0 THEN
@delsourcekey
IF a$="true" THEN
partact=TRUE
ELSE
partact=FALSE
ENDIF
ENDIF
IF INSTR(a$,"partitions")<>0 THEN
@delsourcekey
drvbits=LPEEK(&H4C2)
drvsact=@getpart
ENDIF
UNTIL EOF(#5)
CLOSE #5
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
ENDIF
RETURN
'
> PROCEDURE putpart(a)
a$="partitions="
FOR i=2 TO 31
IF BTST(a,i)=TRUE THEN
IF i<26 THEN
a$=a$+CHR$(97+i)
ELSE
a$=a$+CHR$(ASC("1")+i-26)
ENDIF
ENDIF
NEXT i
b$="partitionmode="
IF partact=TRUE THEN
b$=b$+"true"
ELSE
b$=b$+"false"
ENDIF
RETURN
'
> FUNCTION getpart
LOCAL drvsa
drvsa=0
FOR i=1 TO LEN(a$)
b=ASC(MID$(a$,i,1))
IF b>=ASC("c") AND b<=ASC("z") THEN
b=b-ASC("c")+2
IF BTST(drvbits,b)=TRUE THEN
drvsa=BSET(drvsa,b)
ENDIF
ENDIF
IF b>=ASC("1") AND b<=ASC("6") THEN
b=b-ASC("1")+26
IF BTST(drvbits,b)=TRUE THEN
drvsa=BSET(drvsa,b)
ENDIF
ENDIF
NEXT i
RETURN drvsa
ENDFUNC
'
> PROCEDURE partsave
LOCAL i,a,b,g
g=RINSTR(part$,"\")
@fileselect(lfw$+"*."+RIGHT$(part$,3),RIGHT$(part$,LEN(part$)-g),"PARTITION-SAVE:")
IF fil$<>"" AND RIGHT$(fil$,1)<>"\" AND pret<>0 AND pbutt=1 AND LEN(fil$)>3 THEN
@busy_mouse
OPEN "O",#5,fil$
PRINT #5,"STARTRACK-LFWSEL V1.0"           ! Versionskontrolle
PRINT #5
@putpart(drvsact)
PRINT #5,a$              ! PARTITIONS=C...Z,1..6
PRINT #5,b$              ! PARTITIONMODE=TRUE,FALSE
CLOSE #5
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
ENDIF
@setbutton(partsav&,0)
RETURN
'
> PROCEDURE mixer
'  mixfade1&  ! USERDEF
'  mixvol1&   ! USERDEF
'  mixvolm1&  ! TEXT
'  mixvoll1&4 ! BOX
'  mixvolr1&  ! BOX
'  mixpkl1&   ! BOX
'  mixpkr1&   ! BOX
'  mixball1&  ! TEXT
'  mixbalr1&  ! TEXT
'  mixbalm1&  ! TEXT
'  mixbal1&   ! USERDEF
'  mixbalz1&  ! USERDEF
'  mixbalp1&  ! USERDEF
'  mixon1&    ! USERDEF
'  mixall1&   ! USERDEF
'  mixmute1&  ! USERDEF
'  mixvolz1&  ! USERDEF
'
@testcopyright
IF BTST(winh,mixer&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=mixer&
'
vshading=shading
shading=TRUE
dopix=TRUE
'
'
dopix=FALSE
shading=vshading
@rsc_draw(nr,7)
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
ELSE
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=mixer&
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_mixer
IF obj=mixhelp& THEN
@helptxt("mixer")
ENDIF
IF obj=mixload& THEN
ENDIF
IF obj=mixsave& THEN
ENDIF
IF obj=mixstop& THEN
ENDIF
IF obj=mixload& THEN
ENDIF
IF obj=mixload& THEN
ENDIF
IF obj=mixload& THEN
ENDIF
IF obj=mixload& THEN
ENDIF
IF obj=mixexit& OR obj=9999 THEN
winh=BCLR(winh,mixer&)
@setbutton(mixexit&,0)
@restaura2
obj=0
ENDIF
RETURN
'
> PROCEDURE xfade
@testcopyright
vornr=nr
nr=xfade&
'
vshading=shading
shading=TRUE
dopix=TRUE
'
'
dopix=FALSE
shading=vshading
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(1,obj,zu%)
IF obj=xfadeno& THEN
ENDIF
IF obj=xfadeup& THEN
ENDIF
IF obj=xfadedwn& THEN
ENDIF
IF obj=xfadcros& THEN
ENDIF
IF obj=xfadehlp& THEN
@helptxt("CROSSFADE")
ENDIF
UNTIL obj=xfadexit&
@setbutton(obj,0)
@restaura2
obj=0
RETURN
'
> PROCEDURE setsync
LOCAL b1$,b24,b3$,b4$
adat0$=" EXT     "
IF adat=TRUE THEN
masterclk=24576000
@adextl2
ELSE
masterclk=synchertz
ENDIF
b1$=STR$(INT(masterclk/76800)/10)
b2$=STR$(INT(masterclk/51200)/10)
b3$=STR$(INT(masterclk/38400)/10)
b4$=STR$(INT(masterclk/25600)/10)
IF INSTR(b1$,".")=0 THEN
b1$=b1$+".0"
ENDIF
IF INSTR(b2$,".")=0 THEN
b2$=b2$+".0"
ENDIF
IF INSTR(b3$,".")=0 THEN
b3$=b3$+".0"
ENDIF
IF INSTR(b4$,".")=0 THEN
b4$=b4$+".0"
ENDIF
IF LEN(b1$)<4 THEN
b1$=" "+b1$
ENDIF
IF LEN(b2$)<4 THEN
b2$=" "+b2$
ENDIF
IF LEN(b3$)<4 THEN
b3$=" "+b3$
ENDIF
IF LEN(b4$)<4 THEN
b4$=" "+b4$
ENDIF
adat1$=" ADAT  48 "
adat2$="   ADAT  48  "
IF adat=TRUE THEN
@stringfeld(popups&,adextl2&,adat1$+CHR$(0),1)
@stringfeld(popups&,ratextl2&,adat2$+CHR$(0),1)
ELSE
@stringfeld(popups&,adextl2&,adat0$+CHR$(0),1)
@stringfeld(popups&,ratextl2&,adat0$+" kHz"+CHR$(0),1)
@stringfeld(popups&,adextl2&,b2$+CHR$(0),6)
@stringfeld(popups&,ratextl2&,b2$+CHR$(0),6)
ENDIF
@stringfeld(popups&,adexth2&,b1$+CHR$(0),6)
@stringfeld(popups&,adexth1&,b3$+CHR$(0),6)
@stringfeld(popups&,adextl1&,b4$+CHR$(0),6)
@stringfeld(popups&,ratexth2&,b1$+CHR$(0),6)
@stringfeld(popups&,ratexth1&,b3$+CHR$(0),6)
@stringfeld(popups&,ratextl1&,b4$+CHR$(0),6)
RETURN
'
> PROCEDURE do_workmode
LOCAL fz,h,m,s,ms
~@xrsrc_gaddr(0,wmode&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
IF but=22 THEN
IF obj=frame& THEN
a$=@rsc_text$(popups&,framepop&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
framez=24
ENDIF
IF popup&=2 THEN
framez=25
ENDIF
IF popup&=3 THEN
framez=30
ENDIF
IF popup&=4 THEN
framez=75
ENDIF
IF popup&=5 THEN
framez=100
ENDIF
ENDIF
ENDIF
'
@editread(synchz&)
IF obj<>synchz& AND obj<>smpteset& AND obj<>syncsrte THEN
edit_obj&=0
ENDIF
IF synchertz<>VAL(a$) THEN
synchertz=VAL(a$)
@setsync
ENDIF
'
@editread(smpteset&)
IF LEN(a$)=8 THEN
fz=framez
h=VAL(LEFT$(a$,2))
m=VAL(MID$(a$,3,2))
s=VAL(MID$(a$,5,2))
ms=VAL(MID$(a$,7,2))
smptestrt=h*fz*60*60+m*fz*60+s*fz+ms
ENDIF
'
IF obj=midictrl& THEN
@midislider
ENDIF
IF obj=wmhelp& THEN
@helptxt("WORKMODE")
ENDIF
IF obj=syncalc& THEN
@editread(syncsrte&)
a=VAL(a$)
@setpcg(a)
synchertz=pcgfreq
a$=STR$(synchertz)+CHR$(0)
@editfeld(synchz&,a$)
a$=STR$(INT(pcgfreq/512))
IF LEN(a$)>5 THEN
a$=RIGHT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@editfeld(syncsrte&,a$)
@setsync
@setbutton(obj,0)
ENDIF
IF obj=syncadat& THEN
IF adat=TRUE THEN
adat=FALSE
@setsync
ELSE
adat=TRUE
@setsync
ENDIF
ENDIF
IF obj=syncpcg& THEN
IF pcg=FALSE THEN
pcg=TRUE
ELSE
pcg=FALSE
ENDIF
@pcgsetup
ENDIF
IF obj=syncmtc& THEN
IF mtc=FALSE THEN
mtc=TRUE
ELSE
mtc=FALSE
ENDIF
@mtcsetup
ENDIF
IF obj=syncxmit& THEN
IF sendsmpte=FALSE THEN
sendsmpte=TRUE
ELSE
sendsmpte=FALSE
ENDIF
ENDIF
IF obj=clkfalc& THEN
IF fmclk=FALSE THEN
fmclk=TRUE
clkmode=3
ELSE
fmclk=FALSE
clkmode=2
ENDIF
IF clkmode=1 THEN
cdivz=60
ENDIF
IF clkmode=2 THEN
cdivz=38
ENDIF
IF clkmode=3 THEN
cdivz=14
ENDIF
IF cdivz<cdivsms THEN
cdivsms=cdivz
ENDIF
ENDIF
IF obj=ramhi& THEN
bigram=TRUE
ENDIF
IF obj=ramlo& THEN
bigram=FALSE
ENDIF
IF obj=mast24& THEN
@setbitrate24
@setbutton(mast16&,0)
@setbutton(mast24&,1)
@hidetree(recm8&,TRUE,wmbox3&)
@hidetree2(mixdsp&,TRUE)
@hidetree(mixdma&,TRUE,wmbox2&)
@setbutton(mixdsp&,0)
@setbutton(mixdma&,0)
@setbutton(mixcpu&,1)
matrix=FALSE
IF rmo8=TRUE THEN
rmo8=FALSE
@setrecart
ENDIF
mixdsp=FALSE
ENDIF
IF obj=mast16& THEN
@setbitrate16
@setbutton(mast24&,0)
@setbutton(mast16&,1)
@hidetree(recm8&,FALSE,wmbox3&)
@hidetree(mixdsp&,FALSE,wmbox2&)
@hidetree(mixdma&,FALSE,wmbox2&)
ENDIF
IF obj=recm2& THEN
rch4=FALSE
rmo8=FALSE
ENDIF
IF obj=recm4& THEN
rch4=TRUE
rmo8=FALSE
ENDIF
IF obj=recm8& THEN
rch4=FALSE
rmo8=TRUE
ENDIF
IF obj=mixcpu& THEN
matrix=FALSE
mixdsp=FALSE
ENDIF
IF obj=mixdma& THEN
matrix=TRUE
mixdsp=FALSE
ENDIF
IF obj=mixdsp& THEN
matrix=TRUE
mixdsp=TRUE
ENDIF
IF obj=wmexit& OR obj=9999 THEN
winh=BCLR(winh,wmode&)
@setbutton(wmexit&,0)
@restaura2b
obj=0
@fliphz
IF ext>0 THEN
IF cdivsms=-1 THEN
cdivsms=1
ENDIF
@addiv3
@addiv2
@fliphz2
ENDIF
IF adat=TRUE THEN
@setsync
ENDIF
IF dig24<>olddig24 THEN
@switchbitres
ENDIF
IF nr=smpedit& THEN
@setbutton(wmodes&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE setrecart
IF rch4=FALSE AND rmo8=FALSE THEN
@setbutton(recm4&,0)
@setbutton(recm8&,0)
@setbutton(recm2&,1)
ENDIF
IF rch4=TRUE AND rmo8=FALSE THEN
@setbutton(recm2&,0)
@setbutton(recm8&,0)
@setbutton(recm4&,1)
ENDIF
IF rch4=FALSE AND rmo8=TRUE THEN
@setbutton(recm2&,0)
@setbutton(recm4&,0)
@setbutton(recm8&,1)
ENDIF
RETURN
'
> PROCEDURE setrecart2
IF rch4=FALSE AND rmo8=FALSE THEN
@setbutton3(recm4&,0,nr)
@setbutton3(recm8&,0,nr)
@setbutton3(recm2&,1,nr)
ENDIF
IF rch4=TRUE AND rmo8=FALSE THEN
@setbutton3(recm2&,0,nr)
@setbutton3(recm8&,0,nr)
@setbutton3(recm4&,1,nr)
ENDIF
IF rch4=FALSE AND rmo8=TRUE THEN
@setbutton3(recm2&,0,nr)
@setbutton3(recm4&,0,nr)
@setbutton3(recm8&,1,nr)
ENDIF
IF matrix=FALSE THEN
@setbutton3(mixdma&,0,nr)
@setbutton3(mixdsp&,0,nr)
@setbutton3(mixcpu&,1,nr)
ENDIF
IF matrix=TRUE AND mixdsp=FALSE THEN
@setbutton3(mixdsp&,0,nr)
@setbutton3(mixcpu&,0,nr)
@setbutton3(mixdma&,1,nr)
ENDIF
IF matrix=TRUE AND mixdsp=TRUE THEN
@setbutton3(mixcpu&,0,nr)
@setbutton3(mixdma&,0,nr)
@setbutton3(mixdsp&,1,nr)
ENDIF
RETURN
'
> PROCEDURE switchbitres
nr=smpedit&
@editselect
g=0
trashalert=TRUE
@trash
trashalert=FALSE
tdig24=dig24   ! fÅr Tracker
tmbit=mbit     ! fÅr Tracker
@fnamwrite
@hztext
@restaura3
cached=FALSE
credraw=TRUE
@curve(cs,ce)
@blkupdate
credraw=FALSE
@getcurve
RETURN
'
> PROCEDURE monitor
.| Glob. Var.: p#,mdat%,nr#,smpedit&,monitor&
.| Ruft auf  : digout,maschinit6,maschruf6,setbutton
.| Aufruf in : drop2-1,do_smpedit-1,do_peak-1,
'
IF demo=FALSE THEN
p=mdat%
POKE p,7
POKE p+1,4
~XBIOS(25,1,L:p)
@digout(TRUE)
@maschruf6
@digout(FALSE)
PAUSE 20
p=mdat%
POKE p,7
POKE p+1,0
~XBIOS(25,1,L:p)
IF nr=smpedit& THEN
'    @setbutton(monitor&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE mtcsetup
IF demo=FALSE THEN
IF mtc=TRUE THEN
~XBIOS(xbs,161)
~XBIOS(xbs,162,1)
ELSE
~XBIOS(xbs,162,0)
~XBIOS(xbs,161)
ENDIF
ENDIF
RETURN
'
> PROCEDURE workblock
LOCAL okay,a,vln,okay2
okay2=FALSE
IF virtual=FALSE THEN
@blocklook
IF sblock=0 OR (sblock=1 AND c2>c1 AND mce<>0 AND sms<>0 AND ce<>0 AND xm>0) THEN
SELECT blkobj
CASE mono&
IF sblock=0 THEN
@maschruf17(meml,memh)
ELSE
@maschruf17(mcs,mce)
ENDIF
CASE negate&
IF sblock=0 THEN
@maschruf34(meml,memh)
ELSE
@maschruf34(mcs,mce)
ENDIF
CASE lrchange&
IF sblock=0 THEN
@maschruf35(meml,memh)
ELSE
@maschruf35(mcs,mce)
ENDIF
CASE 990
IF sblock=0 THEN
@maschruf13(meml,memh,grenz,back%)
ELSE
@maschruf13(mcs,mce,grenz,back%)
makecurve=1
ENDIF
ENDSELECT
ELSE
@alerts(13)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
'    @restaura
okay2=TRUE
IF blkobj<990 THEN
@setbutton(blkobj,0)
ENDIF
obj=0
ELSE
bytes=INT(mlen/mbit)*mbit
okay=FALSE
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
IF virtwfile=FALSE THEN
OPEN "U",#1,virtpath$
okay=TRUE
ELSE
a=ASC(LEFT$(virtpath$,1))-64
IF @dfree(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
ENDIF
IF okay=TRUE THEN
IF sblock=1 THEN
@blocklook
c1=INT(c1/mbit)*mbit
c2=INT(c2/mbit)*mbit
seekz=0
vln=c1
IF virtwfile=FALSE THEN
SEEK #1,seekz
ELSE
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
vln=c2-c1
seekz=c1
ELSE
vln=virtln
seekz=0
ENDIF
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
SELECT blkobj
CASE mono&
@maschruf17(meml,meml+bytes)
CASE negate&
@maschruf34(meml,meml+bytes)
CASE lrchange&
@maschruf35(meml,meml+bytes)
CASE 990
@maschruf13(meml,meml+bytes,grenz,back%)
ENDSELECT
IF virtwfile=TRUE THEN
BPUT #2,meml,bytes
ELSE
SEEK #1,seekz
BPUT #1,meml,bytes
ENDIF
ENDIF
vln=vln-bytes
seekz=seekz+bytes
UNTIL vln<4
IF vln>0 AND virtwfile=TRUE THEN
BGET #1,meml,vln
BPUT #2,meml,vln
ENDIF
IF sblock=1 AND virtwfile=TRUE THEN
seekz=c2
vln=virtln-c2
IF virtwfile=FALSE THEN
SEEK #1,seekz
ENDIF
bytes=INT(mlen/mbit)*mbit
REPEAT
@busy_mouse
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
BPUT #2,meml,bytes
ENDIF
vln=vln-bytes
UNTIL vln<4
ENDIF
CLOSE #1
IF virtwfile=TRUE THEN
CLOSE #2
ELSE
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
@hardproof3
vmem=INT(virtln/mbit)*mbit
IF blkobj<990 THEN
nr=smpedit&
@editselect
ENDIF
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
IF blkobj>=990 THEN
makecurve=1
ENDIF
ENDIF
ELSE
@nomem
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF blkobj<990 THEN
@blkrestaura
@setbutton(blkobj,0)
obj=0
ENDIF
RETURN
'
> PROCEDURE harddisk
.| Glob. Var.: hrd#
.| Aufruf in : do_smpedit-1,
IF hrd=0 THEN
hrd=1
@setbutton(obj,1)
ELSE
hrd=0
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE midi
.| Glob. Var.: vornr#,nr#,midiedit&,db$,ch#,chtxt&,obj#,popup&,zu%,zuadr#,x#
.|     y#,v3#,but#,midicup&,midicdwn&,midinup&,midindwn&,midioup&,midiodwn&
.|     helpmidi&,midiok&,smpedit&,edmidi&
.| Ruft auf  : rsc_draw,markhlp,textfeld,makenote,rsc_do,xrsrc_gaddr,mouse
.|     channelup,channeldown,noteup,notedown,oktup,oktdown,helptxt,setbutton
.|     restaura2
.| Aufruf in : drop2-1,arrmidi-1,do_smpedit-1,
@testcopyright
vornr=nr
nr=midiedit&
'
vshading=shading
shading=TRUE
dopix=TRUE
db$=STR$(ch)+CHR$(0)
@textfeld2(nr,chtxt&,db$,1)
@makenote
dopix=FALSE
shading=vshading
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1
~@xrsrc_gaddr(1,obj,zu%)
IF obj=midicup& THEN
@channelup
ENDIF
IF obj=midicdwn& THEN
@channeldown
ENDIF
IF obj=midinup& THEN
@noteup
ENDIF
IF obj=midindwn& THEN
@notedown
ENDIF
IF obj=midioup& THEN
@oktup
ENDIF
IF obj=midiodwn& THEN
@oktdown
ENDIF
IF obj=helpmidi& THEN
@helptxt("MIDI")
ENDIF
IF obj<>0 AND obj<>helpmidi& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=midiok&
@setbutton(obj,0)
@restaura2
obj=0
IF nr=smpedit& THEN
@setbutton(edmidi&,0)
ENDIF
RETURN
'
> PROCEDURE makefade
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=8
RETURN
'
> PROCEDURE channelup
.| Glob. Var.: ch#,db$,chtxt&
.| Ruft auf  : textfeld,makenote
.| Aufruf in : midi-1,
IF ch<16 THEN
ch=ch+1
ENDIF
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
RETURN
'
> PROCEDURE channeldown
.| Glob. Var.: ch#,db$,chtxt&
.| Ruft auf  : textfeld,makenote
.| Aufruf in : midi-1,
IF ch>1 THEN
ch=ch-1
ENDIF
db$=STR$(ch)+CHR$(0)
@textfeld(chtxt&,db$,1)
@makenote
RETURN
'
> PROCEDURE makenote
.| Glob. Var.: notetxt&,db$,midiwort#,ch#,note#
.| Ruft auf  : midinote,textfeld
.| Aufruf in : midi-1,channelup-1,channeldown-1,notedown-1,noteup-1
.|     oktdown-1,oktup-1,
@midinote(note)
@textfeld(notetxt&,db$,1)
midiwort=(ch-1)*256+note
RETURN
'
> PROCEDURE midinote(mnote)
LOCAL n,o
o=INT(mnote/12)
n=mnote-o*12
IF n=0 THEN
IF o<3 THEN
db$="C "
ELSE
db$="c "
ENDIF
ENDIF
IF n=1 THEN
IF o<3 THEN
db$="C#"
ELSE
db$="c#"
ENDIF
ENDIF
IF n=2 THEN
IF o<3 THEN
db$="D "
ELSE
db$="d "
ENDIF
ENDIF
IF n=3 THEN
IF o<3 THEN
db$="D#"
ELSE
db$="d#"
ENDIF
ENDIF
IF n=4 THEN
IF o<3 THEN
db$="E "
ELSE
db$="e "
ENDIF
ENDIF
IF n=5 THEN
IF o<3 THEN
db$="F "
ELSE
db$="f "
ENDIF
ENDIF
IF n=6 THEN
IF o<3 THEN
db$="F#"
ELSE
db$="f#"
ENDIF
ENDIF
IF n=7 THEN
IF o<3 THEN
db$="G "
ELSE
db$="g "
ENDIF
ENDIF
IF n=8 THEN
IF o<3 THEN
db$="G#"
ELSE
db$="g#"
ENDIF
ENDIF
IF n=9 THEN
IF o<3 THEN
db$="A "
ELSE
db$="a "
ENDIF
ENDIF
IF n=10 THEN
IF o<3 THEN
db$="A#"
ELSE
db$="a#"
ENDIF
ENDIF
IF n=11 THEN
IF o<3 THEN
db$="B "
ELSE
db$="b "
ENDIF
ENDIF
IF o=0 THEN
db$=db$+"3"
ENDIF
IF o=1 THEN
db$=db$+"2"
ENDIF
IF o=2 THEN
db$=db$+"1"
ENDIF
IF o=3 THEN
db$=db$+"0"
ENDIF
IF o=4 THEN
db$=db$+"1"
ENDIF
IF o=5 THEN
db$=db$+"2"
ENDIF
IF o=6 THEN
db$=db$+"3"
ENDIF
IF o=7 THEN
db$=db$+"4"
ENDIF
IF o=8 THEN
db$=db$+"5"
ENDIF
IF o=9 THEN
db$=db$+"6"
ENDIF
IF o=10 THEN
db$=db$+"7"
ENDIF
db$=db$+CHR$(0)
RETURN
'
> FUNCTION midivalue(a$)
LOCAL o,n,n$
n$=LEFT$(a$,2)
o=ASC(RIGHT$(a$,1))-48
IF ASC(LEFT$(a$,1))<97 THEN
o=3-o
MID$(n$,1)=CHR$(ASC(LEFT$(n$,1))+32)
ELSE
o=o+3
ENDIF
SELECT n$
CASE "c "
n=0
CASE "c#"
n=1
CASE "d "
n=2
CASE "d#"
n=3
CASE "e "
n=4
CASE "f "
n=5
CASE "f#"
n=6
CASE "g "
n=7
CASE "g#"
n=8
CASE "a "
n=9
CASE "a#"
n=10
CASE "b "
n=11
ENDSELECT
n=o*12+n
RETURN n
ENDFUNC
'
> PROCEDURE notedown
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf hn : midi-1,
IF note>0 THEN
note=note-1
ENDIF
@makenote
RETURN
'
> PROCEDURE noteup
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf in : midi-1,
IF note<127 THEN
note=note+1
ENDIF
@makenote
RETURN
'
> PROCEDURE oktdown
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf in : midi-1,
IF (note-12)>=0 THEN
note=note-12
ENDIF
@makenote
RETURN
'
> PROCEDURE oktup
.| Glob. Var.: note#
.| Ruft auf  : makenote
.| Aufruf in : midi-1,
IF (note+12)<=127 THEN
note=note+12
ENDIF
@makenote
RETURN
'
> PROCEDURE machmidi
.| Glob. Var.: mamidi#
.| Aufruf in : do_smpedit-1,
IF mamidi=0 THEN
mamidi=1
ELSE
mamidi=0
ENDIF
RETURN
'
> PROCEDURE loopbut(i,j)
IF i=0 THEN
@setbutton(forw&,j)
ENDIF
IF i=1 THEN
@setbutton(backw&,j)
ENDIF
IF i=2 THEN
@setbutton(cross&,j)
ENDIF
RETURN
'
> PROCEDURE loopwahl
.| Glob. Var.: winh#,loop&,rsc_window&,vornr#,nr#,menuda#,sret#,forw&,backw&
.|     cross&,loopart&,g#,smpedit&,edit_obj&,idx&
.| Ruft auf  : rsc_draw,rsc_menu_ienable,markhlp,setbutton,setbutton2
.|     rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
@testcopyright
IF BTST(winh,loop&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=loop&
vshading=shading
shading=TRUE
dopix=TRUE
@loopbut(0,0)
@loopbut(1,0)
@loopbut(2,0)
@loopbut(sret,1)
dopix=FALSE
shading=vshading
@rsc_draw(nr,7)
winh=BSET(winh,nr)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@markhlp
ELSE
@setbutton(loopart&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=loop&
IF vornr=smpedit& THEN
@setbutton2(loopart&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE do_loop
.| Glob. Var.: obj#,helploop&,forw&,backw&,cross&,loopexit&,winh#,loop&,nr#
.|     smpedit&,loopart&
.| Ruft auf  : helptxt,loopfor,loopret,loopcross,setbutton,restaura2b
.| Aufruf in : windows-1,
IF obj=helploop& THEN
@helptxt("LOOPS")
ENDIF
IF obj=forw& THEN
@loopfor
ENDIF
IF obj=backw& THEN
@loopret
ENDIF
IF obj=cross& THEN
@loopcross
ENDIF
IF obj=loopexit& OR obj=9999 THEN
winh=BCLR(winh,loop&)
@setbutton(loopexit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(loopart&,0)
ENDIF
ENDIF
RETURN
'
> FUNCTION marknrinp(value)
LOCAL mn$,a,vsmsok
@testcopyright
vsmsok=FALSE
vornr=nr
nr=marknumb&
mn$=STR$(value)+CHR$(0)
@textfeld2(nr,mnumtxt&,mn$,1)
@rsc_draw(nr,0)
@markhlp
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
@mouse(x,y,v3)
UNTIL obj<>0 AND obj<>-1 AND obj<>mnumtxt&
edit_obj&=0
~@xrsrc_gaddr(1,obj,zu%)
IF obj=mnumhelp& THEN
@helptxt("SET MARKER")
ENDIF
IF obj<>0 AND obj<>mnumhelp& THEN
@setbutton(obj,0)
ENDIF
UNTIL obj=mnumok& OR obj=mnumexit&
@setbutton(obj,0)
IF obj=mnumok& THEN
@editread(mnumtxt&)
a=VAL(a$)
IF a>0 AND a<=loopz THEN
bvalue=a
vsmsok=TRUE
ENDIF
ENDIF
@restaura2
IF vsmsok=TRUE AND nr=smpedit& THEN
@edslidemove(bvalue)
ENDIF
obj=0
IF nr=smpedit& THEN
@setbutton(edmnr&,0)
ENDIF
RETURN bvalue
ENDFUNC
'
> FUNCTION dsptex(i)
SELECT i
CASE 1
txf=dspslot0&
CASE 2
txf=dspslot1&
CASE 3
txf=dspslot2&
CASE 4
txf=dspslot3&
CASE 5
txf=dspslot4&
CASE 6
txf=dspslot5&
CASE 7
txf=dspslot6&
CASE 8
txf=dspslot7&
CASE 9
txf=dspslot8&
CASE 10
txf=dspslot9&
ENDSELECT
RETURN txf
ENDFUNC
'
> PROCEDURE dsp_butset
LOCAL dspa
dspsz=dsplist/dspsmax*dspsz2
IF dspsz2>dspsmax-dspstep THEN
dspsz2=dspsmax-dspstep
ENDIF
@setslide2(dspslide&,dspslbut&,dspsmax,dspsz2,dspstep)
IF dspsz>(dsplist-dspsl+1) THEN
dspsz=dsplist-dspsl
ENDIF
IF dspsz<0 THEN
dspsz=0
ENDIF
dspsz=ROUND(dspsz)
IF dsplugz>0 THEN
z=dsplugz
IF z>dspsz+10 THEN
z=dspsz+10
ENDIF
IF dspbobj<>-1 THEN
@setbutton(dspbobj,0)
ENDIF
FOR i=dspsz+1 TO z
dspa=@dsptex(i-dspsz)
@textfeld(dspa,dplugnam$(i)+CHR$(0),1)
IF i=dplugwind THEN
dspbobj=dspa
@setbutton(dspa,1)
ENDIF
NEXT i
IF z<dspsz+10 THEN
FOR i=z+1 TO dspsz+10
a=@dsptex(i-dspsz)
@textfeld(a,CHR$(0),1)
NEXT i
ENDIF
ENDIF
RETURN
'
> PROCEDURE dspwahl
.| Glob. Var.: winh#,dspedit&,rsc_window&,vorvornr#,vornr#,nr#,menuda#
.|     swdsp&,g#
.| Ruft auf  : rsc_draw,markhlp,rsc_menu_ienable,setbutton
.| Aufruf in : drop2-1,do_main-1,do_smpedit-1,
LOCAL txf,i,z,a
@testcopyright
IF BTST(winh,dspedit&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=dspedit&
vshading=shading
shading=TRUE
dopix=TRUE
IF dspw=0 THEN
@dspoff
ENDIF
IF dspw=1 THEN
@dspin
ENDIF
IF dspw=2 THEN
@dspout
ENDIF
dspbobj=-1
dsplist=dsplugz
@slidelen(dspslide&,dspslbut&,v,dspsbr)
dspsl=10                        ! Anzahl der lines
dsplist2=dsplist
IF dsplist2<dspsl THEN
dsplist2=dspsl
ENDIF
dspbbut=INT(dspsbr/dsplist2*dspsl)   ! Buttonbreite
dspsmax=dspsbr                     ! Breite des Sliders
dspstep=dspsmax/dsplist2*dspsl       ! Schrittweite des Sliders
dspsplus=dspsmax/dsplist2           ! Einzelschritt
@slideinit(dspslide&,dspslbut&,dspsmax,dspbbut,tfsz)
@setslide(dspslide&,dspslbut&,dspsmax,dspbbut,tfsz)
@dsp_butset
dopix=FALSE
shading=vshading
@markhlp
'
IF dsplugz>0 THEN
z=dsplugz
IF z>dspsz+10 THEN
z=dspsz+10
ENDIF
FOR i=dspsz+1 TO z
a=@dsptex(i-dspsz)
@textfeld2(nr,a,dplugnam$(i)+CHR$(0),1)
NEXT i
IF z<dspsz+10 THEN
FOR i=z+1 TO dspsz+10
a=@dsptex(i-dspsz)
@textfeld2(nr,a,CHR$(0),1)
NEXT i
ENDIF
ENDIF
'
@rsc_draw(nr,7)
@markhlp
winh=BSET(winh,nr)
ELSE
@setbutton(swdsp&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=dspedit&
IF vornr=smpedit& THEN
@setbutton2(swdsp&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
RETURN
'
> PROCEDURE dspup
IF dspsz2>0 THEN
@slideup2(dspslide&,dspslbut&,dspsmax,dspsplus,dspsz2,slflg)
IF slflg=TRUE THEN
@dsp_butset
ENDIF
ENDIF
RETURN
'
> PROCEDURE dspdown
IF dspsz2+0.00001<(dspsmax-dspstep) THEN
@slidedwn2(dspslide&,dspslbut&,dspsmax,dspstep,dspsplus,dspsz2,slflg)
IF slflg=TRUE THEN
@dsp_butset
ENDIF
ENDIF
RETURN
'
> PROCEDURE do_dsp
.| Glob. Var.: obj#,dspload&,dspsave&,dsphall&,dspecho&,dspret&,dspeq&
.|     helpdsp&,dspexit&,winh#,dspedit&,vornr#,vorvornr#,nr#,smpedit&,swdsp&
.| Ruft auf  : setbutton,helptxt,restaura2
.| Aufruf in : windows-1,
~@xrsrc_gaddr(0,dspedit&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
IF but=22 THEN
IF obj=dspflip& THEN
a$=@rsc_text$(popups&,dsppopup&+popup&)
@textfeld(obj,a$,1)
IF popup&=1 THEN
@dspoff
ENDIF
IF popup&=2 THEN
@dspin
ENDIF
IF popup&=3 THEN
@dspout
ENDIF
ENDIF
ENDIF
IF obj=dspload& THEN
@dsp_lodload
@setbutton(dspload&,0)
ENDIF
IF obj=dspslup& THEN
@dspup
@setbutton(dspslup&,0)
ENDIF
IF obj=dspsldwn& THEN
@dspdown
@setbutton(dspsldwn&,0)
ENDIF
IF obj=dspsave& THEN
PAUSE 2
@setbutton(dspsave&,0)
ENDIF
IF obj>=dspslot0& AND obj<=dspslot9& THEN
IF dspw=0 THEN
@dspout
ENDIF
@dspslots
ENDIF
IF obj=helpdsp& THEN
@helptxt("DSP")
ENDIF
IF obj=dspexit& OR obj=9999 THEN
winh=BCLR(winh,dspedit&)
@setbutton(dspexit&,0)
@restaura2b
obj=0
IF nr=smpedit& THEN
@setbutton(swdsp&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE dspslots
LOCAL v
v=obj-dspslot0&
IF dsplugz>dspsz+v THEN
dspbobj=obj
dplugwind=dspsz+v+1                   ! aktives DSP-Plugin
@dsp_plugwind(dplugwind)
ENDIF
RETURN
'
> PROCEDURE dspbypass
@dsp_boot
IF demo=FALSE THEN
~XBIOS(xbs,500)
ENDIF
RETURN
'
> PROCEDURE dsprec2     ! stereo-hosttransfer mit 8K-Buffer (fÅr dspuse)
@dsp_boot
IF demo=FALSE THEN
~XBIOS(xbs,501)
ENDIF
RETURN
'
> PROCEDURE dsprec4     ! stereo-hosttransfer mit 1K-Buffer (fÅr 4channel record)
@dsp_boot
IF demo=FALSE THEN
~XBIOS(xbs,502)
ENDIF
RETURN
'
> PROCEDURE dspplay2    ! stereo-hosttransfer (fÅr 4channel play und dspuse)
@dsp_boot
IF demo=FALSE THEN
~XBIOS(xbs,503)
ENDIF
RETURN
'
> PROCEDURE dspplay4    ! hosttransfer 4 channels and mix to stereo
@dsp_boot
IF demo=FALSE THEN
~XBIOS(xbs,504)
ENDIF
RETURN
'
> PROCEDURE dspplay8    ! hosttransfer 8 channels and mix to stereo
@dsp_boot
IF demo=FALSE THEN
~XBIOS(xbs,505)
ENDIF
RETURN
'
> PROCEDURE dspmix8     ! ssi-transfer and mix all 8 channels to 7/8
@dsp_boot
IF demo=FALSE THEN
~XBIOS(xbs,506)
ENDIF
RETURN
'
> PROCEDURE dspeffmix8  ! ssi-transfer,hall on 1/2 and mix all 8 channels to 7/8
@dsp_boot
IF demo=FALSE THEN
~XBIOS(xbs,507)
ENDIF
RETURN
'
> PROCEDURE dsp_boot               ! fuer DSP56001 und DSP56002 ohne PLL (40Mhz)
LOCAL a,xx,i
'
' Bootstrap-Programm
' this is the patched SLOADER  named "SLOADER3.ASM"
'
IF demo=FALSE THEN
IF bigram=FALSE THEN
~XBIOS(xbs,70,0)
ELSE
~XBIOS(xbs,70,1)
ENDIF
~XBIOS(xbs,72,15)
ENDIF
'
timeout=FALSE
break=FALSE
'
'  @fifodel
@dspreset
IF demo=FALSE THEN
~XBIOS(xbs,74)            ! DSP-Clear
ENDIF
RETURN
'
> PROCEDURE dsp_lodput(a$)
LOCAL ability,f,buffer,z
IF demo=FALSE OR (falcon=TRUE AND magicmac=0) THEN
@dsp_boot
~XBIOS(105)  ! unlock
~XBIOS(104)  ! lock
'
' Transfer LOD-File to HI-Interface
'
ability=XBIOS(113)  ! ability
f=VARPTR(a$)
IF dspbuf=0 THEN
dspbuf=@malloc(65535,1)
ENDIF
dspbinsize=XBIOS(111,L:f,L:dspbuf)  ! dsp_lodtobin
IF dspbinsize>3 THEN
FOR z=dspbuf TO dspbuf+dspbinsize-3
z1=PEEK(z)
z2=PEEK(z+1)
z3=PEEK(z+2)
IF z1=&H8 AND z2=&HF4 AND z3=&HAC THEN
z4=PEEK(z+3)
z5=PEEK(z+4)
IF z4=0 AND z5=&H40 THEN
z5=PEEK(z+5)
IF dig24=TRUE THEN
POKE z+5,&H36
ELSE
POKE z+5,&H34
ENDIF
ENDIF
ENDIF
NEXT z
ENDIF
~XBIOS(109,L:dspbuf,L:dspbinsize,ability)  ! dsp_execprog
ENDIF
RETURN
'
> PROCEDURE dsp_lodload
'
' Host-LOD-File-Loader to Host by Bootstrap-Loading from DSP56001
' Load a LOD-File in the DSP and Start it at P:0
'
'
@fileselect("D:\SAMPLER\SAMPLE.16\DSP\*.LOD","","LOAD LOD-FILE to DSP:")
IF fil$<>"" THEN
IF EXIST(fil$)=TRUE THEN
@dsp_lodput(fil$)
ENDIF
ENDIF
RETURN
'
> PROCEDURE loopauto
.| Aufruf in : do_smpedit-1,
'  @setbutton(loopauto&,0)
RETURN
'
> PROCEDURE loopfor
.| Glob. Var.: sret#
.| Aufruf in : do_loop-1,
sret=0
RETURN
'
> PROCEDURE loopret
.| Glob. Var.: sret#
.| Aufruf in : do_loop-1,
sret=1
RETURN
'
> PROCEDURE loopcross
.| Glob. Var.: sret#
.| Aufruf in : do_loop-1,
sret=2
RETURN
'
> PROCEDURE normadj
.| Glob. Var.: grenz#,db#,aufloes#
.| Ruft auf  : makenorm
.| Aufruf in : normalize-1,
grenz=(db+aufloes)/20
grenz=10^grenz
grenz=grenz/2
IF dig24=FALSE THEN
IF grenz>&H7FFF THEN
grenz=&H7FFF
ENDIF
ELSE
IF grenz>&H7FFFFF THEN
grenz=&H7FFFFF
ENDIF
ENDIF
grenz=INT(grenz)
blkobj=990   ! cookie fÅr normalize
@workblock
RETURN
'
> PROCEDURE normauto
.| Glob. Var.: db#,grenz#
.| Ruft auf  : makenorm
.| Aufruf in : normalize-1,
db=0
IF dig24=FALSE THEN
grenz=&H7FFF
ELSE
grenz=&H7FFFFF
ENDIF
blkobj=990   ! cookie fÅr normalize
@workblock
RETURN
'
> PROCEDURE normtest
.| Glob. Var.: virtual#,sblock#,meml#,memh#,mcs#,mce#,back%,db#,aufloes#
.|     vln#,virtln#,bhold#,bytes#,virtpath$,mlen#,db$,normdb&
.| Ruft auf  : maschinit12,maschruf12,blocklook,textfeld
.| Aufruf in : normalize-1,
IF virtual=FALSE THEN
IF sblock=0 THEN
@maschruf12(meml,memh)
ELSE
@blocklook
@maschruf12(mcs,mce)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF back%>0 THEN
mdb=2*back%
mdb=20*LOG10(mdb)
mdb=mdb-aufloes
mdb=INT(mdb*100)/100
ELSE
back%=0
mdb=-aufloes
ENDIF
ELSE
vln=virtln
bhold=0
bytes=0
OPEN "I",#1,virtpath$
REPEAT
IF vln>=bytes THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
@maschruf12(meml,meml+bytes)
ENDIF
vln=vln-bytes
IF back%>bhold THEN
bhold=back%
ENDIF
UNTIL vln<4
CLOSE #1
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF bhold>0 THEN
mdb=2*bhold
mdb=20*LOG10(mdb)
mdb=mdb-aufloes
mdb=INT(mdb*100)/100
ELSE
bhold=0
mdb=-aufloes
ENDIF
back%=bhold
ENDIF
db$=STR$(mdb)+CHR$(0)
@textfeld(maxdb&,db$,1)
RETURN
'
> PROCEDURE norml
.| Glob. Var.: norma#,auflh#,aufloes#,dbx#,db#,obj#,norml1&,nz#,norml2&
.|     norml3&,db$,normdb&
.| Ruft auf  : textfeld
.| Aufruf in : normalize-1,
IF norma=0 THEN
auflh=INT(0-(aufloes*100))
dbx=INT(db*100)
IF obj=norml1& THEN
nz=2
ENDIF
IF obj=norml2& THEN
nz=20
ENDIF
IF obj=norml3& THEN
nz=400
ENDIF
dbx=dbx-nz
IF dbx>=auflh THEN
db=INT(dbx)/100
ENDIF
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
ENDIF
RETURN
'
> PROCEDURE normr
.| Glob. Var.: norma#,dbx#,db#,obj#,normr1&,nz#,normr2&,normr3&,t#,db$
.|     normdb&
.| Ruft auf  : textfeld
.| Aufruf in : normalize-1,
IF norma=0 THEN
dbx=INT(db*100)
IF obj=normr1& THEN
nz=2
ENDIF
IF obj=normr2& THEN
nz=20
ENDIF
IF obj=normr3& THEN
nz=400
ENDIF
t=1
dbx=dbx+nz
IF t>dbx THEN
db=INT(dbx)/100
ENDIF
db$=STR$(db)+CHR$(0)
@textfeld(normdb&,db$,1)
ENDIF
RETURN
'
> PROCEDURE resl
.| Glob. Var.: obj#,resl1&,nz#,resl2&,resl3&,t#,resoth#,db$,resother&
.| Ruft auf  : textfeld
.| Aufruf in : resample-1,arrsmpr-1,
IF obj=resl1& THEN
nz=0.1
ENDIF
IF obj=resl2& THEN
nz=1
ENDIF
IF obj=resl3& THEN
nz=5
ENDIF
t=5
IF (resoth-nz)>=t THEN
resoth=resoth-nz
ENDIF
db$=RIGHT$("000"+STR$(resoth*10),3)+CHR$(0)
@editfeld(resother&,db$)
RETURN
'
> PROCEDURE resr
.| Glob. Var.: obj#,resr1&,nz#,resr2&,resr3&,t#,resoth#,db$,resother&
.| Ruft auf  : textfeld
.| Aufruf in : resample-1,arrsmpr-1,
IF obj=resr1& THEN
nz=0.1
ENDIF
IF obj=resr2& THEN
nz=1
ENDIF
IF obj=resr3& THEN
nz=5
ENDIF
t=96
IF (resoth+nz)<=t THEN
resoth=resoth+nz
ENDIF
db$=RIGHT$("000"+STR$(resoth*10),3)+CHR$(0)
@editfeld(resother&,db$)
RETURN
'
> PROCEDURE resmptovirt(va,vb)
bedarfw=(vb-va)*bedarf
bedarfw=(INT(bedarfw/mbit)*mbit)+mbit+head
IF @dfree(a)>=bedarfw THEN
a=RINSTR(path$,"\")
IF a>0 THEN
workf$=LEFT$(path$,a)+workfile$
ELSE
workf$=lfw$+workfile$
ENDIF
@busy_mouse
@headart2(workf$)
danf=mdat%
fileart=sfileart
@headmake
vln=vb-va
@headmake2
OPEN "O",#1,workf$
BPUT #1,danf,head
BPUT #1,va,vb-va
CLOSE #1
virtual=TRUE
path$=workf$
smpnam$=workfile$
'    mbs=0
IF nr=smpedit& THEN
@setbutton(hard&,1)
ENDIF
makevirt=TRUE
virtln=vb-va
virtpath$=workf$
efil$=workf$
enam$=smpnam$
ELSE
@nomem
ENDIF
RETURN
'
> PROCEDURE makeresmp
.| Glob. Var.: e#,resorig#,f#,resoth#,bedarf#,virtual#,sblock#,a#,meml#,b#
.|     memh#,c#,d#,back%,adjresmp#,hz#,hzm#,retime#,makecurve#,drittel#
.|     ldlen#,mcs#,mce#,virtln#,bytes#,mlen#,virtpath$,virtp$,virtfile$
.|     seekz#,seekz2#,virtwfile#,path$,smpnam$,vmem#
.| Ruft auf  : maschinit16,maschruf16,maschinit9,maschruf9,maschinit10
.|     maschruf10,blocklook,hardproof3,memtovirt2,nomem
.| Aufruf in : resample-1,
LOCAL okay,vln
e=INT(resorig*10)
f=INT(resoth*10)
bedarf=f/e
IF virtual=FALSE THEN
IF sblock=0 THEN
IF bedarf<=1 THEN
a=meml
b=memh
c=meml
d=memh
@maschruf16(a,b,c,d,e,f)
FOR i=1 TO loopz
FOR j=1 TO 4
IF loops%(i,j)<>-1 THEN
loops%(i,j)=INT(loops%(i,j)*bedarf/mbit)*mbit
ENDIF
NEXT j
NEXT i
IF back%<memh AND back%>meml THEN
@maschruf9(back%,memh-mbit)
ENDIF
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
ELSE
'        go to virtual
'
@resmptovirt(meml,memh)
'
ENDIF
ELSE
@blocklook
a=mcs
b=mce
drittel=(memh-meml)/(mce-mcs)
'
'     IF loops%(sms,2)<>-1 THEN
'      le=(c2-c1)*bedarf+c1
'      le=INT(le/mbit)*mbit
'      loops%(sms,2)=le
'     ENDIF
'
IF bedarf<=1 THEN
c=mcs
d=mce
@maschruf16(a,b,c,d,e,f)
IF sms<>0 THEN
IF loops%(sms,2)<>-1 THEN
loops%(sms,2)=INT((loops%(sms,1)+((loops%(sms,2)-loops%(sms,1))*bedarf))/mbit)*mbit
ENDIF
ENDIF
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
IF back%<mce AND back%>mcs THEN
@maschruf9(back%,mce)
ENDIF
ELSE
IF mce+mbit<memh AND drittel>=bedarf THEN
c=mce
d=memh-mbit
@maschruf16(a,b,c,d,e,f)
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
@maschruf10(c,d,mcs,memh-mbit)
b=INT((d-c)/mbit)*mbit
@maschruf9(mcs+b,d)
IF sms<>0 THEN
IF loops%(sms,2)<>-1 THEN
loops%(sms,2)=INT((loops%(sms,1)+((loops%(sms,2)-loops%(sms,1))*bedarf))/mbit)*mbit
ENDIF
ENDIF
ELSE
'
@resmptovirt(mcs,mce)
'
'          @alerts(46)
ENDIF
ENDIF
ENDIF
ENDIF
IF virtual=TRUE THEN
vln=virtln
bytes=INT(mlen/mbit)*mbit
okay=FALSE
drittel=(memh-meml)/(e+f)*e
drittel=INT(drittel/mbit)*mbit
IF drittel>=mbit*4 THEN
drittel=drittel-mbit*2
ENDIF
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
infname$=LEFT$(virtpath$,a)+inf$
dcach$=LEFT$(virtpath$,a)+peak$
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
a=ASC(LEFT$(virtpath$,1))-64
IF @dfree(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
IF okay=TRUE THEN
seekz=0
seekz2=0
IF head>0 THEN
BGET #1,meml,head
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
@headmake3
ENDIF
BPUT #2,meml,head
vln=vln-head
ENDIF
REPEAT
IF vln+head>=bytes THEN
IF bedarf<=1 THEN
bytes=INT(mlen/mbit)*mbit
ELSE
bytes=drittel
ENDIF
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
a=meml
b=meml+bytes
IF bedarf<=1 THEN
c=meml
ELSE
c=meml+bytes
ENDIF
d=memh
@maschruf16(a,b,c,d,e,f)
back%=INT(back%/mbit)*mbit
BPUT #2,c,back%-c
ENDIF
vln=vln-bytes
seekz=seekz+bytes
seekz2=seekz2+(back%-c)
UNTIL vln<4
CLOSE #1
CLOSE #2
FOR i=1 TO loopz
FOR j=1 TO 4
IF loops%(i,j)<>-1 THEN
loops%(i,j)=INT(loops%(i,j)*bedarf/mbit)*mbit
ENDIF
NEXT j
NEXT i
IF virtwfile=FALSE THEN
IF adjresmp=TRUE THEN
hz=resoth*1000
ENDIF
ELSE
hz=resorig*1000
ENDIF
@infsave
IF virtwfile=FALSE THEN
KILL virtpath$
RENAME virtp$ AS virtpath$
path$=virtpath$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
fil$=path$
@hardproof3
vmem=INT(virtln/mbit)*mbit
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
IF adjresmp=TRUE THEN
hz=resoth*1000
hzm=hz
retime=1
makecurve=1
ENDIF
ELSE
hz=resorig*1000
retime=0
makecurve=0
ENDIF
ELSE
@nomem
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE makebitconv
LOCAL okay,vln
IF virtual=FALSE THEN
IF blkobj=conv16& THEN
IF sblock=0 THEN
a=INT(mlen/6)
@maschruf19(a,meml,meml)
a=meml+INT(mlen/6*4)
@maschruf9(a,memh)
ELSE
@blocklook
a=INT((mce-mcs)/6)
@maschruf19(a,mcs,mcs)
a=mcs+INT((mce-mcs)/6*4)
@maschruf9(a,mce)
ENDIF
@setbitrate16
IF nr=blkfunc& THEN
@setbutton(blkobj,0)
ENDIF
cached=FALSE
FOR i=1 TO loopz
FOR j=1 TO 4
IF loops%(i,j)<>-1 THEN
loops%(i,j)=INT(loops%(i,j)/6*4)
ENDIF
NEXT j
NEXT i
ELSE
IF sblock=0 THEN
@resmptovirt(meml,memh)
ELSE
@blocklook
a=INT((mce-mcs)/4)
IF (mce+a*2)<memh THEN
@maschruf20(a,mcs,mcs)
IF nr=blkfunc& THEN
@setbutton(blkobj,0)
ENDIF
@setbitrate24
FOR i=1 TO loopz
FOR j=1 TO 4
IF loops%(i,j)<>-1 THEN
loops%(i,j)=INT(loops%(i,j)/4*6)
ENDIF
NEXT j
NEXT i
ELSE
@resmptovirt(mcs,mce)
ENDIF
ENDIF
ENDIF
ENDIF
IF virtual=TRUE THEN
vln=virtln
okay=FALSE
IF blkobj=conv16& THEN
tbytes=INT(mlen/6)*6
ELSE
tbytes=INT(mlen/6)*4
ENDIF
'
a=RINSTR(virtpath$,".")                 ! peak cache-file loeschen
IF a>0 THEN
dcach$=LEFT$(virtpath$,a)+peak$
cext$=RIGHT$(virtpath$,LEN(virtpath$)-a)
IF EXIST(dcach$)=TRUE THEN
KILL dcach$
ENDIF
ENDIF
'
a=ASC(LEFT$(virtpath$,1))-64
IF @dfree(a)>=virtln THEN
okay=TRUE
ENDIF
IF okay=TRUE THEN
OPEN "I",#1,virtpath$
a=RINSTR(virtpath$,"\")
'
IF blkobj=conv16& THEN
@setbitrate16
ELSE
@setbitrate24
ENDIF
'
virtfile$="VIRTWORK."+cext$
workfile$="WORK."+cext$
aback$="BACKUP."+cext$
'
IF a>0 THEN
virtp$=LEFT$(virtpath$,a)+virtfile$
ENDIF
OPEN "O",#2,virtp$
ENDIF
IF okay=TRUE THEN
seekz=0
seekz2=0
IF head>0 THEN
BGET #1,mdat%,head
@headmake4
BPUT #2,mdat%,head
vln=vln-head
ENDIF
REPEAT
IF vln>=tbytes THEN
IF blkobj=conv16& THEN
bytes=INT(mlen/6)*6
ELSE
bytes=INT(mlen/6)*4
ENDIF
ELSE
IF blkobj=conv16& THEN
bytes=INT(vln/6)*6
ELSE
bytes=INT(vln/4)*4
ENDIF
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF blkobj=conv16& THEN
a=INT(bytes/6)
@maschruf19(a,meml,meml)
bytes2=INT(bytes/6)*4
ELSE
a=INT(bytes/4)
@maschruf20(a,meml,meml)
bytes2=INT(bytes/4)*6
ENDIF
BPUT #2,meml,bytes2
ENDIF
vln=vln-bytes
seekz=seekz+bytes
seekz2=seekz2+bytes2
UNTIL vln<4
CLOSE #1
CLOSE #2
FOR i=1 TO loopz
FOR j=1 TO 4
IF loops%(i,j)<>-1 THEN
IF blkobj=conv16& THEN
loops%(i,j)=INT(loops%(i,j)/6*4)
ELSE
loops%(i,j)=INT(loops%(i,j)/4*6)
ENDIF
ENDIF
NEXT j
NEXT i
IF virtwfile=FALSE THEN
IF nr=blkfunc& THEN
@setbutton(blkobj,0)
ENDIF
KILL virtpath$
virtpath2$=virtpath$
a=RINSTR(virtpath2$,".")
IF a>0 THEN
cext$=RIGHT$(virtpath2$,LEN(virtpath2$)-a)
virtpath2$=LEFT$(virtpath2$,a)+cext$
ENDIF
RENAME virtp$ AS virtpath2$
path$=virtpath2$
workf$=path$
a=RINSTR(path$,"\")
smpnam$=RIGHT$(path$,LEN(path$)-a)
enam$=smpnam$
fil$=path$
efil$=path$
@hardproof3
vmem=INT(virtln/mbit)*mbit
noblkdel=TRUE
@memtovirt2
noblkdel=FALSE
ENDIF
ELSE
@nomem
IF nr=blkfunc& THEN
@setbutton(blkobj,0)
ENDIF
ENDIF
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
@blkrestaura
RETURN
'
> PROCEDURE nomem
.| Glob. Var.: g#,nomem#
.| Aufruf in : fade_it-1,fadesave-1,smpkhlp-1,smpmhlp-9,smpihlp-2,smpcut-1
.|     virtmove-1,virtcopy-1,virtins-1,putpix-1,edhandler2-1,sdsave-2
.|     smpsave-4,infsave-1,rettmem-2,arrsave-1,make-1,setsave-1,conspace-1
.|     coninsert-3,mono-1,negate-1,lrchange-1,makenorm-1,makeresmp-1,
@alerts(47)
nomem=TRUE
RETURN
'
> PROCEDURE nomem2
@alerts(3)
RETURN
'
> PROCEDURE makevoldb(vdb)
.| Glob. Var.: vol#,a$
.| Aufruf in : peak-1,do_peak-1,
LOCAL v
IF vdb<128+64 THEN
v=32-(vdb/3*2)
ELSE
v=32/127*(255-vdb)
ENDIF
v=(vdb-(128+64))/2
a$=STR$(v)
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
avol=v
RETURN
'
> PROCEDURE peakvar
distx=10
disty=29+wymax
wy=1
wx=31
distx2=distx+72
wymax=peaksize
px=volinbal
RETURN
'
> PROCEDURE volinit
@windowtest
IF vio=TRUE THEN
@setbutton(volinout&,1)
~@xrsrc_gaddr(0,nr,zu%)
pymax=DPEEK(zu%+24*volbox&+22)                    ! Hîhe der Volumebox in Pixeln
pymax=pymax-25-25                ! (war pymax-25)
IF vol2<192 THEN
vp=LOG10(192-vol2)
vp=pymax-ROUND((192-vp/LOG10(192)*192)/3*2/256*pymax)
ELSE
vp=vol2-192
IF vp=0 THEN
vp=pymax/2
ELSE
vp=ROUND(pymax/2-(LOG10(vp)/LOG10(63.5)/2*pymax))
ENDIF
ENDIF
py=vp
pyi=vp
DPOKE (zu%+24*volume&+18),vp+6                      ! Volume-Slider positionieren
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~OBJC_DRAW(zu%,volbox&,9,0,0,xwidth,ywidth)       ! neu zeichnen
~WIND_UPDATE(0)                                   ! BEG_UPDATE
ENDIF
px=volinbal2
pxv=px
DPOKE (zu%+24*balance&+16),px+pxmax+5              ! Horizontalposition des Balance-Sliders verÑndern
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
IF mute2=FALSE THEN
@balwrite2(vol2,px,pxmax)                             ! Ausgang auf 0 db stellen
ENDIF
@makevoldb(vol2)
@textfeld(peakdb&,a$,1)
@makevoldb(lbal)
bvol=avol
@makevoldb(rbal)
a$=STR$(ABS(bvol-avol))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
ELSE
@setbutton(volinout&,0)
~@xrsrc_gaddr(0,nr,zu%)
pymax=DPEEK(zu%+24*volbox&+22)                    ! Hîhe der Volumebox in Pixeln
pymax=pymax-25-25
IF vol<192 THEN
vp=LOG10(192-vol)
vp=pymax-ROUND((192-vp/LOG10(192)*192)/3*2/256*pymax)
ELSE
vp=vol-192
IF vp=0 THEN
vp=pymax/2
ELSE
vp=ROUND(pymax/2-(LOG10(vp)/LOG10(63.5)/2*pymax))
ENDIF
ENDIF
py=vp
pyi=vp
DPOKE (zu%+24*volume&+18),vp+6                      ! Volume-Slider positionieren
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~OBJC_DRAW(zu%,volbox&,9,0,0,xwidth,ywidth)       ! neu zeichnen
~WIND_UPDATE(0)                                   ! BEG_UPDATE
ENDIF
px=volinbal
pxv=px
DPOKE (zu%+24*balance&+16),px+pxmax+5              ! Horizontalposition des Balance-Sliders verÑndern
IF shading=FALSE AND dopix=FALSE THEN
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
IF mute1=FALSE THEN
@balwrite(vol,px,pxmax)
ENDIF
@makevoldb(vol)
@textfeld(peakdb&,a$,1)
@makevoldb(lbal)
bvol=avol
@makevoldb(rbal)
a$=STR$(ABS(bvol-avol))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
ENDIF
RETURN
'
> PROCEDURE volinout
IF vio=FALSE THEN
vio=TRUE
ELSE
vio=FALSE
ENDIF
@mutecontrol
@volinit
RETURN
'
> PROCEDURE peakinit
IF nr=peak& THEN
@markhlp
@buttbh(plmax&,v,peaksize)
wymax=peaksize
pkblk=wymax/9                  ! Einteilungs-Blockgroesse
pkrot=pkblk                      ! roter Bereich in Pixeln
pksix=pkrot+4*pkblk                ! -6db-Bereich
@peakvar
ENDIF
RETURN
'
> PROCEDURE tpeakinit
IF nr=trakker& THEN
@markhlp
@buttbh(trklvol&,v,h)
trakpkmax=h-1
tpkblk=trakpkmax/9                         ! Einteilungs-Blockgroesse
tpkrot=8                            ! roter Bereich in Pixeln
tpksix=tpkrot+4*tpkblk              ! -6db-Bereich
ENDIF
RETURN
'
> PROCEDURE peak
.| Glob. Var.: winh#,peak&,rsc_window&,vornr#,nr#,distx#,distx2#,disty#,wx#
.|     wy#,wymax#,peakint#,vpl#,pl#,vpr#,pr#,zu%,vol#,peakdb&,a$,pymax#
.|     volbox&,vp#,volume&,xwidth#,ywidth#,mute#,peaksw2&,g#,smpedit&
.|     edit_obj&,idx&
.| Ruft auf  : rsc_draw,markhlp,peakread,xrsrc_gaddr,fifodel,volwrite
.|     makevoldb,textfeld,setbutton,setbutton2,rsc_message
.| Aufruf in : drop2-1,smpedit-1,do_smpedit-1,
@testcopyright
slowpeak2=TIMER
IF BTST(winh,peak&)=FALSE THEN
IF rsc_window&<7 THEN
vornr=nr
nr=peak&
'
wpl=0   ! peakhold left
wpr=0   ! peakhold right
'
@buttbh(plmax&,v,peaksize)
wymax=peaksize
pkblk=wymax/9               ! Einteilungs-Blockgroesse
pkrot=pkblk                      ! roter Bereich in Pixeln
pksix=pkrot+4*pkblk                ! -6db-Bereich
'
IF adat=TRUE OR rch8=TRUE THEN
@hidetree2(peakch1&,FALSE)
@hidetree2(peakch2&,FALSE)
@hidetree2(peakch3&,FALSE)
@hidetree2(peakch4&,FALSE)
ELSE
@hidetree2(peakch1&,TRUE)
@hidetree2(peakch2&,TRUE)
@hidetree2(peakch3&,TRUE)
@hidetree2(peakch4&,TRUE)
ENDIF
'
vshading=shading
shading=TRUE
dopix=TRUE
xbmagic=XBIOS(xbs,1)
'
IF adat=TRUE OR rch8=TRUE THEN
IF rchmo=0 THEN
@setbutton3(peakch1&,1,nr)
ENDIF
IF rchmo=1 THEN
@setbutton3(peakch2&,1,nr)
ENDIF
IF rchmo=2 THEN
@setbutton3(peakch3&,1,nr)
ENDIF
IF rchmo=3 THEN
@setbutton3(peakch4&,1,nr)
ENDIF
ENDIF
GRAPHMODE 1
DEFLINE 1
prt=-1
plt=-1
prw=FALSE
plw=FALSE
@setbutton3(peakl&,0,nr)
@setbutton3(peakr&,0,nr)
@peakvar
'
'
peakint=FALSE
~@xrsrc_gaddr(0,nr,zu%)
'      @fifodel
pxmax=DPEEK(zu%+24*balbox&+20)                    ! Breite der Balancebox in Pixeln
pxmax=INT((pxmax-25)/2)
balinmax=pxmax
mute1=FALSE
mute2=FALSE
IF nr=peak& THEN
@textfeld2(nr,recerror&,"0"+CHR$(0),1)
@textfeld2(nr,recpeaks&,"0"+CHR$(0),1)
@textfeld2(nr,peakname&,CHR$(0),1)
ENDIF
@markhlp
@volinit
@setslide(phldslid&,pholdbut&,16,16,phold)
a$=RIGHT$(" "+STR$(phold),2)+CHR$(0)
@textbutt(phldslid&,pholdbut&,a$,1)
'
dopix=FALSE
shading=vshading
'
@rsc_draw(nr,7)
'
@peakread
vpl=pl
vpr=pr
'
winh=BSET(winh,nr)
@bigtext2
ELSE
@setbutton(peaksw2&,0)
@alerts(11)
ENDIF
ELSE
vornr=nr
nr=peak&
IF vornr=smpedit& THEN
@setbutton2(peaksw2&,1,vornr)
ENDIF
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
@wischwasch
@volinit
@bigtext2
ENDIF
IF nr=peak& THEN
IF hrd=1 THEN
@setbutton(hardpeak&,1)
ELSE
@setbutton(hardpeak&,0)
ENDIF
@mutecontrol
ENDIF
RETURN
'
> PROCEDURE mutecontrol
IF vio=FALSE THEN
IF mute1=FALSE THEN
@setbutton(peakmute&,0)
ELSE
@setbutton(peakmute&,1)
ENDIF
ELSE
IF mute2=FALSE THEN
@setbutton(peakmute&,0)
ELSE
@setbutton(peakmute&,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE deselchmo
IF rchmo=0 THEN
@setbutton(peakch1&,0)
ENDIF
IF rchmo=1 THEN
@setbutton(peakch2&,0)
ENDIF
IF rchmo=2 THEN
@setbutton(peakch3&,0)
ENDIF
IF rchmo=3 THEN
@setbutton(peakch4&,0)
ENDIF
RETURN
'
> PROCEDURE lpeakhold
@slideup(phldslid&,pholdbut&,16,1,16,phold,slflg)
IF slflg=TRUE THEN
a$=RIGHT$(" "+STR$(phold),2)+CHR$(0)
@textbutt(phldslid&,pholdbut&,a$,1)
ENDIF
@setbutton(lphold&,0)
RETURN
'
> PROCEDURE rpeakhold
@slidedwn(phldslid&,pholdbut&,16,1,16,phold,slflg)
IF slflg=TRUE THEN
a$=RIGHT$(" "+STR$(phold),2)+CHR$(0)
@textbutt(phldslid&,pholdbut&,a$,1)
ENDIF
@setbutton(rphold&,0)
RETURN
'
> PROCEDURE channelrec
IF obj=peakch1& THEN
@deselchmo
@setbutton(peakch1&,1)
rchmo=0
ENDIF
IF obj=peakch2& THEN
@deselchmo
@setbutton(peakch2&,1)
rchmo=1
ENDIF
IF obj=peakch3& THEN
@deselchmo
@setbutton(peakch3&,1)
rchmo=2
ENDIF
IF obj=peakch4& THEN
@deselchmo
@setbutton(peakch4&,1)
rchmo=3
ENDIF
RETURN
'
> PROCEDURE playpeak
@setbutton(obj,1)
IF obj=peakwait& THEN
pwait=TRUE
ENDIF
@smpplay
@setbutton(obj,0)
peakint=FALSE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE rectocurve
IF pstop=FALSE AND hrd=1 AND inf=TRUE AND nofile=0 THEN
@maschruf9(meml,memh)   ! Delete Memory
cached=FALSE
efil$=recfil$
ce=vmem
@hardproof3
vmem=virtln-head
vmeml=0
vmemh=vmem
hrd=1
@hardproof2
ln=vmem
obj=savall&
mrkobj=obj
virtual=TRUE
virtld=TRUE
ldtrk=TRUE
enam$=recnam$
smpnam$=enam$
@ldhlp
virtld=FALSE
ldtrk=FALSE
IF vmem<=mlen THEN
hrd=0
@setbutton(hardpeak&,0)
ENDIF
IF nr=smpedit& THEN
@editredraw
ELSE
nr=smpedit&
@wischwasch
@editselect
ENDIF
IF blks=0 THEN
sms=1
IF kms>0 THEN
IF EXIST(infname$) THEN
fil$=infname$
@infload
ENDIF
FOR i=1 TO kms
FOR j=1 TO 4
IF loops%(i,j)<>-1 THEN
bloops%(i,j)=loops%(i,j)/mbit
ENDIF
IF bloops%(i,j)<>-1 THEN
loops%(i,j)=bloops%(i,j)*mbit
ENDIF
NEXT j
NEXT i
ENDIF
'      @markdel      ! NEU
@clsed        ! NEU
@rebuild
@zslidecalc
@setslide(zomslide&,zoombutt&,zmax,16,zoomp)
@makepnt
@scrollinit
@setslide(scrlslde&,scrolbut&,scmax,5,scrollp)
mrscroll=scrollp
'
'      @edmarkdel
'      sms=i
@edmarksearch
@edmarkset(sms)
'
ENDIF
ln=vmem
vce=0
vcs=0
lz=1
IF vmem<=mlen THEN
@setbutton(hard&,0)
ENDIF
@fnamwrite
@getcurve
ENDIF
pstop=FALSE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE recpeak
@setbutton(obj,1)
'    nr=smpedit&
'    @rsc_redraw_obj(nr,0)
@markhlp
peakrd=TRUE
@smpstart
@setbutton(peakwait&,0)
IF breakrec=FALSE THEN
@rectocurve
ENDIF
peakrd=FALSE
peakint=FALSE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE recautopeak
@setbutton(obj,1)
'    nr=smpedit&
'    @rsc_redraw_obj(nr,0)
@markhlp
peakrd=TRUE
@smpauto
@rectocurve
peakrd=FALSE
peakint=FALSE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
RETURN
'
> PROCEDURE do_peak
.| Glob. Var.: peakint#,peak&,zu%,obj#,smpautop&,smpstrtp&,monitorp&
.|     peakmute&,mute#,vol#,volume&,zu2%,opy#,noppause#,x#,y#,k#,py#,yd#
.|     pymax#,peakdb&,a$,volbox&,xwidth#,ywidth#,peakexit&,winh#,nr#
.|     smpedit&,peaksw2&
.| Ruft auf  : xrsrc_gaddr,markhlp,smpauto,smpstart,monitor,volwrite
.|     setbutton,mousey,peakwert,mouse,makevoldb,textfeld,peakread,mousek
.|     restaura2b
.| Aufruf in : windows-1,
peakint=FALSE
~@xrsrc_gaddr(0,peak&,zu%)
GRAPHMODE 1
DEFLINE 1
peakrd=FALSE
IF obj=smpautop& THEN
@recautopeak
ENDIF
IF obj=peakhelp& THEN
@readbutton(obj)
@setbutton(obj,(buttflag AND &HFFFE)+1)
@helptxt("PEAKMETER")
ENDIF
IF obj=smpstrtp& OR (obj=peakwait& AND (lshft=TRUE OR rshft=TRUE)) THEN
obj=peakwait&
recpaus=TRUE
@setbutton(obj,1)
obj=smpstrtp&
@setbutton(obj,1)
@recpeak
recpaus=FALSE
@setbutton(peakwait&,0)
ENDIF
IF obj=playpeak& OR (obj=peakwait& AND lshft=FALSE AND rshft=FALSE) THEN
@setbutton(playpeak&,1)
@playpeak
@setbutton(playpeak&,0)
pwait=FALSE
ENDIF
IF obj=lphold& THEN
@lpeakhold
ENDIF
IF obj=rphold& THEN
@rpeakhold
ENDIF
@channelrec
IF obj=hardpeak& THEN
IF virtual=FALSE THEN
@harddisk
ELSE
@setbutton(hardpeak&,1)
ENDIF
ENDIF
@peakwork
IF obj=9999 OR obj=peakexit& THEN
IF XBIOS(xbs,1)=&H71273800 THEN
IF demo=FALSE THEN
@write_int(0)
ENDIF
peakint=FALSE
ENDIF
@setbutton(peakexit&,0)
winh=BCLR(winh,peak&)
@restaura2b
IF nr=smpedit& THEN
@setbutton(peaksw2&,0)
IF hrd=1 THEN
@setbutton(hard&,1)
ELSE
@setbutton(hard&,0)
ENDIF
ENDIF
ENDIF
obj=0
peakmrk=nr
REPEAT
UNTIL @mousek=0
RETURN
'
> PROCEDURE peakmute
mutemake=TRUE
IF vio=FALSE THEN
IF mute1=FALSE THEN
mute1=TRUE
ELSE
mute1=FALSE
ENDIF
ELSE
IF mute2=FALSE THEN
mute2=TRUE
ELSE
mute2=FALSE
ENDIF
ENDIF
IF vio=FALSE THEN
IF mute1=TRUE THEN
@setbutton(peakmute&,1)
@volwrite(0,0)
ELSE
@setbutton(peakmute&,0)
@balwrite(vol,volinbal,pxmax)
ENDIF
ELSE
IF mute2=TRUE THEN
@setbutton(peakmute&,1)
@volwrite2(0,0)
ELSE
@setbutton(peakmute&,0)
@balwrite2(vol2,volinbal2,pxmax)
ENDIF
ENDIF
IF peakrd=FALSE THEN
mutemake=FALSE
REPEAT
UNTIL @mousek=0
ENDIF
obj=0
RETURN
'
> PROCEDURE peakzero
~@xrsrc_gaddr(0,peak&,zu%)
zeromake=TRUE
@setbutton(balzero&,1)
px=0
IF vio=FALSE THEN
volinbal=0
ELSE
volinbal2=0
ENDIF
DPOKE (zu%+24*balance&+16),px+pxmax+5            ! Horizontalposition des Balance-Sliders verÑndern
IF flicker=TRUE THEN
VSYNC
ENDIF
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
IF vio=FALSE THEN
IF mute1=FALSE THEN
@balwrite(vol,px,pxmax)
ENDIF
ELSE
IF mute2=FALSE THEN
@balwrite2(vol2,px,pxmax)
ENDIF
ENDIF
@makevoldb(lbal)
bvol=avol
@makevoldb(rbal)
a$=STR$(ABS(bvol-avol))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
IF peakrd=FALSE THEN
zeromake=FALSE
REPEAT
UNTIL @mousek=0
@setbutton(balzero&,0)
ENDIF
obj=0
RETURN
'
> PROCEDURE volswitch
viomake=TRUE
@volinout
IF peakrd=FALSE THEN
viomake=FALSE
REPEAT
UNTIL @mousek=0
ENDIF
obj=0
RETURN
'
> PROCEDURE peakbalance(p)
IF ABS(p)<=pxmax THEN
px=p
IF vio=FALSE THEN
volinbal=px
IF mute1=FALSE THEN
@balwrite(vol,px,pxmax)
ENDIF
ELSE
volinbal2=px
IF mute2=FALSE THEN
@balwrite2(vol2,px,pxmax)
ENDIF
ENDIF
@makevoldb(lbal)
bvol=avol
@makevoldb(rbal)
a$=STR$(ABS(bvol-avol))
IF LEN(a$)>5 THEN
a$=LEFT$(a$,5)
ENDIF
a$=a$+CHR$(0)
@textfeld(peakbal&,a$,1)
DPOKE (zu%+24*balance&+16),px+pxmax+5            ! Horizontalposition des Balance-Sliders verÑndern
IF flicker=TRUE THEN
VSYNC
ENDIF
~WIND_UPDATE(1)                                  ! BEG_UPDATE
~OBJC_DRAW(zu%,balbox&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE peakvolume(p)
LOCAL lpmax
IF p<=pymax AND p>=0 THEN
pyi=p
IF vio=FALSE THEN
IF p>=INT(pymax/2) THEN
vol=((pymax-p)/pymax*256)/2*3
lpmax=192/LOG10(192)
vol=(192-vol)/lpmax
IF vol>0.1 THEN
vol=ROUND(192-10^vol)
ELSE
vol=192
ENDIF
ELSE
vol=(pymax/2-p)/pymax*127
lpmax=63.5/LOG10(63.5)
vol=(vol/lpmax)
IF vol>0.1 THEN
vol=ROUND(192+10^vol)
ELSE
vol=192
ENDIF
ENDIF
IF mute1=FALSE THEN
@balwrite(vol,volinbal,pxmax)
ENDIF
@makevoldb(vol)
ELSE
IF p>=INT(pymax/2) THEN
vol2=((pymax-p)/pymax*256)/2*3
lpmax=192/LOG10(192)
vol2=(192-vol2)/lpmax
IF vol2>0.1 THEN
vol2=ROUND(192-10^vol2)
ELSE
vol2=192
ENDIF
ELSE
vol2=(pymax/2-p)/pymax*127
lpmax=63.5/LOG10(63.5)
vol2=(vol2/lpmax)
IF vol2>0.1 THEN
vol2=ROUND(192+10^vol2)
ELSE
vol2=192
ENDIF
ENDIF
IF mute2=FALSE THEN
@balwrite2(vol2,volinbal2,pxmax)                             ! Ausgang auf db einstellen
ENDIF
@makevoldb(vol2)
ENDIF
@textfeld(peakdb&,a$,1)
DPOKE (zu%+24*volume&+18),p+6                   ! Hîhenposition des Volume-Sliders verÑndern
~WIND_UPDATE(1)                                  ! BEG_UPDATE
IF flicker=TRUE THEN
VSYNC
ENDIF
~OBJC_DRAW(zu%,volbox&,3,ax&+164,ay&+p+peaksize-pydist,33,80)      ! neu zeichnen
~WIND_UPDATE(0)                                  ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE peakwork
LOCAL mf,pydist
mf=4
'
IF obj=volinout& AND viomake=FALSE AND volmake=FALSE AND balmake=FALSE THEN
@volswitch
ENDIF
IF obj=peakmute& AND mutemake=FALSE AND volmake=FALSE AND balmake=FALSE THEN
@peakmute
ENDIF
IF obj=balzero& AND zeromake=FALSE AND volmake=FALSE AND balmake=FALSE THEN
@peakzero
ENDIF
IF ((obj=balance& OR balmake=TRUE) AND volmake=FALSE) OR (balmake=TRUE AND pshift2=TRUE) THEN
~@xrsrc_gaddr(1,obj,zu2%)
REPEAT
@mouse(x,y,k)
IF k=1 AND balmake=FALSE THEN
balmake=TRUE
DEFMOUSE mf
opx=x
ENDIF
IF opx<>x THEN
opx=x
pxv=x-xd-153+8
@peakbalance(pxv)
ENDIF
IF peakrd=FALSE THEN
xpsec=psec
psec=INT(psec/3)
@peakread
psec=xpsec
ENDIF
UNTIL peakrd=TRUE OR (peakrd=FALSE AND k=0)
IF peakrd=FALSE THEN
balmake=FALSE
IF intrec=TRUE OR intplay=TRUE THEN
@maus_player
ELSE
DEFMOUSE 0
ENDIF
ENDIF
obj=0
ENDIF
IF ((obj=volume& OR volmake=TRUE) AND balmake=FALSE) OR (volmake=TRUE AND pshift2=TRUE) THEN
~@xrsrc_gaddr(1,obj,zu2%)
REPEAT
~GRAF_MKSTATE(x,y,k,pshift)
IF pshift<>0 THEN
balmake=TRUE
opx=x
pshift2=TRUE
ENDIF
IF k=1 AND volmake=FALSE THEN
volmake=TRUE
DEFMOUSE mf
opy=y
ENDIF
IF opy<>y THEN
IF opy-y>10
y=opy-10
ENDIF
IF y-opy>10
y=opy+10
ENDIF
opy=y
IF bigtxt=FALSE THEN
py=y-yd-peaksize+176-10
pydist=190
ELSE
py=y-yd-peaksize+280-10
pydist=290
ENDIF
@peakvolume(py)
ENDIF
IF peakrd=FALSE THEN
xpsec=psec
psec=INT(psec/3)
@peakread
psec=xpsec
ENDIF
UNTIL peakrd=TRUE OR (peakrd=FALSE AND k=0)
IF peakrd=FALSE THEN
volmake=FALSE
IF intrec=TRUE OR intplay=TRUE THEN
@maus_player
ELSE
DEFMOUSE 0
ENDIF
ENDIF
obj=0
ENDIF
IF k=0 AND pshift2=TRUE THEN
pshift2=FALSE
ENDIF
RETURN
'
> PROCEDURE peakwert
.| Glob. Var.: demo#,scb%,sth#,sdb%,recfifolen#,seb%,adr#,sfb%,peakint#
.|     peakret#,back3%,pl#,pr#,wymax#,rwert#,pr2#,pl2#,gr1#,gr2#,n#
.| Ruft auf  : mousek,read_smp
.| Aufruf in : maschruf4b-1,do_peak-1,peakread-2,
IF demo=FALSE AND falcon=FALSE THEN
IF xbmagic=&H71273800 THEN
IF peakint=FALSE AND smpedda=TRUE THEN   ! Schutz vor Int-Start beim Programmstart
peakint=TRUE
peakret=XBIOS(xbs,120)
@write_int(2)
LPOKE pkreq+2,0
ENDIF
IF DPEEK(pkreq)=0   ! peak-answer ?
DPOKE pkreq,1               ! peak-request
pl=DPEEK(pkreq+2)  ! ...peakwert angekommen
pr=DPEEK(pkreq+4)
@peakfound
IF pl>32766 THEN
@setbutton(peakl&,1)
plt=TIMER
plw=TRUE
ENDIF
IF pr>32766 THEN
@setbutton(peakr&,1)
prt=TIMER
prw=TRUE
ENDIF
IF (TIMER-plt)>100 AND plw=TRUE THEN
plw=FALSE
@setbutton(peakl&,0)
ENDIF
IF (TIMER-prt)>100 AND prw=TRUE THEN
prw=FALSE
@setbutton(peakr&,0)
ENDIF
@peakdbcalc(pkblk)
ENDIF
ELSE
REPEAT
@read_smp
pr=rwert
UNTIL (pr AND 256)=0
REPEAT
REPEAT
@read_smp
pr=rwert
UNTIL (pr AND 256)=256
@read_smp
pr2=rwert
UNTIL (pr2 AND 256)=256
REPEAT
REPEAT
@read_smp
pl=rwert
UNTIL (pl AND 256)=0
@read_smp
pl2=rwert
UNTIL (pl2 AND 256)=0
pr=(pr AND 255)*256+(pr2 AND 255)
pl=(pl AND 255)*256+(pl2 AND 255)
IF pr>32767 THEN
pr=ABS(pr-65536)
ENDIF
IF pl>32767 THEN
pl=ABS(pl-65536)
ENDIF
pr=pr/32767*wymax
pl=pl/32767*wymax
ENDIF
ELSE
INC pr
INC pl
IF pr>gr1 THEN
pr=0
gr1=INT(RND(1)*wymax)
ENDIF
IF pl>gr2 THEN
pl=0
gr2=INT(RND(1)*wymax)
ENDIF
FOR n=0 TO 300
NEXT n
ENDIF
RETURN
'
> PROCEDURE peakdbcalc(mpkblk)
pl2=pl
IF pl2<=pkg0 THEN
'        db=-96..-48
pl=0
ENDIF
IF pl2>pkg0 AND pl2<=pkg1 THEN
'        db=-48..-24
pkdba=ROUND(pkt*LOG10(pl*2))
pl=ROUND(mpkblk/(pkdb1-pkdb0)*(pkdba-pkdb0))
ENDIF
IF pl2>pkg1 AND pl2<=pkg2 THEN
'        db=-24..-12
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk+ROUND(mpkblk/(pkdb2-pkdb1)*(pkdba-pkdb1))
ENDIF
IF pl2>pkg2 AND pl2<=pkg3 THEN
'        db=-12..-8
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*2+ROUND(mpkblk/(pkdb3-pkdb2)*(pkdba-pkdb2))
ENDIF
IF pl2>pkg3 AND pl2<=pkg4 THEN
'        db=-8..-6
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*3+ROUND(mpkblk/(pkdb4-pkdb3)*(pkdba-pkdb3))
ENDIF
IF pl2>pkg4 AND pl2<=pkg5 THEN
'        db=-6..-4
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*4+ROUND(mpkblk/(pkdb5-pkdb4)*(pkdba-pkdb4))
ENDIF
IF pl2>pkg5 AND pl2<=pkg6 THEN
'        db=-4..-3
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*5+ROUND(mpkblk/(pkdb6-pkdb5)*(pkdba-pkdb5))
ENDIF
IF pl2>pkg6 AND pl2<=pkg7 THEN
'        db=-3..-2
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*6+ROUND(mpkblk/(pkdb7-pkdb6)*(pkdba-pkdb6))
ENDIF
IF pl2>pkg7 AND pl2<=pkg8 THEN
'        db=-2..-1
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*7+ROUND(mpkblk/(pkdb8-pkdb7)*(pkdba-pkdb7))
ENDIF
IF pl2>pkg8 THEN
'        db=-1..0
pkdba=ROUND(pkt*LOG10(pl*2))
pl=mpkblk*8+ROUND((mpkblk-1)/(pkdb9-pkdb8)*(pkdba-pkdb8))
ENDIF
'
pr2=pr
IF pr2<=pkg0 THEN
'        db=-96..-48
pr=0
ENDIF
IF pr2>pkg0 AND pr2<=pkg1 THEN
'        db=-48..-24
pkdba=ROUND(pkt*LOG10(pr*2))
pr=ROUND(mpkblk/(pkdb1-pkdb0)*(pkdba-pkdb0))
ENDIF
IF pr2>pkg1 AND pr2<=pkg2 THEN
'        db=-24..-12
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk+ROUND(mpkblk/(pkdb2-pkdb1)*(pkdba-pkdb1))
ENDIF
IF pr2>pkg2 AND pr2<=pkg3 THEN
'        db=-12..-8
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*2+ROUND(mpkblk/(pkdb3-pkdb2)*(pkdba-pkdb2))
ENDIF
IF pr2>pkg3 AND pr2<=pkg4 THEN
'        db=-8..-6
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*3+ROUND(mpkblk/(pkdb4-pkdb3)*(pkdba-pkdb3))
ENDIF
IF pr2>pkg4 AND pr2<=pkg5 THEN
'        db=-6..-4
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*4+ROUND(mpkblk/(pkdb5-pkdb4)*(pkdba-pkdb4))
ENDIF
IF pr2>pkg5 AND pr2<=pkg6 THEN
'        db=-4..-3
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*5+ROUND(mpkblk/(pkdb6-pkdb5)*(pkdba-pkdb5))
ENDIF
IF pr2>pkg6 AND pr2<=pkg7 THEN
'        db=-3..-2
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*6+ROUND(mpkblk/(pkdb7-pkdb6)*(pkdba-pkdb6))
ENDIF
IF pr2>pkg7 AND pr2<=pkg8 THEN
'        db=-2..-1
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*7+ROUND(mpkblk/(pkdb8-pkdb7)*(pkdba-pkdb7))
ENDIF
IF pr2>pkg8 THEN
'        db=-1..0
pkdba=ROUND(pkt*LOG10(pr*2))
pr=mpkblk*8+ROUND((mpkblk-1)/(pkdb9-pkdb8)*(pkdba-pkdb8))
ENDIF
RETURN
'
> PROCEDURE peakread
.| Glob. Var.: nr#,peak&,pl#,pr#
.| Ruft auf  : peakwert,fifodel,peakread2
.| Aufruf in : rsc_do-1,peak-1,do_peak-1,
LOCAL i,a,b,t,t2,nov,nov2
GRAPHMODE 1
DEFLINE 1
IF nr=peak& THEN
IF xbmagic=&H71273800 THEN
@peakwert
ELSE
a=0
b=0
FOR i=0 TO 19
IF peakrd=FALSE THEN
'          @fifodel
ENDIF
@peakwert
IF pl>a THEN
a=pl
ENDIF
IF pr>b THEN
b=pr
ENDIF
NEXT i
pl=a
pr=b
ENDIF
ENDIF
@peakread2
RETURN
'
> PROCEDURE peakread2     ! peakmeter-draw
.| Glob. Var.: nr#,peak&,t#,t2#,vpl#,pl#,nov#,wymax#,vpr#,pr#,nov2#,erlaub#
.|     ax&,distx#,ay&,disty#,wy#,wx#,plm#,maxcol#,noppause#,distx2#,prm#
.| Ruft auf  : markhlp
.| Aufruf in : peakread-1,peakrec-1,
LOCAL x,y,k,v
fstyle=2
ffill=1
ffill2=3
ffill3=5
@windowtest
~WIND_UPDATE(1)                                    ! BEG_UPDATE
@peakvar
IF mywindow=TRUE THEN
IF nr=peak& THEN
slowpeak=INT((TIMER-slowpeak2)/2)
vrl=vpl-pl
vrr=vpr-pr
IF vrl>pschwell THEN
pl=vpl
ENDIF
IF vrr>pschwell THEN
pr=vpr
ENDIF
IF slowpeak>psec THEN    ! ums langsamer zu machen !
slowpeak2=TIMER
IF vrl>0 THEN
pl=vpl*prest
ENDIF
IF vrr>0 THEN
pr=vpr*prest
ENDIF
ENDIF
erlaub=TRUE
IF erlaub=TRUE AND shading=FALSE AND dopix=FALSE THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
@markhlp
'
IF hardcursor=FALSE THEN
~GRAF_MKSTATE(x,y,k,v4)
IF x>=ax&+distx-16 AND x<=ax&+distx2+wx+8 AND y<=ay&+disty+8 AND y>=ay&+disty-wymax-16 THEN
~GRAF_MOUSE(256,0)                              ! Hidem
ENDIF
ENDIF
'
IF pl>wpl THEN
wpl=pl
ELSE
INC wplz
IF wplz>(phold+1)*7 THEN
DEFFILL 0,1,0
PBOX ax&+distx,ay&+disty-wpl,ax&+distx+wx,ay&+disty-wpl+1
wplz=0
wpl=0
ENDIF
ENDIF
IF vpl>pl THEN
DEFFILL 0,1,0
IF INT(vpl)=INT(wpl) THEN
PBOX ax&+distx,ay&+disty-pl,ax&+distx+wx,ay&+disty-vpl+1
ELSE
PBOX ax&+distx,ay&+disty-pl,ax&+distx+wx,ay&+disty-vpl
ENDIF
ENDIF
IF pl<wymax-pksix THEN
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx,ay&+disty,ax&+distx+wx,ay&+disty-pl
ENDIF
IF pl>=wymax-pksix AND pl<wymax-pkrot THEN
plm=pl-(wymax-pksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx,ay&+disty,ax&+distx+wx,ay&+disty-(pl-plm)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill2
ELSE
DEFFILL dred,1,dred
ENDIF
PBOX ax&+distx,ay&+disty-(pl-plm),ax&+distx+wx,ay&+disty-pl
ENDIF
IF pl>=wymax-pkrot THEN
plm=pl-(wymax-pkrot)
plm2=pl-(wymax-pksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx,ay&+disty,ax&+distx+wx,ay&+disty-(pl-plm2)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill2
ELSE
DEFFILL dred,1,dred
ENDIF
PBOX ax&+distx,ay&+disty-(pl-plm2),ax&+distx+wx,ay&+disty-(pl-plm)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill3
ELSE
DEFFILL red,1,red
ENDIF
PBOX ax&+distx,ay&+disty-(pl-plm),ax&+distx+wx,ay&+disty-pl
ENDIF
IF pr>wpr THEN
wpr=pr
ELSE
INC wprz
IF wprz>(phold+1)*7 THEN
DEFFILL 0,1,0
PBOX ax&+distx2,ay&+disty-wpr,ax&+distx2+wx,ay&+disty-wpr+1
wprz=0
wpr=0
ENDIF
ENDIF
IF vpr>pr THEN
DEFFILL 0,1,0
IF INT(vpr)=INT(wpr) THEN
PBOX ax&+distx2,ay&+disty-pr,ax&+distx2+wx,ay&+disty-vpr+1
ELSE
PBOX ax&+distx2,ay&+disty-pr,ax&+distx2+wx,ay&+disty-vpr
ENDIF
ENDIF
IF pr<wymax-pksix THEN
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx2,ay&+disty,ax&+distx2+wx,ay&+disty-pr
ENDIF
IF pr>=wymax-pksix AND pr<wymax-pkrot THEN
prm=pr-(wymax-pksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx2,ay&+disty,ax&+distx2+wx,ay&+disty-(pr-prm)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill2
ELSE
DEFFILL dred,1,dred
ENDIF
PBOX ax&+distx2,ay&+disty-(pr-prm),ax&+distx2+wx,ay&+disty-pr
ENDIF
IF pr>=wymax-pkrot THEN
prm=pr-(wymax-pkrot)
prm2=pr-(wymax-pksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
PBOX ax&+distx2,ay&+disty,ax&+distx2+wx,ay&+disty-(pr-prm2)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill2
ELSE
DEFFILL dred,1,dred
ENDIF
PBOX ax&+distx2,ay&+disty-(pr-prm2),ax&+distx2+wx,ay&+disty-(pr-prm)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill3
ELSE
DEFFILL red,1,red
ENDIF
PBOX ax&+distx2,ay&+disty-(pr-prm),ax&+distx2+wx,ay&+disty-pr
ENDIF
'
IF hardcursor=FALSE THEN
IF x>=ax&+distx-16 AND x<=ax&+distx2+wx+8 AND y<=ay&+disty+8 AND y>=ay&+disty-wymax-16 THEN
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
ENDIF
'
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
vpl=pl
vpr=pr
ENDIF
ENDIF
~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE peakrec
.| Glob. Var.: nr#,peak&,pl#,peakret#,pr#,wymax#
.| Ruft auf  : peakread2
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,
LOCAL i,a,b,t,t2,nov,nov2
GRAPHMODE 1
DEFLINE 1
IF nr=peak& THEN
IF XBIOS(xbs,1)=&H71273800 THEN
~@xrsrc_gaddr(0,nr,zu%)
@mouse(x,y,k)
IF k=1 THEN
obj=OBJC_FIND(zu%,0,6,x,y)
IF obj<>0 OR volmake=TRUE OR balmake=TRUE THEN
peakrd=TRUE
@peakwork
peakrd=FALSE
ENDIF
ELSE
IF zeromake=TRUE AND k=0 THEN
@setbutton(balzero&,0)
zeromake=FALSE
ENDIF
IF mutemake=TRUE AND k=0 THEN
mutemake=FALSE
ENDIF
IF viomake=TRUE AND k=0 THEN
viomake=FALSE
ENDIF
IF volmake=TRUE THEN
volmake=FALSE
IF intrec=TRUE OR intplay=TRUE THEN
@maus_player
ELSE
DEFMOUSE 0
ENDIF
ENDIF
IF balmake=TRUE THEN
balmake=FALSE
IF intrec=TRUE OR intplay=TRUE THEN
@maus_player
ELSE
DEFMOUSE 0
ENDIF
ENDIF
ENDIF
ENDIF
@peakrec2
ENDIF
RETURN
'
> PROCEDURE peakfound
IF pl>32766 THEN
@setbutton(peakl&,1)
plt=TIMER
plw=TRUE
IF ad=1 THEN
INC peaks2
ENDIF
ENDIF
IF pr>32766 THEN
@setbutton(peakr&,1)
prt=TIMER
prw=TRUE
IF ad=1 THEN
INC peaks2
ENDIF
ENDIF
RETURN
'
> PROCEDURE peakrec2
IF demo=FALSE THEN
IF DPEEK(pkreq)=0   ! peak-answer ?
DPOKE pkreq,1               ! peak-request
pl=DPEEK(pkreq+2)  ! ...peakwert angekommen
pr=DPEEK(pkreq+4)
@peakfound
IF (TIMER-plt)>100 AND plw=TRUE THEN
plw=FALSE
@setbutton(peakl&,0)
ENDIF
IF (TIMER-prt)>100 AND prw=TRUE THEN
prw=FALSE
@setbutton(peakr&,0)
ENDIF
@peakdbcalc(pkblk)
@peakread2
ENDIF
ELSE
@peakfound
IF (TIMER-plt)>100 AND plw=TRUE THEN
plw=FALSE
@setbutton(peakl&,0)
ENDIF
IF (TIMER-prt)>100 AND prw=TRUE THEN
prw=FALSE
@setbutton(peakr&,0)
ENDIF
@peakdbcalc(pkblk)
@peakread2
ENDIF
RETURN
'
> PROCEDURE peakrec3
@windowtest
IF bigfoot=FALSE THEN
distx=rscw&(trakker&)/2+222
disty=rsch&(trakker&)-71
wymax=trakpkmax
distx2=distx+7
ELSE
distx=rscw&(trakker&)/2+290
disty=rsch&(trakker&)-68
wymax=trakpkmax
distx2=distx+8
ENDIF
wy=4
blue=4
green=3+8
red=2
IF demo=FALSE AND shading=FALSE AND dopix=FALSE THEN
IF DPEEK(pkreq)=0  ! peak-answer ?
DPOKE pkreq,1               ! peak-request
pl=DPEEK(pkreq+2)  ! ...peakwert angekommen
pr=DPEEK(pkreq+4)
@peakrec4
@peakdbcalc(tpkblk)
@peakread3
ENDIF
ENDIF
RETURN
'
> PROCEDURE peakrec4      ! peakdraw
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
IF pl>32766 THEN
IF maxcol=2 THEN
DEFFILL 1,2,4
ELSE
DEFFILL red,1,red
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-wymax-1,ax&+distx+wy,ay&+disty-wymax-5
~GRAF_MOUSE(257,0)                              ! Hidem
plt=TIMER
plw=TRUE
ENDIF
IF pr>32766 THEN
IF maxcol=2 THEN
DEFFILL 1,2,4
ELSE
DEFFILL red,1,red
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-wymax-1,ax&+distx2+wy,ay&+disty-wymax-5
~GRAF_MOUSE(257,0)                              ! Hidem
prt=TIMER
prw=TRUE
ENDIF
IF (TIMER-plt)>100 AND plw=TRUE THEN
plw=FALSE
DEFFILL 0,0,0
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-wymax-1,ax&+distx+wy,ay&+disty-wymax-5
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF (TIMER-prt)>100 AND prw=TRUE THEN
prw=FALSE
DEFFILL 0,0,0
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-wymax-1,ax&+distx2+wy,ay&+disty-wymax-5
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
RETURN
'
> PROCEDURE peakread3     ! peakmeter-draw
fstyle=1
ffill=5
@windowtest
~WIND_UPDATE(1)                                    ! BEG_UPDATE
IF mywindow=TRUE THEN
IF nr=trakker& THEN
slowpeak=INT((TIMER-slowpeak2)/2)
vrl=vpl-pl
vrr=vpr-pr
IF vrl>pschwell THEN
pl=vpl
ENDIF
IF vrr>pschwell THEN
pr=vpr
ENDIF
IF slowpeak>psec THEN    ! ums langsamer zu machen !
slowpeak2=TIMER
IF vrl>t2 THEN
pl=vpl*prest
ENDIF
IF vrr>t2 THEN
pr=vpr*prest
ENDIF
ENDIF
erlaub=TRUE
IF erlaub=TRUE AND shading=FALSE AND dopix=FALSE THEN
@markhlp
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
IF pl>wpl THEN
wpl=pl
ELSE
INC wplz
IF wplz>(phold+1)*7 THEN
DEFFILL 0,1,0
PBOX ax&+distx,ay&+disty-wpl,ax&+distx+wy,ay&+disty-wpl+1
wplz=0
wpl=0
ENDIF
ENDIF
IF vpl>pl THEN
DEFFILL 0,1,0
~GRAF_MOUSE(256,0)                              ! Hidem
IF INT(vpl)=INT(wpl) THEN
PBOX ax&+distx,ay&+disty-pl,ax&+distx+wy,ay&+disty-vpl+1
ELSE
PBOX ax&+distx,ay&+disty-pl,ax&+distx+wy,ay&+disty-vpl
ENDIF
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pl<wymax-tpksix THEN
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty,ax&+distx+wy,ay&+disty-pl
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pl>=wymax-tpksix AND pl<wymax-tpkrot THEN
plm=pl-(wymax-tpksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty,ax&+distx+wy,ay&+disty-(pl-plm)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL dred,1,dred
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-(pl-plm),ax&+distx+wy,ay&+disty-pl
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pl>=wymax-tpkrot THEN
plm=pl-(wymax-tpkrot)
plm2=pl-(wymax-tpksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty,ax&+distx+wy,ay&+disty-(pl-plm2)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL dred,1,dred
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-(pl-plm2),ax&+distx+wy,ay&+disty-(pl-plm)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL red,1,red
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx,ay&+disty-(pl-plm),ax&+distx+wy,ay&+disty-pl
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pr>wpr THEN
wpr=pr
ELSE
INC wprz
IF wprz>(phold+1)*7 THEN
DEFFILL 0,1,0
PBOX ax&+distx2,ay&+disty-wpr,ax&+distx2+wy,ay&+disty-wpr+1
wprz=0
wpr=0
ENDIF
ENDIF
IF vpr>pr THEN
DEFFILL 0,1,0
~GRAF_MOUSE(256,0)                              ! Hidem
IF INT(vpr)=INT(wpr) THEN
PBOX ax&+distx2,ay&+disty-pr,ax&+distx2+wy,ay&+disty-vpr+1
ELSE
PBOX ax&+distx2,ay&+disty-pr,ax&+distx2+wy,ay&+disty-vpr
ENDIF
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pr<wymax-tpksix THEN
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty,ax&+distx2+wy,ay&+disty-pr
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pr>=wymax-tpksix AND pr<wymax-tpkrot THEN
prm=pr-(wymax-tpksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty,ax&+distx2+wy,ay&+disty-(pr-prm)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL dred,1,dred
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-(pr-prm),ax&+distx2+wy,ay&+disty-pr
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF pr>=wymax-tpkrot THEN
prm=pr-(wymax-tpkrot)
prm2=pr-(wymax-tpksix)
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL blue,1,blue
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty,ax&+distx2+wy,ay&+disty-(pr-prm2)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL dred,1,dred
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-(pr-prm2),ax&+distx2+wy,ay&+disty-(pr-prm)
~GRAF_MOUSE(257,0)                              ! Hidem
IF maxcol=2 THEN
DEFFILL 1,fstyle,ffill
ELSE
DEFFILL red,1,red
ENDIF
~GRAF_MOUSE(256,0)                              ! Hidem
PBOX ax&+distx2,ay&+disty-(pr-prm),ax&+distx2+wy,ay&+disty-pr
~GRAF_MOUSE(257,0)                              ! Hidem
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
vpl=pl
vpr=pr
ENDIF
ENDIF
~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE peaktime
LOCAL t
IF demo=FALSE THEN
rfull2=LPEEK(peakfull)
ENDIF
t=peaktime
hsec2=INT((TIMER-t)/2)
IF INT(hsec2/mbit)<>INT(hsec/mbit) THEN    ! ums langsamer zu machen !
hsec=hsec2
@htimeset
IF nr=peak& THEN
IF bigtxt=FALSE THEN
IF flicker=TRUE THEN
VSYNC
ENDIF
@textfeld(peakpos&,a$,1)
ELSE
@bigtext(nr,a$,1)
ENDIF
IF rfull2<>rfull THEN
rfull=rfull2
b$=STR$(rfull)+CHR$(0)
@textfeld(recerror&,b$,1)
ENDIF
IF peaks2<>peaks THEN
peaks=peaks2
b$=STR$(peaks)+CHR$(0)
@textfeld(recpeaks&,b$,1)
ENDIF
ENDIF
ENDIF
~FRE(0)
RETURN
'
> PROCEDURE smpscrol
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=1
RETURN
'
> PROCEDURE smpzoom
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=2
RETURN
'
> PROCEDURE smpkopie
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=5
RETURN
'
> PROCEDURE smpmove
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=6
RETURN
'
> PROCEDURE smpinsert
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=4
RETURN
'
> PROCEDURE smpmerge
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=7
RETURN
'
> PROCEDURE smpmark
.| Glob. Var.: smark#
.| Aufruf in : do_smpedit-1,
smark=3
RETURN
'
> PROCEDURE springart(sa)
.| Glob. Var.: v4#,ce#,cs#,virtual#,back%,virtpath$,mlen#,maxx#,vln#,meml#
.| Ruft auf  : maschinit33,maschruf33,maschinit32,maschruf32,busy_mouse
.| Aufruf in : edhandler2-1,markhandler-1,
LOCAL seek,seek2,bytes
IF markmode=4 THEN
IF v4=1 OR v4=8 THEN
sa=sa+mbit
IF sa>ce THEN
sa=ce-mbit
ENDIF
ENDIF
IF v4=2 OR v4=4 THEN
sa=sa-mbit
IF sa<cs THEN
sa=cs+mbit
ENDIF
ENDIF
IF virtual=FALSE THEN
IF v4=1 THEN           ! rechte SHIFT
@maschruf33(sa,ce,0)
ENDIF
IF v4=2 THEN           ! linke SHIFT
@maschruf33(cs,sa,1)
ENDIF
IF v4=8 THEN           ! Alternate
@maschruf32(sa,ce,0)
ENDIF
IF v4=4 THEN           ! Control
@maschruf32(cs,sa,1)
ENDIF
ELSE
back%=-1
IF EXIST(virtpath$)=TRUE AND (v4=1 OR v4=2 OR v4=4 OR v4=8) THEN
OPEN "I",#1,virtpath$
bytes=INT(mlen/mbit)*mbit
IF bytes>50000 THEN
maxx=50000
ELSE
maxx=bytes
ENDIF
IF v4=1 OR v4=8 THEN         ! vorwÑrts
seek=sa
vln=ce-sa
ELSE                         ! rÅckwÑrts
seek=sa-maxx
IF seek<cs THEN
seek=cs
ENDIF
vln=sa-cs
ENDIF
vln=INT(vln/mbit)*mbit
seek=INT(seek/mbit)*mbit
seek2=seek
IF vln>0 THEN
REPEAT
@busy_mouse
SEEK #1,seek
seek2=seek
IF vln>=maxx THEN
bytes=maxx
ELSE
bytes=INT(vln/mbit)*mbit
ENDIF
IF bytes>3 THEN
BGET #1,meml,bytes
IF v4=1 THEN
@maschruf33(0,bytes,0)
ENDIF
IF v4=2 THEN
@maschruf33(0,bytes,1)
ENDIF
IF v4=8 THEN
@maschruf32(0,bytes,0)
ENDIF
IF v4=4 THEN
@maschruf32(0,bytes,1)
ENDIF
ENDIF
vln=vln-bytes
IF v4=1 OR v4=8 THEN
seek=seek+bytes
ELSE
seek=seek-bytes
ENDIF
UNTIL vln<4 OR back%<>-1
IF back%<>-1 THEN
back%=seek2+back%
ENDIF
ENDIF
CLOSE #1
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE markhandler(VAR tx)
.| Glob. Var.: cs#,ce#,xm#,x#,xd#,y#,stay1#,stay2#,k#,f#,x3#,x2#,v2#,show#
.|     showdat#,tedart#,hz#,showbdat#,shw$,showxy&,zsnap#,v#,v3#,v4#,back%
.|     t$,obj#
.| Ruft auf  : mousek,mouse,maketime,textfeld,springart
.| Aufruf in : markprod2-4,
LOCAL ux,i,vtx,cvt,fm,mx,ue
BOUNDARY 0
fm=0
vtx=tx
'  cvt=TIMER
IF vtx>=cs AND vtx<=ce AND (ce-cs)>0 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
IF x>ux+xd-2 AND x<ux+xd+2 AND y>=stay1 AND y<=stay2 THEN
k=@mousek
~GRAF_MOUSE(256,0)                              ! Hidem
IF k=1 THEN
IF maxcol=2 OR dreidim=0 THEN
COLOR 0
ELSE
COLOR smpwcol
ENDIF
GRAPHMODE 1
IF markmode<>2 THEN
IF bigfoot=FALSE THEN
ue=5
ELSE
ue=11
ENDIF
FOR i=x-3 TO x+3
LINE i,stay1,i,stay1-ue
NEXT i
ENDIF
drawnew=TRUE
GRAPHMODE 3
f=0
x3=-1
IF markmode=3 AND sms2<>0 AND loops%(sms,sms2)<>-1 THEN
scrubb2=FALSE
@digout(TRUE)
@write_int(0)
'
scrubbm=meml+loops%(sms,sms2)
IF virtual=TRUE THEN
scrubbm=scrubbm-vcs
ENDIF
'
scrubbz=loops%(sms,sms2)
IF scrubbm>=meml AND scrubbm<memh THEN
IF demo=FALSE THEN
scrubb=XBIOS(xbs,307,L:scrubbm,L:hz)
@write_int(1)
scrubb2=TRUE
ENDIF
ENDIF
ENDIF
REPEAT
@mouse(x2,v2,k)
'
IF markmode=3 AND sms2<>0 AND loops%(sms,sms2)<>-1 THEN
'    IF TIMER-cvt>4 THEN
'   cvt=TIMER
'
scrubbm=meml+scrubdat*mbit
IF virtual=TRUE THEN
scrubbm=scrubbm-vcs
ENDIF
'
IF scrubbm>=meml AND scrubbm<memh AND scrubb2=TRUE AND (TIMER-sct)>2 THEN
LPOKE scrubb+8,scrubbm
sct=TIMER
ENDIF
' ENDIF
ENDIF
'
@maketime
IF x2>=xd AND x2<=(xm+xd) AND xm>0 AND ce>cs AND show=TRUE THEN
scrubdat=(INT((INT((ce-cs)/mbit))/xm*(x2-xd)))+INT(cs/mbit)
showdat=scrubdat
IF tedart=0 THEN
showdat=showdat/hz
ENDIF
IF showbdat<>showdat THEN
showbdat=showdat
IF tedart=1 THEN
a$=STR$(showdat)
@formatsmp
shw$=a$+CHR$(0)
ELSE
hsec=showdat*100
@htimeset
shw$=a$
ENDIF
IF LEN(shw$)>13 THEN
shw$=LEFT$(shw$,13)+CHR$(0)
ENDIF
@textfeld(showxy&,shw$,1)
ENDIF
ENDIF
'
IF x<>x2 THEN
INC f
ENDIF
x=x2
IF x>=xd AND x<=xm+xd AND x<>ux+xd AND x3<>x THEN
GRAPHMODE 3
IF fm=0 AND markmode=2 THEN
mx=ux
LINE mx+xd,stay1+1,mx+xd,stay2
ENDIF
IF (fm>0 AND markmode=2) OR markmode<>2 THEN
COLOR 0
LINE ux+xd,stay1+1,ux+xd,stay2
ENDIF
fm=1
COLOR 1
IF markmode=2 THEN
PBOX mx+xd,stay1+1,ux+xd,stay2
ENDIF
vtx=INT(((ce-cs)/xm*(x-xd)+cs)/mbit)*mbit
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
x3=x
LINE ux+xd,stay1+1,ux+xd,stay2
GRAPHMODE 3
IF markmode=2 THEN
PBOX mx+xd,stay1+1,ux+xd,stay2
ENDIF
drawnew=TRUE
ENDIF
UNTIL k=0
IF markmode=2 THEN
COLOR 1
GRAPHMODE 3
PBOX mx+xd,stay1+1,ux+xd,stay2
COLOR 1
ENDIF
IF markmode=3 THEN
@write_int(0)
@digout(FALSE)
ENDIF
IF markmode=4 THEN
~GRAF_MKSTATE(v,v2,v3,v4)
IF v4<>0 THEN
@springart(vtx)
IF back%>=cs AND back%<=ce THEN
vtx=back%
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
GRAPHMODE 3
COLOR 0
LINE ux+xd,stay1+1,ux+xd,stay2
COLOR 1
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
x3=x
LINE ux+xd,stay1+1,ux+xd,stay2
GRAPHMODE 3
drawnew=TRUE
ENDIF
ENDIF
tx=vtx
COLOR 1
GRAPHMODE 3
IF bigfoot=FALSE THEN
DEFTEXT 1,0,0,4
ELSE
DEFTEXT 1,0,0,11
ENDIF
TEXT ux+xd-2,stay1-1,t$
DEFTEXT 1,0,0,4
drawnew=TRUE
ENDIF
~GRAF_MOUSE(257,0)                              ! Showm
ENDIF
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
obj=0
BOUNDARY 0
RETURN
'
> PROCEDURE markhandl2(VAR tx)
.| Glob. Var.: x#,vmem#,cs#,ce#,xm#,xd#,stay1#,stay2#,t$
.| Aufruf in : smph2-4,
LOCAL ux,i,vtx,ue
vtx=tx
IF x>=0 AND x<=vmem AND x>=cs AND x<=ce AND (ce-cs)>0 THEN
IF credraw=FALSE THEN
CLIP 0,0,xwidth,ywidth
ENDIF
ux=vtx-cs
ux=INT(ux/(ce-cs)*xm)
GRAPHMODE 3
COLOR 1
LINE ux+xd,stay1,ux+xd,stay2
IF maxcol=2 OR dreidim=0 THEN
COLOR 0
ELSE
COLOR smpwcol
ENDIF
GRAPHMODE 1
IF bigfoot=FALSE THEN
ue=5
ELSE
ue=11
ENDIF
FOR i=ux-3 TO ux+3
LINE i+xd,stay1,i+xd,stay1-ue
NEXT i
GRAPHMODE 1
COLOR 1
ux=x-cs
ux=INT(ux/(ce-cs)*xm)
GRAPHMODE 3
LINE ux+xd,stay1,ux+xd,stay2
IF bigfoot=FALSE THEN
DEFTEXT 1,0,0,4
ELSE
DEFTEXT 1,0,0,11
ENDIF
TEXT ux+xd-2,stay1-1,t$
DEFTEXT 1,0,0,4
drawnew=TRUE
IF credraw=FALSE THEN
CLIP OFF
ENDIF
ENDIF
IF x>=0 AND x<=vmem AND (ce-cs)>0 THEN
tx=x
ENDIF
RETURN
'
> PROCEDURE blkstore
.| Glob. Var.: blks#
.| Aufruf in : do_smpedit-1,
IF blks=0 THEN
blks=1
ELSE
blks=0
ENDIF
RETURN
'
> PROCEDURE tstfile
LOCAL t3,t4
OPEN "I",#1,fil$
f=LOF(#1)
datx=mdat%
BGET #1,datx,4
@fileart
SEEK #1,0
@fileart2
CLOSE #1
danf=datx
'
IF fileart=0 THEN
hz=44100
head=0
ENDIF
IF fileart=1 THEN       ! S16
x=PEEK(danf+7)                            ! Periodendauer eines Samples
y=DPEEK(danf+8)                           ! Periodendauer eines Samples
per=INT(10^9/(x*65536+y))
per=@hzanalye(per)
perm=per
t3=PEEK(danf+13)                           ! Sustain Loop-Start
t4=DPEEK(danf+14)                          ! Sustain Loop-Start
tmin=t3*65536+t4
t3=DPEEK(danf+16)                          ! Sustain Loop-End
t4=PEEK(danf+18)                           ! Sustain Loop-End
tmax=t3*256+t4
head=20   ! HeaderlÑnge fÅr S16-Files
ENDIF
IF fileart=2 THEN        ! AVR
tst1=DPEEK(danf+12)    ! mode
tst2=DPEEK(danf+14)    ! resolution
IF tst2=16 THEN
@setbitrate16
ENDIF
IF tst2=24 THEN
@setbitrate24
ENDIF
tst3=DPEEK(danf+16)    ! sign
IF tst1=&HFFFF AND (tst2=16 OR tst2=24) AND tst3=&HFFFF THEN
per=DPEEK(danf+24)    ! Sample-Rate
ELSE
per=44100
ENDIF
head=128   ! HeaderlÑnge fÅr AVR-Files
ENDIF
IF fileart=3 THEN        ! WAV
tst1=LPEEK(danf+8)     ! "WAVE"
tst2=LPEEK(danf+12)    ! "fmt "
tst3=PEEK(danf+20)     ! format
tst4=PEEK(danf+22)     ! channels
tst5=PEEK(danf+32)     ! align
tst6=PEEK(danf+34)     ! bps
IF tst6=16 THEN
@setbitrate16
ENDIF
IF tst6=24 THEN
@setbitrate24
ENDIF
IF tst1=&H57415645 AND tst2=&H666D7420 AND tst3=1 AND tst4=2 AND (tst5=4 OR tst5=6) AND (tst6=16 OR tst6=24) THEN
per=PEEK(danf+24)+256*PEEK(danf+25)    ! Sample-Rate
ELSE
per=44100
ENDIF
head=44   ! HeaderlÑnge fÅr AVR-Files
ENDIF
IF fileart=4 THEN        ! AU
tst1=LPEEK(danf+12)    ! dataformat
tst2=LPEEK(danf+20)    ! channelcount
IF tst1=3 AND tst2=2 THEN
per=LPEEK(danf+16)    ! Sample-Rate
ELSE
per=44100
ENDIF
head=28   ! HeaderlÑnge fÅr AVR-Files
ENDIF
IF fileart=5 THEN         ! SD
per=LPEEK(danf+1020)    ! Sample-Rate
head=1336 ! HeaderlÑnge fÅr SD-Files
ENDIF
IF fileart=6 THEN         ! SMP
tst1=DPEEK(danf+76)     ! Bits
IF tst1=16 OR tst1=24 THEN
per=LPEEK(danf+72)     ! Sample-Rate
ELSE
per=44100
ENDIF
head=296 ! HeaderlÑnge fÅr SD-Files
ENDIF
IF fileart=7 THEN        ! AIFF
tst1=LPEEK(danf+8)     ! AIFF-Kennung
tst2=LPEEK(danf+12)    ! COMM-Kennung
tst3=DPEEK(danf+20)    ! Channels
tst4=LPEEK(danf+38)    ! SSND-Kennung
tst5=DPEEK(danf+26)    ! Bits
IF tst5=16 THEN
@setbitrate16
ENDIF
IF tst5=24 THEN
@setbitrate24
ENDIF
IF tst1=&H41494646 AND tst2=&H434F4D4D AND tst3=2 AND tst4=&H53534E44 AND (tst5=16 OR tst5=24) THEN
per=DPEEK(danf+30)     ! Sample-Rate
ELSE
per=44100
ENDIF
head=54+458   ! HeaderlÑnge fÅr AIFF-Files
ENDIF
IF fileart<>0 AND NOT (hzkey=FALSE AND virtual=TRUE) THEN
@ldhztest
ENDIF
sectors=f
RETURN
'
> PROCEDURE sethdoffset
head=0
IF fileart=1 THEN
head=20
ENDIF
IF fileart=2 THEN
head=128
ENDIF
IF fileart=3 THEN
head=44
ENDIF
IF fileart=4 THEN
head=28
ENDIF
IF fileart=5 THEN
head=1336
ENDIF
IF fileart=6 THEN
head=20+296
ENDIF
IF fileart=7 THEN
head=54+458
ENDIF
RETURN
'
> PROCEDURE onlystart
IF c1>=0 AND c2=-1 THEN
c2=vmem
ENDIF
RETURN
'
> PROCEDURE smpplay
.| Glob. Var.: digana#,merkc#,hrd#,sblock#,mamidi#,a#,meml#,b#,memh#,sret#
.|     adder#,c#,l#,sloop#,adm#,ad#,nr#,smp16&,a$,popups&,analog&,input&
.|     digital&,smpedit&,smpplay&,virtual#,op$,ext$,pret#,pbutt#,fil$,f#
.|     sectors#,flen#,smpfile&,nam$,smplen&,mem$,s#,hz#,smpsec&,sec$,over#
.|     handle#,playpos#,cblk#,sms#,sme#,c1#,c2#,raus#,y#,v3#,demo#
.| Ruft auf  : edhandler3,wait,maschinit2,analog,textfeld,maschruf2
.|     maschruf18,digin,digital,setbutton,smppmhlp,fileselect,restaura
.|     memfeld,secfeld,digout,maschinit5b,blocklook,maschruf5c,maschruf18c
.|     maschinit5d,fnamwrite
.| Aufruf in : drop2-1,do_smpedit-1,smpcblkplay-1,
@markhlp
phz=hz
adm=ad
IF nr=peak& THEN
@write_int(0)
ENDIF
IF digana=FALSE THEN
merkc=-1
@edhandler3
ENDIF
@wait
IF hrd=0 THEN
'
IF falcon=TRUE THEN
demo=FALSE
ENDIF
'
IF sblock=0 THEN
a=meml
b=memh
IF sret=1 THEN
adder=0
c=a
a=b-mbit
b=c
IF sloop!=FALSE THEN
l=0
ELSE
l=1
ENDIF
ELSE
adder=0
l=sret
IF sloop!=TRUE THEN
l=l+1
ENDIF
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,analog&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF nr=peak& THEN
pknam$=smpnam$
@textfeld(peakname&,pknam$+CHR$(0),1)
ENDIF
IF (sret=0 OR sret=2) AND a<b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF sret=1 AND a>b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,digital&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
@setbutton(smpwait&,32)
ENDIF
IF nr=peak& THEN
@setbutton(playpeak&,32)
ENDIF
ELSE
@smppmhlp
ENDIF
'
IF falcon=TRUE THEN
demo=TRUE
ENDIF
'
ELSE
IF virtual=FALSE THEN
@fileselect(op$+"*."+ext$,"","PLAY:")
@restaura
ELSE
fil$=efil$
ENDIF
IF (virtual=FALSE AND pret<>0 AND pbutt=1) OR virtual=TRUE THEN
IF EXIST(fil$) THEN
'
@infload
'
@tstfile
IF hzkey=FALSE AND virtual=TRUE THEN
hz=phz
per=phz
@makehz
ENDIF
'
@sethdoffset
IF nr=smpedit& THEN
@textfeld(smpfile&,enam$+CHR$(0),1)
@memfeld(f,8)
@textfeld(smplen&,mem$,1)
s=f/(hz*mbit)
@secfeld(s,8)
@textfeld(smpsec&,sec$,1)
ENDIF
IF nr=peak& THEN
pknam$=nam$
@textfeld(peakname&,pknam$+CHR$(0),1)
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,analog&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
@digout(TRUE)
'        @maschinit5b
IF sret=0 OR sret=2 THEN
l=sret
IF sloop!=TRUE THEN
l=l+1
ENDIF
over=0
adder=over
REPEAT
a$=fil$+CHR$(0)
handle=GEMDOS(61,L:VARPTR(a$),0)
IF handle>0 THEN
playpos=head
IF virtual=TRUE AND sblock=1 THEN
IF cblk=FALSE THEN
@blocklook
@onlystart
ENDIF
IF (sms<>0 AND c1<>-1 AND c2>0 AND c2>c1) OR cblk=TRUE THEN
sectors=(c2-c1)
playpos=c1+head
ENDIF
ENDIF
IF mamidi=0 THEN
@maschrufb5
ELSE
@maschruf18c
IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
l=sret+4
IF sloop!=TRUE THEN
l=l+1
ENDIF
@maschruf5c
ENDIF
ENDIF
~GEMDOS(62,handle)
ENDIF
UNTIL mamidi=0 OR (mamidi=1 AND (v3=2 OR INP?(2)=TRUE))
ENDIF
IF sret=1 OR sret=2 THEN
IF sloop!=FALSE THEN
l=0
ELSE
l=1
ENDIF
over=-mbit*2
adder=over
REPEAT
a$=fil$+CHR$(0)
handle=GEMDOS(61,L:VARPTR(a$),0)
IF handle>0 THEN
IF virtual=TRUE AND sblock=1 THEN
IF cblk=FALSE THEN
@blocklook
@onlystart
ENDIF
IF (sms<>0 AND c1<>-1 AND c2>0 AND c2>c1) OR cblk=TRUE THEN
sectors=(c2-c1)
playpos=c2+head
ENDIF
ELSE
playpos=sectors
ENDIF
IF mamidi=0 THEN
@maschrufb5
ELSE
@maschruf18c
IF raus=TRUE AND y=FALSE AND v3<>2 AND demo=FALSE THEN
l=4
IF sloop!=TRUE THEN
l=l+1
ENDIF
@maschruf5c
ENDIF
ENDIF
~GEMDOS(62,handle)
ENDIF
UNTIL mamidi=0 OR (mamidi=1 AND (v3=2 OR INP?(2)=TRUE))
ENDIF
@fnamwrite
'
@infsave2
'
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
@setbutton(smpwait&,32)
ENDIF
IF nr=peak& THEN
@setbutton(playpeak&,32)
ENDIF
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,digital&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
@digout(FALSE)
RETURN
'
> PROCEDURE smpcblkplay
.| Glob. Var.: cs#,ce#,vmem#,a#,meml#,b#,c1#,c2#,vsblock#,sblock#,vmamidi#
.|     mamidi#,cblk#,ama#,amb#,memh#
.| Ruft auf  : smpplay
.| Aufruf in : do_smpedit-1,
IF cs>=0 AND ce<=vmem AND cs<ce THEN
cs=INT(cs/mbit)*mbit
ce=INT(ce/mbit)*mbit
a=meml+cs
b=meml+ce
a=INT(a/mbit)*mbit
b=INT(b/mbit)*mbit
c1=cs
c2=ce
vsblock=sblock
vmamidi=mamidi
sblock=1
mamidi=0
cblk=TRUE
ama=meml
amb=memh
@smpplay
cblk=FALSE
sblock=vsblock
mamidi=vmamidi
ENDIF
RETURN
'
> PROCEDURE smppmhlp
.| Glob. Var.: mamidi#,cblk#,l#,sloop#,lmin#,a#,lma#,b#,sms#,sme#,ama#,amb#
.|     xm#,stxnr#,sret#,adder#,c#,adm#,ad#,nr#,smp16&,a$,popups&,analog&
.|     input&,digital&,smpedit&,smpplay&
.| Ruft auf  : maschinit2,playblksearch,analog,textfeld,maschruf2,maschruf18
.|     digin,digital,setbutton
.| Aufruf in : smpplay-1,
IF cblk=FALSE THEN
@playblksearch
ENDIF
IF sloop!=TRUE THEN
l=1
ELSE
l=0
ENDIF
lmin=a
lma=b
IF (sms<>0 AND a>=ama AND b<=amb AND xm<>0 AND stxnr<>0) OR cblk=TRUE THEN
IF sret=1 THEN
adder=0
c=a
a=b-mbit
b=c
ELSE
adder=0
ENDIF
adm=ad
IF adm=0 THEN
@analog
IF nr=smp16& THEN
a$=@rsc_text$(popups&,analog&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
IF (sret=0 OR sret=2) AND a<b THEN
l=l+sret
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF sret=1 AND a>b THEN
IF mamidi=0 THEN
@maschruf2
ELSE
@maschruf18
ENDIF
@digin
ENDIF
IF adm=0 THEN
@digital
IF nr=smp16& THEN
a$=@rsc_text$(popups&,digital&)
@textfeld(input&,a$,1)
ENDIF
ENDIF
ENDIF
IF nr=smpedit& THEN
@setbutton(smpplay&,32)
ENDIF
IF nr=peak& THEN
@setbutton(playpeak&,32)
ENDIF
RETURN
'
> PROCEDURE playblksearch
.| Glob. Var.: a#,meml#,ama#,amb#,memh#,i#,loopz#,sms#,stxnr#,xm#,b#,sme#
.| Felder    : loops#(),loope#()
.| Aufruf in : smppmhlp-1,
a=meml
ama=a
amb=memh
stxnr2=loops%(sms,1)
IF xm>0 AND stxnr2>0 THEN
a=a+stxnr2
a=INT(a/mbit)*mbit
ENDIF
b=meml
stxnr=loops%(sms,2)
IF xm>0 AND stxnr>0 THEN
b=b+stxnr
b=INT(b/mbit)*mbit
b=b-mbit
ENDIF
IF xm>0 AND stxnr=-1 AND stxnr2>=0 THEN
b=memh
b=INT(b/mbit)*mbit
b=b-mbit
ENDIF
RETURN
'
> PROCEDURE smppmark
.| Glob. Var.: sblock#
.| Aufruf in : do_smpedit-1,
IF sblock=0 THEN
sblock=1
ELSE
sblock=0
ENDIF
RETURN
'
> PROCEDURE smploop
.| Glob. Var.: sloop#
.| Aufruf in : do_smpedit-1,
IF sloop!=FALSE THEN
sloop!=TRUE
ELSE
sloop!=FALSE
ENDIF
RETURN
'
> PROCEDURE smpauto
.| Glob. Var.: autorec#,obj#,recok&,retime#,ldlen#,hrd#,blocks#,a#,meml#,l#
.|     mlen#,mcs#,mce#,sab%,sbb%,frag#,nofile#,ad#,hzc#,rwert#,sblock#,c2#
.|     c1#,sms#,sme#,ce#,xm#,nr#,smpedit&,smpauto2&,arranger&,smpauto3&
.| Ruft auf  : makehz2,sethertz,wait,smptime,maschinit3,blocklook,record3
.|     digout,smprate,maschruf4b,maschruf4,fifodel,maschruf3b,record4
.|     setbutton,record2
.| Aufruf in : drop2-1,do_arrange-1,do_smpedit-1,do_peak-1,
breakrec=FALSE
sectpos=0
ed_obj=obj
autorec=TRUE
@makehz2
@sethertz
@wait
retime=0
ldlen=0
IF hrd=0 THEN
IF blocks=0 THEN
a=meml
l=mlen
ELSE
@blocklook
a=mcs
l=mce-mcs
ENDIF
sab%=a
sbb%=a+l
ELSE
@record3
ENDIF
IF hrd=0 OR (hrd=1 AND obj=recok&) THEN
@digout(FALSE)
IF hrd=0 THEN
@alerts(48)
ENDIF
IF (hrd=1 AND nofile=0) THEN
frag=1
ENDIF
IF frag=2 THEN
@setbutton(ed_obj,0)
ENDIF
@wait
IF ad=0 THEN
@read_digsrate
hzc=rwert
ENDIF
IF frag=1 AND ((hrd=0 AND sblock=0) OR (hrd=0 AND sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND ce<>0 AND xm>0)) THEN
IF XBIOS(xbs,1)=&H71273800 THEN
@maschruf4b
ENDIF
ELSE
'      @fifodel
ENDIF
IF frag=1 AND ((hrd=0 AND sblock=0) OR (hrd=0 AND sblock=1 AND c2>c1 AND mce<>0 AND l<>0 AND sms<>0 AND ce<>0 AND xm>0)) THEN
@maschruf3b
ENDIF
IF hrd=1 THEN
@record4
ENDIF
IF nr=smpedit& THEN
@setbutton(smpauto2&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpauto3&,0)
ENDIF
@record2
ELSE
IF nr=smpedit& THEN
@setbutton(smpauto2&,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpauto3&,0)
ENDIF
ENDIF
obj=0
edit_obj&=0
IF nr=smpedit& THEN
IF hrd=1 THEN
@setbutton(hard&,1)
ELSE
@setbutton(hard&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE smpstart
.| Glob. Var.: autorec#,obj#,recok&,ldlen#,hrd#,nr#,smpedit&,smpstrt2&
.|     arranger&,smpstrt3&
.| Ruft auf  : makehz2,sethertz,wait,smptime,fifodel,record,record3,record4
.|     setbutton,record2
.| Aufruf in : drop2-1,do_arrange-1,do_smpedit-1,do_peak-1,
sectpos=0
ed_obj=obj
autorec=FALSE
@makehz2
@sethertz
@wait
~@xrsrc_gaddr(0,info&,dzu%)
nkind=(DPEEK(dzu%+24*inforeg1&))
IF nkind<>21 THEN
tstcpr=-1
ENDIF
ldlen=0
'  @fifodel
IF hrd=0 THEN
'    @alerts(48)
'    IF frag=1 THEN
frag=1
@record
'  ELSE
@setbutton(ed_obj,0)
'  ENDIF
ELSE
@record3
IF obj=recok& THEN
@record4
ENDIF
ENDIF
IF (hrd=0 AND frag=1) OR (hrd=1 AND obj=recok&) THEN
IF nr=smpedit& THEN
@setbutton(ed_obj,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpstrt3&,0)
ENDIF
IF hrd=0 THEN
@record2
ENDIF
ELSE
IF nr=smpedit& THEN
@setbutton(ed_obj,0)
ENDIF
IF nr=arranger& THEN
@setbutton(smpstrt3&,0)
ENDIF
ENDIF
obj=0
edit_obj&=0
IF nr=smpedit& THEN
IF hrd=1 THEN
@setbutton(hard&,1)
ELSE
@setbutton(hard&,0)
ENDIF
ENDIF
RETURN
'
> PROCEDURE record
.| Glob. Var.: retime#,ldlen#,nr#,smpedit&,p$,smprate&,sblock#,a#,meml#,l#
.|     mlen#,mcs#,mce#,ad#,hzc#,rwert#,c2#,c1#,sms#,sme#,ce#,xm#
.| Ruft auf  : textfeld,maschinit3,blocklook,smprate,digout,maschruf3
.| Aufruf in : smpstart-1,
'
IF falcon=TRUE THEN
demo=FALSE
ENDIF
'
vsms2=sms2
retime=0
ldlen=0
IF nr=smpedit& THEN
p$="    "+CHR$(0)
@textfeld(smprate&,p$,1)
ENDIF
IF nr=peak& THEN
pknam$=smpnam$
@textfeld(peakname&,pknam$+CHR$(0),1)
ENDIF
IF sblock=0 THEN
IF sms2<>0 AND nr=smpedit& THEN
@edmarkdel
ENDIF
@markdel
@clsed
ENDIF
IF sblock=0 THEN
ar=meml
lr=mlen
ELSE
@blocklook
ar=mcs
lr=mce-mcs
ENDIF
IF ad=0 THEN
@read_digsrate
hzc=rwert
ENDIF
IF sblock=0 OR (sblock=1 AND c2>c1 AND mce<>0 AND lr<>0 AND sms<>0 AND ce<>0 AND xm>0) THEN
ar=INT(ar/mbit)*mbit
lr=INT(lr/mbit)*mbit
@digout(FALSE)
IF ed_obj=smpstrt2& OR ed_obj=smpstrtp& THEN
@maschruf3
ENDIF
IF ed_obj=recplay3& THEN
@maschruf7
ENDIF
IF nr=smpedit& THEN
@edmarkdel
IF sms2<>0 THEN
FOR j=1 TO 4
@selblkstxt(j,CHR$(0))
NEXT j
IF vsms2<>0 THEN
@selblkshak(vsms2,0)
ENDIF
@selblkshak(sms2,1)
@edmarkset(sms)
ENDIF
ENDIF
ELSE
@setbutton(obj,0)
ENDIF
'
IF falcon=TRUE THEN
demo=TRUE
ENDIF
'
RETURN
'
> PROCEDURE record2
.| Glob. Var.: nr#,sblock#,smpnam$,ext2$,path$,lfw$,smplen#,vmem#,mbs#,i#
.|     bloopz#,lded#,smpedit&,cs#,ce#
.| Felder    : bloops#(),bloope#()
.| Ruft auf  : rsc_redraw_obj,markdel,clsed,fnamwrite,curve,markprod3
.| Aufruf in : smpauto-1,smpstart-1,
smpnam$="MEMORY."+ext2$
path$=lfw$+smpnam$
smplen=vmem
mbs=0
FOR i=1 TO bloopz
bloops%(i,1)=-1
bloops%(i,2)=-1
NEXT i
lded=0
@fnamwrite
IF nr=smpedit& THEN
@editredraw
ENDIF
RETURN
'
> PROCEDURE record3
.| Glob. Var.: retime#,ldlen#,nofile#,hrd#,op$,ext2$,nr#,fil$,pret#,pbutt#
.|     nam$,f#,min#,hz#,sectors#,flen#,smpedit&,smpfile&,4smplen&,mem$,hsec#
.|     smpsec&,sec$,autorec#
.| Ruft auf  : fileselect,rsc_redraw_obj,textfeld,memfeld,secfeld,restaura
.| Aufruf in : smpauto-1,smpstart-1,
ext2$=ext$
IF ext2$="*" THEN
IF dig24=FALSE THEN
ext2$="S16"
ELSE
ext2$="S24"
ENDIF
ENDIF
retime=0
ldlen=0
nofile=0
IF hrd=1 THEN
rsmpnam$=smpnam$
rpath$=path$
rsmplen=smplen
rfil$=efil$
rnam$=enam$
rordner$=ordner$
REPEAT
@fileselect(op$+"*."+ext2$,"","RECORD:")
IF fil$="" OR pret=0 OR pbutt=0 THEN
nofile=1
ELSE
IF RIGHT$(fil$,1)="\" THEN
nofile=1
ENDIF
ENDIF
IF nofile=0 THEN
IF nr=trakker& THEN
IF INSTR(fil$,CHR$(0))>0 THEN
fil$=LEFT$(fil$,LEN(fil$)-1)
ENDIF
a$=fil$+CHR$(0)
trkisda=FALSE
FOR i=1 TO trkvmax
a=trkpnt(i)
IF a<>0 THEN
IF trkpath$(a)<>a$ THEN
REPEAT
a=trknext(a)
IF trkpath$(a)=a$ THEN
trkisda=TRUE
ENDIF
UNTIL a=0 OR trkisda=TRUE
ELSE
trkisda=TRUE
ENDIF
ENDIF
EXIT IF trkisda=TRUE
NEXT i
IF trkisda=TRUE AND nofile=0 THEN
@alerts(68)
IF g=2 THEN
nofile=1
ENDIF
ENDIF
ENDIF
ENDIF
UNTIL (nr=trakker& AND (trkisda=FALSE OR nofile=1)) OR nr<>trakker&
IF nofile=0 THEN
@killpbfinf(fil$)
IF recp=FALSE THEN
'        @smptime
a=ASC(LEFT$(fil$,1))-64
a2=@dfree(a)
a2=INT(a2-(a2/64)-4*maxhdsec)
sectors=rtime/100*hz*mbit
IF a2<sectors OR recmax=TRUE THEN
sectors=a2
ENDIF
obj=recok&
IF sectors<=0 THEN
nofile=1
ENDIF
ELSE
a=ASC(LEFT$(fil$,1))-64
a2=@dfree(a)
a2=INT(a2-(a2/64)-4*maxhdsec)
sectors=a2
'       IF a2<trkall THEN
'        sectors=a2
'       ELSE
'        sectors=trkall
'       ENDIF
obj=recok&
IF sectors<=0 THEN
nofile=1
ENDIF
ENDIF
l=sectors
ENDIF
IF nofile=0 AND obj=recok& THEN
IF INSTR(fil$,".")=0 THEN
fil$=fil$+"."+ext2$
ENDIF
IF INSTR(nam$,".")=0 THEN
nam$=nam$+"."+ext2$
ENDIF
efil$=fil$+CHR$(0)
enam$=nam$
recfil$=efil$
recnam$=enam$
'      f=INT(rtime/100*hz)*mbit
f=sectors
'      IF recp=FALSE THEN
'        sectors=f
'      ENDIF
IF nr=smpedit& THEN
@textfeld(smpfile&,enam$+CHR$(0),1)
@memfeld(f,8)
@textfeld(smplen&,mem$,1)
IF rmo8=FALSE THEN
hsec=f/(hz*mbit)
ELSE
hsec=f/hz
ENDIF
@secfeld(hsec,8)
@textfeld(smpsec&,sec$,1)
ENDIF
IF nr=peak& THEN
pknam$=nam$
@textfeld(peakname&,pknam$+CHR$(0),1)
ENDIF
IF wisch=FALSE AND recp=FALSE THEN
@restaura
ENDIF
ELSE
smpnam$=rsmpnam$
path$=rpath$
smplen=rsmplen
efil$=rfil$
enam$=rnam$
ordner$=rordner$
@setbutton(ed_obj,0)
IF autorec=FALSE AND wisch=FALSE AND recp=FALSE THEN
@restaura
ENDIF
ENDIF
ENDIF
IF trakact=0 AND nofile=0 AND nr=trakker& THEN
trakact=1
ENDIF
RETURN
'
> PROCEDURE wrongcopyright
LOCAL i
IF compile=TRUE THEN
BMOVE BASEPAGE+256,BASEPAGE+1888,500000
i=0
CLS
REPEAT
PRINT reg5$
INC i
UNTIL i=100
ENDIF
RETURN
'
> PROCEDURE record4
.| Glob. Var.: mrkfastrec#,fastrec#,hrd#,nofile#,autorec#,isave#,bnam$,nam$
.|     fil$,l#,smplen#,inf#,path$,smpnam$,g#,mlen#
.| Ruft auf  : maschinit8,maschinit8b,infhol,sampleinf,makedatum,infsave
.|     maschruf8,maschruf8b,fnamwrite
.| Aufruf in : smpauto-1,smpstart-1,
IF hrd=1 THEN
IF nofile=0 THEN
IF hrd=1 THEN
@infhol
isave=TRUE
bnam$=enam$
l=sectors
smplen=sectors
'
@infmemkill2
infname$=LEFT$(efil$,RINSTR(efil$,"."))+inf$
@infsave
inf=TRUE
'
'        @sampleinf
isave=FALSE
IF inf=TRUE THEN
path$=efil$
smpnam$=enam$
@makedatum
ELSE
IF virtual=TRUE AND EXIST(rfil$) THEN
smpnam$=rsmpnam$
path$=rpath$
smplen=rsmplen
efil$=rfil$
enam$=rnam$
ordner$=rordner$
ENDIF
ENDIF
ENDIF
IF inf=TRUE THEN
'
@markdel
@clsed
'
IF mtc=FALSE AND recp=FALSE AND nr<>smpedit& AND nr<>peak& AND nr<>arranger& AND nr<>trakker& THEN
@alerts(49)
ENDIF
IF autorec=TRUE THEN
IF frag=1 AND hrd=1 AND nofile=0 THEN
IF XBIOS(xbs,1)=&H71273800 THEN
@maschruf4b
ENDIF
ELSE
'           @fifodel
ENDIF
ENDIF
IF recp=FALSE THEN
IF breakrec=FALSE THEN
@maschruf8c
efil$=fil$
enam$=nam$
infname$=LEFT$(efil$,RINSTR(efil$,"."))+inf$
@infsave
'          @infmemkill
ELSE
@setbutton(ed_obj,0)
ENDIF
ENDIF
IF nr=smpedit& AND breakrec=FALSE THEN
@markdel
@clsed
'
'          @infmemkill             ! Das hier ist nîtig, weil durch HDR das samplemem Åberschrieben wird
cached=FALSE
@maschruf9(meml,memh)   ! Delete Memory
@restaura
'
ENDIF
IF virtual=TRUE AND EXIST(rfil$) AND breakrec=FALSE THEN
smpnam$=rsmpnam$
path$=rpath$
smplen=rsmplen
efil$=rfil$
enam$=rnam$
ordner$=rordner$
ENDIF
IF nr=smpedit& AND breakrec=TRUE THEN
hsec=0
@htimeset
IF bigfoot=TRUE THEN
@textfeld(editime&,a$,1)
ENDIF
ENDIF
ELSE
@setbutton(ed_obj,0)
ENDIF
ENDIF
smplen=mlen
ENDIF
autorec=FALSE
RETURN
'
> FUNCTION freemem(vv)
IF vv>0 THEN
~MFREE(vv)
vv=0
ENDIF
RETURN vv
ENDFUNC
'
> PROCEDURE exit
arrmem=@freemem(arrmem)
dspbuf=@freemem(dspbuf)
tmem=@freemem(tmem)
mixmem%=@freemem(mixmem%)
nonstm=@freemem(nonstm)
IF windcache=TRUE THEN
memfade=@freemem(memfade)
memc=@freemem(memc)
memtrak=@freemem(memtrak)
ENDIF
IF peakmem%>0 AND nopeakmem=FALSE AND peakmemda=TRUE THEN
peakmem%=@freemem(peakmem%)
ENDIF
cwert=@freemem(cwert)
merkfrei=@freemem(merkfrei)
mdatf=@freemem(mdatf)
IF big=0 AND anfloadx>0 THEN
anfloadx=@freemem(anfloadx)
ENDIF
'
beep=@freemem(beep)
peakmem2%=@freemem(peakmem2%)
recmem%=@freemem(recmem%)
ptest=@freemem(ptest)
cpstart=@freemem(cpstart)
'
IF EXIST(virt$) THEN
KILL virt$
ENDIF
IF EXIST(virt2$) THEN
KILL virt2$
ENDIF
CLOSE
RETURN
'
> PROCEDURE fehler
.| Glob. Var.: g#
.| Ruft auf  : goodbye
.| Aufruf in : HAUPTPROGRAMM-1,
@alerts(50)
IF g=1 THEN
RESUME NEXT
ELSE
@goodbye
ENDIF
RETURN
'
'
' ENDE
