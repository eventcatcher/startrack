$m100000
$e$
'
debug=TRUE
'
' Voraussetzungen:
' 1. Der STARTRAK Ordner muss auf einem beliebigen Laufwerk im Rootverzeichnis vorhanden sein. Dort liegt der Sourcecode.
' Wichtig: In diesem Verzeichnis muss ebenfalls die unberÅhrte, also noch nicht registrierte STARTRAK.PRG liegen, und u.a. die beiden
' unverÑnderten RSC Dateien STARMONO.RSC und STARCOLR.RSC.
' FÅr die Registrierung wird die PRG angepasst, sowie die 2 RSC Dateien die den Infodialog enthalten: STARMONO.RSC und STARCOLR.RSC
' 2. Innerhalb des STARTRAK Ordners muss ein weiterer STARTRAK Ordner angelegt werden. In diesen werden durch dieses Make-Programm die
' verÑnderten Dateien gespeichert, welche dann bereits die Registrierungsinformationen enthalten.
' 3. Im Hauptverzeichnis muss eine LHARCGER.TTP liegen, damit die Dateien automatisch gepackt werden kînnen.
' 4. Bei der Eingabe der Adressinformationen ist darauf zu achten, dass die LÑnderkennung mit Bindestrich vorhanden ist. (z.B. "D-")
' Andernfalls lÑuft das Makeprogramm nicht und kann nur durch klick auf den Exit-Button beendet werden.
' 5. Das Makeprogramm muss als Compilat laufen, da sonst die Pfade nicht korrekt gefunden werden!
' 6. Wenn man debug=true setzt, dann bekommt man bei der AusfÅhrung die Pfade und weitere wertvolle Informationen zur Fehlersuche angezeigt.
'
'
dsk$="A:\"                     ! Diskettenlaufwerk
l$=""                          ! Arbeitslaufwerk (z.B. D:\,""=aktueller Startpfad)
fold$="STARTRAK"               ! zu packender ZielOrdner (Haupdir-Pfadangabe,z.B. "STARTRAK" = Pfad: X:\STARTRAK\*.*)
lzh$="STARTRAK"                ! Name des LZH-Files  (z.B. STARTRAK = STARTRAK.LZH)
d1$="INSTALL\DISK1\"           ! LZH-Zielpfad        (z.B. INSTALL\DISK1\ = X:\INSTALL\DISK1\)
d2$="INSTALL\DISK2\"           ! Helpsys-Pfad des LZH
lh$="LHARCGER.TTP"             ! Packerpfad          (z.B. LHARCGER.TTP = X:\LHARCGER.TTP)
rsc1$="STARCOLR.RSC"           ! kopiere Datei1 aus Hauptdir in Ordner fold$
rsc2$="STARMONO.RSC"           ! kopiere Datei2 aus Hauptdir in Ordner fold$
rsc3$="STARTRAK.PRG"           ! kopiere Datei3 aus Hauptdir in Ordner fold$
starset$="STARTRK.SET"         ! lîsche Datei STARTRK.SET aus LZH-File
help$="STARHELP.LZH"           ! Name des Hilfesystem-LZH
inf$="INSTALL.INF"             ! Name des Install-Infofile
sn$="STARMAKE.INF"             ! Seriennummer-Datei
nul=2000000000                 ! Seriennummern-Basis
'
'
starversion$="V2.00 / "+DATE$
'
'
reg0$="REGISTRIERT AUF:"
reg4$=STR$(nul)
reg5$="Dies ist eine Raubkopie !!!"
reg6$="STARTRACK "+starversion$+" BY SWE,S.WILHELM"
'
'
key:
DATA 4,63,12,55,2,66,112,75,23,36,68,93,88,13,113,136,41,39,99,85,49,17,89,54,89,92,52,75,91,67,34,63,89,48,36,1,77,118,19,70
key2:
DATA 14,23,52,15,52,86,12,85,23,66,98,13,38,15,109,114,25,88,92,81,46,11,81,51,66,42,22,85,101,17,24,69,12,55,70,14,17,48,119,18
DATA 14,23,52,15,52,86,12,85,23,66,98,13,38,15,109,114,25,88,92,81,46,11,81,51,66,42,22,85,101,17,24,69,12,55,70,14,17,48,119,18
key3:
DATA 44,45,24,102,8,12,9,78,86,33,11,93,37,28,19,69,26,56,102,34,65,72,71,22,82,12,82,79,21,47,12
'
'
gemvers=GEMDOS(48)
language=1
dreidim=TRUE
DIM sers!(10000)
'
'
' StarTrack-Serialisierer
'
compile=BYTE{ADD(BASEPAGE,256)}<>96
xwidth=WORK_OUT(0)+1
ywidth=WORK_OUT(1)+1
INLINE m_busy%,592
m_adr%=m_busy%
'
' ------------------------------------------------------------------------------
' ------------------------RSC-VARIABLEN-----------------------------------------
' ------------------------------------------------------------------------------
REM Resource Datei Indizes fÅr COPYRIGT
'
LET main&=0 ! Formular/Dialog
LET mainbox&=0 ! BOX in Baum MAIN
LET mainok&=1 ! BUTTON in Baum MAIN
LET name&=3 ! FBOXTEXT in Baum MAIN
LET street&=8 ! FBOXTEXT in Baum MAIN
LET state&=9 ! FBOXTEXT in Baum MAIN
LET serial&=10 ! FBOXTEXT in Baum MAIN
LET version&=12 ! FBOXTEXT in Baum MAIN
LET mainex&=14 ! BUTTON in Baum MAIN
LET getser1&=15 ! BUTTON in Baum MAIN
LET getser2&=16 ! BUTTON in Baum MAIN
'
LET alertbox&=1 ! Formular/Dialog
LET alertcol&=0 ! BOX in Baum ALERTBOX
'
'
LET blkfunc&=2 ! Dialog in starcolor/starmono
LET sernr&=35 !  seriennummer
'
OPTION BASE 0
IF compile=FALSE THEN
  RESERVE 500000
ENDIF
'
maxcol=WORK_OUT(13)
'
'
' ------------------------------------------------------------------------------
' ------------------------RSC LADEN---------------------------------------------
' ------------------------------------------------------------------------------
DEFMOUSE 0
KEYPAD 0                    ! wg KompatibilitÑt (normale Tastatureinstellung)
'
btree=alertbox&                      ! Anzahl der BÑume-1
popup&=0
@rsc_init
'
mtype=INT(C:rsc_cookie%(L:CVL("_MCH"))/&H10000)          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
magicmac=INT(C:rsc_cookie%(L:CVL("MgMc")))          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
magix=INT(C:rsc_cookie%(L:CVL("MagX")))          ! COOKIE-ABFRAGE MagiC
pci=INT(C:rsc_cookie%(L:CVL("_PCI")))          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
'
rscda=@rsc_holen(btree,0,0,btree)  ! File$,Trees,Popup,Menu,Alert
'
IF rscda=TRUE THEN
  IF maxcol=2 THEN
    @colorbox(main&,mainbox&,0,7)
    @colorbox(alertbox&,alertcol&,0,7)
  ENDIF
ENDIF
'
' ---------------------------.ACC-Abfrage---------------------------------------
'
IF rscda=TRUE THEN
  @workit
  END
ELSE
  @goodbye
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------FLYDIALS--------------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE key
  .| Glob. Var.: key&,edit_obj&,cont&,rsc_adr%,next_obj&,idx&,obj&,mrkhandle2#
  .|     v1#,v2#,v3#,ascii|,scan|,a#,shift&,title&,shcut#,nob#,nr#,keytab%,a&
  .|     a$,tree&,evnt&,mb&,mx&,my&
  .| Felder    : rsc_adr%()
  .| Ruft auf  : form_keybd,rsc_shortcut
  .| Aufruf in : rsc_do-1,
  LOCAL bs
  ' Mîchten Sie erweiterte Tastaturkommandos? Dann entREMen Sie
  ' diese Zeile und ersetzen die Prozedur durch:
  '  IF key& AND edit_obj&<>0     ! vorher so....
  IF (key& AND edit_obj&<>0) OR (((key& AND 255)=13) AND ((key& DIV 256)<>50))    ! jetzt so....
    cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  ENDIF
  '
  obj&=0
  ~WIND_GET(MENU(4),10,mrkhandle2,v1,v2,v3)
  '
  ascii|=BYTE(key&)                                  ! ASCII-Code
  scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
  shcut=FALSE
  '
  rsc_adr%=rsc_adr%(nr)
  IF ascii|=0                                        ! Kein ASCII-Code...
    '
    IF scan|=97 OR scan|=98                          ! UNDO/HELP...
      ascii|=ADD(SUB(scan|,97),14)
      mb&=0
      obj&=0
      '
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
      '
      IF BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE IF scan|>=59 AND scan|<=68                  ! F-Tasten...
      ascii|=SUB(scan|,58)
      obj&=0
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
      IF SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE                                             ! ALT+Buchstabe...
      '
      IF scan|>=120 AND scan|<=129                   ! Zahlen...
        SUB scan|,118
        keytab%={XBIOS(16,L:-1,L:-1,L:-1)}           ! ...ohne Shift
      ELSE                                           ! Alles andere...
        keytab%={ADD(XBIOS(16,L:-1,L:-1,L:-1),4)}    ! ...mit Shift
      ENDIF
      '
      ascii|=BYTE{ADD(keytab%,scan|)}                ! ASCII-Code holen
      IF ascii|<>0                                      ! Tastaturbedienbar...
        CLR a&,obj&
        '
        DO WHILE NOT BTST(OB_FLAGS(rsc_adr%,obj&),5) ! Nicht LASTOBJ
          INC obj&
          '
          scan|=BYTE(SHR(OB_TYPE(rsc_adr%,obj&),8))
          IF scan|=26 OR scan|=28                    ! Ein Button/String...
            a$=@rsc_text$(tree&,obj&)                ! ...Text
            '
            a&=INSTR(a$,"[")
            IF a&                                    ! Tastaturbedienbar...
              a&=ASC(MID$(a$,SUCC(a&),1))
              a&=(BCLR(a&,5)=ascii|) OR (a&>=48 AND a&<=57 AND a&=ascii|)
            ENDIF
            '                                        ! '[' vor Zeichen
          ENDIF
          '
        LOOP UNTIL a&                                ! ...gefunden
        '
        IF a&                                        ! Objekt gefunden...
          key&=0                                     ! ...keine Eingabe mehr
          mb&=0
          '                                          ! +SHIFT Circle-Butt?
          IF BTST(shift&,1) AND BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5) AND SHR(OB_TYPE(rsc_adr%,obj&+2),8)=27
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simulieren
            ~OBJC_OFFSET(rsc_adr%,obj&+2,mx&,my&)
            '                                        ! Ist es ein Popup...
          ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5)
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simul.
            ~OBJC_OFFSET(rsc_adr%,obj&,mx&,my&)
          ELSE                                       ! ...Button bedienen
            cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
          ENDIF
        ENDIF
        '
      ENDIF
    ENDIF
    '
  ENDIF
  '
  IF next_obj&<>0 AND edit_obj&<>next_obj&
    ~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,3,idx&)  ! ...Eingabe
  ENDIF
  '  obj=obj&
  '
RETURN
> PROCEDURE message
  .| Glob. Var.: handle&,a&,rsc_trees&,accwindopen#,tree&,rsc_window&
  .|     next_obj&,edit_obj&,idx&,nr#,peak&,peakint#,mx#,my#,mz#,rsc_adr%,n#
  .|     butdirect#,butnr#,donr#,h#,a#,smpedit&,mnr#,cs#,ce#
  .| Felder    : rsc_handle%(),rsc_adr%()
  .| Ruft auf  : markhlp,rsc_message,mouse,button,rsc_redraw_obj,curve
  .|     markprod3
  .| Aufruf in : rsc_do-1,helptxt-2,
  LOCAL iz
  handle&=MENU(4)                                    ! ...Fenster-Handle
  '
  FOR a&=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
    EXIT IF handle&=rsc_handle%(a&)
  NEXT a&
  '
  '  IF handle&=rsc_handle%(a&) THEN
  '  mywindow=TRUE
  '  wind_active=a&
  ' ELSE
  '  mywindow=FALSE
  '  wind_active=0
  ' ENDIF
  '
  IF MENU(1)=&H4724 THEN
    accwindopen=TRUE
  ENDIF
  IF MENU(1)=41 OR (MENU(1)=22 AND tree&=a&)         ! AC_CLOSE/Closer...
    MUL rsc_window&,-(MENU(1)=22)
    '
    next_obj&=9999                                   ! ...Exit-Code
    '
    GOTO rsc_dox_ende                                ! ...rsc_do verlassen
    '
  ELSE IF a&>-1 AND NOT (MENU(1)=21 AND a&<>tree&)   ! Ein RSC-Fenster....
    rsc_message(a&,MENU(1),MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    '
  ELSE IF MENU(1)=40 OR MENU(1)=21                   ! AC_OPEN/Anderes Fenster toppen...
    '
    IF a&<>-1 THEN
      IF handle&=rsc_handle%(a&) THEN
        tree&=a&
        nr=tree&
        @mouse(mx,my,mz)
        rsc_adr%=rsc_adr%(tree&)
        n=OBJC_FIND(rsc_adr%,0,100,mx,my)
        IF n<>0 AND n<>-1 THEN
          @button
          butdirect=TRUE
          butnr=donr
        ENDIF
      ENDIF
    ENDIF
    rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
  ELSE IF MENU(1)<>21 AND MENU(1)<>22                ! nicht toppen/schlieûen...
  ELSE                                               ! Nichts zu machen...
    ~BIOS(3,2,7)
  ENDIF
  IF MENU(1)=20 THEN
    h=MENU(4)                                    ! ...Fenster-Handle
    FOR a=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
      EXIT IF h=rsc_handle%(a)
    NEXT a
    ha1=h
  ENDIF
rsc_dox_ende:
RETURN
> PROCEDURE button
  .| Glob. Var.: mrkhandle2#,mx&,my&,rsc_adr%,nr#,next_obj&,fsel&,fssldbut&
  .|     fsslide&,fsmax#,fsz#,slflg#,arranger&,arrslbut&,arrslide&,slmax#,pbz#
  .|     trakker&,trakxbut&,trakslid&,tmax#,trakkz#,trakybut&,trkvslid&,tymax#
  .|     trakkyz#,virtual&,vslbut&,vslider&,hbg#,hbz#,vhbldstrt#,smplen#,zu%
  .|     edit_obj&,idx&,vblkstrt&,a$,slr#,hbgm#,mt#,vslc#,lslide#,smpedit&
  .|     zoombutt&,mrz#,zoomp#,mrcs#,cs#,mrce#,ce#,zomslide&,zmax#,mrzoom#
  .|     scrlslde&,scrolbut&,scmax#,scrollp#,mrscroll#,scteil#,scrolm#,vmem#
  .|     cached#,scstep#,peak&,cont&,tree&,evnt&,obj&,ob_tail&,rsc_popup&,b$
  .|     popup&,rate&,digana#,mover&,input&,source&,dsp&,rate2&,smp16&
  .|     makerate&,arrmake&,make&,mb&,editfade&,peakmute&,arrm1&,arrm2&,arrm3&
  .|     arrm4&,arrclip&,leave#,v#,v2#,v3#,v4#
  .| Felder    : rsc_adr%(),rscx&(),rscy&(),rscw&(),rsch&()
  .| Ruft auf  : sliding,fsnrset,setbutton,slideupdate,arrnrset,timeline
  .|     blkart,slidelr,textbutt,zoomcalc,scrollinit,setslide,restaura
  .|     rsc_movedial,rsc_text,rsc_popup,rsc_set_cursor,edhandler2
  .| Aufruf in : message-1,rsc_do-2,
  LOCAL popok,dif
  leave=FALSE
  mrkhandle2=WIND_FIND(mx&,my&)
  '  IF mrkhandle=mrkhandle2 THEN
  '  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
  '  IF v<>0 AND kenn=mrkhandle2 THEN
  rsc_adr%=rsc_adr%(nr)
  next_obj&=OBJC_FIND(rsc_adr%,0,100,mx&,my&)
  '
  '                                                  ! String vor Popup...
  IF next_obj&>0
    IF BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND SHR(OB_TYPE(rsc_adr%,next_obj&),8)=28 AND BTST(OB_STATE(rsc_adr%,SUCC(next_obj&)),5)
      ' (TOUCHEXIT, STRING, SUCC: SHADOWED)
      INC next_obj&
    ENDIF
  ENDIF
  '
  IF next_obj&=-1                                    ! Neben die Box...
    IF rsc_mtsk!=FALSE THEN
      SOUND 1,15,10,4,10
      SOUND 0,0,0,0,0
    ENDIF
    next_obj&=0
  ELSE
    '
    cont&=FORM_BUTTON(rsc_adr%,next_obj&,1,next_obj&)
    ' ------------------------------------------------ Flydial-Ecke
    IF BTST(OB_STATE(rsc_adr%,next_obj&),1)          ! (CROSSED)
      rsc_movedial(tree&,edit_obj&,idx&)             ! ...Dialog verschieben
      '
      next_obj&=0                                    ! Damit der Cursor..
      cont&=1                                        ! ..bleibt wo er ist
      ' ---------------------------------------------- Circle-Button...
    ELSE IF SHR(OB_TYPE(rsc_adr%,next_obj&),8)=27 AND BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),5) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),3))
      ' (G_BOXCHAR, PRED: SHADOWED /NOT DISABLED)
      '
      popok2=TRUE
      IF popok2=TRUE THEN
        next_obj&=PRED(next_obj&)                      ! Objektnr. Button
        a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
        evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
        '
        obj&=1
        FOR ob_tail&=1 TO PRED(evnt&)
          obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
        NEXT ob_tail&
        '
        evnt&=SUCC(obj&)
        b$=@rsc_text$(rsc_popup&,evnt&)
        DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
          INC evnt&                                    ! Defaulteintrag
        LOOP
        '
        REPEAT
          INC evnt&                                    ! NÑchster Eintrag...
          IF evnt&>OB_TAIL(rsc_adr%(rsc_popup&),obj&)  ! ...gibt es nicht
            evnt&=SUCC(obj&)                           ! ...dann wieder 1.
          ENDIF
          '                                            ! bis nicht DISABLED
        UNTIL NOT BTST(OB_STATE(rsc_adr%(rsc_popup&),evnt&),3)
        '                                              ! Button Ñndern...
        rsc_text(tree&,next_obj&,@rsc_text$(rsc_popup&,evnt&))
        ~OBJC_DRAW(rsc_adr%,next_obj&,1,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
        popup&=SUB(evnt&,obj&)
        '          REPEAT
        '          ~GRAF_MKSTATE(v,v2,v3,v4)
        '        UNTIL v3=0
        ' ---------------------------------------------- Popup-Menue...
      ENDIF
    ELSE IF BTST(OB_STATE(rsc_adr%,next_obj&),5) AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND (NOT BTST(OB_STATE(rsc_adr%,next_obj&),3))
      popok=FALSE
      IF popok=TRUE THEN
        ' (SHADOWED, TOUCHEXIT, NOT DISABLED)
        evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
        obj&=1
        FOR ob_tail&=1 TO PRED(evnt&)
          obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
        NEXT ob_tail&
        ob_tail&=OB_TAIL(rsc_adr%(rsc_popup&),obj&)
        a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
        evnt&=SUCC(obj&)
        DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
          INC evnt&                                    ! Ausrichtung ermitteln
        LOOP UNTIL evnt&>ob_tail&
        '
        IF evnt&<=ob_tail&                             ! Defaulteintrag...
          popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,SUB(evnt&,SUCC(obj&)))
        ELSE                                           ! Sonst ohne...
          IF tree&=smpedit& OR tree&=make& THEN
            popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,1)
          ENDIF
        ENDIF
        IF popup&=0                                    ! Abbruch...
          cont&=1                                      ! ...weiter geht's
          next_obj&=0                                  ! ...Cursor 'festhalten'
        ENDIF
      ENDIF
      ' ---------------------------------------------- Cursor positionieren
      ' Mîchten Sie den Cursor mit der Maus zeichengenau positionieren?
      ' Dann entREMen Sie diese Zeilen und laden diese Prozedur nach:
    ELSE IF BTST(OB_FLAGS(rsc_adr%,next_obj&),3)
      @rsc_set_cursor(rsc_adr%,mx&,my&,edit_obj&,next_obj&,idx&)
    ENDIF
    '
  ENDIF
  IF cont&=0 OR (next_obj&<>0 AND next_obj&<>edit_obj&)
    ~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
  ENDIF
  ' ENDIF
  ' ENDIF
  REPEAT
    ~GRAF_MKSTATE(v,v2,v3,v4)        ! NEU !!!
  UNTIL v3=0 OR leave=TRUE
  IF next_obj&=0 THEN
    next_obj&=-1
  ENDIF
RETURN
> PROCEDURE rsc_init
  .| Glob. Var.: ap_id&,rsc_aes&,rsc_mtsk!,rsc_alert&,wchar&,hchar&,rsc_vh&
  .|     planes&,deskx&,desky&,deskw&,deskh&,rsc_flyd%,rsc_bitblt%,rsc_obspec%
  .|     rsc_cookie%
  .| Felder    : rsc_adr%()
  .| Aufruf in : HAUPTPROGRAMM-1,
  LOCAL a&
  '
  ' Initialisiert die von den RSC-Routinen benîtigten Variablen...
  '
  ap_id&=APPL_INIT()                         ! Applikations-ID
  '
  rsc_aes&=INT{{ADD(GB,4)}}                  ! AES-Version
  rsc_mtsk!=INT{ADD({ADD(GB,4)},2)}<>1       ! Multitasking?
  rsc_alert&=-1                              ! Noch keine fliegenden Alerts
  '
  CONTRL(6)=GRAF_HANDLE(wchar&,hchar&,a&,a&) ! AES-Handle, Zeichenbreite/Hîhe
  rsc_vh&=V_OPNVWK(1)                        ! Virt.Workst. fÅr Flydials îffnen
  IF rsc_vh&=0
    rsc_vh&=V~H                              ! ...Fehler, dann eben die alte
  ENDIF
  CONTRL(6)=V~H
  '
  INTIN(0)=1
  VDISYS 102,1,0
  planes&=INTOUT(4)                          ! Bitplanes
  '
  ~WIND_GET(0,7,deskx&,desky&,deskw&,deskh&) ! Hintergrundfenster
  ' ------------------------------------------------------ Inline vorbereiten
  INLINE rsc_flyd%,3090
  '
  rsc_bitblt%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,16)})      ! BITBLT-Routine
  rsc_obspec%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,18)})      ! OB_SPEC-Routine...
  rsc_cookie%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,20)})      ! COOKIE-Routine...
  '
  {ADD(rsc_flyd%,22)}=ADD(GB,24)                         ! VDI-Parameterblock
  INT{ADD(rsc_flyd%,26)}=rsc_vh&                         ! Virt. Workstation
  INT{ADD(rsc_flyd%,28)}=wchar&                          ! Zeichenzellenbreite
  INT{ADD(rsc_flyd%,30)}=hchar&                          ! Zeichenzellenhîhe
  ' ------------------------------------------------------
  ' Berechnet den Speicherbedarf einer Bitmap-Grafik...
  DEFFN getsize(w&,h&)=SHL(SHR(ADD(MUL(MUL(SHR(ADD(w&,15),3),h&),planes&),255),8),8)
  '
  ' GegenstÅck zur Prozedur rsc_text: Universelles Objekt-Text auslesen...
  DEFFN rsc_text$(tree&,obj&)=CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}
  '
RETURN
> PROCEDURE rsc_exit
  .| Glob. Var.: rsc_vh&,popup_back%,rsc_userblk%
  .| Aufruf in : goodbye-1,
  '
  CONTRL(6)=rsc_vh&
  VDISYS 38,0,0                              ! vqt_attributes
  IF ABS(INTOUT(0))<>1                       ! Anderer AES-Zeichensatz (MTOS)...
    ~VST_UNLOAD_FONTS(0)                     ! ...freigeben
  ENDIF
  '
  IF rsc_vh&<>V~H                            ! Flydial-Workstation freigeben...
    ~V_CLSVWK()
  ENDIF
  '
  ' Die folgenden Zeilen sind nur im Interpreter relevant und kînnen im
  ' Compilat wegfallen. Tip: Mit dem ERGO!pro-PrÑprozessor ausblenden.
  '
  ~RSRC_FREE()                               ! Resource entfernen
  '
  IF popup_back%
    ~MFREE(popup_back%)                      ! Popup-Hintergrund freigeben
  ENDIF
  '
  IF rsc_userblk%
    ~MFREE(rsc_userblk%)                     ! Userblks freigeben
  ENDIF
  '
RETURN
> FUNCTION rsc_walk_tree(trees&)
$F%
.| Glob. Var.: rsc_userblk%,hchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_instal_userdef
.| Aufruf in : rsc_laden-1,
LOCAL a&,b&,userblk&,tree&,obj&,a%
'
' RSC-Baum durchgehen und userdefs installieren...
'
' ------------------------------------------------------ Userdefs ermitteln
FOR tree&=0 TO trees&
  '
  obj&=-1
  '
  REPEAT
    '
    INC obj&
    '
    a&=SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)           ! Es ist ein userdef...
    ADD userblk&,-AND(a&>=17,a&<=22)
    '
  UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! ...bis LAST_OBJ
  '
NEXT tree&
'
rsc_userblk%=@malloc(SHL(SUCC(userblk&),3),7)             ! Userblks(+1) anfordern (*8)
IF rsc_userblk%=0                                      ! Zu wenig Speicher...
  RETURN FALSE                                         ! ...Error!
ENDIF
a%=rsc_userblk%                                        ! Merken
' ------------------------------------------------------ ObjektbÑume modifiz.
FOR tree&=0 TO trees&
  '
  obj&=-1
  REPEAT
    '
    INC obj&
    '
    SELECT SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)       ! OB_TYPE
      ' ------------------------------------------------ Flydial-Ecke...
    CASE 17
      rsc_instal_userdef(tree&,obj&,5)
      ' ------------------------------------------------ Button/String...
    CASE 18
      '
      a&=OB_FLAGS(rsc_adr%(tree&),obj&)                ! OB_FLAGS
      b&=BYTE(OB_TYPE(rsc_adr%(tree&),obj&))           ! Alter OB_TYPE
      '
      IF BTST(a&,4)                                    ! Radiobutton...
        rsc_instal_userdef(tree&,obj&,1)
        '                                              ! BUTTON, nicht EXIT
      ELSE IF b&=26 AND (NOT BTST(a&,2))               ! Checkbutton...
        rsc_instal_userdef(tree&,obj&,2)
        '
      ELSE                                             ! Normale EXIT-Buttons...
        '
        IF b&<>28                                      ! Kein STRING...
          a&=SUCC(-BTST(a&,1)-BTST(a&,2)-BTST(a&,6))
          IF a&>1 !EXIT       DEFAULT    TOUCHEXIT
            OB_X(rsc_adr%(tree&),obj&)=SUB(OB_X(rsc_adr%(tree&),obj&),a&)
            OB_Y(rsc_adr%(tree&),obj&)=SUB(OB_Y(rsc_adr%(tree&),obj&),a&)
            OB_W(rsc_adr%(tree&),obj&)=ADD(OB_W(rsc_adr%(tree&),obj&),ADD(a&,a&))
            OB_H(rsc_adr%(tree&),obj&)=SUCC(ADD(OB_H(rsc_adr%(tree&),obj&),ADD(a&,a&)))
          ENDIF                                        ! ...fÅr Redraw grîûer
        ENDIF
        '
        rsc_instal_userdef(tree&,obj&,6)
        '
      ENDIF
      ' ------------------------------------------------ Unterstr. Text...
    CASE 19
      rsc_instal_userdef(tree&,obj&,4)
      OB_FLAGS(rsc_adr%(tree&),obj&)=BSET(OB_FLAGS(rsc_adr%(tree&),obj&),13)
      ' ...OB_FLAG 13 setzen, wird in 'rsc_draw' benîtigt
      ' ------------------------------------------------ Rahmen...
    CASE 20
      rsc_instal_userdef(tree&,obj&,3)
      ' ------------------------------------------------ Niceline...
    CASE 21
      rsc_instal_userdef(tree&,obj&,8)
      ' ------------------------------------------------ Circlebutton...
    CASE 22
      IF hchar&=8 OR hchar&=16                         ! ...nur wenn mîglich
        rsc_instal_userdef(tree&,obj&,7)               ! ...als Bitmap
      ELSE
        OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(27,8),BYTE(OB_TYPE(rsc_adr%(tree&),obj&)))
      ENDIF                                            ! ...sonst Pfeil lassen
      '
    ENDSELECT
    '
  UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! Bis LAST_OB gesetzt
  '
NEXT tree&
'
{rsc_userblk%}=0                                       ! FÅr Nullstrings
rsc_userblk%=a%                                        ! FÅr MFREE() am Ende
'
RETURN TRUE                                            ! Alles OK
ENDFUNC
> PROCEDURE rsc_instal_userdef(tree&,obj&,nr&)
.| Glob. Var.: rsc_userblk%,rsc_flyd%
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_walk_tree-8,
'
' Userdef-Objekt installieren...
'
' nr& bezeichnet eine der folgenden Ausgaberoutinen:
' 1  Radiobutton, rund
' 2  Check-Button
' 3  Rahmen
' 4  Unterstr. Text
' 5  Flydial
' 6  Button
' 7  Circlebutton
' 8  Niceline
'
{rsc_userblk%}=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,SHL(PRED(nr&),1))})
{ADD(rsc_userblk%,4)}=OB_SPEC(rsc_adr%(tree&),obj&)
'
OB_SPEC(rsc_adr%(tree&),obj&)=rsc_userblk%             ! userdef und alter Typ
OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(BYTE(OB_TYPE(rsc_adr%(tree&),obj&)),8),24)
'                                                      ! im oberen Byte
ADD rsc_userblk%,8
'
RETURN
> PROCEDURE rsc_draw(tree&,flag%)
'  LOCAL fly&,title&,obj&,x&,y&,w&,h&,rx&,ry&,rb&,rh&,handle&,a%,rsc_adr%
'
' Stellt einen Dialog auf dem Bildschirm dar...
'
' tree&   : Index des Dialogbaumes
' flag%   : Bitbelegung
'           Bit 0 -> Fensterdialog
'           Bit 1 -> Schlieûfeld
'           Bit 2 -> Bei Fensterdialogen: Sofort zeichnen
'
'
IF flag%=0 THEN
  fly=TRUE
ELSE
  fly=FALSE
ENDIF
rsc_adr%=rsc_adr%(tree&)
' --------------------------------------------------- Titel & Flugecke suchen
DO WHILE NOT (fly&>0 AND title&>0)
  INC obj&
  IF BTST(OB_STATE(rsc_adr%,obj&),1)                ! Flugecke...
    fly&=obj&
  ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),13)          ! Dialogtitel...
    title&=obj&
  ENDIF
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
' --------------------------------------------------- Als Fenster-Dialog
IF BTST(flag%,0)
  x&=SUCC(rscx&(tree&))
  y&=ADD(ADD(rscy&(tree&),SHL(hchar&,1)),5)
  w&=SUB(rscw&(tree&),2)
  h&=SUB(SUB(rsch&(tree&),SHL(hchar&,1)),5)
  '
  IF fly&                                           ! Flugecke hidden...
    OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
  ENDIF
  '                                                 ! Rahmen: 1 Pixel auûen...
  OB_SPEC(rsc_adr%,0)=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
  '
  rx&=OR(&X1001,SHL(-BTST(flag%,1),1))              ! Ggf. Schlieûfeld
  handle&=WIND_CREATE(rx&,deskx&,desky&,deskw&,deskh&)
  '    ~WIND_SET(handle&,10,handle&,0,0,0)  ! Fenstertitel setzen
  IF handle&>0                                      ! Fenster vorhanden...
    '
    ~WIND_UPDATE(1)                                 ! BEG_UPDATE
    '
    INC rsc_window&                                 ! Anz. offene Fenster+1
    '      rsc_menu_ienable(FALSE)                         ! MenÅtitel disablen
    '
    IF title&                                       ! Dialogtitel existiert...
      a%=C:rsc_obspec%(L:rsc_adr%,title&)           ! ...Adresse des Titels
    ELSE
      a%=rsc_userblk%                               ! ...sonst Nullstring
    ENDIF
    ~WIND_SET(handle&,2,INT(SWAP(a%)),INT(a%),0,0)  ! Fenstertitel setzen
    mrkhandle=handle&
    '
    ~WIND_CALC(0,&X1001,x&,y&,w&,h&,rx&,ry&,rb&,rh&)! WC_BORDER
    ~WIND_OPEN(handle&,rx&,ry&,rb&,rh&)
    '
    rsc_handle%(tree&)=handle&
    '
    IF BTST(flag%,2)                                ! Sofort zeichnen...
      rsc_message(tree&,20,x&,y&,w&,h&,0,0)         ! ...redrawen
      REPEAT
        obj&=EVNT_MULTI(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1000)
        IF BTST(obj&,4) AND (MENU(4)<>rsc_handle%(tree&))
          '           message_auswerten(MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
        ENDIF
      UNTIL BTST(obj&,5)                            ! ...bis Timer-Event
    ENDIF
    '
    ~WIND_UPDATE(0)                                 ! END_UPDATE
    '
  ENDIF
ENDIF
' --------------------------------------------------- Als normaler Dialog
IF rsc_handle%(tree&)=0
  a%=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
  OB_SPEC(rsc_adr%,0)=OR(a%,SHL(2,16))              ! Rahmen: 2 Pixel innen
  '
  w&=rscw&(tree&)
  h&=rsch&(tree&)
  '                                                 ! Auûerhalb des Screens...
  IF rscy&(tree&)<desky& OR ADD(rscx&(tree&),PRED(w&))>ADD(deskx&,PRED(deskw&)) OR ADD(rscy&(tree&),PRED(h&))>ADD(desky&,PRED(deskh&))
    ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
  ENDIF                                             ! ...wieder in die Mitte
  '
  ~WIND_UPDATE(1)                                   ! BEG_UPDATE
  '
  rsc_list$=rsc_list$+MKI$(tree&)                   ! Dialog in die Liste aufnehmen
  '
  rsc_handle%(tree&)=@malloc(@getsize(w&,h&),7)
  IF rsc_handle%(tree&)                             ! Hintergrund retten...
    rsc_bitblt(0,0,0,rsc_handle%(tree&),w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
    '
  ENDIF
  '
  IF fly&>0 AND rsc_handle%(tree&)>0               ! Flugecke sichtbar...
    OB_FLAGS(rsc_adr%,fly&)=BCLR(OB_FLAGS(rsc_adr%,fly&),7)
  ELSE IF fly&                                     ! unsichtbar...
    OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
  ENDIF
  '                                                ! Zeichnen...
  ~OBJC_DRAW(rsc_adr%,0,9,rscx&(tree&),rscy&(tree&),w&,h&)
ENDIF
'  mrkhandle=WIND_FIND(x&,y&)
RETURN
> FUNCTION rsc_holen(trees&,popup&,menu&,alert&)
$F%
.| Glob. Var.: popup_back%,rsc_trees&,rsc_popup&,rsc_menu&,rsc_alert&
.|     rsc_aes&,rsc_vh&,dreidim#,rsc_flyd%
.| Felder    : rsc_adr%(),rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&()
.| Ruft auf  : xrsrc_load,xrsrc_gaddr,rsc_walk_tree
.| Aufruf in : HAUPTPROGRAMM-2,
LOCAL tree&,obj&,font_h&,font_id&,color3d&,a%
popup_back%=0
'
' LÑdt die Resource und initialisiert einige globale Variablen...
' ------------------------------------------------------ RSC laden
' Wollen Sie das RSC-File direkt im Programmcode 'aufbewahren'?
' Dann entREMen Sie diese Zeilen und laden Sie die Funktion
' 'rsc_conv' aus EXTENDED.LST hinzu...
INLINE rsc%,2144
IF @rsrc_conv(rsc%)=0
~FORM_ALERT(1,"[3][ | Fehler beim Laden | der RSC-Datei! | ][Abbruch]")
RETURN FALSE
ENDIF
' ------------------------------------------------------
DIM rsc_adr%(trees&),rsc_handle%(trees&)
DIM rscx&(trees&),rscy&(trees&),rscw&(trees&),rsch&(trees&)
'
rsc_trees&=trees&                                      ! Anzahl ObjektbÑume-1
rsc_popup&=popup&                                      ! Popup-Baum
rsc_menu&=menu&                                        ! Dropdown-Baum
rsc_alert&=alert&                                      ! Alert-Baum
' ------------------------------------------------------ Adressen ermitteln
FOR tree&=0 TO trees&
'
~RSRC_GADDR(0,tree&,a%)  ! Kompatibel zu den XRSRC-Routinen
rsc_adr%(tree&)=a%
IF tree&<>menu& OR menu&=0 THEN
  ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF
'
NEXT tree&
' ------------------------------------------------------ Grîûtes Popup
IF popup&>-1
obj&=1
WHILE obj&>0
  popup_back%=MAX(popup_back%,@getsize(ADD(OB_W(rsc_adr%(popup&),obj&),21),OB_H(rsc_adr%(popup&),obj&)))
  obj&=OB_NEXT(rsc_adr%(popup&),obj&)
WEND
popup_back%=@malloc(popup_back%,7)                   ! Hintergrundpuffer...
IF popup_back%=0
  RETURN FALSE                                       ! ...nicht geklappt
ENDIF
ENDIF
' ------------------------------------------------------ Anderer Zeichensatz
IF rsc_aes&>=&H400 OR APPL_FIND("?API")=0              ! Hat APPL_GETINFO()...
'
GCONTRL(0)=130
GCONTRL(1)=1
GCONTRL(2)=5
GCONTRL(3)=0
GCONTRL(4)=0
GINTIN(0)=0
'
GEMSYS                                               ! APPL_GETINFO()
'
IF GINTOUT(0)=1                                      ! Hat geklappt...
  font_h&=GINTOUT(1)                                 ! AES-Font Hîhe
  font_id&=GINTOUT(2)                                ! AES-Font ID
  '
  IF ABS(font_id&)<>1 AND GDOS?<>0                   ! Anderer AES-Font...
    V~H=rsc_vh&
    ~VST_LOAD_FONTS(0)                               ! ...Fonts laden
    DEFTEXT ,,,,font_id&
    DEFTEXT ,,,font_h&                               ! ...und einstellen
    V~H=-1
  ENDIF
ENDIF
ENDIF
' ------------------------------------------------------ 3D-Darstellung
IF rsc_aes&>=&H340                                     ! Ab AES 3.40...
GCONTRL(0)=48
GCONTRL(1)=4
GCONTRL(2)=3
GCONTRL(3)=0
GCONTRL(4)=0
'
GINTIN(0)=0                                          ! Inquire
GINTIN(1)=5                                          ! Background
'
GEMSYS                                               ! OBJC_SYSVAR()
'
IF GINTOUT(0)>0                                      ! Hat geklappt...
  color3d&=GINTOUT(1)                                ! ...3D-Farbe
ENDIF
ENDIF
IF dreidim=0 OR maxcol=2 THEN
color3d&=0
ELSE
color3d&=8
ENDIF
' ------------------------------------------------------
INT{ADD(rsc_flyd%,32)}=color3d&>0                      ! 3D-Darstellung an/aus
INT{ADD(rsc_flyd%,34)}=color3d&                        ! 3D-Farbe
' ------------------------------------------------------
IF @rsc_walk_tree(trees&)
RETURN TRUE                                          ! alles ok
ENDIF
'
RETURN FALSE                                           ! Error!
ENDFUNC
> FUNCTION rsrc_conv(r_ra%)
$F%
'     r_ra%                            ! RSC INLINE Adresse
LOCAL r_buf!                           ! TRUE=RSC Daten puffern
LOCAL r_pa%                            ! Puffer-Adresse
LOCAL r_o&,r_t&                        ! Laufvar
LOCAL r_ob&                            ! Beginn des Objekt Feldes
LOCAL r_no&                            ! Anzahl OBJECTS
LOCAL r_nt&                            ! Anzahl TREES
LOCAL r_rs&                            ! LÑnge des INLINEs
LOCAL r_napt%                          ! neue TREE Table Adresse
LOCAL r_gb%                            ! Adresse des AES Global Feldes
LOCAL r_of%                            ! Objekt Feld
LOCAL r_ns&                            ! Anzahl der freien Strings
LOCAL r_ni&                            ! Anzahl der freien Images
LOCAL r_adr%,r_i&                      ! Hilfsvar, Laufvar
'
r_buf!=(BYTE{ADD(BASEPAGE,256)}=96)    ! Im Interpreter? ==>puffern
'
r_rs&=WORD{ADD(r_ra%,&H22)}            ! LÑnge des INLINEs
IF r_buf! AND DIM?(rsc_buf|())>0       ! Ist RSC Buf schon dimensioniert?...
r_rs&=0
ENDIF
'
IF r_rs&>0
'
IF r_buf!                            ! RSC Daten puffern (nur Interpreter)...
DIM rsc_buf|(r_rs&)
r_pa%=ADD({*rsc_buf|()},4)
BMOVE r_ra%,r_pa%,r_rs&
r_ra%=r_pa%
ENDIF
'
r_napt%=ADD(r_ra%,WORD{ADD(r_ra%,&H12)})       ! neue Adresse der Tree Tabelle
r_gb%={ADD(GB,4)}                    ! Adr. des AES-GLOBAL-Feldes
{ADD(r_gb%,10)}=r_napt%              ! GLOBAL(5/6): neue Tabellen Adr.
r_ob&=WORD{ADD(r_ra%,2)}             ! bisheriger Start Objekt Feld
r_of%=ADD(r_ra%,r_ob&)               ! Neue Startadr. Objekt Feld
r_no&=PRED(WORD{ADD(r_ra%,&H14)})    ! Anzahl der Objekte im File -1
r_nt&=PRED(WORD{ADD(r_ra%,&H16)})    ! Anzahl der Trees in File  -1
'
FOR r_o&=0 TO r_no&                  ! Alle Objekte durchgehen...
~RSRC_OBFIX(r_of%,r_o&)            ! ...Koordinaten umrechnen
'
SELECT BYTE(OB_TYPE(r_of%,r_o&))   ! Objekt-Typ...
  '
CASE 21,22,29,30,31                ! ...G_TEXT,G_BOXTEXT,G_FTEXT,G_FBOXTEXT,G_ICON
  OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
  {OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
  {ADD(OB_SPEC(r_of%,r_o&),4)}=ADD({ADD(OB_SPEC(r_of%,r_o&),4)},r_ra%)
  {ADD(OB_SPEC(r_of%,r_o&),8)}=ADD({ADD(OB_SPEC(r_of%,r_o&),8)},r_ra%)
  '
CASE 24                            ! ...G_USERDEF
  OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
  {OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
  {ADD(OB_SPEC(r_of%,r_o&),4)}=ADD({ADD(OB_SPEC(r_of%,r_o&),4)},r_ra%)
  '
CASE 23                            ! ...G_IMAGE
  OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
  {OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
  '
CASE 26,28,32                      ! ...G_BUTTON,G_STRING,G_TITLE
  OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
ENDSELECT
'
NEXT r_o&
'
FOR r_t&=0 TO r_nt&
{ADD(r_napt%,MUL(4,r_t&))}=ADD({ADD(r_napt%,MUL(4,r_t&))},r_ra%)
NEXT r_t&
'
r_ns&=PRED(WORD{ADD(r_ra%,&H1E)})
IF r_ns&>-1
r_adr%=ADD(r_ra%,WORD{ADD(r_ra%,&HA)})
FOR r_i&=0 TO r_ns&
  {ADD(r_adr%,MUL(4,r_i&))}=ADD({ADD(r_adr%,MUL(4,r_i&))},r_ra%)
NEXT r_i&
ENDIF
'
r_ni&=PRED(WORD{ADD(r_ra%,&H20)})
IF r_ni&>-1
r_adr%=ADD(r_ra%,WORD{ADD(r_ra%,&H10)})
'
FOR r_i&=0 TO r_ni&
  {ADD(r_adr%,MUL(4,r_i&))}=ADD({ADD(r_adr%,MUL(4,r_i&))},r_ra%)
  {{ADD(r_adr%,MUL(4,r_i&))}}=ADD({{ADD(r_adr%,MUL(4,r_i&))}},r_ra%)
NEXT r_i&
'
ENDIF
'
ENDIF
'
RETURN r_rs&
ENDFUNC
> FUNCTION rsc_do(tree&,next_obj&,VAR popup&)
$F%
.| Glob. Var.: obj#,donr#,nr#,edit_obj&,idx&,tim&,mx&,my&,mb&,shift&,c#
.|     shcut#,winh#,smp16&,peak&,editfade&,smpedit&,digana#,xd#,xm#,ce#,cs#
.|     stay1#,stay2#,show#,showdat#,tedart#,hz#,showbdat#,shw$,showxy&
.|     butdirect#,othernr#
.| Felder    : rsc_handle%(),rsc_adr%()
.| Ruft auf  : message,drop,button,key,drop2,edhandler,peakread,fadehandler
.|     maketime,edhandler3,textfeld
.| Aufruf in : rsc_alert-1,windows-1,normalize-1,fade-1,smptime-1
.|     movefrag-1,smpsave-1,blklfrag-1,newfsel-1,sampleinf-1,resample-1
.|     arrsmpr-1,arrdelay-1,arrmname-1,virtual-1,abackup-1,time_edit-1
.|     make-1,setupdat-1,conspace-1,midi-1,
LOCAL a&,handle&,a$,c
LOCAL cont&,ob_tail&,obj&,flags&,rsc_adr%,keytab%
LOCAL ascii|,scan|,evnt&,mc&,key&
'
' Dialog auswerten...
'
obj=0
donr=nr
'
~WIND_UPDATE(1)                                      ! ...BEG_UPDATE
~WIND_UPDATE(3)                                      ! ...BEG_MCTRL
flags&=&X100011                                      ! ...zus. MESSAGE-Events
'
rsc_adr%=rsc_adr%(tree&)
cont&=TRUE
' ------------------------------------------------------ Editierbares Objekt
DO WHILE (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3)) OR BTST(OB_STATE(rsc_adr%,next_obj&),3)
INC next_obj&
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,next_obj&),5)
IF BTST(OB_FLAGS(rsc_adr%,next_obj&),5) AND (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3))
next_obj&=0
ENDIF
' ------------------------------------------------------
'
IF cont&<>0 AND (next_obj&<>0 AND edit_obj&<>next_obj&)             ! Ggf. Cursor setzen...
edit_obj&=next_obj&                                ! ...Exit-Code zurÅck
next_obj&=0                                        ! ...'rsc_do' verlassen
~OBJC_EDIT(rsc_adr%,edit_obj&,27,idx&,1,idx&)       ! ...Cursor ein
ENDIF
'
next_obj&=0
tim&=20   ! EVENT-TIMER in msec
REPEAT
c=0
evnt&=EVNT_MULTI(flags&,2,1,1,0,0,0,0,0,0,0,0,0,0,0,tim&,mx&,my&,mb&,shift&,key&,c)
'
IF BTST(evnt&,1) THEN
@button
ENDIF
IF BTST(evnt&,0) THEN
@key
IF obj&<>0 AND mb&=1 THEN
@button
ENDIF
ENDIF
'
IF mc&=2 AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6)      ! Doppelklick auf
next_obj&=WORD(BSET(next_obj&,15))                   ! TOUCHEXIT...
ENDIF
UNTIL (next_obj&>0 OR donr<>nr)
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(0)                                      ! END_UPDATE
~WIND_UPDATE(2)                                      ! END_MCTRL
ENDIF
IF donr<>nr AND butdirect=FALSE THEN
next_obj&=0
ENDIF
othernr=FALSE
rsc_do_ende:
RETURN next_obj&
ENDFUNC
> FUNCTION rsc_popup(a!,tree&,button&,popup&,def&)
$F%
.| Glob. Var.: rsc_popup&,hchar&,popup_back%,rsc_vh&,wchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_text
.| Aufruf in : button-2,
LOCAL x&,y&,b&,h&,m!
LOCAL evnt&,mx&,my&,mb&,shift&,key&,mc&,ascii|,scan|
LOCAL obj&,old_obj&,first&,anz&
LOCAL rsc&,rsc_adr%
'
' Popup-MenÅ darstellen und auswerten...
'
' a!       : TRUE: Button verÑndern, FALSE: Nur Popup
' tree&    : Index des Dialogbaumes
' button&  : Objektnr. des betÑtigten Buttons
' popup&   : Index des Popups
' def&     : Default-Eintrag (1-x)
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~WIND_UPDATE(3)                                   ! BEG_MCTRL
'
rsc_adr%=rsc_adr%(rsc_popup&)
'
first&=OB_HEAD(rsc_adr%,popup&)                   ! erster Eintrag
anz&=SUB(OB_TAIL(rsc_adr%,popup&),first&)         ! Anzahl EintrÑge-1
' ------------------------------------------------- Popup positionieren
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)
OB_X(rsc_adr%,0)=SUB(x&,OB_X(rsc_adr%,popup&))
OB_Y(rsc_adr%,0)=MAX(ADD(hchar&,4),MIN(SUB(WORK_OUT(1),4)-OB_H(rsc_adr%,popup&),SUB(y&,MUL(def&,hchar&))))-OB_Y(rsc_adr%,popup&)
'
x&=ADD(OB_X(rsc_adr%,0),PRED(OB_X(rsc_adr%,popup&)))
y&=ADD(OB_Y(rsc_adr%,0),PRED(OB_Y(rsc_adr%,popup&)))
b&=ADD(OB_W(rsc_adr%,popup&),4)
h&=ADD(OB_H(rsc_adr%,popup&),4)
' -------------------------------------------------
'
rsc_bitblt(0,0,0,popup_back%,b&,h&,x&,y&,b&,h&,0,0)
'
~OBJC_DRAW(rsc_adr%,0,7,x&,y&,b&,h&)              ! Popup zeichnen
'
IF a!                                             ! Button verÑndern...
'
~GRAF_MOUSE(256,0)                              ! Hidem
V~H=rsc_vh&                                     ! ...Default-Eintrag mit...
GRAPHMODE 2
'
INTIN(0)=8                                      ! ...HÑkchen versehen
PTSIN(0)=ADD(x&,DIV(wchar&,2))
PTSIN(1)=y&-DIV(hchar&,6)+MUL(SUCC(def&),hchar&)
VDISYS 8,1,1                                    ! ...v_gtext()
'
GRAPHMODE 1
V~H=-1
~GRAF_MOUSE(257,0)                              ! Showm
'
ENDIF
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)      ! Objekt unter der Maus...
'
IF obj&<=0                                        ! Daneben...
obj&=ADD(first&,def&)                           ! ...Default-Eintrag nehmen
ENDIF
'
old_obj&=obj&
IF (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))   ! Nicht disabled...
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
ENDIF                                             ! ...selektieren
'
~EVNT_TIMER(200)
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
IF mb&=1
m!=TRUE
evnt&=4
ENDIF
'
' --------------------------------------------------
DO
'
IF NOT m!
evnt&=EVNT_MULTI(&X111,1,1,1,1,mx&,my&,1,1,0,0,0,0,0,0,0,mx&,my&,mb&,shift&,key&,mc&)
ELSE
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
ENDIF
'
IF BTST(evnt&,0)                                 ! Tastaturereignis...
ascii|=BYTE(key&)
scan|=BYTE(SHR(key&,8))
'                                              ! Noch kein sel. Eintrag...
IF NOT (obj&>=first& AND obj&<=ADD(first&,anz&))
obj&=first&
'
ELSE IF scan|=80                               ! ...Cursor runter
INC obj&
IF obj&>ADD(first&,anz&)
obj&=first&
ENDIF
'
ELSE IF scan|=72                               ! ...Cursor runter
DEC obj&
IF obj&<first&
obj&=ADD(first&,anz&)
ENDIF
'
ENDIF
'
ENDIF
'
IF BTST(evnt&,2)                                 ! Mausereignis...
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)
ENDIF
'                                                ! Alten Eintrag deselekt...
IF obj&<>old_obj&
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),1)
ENDIF
'                                                ! Im MenÅ und nicht disabled...
IF (obj&>=first& AND obj&<=ADD(first&,anz&)) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
'                                              ! ...neuen selektieren
old_obj&=obj&
rsc&=SUB(obj&,first&)                          ! RÅckgabe
ENDIF
'
LOOP UNTIL BTST(evnt&,1) OR (mb&<>1 AND m!) OR ascii|=13 OR ascii|=27 OR scan|=97
' --------------------------------------------------
rsc_bitblt(popup_back%,b&,h&,0,0,0,0,0,b&,h&,x&,y&)! Hintergrund restaurieren
'
IF rsc&=SUB(obj&,first&) AND scan|<>97 AND ascii|<>27 ! Eintrag ausgewÑhlt...
'
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,obj&),0),0)
'
IF a!                                            ! Button verÑndern...
'                                              ! Neuen Text eintragen:
rsc_text(tree&,button&,@rsc_text$(rsc_popup&,obj&))
'
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)    ! Button zeichnen
~OBJC_DRAW(rsc_adr%(tree&),button&,1,x&,y&,OB_W(rsc_adr%(tree&),button&),OB_H(rsc_adr%(tree&),button&))
'
ENDIF
'
ELSE                                               ! Daneben => Abbruch...
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),0)
'
rsc&=-1                                          ! ...Abbruch markieren
'
ENDIF
'
REPEAT
~GRAF_MKSTATE(mx&,my&,mb&,shift&)                ! Mausknopf 'entprellen'
UNTIL mb&=0
'
~WIND_UPDATE(2)                                    ! END_MCTRL
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN SUCC(rsc&)
ENDFUNC
> PROCEDURE rsc_message(tree&,message&,x&,y&,w&,h&,edit_obj&,idx&)
.| Glob. Var.: wchar&,hchar&
.| Felder    : rsc_handle%(),rsc_adr%(),rscx&(),rscy&()
.| Ruft auf  : rsc_cursor
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,message-2,rsc_draw-1
.|     rsc_back-1,rsc_redraw_obj-1,main-1,fade-1,arranger-1,trakker-1
.|     blkfunc-1,info-1,loopwahl-1,peak-1,
LOCAL a|,ax&,ay&,ab&,ah&,handle&,obj&,rsc_adr%,a%,a$
'
' Wertet ein innerhalb des 'rsc_do' eingetroffenes Message-Ereignis aus...
'
IF nr<>smpinf& AND nr<>fsel& THEN
handle&=rsc_handle%(tree&)                         ! Fensterhandle des Dialogs
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
SELECT message&
' --------------------------------------------------------------------------
CASE 20,21                                         ! WM_REDRAW/WM_TOPPED
IF message&=20                                   ! WM_REDRAW...
~GRAF_MOUSE(256,0)                           ! Hidem
~WIND_GET(handle&,11,ax&,ay&,ab&,ah&)          ! 1. Rechteck
'
REPEAT
'
IF RC_INTERSECT(x&,y&,w&,h&,ax&,ay&,ab&,ah&) ! ...redrawen
  ~OBJC_DRAW(rsc_adr%(tree&),0,7,ax&,ay&,ab&,ah&)
ENDIF
'
~WIND_GET(handle&,12,ax&,ay&,ab&,ah&)        ! NÑchstes Rechteck...
UNTIL ab&=0 AND ah&=0                          ! ...kein Redraw mehr nîtig
'
~GRAF_MOUSE(257,0)                           ! Showm
'
ELSE                                             ! WM_TOPPED...
~WIND_SET(handle&,10,0,0,0,0)                  ! ...toppen
ENDIF
'
~WIND_GET(0,10,ax&,ay&,ay&,ay&)                  ! Oberstes Fenster...
IF ax&=handle& AND edit_obj&>0                   ! Ist das unsrige...
' ---------------------------------------------- Cursor-Setz-Orgie...
rsc_adr%=rsc_adr%(tree&)
'
obj&=edit_obj&                                 ! Parent ermitteln...
'
REPEAT
obj&=OB_NEXT(rsc_adr%,obj&)
UNTIL obj&<edit_obj&
'
~OBJC_OFFSET(rsc_adr%,edit_obj&,ax&,ay&)       ! Koordinaten des Objekts
'
a$=CHAR{{ADD(OB_SPEC(rsc_adr%,edit_obj&),4)}}  ! Maske: "Eingabe:______"
ah&=1
WHILE MID$(a$,ah&,1)<>"_"                      ! LÑnge des Vortextes...
INC ah&
WEND                                           ! ...ermitteln
'
ADD ax&,MUL(wchar&,ADD(PRED(ah&),idx&))        ! Cursor-Position im Pixeln
ah&=ADD(OB_H(rsc_adr%,edit_obj&),6)            ! Cursor ist grîûer hchar&
'                                              ! Cursor lîschen...
~OBJC_DRAW(rsc_adr%,obj&,7,ax&,SUB(ay&,3),wchar&,ah&)
rsc_cursor(rsc_adr%,edit_obj&,idx&)            ! ...und setzen
'
ENDIF
' --------------------------------------------------------------------------
CASE 28                                            ! WM_MOVED
~WIND_CALC(1,&X1001,x&,y&,w&,h&,ax&,ay&,ab&,ah&)
'
rscx&(tree&)=PRED(ax&)
rscy&(tree&)=SUB(SUB(ay&,5),MUL(hchar&,2))
OB_X(rsc_adr%(tree&),0)=ADD(rscx&(tree&),3)
OB_Y(rsc_adr%(tree&),0)=ADD(rscy&(tree&),3)
'
~WIND_SET(handle&,5,x&,y&,w&,h&)
'
ENDSELECT
'
~WIND_UPDATE(0)                                    ! END_UPDATE
'
ENDIF
RETURN
> PROCEDURE rsc_back(tree&)
.| Glob. Var.: rsc_window&,nr#,smp16&,blkfunc&,peak&,loop&,editfade&
.|     arranger&,info&,trakker&,smpedit&,edit_obj&,idx&,rsc_list$
.| Felder    : rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&(),rsc_adr%()
.| Ruft auf  : rsc_menu_ienable,rsc_message,rsc_bitblt
.| Aufruf in : rsc_alert-1,goodbye-1,normalize-1,blklfrag-1,newfsel-4
.|     restaura2-1,restaura2b-1,sampleinf-1,resample-1,make-1,conspace-1
.|     memtovirt2-1,
'
' Entfernt den Dialog vom Bildschirm...
'
' ---------------------------------------------------- Als Fenster-Dialog
fly=FALSE
IF rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
'    rsc_menu_ienable(TRUE)                             ! ...MenÅ wieder wÑhlbar
'
IF rsc_window&                                     ! Fenster existiert...
'
~WIND_CLOSE(rsc_handle%(tree&))
~WIND_DELETE(rsc_handle%(tree&))                 ! ...schlieûen & abmelden
'
DEC rsc_window&                                  ! Anz. offene Fenster-1
'
ELSE                                               ! Sonst Redraw auslîsen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF
' -------------------------------------------------- Als normaler Dialog
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
IF rsc_window&>0 THEN
'      rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
ELSE
rsc_list$=LEFT$(rsc_list$,SUB(LEN(rsc_list$),2))   ! Dialog aus der Liste entf.
'
IF rsc_handle%(tree&)                              ! Hintergrund gerettet...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~MFREE(rsc_handle%(tree&))
'
ELSE                                               ! Desktop redrawen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
IF rsc_list$<>""                                 ! Noch ein Dialog drunter...
~OBJC_DRAW(rsc_adr%(CVI(RIGHT$(rsc_list$,2))),0,7,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                            ! ...diesen auch redrawen
ENDIF
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
ENDIF
RETURN
> PROCEDURE rsc_text(tree&,obj&,a$)
.| Aufruf in : button-1,rsc_popup-1,rsc_alert-2,
'
' Universelle Objekt-Text Belegung...
'
CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}=a$
RETURN
> PROCEDURE rsc_bitblt(a%,w&,h&,b%,rb&,rh&,ax&,ay&,ab&,ah&,gx&,gy&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : rsc_draw-1,rsc_popup-2,rsc_back-1,rsc_movedial-3
.|     rsc_flipping-23,
'
' Universeller Raster-Kopierer (benutzt vro_cpyfm oder vrt_cpyfm)...
'
IF ab&>0 AND ah&>0                 ! Breite und Hîhe vorhanden...
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:a%,w&,h&,0,planes&,L:b%,rb&,rh&,0,planes&,ax&,ay&,ab&,ah&,gx&,gy&,1)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_cursor(rsc_adr%,edit_obj&,idx&)
.| Aufruf in : rsc_message-1,rsc_movedial-1,
LOCAL a|,a%
'
' Zeichengenaue Positionierung des Cursors...
'
a%=ADD({OB_SPEC(rsc_adr%,edit_obj&)},idx&)
'
a|=BYTE{a%}                                        ! Zeichen merken
BYTE{a%}=0                                         ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)       ! Cursor setzen
BYTE{a%}=a|                                        ! ...Zeichen restaurieren
'
RETURN
> FUNCTION malloc(b%,c%)
LOCAL g,a%
IF gemvers>=&H1900 THEN
a%=@mxalloc(b%,3)     ! Buffer anfordern
IF a%<=0 THEN
a%=MALLOC(b%)       ! Buffer anfordern
ENDIF
ELSE
a%=MALLOC(b%)         ! Buffer fÅr Trakker-Caches
ENDIF
IF a%<=0 THEN
IF (c% AND 3)=1 THEN
@alerts(3)
ENDIF
IF (c% AND 3)=2 THEN
@alerts(4)
ENDIF
IF (c% AND 7)=3 THEN
@alerts(5)
ENDIF
IF (c% AND 7)=7 THEN
@alerts(6)
ENDIF
IF (g=2 AND (c% AND 7)=7) OR (c% AND 4)=4 THEN
@goodbye
ENDIF
ENDIF
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION rsc_get(x&,y&,w&,h&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : fseldef-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%,b%,g
'
b%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
a%=@malloc(b%,1)         ! Buffer fÅr Trakker-Caches
'
IF a%>0 THEN                       ! Hat geklappt...
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
'                                ! Kopieren...
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> PROCEDURE rsc_put(a%,x&,y&,m&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&
'
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,0,0,w&,h&,x&,y&,m&)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
' ------------------------------------------------------------------------------
' ------------------------ENHANCED-FLYDIALS-------------------------------------
' ------------------------------------------------------------------------------
DEFFN rsc_flags(tree&,obj&,bit&)=BTST(OB_FLAGS(rsc_adr%(tree&),obj&),bit&)
DEFFN rsc_state(tree&,obj&,bit&)=BTST(OB_STATE(rsc_adr%(tree&),obj&),bit&)
> FUNCTION form_keybd(rsc_adr%,edit_obj&,key&,a&,VAR next_obj&,key_back&,idx&)
.| Ruft auf  : form_search_flag
.| Aufruf in : key-1,
' ZusÑtzliche Tastaturkommandos...
' Einfach FORM_KEYBD in 'rsc_do' durch @form_keybd ersetzen.
$F%
LOCAL scan|,cont&
'
' Ersetzt FORM_KEYBD()...
'
key_back&=0
cont&=1
'
SELECT key&
'
' ------------------------------------------------- SHIFT right
CASE &H4D36
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
' ------------------------------------------------- SHIFT left
CASE &H4B34
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
'
a&=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=0
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=a&
'
' ------------------------------------------------- Cursor runter
CASE &H5000
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
' ------------------------------------------------- Cursor rauf
CASE &H4800
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,-1)
' ------------------------------------------------- SHIFT runter/HOME
CASE &H5032,&H4737                                  ! =>letztes Feld
REPEAT
next_obj&=edit_obj&
edit_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
UNTIL edit_obj&=0
' ------------------------------------------------- SHIFT rauf, HOME
CASE &H4838,&H4700                                  ! =>erstes Feld
next_obj&=@form_search_flag(rsc_adr%,0,3,1)
' ------------------------------------------------- HELP/UNDO
CASE &H6200,&H6100
key_back&=key&
' ------------------------------------------------- Alles andere
DEFAULT
scan|=BYTE(SHR(key&,8))                           ! SCAN-Code
'
IF BYTE(key&)>0 OR scan|=75 OR scan|=77           ! Cursor rauf/runter
cont&=FORM_KEYBD(rsc_adr%,edit_obj&,key&,0,next_obj&,key&)
'                                               ! Kein Ende&TAB u. EDITABLE
IF cont&>0 AND BYTE(key&)<>9 AND BTST(OB_FLAGS(rsc_adr%,edit_obj&),3)
'
scan|=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)+8}+idx&}! Maske 'A' oder 'N'...
IF scan|=65 OR (scan|=78 AND (BYTE(key&)<48 OR BYTE(key&)>57))
key&=BCLR(key&,5)                             ! ...Groûschrift setzen
ENDIF
'
~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,2,idx&) ! ...Eingabe
ENDIF
'
ELSE
key_back&=key&
ENDIF
'
ENDSELECT
'
RETURN cont&
ENDFUNC
> FUNCTION form_search_flag(rsc_adr%,obj&,flag&,step&)
$F%
.| Aufruf in : form_keybd-4,
'
' Unterroutine fÅr form_keybd. Sucht das nÑchste/vorhergehende Objekt mit
' dem gesetzten Bit 'flag&' in OB_FLAGS...
'
' Sonderfall: Letztes Objekt ist edierbar, Cursor runter:
IF NOT (BTST(OB_FLAGS(rsc_adr%,obj&),5)=TRUE AND step&>0)
'
REPEAT
ADD obj&,step&
'
IF BTST(OB_FLAGS(rsc_adr%,obj&),flag&) AND (NOT BTST(OB_STATE(rsc_adr%,obj&),3))
RETURN obj&
ENDIF
UNTIL (obj&<=0) OR BTST(OB_FLAGS(rsc_adr%,obj&),5)
'
ENDIF
'
RETURN 0
ENDFUNC
> PROCEDURE rsc_movedial(tree&,edit_obj&,idx&)
.| Glob. Var.: deskx&,deskw&,desky&,deskh&
.| Felder    : rscw&(),rsch&(),rscx&(),rscy&(),rsc_handle%(),rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_flipping,rsc_cursor
.| Aufruf in : button-1,
' SOLID Flydials...
' Einfach die Prozedur 'rsc_movedial' ersetzen.
LOCAL x&,y&,w&,h&,fx&,fy&,mx&,my&,mb&,shift&,rsc%
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'
~GRAF_MKSTATE(mx&,my&,x&,y&)
' Nicht zusÑtzl. rechte Maustaste oder SHIFT/CONTROL/ALT...
IF NOT (x&=3 OR AND(y&,&X1111)>0)
rsc%=@malloc(@getsize(w&,h&),7)                    ! Dialog retten
ENDIF
IF rsc%                                           ! Hat geklappt...
rsc_bitblt(0,0,0,rsc%,w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
ENDIF
'
~GRAF_MOUSE(4,0)                                  ! FLAT_HAND
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
fx&=SUB(mx&,SUCC(rscx&(tree&)))                   ! Relativer Mausfaktor
fy&=SUB(my&,SUCC(rscy&(tree&)))
'
mx&=rscx&(tree&)
my&=rscy&(tree&)
' ------------------------------------------------- Bewegen
IF rsc%                                           ! SOLID...
REPEAT
'
~GRAF_MKSTATE(x&,y&,mb&,shift&)
'
x&=SUB(PRED(x&),fx&)
y&=SUB(PRED(y&),fy&)                          ! Clipping...
x&=MIN(MAX(x&,deskx&),SUB(ADD(deskx&,deskw&),w&))
y&=MIN(MAX(y&,desky&),SUB(ADD(desky&,deskh&),h&))
'
IF mx&<>x& OR my&<>y&
rsc_flipping(rsc_handle%(tree&),rsc%,mx&,my&,w&,h&,x&,y&)
mx&=x&
my&=y&
'
ENDIF
'
UNTIL mb&=0
'
~MFREE(rsc%)
'
ELSE                                              ! Nicht SOLID...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~GRAF_DRAGBOX(rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),deskx&,desky&,deskw&,deskh&,x&,y&)
ENDIF
' ------------------------------------------------- Hinsetzen
rscx&(tree&)=x&
rscy&(tree&)=y&
OB_X(rsc_adr%(tree&),0)=ADD(x&,3)
OB_Y(rsc_adr%(tree&),0)=ADD(y&,3)
'
IF rsc%=0                                         ! Nicht SOLID...
rsc_bitblt(0,0,0,rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
~OBJC_DRAW(rsc_adr%(tree&),0,10,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
'
IF edit_obj&
rsc_cursor(rsc_adr%(tree&),edit_obj&,idx&)    ! ...Cursor ein
ENDIF
ENDIF
'
~GRAF_MOUSE(0,0)
'
RETURN
> PROCEDURE rsc_flipping(rsc_back%,rsc%,ax&,ay&,w&,h&,x&,y&)
.| Ruft auf  : rsc_bitblt
.| Aufruf in : rsc_movedial-1,
LOCAL rb&,rh&,gw&,gh&
'
gw&=ABS(SUB(x&,ax&))         ! Verschiebbreite
gh&=ABS(SUB(y&,ay&))         ! Verschiebhîhe
rb&=SUB(w&,gw&)              ! Restbreite
rh&=SUB(h&,gh&)              ! Resthîhe
'
IF rb&<0 OR rh&<0            ! rsc% auûerhalb von rsc_back%
'
' Gesamten Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,h&,ax&,ay&)
'
' Gesamten Dialog aktualisieren -----
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,h&,0,0)
'
ELSE IF x&>ax&               ! nach rechts...
'
IF y&>ay&                  ! nach rechts-unten veschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,gh&,gw&,rh&,ax&,ADD(ay&,gh&))
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,gh&,ax&,ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,gh&,rb&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),rb&,gh&,0,rh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ELSE                      ! nach rechts-oben / rechts verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,gw&,rh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,0,rb&,rh&,0,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,rb&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ENDIF
'                         ! nach links / oben / unten...
ELSE IF y&>ay&              ! nach links-unten / unten verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,rb&,gh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,h&,ADD(ax&,rb&),ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,gh&,rb&,rh&,gw&,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,gw&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),w&,gh&,0,rh&)
'
ELSE                        ! nach links-oben / links / oben verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,rh&,ADD(ax&,rb&),ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,0,rb&,rh&,gw&,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,gh&),gw&,rh&,0,gh&)
'
ENDIF
'
rsc_bitblt(rsc%,w&,h&,0,0,0,0,0,w&,h&,x&,y&)
'
RETURN
> PROCEDURE rsc_set_cursor(rsc_adr%,mx&,my&,VAR edit_obj&,next_obj&,idx&)
.| Glob. Var.: wchar&
.| Aufruf in : button-1,
' Zeichengenaues Cursor-Positionieren mit der Maus...
' Nur die entsprechenden 2 Zeilen in 'rsc_do' (ziemlich am Ende) entREMen.
LOCAL x&,a&,i&,ob_spec%,a$
'
ob_spec%=OB_SPEC(rsc_adr%,next_obj&)
'
~OBJC_OFFSET(rsc_adr%,next_obj&,x&,a&)          ! Absolute X-Position
'
x&=DIV(SUB(mx&+SHR(wchar&,2),x&),wchar&)        ! Spaltenposition
'
a$=CHAR{{ADD(ob_spec%,4)}}                      ! Maske lesen
'
FOR a&=1 TO x&                                  ! Pos. im Eingabefeld...
IF MID$(a$,a&,1)="_"
INC i&                                      ! ...nur relevante
ENDIF
NEXT a&
SUB x&,(x&-i&)
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)    ! Cursor aus
'
ob_spec%=ADD({ob_spec%},x&)
'
a&=BYTE{ob_spec%}                               ! Zeichen merken
BYTE{ob_spec%}=0                                ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,next_obj&,0,idx&,1,idx&)    ! Cursor setzen
BYTE{ob_spec%}=a&                               ! ...und Zeichen restaurieren
'
edit_obj&=next_obj&
'
RETURN
> FUNCTION rsc_shortcut(tree&,scan|,shift&,VAR title&)
.| Felder    : rsc_adr%()
.| Aufruf in : key-1,
' MenÅshortcut ermitteln...
$F%
LOCAL a&,obj&,rsc_adr%,s$,t$
'
' tree&      : Index des MenÅbaumes
' scan|      : SCAN-Code der gedrÅckten Taste
' shift&     : Status der tastaturumschalttasten
' VAR title& : Bei Erfolg Objektnummer des MenÅtitels
'
SELECT scan|
CASE 2 TO 10                                   ! 1-2...
s$=CHR$(ADD(47,scan|))
CASE 15                                        ! TAB...
s$="I"
shift&=BSET(shift&,2)                        ! ...entspricht "^I"
'
CASE 59 TO 68,84 TO 93                         ! Ftasten...
IF scan|<84
s$="F"+STR$(SUB(scan|,58))                 ! ...normal
ELSE
s$="F"+STR$(SUB(scan|,83))                 ! ...mit Shift
ENDIF
CASE 71                                        ! ClrHome...
s$="CLR"
CASE 83                                        ! DELETE...
s$="DEL"
CASE 97                                        ! UNDO...
s$="UNDO"
CASE 98                                        ! HELP...
s$="HELP"
DEFAULT                                        ! Alles andere...
rsc_adr%={XBIOS(16,L:-1,L:-1,L:-1)}
s$=CHR$(BCLR(BYTE{ADD(rsc_adr%,scan|)},5))
ENDSELECT
'
IF BTST(shift&,3)                              ! Alternate...
s$=CHR$(7)+s$
ENDIF
IF BTST(shift&,2)                              ! Control...
s$="^"+s$
ENDIF
IF BTST(shift&,0) OR BTST(shift&,1)            ! Shift...
s$=CHR$(1)+s$
ENDIF
'
title&=2                                       ! Position des Titels
obj&=5                                         ! Beginn der eigentl. MenÅs
rsc_adr%=rsc_adr%(tree&)                       ! öbersichtlicher
'
REPEAT                                         ! alle Objekte d. MenÅbaums
INC obj&
'
IF BYTE(OB_TYPE(rsc_adr%,obj&))=28           ! G_STRING...
IF NOT BTST(OB_STATE(rsc_adr%,obj&),3)     ! disabled ?
'
t$=TRIM$(CHAR{OB_SPEC(rsc_adr%,obj&)})   ! MenÅpunkt-Text
'
a&=RINSTR(t$," ")
IF a&                                    ! Shortcut vorhanden ?
'
IF MID$(t$,SUCC(a&))=s$                ! hier der vermutete Shortcut
RETURN obj&                          ! gefunden
ENDIF
'
ENDIF
ENDIF
'
ELSE IF BYTE(OB_TYPE(rsc_adr%,obj&))=20      ! G_STRING ?
INC title&
ENDIF
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)          ! LAST_OB ?
'
title&=0
RETURN 0                                       ! nicht gef. oder disabled
ENDFUNC
> FUNCTION rsc_alert(icon&,text$,def&,button$)
.| Glob. Var.: rsc_alert&,wchar&,hchar&
.| Felder    : rsc_adr%(),rscw&(),rsch&(),rscx&(),rscy&()
.| Ruft auf  : rsc_text,rsc_draw,rsc_do,rsc_back
.| Aufruf in : copytoarr-1,
' Fliegende ALERT-Box...
$F%
LOCAL a&,b&,h&,i&,l&,len&,w&,x&,y&,z&,ab&,ah&,rsc&,rsc_adr%,a$,knr,kobj,rdraw
'
' Alert-Box darstellen...
'
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF rsc_alert&>-1 AND rscda=TRUE AND exerr=FALSE THEN      ! Wenn's den Baum gibt:
rsc_adr%=rsc_adr%(rsc_alert&)                               ! rsc_alert=GLOBAL
'
text$=text$+"|"
button$=button$+"|"
' ---------------------------------------------------- Icon bestimmen
OB_FLAGS(rsc_adr%,2)=BSET(OB_FLAGS(rsc_adr%,2),7)    ! Hidden...
OB_FLAGS(rsc_adr%,3)=BSET(OB_FLAGS(rsc_adr%,3),7)
OB_FLAGS(rsc_adr%,4)=BSET(OB_FLAGS(rsc_adr%,4),7)
'
OB_FLAGS(rsc_adr%,SUCC(icon&))=BCLR(OB_FLAGS(rsc_adr%,SUCC(icon&)),7)
' ---------------------------------------------------- Buttons
OB_FLAGS(rsc_adr%,10)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,10)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,11)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,11)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,12)=OR(&X100101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,12))) ! LAST_OB+EXIT+SELECT.
'                                                    ! Default-Button...
OB_FLAGS(rsc_adr%,9+def&)=BSET(OB_FLAGS(rsc_adr%,9+def&),1)
' ---------------------------------------------------- Textzeilen setzen
FOR i&=1 TO 5
a&=INSTR(text$,"|")
a$=LEFT$(text$,MIN(30,MAX(0,PRED(a&))))
IF LEN(a$)>0 THEN
a$=a$+" "
ENDIF
IF LEN(a$)>30 THEN
a$=LEFT$(a$,30)
ENDIF
text$=MID$(text$,SUCC(a&))
'
z&=MAX(z&,-i&*(a$<>""))                            ! Hîchste belegte Zeile
l&=MAX(l&,LEN(a$))                                 ! LÑngste Zeile
'
rsc_text(rsc_alert&,ADD(4,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Button-Texte setzen
FOR i&=1 TO 3
a&=INSTR(button$,"|")
a$=LEFT$(button$,MIN(10,MAX(0,PRED(a&))))
button$=MID$(button$,SUCC(a&))
'
ADD b&,-(a$<>"")                                   ! Anzahl Buttons
len&=MAX(len&,LEN(a$))                             ! LÑngster Button
'
rsc_text(rsc_alert&,ADD(9,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Dialog-Breite Ñndern
l&=MAX(l&,MUL(10,b&))                                ! Minimal-Breite
'
w&=OB_W(rsc_adr%,3)+MUL(wchar&,ADD(l&,5))
OB_W(rsc_adr%,0)=w&                                  ! Neue Breite
'
OB_X(rsc_adr%,1)=w&-PRED(OB_W(rsc_adr%,1))           ! Flydial verschieben
rscw&(rsc_alert&)=ADD(w&,6)
' ---------------------------------------------------- Dialog-Hîhe Ñndern
h&=OB_H(rsc_adr%,10)+MUL(hchar&,ADD(z&,2))
OB_H(rsc_adr%,0)=h&                                  ! Neue Hîhe
rsch&(rsc_alert&)=ADD(h&,6)
' ---------------------------------------------------- Buttons plazieren
len&=MUL(wchar&,MAX(8,SUCC(len&)))
OB_W(rsc_adr%,10)=len&                               ! Breite anpassen..
OB_W(rsc_adr%,11)=len&
OB_W(rsc_adr%,12)=len&
'
good=TRUE
SELECT b&                                            ! Anzahl Buttons...
CASE 1
OB_FLAGS(rsc_adr%,11)=BSET(OB_FLAGS(rsc_adr%,11),7)! ...hidden
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
' OB_X(rsc_adr%,10)=SHR(SUB(w&,OB_W(rsc_adr%,10)),1)
OB_X(rsc_adr%,10)=SUB(w&,OB_W(rsc_adr%,10))-2*wchar&
'
CASE 2
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
x&=w&-OB_W(rsc_adr%,11)-2*wchar&
OB_X(rsc_adr%,11)=x&
OB_X(rsc_adr%,10)=x&-OB_W(rsc_adr%,10)-wchar&
'
CASE 3
x&=w&-OB_W(rsc_adr%,12)-SHL(wchar&,1)              ! ...Mitte
OB_X(rsc_adr%,12)=x&
OB_X(rsc_adr%,11)=x&-OB_W(rsc_adr%,10)-wchar&
OB_X(rsc_adr%,10)=OB_X(rsc_adr%,11)-OB_W(rsc_adr%,10)-wchar&
'
ENDSELECT
'
y&=h&-OB_H(rsc_adr%,10)-SHR(hchar&,1)
OB_Y(rsc_adr%,10)=y&
OB_Y(rsc_adr%,11)=y&
OB_Y(rsc_adr%,12)=y&
' ---------------------------------------------------- Anzeigen
~FORM_CENTER(rsc_adr%(rsc_alert&),rscx&(rsc_alert&),rscy&(rsc_alert&),rscw&(rsc_alert&),rsch&(rsc_alert&))
'
rdraw=FALSE
knr=nr
kobj=obj
nr=alertbox&
@rsc_draw(nr,0)
rsc&=@rsc_do(nr,0,popup&)
rsc_back(nr)
nr=knr
obj=kobj
'    IF rdraw=TRUE THEN
'    @rsc_draw(nr,0)
'  ENDIF
rdraw=FALSE
' ----------------------------------------------------
OB_STATE(rsc_adr%,rsc&)=BCLR(OB_STATE(rsc_adr%,rsc&),0)! SELECTED lîschen
'
RETURN SUB(rsc&,9)                                   ! Nummer des Buttons 1-3
ELSE
' Normaler Alert...
WHILE INSTR(button$,"[")>0
button$=LEFT$(button$,PRED(INSTR(button$,"[")))+MID$(button$,SUCC(INSTR(button$,"[")))
WEND                                                   ! ...'[' rausfiltern
RETURN FORM_ALERT(def&,"["+STR$(icon&)+"]["+text$+"]["+button$+"]")
ENDIF
ENDFUNC
> PROCEDURE appl_write(id&,msg&,handle&,x&,y&,w&,h&,a$)
.| Glob. Var.: msg%,ap_id&
.| Aufruf in : helptxt-2,
' LOCAL b$
'
' Sendet eine Message an ein Programm. Dabei kann es sich auch um
' das eigene Programm handeln (id&=ap_id&), siehe 'rsc_redraw_obj'
' --------------------------------------------------
INLINE msg%,256
'
INT{msg%}=msg&                                     ! 0 Message-ID
INT{msg%+2}=ap_id&                                 ! 1 Unsere ID
INT{msg%+4}=0                                      ! 2 Keine öberlÑnge
INT{msg%+6}=handle&                                ! 3
INT{msg%+8}=x&                                     ! 4 MenÅpunkt
INT{msg%+10}=y&                                    ! 5
INT{msg%+12}=w&                                    ! 6
INT{msg%+14}=h&                                    ! 7
'
'  IF x&=0                                            ! String (z.B. fÅr VA_START)...
CHAR{msg%+16}=LEFT$(a$,240)
{msg%+6}=msg%+16
' ENDIF
'
~APPL_WRITE(id&,16,msg%)                           ! Weg damit
'
RETURN
> PROCEDURE busy_mouse
.| Glob. Var.: m_adr%,m_busy%
.| Aufruf in : HAUPTPROGRAMM-1,maschruf-1,maschruf2-1,maschinit2b-1
.|     maschruf3-1,maschruf3b-1,maschruf5-1,maschinit5b-1,maschruf5c-1
.|     maschruf6-1,maschruf8-1,maschruf8b-1,maschruf9-1,maschruf10-1
.|     maschruf11-1,maschruf12-1,maschruf13-1,maschruf16-1,maschruf17-1
.|     maschruf18b-1,maschruf18c-1,maschruf28-1,maschruf29-1,maschruf30-1
.|     maschruf31b-1,maschruf32-1,maschruf33-1,maschruf34-1,maschruf35-1
.|     maschruf36-1,maschruf37-1,maschruf38-1,fade_it-7,smpkhlp-1,smpihlp-5
.|     smpcut-3,virtmove-7,virtcopy-2,virtins-4,putpix-3,edhandler2-7
.|     smpsave-2,ldhlp-1,sampleinf-1,trakload-1,arrinsert-1,arrdelete-1
.|     hardfs-1,hardproof2-2,rettmem-1,arrload-1,arrsave-1,make-3,trash-2
.|     setload-1,setsave-1,fseldef-1,conspace-1,coninsert-4,mono-3,negate-3
.|     lrchange-3,springart-1,
' Eine Busy-Maus in der Form eines kleines Balles...
'
IF m_adr%=ADD(m_busy%,518)
m_adr%=m_busy%
'
ELSE
ADD m_adr%,74
ENDIF
'
~GRAF_MOUSE(255,m_adr%)
'
RETURN
' ------------------------------------------------------------------------------
' ------------------------RCS-Zugriffs-Routinen---------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE textfeld(txtname,txt$,versatz)
LOCAL a
~RSRC_GADDR(0,nr,zu%)
string=LPEEK(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,txtname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~FRE(0)
RETURN
'
> PROCEDURE textfeld2(txtname,txt$,versatz)
LOCAL a
~RSRC_GADDR(0,nr,zu%)
string=LPEEK(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
RETURN
'
> PROCEDURE setbutton(buttnr,buttflag)
IF buttnr<>0 THEN
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE setbutton2(buttnr,buttflag)
LOCAL buttadr,zu%
IF buttnr<>0 THEN
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
ENDIF
RETURN
'
> PROCEDURE colorbox(nrr,buttnr,col,fill)
.| Glob. Var.: zu%,buttadr#,colflag#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : HAUPTPROGRAMM-68,
~RSRC_GADDR(0,nrr,zu%)
buttadr=zu%+24*buttnr
colflag=DPEEK(buttadr+14)
colflag=(colflag AND &HFFF0)+col
colflag=(colflag AND &HFF8F)+fill*16
DPOKE buttadr+14,colflag
RETURN
'
> PROCEDURE textcolor(nrr,buttnr,col,rahmen,fill)
~RSRC_GADDR(0,nrr,zu%)
buttadr=LPEEK(zu%+24*buttnr+12)
colflag=DPEEK(buttadr+18)
colflag=(colflag AND &HF0)+col*256+rahmen*4096+fill
DPOKE buttadr+18,colflag
RETURN
'
> PROCEDURE editread(edread)
.| Glob. Var.: nr#,zu%,editadr#,erd#,a$,bv$
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-2,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkproof-1,tedproof-1,setupdat-1,setsave-1,
~RSRC_GADDR(0,nr,zu%)
editadr=zu%+24*edread+12
erd=LPEEK(LPEEK(editadr))
a$=""
WHILE PEEK(erd)<>0
bv$=CHR$(PEEK(erd))
a$=a$+bv$
erd=erd+1
WEND
RETURN
'
> PROCEDURE editfeld(edname,ed$)
.| Glob. Var.: edit_obj&,nr#,zu%,editadr#,edanf#,edz#,ef#,ap#,xwidth#
.|     ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-8,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkart-1,tedart-2,setdat-1,
edit_obj&=0
~RSRC_GADDR(0,nr,zu%)
editadr=zu%+24*edname+12
edanf=LPEEK(LPEEK(editadr))
edz=LEN(ed$)
FOR ef=1 TO edz
ap=ASC(MID$(ed$,ef,1))
POKE edanf+ef-1,ap
NEXT ef
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,edname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~FRE(0)
RETURN
'
> PROCEDURE readbutton(buttnr)
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+10)
RETURN
'
> PROCEDURE mouse(VAR mx,my,mk)
.| Aufruf in : message-1,normalize-1,fadehandler-2,markhandl4-1,arrsmpr-1
.|     dragging1-2,dragging2-2,arrmname-1,virtual-1,setupdat-1,midi-1
.|     do_peak-1,markhandler-1,
LOCAL void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx,my,mk,void&)
~WIND_UPDATE(2)
'
SUB mx,WORD{WINDTAB+64}
SUB my,WORD{WINDTAB+66}
RETURN
'
> PROCEDURE hidetree(buttnr,buttflag)
LOCAL bf
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,0    ! setbutton lîschen
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
ENDIF
RETURN
' ------------------------------------------------------------------------------
'          HardwareunabhÑngiger Teil - GEM
' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------
' ------------------------HAUPTPROGRAMM-----------------------------------------
' ------------------------------------------------------------------------------
'
> PROCEDURE helptxt(search$)        ! Hilfstexte von 1st Guide aktivieren
'
' Der Pfad der IDX-Datei muû vorher im 1stGuide Konfigurationsdialog eingegeben werden !!!
'
LOCAL g,hlpfound,t,a,hobj,vfly
msg_id=APPL_FIND("1STGUIDE")
IF msg_id<>-1 THEN
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=s$+"1STGUIDE.IDX"
ENDIF
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=op$+"1STGUIDE.IDX"
ENDIF
IF EXIST(hpath$)=FALSE THEN
hlpfound=FALSE
~GRAF_MOUSE(256,0)                              ! Hidem
ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
@fileselect(op$+"*.IDX","1STGUIDE.IDX","Search 1STGUIDE.IDX:")
@rsc_put(ab,rscx&(nr),rscy&(nr),1)
IF ordner$<>"" AND pret<>0 AND pbutt=1 THEN
hpath$=ordner$+"1STGUIDE.IDX"
IF EXIST(hpath$)=TRUE THEN
hlpfound=TRUE
ENDIF
ENDIF
ELSE
hlpfound=TRUE
ENDIF
IF hlpfound=TRUE THEN
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
normd=FALSE
IF rsc_handle%(nr)>1000                             ! Normaler Dialog...
normd=TRUE
ndnr=nr
@rsc_back(nr)
ENDIF
'
hpath$=hpath$+CHR$(0)
@appl_write(msg_id,&H4711,0,0,0,0,0,hpath$)    ! VA_START
accwindopen=FALSE
ON MENU MESSAGE GOSUB message
t=TIMER
REPEAT
ON MENU
UNTIL accwindopen=TRUE OR (TIMER-t)>400
search$=search$+CHR$(0)
a=1025
accwindopen=FALSE
@appl_write(msg_id,a,0,0,0,0,0,search$)                           ! AC_HELP
ON MENU MESSAGE GOSUB message
t=TIMER
REPEAT
ON MENU
UNTIL accwindopen=TRUE OR (TIMER-t)>400
IF normd=TRUE THEN                            ! Normaler Dialog...
nr=ndnr
@rsc_draw(nr,0)
ENDIF
ELSE
'
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
ENDIF
ELSE
'
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
@readbutton(obj)
hobj=obj
vfly=fly
fly=TRUE
edit_obj&=0
@alerts(12)
fly=vfly
obj=hobj
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
ENDIF
RETURN
'
> PROCEDURE fileselect(a$,b$,c$)
.| Glob. Var.: fs_iinpath%,fs_iinsel%,fs_iinlabel%,a#,ordner$,nam$,fil$
.| Ruft auf  : fsel_exinput
.| Aufruf in : fadesave-1,fadeload-1,smpsave-1,newfsel-3,ldhlp-1,trakload-1
.|     hardfs-1,arrload-1,arrsave-1,make-1,fseldef-1,coninsert-1,smpplay-1
.|     record3-1,
~GRAF_MOUSE(256,0)                              ! Hidem
'  ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
a$=a$+CHR$(0)+SPACE$(100)
fs_iinpath%=VARPTR(a$)
b$=b$+CHR$(0)+SPACE$(100)
fs_iinsel%=VARPTR(b$)
c$=c$+CHR$(0)+SPACE$(100)
fs_iinlabel%=VARPTR(c$)
@fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
a=INSTR(a$,CHR$(0))
a$=LEFT$(a$,a-1)
a=INSTR(b$,CHR$(0))
b$=LEFT$(b$,a-1)
a=RINSTR(a$,"\")
IF LEN(a$)=0 THEN
ordner$=""
ELSE
ordner$=LEFT$(a$,a)
ENDIF
IF LEN(b$)=0 THEN
nam$=""
fil$=""
ELSE
nam$=b$
fil$=ordner$+b$
ENDIF
RETURN
'
> PROCEDURE fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
.| Glob. Var.: pret#,pbutt#
.| Ruft auf  : ain
.| Aufruf in : fileselect-1,
LPOKE ADDRIN,fs_iinpath%
LPOKE ADDRIN+4,fs_iinsel%
LPOKE ADDRIN+8,fs_iinlabel%
@ain(91,0,2,3,0)
pret=GINTOUT(0)
pbutt=GINTOUT(1)
RETURN
'
> PROCEDURE ain(g0%,g2%,g4%,g6%,g8%)
.| Aufruf in : fsel_exinput-1,
DPOKE GCONTRL,g0%
DPOKE GCONTRL+2,g2%
DPOKE GCONTRL+4,g4%
DPOKE GCONTRL+6,g6%
DPOKE GCONTRL+8,g8%
GEMSYS
RETURN
'
> PROCEDURE errorcode
e$=ERR$(ERR)
e=INSTR(2,e$,"[")
e$=RIGHT$(e$,LEN(e$)-e)
e=INSTR(e$,"]")
e$=LEFT$(e$,e-1)
e=INSTR(e$,"|")
e2=FALSE
IF e<>0 THEN
e$=LEFT$(e$,e-1)
e2=TRUE
ENDIF
IF e2=FALSE AND LEN(e$)>28 THEN
e$=LEFT$(e$,25)+"..."
ENDIF
IF e2=TRUE THEN
IF LEN(e$)>25 THEN
e$=LEFT$(e$,25)+"..."
ELSE
e$=e$+"..."
ENDIF
ENDIF
RETURN
'
PROCEDURE alerts(alert)
LOCAL aobj,afly
aobj=obj
afly=fly
fly=TRUE
edit_obj&=0
'  @wischwasch
SELECT language
CASE 1
SELECT alert
CASE 1
g=@rsc_alert(3,"Auflîsung ist zu gering|Mindestens 320x200 nîtig !",1,"E[XIT")
CASE 3
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher !!!",1,"E[XIT")
CASE 4
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher !!!",1,"[OK")
CASE 5
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher !!!",2,"[OK|E[XIT")
CASE 6
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher|DANGER !!!",2,"[OK|E[XIT")
CASE 7
g=@rsc_alert(1,"Files wurden bereits|serialisiert !",1,"[OK")
CASE 8
g=@rsc_alert(1,"Seriennummer:"+ser$,1,"E[XIT")
CASE 9
g=@rsc_alert(3,"Audio-Treiber fehlt !",1,"E[XIT")
CASE 10
g=@rsc_alert(2,"Diskette schreiben?| |Wenn ja,bitte jetzt|leere Diskette einlegen",2,"[JA|[NEIN")
CASE 11
g=@rsc_alert(2,"Hilfesystem?",2,"[JA|[NEIN")
CASE 12
g=@rsc_alert(1,"1stGuide|ist nicht installiert|daher keine Hilfe,sorry !!!",1,"[OK")
CASE 13
g=@rsc_alert(1,"Fertig !",1,"[OK")
CASE 14
g=@rsc_alert(1,"Bitte Disk2 (Hilfesystem)|einlegen",1,"[OK")
CASE 15
g=@rsc_alert(1,"WÑhle Sprache",1,"FR[G|[UK|[FRA")
CASE 16
g=@rsc_alert(3,"Speichermedium voll !!!",1,"E[XIT")
CASE 23
g=@rsc_alert(1,"Datei nicht gefunden !",1,"E[XIT")
CASE 50
@errorcode
g=@rsc_alert(3,"Fehler aufgetaucht !!!|Fehlernummer:"+STR$(ERR)+"|"+e$+"|Weiter ?",2,"[JA|[NEIN")
CASE 99
g=@rsc_alert(2,"Programm beenden",1,"[JA|[NEIN")
ENDSELECT
CASE 2
SELECT alert
CASE 1
g=@rsc_alert(3,"screen resolution too low|minimal 320x200 necessary !",1,"E[XIT")
CASE 3
g=@rsc_alert(3,"memory overrun !|too little memory-space !!!",1,"E[XIT")
CASE 4
g=@rsc_alert(3,"memory overrun !|too little memory-space !!!",1,"[OK")
CASE 5
g=@rsc_alert(3,"memory overrun !|too little memory-space !!!",2,"[OK|E[XIT")
CASE 6
g=@rsc_alert(3,"memory overrun !|too little memory-space|DANGER !!!",2,"[OK|E[XIT")
CASE 7
g=@rsc_alert(1,"files are serialized !",1,"[OK")
CASE 8
g=@rsc_alert(1,"serial number:"+ser$,1,"E[XIT")
CASE 9
g=@rsc_alert(3,"audio-driver|is missing !",1,"E[XIT")
CASE 10
g=@rsc_alert(2,"Write to Disk?| |If yes,please insert now|a empty Disk",2,"[YES|[NO")
CASE 11
g=@rsc_alert(2,"Helpsystem?",2,"[YES|[NO")
CASE 12
g=@rsc_alert(1,"1stGuide is not installed|therefore no help,sorry !!!",1,"[OK")
CASE 13
g=@rsc_alert(1,"Successfully written !",1,"[OK")
CASE 14
g=@rsc_alert(1,"Please,insert Disk2|for Helpsystem",1,"[OK")
CASE 15
g=@rsc_alert(1,"Select language",1,"FR[G|[UK|[FRA")
CASE 16
g=@rsc_alert(3,"Disk full !!!",1,"E[XIT")
CASE 23
g=@rsc_alert(1,"file not found !",1,"E[XIT")
CASE 50
@errorcode
g=@rsc_alert(3,"error found !!!|error-number:"+STR$(ERR)+"|"+e$+"|continue ?",2,"[YES|[NO")
CASE 99
g=@rsc_alert(2,"close program",1,"[YES|[NO")
ENDSELECT
ENDSELECT
obj=aobj
fly=afly
edit_obj&=0
RETURN
'
> PROCEDURE goodbye
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
proghere=FALSE
IF acc=FALSE THEN
IF rscda=TRUE THEN
@rsc_exit
ENDIF
IF compile=FALSE THEN
RESERVE         ! Reservierung lîschen
ENDIF
ENDIF
exit=TRUE
END
RETURN
'
> PROCEDURE language
SELECT language
CASE 1 ! deutsch
CASE 2 !englisch
ENDSELECT
RETURN
'
> PROCEDURE treiberload
IF XBIOS(xbs,1)<>&H71273800 THEN
@alerts(9)
exit=TRUE
ENDIF
RETURN
'
> FUNCTION mxalloc(giveme,art)
a=GEMDOS(68,L:giveme,art)
RETURN a
ENDFUNC
'
PROCEDURE workit
d1$=l$+d1$                     ! LZH-Zielpfad
d2$=l$+d2$+help$+CHR$(0)       ! Helpsys-LZH-Pfad
lh$=l$+lh$+CHR$(0)             ! Packerpfad
r1$=rsc1$+CHR$(0)
r2$=rsc2$+CHR$(0)
r3$=rsc3$+CHR$(0)
p1$=l$+lzh$+".LZH"+CHR$(0)
p2$=d1$+lzh$+".LZH"+CHR$(0)
s1$=l$+r1$
s2$=l$+r2$
s3$=l$+r3$
f1$=l$+fold$+"\"+r1$
f2$=l$+fold$+"\"+r2$
f3$=l$+fold$+"\"+r3$
fsn$=l$+sn$+CHR$(0)
IF debug=TRUE THEN
PRINT "lzh zielpfad: "+d1$
PRINT "helpsys lzh pfad: "+d2$
PRINT "packerpfad: "+lh$
PRINT "rsc 1: "+r1$
PRINT "rsc 2: "+r2$
PRINT "rsc 3: "+r3$
PRINT "p1: "+p1$
PRINT "p2: "+p2$
PRINT "s1: "+s1$
PRINT "s2: "+s2$
PRINT "s3: "+s3$
PRINT "f1: "+f1$
PRINT "f2: "+f2$
PRINT "f3: "+f3$
PRINT "fsn: "+fsn$
ENDIF
IF EXIST(p2$) THEN
KILL p2$
ENDIF
@workit2
RETURN
'
PROCEDURE workit2
LOCAL a$,ms,h,m,s,fz,a1$,a2$,a3$,a4$
IF EXIST(s1$) AND EXIST(s2$) AND EXIST(s3$) THEN
nr=main&
IF proghere=FALSE THEN
@rsc_draw(nr,0)
ENDIF
proghere=TRUE
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
a$=STR$(INT(synchertz/512))
IF LEN(a$)>5 THEN
a$=RIGHT$(a$,5)
ENDIF
a$=a$+CHR$(0)
reg1$=CHR$(0)
reg2$=CHR$(0)
reg3$=CHR$(0)
reg4$=reg4$+CHR$(0)
reg6$=reg6$+CHR$(0)
@editfeld(name&,reg1$)
@editfeld(street&,reg2$)
@editfeld(state&,reg3$)
@editfeld(serial&,reg4$)
@editfeld(version&,reg6$)
@do_workit
ELSE
IF debug=TRUE THEN
PRINT "ERR: s1, s2 or s3 doesnt exist"
ENDIF
@alerts(23)
ENDIF
@goodbye
RETURN
'
PROCEDURE do_workit
REPEAT
REPEAT
obj=@rsc_do(nr,obj,popup&)
IF obj<>name& AND obj<>street& AND obj<>state& AND obj<>serial& AND obj<>version& THEN
edit_obj&=0
ENDIF
IF obj=getser1& THEN
@rsc_back(main&)
@rsc_exit
o=RSRC_LOAD(f$)
~RSRC_GADDR(0,blkfunc&,zu)
ed=LPEEK(zu+(24*sernr&)+12)
ed=4+LPEEK(ed)
RESTORE key3
ser$=""
WHILE PEEK(ed)<>0
ax=PEEK(ed)
IF ax<>0 THEN
READ bx
a=(ax-bx)
ENDIF
ser$=ser$+CHR$(a)
ed=ed+1
WEND
~RSRC_FREE()
@alerts(8)
END
ENDIF
IF obj=getser2& THEN
@rsc_back(main&)
@rsc_exit
o=RSRC_LOAD(f2$+CHR$(0))
~RSRC_GADDR(0,blkfunc&,zu%)
e=4+LPEEK(LPEEK(zu%+24*sernr&+12))
RESTORE key3
ser$=""
WHILE PEEK(e)<>0
a=PEEK(e)
IF a<>0 THEN
READ b
a=((a-b) AND 255)
ENDIF
ser$=ser$+CHR$(a)
e=e+1
WEND
~RSRC_FREE()
@alerts(8)
END
ENDIF
UNTIL obj=mainex& OR obj=mainok&
IF obj=mainok& THEN
sernr2=FALSE
@editread(name&)
reg1$=a$
@editread(street&)
reg2$=a$
@editread(state&)
reg3$=a$
@editread(serial&)
isn$=a$
reg4$="SER.NR."+a$
@editread(version&)
reg6$=a$
@setbutton(obj,0)
IF reg1$<>"" THEN
@serfile
ENDIF
ENDIF
UNTIL (reg1$<>"" AND reg2$<>"" AND reg3$<>"" AND isn$<>"" AND reg6$<>"" AND INSTR(reg3$,"-")<>0 AND INSTR(reg1$," ")<>0 AND INSTR(reg6$,"/")<>0 AND sernr1=TRUE AND sernr2=FALSE) OR obj=mainex&
IF debug=TRUE THEN
PRINT "all check are valid"
ENDIF
IF obj=mainok& THEN
IF LEN(reg0$)>20 THEN
reg0$=LEFT$(reg0$,20)
ENDIF
IF LEN(reg1$)>40 THEN
reg1$=LEFT$(reg1$,40)
ENDIF
IF LEN(reg2$)>40 THEN
reg2$=LEFT$(reg2$,40)
ENDIF
IF LEN(reg3$)>40 THEN
reg3$=LEFT$(reg3$,40)
ENDIF
IF LEN(reg4$)>40 THEN
reg4$=LEFT$(reg4$,40)
ENDIF
IF LEN(reg6$)>47 THEN
reg6$=LEFT$(reg6$,47)
ENDIF
@rsc_back(main&)
@main
ELSE
@setbutton(obj,0)
ENDIF
obj=0
RETURN
'
PROCEDURE serfile
sernr2=FALSE
IF reg1$="STEPHAN WILHELM" THEN
sernr1=TRUE
ELSE
sernr1=FALSE
IF EXIST(fsn$)=TRUE THEN
~GEMDOS(67,L:VARPTR(fsn$),1,0)
OPEN "U",#1,fsn$
FOR i=0 TO 9999
sers!(i)=FALSE
NEXT i
REPEAT
IF EOF(#1)=FALSE THEN
INPUT #1,a1$
INPUT #1,a2$
INPUT #1,a3$
INPUT #1,a4$
IF a2$=reg1$ THEN
b1$=a1$
b3$=a3$
b4$=a4$
IF (reg2$="" AND reg3$="") OR (reg2$<>"" AND reg3$<>"") THEN
sernr1=TRUE
ENDIF
IF reg2$<>"" AND reg3$="" AND a3$=reg2$ THEN
sernr1=TRUE
ENDIF
IF reg2$="" AND reg3$<>"" AND a4$=reg3$ THEN
sernr1=TRUE
ENDIF
ELSE
s=VAL(RIGHT$(a1$,4))
sers!(s)=TRUE
ENDIF
ENDIF
UNTIL EOF(#1)=TRUE
IF sernr1=TRUE THEN
IF reg2$="" OR reg3$="" THEN
sernr2=TRUE
isn$=b1$
reg4$="SER.NR."+isn$
reg2$=b3$
reg3$=b4$
@editfeld(serial&,isn$+CHR$(0))
@editfeld(street&,reg2$+CHR$(0))
@editfeld(state&,reg3$+CHR$(0))
ELSE
s=VAL(RIGHT$(isn$,4))
IF sers!(s)=TRUE OR VAL(isn$)=0 OR VAL(isn$)=nul THEN
sernr1=FALSE
ENDIF
ENDIF
ELSE
s=VAL(RIGHT$(isn$,4))
IF VAL(isn$)<>0 AND VAL(isn$)<>nul AND sers!(s)=FALSE THEN
sernr1=TRUE
PRINT #1,isn$+","+reg1$+","+reg2$+","+reg3$
ELSE
sernr1=FALSE
ENDIF
ENDIF
CLOSE #1
~GEMDOS(67,L:VARPTR(fsn$),1,1)
ELSE
IF VAL(isn$)<>0 AND VAL(isn$)<>nul THEN
sernr1=TRUE
OPEN "O",#1,fsn$
PRINT #1,isn$+","+reg1$+","+reg2$+","+reg3$
CLOSE #1
~GEMDOS(67,L:VARPTR(fsn$),1,1)
ELSE
sernr1=FALSE
ENDIF
ENDIF
ENDIF
RETURN
'
PROCEDURE main
doexit=FALSE
IF debug=TRUE THEN
PRINT "open to read s1:"+s1$
ENDIF
OPEN "I",#1,s1$
len=LOF(#1)
CLOSE #1
mem=MALLOC(len)
IF mem>0 THEN
IF debug=TRUE THEN
PRINT "create rsc f1:"+f1$
ENDIF
handle=GEMDOS(60,L:VARPTR(f1$),0)    ! create rsc
handle2=GEMDOS(61,L:VARPTR(s1$),0)    ! open rsc
@work
~GEMDOS(62,handle2)                 ! close rsc
~GEMDOS(62,handle)                  ! close rsc
~MFREE(mem)
OPEN "I",#1,s2$
IF debug=TRUE THEN
PRINT "open to read s2:"+s2$
ENDIF
len=LOF(#1)
CLOSE #1
mem=MALLOC(len)
IF mem>0 THEN
IF debug=TRUE THEN
PRINT "create rsc f2:"+f2$
ENDIF
handle=GEMDOS(60,L:VARPTR(f2$),0)   ! create rsc
handle2=GEMDOS(61,L:VARPTR(s2$),0)    ! open rsc
@work
~GEMDOS(62,handle2)                 ! close rsc
~GEMDOS(62,handle)                  ! close rsc
~MFREE(mem)
OPEN "I",#1,s3$
IF debug=TRUE THEN
PRINT "open to read s3:"+s3$
ENDIF
len=LOF(#1)
CLOSE #1
mem=MALLOC(len)
IF mem>0 THEN
handle=GEMDOS(60,L:VARPTR(f3$),0)   ! create prg
IF debug=TRUE THEN
PRINT "create prg f3:"+f3$
ENDIF
handle2=GEMDOS(61,L:VARPTR(s3$),0)    ! open prg
@work2
~GEMDOS(62,handle2)                 ! close prg
~GEMDOS(62,handle)                  ! close prg
~MFREE(mem)
'
b$=" a -rXrq "+l$+lzh$+" "+l$+fold$+"\*.*"
IF debug=TRUE THEN
PRINT "pack STARTRAK Folder to LZH:"+b$
PRINT "exec "+lh$
ENDIF
a=EXEC(0,lh$,b$,"")                          ! pack STARTRAK-Folder to STARTRAK.LZH
b$=" d -rXrq "+l$+lzh$+" "+starset$
a=EXEC(0,lh$,b$,"")                          ! delete STARTRK.SET from STARTRAK.LZH
IF debug=TRUE THEN
PRINT "delete startrk.set from lzh:"+b$
PRINT "exec "+lh$
ENDIF
'
IF debug=TRUE THEN
PRINT "read from lzh (p1s):"+p1$
PRINT "write to lzh (p2$):"+p2$
ENDIF
IF EXIST(p1$)=TRUE THEN
OPEN "I",#1,p1$
len=LOF(#1)
CLOSE #1
mem=MALLOC(len)
IF mem>0 THEN
handle=GEMDOS(60,L:VARPTR(p2$),0)   ! create lzh
handle2=GEMDOS(61,L:VARPTR(p1$),0)  ! open lzh
~GEMDOS(63,handle2,L:len,L:mem)     ! read lzh
q=GEMDOS(64,handle,L:len,L:mem)      ! write lzh
IF q<>len THEN
@alerts(16)
@goodbye
ENDIF
~GEMDOS(62,handle2)                 ! close lzh
~GEMDOS(62,handle)                  ! close lzh
~MFREE(mem)
IF debug=TRUE THEN
PRINT "delete p1: "+p1$
ENDIF
KILL p1$
'
@alerts(15)
g2=g
@alerts(11)
g3=g
in$=d1$+inf$
IF debug=TRUE THEN
PRINT "open in: "+in$
ENDIF
OPEN "O",#1,in$
SELECT g2
CASE 1
PRINT #1,"FRG"
CASE 2
PRINT #1,"UK"
CASE 3
PRINT #1,"FRA"
ENDSELECT
IF g3=1 THEN
PRINT #1,"helpsys=true"
ELSE
PRINT #1,"helpsys=false"
ENDIF
CLOSE #1
'
@alerts(10)
IF g=1 THEN
IF debug=TRUE THEN
PRINT "fsfirst "+l$+d1$+"*.*"
ENDIF
a=FSFIRST(l$+d1$+"*.*",0)
IF a=0 THEN
dta=FGETDTA()+30
REPEAT
a$=""
i=0
REPEAT
a$=a$+CHR$(PEEK(dta+i))
INC i
UNTIL PEEK(dta+i)=0
b$=dsk$+a$+CHR$(0)
a$=l$+d1$+a$+CHR$(0)
OPEN "I",#1,a$
len=LOF(#1)
CLOSE #1
mem=MALLOC(len)
IF mem>0 THEN
IF debug=TRUE THEN
PRINT "read from "+a$
PRINT "write to "+b$
ENDIF
handle=GEMDOS(60,L:VARPTR(b$),0)   ! create lzh
handle2=GEMDOS(61,L:VARPTR(a$),0)  ! open lzh
~GEMDOS(63,handle2,L:len,L:mem)     ! read lzh
q=GEMDOS(64,handle,L:len,L:mem)      ! write lzh
IF q<>len THEN
@alerts(16)
@goodbye
ENDIF
~GEMDOS(62,handle2)                 ! close lzh
~GEMDOS(62,handle)                  ! close lzh
~MFREE(mem)
fn=FSNEXT()
ENDIF
UNTIL fn<0
ELSE
IF debug=TRUE THEN
PRINT "ERR: fsfirst without result"
ENDIF
@alerts(23)
@goodbye
ENDIF
IF g3=1 THEN
@alerts(14)
IF EXIST(d2$)=TRUE THEN
OPEN "I",#1,d2$
len=LOF(#1)
CLOSE #1
mem=MALLOC(len)
IF mem>0 THEN
b$=dsk$+help$+CHR$(0)
handle=GEMDOS(60,L:VARPTR(b$),0)    ! create lzh
handle2=GEMDOS(61,L:VARPTR(d2$),0)  ! open lzh
~GEMDOS(63,handle2,L:len,L:mem)     ! read lzh
q=GEMDOS(64,handle,L:len,L:mem)      ! write lzh
IF q<>len THEN
@alerts(16)
@goodbye
ENDIF
~GEMDOS(62,handle2)                 ! close lzh
~GEMDOS(62,handle)                  ! close lzh
~MFREE(mem)
ELSE
@alerts(3)
@goodbye
ENDIF
ELSE
IF debug=TRUE THEN
PRINT "ERR: d2 not exist: "+d2$
ENDIF
@alerts(23)
@goodbye
ENDIF
ENDIF
ENDIF
@alerts(13)
ELSE
IF debug=TRUE THEN
PRINT "no memory: "+p1$
ENDIF
@alerts(3)
@goodbye
ENDIF
ELSE
IF debug=TRUE THEN
PRINT "ERR: p1 doesnt exist: "+p1$
ENDIF
@alerts(23)
@goodbye
ENDIF
ELSE
@alerts(3)
@goodbye
ENDIF
ELSE
@alerts(3)
@goodbye
ENDIF
ELSE
@alerts(3)
@goodbye
ENDIF
RETURN
'
PROCEDURE work
IF doexit=FALSE THEN
k=0
~GEMDOS(63,handle2,L:len,L:mem)      ! read rsc
FOR i=0 TO len-10
a1=PEEK(mem+i)
IF a1=ASC("C") THEN
a2=PEEK(mem+i+1)
IF a2=ASC("O") THEN
a3=PEEK(mem+i+2)
IF a3=ASC("P") THEN
a4=PEEK(mem+i+3)
a5=PEEK(mem+i+4)
a6=PEEK(mem+i+5)
a7=PEEK(mem+i+6)
a8=PEEK(mem+i+7)
a9=PEEK(mem+i+8)
an=PEEK(mem+i+9)-48
a$=CHR$(a1)+CHR$(a2)+CHR$(a3)+CHR$(a4)+CHR$(a5)+CHR$(a6)+CHR$(a7)+CHR$(a8)+CHR$(a9)
IF a$="COPYRIGHT" THEN
INC k
SELECT an
CASE 0
a$=CHR$(0)+reg0$+CHR$(0)
CASE 1
a$=CHR$(0)+reg1$+CHR$(0)
CASE 2
a$=CHR$(0)+reg2$+CHR$(0)
CASE 3
a$=CHR$(0)+reg3$+CHR$(0)
CASE 4
a$=CHR$(0)+reg4$+CHR$(0)
ENDSELECT
RESTORE key
@busy_mouse
FOR j=0 TO LEN(a$)-1
a=ASC(MID$(a$,j+1,1))
IF a<>0 THEN
READ b
a=(a+b) AND 255
ENDIF
POKE mem+i+j,a
NEXT j
ENDIF
ENDIF
ENDIF
ENDIF
IF a1=ASC("S") THEN
a2=PEEK(mem+i+1)
IF a2=ASC("E") THEN
a3=PEEK(mem+i+2)
IF a3=ASC("R") THEN
a4=PEEK(mem+i+3)
a5=PEEK(mem+i+4)
a6=PEEK(mem+i+5)
a7=PEEK(mem+i+6)
a8=PEEK(mem+i+7)
a9=PEEK(mem+i+8)
a$=CHR$(a1)+CHR$(a2)+CHR$(a3)+CHR$(a4)+CHR$(a5)+CHR$(a6)+CHR$(a7)+CHR$(a8)+CHR$(a9)
IF a$="SERNUMMER" THEN
INC k
a$=CHR$(0)+"   "+MID$(reg4$,8,LEN(reg4$)-7)+CHR$(0)
RESTORE key3
@busy_mouse
FOR j=0 TO LEN(a$)-1
a=ASC(MID$(a$,j+1,1))
IF a<>0 AND a<>32 THEN
READ b
a=(a+b) AND 255
ENDIF
POKE mem+i+j,a
NEXT j
ENDIF
ENDIF
ENDIF
ENDIF
EXIT IF k=6 OR doexit=TRUE
NEXT i
@busy_mouse
IF doexit=FALSE THEN
q=GEMDOS(64,handle,L:len,L:mem)      ! write rsc
IF q<>len THEN
@alerts(16)
@goodbye
ENDIF
ELSE
doexit=TRUE
@alerts(7)
ENDIF
ENDIF
RETURN
'
PROCEDURE work2
k=0
IF doexit=FALSE THEN
~GEMDOS(63,handle2,L:len,L:mem)      ! read rsc
FOR i=len-10 TO 0 STEP -1
a1=PEEK(mem+i)
IF a1=ASC("C") THEN
a2=PEEK(mem+i+1)
IF a2=ASC("O") THEN
a3=PEEK(mem+i+2)
IF a3=ASC("P") THEN
a4=PEEK(mem+i+3)
a5=PEEK(mem+i+4)
a6=PEEK(mem+i+5)
a7=PEEK(mem+i+6)
a8=PEEK(mem+i+7)
a9=PEEK(mem+i+8)
a10=PEEK(mem+i+9)
an=PEEK(mem+i+9)-48
a$=CHR$(a1)+CHR$(a2)+CHR$(a3)+CHR$(a4)+CHR$(a5)+CHR$(a6)+CHR$(a7)+CHR$(a8)+CHR$(a9)
IF debug=TRUE THEN
PRINT "check for copyright string, found: "+a$
PRINT "char after copyright is (code:";a10;"), (chr:";CHR$(a10);")"
ENDIF
' IF a$="COPYRIGHT" AND a10<>ASC(" ") THEN
IF a$="COPYRIGHT" THEN
INC k
SELECT an
CASE 0
a$=reg0$+CHR$(0)
CASE 1
a$=reg1$+CHR$(0)
CASE 2
a$=reg2$+CHR$(0)
CASE 3
a$=reg3$+CHR$(0)
CASE 4
a$=reg4$+CHR$(0)
CASE 5
a$=reg5$+CHR$(0)
CASE 6
a$=reg6$+CHR$(0)
ENDSELECT
IF debug=TRUE THEN
PRINT "select ";k;"/7: ";an;" - "+a$
ENDIF
ENDIF
RESTORE key2
@busy_mouse
FOR j=0 TO LEN(a$)-1
a=ASC(MID$(a$,j+1,1))
IF a<>0 THEN
READ b
a=(a+b) AND 255
ENDIF
POKE mem+i+j,a
NEXT j
ENDIF
ENDIF
ENDIF
EXIT IF k=7
NEXT i
@busy_mouse
q=GEMDOS(64,handle,L:len,L:mem)      ! write rsc
IF q<>len THEN
@alerts(16)
@goodbye
ENDIF
ENDIF
RETURN
'
' ENDE
