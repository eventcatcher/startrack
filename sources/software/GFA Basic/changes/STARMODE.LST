$m50000
$e$
'
' Mode-Control and Soundcall-Analyser for StarTrack Audiocard V2.0
'
profi=TRUE
gemvers=GEMDOS(48)
dreidim=TRUE
'
sysbase=LPEEK(&H4F2)
land=DPEEK(sysbase+28)
IF BTST(land,1)=TRUE OR BTST(land,8)=TRUE THEN
  language=1   ! deutsch
ELSE
  language=2   ! english
ENDIF
xload=FALSE
windowda=FALSE
xbs=500                   ! my_xbios
' ON ERROR GOSUB fehler
CLIP OFF
startup=FALSE
compile=BYTE{ADD(BASEPAGE,256)}<>96
acc=({ADD(BASEPAGE,36)}=0)
INLINE m_busy%,592
m_adr%=m_busy%
xwidth=WORK_OUT(0)+1
ywidth=WORK_OUT(1)+1
bigfoot=FALSE
IF xwidth>=998 AND ywidth>=662 THEN
  bigfoot=TRUE
ENDIF
@busy_mouse
@initdata
'
' ------------------------------------------------------------------------------
' ------------------------RSC-VARIABLEN-----------------------------------------
' ------------------------------------------------------------------------------
REM Resource Datei Indizes fÅr STARMODE
'
LET mode&=0 ! Formular/Dialog
LET mainbox&=0 ! BOX in Baum MODE
LET exit&=1 ! BUTTON in Baum MODE
LET mainbox2&=2 ! BOX in Baum MODE
LET wmbox3&=4 ! BOX in Baum MODE
LET mat2&=5 ! BUTTON in Baum MODE
LET mat4&=6 ! BUTTON in Baum MODE
LET mat16&=7 ! BUTTON in Baum MODE
LET mat8&=8 ! BUTTON in Baum MODE
LET wmbox7&=10 ! BOX in Baum MODE
LET rec2&=11 ! BUTTON in Baum MODE
LET rec4&=12 ! BUTTON in Baum MODE
LET rec8&=13 ! BUTTON in Baum MODE
LET emadc8&=14 ! BUTTON in Baum MODE
LET emadca8&=16 ! BUTTON in Baum MODE
LET wmbox4&=19 ! BOX in Baum MODE
LET mast16&=20 ! BUTTON in Baum MODE
LET mast24&=21 ! BUTTON in Baum MODE
LET wmbox5&=23 ! BOX in Baum MODE
LET ramlo&=24 ! BUTTON in Baum MODE
LET ramhi&=25 ! BUTTON in Baum MODE
LET wmbox6&=27 ! BOX in Baum MODE
LET emula&=28 ! BUTTON in Baum MODE
LET falclk&=29 ! BUTTON in Baum MODE
LET inswc&=32 ! BOXTEXT in Baum MODE
LET incirc&=33 ! BOXCHAR in Baum MODE
LET inlnk&=35 ! BOXTEXT in Baum MODE
LET ratecir2&=36 ! BOXCHAR in Baum MODE
LET helpmod&=37 ! BOXTEXT in Baum MODE
LET modeundo&=39 ! BOXTEXT in Baum MODE
LET modekick&=40 ! BUTTON in Baum MODE
LET modevol&=41 ! BUTTON in Baum MODE
'
LET devco&=1 ! Formular/Dialog
LET devcobx&=0 ! BOX in Baum DEVCO
LET devcobx2&=1 ! BOX in Baum DEVCO
LET devcobx1&=3 ! BOX in Baum DEVCO
LET dmap0&=4 ! BUTTON in Baum DEVCO
LET xmita0&=5 ! BUTTON in Baum DEVCO
LET adc0&=6 ! BUTTON in Baum DEVCO
LET adc1&=10 ! BUTTON in Baum DEVCO
LET adc2&=11 ! BUTTON in Baum DEVCO
LET xmita1&=12 ! BUTTON in Baum DEVCO
LET xmita2&=13 ! BUTTON in Baum DEVCO
LET dmap1&=14 ! BUTTON in Baum DEVCO
LET dmap2&=15 ! BUTTON in Baum DEVCO
LET devcobx5&=21 ! BOX in Baum DEVCO
LET xmitb0&=22 ! BUTTON in Baum DEVCO
LET dspx0&=23 ! BUTTON in Baum DEVCO
LET exti0&=24 ! BUTTON in Baum DEVCO
LET exti1&=28 ! BUTTON in Baum DEVCO
LET exti2&=29 ! BUTTON in Baum DEVCO
LET dspx1&=30 ! BUTTON in Baum DEVCO
LET dspx2&=31 ! BUTTON in Baum DEVCO
LET xmitb1&=32 ! BUTTON in Baum DEVCO
LET xmitb2&=33 ! BUTTON in Baum DEVCO
LET devcobx4&=39 ! BOX in Baum DEVCO
LET conv&=40 ! BUTTON in Baum DEVCO
LET devcohlp&=52 ! BOXTEXT in Baum DEVCO
LET devundo&=53 ! BOXTEXT in Baum DEVCO
LET devexit&=54 ! BUTTON in Baum DEVCO
LET devshow&=55 ! BUTTON in Baum DEVCO
LET expotxt&=56 ! BOXTEXT in Baum DEVCO
LET mchitxt&=57 ! BOXTEXT in Baum DEVCO
LET mchotxt&=58 ! BOXTEXT in Baum DEVCO
LET extotxt&=62 ! BOXTEXT in Baum DEVCO
'
LET status&=2 ! Formular/Dialog
LET statbx1&=0 ! BOX in Baum STATUS
LET statexit&=1 ! BUTTON in Baum STATUS
LET statbx2&=2 ! BOX in Baum STATUS
LET statbx7&=4 ! BOX in Baum STATUS
LET snd0&=5 ! BUTTON in Baum STATUS
LET snd1&=6 ! BUTTON in Baum STATUS
LET snd2&=7 ! BUTTON in Baum STATUS
LET statbx10&=9 ! BOX in Baum STATUS
LET addr0&=10 ! BUTTON in Baum STATUS
LET addr1&=11 ! BUTTON in Baum STATUS
LET statbx9&=13 ! BOX in Baum STATUS
LET adci0&=14 ! BUTTON in Baum STATUS
LET adci1&=15 ! BUTTON in Baum STATUS
LET statbx5&=17 ! BOX in Baum STATUS
LET trkp0&=18 ! BUTTON in Baum STATUS
LET trkp1&=19 ! BUTTON in Baum STATUS
LET trkp3&=20 ! BUTTON in Baum STATUS
LET trkp2&=21 ! BUTTON in Baum STATUS
LET statbx11&=23 ! BOX in Baum STATUS
LET trkr0&=24 ! BUTTON in Baum STATUS
LET trkr1&=25 ! BUTTON in Baum STATUS
LET trkr2&=26 ! BUTTON in Baum STATUS
LET trkr3&=27 ! BUTTON in Baum STATUS
LET statbx3&=30 ! BOX in Baum STATUS
LET src0&=31 ! BUTTON in Baum STATUS
LET src1&=32 ! BUTTON in Baum STATUS
LET src2&=33 ! BUTTON in Baum STATUS
LET src3&=34 ! BUTTON in Baum STATUS
LET statbx4&=36 ! BOX in Baum STATUS
LET mon0&=37 ! BUTTON in Baum STATUS
LET mon1&=38 ! BUTTON in Baum STATUS
LET mon3&=39 ! BUTTON in Baum STATUS
LET mon2&=40 ! BUTTON in Baum STATUS
LET statbx8&=42 ! BOX in Baum STATUS
LET intp0&=43 ! BUTTON in Baum STATUS
LET intp1&=44 ! BUTTON in Baum STATUS
LET statbx12&=47 ! BOX in Baum STATUS
LET intr0&=48 ! BUTTON in Baum STATUS
LET intr1&=49 ! BUTTON in Baum STATUS
LET statbx6&=51 ! BOX in Baum STATUS
LET rate0&=53 ! BOXTEXT in Baum STATUS
LET rate1&=54 ! BOXTEXT in Baum STATUS
LET stathelp&=58 ! BOXTEXT in Baum STATUS
LET statundo&=60 ! BOXTEXT in Baum STATUS
LET statshow&=61 ! BUTTON in Baum STATUS
'
LET popups&=3 ! Formular/Dialog
LET inpop&=1 ! BOX in Baum POPUPS
LET analog&=2 ! STRING in Baum POPUPS
LET digital&=3 ! STRING in Baum POPUPS
LET srcpop&=4 ! BOX in Baum POPUPS
LET opto&=5 ! STRING in Baum POPUPS
LET coax&=6 ! STRING in Baum POPUPS
LET aesebu&=7 ! STRING in Baum POPUPS
'
LET seedev&=4 ! Formular/Dialog
LET fselbox&=0 ! BOX in Baum SEEDEV
LET fselbox2&=1 ! BOX in Baum SEEDEV
LET fsbut1&=2 ! BOXTEXT in Baum SEEDEV
LET fsbut2&=3 ! BOXTEXT in Baum SEEDEV
LET fsbut3&=4 ! BOXTEXT in Baum SEEDEV
LET fsbut4&=5 ! BOXTEXT in Baum SEEDEV
LET fsbut5&=6 ! BOXTEXT in Baum SEEDEV
LET fsbut6&=7 ! BOXTEXT in Baum SEEDEV
LET fsbut7&=8 ! BOXTEXT in Baum SEEDEV
LET fsbut8&=9 ! BOXTEXT in Baum SEEDEV
LET fsbut9&=10 ! BOXTEXT in Baum SEEDEV
LET fsbut10&=11 ! BOXTEXT in Baum SEEDEV
LET fsbut11&=12 ! BOXTEXT in Baum SEEDEV
LET fsbut12&=13 ! BOXTEXT in Baum SEEDEV
LET fsbut13&=14 ! BOXTEXT in Baum SEEDEV
LET fsbut14&=15 ! BOXTEXT in Baum SEEDEV
LET fsbut15&=16 ! BOXTEXT in Baum SEEDEV
LET fstxt1&=17 ! BOXTEXT in Baum SEEDEV
LET fstxt2&=18 ! BOXTEXT in Baum SEEDEV
LET fstxt3&=19 ! BOXTEXT in Baum SEEDEV
LET fstxt4&=20 ! BOXTEXT in Baum SEEDEV
LET fstxt5&=21 ! BOXTEXT in Baum SEEDEV
LET fstxt6&=22 ! BOXTEXT in Baum SEEDEV
LET fstxt7&=23 ! BOXTEXT in Baum SEEDEV
LET fstxt8&=24 ! BOXTEXT in Baum SEEDEV
LET fstxt9&=25 ! BOXTEXT in Baum SEEDEV
LET fstxt10&=26 ! BOXTEXT in Baum SEEDEV
LET fstxt11&=27 ! BOXTEXT in Baum SEEDEV
LET fstxt12&=28 ! BOXTEXT in Baum SEEDEV
LET fstxt13&=29 ! BOXTEXT in Baum SEEDEV
LET fstxt14&=30 ! BOXTEXT in Baum SEEDEV
LET fstxt15&=31 ! BOXTEXT in Baum SEEDEV
LET fsslide&=32 ! BOX in Baum SEEDEV
LET fssldbut&=33 ! BUTTON in Baum SEEDEV
LET fsexit&=34 ! BUTTON in Baum SEEDEV
LET fshelp&=35 ! BOXTEXT in Baum SEEDEV
LET fssldup&=37 ! ICON in Baum SEEDEV
LET fsslddwn&=38 ! ICON in Baum SEEDEV
LET fsclear&=39 ! BUTTON in Baum SEEDEV
LET fsdsp&=40 ! BUTTON in Baum SEEDEV
LET fssnd&=41 ! BUTTON in Baum SEEDEV
LET fsdevc&=42 ! BUTTON in Baum SEEDEV
LET fsclip&=43 ! BUTTON in Baum SEEDEV
'
LET alertbox&=5 ! Formular/Dialog
LET alertcol&=0 ! BOX in Baum ALERTBOX
'
OPTION BASE 0
IF compile=FALSE THEN
  RESERVE &H100000
ENDIF
'
maxcol=WORK_OUT(13)
'
'
' ------------------------------------------------------------------------------
' ------------------------AUFLôSUNG ERFRAGEN------------------------------------
' ------------------------------------------------------------------------------
IF xwidth<640 OR ywidth<400 THEN
  @alerts(1)
  IF acc=TRUE THEN
    GOTO ende
  ELSE
    END
  ENDIF
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------RSC LADEN---------------------------------------------
' ------------------------------------------------------------------------------
DEFMOUSE 0
KEYPAD 0                    ! wg KompatibilitÑt (normale Tastatureinstellung)
'
rsc$="STARMODE.RSC"        ! Name des kleinen RSC-Files
'
'
btree=alertbox&                      ! Anzahl der BÑume-1
@rsc_init
'
xrok=@xrsrc_init
IF xrok=FALSE THEN
  @alerts(3)
  END
ENDIF
'
mtype=INT(C:rsc_cookie%(L:CVL("_MCH"))/&H10000)          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
magicmac=INT(C:rsc_cookie%(L:CVL("MgMc")))          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
magix=INT(C:rsc_cookie%(L:CVL("MagX")))          ! COOKIE-ABFRAGE MagiC
pci=INT(C:rsc_cookie%(L:CVL("_PCI")))          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
mch=INT(C:rsc_cookie%(L:CVL("_MCH")))          ! COOKIE-ABFRAGE PCI
snd=INT(C:rsc_cookie%(L:CVL("_SND")))          ! COOKIE-ABFRAGE PCI
vdo=INT(C:rsc_cookie%(L:CVL("_VDO")))          ! COOKIE-ABFRAGE PCI
cpu=INT(C:rsc_cookie%(L:CVL("_CPU")))          ! COOKIE-ABFRAGE PCI
IF mtype=2 THEN
  vme=&HFEFF0000
ELSE
  vme=&HDF0000
ENDIF
adr=vme+&H401
'
IF compile=TRUE THEN
  lfw$=CHR$(GEMDOS(25)+65)+":"+DIR$(0)+"\"       ! funktioniert als COMPILAT !
ELSE
  lfw$="D:\"
ENDIF
s$=lfw$
'
' ---------------------------.ACC-Abfrage---------------------------------------
IF acc=TRUE THEN
  ap_id&=APPL_INIT()
  IF ap_id&
    me_id&=MENU_REGISTER(ap_id&,"  StarMode")
    DO
      ~EVNT_MESAG(0)
      IF MENU(1)=40
        accx=TRUE
        GOTO start
      ende:
      ENDIF
    LOOP
  ENDIF
ENDIF
'
start:
@loaddesk
@treiberload
IF rscda=TRUE THEN
  @main
  IF acc=TRUE THEN
    GOTO ende
  ELSE
    END
  ENDIF
ELSE
  @alerts(2)
  GEMSYS 109                                        ! Nur ab GEM 1.04!
  @goodbye
  IF acc=TRUE THEN
    GOTO ende
  ENDIF
ENDIF
IF away=TRUE THEN
  @alerts(3)
  IF acc=TRUE THEN
    GOTO ende
  ELSE
    END
  ENDIF
ENDIF
END
'
' ------------------------------------------------------------------------------
' ------------------------FLYDIALS--------------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE key
  .| Glob. Var.: key&,edit_obj&,cont&,rsc_adr%,next_obj&,idx&,obj&,mrkhandle2#
  .|     v1#,v2#,v3#,ascii|,scan|,a#,shift&,title&,shcut#,nob#,nr#,keytab%,a&
  .|     a$,tree&,evnt&,mb&,mx&,my&
  .| Felder    : rsc_adr%()
  .| Ruft auf  : form_keybd,rsc_shortcut
  .| Aufruf in : rsc_do-1,
  LOCAL bs
  ' Mîchten Sie erweiterte Tastaturkommandos? Dann entREMen Sie
  ' diese Zeile und ersetzen die Prozedur durch:
  '  IF key& AND edit_obj&<>0     ! vorher so....
  IF (key& AND edit_obj&<>0) OR (((key& AND 255)=13) AND ((key& DIV 256)<>50))    ! jetzt so....
    cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  ENDIF
  '  cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  '
  obj&=0
  ~WIND_GET(MENU(4),10,mrkhandle2,v1,v2,v3)
  '  ~WIND_GET(mrkhandle,10,mrkhandle2,v1,v2,v3)
  '
  ascii|=BYTE(key&)                                  ! ASCII-Code
  scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
  a=@rsc_shortcut(dropdown&,scan|,shift&,title&)
  shcut=FALSE
  IF a<>0 THEN
    nob=a
    obj&=a
    shcut=TRUE
  ENDIF
  '
  rsc_adr%=rsc_adr%(nr)
  IF ascii|=0                                        ! Kein ASCII-Code...
    '
    IF scan|=97 OR scan|=98                          ! UNDO/HELP...
      ascii|=ADD(SUB(scan|,97),14)
      mb&=0
      obj&=0
      '
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
      '
      IF BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE IF scan|>=59 AND scan|<=68                  ! F-Tasten...
      ascii|=SUB(scan|,58)
      obj&=0
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
      IF SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE                                             ! ALT+Buchstabe...
      '
      IF scan|>=120 AND scan|<=129                   ! Zahlen...
        SUB scan|,118
        keytab%={XBIOS(16,L:-1,L:-1,L:-1)}           ! ...ohne Shift
      ELSE                                           ! Alles andere...
        keytab%={ADD(XBIOS(16,L:-1,L:-1,L:-1),4)}    ! ...mit Shift
      ENDIF
      '
      ascii|=BYTE{ADD(keytab%,scan|)}                ! ASCII-Code holen
      IF ascii|<>0                                      ! Tastaturbedienbar...
        CLR a&,obj&
        '
        DO WHILE NOT BTST(OB_FLAGS(rsc_adr%,obj&),5) ! Nicht LASTOBJ
          INC obj&
          '
          scan|=BYTE(SHR(OB_TYPE(rsc_adr%,obj&),8))
          IF scan|=26 OR scan|=28                    ! Ein Button/String...
            a$=@rsc_text$(tree&,obj&)                ! ...Text
            '
            a&=INSTR(a$,"[")
            IF a&                                    ! Tastaturbedienbar...
              a&=ASC(MID$(a$,SUCC(a&),1))
              a&=(BCLR(a&,5)=ascii|) OR (a&>=48 AND a&<=57 AND a&=ascii|)
            ENDIF
            '                                        ! '[' vor Zeichen
          ENDIF
          '
        LOOP UNTIL a&                                ! ...gefunden
        '
        IF a&                                        ! Objekt gefunden...
          key&=0                                     ! ...keine Eingabe mehr
          mb&=0
          '                                          ! +SHIFT Circle-Butt?
          IF BTST(shift&,1) AND BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5) AND SHR(OB_TYPE(rsc_adr%,obj&+2),8)=27
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simulieren
            ~OBJC_OFFSET(rsc_adr%,obj&+2,mx&,my&)
            '                                        ! Ist es ein Popup...
          ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5)
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simul.
            ~OBJC_OFFSET(rsc_adr%,obj&,mx&,my&)
          ELSE                                       ! ...Button bedienen
            cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
          ENDIF
        ENDIF
        '
      ENDIF
    ENDIF
    '
  ENDIF
  '
  IF next_obj&<>0 AND edit_obj&<>next_obj&
    ~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,3,idx&)  ! ...Eingabe
  ENDIF
  '  obj=obj&
  '
RETURN
> PROCEDURE message
  .| Glob. Var.: handle&,a&,rsc_trees&,accwindopen#,tree&,rsc_window&
  .|     next_obj&,edit_obj&,idx&,nr#,peak&,peakint#,mx#,my#,mz#,rsc_adr%,n#
  .|     butdirect#,butnr#,donr#,h#,a#,smpedit&,mnr#,cs#,ce#
  .| Felder    : rsc_handle%(),rsc_adr%()
  .| Ruft auf  : markhlp,rsc_message,mouse,button,rsc_redraw_obj,curve
  .|     markprod3
  .| Aufruf in : rsc_do-1,helptxt-2,
  LOCAL iz
  handle&=MENU(4)                                    ! ...Fenster-Handle
  '
  FOR a&=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
    EXIT IF handle&=rsc_handle%(a&)
  NEXT a&
  IF MENU(1)=&H4724 THEN
    accwindopen=TRUE
  ENDIF
  IF MENU(1)=41 OR (MENU(1)=22 AND tree&=a&)         ! AC_CLOSE/Closer...
    MUL rsc_window&,-(MENU(1)=22)
    '
    next_obj&=9999                                   ! ...Exit-Code
    '
    GOTO rsc_dox_ende                                ! ...rsc_do verlassen
    '
  ELSE IF a&>-1 AND NOT (MENU(1)=21 AND a&<>tree&)   ! Ein RSC-Fenster....
    rsc_message(a&,MENU(1),MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    '
  ELSE IF MENU(1)=40 OR MENU(1)=21                   ! AC_OPEN/Anderes Fenster toppen...
    '
    IF a&<>-1 THEN
      IF handle&=rsc_handle%(a&) THEN
        tree&=a&
        nr=tree&
        @mouse(mx,my,mz)
        rsc_adr%=rsc_adr%(tree&)
        n=OBJC_FIND(rsc_adr%,0,100,mx,my)
        IF n<>0 AND n<>-1 THEN
          @button
          butdirect=TRUE
          butnr=donr
        ENDIF
      ENDIF
    ENDIF
    rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
  ELSE IF MENU(1)<>21 AND MENU(1)<>22                ! nicht toppen/schlieûen...
  ELSE                                               ! Nichts zu machen...
    ~BIOS(3,2,7)
  ENDIF
  IF MENU(1)=20 THEN
    h=MENU(4)                                    ! ...Fenster-Handle
    FOR a=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
      EXIT IF h=rsc_handle%(a)
    NEXT a
    ha1=h
  ENDIF
rsc_dox_ende:
  IF next_obj&<>9999 THEN
    next_obj&=0
  ENDIF
RETURN
> PROCEDURE button
  .| Glob. Var.: mrkhandle2#,mx&,my&,rsc_adr%,nr#,next_obj&,fsel&,fssldbut&
  .|     fsslide&,fsmax#,fsz#,slflg#,arranger&,arrslbut&,arrslide&,slmax#,pbz#
  .|     trakker&,trakxbut&,trakslid&,tmax#,trakkz#,trakybut&,trkvslid&,tymax#
  .|     trakkyz#,virtual&,vslbut&,vslider&,hbg#,hbz#,vhbldstrt#,smplen#,zu%
  .|     edit_obj&,idx&,vblkstrt&,a$,slr#,hbgm#,mt#,vslc#,lslide#,smpedit&
  .|     zoombutt&,mrz#,zoomp#,mrcs#,cs#,mrce#,ce#,zomslide&,zmax#,mrzoom#
  .|     scrlslde&,scrolbut&,scmax#,scrollp#,mrscroll#,scteil#,scrolm#,vmem#
  .|     cached#,scstep#,peak&,cont&,tree&,evnt&,obj&,ob_tail&,rsc_popup&,b$
  .|     popup&,rate&,digana#,mover&,input&,source&,dsp&,rate2&,smp16&
  .|     makerate&,arrmake&,make&,mb&,editfade&,peakmute&,arrm1&,arrm2&,arrm3&
  .|     arrm4&,arrclip&,leave#,v#,v2#,v3#,v4#
  .| Felder    : rsc_adr%(),rscx&(),rscy&(),rscw&(),rsch&()
  .| Ruft auf  : sliding,fsnrset,setbutton,slideupdate,arrnrset,timeline
  .|     blkart,slidelr,textbutt,zoomcalc,scrollinit,setslide,restaura
  .|     rsc_movedial,rsc_text,rsc_popup,rsc_set_cursor,edhandler2
  .| Aufruf in : message-1,rsc_do-2,
  LOCAL popok,dif
  leave=FALSE
  mrkhandle2=WIND_FIND(mx&,my&)
  '  IF mrkhandle=mrkhandle2 THEN
  '  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
  '  IF v<>0 AND kenn=mrkhandle2 THEN
  rsc_adr%=rsc_adr%(nr)
  IF next_obj&<>-1 OR rsc_handle%(tree&)>1000 THEN
    next_obj&=OBJC_FIND(rsc_adr%,0,100,mx&,my&)
  ENDIF
  '
  '                                                  ! String vor Popup...
  IF next_obj&>0
    IF BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND SHR(OB_TYPE(rsc_adr%,next_obj&),8)=28 AND BTST(OB_STATE(rsc_adr%,SUCC(next_obj&)),5)
      ' (TOUCHEXIT, STRING, SUCC: SHADOWED)
      INC next_obj&
    ENDIF
  ENDIF
  '
  IF next_obj&=-1                                    ! Neben die Box...
    IF rsc_mtsk!=FALSE THEN
      '      SOUND 1,15,10,4,10
      '     SOUND 0,0,0,0,0
    ENDIF
    next_obj&=0   !!!
  ELSE
    '
    IF tfselm=FALSE AND nr=seedev& AND next_obj&=fssldbut& THEN
      IF fsz2>(fsmax-fstep) THEN
        fsz2=fsmax-fstep
      ENDIF
      @sliding3(fsslide&,fssldbut&,fsmax,fstep,fsz2,slflg)
      IF slflg=TRUE THEN
        @clearfsel
        @fscalc
        @getsel2
      ENDIF
      @setbutton(next_obj&,0)
      next_obj&=0
    ENDIF
    '
    '
    IF tfselm=FALSE AND nr=seedev& AND next_obj&=fsslide& THEN
      ay&=rscy&(nr)
      @slideupdate2(fsslide&,fssldbut&,ay&+3,fsmax,mx&,my&,fstep,fsz2,slflg)
      IF slflg=TRUE THEN
        @clearfsel
        @fscalc
        @getsel2
      ENDIF
      next_obj&=0
    ENDIF
    '
    '
    '
    '
    '
    cont&=FORM_BUTTON(rsc_adr%,next_obj&,1,next_obj&)
    ' ------------------------------------------------ Flydial-Ecke
    IF BTST(OB_STATE(rsc_adr%,next_obj&),1)          ! (CROSSED)
      rsc_movedial(tree&,edit_obj&,idx&)             ! ...Dialog verschieben
      '
      next_obj&=0                                    ! Damit der Cursor..
      cont&=1                                        ! ..bleibt wo er ist
      ' ---------------------------------------------- Circle-Button...
    ELSE IF SHR(OB_TYPE(rsc_adr%,next_obj&),8)=27 AND BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),5) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),3))
      ' (G_BOXCHAR, PRED: SHADOWED /NOT DISABLED)
      '
      next_obj&=PRED(next_obj&)                      ! Objektnr. Button
      a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
      evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
      '
      obj&=1
      FOR ob_tail&=1 TO PRED(evnt&)
        obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
      NEXT ob_tail&
      '
      evnt&=SUCC(obj&)
      b$=@rsc_text$(rsc_popup&,evnt&)
      DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
        INC evnt&                                    ! Defaulteintrag
      LOOP
      '
      REPEAT
        INC evnt&                                    ! NÑchster Eintrag...
        IF evnt&>OB_TAIL(rsc_adr%(rsc_popup&),obj&)  ! ...gibt es nicht
          evnt&=SUCC(obj&)                           ! ...dann wieder 1.
        ENDIF
        '                                            ! bis nicht DISABLED
      UNTIL NOT BTST(OB_STATE(rsc_adr%(rsc_popup&),evnt&),3)
      '                                              ! Button Ñndern...
      rsc_text(tree&,next_obj&,@rsc_text$(rsc_popup&,evnt&))
      ~OBJC_DRAW(rsc_adr%,next_obj&,1,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
      popup&=SUB(evnt&,obj&)
      '          REPEAT
      '          ~GRAF_MKSTATE(v,v2,v3,v4)
      '        UNTIL v3=0
      ' ---------------------------------------------- Popup-Menue...
    ELSE IF BTST(OB_STATE(rsc_adr%,next_obj&),5) AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND (NOT BTST(OB_STATE(rsc_adr%,next_obj&),3))
      ' (SHADOWED, TOUCHEXIT, NOT DISABLED)
      evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
      obj&=1
      FOR ob_tail&=1 TO PRED(evnt&)
        obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
      NEXT ob_tail&
      ob_tail&=OB_TAIL(rsc_adr%(rsc_popup&),obj&)
      a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
      evnt&=SUCC(obj&)
      DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
        INC evnt&                                    ! Ausrichtung ermitteln
      LOOP UNTIL evnt&>ob_tail&
      '
      IF evnt&<=ob_tail&                             ! Defaulteintrag...
        popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,SUB(evnt&,SUCC(obj&)))
      ELSE                                           ! Sonst ohne...
        '        IF tree&=smpedit& OR tree&=make& THEN
        '        popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,1)
        '     ENDIF
      ENDIF
      IF popup&=0                                    ! Abbruch...
        cont&=1                                      ! ...weiter geht's
        next_obj&=0                                  ! ...Cursor 'festhalten'
      ENDIF
      ' ---------------------------------------------- Cursor positionieren
      ' Mîchten Sie den Cursor mit der Maus zeichengenau positionieren?
      ' Dann entREMen Sie diese Zeilen und laden diese Prozedur nach:
    ELSE IF BTST(OB_FLAGS(rsc_adr%,next_obj&),3)
      @rsc_set_cursor(rsc_adr%,mx&,my&,edit_obj&,next_obj&,idx&)
    ENDIF
    '
  ENDIF
  IF cont&=0 OR (next_obj&<>0 AND next_obj&<>edit_obj&)
    ~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
  ENDIF
  ' ENDIF
  ' ENDIF
  REPEAT
    ~GRAF_MKSTATE(v,v2,v3,v4)        ! NEU !!!
  UNTIL v3=0 OR leave=TRUE
RETURN
> PROCEDURE rsc_init
  .| Glob. Var.: ap_id&,rsc_aes&,rsc_mtsk!,rsc_alert&,wchar&,hchar&,rsc_vh&
  .|     planes&,deskx&,desky&,deskw&,deskh&,rsc_flyd%,rsc_bitblt%,rsc_obspec%
  .|     rsc_cookie%
  .| Felder    : rsc_adr%()
  .| Aufruf in : HAUPTPROGRAMM-1,
  LOCAL a&
  '
  ' Initialisiert die von den RSC-Routinen benîtigten Variablen...
  '
  ap_id&=APPL_INIT()                         ! Applikations-ID
  '
  rsc_aes&=INT{{ADD(GB,4)}}                  ! AES-Version
  rsc_mtsk!=INT{ADD({ADD(GB,4)},2)}<>1       ! Multitasking?
  rsc_alert&=-1                              ! Noch keine fliegenden Alerts
  '
  CONTRL(6)=GRAF_HANDLE(wchar&,hchar&,a&,a&) ! AES-Handle, Zeichenbreite/Hîhe
  rsc_vh&=V_OPNVWK(1)                        ! Virt.Workst. fÅr Flydials îffnen
  IF rsc_vh&=0
    rsc_vh&=V~H                              ! ...Fehler, dann eben die alte
  ENDIF
  CONTRL(6)=V~H
  '
  INTIN(0)=1
  VDISYS 102,1,0
  planes&=INTOUT(4)                          ! Bitplanes
  '
  ~WIND_GET(0,7,deskx&,desky&,deskw&,deskh&) ! Hintergrundfenster
  ' ------------------------------------------------------ Inline vorbereiten
  INLINE rsc_flyd%,2834
  '
  rsc_bitblt%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,16)})      ! BITBLT-Routine
  rsc_obspec%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,18)})      ! OB_SPEC-Routine...
  rsc_cookie%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,20)})      ! COOKIE-Routine...
  '
  {ADD(rsc_flyd%,22)}=ADD(GB,24)                         ! VDI-Parameterblock
  INT{ADD(rsc_flyd%,26)}=rsc_vh&                         ! Virt. Workstation
  INT{ADD(rsc_flyd%,28)}=wchar&                          ! Zeichenzellenbreite
  INT{ADD(rsc_flyd%,30)}=hchar&                          ! Zeichenzellenhîhe
  ' ------------------------------------------------------
  ' Berechnet den Speicherbedarf einer Bitmap-Grafik...
  DEFFN getsize(w&,h&)=SHL(SHR(ADD(MUL(MUL(SHR(ADD(w&,15),3),h&),planes&),255),8),8)
  '
  ' GegenstÅck zur Prozedur rsc_text: Universelles Objekt-Text auslesen...
  DEFFN rsc_text$(tree&,obj&)=CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}
  '
RETURN
> PROCEDURE rsc_exit
  .| Glob. Var.: rsc_vh&,popup_back%,rsc_userblk%
  .| Aufruf in : goodbye-1,
  '
  CONTRL(6)=rsc_vh&
  VDISYS 38,0,0                              ! vqt_attributes
  IF ABS(INTOUT(0))<>1                       ! Anderer AES-Zeichensatz (MTOS)...
    ~VST_UNLOAD_FONTS(0)                     ! ...freigeben
  ENDIF
  '
  IF rsc_vh&<>V~H                            ! Flydial-Workstation freigeben...
    ~V_CLSVWK()
  ENDIF
  '
  ' Die folgenden Zeilen sind nur im Interpreter relevant und kînnen im
  ' Compilat wegfallen. Tip: Mit dem ERGO!pro-PrÑprozessor ausblenden.
  '
  ~RSRC_FREE()                               ! Resource entfernen
  '
  IF popup_back%
    ~MFREE(popup_back%)                      ! Popup-Hintergrund freigeben
  ENDIF
  '
  IF rsc_userblk%
    ~MFREE(rsc_userblk%)                     ! Userblks freigeben
  ENDIF
  '
RETURN
> FUNCTION rsc_laden(file$,trees&,popup&,menu&,alert&)
$F%
.| Glob. Var.: popup_back%,rsc_trees&,rsc_popup&,rsc_menu&,rsc_alert&
.|     rsc_aes&,rsc_vh&,dreidim#,rsc_flyd%
.| Felder    : rsc_adr%(),rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&()
.| Ruft auf  : xrsrc_load,xrsrc_gaddr,rsc_walk_tree
.| Aufruf in : HAUPTPROGRAMM-2,
LOCAL tree&,obj&,font_h&,font_id&,color3d&,a%
popup_back%=0
'
' LÑdt die Resource und initialisiert einige globale Variablen...
' ------------------------------------------------------ RSC laden
' Wollen Sie das RSC-File direkt im Programmcode 'aufbewahren'?
' Dann entREMen Sie diese Zeilen und laden Sie die Funktion
' 'rsc_conv' aus EXTENDED.LST hinzu...
' INLINE rsc%,3160
' IF @rsrc_conv(rsc%)=0
IF @xrsrc_load(file$)=0
  ~FORM_ALERT(1,"[3][ | Fehler beim Laden | der RSC-Datei! | ][Abbruch]")
  RETURN FALSE
ENDIF
' ------------------------------------------------------
DIM rsc_adr%(trees&),rsc_handle%(trees&)
DIM rscx&(trees&),rscy&(trees&),rscw&(trees&),rsch&(trees&)
'
rsc_trees&=trees&                                      ! Anzahl ObjektbÑume-1
rsc_popup&=popup&                                      ! Popup-Baum
rsc_menu&=menu&                                        ! Dropdown-Baum
rsc_alert&=alert&                                      ! Alert-Baum
' ------------------------------------------------------ Adressen ermitteln
FOR tree&=0 TO trees&
  '
  ~@xrsrc_gaddr(0,tree&,a%)  ! Kompatibel zu den XRSRC-Routinen
  rsc_adr%(tree&)=a%
  IF tree&<>menu& OR menu&=0 THEN
    ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
  ENDIF
  '
NEXT tree&
' ------------------------------------------------------ Grîûtes Popup
IF popup&>-1
  obj&=1
  WHILE obj&>0
    popup_back%=MAX(popup_back%,@getsize(ADD(OB_W(rsc_adr%(popup&),obj&),21),OB_H(rsc_adr%(popup&),obj&)))
    obj&=OB_NEXT(rsc_adr%(popup&),obj&)
  WEND
  popup_back%=@malloc(popup_back%,7)                   ! Hintergrundpuffer...
  IF popup_back%=0
    RETURN FALSE                                       ! ...nicht geklappt
  ENDIF
ENDIF
' ------------------------------------------------------ Anderer Zeichensatz
IF rsc_aes&>=&H400 OR APPL_FIND("?API")=0              ! Hat APPL_GETINFO()...
  '
  GCONTRL(0)=130
  GCONTRL(1)=1
  GCONTRL(2)=5
  GCONTRL(3)=0
  GCONTRL(4)=0
  GINTIN(0)=0
  '
  GEMSYS                                               ! APPL_GETINFO()
  '
  IF GINTOUT(0)=1                                      ! Hat geklappt...
    font_h&=GINTOUT(1)                                 ! AES-Font Hîhe
    font_id&=GINTOUT(2)                                ! AES-Font ID
    '
    IF ABS(font_id&)<>1 AND GDOS?<>0                   ! Anderer AES-Font...
      V~H=rsc_vh&
      ~VST_LOAD_FONTS(0)                               ! ...Fonts laden
      DEFTEXT ,,,,font_id&
      DEFTEXT ,,,font_h&                               ! ...und einstellen
      V~H=-1
    ENDIF
  ENDIF
ENDIF
' ------------------------------------------------------ 3D-Darstellung
IF rsc_aes&>=&H340                                     ! Ab AES 3.40...
  GCONTRL(0)=48
  GCONTRL(1)=4
  GCONTRL(2)=3
  GCONTRL(3)=0
  GCONTRL(4)=0
  '
  GINTIN(0)=0                                          ! Inquire
  GINTIN(1)=5                                          ! Background
  '
  GEMSYS                                               ! OBJC_SYSVAR()
  '
  IF GINTOUT(0)>0                                      ! Hat geklappt...
    color3d&=GINTOUT(1)                                ! ...3D-Farbe
  ENDIF
ENDIF
IF dreidim=0 OR maxcol=2 THEN
  color3d&=0
ELSE
  color3d&=8
ENDIF
' ------------------------------------------------------
INT{ADD(rsc_flyd%,32)}=color3d&>0                      ! 3D-Darstellung an/aus
INT{ADD(rsc_flyd%,34)}=color3d&                        ! 3D-Farbe
' ------------------------------------------------------
IF @rsc_walk_tree(trees&)
  RETURN TRUE                                          ! alles ok
ENDIF
'
RETURN FALSE                                           ! Error!
ENDFUNC
> FUNCTION rsc_walk_tree(trees&)
$F%
.| Glob. Var.: rsc_userblk%,hchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_instal_userdef
.| Aufruf in : rsc_laden-1,
LOCAL a&,b&,userblk&,tree&,obj&,a%
'
' RSC-Baum durchgehen und userdefs installieren...
'
' ------------------------------------------------------ Userdefs ermitteln
FOR tree&=0 TO trees&
'
obj&=-1
'
REPEAT
  '
  INC obj&
  '
  a&=SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)           ! Es ist ein userdef...
  ADD userblk&,-AND(a&>=17,a&<=22)
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! ...bis LAST_OBJ
'
NEXT tree&
'
rsc_userblk%=@malloc(SHL(SUCC(userblk&),3),7)             ! Userblks(+1) anfordern (*8)
IF rsc_userblk%=0                                      ! Zu wenig Speicher...
RETURN FALSE                                         ! ...Error!
ENDIF
a%=rsc_userblk%                                        ! Merken
' ------------------------------------------------------ ObjektbÑume modifiz.
FOR tree&=0 TO trees&
'
obj&=-1
REPEAT
  '
  INC obj&
  '
  SELECT SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)       ! OB_TYPE
    ' ------------------------------------------------ Flydial-Ecke...
  CASE 17
    rsc_instal_userdef(tree&,obj&,5)
    ' ------------------------------------------------ Button/String...
  CASE 18
    '
    a&=OB_FLAGS(rsc_adr%(tree&),obj&)                ! OB_FLAGS
    b&=BYTE(OB_TYPE(rsc_adr%(tree&),obj&))           ! Alter OB_TYPE
    '
    IF BTST(a&,4)                                    ! Radiobutton...
      rsc_instal_userdef(tree&,obj&,1)
      '                                              ! BUTTON, nicht EXIT
    ELSE IF b&=26 AND (NOT BTST(a&,2))               ! Checkbutton...
      rsc_instal_userdef(tree&,obj&,2)
      '
    ELSE                                             ! Normale EXIT-Buttons...
      '
      IF b&<>28                                      ! Kein STRING...
        a&=SUCC(-BTST(a&,1)-BTST(a&,2)-BTST(a&,6))
        IF a&>1 !EXIT       DEFAULT    TOUCHEXIT
          OB_X(rsc_adr%(tree&),obj&)=SUB(OB_X(rsc_adr%(tree&),obj&),a&)
          OB_Y(rsc_adr%(tree&),obj&)=SUB(OB_Y(rsc_adr%(tree&),obj&),a&)
          OB_W(rsc_adr%(tree&),obj&)=ADD(OB_W(rsc_adr%(tree&),obj&),ADD(a&,a&))
          OB_H(rsc_adr%(tree&),obj&)=SUCC(ADD(OB_H(rsc_adr%(tree&),obj&),ADD(a&,a&)))
        ENDIF                                        ! ...fÅr Redraw grîûer
      ENDIF
      '
      rsc_instal_userdef(tree&,obj&,6)
      '
    ENDIF
    ' ------------------------------------------------ Unterstr. Text...
  CASE 19
    rsc_instal_userdef(tree&,obj&,4)
    OB_FLAGS(rsc_adr%(tree&),obj&)=BSET(OB_FLAGS(rsc_adr%(tree&),obj&),13)
    ' ...OB_FLAG 13 setzen, wird in 'rsc_draw' benîtigt
    ' ------------------------------------------------ Rahmen...
  CASE 20
    rsc_instal_userdef(tree&,obj&,3)
    ' ------------------------------------------------ Niceline...
  CASE 21
    rsc_instal_userdef(tree&,obj&,8)
    ' ------------------------------------------------ Circlebutton...
  CASE 22
    IF hchar&=8 OR hchar&=16                         ! ...nur wenn mîglich
      rsc_instal_userdef(tree&,obj&,7)               ! ...als Bitmap
    ELSE
      OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(27,8),BYTE(OB_TYPE(rsc_adr%(tree&),obj&)))
    ENDIF                                            ! ...sonst Pfeil lassen
    '
  ENDSELECT
  '
UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! Bis LAST_OB gesetzt
'
NEXT tree&
'
{rsc_userblk%}=0                                       ! FÅr Nullstrings
rsc_userblk%=a%                                        ! FÅr MFREE() am Ende
'
RETURN TRUE                                            ! Alles OK
ENDFUNC
> PROCEDURE rsc_instal_userdef(tree&,obj&,nr&)
.| Glob. Var.: rsc_userblk%,rsc_flyd%
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_walk_tree-8,
'
' Userdef-Objekt installieren...
'
' nr& bezeichnet eine der folgenden Ausgaberoutinen:
' 1  Radiobutton, rund
' 2  Check-Button
' 3  Rahmen
' 4  Unterstr. Text
' 5  Flydial
' 6  Button
' 7  Circlebutton
' 8  Niceline
'
{rsc_userblk%}=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,SHL(PRED(nr&),1))})
{ADD(rsc_userblk%,4)}=OB_SPEC(rsc_adr%(tree&),obj&)
'
OB_SPEC(rsc_adr%(tree&),obj&)=rsc_userblk%             ! userdef und alter Typ
OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(BYTE(OB_TYPE(rsc_adr%(tree&),obj&)),8),24)
'                                                      ! im oberen Byte
ADD rsc_userblk%,8
'
RETURN
> PROCEDURE rsc_draw(tree&,flag%)
'  LOCAL fly&,title&,obj&,x&,y&,w&,h&,rx&,ry&,rb&,rh&,handle&,a%,rsc_adr%
'
' Stellt einen Dialog auf dem Bildschirm dar...
'
' tree&   : Index des Dialogbaumes
' flag%   : Bitbelegung
'           Bit 0 -> Fensterdialog
'           Bit 1 -> Schlieûfeld
'           Bit 2 -> Bei Fensterdialogen: Sofort zeichnen
'
'
IF flag%=0 THEN
fly=TRUE
ELSE
fly=FALSE
ENDIF
rsc_adr%=rsc_adr%(tree&)
' --------------------------------------------------- Titel & Flugecke suchen
DO WHILE NOT (fly&>0 AND title&>0)
INC obj&
IF BTST(OB_STATE(rsc_adr%,obj&),1)                ! Flugecke...
  fly&=obj&
ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),13)          ! Dialogtitel...
  title&=obj&
ENDIF
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
' --------------------------------------------------- Als Fenster-Dialog
IF BTST(flag%,0)
x&=SUCC(rscx&(tree&))
y&=ADD(ADD(rscy&(tree&),SHL(hchar&,1)),5)
w&=SUB(rscw&(tree&),2)
h&=SUB(SUB(rsch&(tree&),SHL(hchar&,1)),5)
'
IF fly&                                           ! Flugecke hidden...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                 ! Rahmen: 1 Pixel auûen...
OB_SPEC(rsc_adr%,0)=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
'
rx&=OR(&X1001,SHL(-BTST(flag%,1),1))              ! Ggf. Schlieûfeld
handle&=WIND_CREATE(rx&,deskx&,desky&,deskw&,deskh&)
'    ~WIND_SET(handle&,10,handle&,0,0,0)  ! Fenstertitel setzen
IF handle&>0                                      ! Fenster vorhanden...
  '
  ~WIND_UPDATE(1)                                 ! BEG_UPDATE
  '
  INC rsc_window&                                 ! Anz. offene Fenster+1
  '      rsc_menu_ienable(FALSE)                         ! MenÅtitel disablen
  '
  IF title&                                       ! Dialogtitel existiert...
    a%=C:rsc_obspec%(L:rsc_adr%,title&)           ! ...Adresse des Titels
  ELSE
    a%=rsc_userblk%                               ! ...sonst Nullstring
  ENDIF
  ~WIND_SET(handle&,2,INT(SWAP(a%)),INT(a%),0,0)  ! Fenstertitel setzen
  mrkhandle=handle&
  '
  ~WIND_CALC(0,&X1001,x&,y&,w&,h&,rx&,ry&,rb&,rh&)! WC_BORDER
  ~WIND_OPEN(handle&,rx&,ry&,rb&,rh&)
  '
  rsc_handle%(tree&)=handle&
  '
  IF BTST(flag%,2)                                ! Sofort zeichnen...
    rsc_message(tree&,20,x&,y&,w&,h&,0,0)         ! ...redrawen
    REPEAT
      obj&=EVNT_MULTI(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1000)
      IF BTST(obj&,4) AND (MENU(4)<>rsc_handle%(tree&))
        '           message_auswerten(MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
      ENDIF
    UNTIL BTST(obj&,5)                            ! ...bis Timer-Event
  ENDIF
  '
  ~WIND_UPDATE(0)                                 ! END_UPDATE
  '
ENDIF
ENDIF
' --------------------------------------------------- Als normaler Dialog
IF rsc_handle%(tree&)=0
a%=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
OB_SPEC(rsc_adr%,0)=OR(a%,SHL(2,16))              ! Rahmen: 2 Pixel innen
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'                                                 ! Auûerhalb des Screens...
IF rscy&(tree&)<desky& OR ADD(rscx&(tree&),PRED(w&))>ADD(deskx&,PRED(deskw&)) OR ADD(rscy&(tree&),PRED(h&))>ADD(desky&,PRED(deskh&))
  ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                             ! ...wieder in die Mitte
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
'
rsc_list$=rsc_list$+MKI$(tree&)                   ! Dialog in die Liste aufnehmen
'
rsc_handle%(tree&)=@malloc(@getsize(w&,h&),7)
IF rsc_handle%(tree&)                             ! Hintergrund retten...
  rsc_bitblt(0,0,0,rsc_handle%(tree&),w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
  '
ENDIF
'
IF fly&>0 AND rsc_handle%(tree&)>0               ! Flugecke sichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BCLR(OB_FLAGS(rsc_adr%,fly&),7)
ELSE IF fly&                                     ! unsichtbar...
  OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
ENDIF
'                                                ! Zeichnen...
~OBJC_DRAW(rsc_adr%,0,9,rscx&(tree&),rscy&(tree&),w&,h&)
ENDIF
'  mrkhandle=WIND_FIND(x&,y&)
RETURN
> PROCEDURE rsc_menu_ienable(stat!)
.| Glob. Var.: rsc_menu&,rsc_window&,rsc_aes&,rsc_mtsk!,ap_id&
.| Felder    : rsc_adr%(),rscw&()
.| Aufruf in : rsc_draw-1,rsc_back-1,main-1,windows-1,fade-1,arranger-1
.|     trakker-1,abackup-1,makeaback-1,smpedit-3,blkfunc-1,info-1
.|     loopwahl-1,dspwahl-1,
LOCAL obj&,title&,rsc_adr%
'
' Disabled/enabled alle MenÅ-Titel und den 'About...'-MenÅ-Eintrag...
'                                ! Gibt es ein MenÅ..
IF rsc_menu&>-1 AND rsc_window&=1! und ist es das 1. Fenster?
'
rsc_adr%=rsc_adr%(rsc_menu&)
'                              ! Objektbreite verÑndern...
IF stat!                       ! Enablen...
  OB_W(rsc_adr%,2)=rscw&(rsc_menu&)
ELSE                           ! Disablen...
  rscw&(rsc_menu&)=OB_W(rsc_adr%,2)
  OB_W(rsc_adr%,2)=OB_W(rsc_adr%,3)
ENDIF
'
obj&=3                         ! Ersten MenÅtitel Åberspringen
'
REPEAT
  INC obj&
  '                            ! G_TITEL...
  IF BYTE(OB_TYPE(rsc_adr%,obj&))=32
    '
    ~MENU_IENABLE(rsc_adr%,obj&,stat!)
    '
    title&=obj&                ! Wird fÅr 'About...' gebraucht
  ENDIF
  '
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
'                              ! 'About...' dis/enablen
~MENU_IENABLE(rsc_adr%,ADD(title&,3),stat!)
'                              ! Unter MultiTOS...
IF (rsc_aes&>=&H400) AND rsc_mtsk!
  ' zzz=MENU_BAR(rsc_adr%,-1)
  ' IF ap_id&=zzz THEN
  ~MENU_BAR(rsc_adr%,1)      ! ...Menu nur neu anzeigen, wenn erlaubt
  ' ENDIF
ELSE                           ! Unter SingleTOS...
  ~MENU_BAR(rsc_adr%,1)        ! ...Menu immer neu anzeigen
ENDIF
'
ENDIF
'
RETURN
> FUNCTION rsc_do(tree&,next_obj&,VAR popup&)
$F%
.| Glob. Var.: obj#,donr#,nr#,edit_obj&,idx&,tim&,mx&,my&,mb&,shift&,c#
.|     shcut#,winh#,smp16&,peak&,editfade&,smpedit&,digana#,xd#,xm#,ce#,cs#
.|     stay1#,stay2#,show#,showdat#,tedart#,hz#,showbdat#,shw$,showxy&
.|     butdirect#,othernr#
.| Felder    : rsc_handle%(),rsc_adr%()
.| Ruft auf  : message,drop,button,key,drop2,edhandler,peakread,fadehandler
.|     maketime,edhandler3,textfeld
.| Aufruf in : rsc_alert-1,windows-1,normalize-1,fade-1,smptime-1
.|     movefrag-1,smpsave-1,blklfrag-1,newfsel-1,sampleinf-1,resample-1
.|     arrsmpr-1,arrdelay-1,arrmname-1,virtual-1,abackup-1,time_edit-1
.|     make-1,setupdat-1,conspace-1,midi-1,
LOCAL a&,handle&,a$,c
LOCAL cont&,ob_tail&,obj&,flags&,rsc_adr%,keytab%
LOCAL ascii|,scan|,evnt&,mc&,key&
'
' Dialog auswerten...
'
obj=0
donr=nr
'
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(1)                                      ! ...BEG_UPDATE
~WIND_UPDATE(3)                                      ! ...BEG_MCTRL
flags&=&X11                                          ! ...BUTTON/KEYBD-Events
'
ELSE                                                   ! Fenster-Dialog...
flags&=&X110011                                      ! ...zus. MESSAGE-Events
ENDIF
'
'
rsc_adr%=rsc_adr%(tree&)
cont&=TRUE
' ------------------------------------------------------ Editierbares Objekt
DO WHILE (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3)) OR BTST(OB_STATE(rsc_adr%,next_obj&),3)
INC next_obj&
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,next_obj&),5)
IF BTST(OB_FLAGS(rsc_adr%,next_obj&),5) AND (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3))
next_obj&=0
ENDIF
' ------------------------------------------------------
'
IF cont&<>0 AND (next_obj&<>0 AND edit_obj&<>next_obj&)             ! Ggf. Cursor setzen...
edit_obj&=next_obj&                                ! ...Exit-Code zurÅck
next_obj&=0                                        ! ...'rsc_do' verlassen
~OBJC_EDIT(rsc_adr%,edit_obj&,27,idx&,1,idx&)       ! ...Cursor ein
ENDIF
'
next_obj&=0
tim&=20   ! EVENT-TIMER in msec
REPEAT
c=0
evnt&=EVNT_MULTI(flags&,2,1,1,0,0,0,0,0,0,0,0,0,0,0,tim&,mx&,my&,mb&,shift&,key&,c)
'
IF BTST(evnt&,4) THEN
@message
@wischwasch
obj=0
ENDIF
IF BTST(evnt&,1) THEN
@button
ENDIF
IF BTST(evnt&,0) THEN
@key
IF obj&<>0 AND mb&=1 THEN
  @button
ENDIF
ENDIF
'
IF BTST(evnt&,5) THEN
IF nr=mode& THEN
  @moderead
ENDIF
IF nr=devco& THEN
  @devcoread
ENDIF
IF nr=status& THEN
  @statread
ENDIF
ENDIF
'
IF mc&=2 AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6)      ! Doppelklick auf
next_obj&=WORD(BSET(next_obj&,15))                   ! TOUCHEXIT...
ENDIF
UNTIL (next_obj&>0 OR donr<>nr)
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(0)                                      ! END_UPDATE
~WIND_UPDATE(2)                                      ! END_MCTRL
ENDIF
IF donr<>nr AND butdirect=FALSE THEN
next_obj&=0
ENDIF
othernr=FALSE
rsc_do_ende:
RETURN next_obj&
ENDFUNC
> FUNCTION rsc_popup(a!,tree&,button&,popup&,def&)
$F%
.| Glob. Var.: rsc_popup&,hchar&,popup_back%,rsc_vh&,wchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_text
.| Aufruf in : button-2,
LOCAL x&,y&,b&,h&,m!
LOCAL evnt&,mx&,my&,mb&,shift&,key&,mc&,ascii|,scan|
LOCAL obj&,old_obj&,first&,anz&
LOCAL rsc&,rsc_adr%
'
' Popup-MenÅ darstellen und auswerten...
'
' a!       : TRUE: Button verÑndern, FALSE: Nur Popup
' tree&    : Index des Dialogbaumes
' button&  : Objektnr. des betÑtigten Buttons
' popup&   : Index des Popups
' def&     : Default-Eintrag (1-x)
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~WIND_UPDATE(3)                                   ! BEG_MCTRL
'
rsc_adr%=rsc_adr%(rsc_popup&)
'
first&=OB_HEAD(rsc_adr%,popup&)                   ! erster Eintrag
anz&=SUB(OB_TAIL(rsc_adr%,popup&),first&)         ! Anzahl EintrÑge-1
' ------------------------------------------------- Popup positionieren
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)
OB_X(rsc_adr%,0)=SUB(x&,OB_X(rsc_adr%,popup&))
OB_Y(rsc_adr%,0)=MAX(ADD(hchar&,4),MIN(SUB(WORK_OUT(1),4)-OB_H(rsc_adr%,popup&),SUB(y&,MUL(def&,hchar&))))-OB_Y(rsc_adr%,popup&)
'
x&=ADD(OB_X(rsc_adr%,0),PRED(OB_X(rsc_adr%,popup&)))
y&=ADD(OB_Y(rsc_adr%,0),PRED(OB_Y(rsc_adr%,popup&)))
b&=ADD(OB_W(rsc_adr%,popup&),4)
h&=ADD(OB_H(rsc_adr%,popup&),4)
' -------------------------------------------------
'
rsc_bitblt(0,0,0,popup_back%,b&,h&,x&,y&,b&,h&,0,0)
'
~OBJC_DRAW(rsc_adr%,0,7,x&,y&,b&,h&)              ! Popup zeichnen
'
IF a!                                             ! Button verÑndern...
'
~GRAF_MOUSE(256,0)                              ! Hidem
V~H=rsc_vh&                                     ! ...Default-Eintrag mit...
GRAPHMODE 2
'
INTIN(0)=8                                      ! ...HÑkchen versehen
PTSIN(0)=ADD(x&,DIV(wchar&,2))
PTSIN(1)=y&-DIV(hchar&,6)+MUL(SUCC(def&),hchar&)
VDISYS 8,1,1                                    ! ...v_gtext()
'
GRAPHMODE 1
V~H=-1
~GRAF_MOUSE(257,0)                              ! Showm
'
ENDIF
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)      ! Objekt unter der Maus...
'
IF obj&<=0                                        ! Daneben...
obj&=ADD(first&,def&)                           ! ...Default-Eintrag nehmen
ENDIF
'
old_obj&=obj&
IF (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))   ! Nicht disabled...
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
ENDIF                                             ! ...selektieren
'
~EVNT_TIMER(200)
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
IF mb&=1
m!=TRUE
evnt&=4
ENDIF
'
' --------------------------------------------------
DO
'
IF NOT m!
evnt&=EVNT_MULTI(&X111,1,1,1,1,mx&,my&,1,1,0,0,0,0,0,0,0,mx&,my&,mb&,shift&,key&,mc&)
ELSE
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
ENDIF
'
IF BTST(evnt&,0)                                 ! Tastaturereignis...
ascii|=BYTE(key&)
scan|=BYTE(SHR(key&,8))
'                                              ! Noch kein sel. Eintrag...
IF NOT (obj&>=first& AND obj&<=ADD(first&,anz&))
obj&=first&
'
ELSE IF scan|=80                               ! ...Cursor runter
INC obj&
IF obj&>ADD(first&,anz&)
  obj&=first&
ENDIF
'
ELSE IF scan|=72                               ! ...Cursor runter
DEC obj&
IF obj&<first&
  obj&=ADD(first&,anz&)
ENDIF
'
ENDIF
'
ENDIF
'
IF BTST(evnt&,2)                                 ! Mausereignis...
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)
ENDIF
'                                                ! Alten Eintrag deselekt...
IF obj&<>old_obj&
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),1)
ENDIF
'                                                ! Im MenÅ und nicht disabled...
IF (obj&>=first& AND obj&<=ADD(first&,anz&)) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
'                                              ! ...neuen selektieren
old_obj&=obj&
rsc&=SUB(obj&,first&)                          ! RÅckgabe
ENDIF
'
LOOP UNTIL BTST(evnt&,1) OR (mb&<>1 AND m!) OR ascii|=13 OR ascii|=27 OR scan|=97
' --------------------------------------------------
rsc_bitblt(popup_back%,b&,h&,0,0,0,0,0,b&,h&,x&,y&)! Hintergrund restaurieren
'
IF rsc&=SUB(obj&,first&) AND scan|<>97 AND ascii|<>27 ! Eintrag ausgewÑhlt...
'
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,obj&),0),0)
'
IF a!                                            ! Button verÑndern...
'                                              ! Neuen Text eintragen:
rsc_text(tree&,button&,@rsc_text$(rsc_popup&,obj&))
'
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)    ! Button zeichnen
~OBJC_DRAW(rsc_adr%(tree&),button&,1,x&,y&,OB_W(rsc_adr%(tree&),button&),OB_H(rsc_adr%(tree&),button&))
'
ENDIF
'
ELSE                                               ! Daneben => Abbruch...
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),0)
'
rsc&=-1                                          ! ...Abbruch markieren
'
ENDIF
'
REPEAT
~GRAF_MKSTATE(mx&,my&,mb&,shift&)                ! Mausknopf 'entprellen'
UNTIL mb&=0
'
~WIND_UPDATE(2)                                    ! END_MCTRL
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN SUCC(rsc&)
ENDFUNC
> PROCEDURE rsc_message(tree&,message&,x&,y&,w&,h&,edit_obj&,idx&)
.| Glob. Var.: wchar&,hchar&
.| Felder    : rsc_handle%(),rsc_adr%(),rscx&(),rscy&()
.| Ruft auf  : rsc_cursor
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,message-2,rsc_draw-1
.|     rsc_back-1,rsc_redraw_obj-1,main-1,fade-1,arranger-1,trakker-1
.|     blkfunc-1,info-1,loopwahl-1,peak-1,
LOCAL a|,ax&,ay&,ab&,ah&,handle&,obj&,rsc_adr%,a%,a$
'
' Wertet ein innerhalb des 'rsc_do' eingetroffenes Message-Ereignis aus...
'
handle&=rsc_handle%(tree&)                         ! Fensterhandle des Dialogs
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
SELECT message&
' --------------------------------------------------------------------------
CASE 20,21                                         ! WM_REDRAW/WM_TOPPED
IF message&=20                                   ! WM_REDRAW...
~GRAF_MOUSE(256,0)                           ! Hidem
~WIND_GET(handle&,11,ax&,ay&,ab&,ah&)          ! 1. Rechteck
'
REPEAT
'
IF RC_INTERSECT(x&,y&,w&,h&,ax&,ay&,ab&,ah&) ! ...redrawen
  ~OBJC_DRAW(rsc_adr%(tree&),0,7,ax&,ay&,ab&,ah&)
ENDIF
'
~WIND_GET(handle&,12,ax&,ay&,ab&,ah&)        ! NÑchstes Rechteck...
UNTIL ab&=0 AND ah&=0                          ! ...kein Redraw mehr nîtig
'
~GRAF_MOUSE(257,0)                           ! Showm
'
ELSE                                             ! WM_TOPPED...
~WIND_SET(handle&,10,0,0,0,0)                  ! ...toppen
ENDIF
'
~WIND_GET(0,10,ax&,ay&,ay&,ay&)                  ! Oberstes Fenster...
IF ax&=handle& AND edit_obj&>0                   ! Ist das unsrige...
' ---------------------------------------------- Cursor-Setz-Orgie...
rsc_adr%=rsc_adr%(tree&)
'
obj&=edit_obj&                                 ! Parent ermitteln...
'
REPEAT
obj&=OB_NEXT(rsc_adr%,obj&)
UNTIL obj&<edit_obj&
'
~OBJC_OFFSET(rsc_adr%,edit_obj&,ax&,ay&)       ! Koordinaten des Objekts
'
a$=CHAR{{ADD(OB_SPEC(rsc_adr%,edit_obj&),4)}}  ! Maske: "Eingabe:______"
ah&=1
WHILE MID$(a$,ah&,1)<>"_"                      ! LÑnge des Vortextes...
INC ah&
WEND                                           ! ...ermitteln
'
ADD ax&,MUL(wchar&,ADD(PRED(ah&),idx&))        ! Cursor-Position im Pixeln
ah&=ADD(OB_H(rsc_adr%,edit_obj&),6)            ! Cursor ist grîûer hchar&
'                                              ! Cursor lîschen...
~OBJC_DRAW(rsc_adr%,obj&,7,ax&,SUB(ay&,3),wchar&,ah&)
rsc_cursor(rsc_adr%,edit_obj&,idx&)            ! ...und setzen
'
ENDIF
' --------------------------------------------------------------------------
CASE 28                                            ! WM_MOVED
~WIND_CALC(1,&X1001,x&,y&,w&,h&,ax&,ay&,ab&,ah&)
'
rscx&(tree&)=PRED(ax&)
rscy&(tree&)=SUB(SUB(ay&,5),MUL(hchar&,2))
OB_X(rsc_adr%(tree&),0)=ADD(rscx&(tree&),3)
OB_Y(rsc_adr%(tree&),0)=ADD(rscy&(tree&),3)
'
~WIND_SET(handle&,5,x&,y&,w&,h&)
'
ENDSELECT
'
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN
> PROCEDURE rsc_back(tree&)
.| Glob. Var.: rsc_window&,nr#,smp16&,blkfunc&,peak&,loop&,editfade&
.|     arranger&,info&,trakker&,smpedit&,edit_obj&,idx&,rsc_list$
.| Felder    : rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&(),rsc_adr%()
.| Ruft auf  : rsc_menu_ienable,rsc_message,rsc_bitblt
.| Aufruf in : rsc_alert-1,goodbye-1,normalize-1,blklfrag-1,newfsel-4
.|     restaura2-1,restaura2b-1,sampleinf-1,resample-1,make-1,conspace-1
.|     memtovirt2-1,
'
' Entfernt den Dialog vom Bildschirm...
'
' ---------------------------------------------------- Als Fenster-Dialog
fly=FALSE
IF rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
'    rsc_menu_ienable(TRUE)                             ! ...MenÅ wieder wÑhlbar
'
IF rsc_window&                                     ! Fenster existiert...
'
~WIND_CLOSE(rsc_handle%(tree&))
~WIND_DELETE(rsc_handle%(tree&))                 ! ...schlieûen & abmelden
'
DEC rsc_window&                                  ! Anz. offene Fenster-1
'
ELSE                                               ! Sonst Redraw auslîsen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF
' -------------------------------------------------- Als normaler Dialog
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
IF rsc_window&>0 THEN
'      rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
ELSE
rsc_list$=LEFT$(rsc_list$,SUB(LEN(rsc_list$),2))   ! Dialog aus der Liste entf.
'
IF rsc_handle%(tree&)                              ! Hintergrund gerettet...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~MFREE(rsc_handle%(tree&))
'
ELSE                                               ! Desktop redrawen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
IF rsc_list$<>""                                 ! Noch ein Dialog drunter...
~OBJC_DRAW(rsc_adr%(CVI(RIGHT$(rsc_list$,2))),0,7,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                            ! ...diesen auch redrawen
ENDIF
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
ENDIF
RETURN
> PROCEDURE rsc_text(tree&,obj&,a$)
.| Aufruf in : button-1,rsc_popup-1,rsc_alert-2,
'
' Universelle Objekt-Text Belegung...
'
CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}=a$
RETURN
> PROCEDURE rsc_bitblt(a%,w&,h&,b%,rb&,rh&,ax&,ay&,ab&,ah&,gx&,gy&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : rsc_draw-1,rsc_popup-2,rsc_back-1,rsc_movedial-3
.|     rsc_flipping-23,
'
' Universeller Raster-Kopierer (benutzt vro_cpyfm oder vrt_cpyfm)...
'
IF ab&>0 AND ah&>0                 ! Breite und Hîhe vorhanden...
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:a%,w&,h&,0,planes&,L:b%,rb&,rh&,0,planes&,ax&,ay&,ab&,ah&,gx&,gy&,1)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_cursor(rsc_adr%,edit_obj&,idx&)
.| Aufruf in : rsc_message-1,rsc_movedial-1,
LOCAL a|,a%
'
' Zeichengenaue Positionierung des Cursors...
'
a%=ADD({OB_SPEC(rsc_adr%,edit_obj&)},idx&)
'
a|=BYTE{a%}                                        ! Zeichen merken
BYTE{a%}=0                                         ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)       ! Cursor setzen
BYTE{a%}=a|                                        ! ...Zeichen restaurieren
'
RETURN
> PROCEDURE busy_mouse
.| Glob. Var.: m_adr%,m_busy%
.| Aufruf in : HAUPTPROGRAMM-1,maschruf-1,maschruf2-1,maschinit2b-1
.|     maschruf3-1,maschruf3b-1,maschruf5-1,maschinit5b-1,maschruf5c-1
.|     maschruf6-1,maschruf8-1,maschruf8b-1,maschruf9-1,maschruf10-1
.|     maschruf11-1,maschruf12-1,maschruf13-1,maschruf16-1,maschruf17-1
.|     maschruf18b-1,maschruf18c-1,maschruf28-1,maschruf29-1,maschruf30-1
.|     maschruf31b-1,maschruf32-1,maschruf33-1,maschruf34-1,maschruf35-1
.|     maschruf36-1,maschruf37-1,maschruf38-1,fade_it-7,smpkhlp-1,smpihlp-5
.|     smpcut-3,virtmove-7,virtcopy-2,virtins-4,putpix-3,edhandler2-7
.|     smpsave-2,ldhlp-1,sampleinf-1,trakload-1,arrinsert-1,arrdelete-1
.|     hardfs-1,hardproof2-2,rettmem-1,arrload-1,arrsave-1,make-3,trash-2
.|     setload-1,setsave-1,fseldef-1,conspace-1,coninsert-4,mono-3,negate-3
.|     lrchange-3,springart-1,
' Eine Busy-Maus in der Form eines kleines Balles...
'
IF m_adr%=ADD(m_busy%,518)
m_adr%=m_busy%
'
ELSE
ADD m_adr%,74
ENDIF
'
~GRAF_MOUSE(255,m_adr%)
'
RETURN
> FUNCTION malloc(b%,c%)
LOCAL g,a%
IF gemvers>=&H1900 THEN
a%=@mxalloc(b%,3)     ! Buffer anfordern
IF a%<=0 THEN
a%=MALLOC(b%)       ! Buffer anfordern
ENDIF
ELSE
a%=MALLOC(b%)         ! Buffer fÅr Trakker-Caches
ENDIF
IF a%<=0 THEN
IF (c% AND 3)=1 THEN
@alerts(3)
ENDIF
IF (c% AND 3)=2 THEN
@alerts(4)
ENDIF
IF (c% AND 7)=3 THEN
@alerts(5)
ENDIF
IF (c% AND 7)=7 THEN
@alerts(6)
ENDIF
IF (g=2 AND (c% AND 7)=7) OR (c% AND 4)=4 THEN
@goodbye
ENDIF
ENDIF
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION rsc_get(x&,y&,w&,h&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : fseldef-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%,b%,g
'
b%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
a%=@malloc(b%,1)         ! Buffer fÅr Trakker-Caches
'
IF a%>0 THEN                       ! Hat geklappt...
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
'                                ! Kopieren...
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION rsc_get2(x&,y&,w&,h&,md%)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-3,dragging2-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%
a%=md%                           ! Speicher anfordern
IF a%>0 THEN
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> PROCEDURE rsc_put(a%,x&,y&,m&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&
'
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,0,0,w&,h&,x&,y&,m&)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_put2(a%,x&,y&,m&,sx,bx)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&
'
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,sx,0,bx,h&,x&,y&,m&)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> FUNCTION rsc_len(w&,h&)
LOCAL a%
'
a%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
' ------------------------------------------------------------------------------
' ------------------------INTERFACE-FARBICONS-----------------------------------
' ------------------------------------------------------------------------------
'
' ************************************************************************
' **                        XRSRC-Routinen                              **
' ************************************************************************
> FUNCTION xrsrc_init
LOCAL a%,tl%,dl%,bl%,p$
'
' Initialisierungsroutine fÅr die Xrsrc-Routinen
' XRSRC-Routinen Copyright (c)1992 Olaf Meisiek
'
' -----------------------------------------------------------
INLINE xrsrc%,9423
INLINE relo%,94
'
f.base%=GEMDOS(75,5,L:0,L:0,L:0)     ! CREATE BASEPAGE
'
IF f.base%<=0
RETURN FALSE                       ! ERROR!
ENDIF
'
tl%={xrsrc%+2}                       ! LÑnge TEXT
dl%={xrsrc%+6}                       ! LÑnge DATA
bl%={xrsrc%+10}                      ! LÑnge BSS
'
{f.base%+8}=f.base%+256              ! Adresse TEXT
{f.base%+16}={f.base%+8}+{xrsrc%+2}  ! Adresse DATA
{f.base%+24}={f.base%+16}+{xrsrc%+6} ! Adresse BSS
'
{f.base%+12}=tl%                     ! LÑnge TEXT
{f.base%+20}=dl%                     ! LÑnge DATA
{f.base%+28}=bl%                     ! LÑnge BSS
'
' {f.base%+32}=dta%                  ! Addresse DTA
'
BMOVE xrsrc%+28,f.base%+256,9423-28  ! Relozieren...
~C:relo%(L:f.base%+256,L:tl%,L:dl%,L:INT{xrsrc%+14})
'
~MSHRINK(f.base%,256+tl%+dl%+bl%)
' -----------------------------------------------------------
f.init%={f.base%+8}
'
p$=STRING$(100,0)
{f.init%+4}=V:p$
'
$C+
a%=C:f.init%(L:f.base%)              ! Initialisierung
$C-
'
IF a%=0                              ! Hat geklappt...
f.scalc%={f.init%+42}
'
WORD{f.init%+4+36}=128             ! Nummer der Function
$C+
r%=C:f.scalc%()
$C-
'
RETURN TRUE
ENDIF
'
RETURN FALSE                         ! ERROR!
ENDFUNC
> PROCEDURE xrsrc_exit
'
WORD{f.init%+4+36}=129          ! Nummer der Funktion
$C+
r%=C:f.scalc%()
$C-
'
~MFREE(f.base%)
'
RETURN
> FUNCTION xrsrc_load(file$)
LOCAL r%
'
file$=file$+CHR$(0)
'
WORD{f.init%+4+36}=1          ! Nummer der Funktion
'
{f.init%+4+16}=V:file$
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_free
LOCAL r%
'
WORD{f.init%+4+36}=2          ! Nummer der Function
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_gaddr(re_gtype&,re_gindex&,VAR re_gaddr%)
LOCAL r%
'
WORD{f.init%+4+36}=3          ! Nummer der Funktion
'
WORD{f.init%+4+0}=re_gtype&
WORD{f.init%+4+2}=re_gindex&
'
{f.init%+4+16}=V:re_gaddr%
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_saddr(re_gtype&,re_gindex&,VAR re_gaddr%)
LOCAL r%
'
WORD{f.init%+4+36}=4          ! Nummer der Funktion
'
WORD{f.init%+4+0}=re_gtype&
WORD{f.init%+4+2}=re_gindex&
'
{f.init%+4+16}=V:re_gaddr%
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
> FUNCTION xrsrc_obfix(re_gaddr%,re_obj&)
LOCAL r%
'
WORD{f.init%+4+36}=5          ! Nummer der Funktion
'
WORD{f.init%+4+0}=re_obj&
'
{f.init%+4+16}=re_gaddr%
'
$C+
r%=C:f.scalc%()
$C-
'
RETURN r%
ENDFUNC
'
' ------------------------------------------------------------------------------
' ------------------------ENHANCED-FLYDIALS-------------------------------------
' ------------------------------------------------------------------------------
DEFFN rsc_flags(tree&,obj&,bit&)=BTST(OB_FLAGS(rsc_adr%(tree&),obj&),bit&)
DEFFN rsc_state(tree&,obj&,bit&)=BTST(OB_STATE(rsc_adr%(tree&),obj&),bit&)
> FUNCTION form_keybd(rsc_adr%,edit_obj&,key&,a&,VAR next_obj&,key_back&,idx&)
.| Ruft auf  : form_search_flag
.| Aufruf in : key-1,
' ZusÑtzliche Tastaturkommandos...
' Einfach FORM_KEYBD in 'rsc_do' durch @form_keybd ersetzen.
$F%
LOCAL scan|,cont&
'
' Ersetzt FORM_KEYBD()...
'
key_back&=0
cont&=1
'
SELECT key&
'
' ------------------------------------------------- SHIFT right
CASE &H4D36
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
' ------------------------------------------------- SHIFT left
CASE &H4B34
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
'
a&=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=0
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=a&
'
' ------------------------------------------------- Cursor runter
CASE &H5000
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
' ------------------------------------------------- Cursor rauf
CASE &H4800
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,-1)
' ------------------------------------------------- SHIFT runter/HOME
CASE &H5032,&H4737                                  ! =>letztes Feld
REPEAT
next_obj&=edit_obj&
edit_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
UNTIL edit_obj&=0
' ------------------------------------------------- SHIFT rauf, HOME
CASE &H4838,&H4700                                  ! =>erstes Feld
next_obj&=@form_search_flag(rsc_adr%,0,3,1)
' ------------------------------------------------- HELP/UNDO
CASE &H6200,&H6100
key_back&=key&
' ------------------------------------------------- Alles andere
DEFAULT
scan|=BYTE(SHR(key&,8))                           ! SCAN-Code
'
IF BYTE(key&)>0 OR scan|=75 OR scan|=77           ! Cursor rauf/runter
cont&=FORM_KEYBD(rsc_adr%,edit_obj&,key&,0,next_obj&,key&)
'                                               ! Kein Ende&TAB u. EDITABLE
IF cont&>0 AND BYTE(key&)<>9 AND BTST(OB_FLAGS(rsc_adr%,edit_obj&),3)
'
scan|=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)+8}+idx&}! Maske 'A' oder 'N'...
IF scan|=65 OR (scan|=78 AND (BYTE(key&)<48 OR BYTE(key&)>57))
key&=BCLR(key&,5)                             ! ...Groûschrift setzen
ENDIF
'
~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,2,idx&) ! ...Eingabe
ENDIF
'
ELSE
key_back&=key&
ENDIF
'
ENDSELECT
'
RETURN cont&
ENDFUNC
> FUNCTION form_search_flag(rsc_adr%,obj&,flag&,step&)
$F%
.| Aufruf in : form_keybd-4,
'
' Unterroutine fÅr form_keybd. Sucht das nÑchste/vorhergehende Objekt mit
' dem gesetzten Bit 'flag&' in OB_FLAGS...
'
' Sonderfall: Letztes Objekt ist edierbar, Cursor runter:
IF NOT (BTST(OB_FLAGS(rsc_adr%,obj&),5)=TRUE AND step&>0)
'
REPEAT
ADD obj&,step&
'
IF BTST(OB_FLAGS(rsc_adr%,obj&),flag&) AND (NOT BTST(OB_STATE(rsc_adr%,obj&),3))
RETURN obj&
ENDIF
UNTIL (obj&<=0) OR BTST(OB_FLAGS(rsc_adr%,obj&),5)
'
ENDIF
'
RETURN 0
ENDFUNC
> PROCEDURE rsc_movedial(tree&,edit_obj&,idx&)
.| Glob. Var.: deskx&,deskw&,desky&,deskh&
.| Felder    : rscw&(),rsch&(),rscx&(),rscy&(),rsc_handle%(),rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_flipping,rsc_cursor
.| Aufruf in : button-1,
' SOLID Flydials...
' Einfach die Prozedur 'rsc_movedial' ersetzen.
LOCAL x&,y&,w&,h&,fx&,fy&,mx&,my&,mb&,shift&,rsc%
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'
~GRAF_MKSTATE(mx&,my&,x&,y&)
' Nicht zusÑtzl. rechte Maustaste oder SHIFT/CONTROL/ALT...
IF NOT (x&=3 OR AND(y&,&X1111)>0)
rsc%=@malloc(@getsize(w&,h&),7)                    ! Dialog retten
ENDIF
IF rsc%                                           ! Hat geklappt...
rsc_bitblt(0,0,0,rsc%,w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
ENDIF
'
~GRAF_MOUSE(4,0)                                  ! FLAT_HAND
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
fx&=SUB(mx&,SUCC(rscx&(tree&)))                   ! Relativer Mausfaktor
fy&=SUB(my&,SUCC(rscy&(tree&)))
'
mx&=rscx&(tree&)
my&=rscy&(tree&)
' ------------------------------------------------- Bewegen
IF rsc%                                           ! SOLID...
REPEAT
'
~GRAF_MKSTATE(x&,y&,mb&,shift&)
'
x&=SUB(PRED(x&),fx&)
y&=SUB(PRED(y&),fy&)                          ! Clipping...
x&=MIN(MAX(x&,deskx&),SUB(ADD(deskx&,deskw&),w&))
y&=MIN(MAX(y&,desky&),SUB(ADD(desky&,deskh&),h&))
'
IF mx&<>x& OR my&<>y&
rsc_flipping(rsc_handle%(tree&),rsc%,mx&,my&,w&,h&,x&,y&)
mx&=x&
my&=y&
'
ENDIF
'
UNTIL mb&=0
'
~MFREE(rsc%)
'
ELSE                                              ! Nicht SOLID...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~GRAF_DRAGBOX(rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),deskx&,desky&,deskw&,deskh&,x&,y&)
ENDIF
' ------------------------------------------------- Hinsetzen
rscx&(tree&)=x&
rscy&(tree&)=y&
OB_X(rsc_adr%(tree&),0)=ADD(x&,3)
OB_Y(rsc_adr%(tree&),0)=ADD(y&,3)
'
IF rsc%=0                                         ! Nicht SOLID...
rsc_bitblt(0,0,0,rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
~OBJC_DRAW(rsc_adr%(tree&),0,10,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
'
IF edit_obj&
rsc_cursor(rsc_adr%(tree&),edit_obj&,idx&)    ! ...Cursor ein
ENDIF
ENDIF
'
~GRAF_MOUSE(0,0)
'
RETURN
> PROCEDURE rsc_flipping(rsc_back%,rsc%,ax&,ay&,w&,h&,x&,y&)
.| Ruft auf  : rsc_bitblt
.| Aufruf in : rsc_movedial-1,
LOCAL rb&,rh&,gw&,gh&
'
gw&=ABS(SUB(x&,ax&))         ! Verschiebbreite
gh&=ABS(SUB(y&,ay&))         ! Verschiebhîhe
rb&=SUB(w&,gw&)              ! Restbreite
rh&=SUB(h&,gh&)              ! Resthîhe
'
IF rb&<0 OR rh&<0            ! rsc% auûerhalb von rsc_back%
'
' Gesamten Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,h&,ax&,ay&)
'
' Gesamten Dialog aktualisieren -----
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,h&,0,0)
'
ELSE IF x&>ax&               ! nach rechts...
'
IF y&>ay&                  ! nach rechts-unten veschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,gh&,gw&,rh&,ax&,ADD(ay&,gh&))
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,gh&,ax&,ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,gh&,rb&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),rb&,gh&,0,rh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ELSE                      ! nach rechts-oben / rechts verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,gw&,rh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,0,rb&,rh&,0,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,rb&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ENDIF
'                         ! nach links / oben / unten...
ELSE IF y&>ay&              ! nach links-unten / unten verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,rb&,gh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,h&,ADD(ax&,rb&),ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,gh&,rb&,rh&,gw&,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,gw&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),w&,gh&,0,rh&)
'
ELSE                        ! nach links-oben / links / oben verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,rh&,ADD(ax&,rb&),ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,0,rb&,rh&,gw&,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,gh&),gw&,rh&,0,gh&)
'
ENDIF
'
rsc_bitblt(rsc%,w&,h&,0,0,0,0,0,w&,h&,x&,y&)
'
RETURN
> PROCEDURE rsc_set_cursor(rsc_adr%,mx&,my&,VAR edit_obj&,next_obj&,idx&)
.| Glob. Var.: wchar&
.| Aufruf in : button-1,
' Zeichengenaues Cursor-Positionieren mit der Maus...
' Nur die entsprechenden 2 Zeilen in 'rsc_do' (ziemlich am Ende) entREMen.
LOCAL x&,a&,i&,ob_spec%,a$
'
ob_spec%=OB_SPEC(rsc_adr%,next_obj&)
'
~OBJC_OFFSET(rsc_adr%,next_obj&,x&,a&)          ! Absolute X-Position
'
x&=DIV(SUB(mx&+SHR(wchar&,2),x&),wchar&)        ! Spaltenposition
'
a$=CHAR{{ADD(ob_spec%,4)}}                      ! Maske lesen
'
FOR a&=1 TO x&                                  ! Pos. im Eingabefeld...
IF MID$(a$,a&,1)="_"
INC i&                                      ! ...nur relevante
ENDIF
NEXT a&
SUB x&,(x&-i&)
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)    ! Cursor aus
'
ob_spec%=ADD({ob_spec%},x&)
'
a&=BYTE{ob_spec%}                               ! Zeichen merken
BYTE{ob_spec%}=0                                ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,next_obj&,0,idx&,1,idx&)    ! Cursor setzen
BYTE{ob_spec%}=a&                               ! ...und Zeichen restaurieren
'
edit_obj&=next_obj&
'
RETURN
> FUNCTION rsc_shortcut(tree&,scan|,shift&,VAR title&)
.| Felder    : rsc_adr%()
.| Aufruf in : key-1,
' MenÅshortcut ermitteln...
$F%
LOCAL a&,obj&,rsc_adr%,s$,t$
'
' tree&      : Index des MenÅbaumes
' scan|      : SCAN-Code der gedrÅckten Taste
' shift&     : Status der tastaturumschalttasten
' VAR title& : Bei Erfolg Objektnummer des MenÅtitels
'
SELECT scan|
CASE 2 TO 10                                   ! 1-2...
s$=CHR$(ADD(47,scan|))
CASE 15                                        ! TAB...
s$="I"
shift&=BSET(shift&,2)                        ! ...entspricht "^I"
'
CASE 59 TO 68,84 TO 93                         ! Ftasten...
IF scan|<84
s$="F"+STR$(SUB(scan|,58))                 ! ...normal
ELSE
s$="F"+STR$(SUB(scan|,83))                 ! ...mit Shift
ENDIF
CASE 71                                        ! ClrHome...
s$="CLR"
CASE 83                                        ! DELETE...
s$="DEL"
CASE 97                                        ! UNDO...
s$="UNDO"
CASE 98                                        ! HELP...
s$="HELP"
DEFAULT                                        ! Alles andere...
rsc_adr%={XBIOS(16,L:-1,L:-1,L:-1)}
s$=CHR$(BCLR(BYTE{ADD(rsc_adr%,scan|)},5))
ENDSELECT
'
IF BTST(shift&,3)                              ! Alternate...
s$=CHR$(7)+s$
ENDIF
IF BTST(shift&,2)                              ! Control...
s$="^"+s$
ENDIF
IF BTST(shift&,0) OR BTST(shift&,1)            ! Shift...
s$=CHR$(1)+s$
ENDIF
'
title&=2                                       ! Position des Titels
obj&=5                                         ! Beginn der eigentl. MenÅs
rsc_adr%=rsc_adr%(tree&)                       ! öbersichtlicher
'
REPEAT                                         ! alle Objekte d. MenÅbaums
INC obj&
'
IF BYTE(OB_TYPE(rsc_adr%,obj&))=28           ! G_STRING...
IF NOT BTST(OB_STATE(rsc_adr%,obj&),3)     ! disabled ?
'
t$=TRIM$(CHAR{OB_SPEC(rsc_adr%,obj&)})   ! MenÅpunkt-Text
'
a&=RINSTR(t$," ")
IF a&                                    ! Shortcut vorhanden ?
'
IF MID$(t$,SUCC(a&))=s$                ! hier der vermutete Shortcut
RETURN obj&                          ! gefunden
ENDIF
'
ENDIF
ENDIF
'
ELSE IF BYTE(OB_TYPE(rsc_adr%,obj&))=20      ! G_STRING ?
INC title&
ENDIF
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)          ! LAST_OB ?
'
title&=0
RETURN 0                                       ! nicht gef. oder disabled
ENDFUNC
> FUNCTION rsc_alert(icon&,text$,def&,button$)
.| Glob. Var.: rsc_alert&,wchar&,hchar&
.| Felder    : rsc_adr%(),rscw&(),rsch&(),rscx&(),rscy&()
.| Ruft auf  : rsc_text,rsc_draw,rsc_do,rsc_back
.| Aufruf in : copytoarr-1,
' Fliegende ALERT-Box...
$F%
LOCAL a&,b&,h&,i&,l&,len&,w&,x&,y&,z&,ab&,ah&,rsc&,rsc_adr%,a$,knr,kobj,rdraw
'
' Alert-Box darstellen...
'
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF rsc_alert&>-1 AND rscda=TRUE AND exerr=FALSE THEN      ! Wenn's den Baum gibt:
rsc_adr%=rsc_adr%(rsc_alert&)                               ! rsc_alert=GLOBAL
'
text$=text$+"|"
button$=button$+"|"
' ---------------------------------------------------- Icon bestimmen
OB_FLAGS(rsc_adr%,2)=BSET(OB_FLAGS(rsc_adr%,2),7)    ! Hidden...
OB_FLAGS(rsc_adr%,3)=BSET(OB_FLAGS(rsc_adr%,3),7)
OB_FLAGS(rsc_adr%,4)=BSET(OB_FLAGS(rsc_adr%,4),7)
'
OB_FLAGS(rsc_adr%,SUCC(icon&))=BCLR(OB_FLAGS(rsc_adr%,SUCC(icon&)),7)
' ---------------------------------------------------- Buttons
OB_FLAGS(rsc_adr%,10)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,10)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,11)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,11)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,12)=OR(&X100101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,12))) ! LAST_OB+EXIT+SELECT.
'                                                    ! Default-Button...
OB_FLAGS(rsc_adr%,9+def&)=BSET(OB_FLAGS(rsc_adr%,9+def&),1)
' ---------------------------------------------------- Textzeilen setzen
FOR i&=1 TO 5
a&=INSTR(text$,"|")
a$=LEFT$(text$,MIN(30,MAX(0,PRED(a&))))
IF LEN(a$)>0 THEN
a$=a$+" "
ENDIF
IF LEN(a$)>30 THEN
a$=LEFT$(a$,30)
ENDIF
text$=MID$(text$,SUCC(a&))
'
z&=MAX(z&,-i&*(a$<>""))                            ! Hîchste belegte Zeile
l&=MAX(l&,LEN(a$))                                 ! LÑngste Zeile
'
rsc_text(rsc_alert&,ADD(4,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Button-Texte setzen
FOR i&=1 TO 3
a&=INSTR(button$,"|")
a$=LEFT$(button$,MIN(10,MAX(0,PRED(a&))))
button$=MID$(button$,SUCC(a&))
'
ADD b&,-(a$<>"")                                   ! Anzahl Buttons
len&=MAX(len&,LEN(a$))                             ! LÑngster Button
'
rsc_text(rsc_alert&,ADD(9,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Dialog-Breite Ñndern
l&=MAX(l&,MUL(10,b&))                                ! Minimal-Breite
'
w&=OB_W(rsc_adr%,3)+MUL(wchar&,ADD(l&,5))
OB_W(rsc_adr%,0)=w&                                  ! Neue Breite
'
OB_X(rsc_adr%,1)=w&-PRED(OB_W(rsc_adr%,1))           ! Flydial verschieben
rscw&(rsc_alert&)=ADD(w&,6)
' ---------------------------------------------------- Dialog-Hîhe Ñndern
h&=OB_H(rsc_adr%,10)+MUL(hchar&,ADD(z&,2))
OB_H(rsc_adr%,0)=h&                                  ! Neue Hîhe
rsch&(rsc_alert&)=ADD(h&,6)
' ---------------------------------------------------- Buttons plazieren
len&=MUL(wchar&,MAX(8,SUCC(len&)))
OB_W(rsc_adr%,10)=len&                               ! Breite anpassen..
OB_W(rsc_adr%,11)=len&
OB_W(rsc_adr%,12)=len&
'
good=TRUE
SELECT b&                                            ! Anzahl Buttons...
CASE 1
OB_FLAGS(rsc_adr%,11)=BSET(OB_FLAGS(rsc_adr%,11),7)! ...hidden
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
' OB_X(rsc_adr%,10)=SHR(SUB(w&,OB_W(rsc_adr%,10)),1)
OB_X(rsc_adr%,10)=SUB(w&,OB_W(rsc_adr%,10))-2*wchar&
'
CASE 2
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
x&=w&-OB_W(rsc_adr%,11)-2*wchar&
OB_X(rsc_adr%,11)=x&
OB_X(rsc_adr%,10)=x&-OB_W(rsc_adr%,10)-wchar&
'
CASE 3
x&=w&-OB_W(rsc_adr%,12)-SHL(wchar&,1)              ! ...Mitte
OB_X(rsc_adr%,12)=x&
OB_X(rsc_adr%,11)=x&-OB_W(rsc_adr%,10)-wchar&
OB_X(rsc_adr%,10)=OB_X(rsc_adr%,11)-OB_W(rsc_adr%,10)-wchar&
'
ENDSELECT
'
y&=h&-OB_H(rsc_adr%,10)-SHR(hchar&,1)
OB_Y(rsc_adr%,10)=y&
OB_Y(rsc_adr%,11)=y&
OB_Y(rsc_adr%,12)=y&
' ---------------------------------------------------- Anzeigen
~FORM_CENTER(rsc_adr%(rsc_alert&),rscx&(rsc_alert&),rscy&(rsc_alert&),rscw&(rsc_alert&),rsch&(rsc_alert&))
'
rdraw=FALSE
'    IF rsc_handle%(nr)>1000                             ! Normaler Dialog...
'      rsc_back(nr)
'      rdraw=TRUE
'  ENDIF
knr=nr
kobj=obj
nr=alertbox&
@rsc_draw(nr,0)
rsc&=@rsc_do(nr,0,popup&)
rsc_back(nr)
nr=knr
obj=kobj
'    IF rdraw=TRUE THEN
'    @rsc_draw(nr,0)
'  ENDIF
rdraw=FALSE
' ----------------------------------------------------
OB_STATE(rsc_adr%,rsc&)=BCLR(OB_STATE(rsc_adr%,rsc&),0)! SELECTED lîschen
'
RETURN SUB(rsc&,9)                                   ! Nummer des Buttons 1-3
ELSE
' Normaler Alert...
WHILE INSTR(button$,"[")>0
button$=LEFT$(button$,PRED(INSTR(button$,"[")))+MID$(button$,SUCC(INSTR(button$,"[")))
WEND                                                   ! ...'[' rausfiltern
RETURN FORM_ALERT(def&,"["+STR$(icon&)+"]["+text$+"]["+button$+"]")
ENDIF
ENDFUNC
> PROCEDURE rsc_state(tree&,obj&,bit&,stat!)
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_tristate-4,rsc_tristate2-4,
' Setzen und Abfragen einzelner Bits in OB_STATE und OB_FLAGS...
'
' tree& : Index des Objektbaumes
' obj&  : Objektnummer
' bit&  : Zu setzendes Bit
' stat! : TRUE =Bit setzen, FALSE =Bit lîschen
'
IF stat!
OB_STATE(rsc_adr%(tree&),obj&)=BSET(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ELSE
OB_STATE(rsc_adr%(tree&),obj&)=BCLR(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ENDIF
'
RETURN
> PROCEDURE rsc_tristate(tree&,obj&)
.| Glob. Var.: tri#
.| Ruft auf  : rsc_state,rsc_draw_obj
.| Aufruf in : arrtristate-1,
' Behandlung eines Tristate-Buttons...
'
INC tri
IF tri=3 THEN
tri=0
ENDIF
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
RETURN
> PROCEDURE rsc_tristate2(tree&,obj&)
.| Glob. Var.: tri#
.| Ruft auf  : rsc_state,rsc_draw_obj
.| Aufruf in : arrnrset-4,arranger-4,arrdel-4,
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
RETURN
> PROCEDURE rsc_draw_obj(tree&,obj&)
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_tristate-1,rsc_tristate2-1,
' Zeichnen eines einzelnen Objektes...
LOCAL x&,y&
'
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
~OBJC_DRAW(rsc_adr%(tree&),obj&,8,x&,y&,OB_W(rsc_adr%(tree&),obj&),OB_H(rsc_adr%(tree&),obj&))
'
RETURN
> PROCEDURE rsc_redraw_obj(tree&,obj&)
.| Glob. Var.: edit_obj&,idx&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_message
.| Aufruf in : message-1,fadehandler-1,clsfade-1,fadedel-1,restaura3-1
.|     trakload-1,trakforw-1,trkbackw-1,hardfs-1,mforw-1,mbackw-1
.|     time_edit-1,coninsert-1,record2-1,record3-1,
' Sauberer Redraw eines Objektes, nur fÅr Fensterdialoge!...
LOCAL x&,y&,w&,h&
'
' Sendet einen Redraw-Event fÅr ein Objekt
' --------------------------------------------------
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
w&=OB_W(rsc_adr%(tree&),obj&)
h&=OB_H(rsc_adr%(tree&),obj&)
'
'  appl_write(ap_id&,20,rsc_handle%(tree&),x&-3,y&-3,w&+6,h&+6,"")   ! WM_REDRAW
rsc_message(tree&,20,x&-3,y&-3,w&+6,h&+6,edit_obj&,idx&)   ! WM_REDRAW
'
RETURN
> PROCEDURE appl_write(id&,msg&,handle&,x&,y&,w&,h&,a$)
.| Glob. Var.: msg%,ap_id&
.| Aufruf in : helptxt-2,
' LOCAL b$
'
' Sendet eine Message an ein Programm. Dabei kann es sich auch um
' das eigene Programm handeln (id&=ap_id&), siehe 'rsc_redraw_obj'
' --------------------------------------------------
INLINE msg%,256
'
INT{msg%}=msg&                                     ! 0 Message-ID
INT{msg%+2}=ap_id&                                 ! 1 Unsere ID
INT{msg%+4}=0                                      ! 2 Keine öberlÑnge
INT{msg%+6}=handle&                                ! 3
INT{msg%+8}=x&                                     ! 4 MenÅpunkt
INT{msg%+10}=y&                                    ! 5
INT{msg%+12}=w&                                    ! 6
INT{msg%+14}=h&                                    ! 7
'
'  IF x&=0                                            ! String (z.B. fÅr VA_START)...
CHAR{msg%+16}=LEFT$(a$,240)
{msg%+6}=msg%+16
' ENDIF
'
~APPL_WRITE(id&,16,msg%)                           ! Weg damit
'
RETURN
' ------------------------------------------------------------------------------
' ------------------------RCS-Zugriffs-Routinen---------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE textfeld(txtname,txt$,versatz)
LOCAL a
~@xrsrc_gaddr(0,nr,zu%)
string=LPEEK(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,txtname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~FRE(0)
RETURN
'
> PROCEDURE textfeld2(window,txtname,txt$,versatz)
LOCAL a
~@xrsrc_gaddr(0,window,zu%)
string=LPEEK(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
~@xrsrc_gaddr(0,nr,zu%)
RETURN
'
> PROCEDURE textbutt(parent,txtname,txt$,versatz)
~@xrsrc_gaddr(0,nr,zu%)
string=(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
POKE string+it-1+(versatz-1),ASC(MID$(txt$,it,1))
NEXT it
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,parent,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE setbutton(buttnr,buttflag)
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE setbutton2(buttnr,buttflag)
LOCAL buttadr,zu%
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
ENDIF
RETURN
'
> PROCEDURE drawbutton(buttnr)
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,nr,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE setbild(buttnr,buttflag)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
RETURN
'
> PROCEDURE hidetree(buttnr,buttflag,box)
LOCAL bf
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,box,99,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE hidetree2(buttnr,buttflag)
LOCAL bf
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,0    ! setbutton lîschen
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
ENDIF
RETURN
'
> PROCEDURE readbutton(buttnr)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+10)
RETURN
'
> PROCEDURE flagbutton(buttnr,bfl)
IF buttnr<>0 THEN
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE (buttadr+8),bfl
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE readflag(buttnr)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+8)
RETURN
'
> PROCEDURE readpos(buttnr)
.| Glob. Var.: nr#,zu%,buttadr#,bx#,by#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : dragging1-1,dragging2-1,
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
bx=DPEEK(buttadr+16)
by=DPEEK(buttadr+18)
RETURN
'
> PROCEDURE setpos(buttnr,bx,by)
~@xrsrc_gaddr(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+16,bx
DPOKE buttadr+18,by
RETURN
'
> PROCEDURE colorbox(nrr,buttnr,col,fill)
.| Glob. Var.: zu%,buttadr#,colflag#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : HAUPTPROGRAMM-68,
~@xrsrc_gaddr(0,nrr,zu%)
buttadr=zu%+24*buttnr
colflag=DPEEK(buttadr+14)
colflag=(colflag AND &HFFF0)+col
colflag=(colflag AND &HFF8F)+fill*16
DPOKE buttadr+14,colflag
RETURN
'
> PROCEDURE textcolor(nrr,buttnr,col,rahmen,fill)
~@xrsrc_gaddr(0,nrr,zu%)
buttadr=LPEEK(zu%+24*buttnr+12)
colflag=DPEEK(buttadr+18)
colflag=(colflag AND &HF0)+col*256+rahmen*4096+fill
DPOKE buttadr+18,colflag
RETURN
'
> PROCEDURE editread(edread)
.| Glob. Var.: nr#,zu%,editadr#,erd#,a$,bv$
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-2,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkproof-1,tedproof-1,setupdat-1,setsave-1,
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edread+12
erd=LPEEK(LPEEK(editadr))
a$=""
WHILE PEEK(erd)<>0
bv$=CHR$(PEEK(erd))
a$=a$+bv$
erd=erd+1
WEND
RETURN
'
> PROCEDURE editfeld(edname,ed$)
.| Glob. Var.: edit_obj&,nr#,zu%,editadr#,edanf#,edz#,ef#,ap#,xwidth#
.|     ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-8,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkart-1,tedart-2,setdat-1,
edit_obj&=0
~@xrsrc_gaddr(0,nr,zu%)
editadr=zu%+24*edname+12
edanf=LPEEK(LPEEK(editadr))
edz=LEN(ed$)
FOR ef=1 TO edz
ap=ASC(MID$(ed$,ef,1))
POKE edanf+ef-1,ap
NEXT ef
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,edname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~FRE(0)
RETURN
'
> PROCEDURE mouse(VAR mx,my,mk)
.| Aufruf in : message-1,normalize-1,fadehandler-2,markhandl4-1,arrsmpr-1
.|     dragging1-2,dragging2-2,arrmname-1,virtual-1,setupdat-1,midi-1
.|     do_peak-1,markhandler-1,
LOCAL void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx,my,mk,void&)
~WIND_UPDATE(2)
'
SUB mx,WORD{WINDTAB+64}
SUB my,WORD{WINDTAB+66}
RETURN
'
> FUNCTION mousek
$F%
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf4b-1
.|     maschruf5-1,maschruf5c-1,maschruf8b-1,fadehandler-1,fade-1,smptime-1
.|     movefrag-1,drawpix-2,edhandler2-3,smpsave-1,blklfrag-1,newfsel-1
.|     sampleinf-1,trkplay-1,dragging2-1,arrtristate-1,arrdelay-1,arrplay-1
.|     abackup-1,time_edit-1,make-1,smpsts-1,smpes-1,do_peak-1,peakwert-1
.|     markhandler-1,
LOCAL mk&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(void&,void&,mk&,void&)
~WIND_UPDATE(2)
'
RETURN mk&
'
ENDFUNC
'
> FUNCTION mousex
$F%
.| Aufruf in : markhandl4-1,do_peak-1,
LOCAL mx&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx&,void&,void&,void&)
~WIND_UPDATE(2)
SUB mx&,WORD{WINDTAB+64}
'
RETURN mx&
'
ENDFUNC
'
> FUNCTION mousey
$F%
.| Aufruf in : markhandl4-1,do_peak-1,
LOCAL my&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(void&,my&,void&,void&)
~WIND_UPDATE(2)
SUB my&,WORD{WINDTAB+66}
'
RETURN my&
'
ENDFUNC
'
> PROCEDURE fscalc
LOCAL a
fsz=flist/fsmax*fsz2
IF fsz2>fsmax-fstep THEN
fsz2=fsmax-fstep
@setslide2(fsslide&,fssldbut&,fsmax,fsz2,fstep)
ENDIF
IF fsz>(flist-15) THEN
fsz=flist-15
ENDIF
IF fsz<0 THEN
fsz=0
ENDIF
fsz=ROUND(fsz)
@fsbutset
RETURN
'
> PROCEDURE fselslidset
@slidelen(fsslide&,fssldbut&,v,fsbr)
IF flist=0 THEN
fbbut=fsbr
ELSE
fbbut=INT(fsbr/flist*fsl)  ! Buttonbreite
ENDIF
IF fbbut>fsbr THEN
fbbut=fsbr
ENDIF
fsmax=fsbr                 ! Breite des Sliders
IF flist<=fsl THEN
fstep=0      ! Schrittweite des Sliders
fsplus=0         ! Einzelschritt
ELSE
fstep=fsmax/flist*fsl      ! Schrittweite des Sliders
fsplus=fsmax/flist         ! Einzelschritt
ENDIF
@slideinit(fsslide&,fssldbut&,fsmax,fbbut,fsz)
@setslide(fsslide&,fssldbut&,fsmax,fbbut,fsz)
fsz=0
fsz2=0
RETURN
'
> PROCEDURE setslide2(slidename&,slbutname&,max,pos,step)
LOCAL b,h,poswert
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF max>1 THEN
poswert=1000/(max-1)*pos
ELSE
poswert=0
ENDIF
IF b>h OR b=tbkurz THEN
sx=(poswert*b/1000)
IF sx+step>max THEN
sx=max-step
ENDIF
IF sx<0 THEN
sx=0
ENDIF
DPOKE zu%+24*slbutname&+16,sx              ! X-Position einstellen
ELSE
sy=(poswert*h/1000)
IF sy+step>max THEN
sy=max-step
ENDIF
DPOKE zu%+24*slbutname&+18,sy              ! Y-Position einstellen
IF sy<0 THEN
sy=0
ENDIF
ENDIF
'  @windowtest
IF shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,slidename&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE slideupdate2(slidename&,slbutname&,saxy,max,mx,my,slc,VAR pos,flg)
LOCAL b,h,pbb,pbla,pbl,a
@markhlp
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
a=FALSE
IF b>h OR b=tbkurz THEN
pbb=DPEEK(zu%+24*slidename&+16)+saxy       ! X-Koordinate Anfangspunkt
pbla=INT(b/max*pos)
pbl=INT(b/max)
IF mx>(pbb+pbla+pbl/2) THEN
@slidedwn2(slidename&,slbutname&,max,slc,slc,pos,a)
ENDIF
IF mx<(pbb+pbla-pbl/2) THEN
@slideup2(slidename&,slbutname&,max,slc,pos,a)
ENDIF
ELSE
pbb=DPEEK(zu%+24*slidename&+18)+saxy    ! Y-Koordinate Anfangspunkt
pbla=INT(h/max*pos)
pbl=INT(h/max)
IF my>(pbb+pbla+pbl/2) THEN
@slidedwn2(slidename&,slbutname&,max,slc,slc,pos,a)
ENDIF
IF my<(pbb+pbla-pbl/2) THEN
@slideup2(slidename&,slbutname&,max,slc,pos,a)
ENDIF
ENDIF
flg=a
RETURN
'
> PROCEDURE slideup2(slidename&,slbutname&,max,slc,VAR pos,flg)
LOCAL p,a,sl
p=pos
sl=slc
IF p-sl<0 AND sl>1 THEN
sl=p
ENDIF
IF p-sl>=0 THEN
p=p-sl
@setslide2(slidename&,slbutname&,max,p,slc)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slidedwn2(slidename&,slbutname&,max,step,slc,VAR pos,flg)
LOCAL p,a,sl,st2
p=pos
sl=slc
IF p>=max-sl AND sl>1 THEN
sl=max-p-1
ENDIF
IF p<(max-step) THEN
p=p+sl
@setslide2(slidename&,slbutname&,max,p,slc)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE sliding3(slidename&,slbutname&,max,step,VAR pos,flg)
LOCAL b,h,slwert,p,a
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,0)
ELSE
slwert=GRAF_SLIDEBOX(zu%,slidename&,slbutname&,1)
ENDIF
p=(max-step)/1000*slwert
IF p<>pos THEN
@setslide2(slidename&,slbutname&,max,p,step)
a=TRUE
ELSE
a=FALSE
ENDIF
pos=p
flg=a
RETURN
'
> PROCEDURE slideinit(slidename&,slbutname&,max,bg,VAR pos)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : newfsel-1,arranger-1,trakker-2,virtual-1,scrollinit-1
.|     setup2-1,
LOCAL b,h,pbl
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
pbl=INT(b/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+20),pbl         ! Breite des Schiebers anpassen
ELSE
pbl=INT(h/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
DPOKE (zu%+24*slbutname&+22),pbl         ! Hîhe des Schiebers anpassen
ENDIF
pos=0                                       ! Position des Schiebers
RETURN
'
> PROCEDURE slidelen(slidename&,slbutname&,VAR len,leno)
.| Glob. Var.: nr#,zu%
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : virtual-1,scrollinit-1,
LOCAL b,h
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF b>h OR b=tbkurz THEN
leno=b
len=b-DPEEK(zu%+24*slbutname&+20)   ! Breite des Schiebers in Pixeln
ELSE
leno=h
len=h-DPEEK(zu%+24*slbutname&+22)   ! Hîhe des Schiebers in Pixeln
ENDIF
RETURN
'
> PROCEDURE setslide(slidename&,slbutname&,max,bg,pos)
.| Glob. Var.: nr#,zu%,xwidth#,ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : button-4,rubbermax-1,newfsel-7,slideup-1,slidedwn-1
.|     sliding-1,arranger-1,trakker-2,virtual-1,getmem-2,zslidecalc-1
.|     smpedit-2,do_smpedit-6,time_edit-1,
LOCAL b,h,pbl,poswert
~@xrsrc_gaddr(0,nr,zu%)
h=DPEEK(zu%+24*slidename&+22)         ! Hîhe des Sliders in Pixeln
b=DPEEK(zu%+24*slidename&+20)         ! Breite des Sliders in Pixeln
IF max>1 THEN
poswert=1000/(max-1)*pos
ELSE
poswert=0
ENDIF
IF b>h OR b=tbkurz THEN
pbl=INT(b/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
SUB b,pbl
DPOKE zu%+24*slbutname&+16,poswert*b/1000              ! X-Position einstellen
ELSE
pbl=INT(h/max)                   ! Grîûe des Schiebers
IF pbl<bg THEN
pbl=bg
ENDIF
SUB h,pbl
DPOKE zu%+24*slbutname&+18,poswert*h/1000              ! Y-Position einstellen
ENDIF
'  @windowtest
IF shading=FALSE THEN
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,slidename&,9,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE markhlp
IF rsc_handle%(nr)<1001                             ! Normaler Dialog...
handle&=rsc_handle%(nr)                         ! Fensterhandle des Dialogs
~WIND_GET(handle&,4,ax&,ay&,ab&,ah&)          ! 1. Rechteck
ENDIF
RETURN
'
> PROCEDURE wischwasch
LOCAL xevnt&,key&,xflags&,xtim&,mx&,my&,mb&,shift&,c
IF rscda=TRUE THEN
IF rsc_handle%(nr)<1000                             ! Fenster Dialog ?
xflags&=&X110000                                      ! ...zus. MESSAGE-Events
xtim&=4   ! EVENT-TIMER in msec
REPEAT
xevnt&=EVNT_MULTI(xflags&,2,1,1,0,0,0,0,0,0,0,0,0,0,0,xtim&,mx&,my&,mb&,shift&,key&,c)
IF BTST(xevnt&,4) THEN
@message
ENDIF
UNTIL BTST(xevnt&,4)=FALSE
ENDIF
ENDIF
RETURN
'
' ------------------------------------------------------------------------------
'          HardwareunabhÑngiger Teil - GEM
' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------
' ------------------------HAUPTPROGRAMM-----------------------------------------
' ------------------------------------------------------------------------------
'
> PROCEDURE loaddesk
IF lddesk=FALSE THEN
IF EXIST(s$+rsc$)=TRUE THEN
rscda=@rsc_laden(s$+rsc$,btree,popups&,0,btree)  ! File$,Trees,Popup,Menu,Alert
ELSE
rscda=FALSE
ENDIF
'
IF maxcol=2 AND rscda=TRUE THEN
@textcolor(mode&,helpmod&,1,1,0)
@textcolor(mode&,modeundo&,1,1,0)
@textcolor(mode&,inswc&,1,1,0)
@textcolor(mode&,inlnk&,1,1,0)
@textcolor(devco&,devcohlp&,1,1,0)
@textcolor(devco&,devundo&,1,1,0)
@textcolor(status&,stathelp&,1,1,0)
@textcolor(status&,statundo&,1,1,0)
@textcolor(status&,rate0&,1,1,0)
@textcolor(status&,rate1&,1,1,0)
@colorbox(mode&,mainbox1&,0,7)
@colorbox(mode&,mainbox2&,0,7)
@colorbox(mode&,wmbox3&,0,7)
@colorbox(mode&,wmbox4&,0,7)
@colorbox(mode&,wmbox5&,0,7)
@colorbox(mode&,wmbox6&,0,7)
@colorbox(mode&,wmbox7&,0,7)
@colorbox(devco&,devcobx&,0,7)
@colorbox(devco&,devcobx1&,0,7)
@colorbox(devco&,devcobx2&,0,7)
@colorbox(devco&,devcobx4&,0,7)
@colorbox(devco&,devcobx5&,0,7)
@colorbox(alertbox&,alertcol&,0,7)
@colorbox(status&,statbx1&,0,7)
@colorbox(status&,statbx2&,0,7)
@colorbox(status&,statbx3&,0,7)
@colorbox(status&,statbx4&,0,7)
@colorbox(status&,statbx5&,0,7)
@colorbox(status&,statbx6&,0,7)
@colorbox(status&,statbx7&,0,7)
@colorbox(status&,statbx8&,0,7)
@colorbox(status&,statbx9&,0,7)
@colorbox(status&,statbx10&,0,7)
@colorbox(status&,statbx11&,0,7)
@colorbox(status&,statbx12&,0,7)
@colorbox(seedev&,fselbox&,0,7)
@colorbox(seedev&,fselbox2&,0,7)
@textcolor(seedev&,fstxt1&,1,1,0)
@textcolor(seedev&,fstxt2&,1,1,0)
@textcolor(seedev&,fstxt3&,1,1,0)
@textcolor(seedev&,fstxt4&,1,1,0)
@textcolor(seedev&,fstxt5&,1,1,0)
@textcolor(seedev&,fstxt6&,1,1,0)
@textcolor(seedev&,fstxt7&,1,1,0)
@textcolor(seedev&,fstxt8&,1,1,0)
@textcolor(seedev&,fstxt9&,1,1,0)
@textcolor(seedev&,fstxt10&,1,1,0)
@textcolor(seedev&,fstxt11&,1,1,0)
@textcolor(seedev&,fstxt12&,1,1,0)
@textcolor(seedev&,fstxt13&,1,1,0)
@textcolor(seedev&,fstxt14&,1,1,0)
@textcolor(seedev&,fstxt15&,1,1,0)
@textcolor(seedev&,fsbut1&,1,1,0)
@textcolor(seedev&,fsbut2&,1,1,0)
@textcolor(seedev&,fsbut3&,1,1,0)
@textcolor(seedev&,fsbut4&,1,1,0)
@textcolor(seedev&,fsbut5&,1,1,0)
@textcolor(seedev&,fsbut6&,1,1,0)
@textcolor(seedev&,fsbut7&,1,1,0)
@textcolor(seedev&,fsbut8&,1,1,0)
@textcolor(seedev&,fsbut9&,1,1,0)
@textcolor(seedev&,fsbut10&,1,1,0)
@textcolor(seedev&,fsbut11&,1,1,0)
@textcolor(seedev&,fsbut12&,1,1,0)
@textcolor(seedev&,fsbut13&,1,1,0)
@textcolor(seedev&,fsbut14&,1,1,0)
@textcolor(seedev&,fsbut15&,1,1,0)
@textcolor(seedev&,fshelp&,1,1,0)
@colorbox(seedev&,fsslide&,1,1)
ENDIF
ENDIF
lddesk=TRUE
RETURN
'
> PROCEDURE setmatrtxt
IF nr=devco& THEN
IF matchannel=2 THEN
a$="2CH/64BIT"+CHR$(0)
@textfeld(mchotxt&,a$,1)
@textfeld(expotxt&,a$,1)
@textfeld(mchitxt&,a$,1)
@textfeld(extotxt&,a$,1)
ENDIF
IF matchannel=4 THEN
a$="2CH/64BIT"+CHR$(0)
@textfeld(mchotxt&,a$,1)
@textfeld(expotxt&,a$,1)
@textfeld(mchitxt&,a$,1)
@textfeld(extotxt&,a$,1)
ENDIF
IF matchannel=8 THEN
a$="8CH/128BIT"+CHR$(0)
@textfeld(mchotxt&,a$,1)
@textfeld(expotxt&,a$+CHR$(0),1)
IF cv=1 THEN
a$="2CH/64BIT"+CHR$(0)
@textfeld(mchitxt&,a$,1)
ELSE
a$="8CH/128BIT"+CHR$(0)
@textfeld(mchitxt&,a$,1)
ENDIF
a$="8CH/128BIT"+CHR$(0)
@textfeld(extotxt&,a$,1)
ENDIF
IF matchannel=16 THEN
a$="16CH/128BIT"+CHR$(0)
@textfeld(mchotxt&,a$,1)
a$="8CH/128BIT"+CHR$(0)
@textfeld(expotxt&,a$,1)
IF cv=1 THEN
a$="2CH/64BIT"+CHR$(0)
@textfeld(mchitxt&,a$,1)
ELSE
a$="8CH/128BIT"+CHR$(0)
@textfeld(mchitxt&,a$,1)
ENDIF
a$="8CH/128BIT"+CHR$(0)
@textfeld(extotxt&,a$,1)
ENDIF
ELSE
IF matchannel=2 THEN
a$="2CH/64BIT"+CHR$(0)
@textfeld2(devco&,mchotxt&,a$,1)
@textfeld2(devco&,expotxt&,a$,1)
@textfeld2(devco&,mchitxt&,a$,1)
@textfeld2(devco&,extotxt&,a$,1)
ENDIF
IF matchannel=4 THEN
a$="2CH/64BIT"+CHR$(0)
@textfeld2(devco&,mchotxt&,a$,1)
@textfeld2(devco&,expotxt&,a$,1)
@textfeld2(devco&,mchitxt&,a$,1)
@textfeld2(devco&,extotxt&,a$,1)
ENDIF
IF matchannel=8 THEN
a$="8CH/128BIT"+CHR$(0)
@textfeld2(devco&,mchotxt&,a$,1)
@textfeld2(devco&,expotxt&,a$+CHR$(0),1)
IF cv=1 THEN
a$="2CH/64BIT"+CHR$(0)
@textfeld2(devco&,mchitxt&,a$,1)
ELSE
a$="8CH/128BIT"+CHR$(0)
@textfeld2(devco&,mchitxt&,a$,1)
ENDIF
a$="8CH/128BIT"+CHR$(0)
@textfeld2(devco&,extotxt&,a$,1)
ENDIF
IF matchannel=16 THEN
a$="16CH/128BIT"+CHR$(0)
@textfeld2(devco&,mchotxt&,a$,1)
a$="8CH/128BIT"+CHR$(0)
@textfeld2(devco&,expotxt&,a$,1)
IF cv=1 THEN
a$="2CH/64BIT"+CHR$(0)
@textfeld2(devco&,mchitxt&,a$,1)
ELSE
a$="8CH/128BIT"+CHR$(0)
@textfeld2(devco&,mchitxt&,a$,1)
ENDIF
a$="8CH/128BIT"+CHR$(0)
@textfeld2(devco&,extotxt&,a$,1)
ENDIF
ENDIF
RETURN
'
> PROCEDURE editselect
@wischwasch
~@xrsrc_gaddr(0,nr,zu%)
rsc_message(nr,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
@wischwasch
@setmatrtxt
RETURN
'
> PROCEDURE helptxt(search$)        ! Hilfstexte von 1st Guide aktivieren
'
' Der Pfad der IDX-Datei muû vorher im 1stGuide Konfigurationsdialog eingegeben werden !!!
'
LOCAL g,hlpfound,t,a,hobj,vfly
msg_id=APPL_FIND("1STGUIDE")
IF msg_id<>-1 THEN
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=s$+"1STGUIDE.IDX"
ENDIF
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=op$+"1STGUIDE.IDX"
ENDIF
IF EXIST(hpath$)=FALSE THEN
hlpfound=FALSE
'    ~GRAF_MOUSE(256,0)                              ! Hidem
'    ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
'   ~GRAF_MOUSE(257,0)                              ! Showm
@fileselect(op$+"*.IDX","1STGUIDE.IDX","Search 1STGUIDE.IDX:")
'   @rsc_put(ab,rscx&(nr),rscy&(nr),1)
IF ordner$<>"" AND pret<>0 AND pbutt=1 THEN
hpath$=ordner$+"1STGUIDE.IDX"
IF EXIST(hpath$)=TRUE THEN
hlpfound=TRUE
ENDIF
ENDIF
ELSE
hlpfound=TRUE
ENDIF
IF hlpfound=TRUE THEN
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
normd=FALSE
IF rsc_handle%(nr)>1000                             ! Normaler Dialog...
normd=TRUE
ndnr=nr
@rsc_back(nr)
ENDIF
'
hpath$=hpath$+CHR$(0)
@appl_write(msg_id,&H4711,0,0,0,0,0,hpath$)    ! VA_START
accwindopen=FALSE
ON MENU MESSAGE GOSUB message
t=TIMER
REPEAT
ON MENU
UNTIL accwindopen=TRUE OR (TIMER-t)>400
@wischwasch
search$=search$+CHR$(0)
a=1025
accwindopen=FALSE
@appl_write(msg_id,a,0,0,0,0,0,search$)                           ! AC_HELP
ON MENU MESSAGE GOSUB message
t=TIMER
REPEAT
ON MENU
UNTIL accwindopen=TRUE OR (TIMER-t)>400
@wischwasch
IF normd=TRUE THEN                            ! Normaler Dialog...
IF rsc_handle%(vornr)<1000                  ! FensterDialog...
nr=vornr
@editselect
ENDIF
nr=ndnr
@rsc_draw(nr,0)
ENDIF
ELSE
'
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
ENDIF
ELSE
'
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
@wischwasch
@readbutton(obj)
hobj=obj
vfly=fly
fly=TRUE
edit_obj&=0
@alerts(12)
fly=vfly
obj=hobj
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
ENDIF
RETURN
'
> PROCEDURE fileselect(a$,b$,c$)
.| Glob. Var.: fs_iinpath%,fs_iinsel%,fs_iinlabel%,a#,ordner$,nam$,fil$
.| Ruft auf  : fsel_exinput
.| Aufruf in : fadesave-1,fadeload-1,smpsave-1,newfsel-3,ldhlp-1,trakload-1
.|     hardfs-1,arrload-1,arrsave-1,make-1,fseldef-1,coninsert-1,smpplay-1
.|     record3-1,
~GRAF_MOUSE(256,0)                              ! Hidem
'  ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
a$=a$+CHR$(0)+SPACE$(100)
fs_iinpath%=VARPTR(a$)
b$=b$+CHR$(0)+SPACE$(100)
fs_iinsel%=VARPTR(b$)
c$=c$+CHR$(0)+SPACE$(100)
fs_iinlabel%=VARPTR(c$)
@fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
a=INSTR(a$,CHR$(0))
a$=LEFT$(a$,a-1)
a=INSTR(b$,CHR$(0))
b$=LEFT$(b$,a-1)
a=RINSTR(a$,"\")
IF LEN(a$)=0 THEN
ordner$=""
ELSE
ordner$=LEFT$(a$,a)
ENDIF
IF LEN(b$)=0 THEN
nam$=""
fil$=""
ELSE
nam$=b$
fil$=ordner$+b$
ENDIF
@wischwasch
RETURN
'
> PROCEDURE fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
.| Glob. Var.: pret#,pbutt#
.| Ruft auf  : ain
.| Aufruf in : fileselect-1,
LPOKE ADDRIN,fs_iinpath%
LPOKE ADDRIN+4,fs_iinsel%
LPOKE ADDRIN+8,fs_iinlabel%
@ain(91,0,2,3,0)
pret=GINTOUT(0)
pbutt=GINTOUT(1)
RETURN
'
> PROCEDURE ain(g0%,g2%,g4%,g6%,g8%)
.| Aufruf in : fsel_exinput-1,
DPOKE GCONTRL,g0%
DPOKE GCONTRL+2,g2%
DPOKE GCONTRL+4,g4%
DPOKE GCONTRL+6,g6%
DPOKE GCONTRL+8,g8%
GEMSYS
RETURN
'
> PROCEDURE errorcode
e$=ERR$(ERR)
e=INSTR(2,e$,"[")
e$=RIGHT$(e$,LEN(e$)-e)
e=INSTR(e$,"]")
e$=LEFT$(e$,e-1)
e=INSTR(e$,"|")
e2=FALSE
IF e<>0 THEN
e$=LEFT$(e$,e-1)
e2=TRUE
ENDIF
IF e2=FALSE AND LEN(e$)>28 THEN
e$=LEFT$(e$,25)+"..."
ENDIF
IF e2=TRUE THEN
IF LEN(e$)>25 THEN
e$=LEFT$(e$,25)+"..."
ELSE
e$=e$+"..."
ENDIF
ENDIF
RETURN
'
> PROCEDURE alerts(alert)
LOCAL aobj,afly
aobj=obj
afly=fly
fly=TRUE
edit_obj&=0
'  @wischwasch
SELECT language
CASE 1
SELECT alert
CASE 1
g=@rsc_alert(3,"Auflîsung ist zu gering|Mindestens 640x400 nîtig !",1,"E[XIT")
CASE 2
g=@rsc_alert(3,"RSC-File nicht gefunden !",1,"E[XIT")
CASE 3
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher !!!",1,"E[XIT")
CASE 4
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher !!!",1,"[OK")
CASE 5
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher !!!",2,"[OK|E[XIT")
CASE 6
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher|DANGER !!!",2,"[OK|E[XIT")
CASE 7
g=@rsc_alert(3,"Finde Clipboard-Pfad nicht !",1,"E[XIT")
CASE 8
g=@rsc_alert(3,"Audio-Treiber konnte|nicht geladen werden !",1,"E[XIT")
CASE 9
g=@rsc_alert(3,"Audio-Treiber fehlt !",1,"E[XIT")
CASE 12
g=@rsc_alert(1,"1stGuide|ist nicht installiert|daher keine Hilfe,sorry !!!",1,"[OK")
CASE 99
g=@rsc_alert(2,"Programm beenden",1,"[JA|[NEIN")
ENDSELECT
CASE 2
SELECT alert
CASE 1
g=@rsc_alert(3,"screen resolution too low|minimal 640x400 necessary !",1,"E[XIT")
CASE 2
g=@rsc_alert(3,"RSC-file not found !",1,"E[XIT")
CASE 3
g=@rsc_alert(3,"memory overrun !|too little memory-space !!!",1,"E[XIT")
CASE 4
g=@rsc_alert(3,"memory overrun !|too little memory-space !!!",1,"[OK")
CASE 5
g=@rsc_alert(3,"memory overrun !|too little memory-space !!!",2,"[OK|E[XIT")
CASE 6
g=@rsc_alert(3,"memory overrun !|too little memory-space|DANGER !!!",2,"[OK|E[XIT")
CASE 7
g=@rsc_alert(3,"no Clipboard found !",1,"E[XIT")
CASE 8
g=@rsc_alert(3,"audio-driver could|not get load !",1,"E[XIT")
CASE 9
g=@rsc_alert(3,"audio-driver|is missing !",1,"E[XIT")
CASE 12
g=@rsc_alert(1,"1stGuide is not installed|therefore no help,sorry !!!",1,"[OK")
CASE 99
g=@rsc_alert(2,"close program",1,"[YES|[NO")
ENDSELECT
ENDSELECT
obj=aobj
fly=afly
edit_obj&=0
RETURN
'
> PROCEDURE goodbye
IF rscda=TRUE THEN
IF profi=TRUE THEN
@rsc_back(status&)
@rsc_back(devco&)
ENDIF
@rsc_back(mode&)
proghere=FALSE
ENDIF
'  GEMSYS 109                                        ! Nur ab GEM 1.04!
'
IF acc=FALSE THEN
IF rscda=TRUE THEN
@rsc_exit
ENDIF
IF xload=TRUE THEN
~@xrsrc_free    ! gibt RSC frei
@xrsrc_exit      ! beendet xrsrc-Routinen
ENDIF
RESERVE         ! Reservierung lîschen
ELSE
IF db=TRUE THEN
ERASE dbank$()
ENDIF
ENDIF
exit=TRUE
RETURN
'
> PROCEDURE language
SELECT language
CASE 1 ! deutsch
CASE 2 !englisch
ENDSELECT
RETURN
'
> PROCEDURE treiberload
IF XBIOS(xbs,1)<>&H71273800 THEN
'    IF EXIST(s$+"SOUND.PRG"+CHR$(0))=TRUE THEN
'      a=EXEC(0,s$+"SOUND.PRG"+CHR$(0),CHR$(0),CHR$(0))
'  IF a<>0 OR XBIOS(xbs,1)<>&H71273800 THEN
'    @alerts(8)
'    exit=TRUE
'   ENDIF
'   ELSE
@alerts(9)
exit=TRUE
'  ENDIF
ENDIF
RETURN
'
> FUNCTION mxalloc(giveme,art)
a=GEMDOS(68,L:giveme,art)
RETURN a
ENDFUNC
'
> PROCEDURE initdata
xbs=500
starmagic=&H71273800
matchannel=2
mastering=16
bigram=FALSE
emulate=FALSE
analog=FALSE
digmode=0
vdmarec=-2
vdac=-2
vmatina=-2
vcv=-2
vstd=-2
vdspin=-2
vpdat=-2
vmatchannel=-2
vmastering=-2
vbigram=-2
vemulate=-2
vfclk=-2
vanalog=-2
vdigmode=-2
vrecmode=-2
vemuladc8=-2
vaddr=-2
vadci=-2
vsndmod=-2
vtrkp=-2
vtrkr=-2
vmon=-2
vinta=-2
vsrca=-2
'
RETURN
'
> PROCEDURE moderead
IF demo=FALSE THEN
a=XBIOS(xbs,27,-1)
ENDIF
IF a=0 THEN
matchannel=2
ENDIF
IF a=1 THEN
matchannel=4
ENDIF
IF a=2 THEN
matchannel=8
ENDIF
IF a=3 THEN
matchannel=16
ENDIF
IF vmatchannel<>matchannel THEN
IF matchannel=2 THEN
@setbutton(mat4&,0)
@setbutton(mat8&,0)
@setbutton(mat16&,0)
@setbutton(mat2&,1)
ENDIF
IF matchannel=4 THEN
@setbutton(mat2&,0)
@setbutton(mat8&,0)
@setbutton(mat16&,0)
@setbutton(mat4&,1)
ENDIF
IF matchannel=8 THEN
@setbutton(mat2&,0)
@setbutton(mat4&,0)
@setbutton(mat16&,0)
@setbutton(mat8&,1)
ENDIF
IF matchannel=16 THEN
@setbutton(mat2&,0)
@setbutton(mat4&,0)
@setbutton(mat8&,0)
@setbutton(mat16&,1)
ENDIF
vmatchannel=matchannel
ENDIF
'
IF demo=FALSE THEN
a=XBIOS(xbs,28,-1)
ENDIF
IF a=1 THEN
mastering=24
ELSE
mastering=16
ENDIF
IF vmastering<>mastering THEN
IF mastering=16 THEN
@setbutton(mast24&,0)
@setbutton(mast16&,1)
ENDIF
IF mastering=24 THEN
@setbutton(mast16&,0)
@setbutton(mast24&,1)
ENDIF
vmastering=mastering
ENDIF
'
IF demo=FALSE THEN
a=XBIOS(xbs,70,-1)
ENDIF
IF a=0 THEN
bigram=FALSE
ELSE
bigram=TRUE
ENDIF
IF vbigram<>bigram THEN
IF bigram=FALSE THEN
@setbutton(ramhi&,0)
@setbutton(ramlo&,1)
ELSE
@setbutton(ramlo&,0)
@setbutton(ramhi&,1)
ENDIF
vbigram=bigram
ENDIF
'
IF demo=FALSE THEN
a=XBIOS(xbs,160,-1)
ENDIF
IF a=0 THEN
emulate=FALSE
ELSE
emulate=TRUE
ENDIF
IF vemulate<>emulate THEN
IF emulate=FALSE THEN
@setbutton(emula&,0)
ELSE
@setbutton(emula&,1)
ENDIF
vemulate=emulate
ENDIF
'
IF demo=FALSE THEN
a=XBIOS(xbs,75,-1)
ENDIF
IF a=0 THEN
fclk=FALSE
ELSE
fclk=TRUE
ENDIF
IF vfclk<>fclk THEN
IF fclk=FALSE THEN
@setbutton(falclk&,0)
ELSE
@setbutton(falclk&,1)
ENDIF
vfclk=fclk
vsrca=-2
ENDIF
'
IF demo=FALSE THEN
analog=XBIOS(xbs,20,-1)
ENDIF
IF vanalog<>analog THEN
IF analog=1 THEN
a$=@rsc_text$(popups&,analog&)
@textfeld(inswc&,a$,1)
ENDIF
IF analog=0 THEN
a$=@rsc_text$(popups&,digital&)
@textfeld(inswc&,a$,1)
ENDIF
vanalog=analog
ENDIF
'
IF demo=FALSE THEN
digmode=XBIOS(xbs,21,-1)
ENDIF
IF vdigmode<>digmode THEN
IF digmode=0 THEN
a$=@rsc_text$(popups&,opto&)
@textfeld(inlnk&,a$,1)
ENDIF
IF digmode=1 THEN
a$=@rsc_text$(popups&,coax&)
@textfeld(inlnk&,a$,1)
ENDIF
IF digmode=2 THEN
a$=@rsc_text$(popups&,aesebu&)
@textfeld(inlnk&,a$,1)
ENDIF
vdigmode=digmode
ENDIF
'
IF demo=FALSE THEN
recmode=XBIOS(xbs,26,-1)
ENDIF
IF vrecmode<>recmode THEN
IF recmode=0 OR (matchannel=0 AND recmode<>1) THEN
@setbutton(rec4&,0)
@setbutton(rec8&,0)
@setbutton(rec2&,1)
ENDIF
IF recmode=1 THEN
@setbutton(rec2&,0)
@setbutton(rec8&,0)
@setbutton(rec4&,1)
ENDIF
IF recmode=2 OR (matchannel>=8 AND recmode<>1) THEN
@setbutton(rec2&,0)
@setbutton(rec4&,0)
@setbutton(rec8&,1)
ENDIF
vrecmode=recmode
ENDIF
'
IF demo=FALSE THEN
emuladc8=XBIOS(xbs,165,-1)
ENDIF
IF vemuladc8<>emuladc8 THEN
IF BTST(emuladc8,0)=0 THEN
@setbutton(emadc8&,0)
ELSE
@setbutton(emadc8&,1)
ENDIF
IF BTST(emuladc8,16)=0 THEN
@setbutton(emadca8&,0)
ELSE
@setbutton(emadca8&,1)
ENDIF
vemuladc8=emuladc8
ENDIF
RETURN
'
> PROCEDURE main
demo=FALSE
IF (XBIOS(103)=3 AND snd=&H1F AND mch=&H30000 AND vdo=&H30000 AND XBIOS(xbs,10)=0) OR magicmac<>0 OR XBIOS(500,1)<>&H71273800 THEN
demo=TRUE
ELSE
IF XBIOS(xbs,10)=0 THEN
demo=TRUE
ENDIF
ENDIF
IF proghere=FALSE THEN
'    ~XBIOS(xbs,416,1)     ! Soundcall-Analyser an(Bit0 ein), DSPcalls nicht protokollieren (Bit 1 aus), Devconnect (Bit 2)
DIM dbank$(500)
db=TRUE
@wischwasch
@initdata
IF profi=TRUE THEN
nr=status&
@rsc_draw(nr,1)
@wischwasch
nr=-1
@setmatrtxt
nr=devco&
@rsc_draw(nr,1)
@wischwasch
@devcoread
@wischwasch
ENDIF
nr=mode&
vornr=nr
@rsc_draw(nr,7)
@wischwasch
ENDIF
proghere=TRUE
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
@moderead
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
IF obj<>0 AND nr=mode& THEN
@modemaker
ENDIF
IF obj<>0 AND nr=devco& THEN
@devmaker
ENDIF
IF obj<>0 AND nr=status& THEN
@statmaker
ENDIF
IF nr=mode& AND obj=modeundo& THEN
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
@wischwasch
IF profi=TRUE THEN
nr=devco&
ELSE
nr=mode&
ENDIF
@editselect
ENDIF
IF nr=devco& AND obj=devundo& THEN
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
@wischwasch
nr=status&
@editselect
ENDIF
IF nr=status& AND obj=statundo& THEN
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
@wischwasch
nr=mode&
@editselect
ENDIF
UNTIL (((obj=devexit& AND nr=devco&) OR (obj=statexit& AND nr=status&) OR (obj=exit& AND nr=mode&)) OR obj=9999)
IF obj<>9999 THEN
@setbutton(obj,0)
ENDIF
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
@goodbye
RETURN
'
> PROCEDURE devcoread
IF demo=FALSE THEN
a=XBIOS(xbs,226,-1)
dmarec=DPEEK(a)
dac=DPEEK(a+2)
matina=DPEEK(a+4)
ENDIF
IF vdmarec<>dmarec THEN
IF dmarec=0 THEN
@setbutton(dmap0&,0)
@setbutton(xmita0&,0)
@setbutton(adc0&,0)
ENDIF
IF dmarec=1 THEN
@setbutton(dmap0&,1)
@setbutton(xmita0&,0)
@setbutton(adc0&,0)
ENDIF
IF dmarec=2 THEN
@setbutton(dmap0&,0)
@setbutton(xmita0&,0)
@setbutton(adc0&,1)
ENDIF
IF dmarec=3 THEN
@setbutton(dmap0&,0)
@setbutton(xmita0&,1)
@setbutton(adc0&,0)
ENDIF
vdmarec=dmarec
ENDIF
'
IF vdac<>dac THEN
IF dac=0 THEN
@setbutton(dmap2&,0)
@setbutton(xmita2&,0)
@setbutton(adc2&,0)
ENDIF
IF dac=1 THEN
@setbutton(dmap2&,1)
@setbutton(xmita2&,0)
@setbutton(adc2&,0)
ENDIF
IF dac=2 THEN
@setbutton(dmap2&,0)
@setbutton(xmita2&,0)
@setbutton(adc2&,1)
ENDIF
IF dac=3 THEN
@setbutton(dmap2&,0)
@setbutton(xmita2&,1)
@setbutton(adc2&,0)
ENDIF
vdac=dac
ENDIF
'
IF vmatina<>matina THEN
IF matina=0 THEN
@setbutton(dmap1&,0)
@setbutton(xmita1&,0)
@setbutton(adc1&,0)
ENDIF
IF matina=1 THEN
@setbutton(dmap1&,1)
@setbutton(xmita1&,0)
@setbutton(adc1&,0)
ENDIF
IF matina=2 THEN
@setbutton(dmap1&,0)
@setbutton(xmita1&,0)
@setbutton(adc1&,1)
ENDIF
IF matina=3 THEN
@setbutton(dmap1&,0)
@setbutton(xmita1&,1)
@setbutton(adc1&,0)
ENDIF
vmatina=matina
ENDIF
'
IF demo=FALSE THEN
a=XBIOS(xbs,221)
cv=(SHR(a,3) AND 1)
std=(SHR(a,1) AND 3)
ENDIF
IF vcv<>cv THEN
IF cv=1 THEN
@setbutton(conv&,1)
@setmatrtxt
ELSE
@setbutton(conv&,0)
@setmatrtxt
ENDIF
vcv=cv
ENDIF
'
IF vstd<>std THEN
IF std=0 THEN
@setbutton(xmitb2&,0)
@setbutton(dspx2&,1)
@setbutton(exti2&,0)
ENDIF
IF std=1 THEN
@setbutton(xmitb2&,0)
@setbutton(dspx2&,0)
@setbutton(exti2&,1)
ENDIF
IF std=2 THEN
@setbutton(xmitb2&,1)
@setbutton(dspx2&,0)
@setbutton(exti2&,0)
ENDIF
vstd=std
ENDIF
'
IF demo=FALSE THEN
dx=XBIOS(xbs,224)
pdat=(dx AND 3)
dspin=(SHR(dx,3) AND 1)
ENDIF
IF vpdat<>pdat THEN
IF pdat=0 THEN
@setbutton(xmitb0&,1)
@setbutton(dspx0&,0)
@setbutton(exti0&,0)
ENDIF
IF pdat=1 THEN
@setbutton(xmitb0&,0)
@setbutton(dspx0&,1)
@setbutton(exti0&,0)
ENDIF
IF pdat=2 THEN
@setbutton(xmitb0&,0)
@setbutton(dspx0&,0)
@setbutton(exti0&,1)
ENDIF
vpdat=pdat
ENDIF
IF vdspin<>dspin THEN
IF dspin=0 THEN
@setbutton(xmitb1&,1)
@setbutton(dspx1&,0)
@setbutton(exti1&,0)
ELSE
@setbutton(xmitb1&,0)
@setbutton(dspx1&,0)
@setbutton(exti1&,1)
ENDIF
vdspin=dspin
ENDIF
RETURN
'
> PROCEDURE statread
IF demo=FALSE THEN
addr=(3 AND XBIOS(&H82,4,-1))
ENDIF
IF vaddr<>addr THEN
IF BTST(addr,0)=TRUE THEN
@setbutton(addr0&,1)
ELSE
@setbutton(addr0&,0)
ENDIF
IF BTST(addr,1)=TRUE THEN
@setbutton(addr1&,1)
ELSE
@setbutton(addr1&,0)
ENDIF
vaddr=addr
ENDIF
'
IF demo=FALSE THEN
adci=(3 AND XBIOS(&H82,5,-1))
ENDIF
IF vadci<>adci THEN
IF BTST(adci,0)=TRUE THEN
@setbutton(adci0&,1)
ELSE
@setbutton(adci0&,0)
ENDIF
IF BTST(adci,1)=TRUE THEN
@setbutton(adci1&,1)
ELSE
@setbutton(adci1&,0)
ENDIF
vadci=adci
ENDIF
'
IF demo=FALSE THEN
sndmod=(3 AND XBIOS(&H84,-1))
ENDIF
IF vsndmod<>sndmod THEN
IF sndmod=0 THEN
@setbutton(snd0&,1)
ELSE
@setbutton(snd0&,0)
ENDIF
IF sndmod=1 THEN
@setbutton(snd1&,1)
ELSE
@setbutton(snd1&,0)
ENDIF
IF sndmod=2 THEN
@setbutton(snd2&,1)
ELSE
@setbutton(snd2&,0)
ENDIF
vsndmod=sndmod
ENDIF
'
IF demo=FALSE THEN
trk=XBIOS(&H85,-1)
trkr=(3 AND trk)
trkp=(3 AND SHR(trk,16))
ENDIF
IF vtrkp<>trkp THEN
IF trkp=0 THEN
@setbutton(trkp0&,1)
ELSE
@setbutton(trkp0&,0)
ENDIF
IF trkp=1 THEN
@setbutton(trkp1&,1)
ELSE
@setbutton(trkp1&,0)
ENDIF
IF trkp=2 THEN
@setbutton(trkp2&,1)
ELSE
@setbutton(trkp2&,0)
ENDIF
IF trkp=3 THEN
@setbutton(trkp3&,1)
ELSE
@setbutton(trkp3&,0)
ENDIF
vtrkp=trkp
ENDIF
IF vtrkr<>trkr THEN
IF trkr=0 THEN
@setbutton(trkr0&,1)
ELSE
@setbutton(trkr0&,0)
ENDIF
IF trkr=1 THEN
@setbutton(trkr1&,1)
ELSE
@setbutton(trkr1&,0)
ENDIF
IF trkr=2 THEN
@setbutton(trkr2&,1)
ELSE
@setbutton(trkr2&,0)
ENDIF
IF trkr=3 THEN
@setbutton(trkr3&,1)
ELSE
@setbutton(trkr3&,0)
ENDIF
vtrkr=trkr
ENDIF
'
IF demo=FALSE THEN
mon=3 AND (XBIOS(&H86,-1))
ENDIF
IF vmon<>mon THEN
IF mon=0 THEN
@setbutton(mon0&,1)
ELSE
@setbutton(mon0&,0)
ENDIF
IF mon=1 THEN
@setbutton(mon1&,1)
ELSE
@setbutton(mon1&,0)
ENDIF
IF mon=2 THEN
@setbutton(mon2&,1)
ELSE
@setbutton(mon2&,0)
ENDIF
IF mon=3 THEN
@setbutton(mon3&,1)
ELSE
@setbutton(mon3&,0)
ENDIF
vmon=mon
ENDIF
'
IF demo=FALSE THEN
inta=XBIOS(&H87,-1)
mfp=(1 AND SHR(inta,16))
ints=(inta AND 3)
ENDIF
IF vinta<>inta THEN
IF mfp=0 THEN
IF BTST(ints,0)=TRUE THEN
@setbutton(intp0&,1)
@setbutton(intp1&,0)
ELSE
@setbutton(intp0&,0)
@setbutton(intp1&,0)
ENDIF
IF BTST(ints,1)=TRUE THEN
@setbutton(intr0&,1)
@setbutton(intr1&,0)
ELSE
@setbutton(intr0&,0)
@setbutton(intr1&,0)
ENDIF
ELSE
IF BTST(ints,0)=TRUE THEN
@setbutton(intp1&,1)
@setbutton(intp0&,0)
ELSE
@setbutton(intp1&,0)
@setbutton(intp0&,0)
ENDIF
IF BTST(ints,1)=TRUE THEN
@setbutton(intr1&,1)
@setbutton(intr0&,0)
ELSE
@setbutton(intr1&,0)
@setbutton(intr0&,0)
ENDIF
ENDIF
vinta=inta
ENDIF
'
IF demo=FALSE THEN
srca=XBIOS(xbs,229)
src=3 AND (SHR(srca,16))
pre=(srca AND &HFF)
ENDIF
IF vsrca<>srca THEN
IF src=0 THEN
@setbutton(src0&,1)
ELSE
@setbutton(src0&,0)
ENDIF
IF src=1 THEN
@setbutton(src1&,1)
ELSE
@setbutton(src1&,0)
ENDIF
IF src=2 THEN
@setbutton(src2&,1)
ELSE
@setbutton(src2&,0)
ENDIF
IF src=3 THEN
@setbutton(src3&,1)
ELSE
@setbutton(src3&,0)
ENDIF
a$=STR$(pre)+CHR$(0)
@textfeld(rate0&,a$,1)
@maketime
@textfeld(rate1&,a$,1)
vsrca=srca
ENDIF
RETURN
'
> PROCEDURE statmaker
IF obj=statshow& THEN
@devliste2
ENDIF
IF obj=stathelp& THEN
@helptxt("DEVSTAT")
ENDIF
RETURN
'
> PROCEDURE modemaker
~@xrsrc_gaddr(0,mode&,zu%)
zuadr=zu%
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6) AND 255
IF but=22 THEN
IF obj=inswc& THEN
a$=@rsc_text$(popups&,inpop&+popup&)
@textfeld(obj,a$,1)
IF demo=FALSE THEN
IF popup&=1 THEN
~XBIOS(xbs,20,1)
ENDIF
IF popup&=2 THEN
~XBIOS(xbs,20,0)
ENDIF
ENDIF
obj=0
next_obj&=0
ENDIF
IF obj=inlnk& THEN
a$=@rsc_text$(popups&,srcpop&+popup&)
@textfeld(obj,a$,1)
IF demo=FALSE THEN
IF popup&=1 THEN
~XBIOS(xbs,21,0)
ENDIF
IF popup&=2 THEN
~XBIOS(xbs,21,1)
ENDIF
IF popup&=3 THEN
~XBIOS(xbs,21,2)
ENDIF
ENDIF
obj=0
next_obj&=0
ENDIF
ENDIF
IF obj=mat2& THEN
matchannel=2
@setbutton(rec4&,0)
@setbutton(rec8&,0)
@setbutton(rec2&,1)
IF demo=FALSE THEN
~XBIOS(xbs,27,0)
@setmatrtxt
ENDIF
ENDIF
IF obj=mat4& THEN
matchannel=4
IF demo=FALSE THEN
~XBIOS(xbs,27,1)
@setmatrtxt
ENDIF
ENDIF
IF obj=mat8& THEN
matchannel=8
@setbutton(rec2&,0)
@setbutton(rec4&,0)
@setbutton(rec8&,1)
IF demo=FALSE THEN
~XBIOS(xbs,27,2)
@setmatrtxt
ENDIF
ENDIF
IF obj=mat16& THEN
matchannel=16
@setbutton(rec2&,0)
@setbutton(rec4&,0)
@setbutton(rec8&,1)
IF demo=FALSE THEN
~XBIOS(xbs,27,3)
@setmatrtxt
ENDIF
ENDIF
IF obj=mast16& THEN
mastering=16
IF demo=FALSE THEN
~XBIOS(xbs,28,0)
ENDIF
ENDIF
IF obj=mast24& THEN
mastering=24
IF demo=FALSE THEN
~XBIOS(xbs,28,1)
ENDIF
ENDIF
IF obj=ramlo& THEN
bigram=FALSE
IF demo=FALSE THEN
~XBIOS(xbs,70,0)
ENDIF
ENDIF
IF obj=ramhi& THEN
bigram=TRUE
IF demo=FALSE THEN
~XBIOS(xbs,70,1)
ENDIF
ENDIF
IF obj=emula& THEN
IF emulate=FALSE THEN
emulate=TRUE
IF demo=FALSE THEN
~XBIOS(xbs,160,1)
ENDIF
ELSE
emulate=FALSE
IF demo=FALSE THEN
~XBIOS(xbs,160,0)
ENDIF
ENDIF
ENDIF
IF obj=falclk& THEN
IF fclk=FALSE THEN
fclk=TRUE
IF demo=FALSE THEN
~XBIOS(xbs,75,1)
ENDIF
ELSE
fclk=FALSE
IF demo=FALSE THEN
~XBIOS(xbs,75,0)
ENDIF
ENDIF
ENDIF
IF obj=emadc8& THEN
IF emuladc8=FALSE THEN
emuladc8=TRUE
IF demo=FALSE THEN
~XBIOS(xbs,165,1)
ENDIF
ELSE
emuladc8=FALSE
IF demo=FALSE THEN
~XBIOS(xbs,165,0)
ENDIF
ENDIF
ENDIF
IF obj=helpmod& THEN
@helptxt("MODESEL")
ENDIF
IF obj=modekick& THEN
~XBIOS(xbs,60)
@setbutton(obj,0)
ENDIF
IF obj=modevol& THEN
~XBIOS(&H82,0,0)
~XBIOS(&H82,1,0)
~XBIOS(&H82,2,0)
~XBIOS(&H82,3,0)
@setbutton(obj,0)
ENDIF
RETURN
'
> PROCEDURE devmaker
LOCAL a,a1,a2,a3
~@xrsrc_gaddr(0,mode&,zu%)
zuadr=zu%
IF obj=devshow& THEN
@devliste
ENDIF
IF obj=devcohlp& THEN
@helptxt("DEVCOSEL")
ENDIF
a1=dmarec
@readbutton(dmap0&)
IF obj=dmap0& THEN
@readbutton(obj)
IF buttflag=0 THEN
a1=0
ELSE
a1=1
ENDIF
@setbutton(dmap0&,0)
@setbutton(xmita0&,0)
@setbutton(adc0&,0)
ENDIF
IF obj=xmita0& THEN
@readbutton(obj)
IF buttflag=0 THEN
a1=0
ELSE
a1=3
ENDIF
@setbutton(dmap0&,0)
@setbutton(xmita0&,0)
@setbutton(adc0&,0)
ENDIF
IF obj=adc0& THEN
@readbutton(obj)
IF buttflag=0 THEN
a1=0
ELSE
a1=2
ENDIF
@setbutton(dmap0&,0)
@setbutton(xmita0&,0)
@setbutton(adc0&,0)
ENDIF
a2=dac
IF obj=dmap2& THEN
@readbutton(obj)
IF buttflag=0 THEN
a2=0
ELSE
a2=1
ENDIF
@setbutton(dmap2&,0)
@setbutton(xmita2&,0)
@setbutton(adc2&,0)
ENDIF
IF obj=xmita2& THEN
@readbutton(obj)
IF buttflag=0 THEN
a2=0
ELSE
a2=3
ENDIF
@setbutton(dmap2&,0)
@setbutton(xmita2&,0)
@setbutton(adc2&,0)
ENDIF
IF obj=adc2& THEN
@readbutton(obj)
IF buttflag=0 THEN
a2=0
ELSE
a2=2
ENDIF
@setbutton(dmap2&,0)
@setbutton(xmita2&,0)
@setbutton(adc2&,0)
ENDIF
a3=matina
IF obj=dmap1& THEN
@readbutton(obj)
IF buttflag=0 THEN
a3=0
ELSE
a3=1
ENDIF
@setbutton(dmap1&,0)
@setbutton(xmita1&,0)
@setbutton(adc1&,0)
ENDIF
IF obj=xmita1& THEN
@readbutton(obj)
IF buttflag=0 THEN
a3=0
ELSE
a3=3
ENDIF
@setbutton(dmap1&,0)
@setbutton(xmita1&,0)
@setbutton(adc1&,0)
ENDIF
IF obj=adc1& THEN
@readbutton(obj)
IF buttflag=0 THEN
a3=0
ELSE
a3=2
ENDIF
@setbutton(dmap1&,0)
@setbutton(xmita1&,0)
@setbutton(adc1&,0)
ENDIF
'
'
b1=std
IF obj=xmitb2& THEN
b1=2
@setbutton(xmitb2&,1)
@setbutton(dspx2&,0)
@setbutton(exti2&,0)
ENDIF
IF obj=dspx2& THEN
b1=0
@setbutton(xmitb2&,0)
@setbutton(dspx2&,1)
@setbutton(exti2&,0)
ENDIF
IF obj=exti2& THEN
b1=1
@setbutton(xmitb2&,0)
@setbutton(dspx2&,0)
@setbutton(exti2&,1)
ENDIF
b2=pdat
IF obj=xmitb0& THEN
b2=0
@setbutton(xmitb0&,1)
@setbutton(dspx0&,0)
@setbutton(exti0&,0)
ENDIF
IF obj=dspx0& THEN
b2=1
@setbutton(xmitb0&,0)
@setbutton(dspx0&,1)
@setbutton(exti0&,0)
ENDIF
IF obj=exti0& THEN
b2=2
@setbutton(xmitb0&,0)
@setbutton(dspx0&,0)
@setbutton(exti0&,1)
ENDIF
b3=dspin
IF obj=xmitb1& THEN
b3=0
@setbutton(xmitb1&,1)
@setbutton(exti1&,0)
ENDIF
IF obj=exti1& THEN
b3=1
@setbutton(xmitb1&,0)
@setbutton(exti1&,1)
ENDIF
b4=cv
IF obj=conv& THEN
@readbutton(obj)
IF buttflag=0 THEN
b4=0
ELSE
b4=1
ENDIF
@setbutton(conv&,0)
@setmatrtxt
ENDIF
IF b1<>std OR b2<>pdat OR b3<>dspin OR b4<>cv THEN
IF demo=FALSE THEN
~XBIOS(xbs,227,b1,b2,b3,b4)
ENDIF
@devcoread
ENDIF
IF a1<>dmarec OR a2<>dac OR a3<>matina THEN
IF demo=FALSE THEN
~XBIOS(xbs,226,a1,a2,a3)
ENDIF
@devcoread
ENDIF
RETURN
'
> PROCEDURE maketime
IF (src=0 AND fclk=FALSE) OR (src=3 AND fclk=TRUE) THEN
SELECT pre
CASE 0
a$="pll"
CASE 1
a$="32 kHz"
CASE 2
a$="44.1 kHz"
CASE 3
a$="48 kHz"
CASE 4
a$="8 kHz"
CASE 5
a$="11 kHz"
CASE 6
a$="16 kHz"
CASE 7
a$="16.5 kHz"
CASE 8
a$="22 kHz"
CASE 9
a$="22.05 kHz"
CASE 10
a$="24 kHz"
CASE 11
a$="33 kHz"
CASE 12
a$="ext/768"
CASE 13
a$="ext/512"
CASE 14
a$="ext/384"
CASE 15
a$="ext/256"
ENDSELECT
ENDIF
IF src=1 THEN
gp=XBIOS(&H8A,1)
IF (gp AND 6)=0 THEN
a$="SPDIF pll"
ELSE
IF (gp AND 2)=2 THEN
a$="ADAT 48 kHz"
ELSE
IF (gp AND 1)=1 THEN
IF BTST(gp,0)=TRUE THEN
a$="SPDIF 48 kHz"
ELSE
a$="SPDIF 44.1 kHz"
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF src=2 THEN
mhz=24576000
t=INT(pre/15)
t2=1+(pre-t*15)
SELECT t
CASE 0
div=256
CASE 1
div=384
CASE 2
div=512
CASE 3
div=768
ENDSELECT
hz=INT((mhz/t2)/div)
a$=STR$(hz)+" Hz"
ENDIF
IF (src=3 AND fclk=FALSE) OR (src=0 AND fclk=TRUE) THEN
SELECT pre
CASE 0
a$="pll"
CASE 1
a$="49170 Hz"
CASE 2
a$="32780 Hz"
CASE 3
a$="24585 Hz"
CASE 4
a$="19668 Hz"
CASE 5
a$="16390 Hz"
CASE 6
a$="14049 Hz"
CASE 7
a$="12292 Hz"
CASE 8
a$="10927 Hz"
CASE 9
a$="9834 Hz"
CASE 10
a$="8940 Hz"
CASE 11
a$="8195 Hz"
CASE 12
a$="7565 Hz"
CASE 13
a$="7024 Hz"
CASE 14
a$="6556 Hz"
ENDSELECT
ENDIF
a$=a$+CHR$(0)
RETURN
'
> PROCEDURE getsel1
IF demo=FALSE THEN
a=XBIOS(xbs,410)
b=XBIOS(xbs,411)
j=b
IF j>15 THEN
j=15
ENDIF
@clearfsel
IF j>0 THEN
FOR i=1 TO j
a$=""
c=DPEEK(a+i*4-4)
d=DPEEK(a+2+i*4-4)
IF c=0 THEN
a$="DMAPLAY -> "
ENDIF
IF c=1 THEN
a$="DSPXMIT -> "
ENDIF
IF c=2 THEN
a$="EXTINP -> "
ENDIF
IF c=3 THEN
a$="ADC -> "
ENDIF
IF d=0 THEN
a$=a$+"NONE"
ENDIF
IF BTST(d,0)=TRUE THEN
a$=a$+"DMAREC "
ENDIF
IF BTST(d,1)=TRUE THEN
a$=a$+"DSPREC "
ENDIF
IF BTST(d,2)=TRUE THEN
a$=a$+"EXTOUT "
ENDIF
IF BTST(d,3)=TRUE THEN
a$=a$+"DAC "
ENDIF
dbank$(i)=a$
NEXT i
IF j<100 THEN
FOR i=j+1 TO 100
dbank$(i)=""
NEXT i
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE getsel2
LOCAL gl,mbv
IF fsz<0 THEN
fsz=0
ENDIF
mbv=flist
IF mbv>0 THEN
j=fsz+1
'
IF j+14>mbv THEN
j=mbv-14
ENDIF
'
IF j<1 THEN
j=1
ENDIF
gl=j+14
IF mbv<(j+14) THEN
gl=mbv-j+1
ENDIF
IF gl<1 THEN
gl=1
ENDIF
FOR i=j TO gl
IF i<=mbv THEN
a$=dbank$(i)+CHR$(0)
IF bigfoot=FALSE THEN
nfstl=60
ELSE
nfstl=98
ENDIF
IF LEN(a$)>nfstl THEN
a$=LEFT$(a$,nfstl)
ENDIF
b$=STR$(i)+CHR$(0)
IF i=j THEN
@textfeld(fsbut1&,b$,1)
@textfeld(fstxt1&,a$,1)
ENDIF
IF i=j+1 THEN
@textfeld(fsbut2&,b$,1)
@textfeld(fstxt2&,a$,1)
ENDIF
IF i=j+2 THEN
@textfeld(fsbut3&,b$,1)
@textfeld(fstxt3&,a$,1)
ENDIF
IF i=j+3 THEN
@textfeld(fsbut4&,b$,1)
@textfeld(fstxt4&,a$,1)
ENDIF
IF i=j+4 THEN
@textfeld(fsbut5&,b$,1)
@textfeld(fstxt5&,a$,1)
ENDIF
IF i=j+5 THEN
@textfeld(fsbut6&,b$,1)
@textfeld(fstxt6&,a$,1)
ENDIF
IF i=j+6 THEN
@textfeld(fsbut7&,b$,1)
@textfeld(fstxt7&,a$,1)
ENDIF
IF i=j+7 THEN
@textfeld(fsbut8&,b$,1)
@textfeld(fstxt8&,a$,1)
ENDIF
IF i=j+8 THEN
@textfeld(fsbut9&,b$,1)
@textfeld(fstxt9&,a$,1)
ENDIF
IF i=j+9 THEN
@textfeld(fsbut10&,b$,1)
@textfeld(fstxt10&,a$,1)
ENDIF
IF i=j+10 THEN
@textfeld(fsbut11&,b$,1)
@textfeld(fstxt11&,a$,1)
ENDIF
IF i=j+11 THEN
@textfeld(fsbut12&,b$,1)
@textfeld(fstxt12&,a$,1)
ENDIF
IF i=j+12 THEN
@textfeld(fsbut13&,b$,1)
@textfeld(fstxt13&,a$,1)
ENDIF
IF i=j+13 THEN
@textfeld(fsbut14&,b$,1)
@textfeld(fstxt14&,a$,1)
ENDIF
IF i=j+14 THEN
@textfeld(fsbut15&,b$,1)
@textfeld(fstxt15&,a$,1)
ENDIF
ENDIF
NEXT i
ENDIF
RETURN
'
> PROCEDURE getsel3
IF demo=FALSE THEN
a=XBIOS(xbs,413)
b=XBIOS(xbs,414)
@clearfsel
j=0
i=0
IF b>0 THEN
WHILE i<b
a$=""
c=DPEEK(a+i)
IF c=128 THEN
a$="LOCKSND"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=129 THEN
a$="UNLOCKSND"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=130 THEN
a$="SOUNDCMD"
i=i+2
c1=DPEEK(a+i)
i=i+2
c2=DPEEK(a+i)
i=i+2
a$=a$+" "+STR$(c1)+",h"+HEX$(c2)
INC j
dbank$(j)=a$
ENDIF
IF c=131 THEN
a$="SETBUFFER"
i=i+2
c1=DPEEK(a+i)
i=i+2
c2=LPEEK(a+i)
i=i+4
c3=LPEEK(a+i)
i=i+4
a$=a$+" "+STR$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)
INC j
dbank$(j)=a$
ENDIF
IF c=132 THEN
a$="SETMODE"
i=i+2
c1=DPEEK(a+i)
i=i+2
a$=a$+" "+STR$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=133 THEN
a$="SETTRACKS"
i=i+2
c1=DPEEK(a+i)
i=i+2
c2=DPEEK(a+i)
i=i+2
a$=a$+" "+STR$(c1)+","+STR$(c2)
INC j
dbank$(j)=a$
ENDIF
IF c=134 THEN
a$="SETMONTRACKS"
i=i+2
c1=DPEEK(a+i)
i=i+2
a$=a$+" "+STR$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=135 THEN
a$="SETINTERRUPT"
i=i+2
c1=DPEEK(a+i)
i=i+2
c2=DPEEK(a+i)
i=i+2
a$=a$+" "+STR$(c1)+","+STR$(c2)
INC j
dbank$(j)=a$
ENDIF
IF c=136 THEN
a$="BUFFOPER"
i=i+2
c1=DPEEK(a+i)
i=i+2
a$=a$+" b"+BIN$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=137 THEN
a$="DSPTRISTATE"
i=i+2
c1=DPEEK(a+i)
i=i+2
c2=DPEEK(a+i)
i=i+2
a$=a$+" "+STR$(c1)+","+STR$(c2)
INC j
dbank$(j)=a$
ENDIF
IF c=138 THEN
a$="GPIO"
i=i+2
c1=DPEEK(a+i)
i=i+2
c2=DPEEK(a+i)
i=i+2
a$=a$+" "+STR$(c1)+",b"+BIN$(c2)
INC j
dbank$(j)=a$
ENDIF
IF c=139 THEN
a$="DEVCONNECT"
i=i+2
c1=DPEEK(a+i)
i=i+2
c2=DPEEK(a+i)
i=i+2
c3=DPEEK(a+i)
i=i+2
c4=DPEEK(a+i)
i=i+2
c5=DPEEK(a+i)
i=i+2
a$=a$+" "+STR$(c1)+","+STR$(c2)+","+STR$(c3)+","+STR$(c4)+","+STR$(c5)
INC j
dbank$(j)=a$
ENDIF
IF c=140 THEN
a$="SNDSTATUS"
i=i+2
c1=DPEEK(a+i)
i=i+2
a$=a$+" b"+BIN$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=141 THEN
a$="BUFFPTR"
i=i+2
c1=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=96 THEN
a$="Dsp_DoBlock"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=LPEEK(a+i)
i=i+4
c4=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)+",h"+HEX$(c4)
INC j
dbank$(j)=a$
ENDIF
IF c=97 THEN
a$="Dsp_BlkHandShake"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=LPEEK(a+i)
i=i+4
c4=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)+",h"+HEX$(c4)
INC j
dbank$(j)=a$
ENDIF
IF c=98 THEN
a$="Dsp_BlkUnpacked"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=LPEEK(a+i)
i=i+4
c4=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)+",h"+HEX$(c4)
INC j
dbank$(j)=a$
ENDIF
IF c=99 THEN
a$="Dsp_InStream"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=LPEEK(a+i)
i=i+4
c4=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)+",h"+HEX$(c4)
INC j
dbank$(j)=a$
ENDIF
IF c=100 THEN
a$="Dsp_OutStream"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=LPEEK(a+i)
i=i+4
c4=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)+",h"+HEX$(c4)
INC j
dbank$(j)=a$
ENDIF
IF c=101 THEN
a$="Dsp_IOStream"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=LPEEK(a+i)
i=i+4
c4=LPEEK(a+i)
i=i+4
c5=LPEEK(a+i)
i=i+4
c6=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)+",h"+HEX$(c4)+",h"+HEX$(c5)+",h"+HEX$(c6)
INC j
dbank$(j)=a$
ENDIF
IF c=102 THEN
a$="Dsp_RemoveInterrupts"
i=i+2
c1=DPEEK(a+i)
i=i+2
a$=a$+" "+STR$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=103 THEN
a$="Dsp_GetWordSize"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=104 THEN
a$="Dsp_Lock"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=105 THEN
a$="Dsp_Unlock"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=106 THEN
a$="Dsp_Available"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)
INC j
dbank$(j)=a$
ENDIF
IF c=107 THEN
a$="Dsp_Reserve"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)
INC j
dbank$(j)=a$
ENDIF
IF c=108 THEN
a$="Dsp_LoadProg"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=DPEEK(a+i)
i=i+2
c3=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)
INC j
dbank$(j)=a$
ENDIF
IF c=109 THEN
a$="Dsp_ExecProg"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=DPEEK(a+i)
i=i+2
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)
INC j
dbank$(j)=a$
ENDIF
IF c=110 THEN
a$="Dsp_ExecBoot"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=DPEEK(a+i)
i=i+2
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)
INC j
dbank$(j)=a$
ENDIF
IF c=111 THEN
a$="Dsp_LodToBinary"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)
INC j
dbank$(j)=a$
ENDIF
IF c=112 THEN
a$="Dsp_TriggerHC"
i=i+2
c1=DPEEK(a+i)
i=i+2
a$=a$+" h"+HEX$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=113 THEN
a$="Dsp_RequestUniqueAbility"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=114 THEN
a$="Dsp_GetProgAbility"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=115 THEN
a$="Dsp_FlushSubroutines"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=116 THEN
a$="Dsp_LoadSubroutine"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=DPEEK(a+i)
i=i+2
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)
INC j
dbank$(j)=a$
ENDIF
IF c=117 THEN
a$="Dsp_InqSubrAbility"
i=i+2
c1=DPEEK(a+i)
i=i+2
a$=a$+" h"+HEX$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=118 THEN
a$="Dsp_RunSubroutine"
i=i+2
c1=DPEEK(a+i)
i=i+2
a$=a$+" h"+HEX$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=119 THEN
a$="Dsp_HF0"
i=i+2
c1=DPEEK(a+i)
i=i+2
a$=a$+" h"+HEX$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=120 THEN
a$="Dsp_HF1"
i=i+2
c1=DPEEK(a+i)
i=i+2
a$=a$+" h"+HEX$(c1)
INC j
dbank$(j)=a$
ENDIF
IF c=121 THEN
a$="Dsp_HF2"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=122 THEN
a$="Dsp_HF3"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=123 THEN
a$="Dsp_BlkWords"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=LPEEK(a+i)
i=i+4
c4=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)+",h"+HEX$(c4)
INC j
dbank$(j)=a$
ENDIF
IF c=124 THEN
a$="Dsp_BlkBytes"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=LPEEK(a+i)
i=i+4
c4=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)+",h"+HEX$(c4)
INC j
dbank$(j)=a$
ENDIF
IF c=125 THEN
a$="Dsp_HStat"
i=i+2
INC j
dbank$(j)=a$
ENDIF
IF c=126 THEN
a$="Dsp_SetVectors"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)
INC j
dbank$(j)=a$
ENDIF
IF c=127 THEN
a$="Dsp_MultBlocks"
i=i+2
c1=LPEEK(a+i)
i=i+4
c2=LPEEK(a+i)
i=i+4
c3=LPEEK(a+i)
i=i+4
c4=LPEEK(a+i)
i=i+4
a$=a$+" h"+HEX$(c1)+",h"+HEX$(c2)+",h"+HEX$(c3)+",h"+HEX$(c4)
INC j
dbank$(j)=a$
ENDIF
WEND
flist=j
IF j<100 THEN
FOR i=j+1 TO 100
dbank$(i)=""
NEXT i
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE clearfsel
@textfeld(fstxt1&,CHR$(0),1)
@textfeld(fstxt2&,CHR$(0),1)
@textfeld(fstxt3&,CHR$(0),1)
@textfeld(fstxt4&,CHR$(0),1)
@textfeld(fstxt5&,CHR$(0),1)
@textfeld(fstxt6&,CHR$(0),1)
@textfeld(fstxt7&,CHR$(0),1)
@textfeld(fstxt8&,CHR$(0),1)
@textfeld(fstxt9&,CHR$(0),1)
@textfeld(fstxt10&,CHR$(0),1)
@textfeld(fstxt11&,CHR$(0),1)
@textfeld(fstxt12&,CHR$(0),1)
@textfeld(fstxt13&,CHR$(0),1)
@textfeld(fstxt14&,CHR$(0),1)
@textfeld(fstxt15&,CHR$(0),1)
@textfeld(fsbut1&,CHR$(0),1)
@textfeld(fsbut2&,CHR$(0),1)
@textfeld(fsbut3&,CHR$(0),1)
@textfeld(fsbut4&,CHR$(0),1)
@textfeld(fsbut5&,CHR$(0),1)
@textfeld(fsbut6&,CHR$(0),1)
@textfeld(fsbut7&,CHR$(0),1)
@textfeld(fsbut8&,CHR$(0),1)
@textfeld(fsbut9&,CHR$(0),1)
@textfeld(fsbut10&,CHR$(0),1)
@textfeld(fsbut11&,CHR$(0),1)
@textfeld(fsbut12&,CHR$(0),1)
@textfeld(fsbut13&,CHR$(0),1)
@textfeld(fsbut14&,CHR$(0),1)
@textfeld(fsbut15&,CHR$(0),1)
RETURN
'
> PROCEDURE clearfsel2
.| Glob. Var.: i#,flist#,wurl#
.| Felder    : dbank$(),dbank2$(),wurlnr#()
.| Aufruf in : getsel5-1,
FOR i=1 TO 500
dbank$(i)=""
NEXT i
RETURN
'
> PROCEDURE fsbutset
IF mfsz<>0 THEN
a=mfsz-fsz
IF a>=1 AND a<=15 THEN
IF a=1 THEN
obj=fsbut1&
ENDIF
IF a=2 THEN
obj=fsbut2&
ENDIF
IF a=3 THEN
obj=fsbut3&
ENDIF
IF a=4 THEN
obj=fsbut4&
ENDIF
IF a=5 THEN
obj=fsbut5&
ENDIF
IF a=6 THEN
obj=fsbut6&
ENDIF
IF a=7 THEN
obj=fsbut7&
ENDIF
IF a=8 THEN
obj=fsbut8&
ENDIF
IF a=9 THEN
obj=fsbut9&
ENDIF
IF a=10 THEN
obj=fsbut10&
ENDIF
IF a=11 THEN
obj=fsbut11&
ENDIF
IF a=12 THEN
obj=fsbut12&
ENDIF
IF a=13 THEN
obj=fsbut13&
ENDIF
IF a=14 THEN
obj=fsbut14&
ENDIF
IF a=15 THEN
obj=fsbut15&
ENDIF
@setbutton(obj,1)
nfk=a
mfsz=fsz+nfk
nfk2=obj
ENDIF
ENDIF
RETURN
'
> PROCEDURE devliste
LOCAL j,g,x,y,k,v1,v2,v3,v4,nobj,ofil$,nx,ny
'
@setbutton(obj,0)
onr=nr
nr=seedev&
@rsc_draw(nr,0)
'
a=XBIOS(xbs,416,-1)
IF BTST(a,0)=TRUE THEN
@setbutton(fssnd&,1)
kdsp=FALSE
ELSE
@setbutton(fssnd&,0)
kdsp=TRUE
ENDIF
IF BTST(a,1)=TRUE THEN
@setbutton(fsdsp&,1)
ELSE
@setbutton(fsdsp&,0)
ENDIF
IF kdsp=TRUE THEN
@rsc_state(nr,fsdsp&,3,TRUE)
~@xrsrc_gaddr(0,nr,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,fsdsp&,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
@rsc_state(nr,fsdsp&,3,FALSE)
~@xrsrc_gaddr(0,nr,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,fsdsp&,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
IF BTST(a,2)=TRUE THEN
@setbutton(fsdevc&,1)
ELSE
@setbutton(fsdevc&,0)
ENDIF
'
fsl=15                     ! Anzahl der lines
flist=100
@clearfsel
@clearfsel2
fsz=0
@fselslidset
@getsel1
@getsel2
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
@readbutton(obj)
'
IF kdsp=FALSE THEN
IF obj=fsdsp& THEN
a=XBIOS(xbs,416,-1)
IF BTST(a,1)=TRUE THEN
a=BCLR(a,1)
~XBIOS(xbs,416,a)
@setbutton(obj,0)
ELSE
a=BSET(a,1)
~XBIOS(xbs,416,a)
@setbutton(obj,1)
ENDIF
ENDIF
ENDIF
IF obj=fsdevc& THEN
a=XBIOS(xbs,416,-1)
IF BTST(a,2)=TRUE THEN
a=BCLR(a,2)
~XBIOS(xbs,416,a)
@setbutton(obj,0)
ELSE
a=BSET(a,2)
~XBIOS(xbs,416,a)
@setbutton(obj,1)
ENDIF
ENDIF
IF obj=fssnd& THEN
a=XBIOS(xbs,416,-1)
IF BTST(a,0)=TRUE THEN
a=BCLR(a,0)
~XBIOS(xbs,416,a)
@setbutton(obj,0)
kdsp=TRUE
@rsc_state(nr,fsdsp&,3,kdsp)
~@xrsrc_gaddr(0,nr,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,fsdsp&,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
a=BSET(a,0)
~XBIOS(xbs,416,a)
@setbutton(obj,1)
kdsp=FALSE
@rsc_state(nr,fsdsp&,3,kdsp)
~@xrsrc_gaddr(0,nr,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,fsdsp&,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ENDIF
'
IF obj=fsclip& THEN
IF flist>0 THEN
~SCRP_READ(a$)
IF a$<>"" THEN
a=FSFIRST(a$,16)
IF a=0 THEN
OPEN "O",#1,a$+"\STARDEV.TXT"
PRINT #1,"StarTrack Analyser -> Devconnect"
PRINT #1,"--------------------------------"
PRINT #1
FOR i=1 TO flist
PRINT #1,dbank$(i)
NEXT i
CLOSE #1
ELSE
@alerts(7)
ENDIF
ELSE
@alerts(7)
ENDIF
ENDIF
@setbutton(obj,0)
ENDIF
IF obj=fsclear& THEN
IF demo=FALSE THEN
~XBIOS(xbs,412)
ENDIF
@setbutton(obj,0)
@clearfsel
@clearfsel2
fsz=0
fsz2=0
@getsel1
@getsel2
@fselslidset
ENDIF
IF obj=fshelp& THEN
IF fsmplay=FALSE THEN
@helptxt("DEVCONNECT-ANALYSE")
ENDIF
ENDIF
'
IF obj=fssldup& THEN
IF fsz2>0 THEN
@slideup2(fsslide&,fssldbut&,fsmax,fsplus,fsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@fscalc
@getsel2
ENDIF
ENDIF
@setbutton(fssldup&,0)
ENDIF
IF obj=fsslddwn& THEN
IF fsz2+0.00001<(fsmax-fstep) THEN
@slidedwn2(fsslide&,fssldbut&,fsmax,fstep,fsplus,fsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@fscalc
@getsel2
ENDIF
ENDIF
@setbutton(fsslddwn&,0)
ENDIF
UNTIL obj=fsexit&
IF obj<>0 THEN
@setbutton(obj,0)
ENDIF
'
@setbutton(obj,0)
@rsc_back(nr)
nr=onr
'
RETURN
'
> PROCEDURE devliste2
LOCAL j,g,x,y,k,v1,v2,v3,v4,nobj,ofil$,nx,ny
'
@setbutton(obj,0)
onr=nr
nr=seedev&
@rsc_draw(nr,0)
'
a=XBIOS(xbs,416,-1)
IF BTST(a,0)=TRUE THEN
@setbutton(fssnd&,1)
kdsp=FALSE
ELSE
@setbutton(fssnd&,0)
kdsp=TRUE
ENDIF
IF BTST(a,1)=TRUE THEN
@setbutton(fsdsp&,1)
ELSE
@setbutton(fsdsp&,0)
ENDIF
IF kdsp=TRUE THEN
@rsc_state(nr,fsdsp&,3,TRUE)
~@xrsrc_gaddr(0,nr,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,fsdsp&,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
@rsc_state(nr,fsdsp&,3,FALSE)
~@xrsrc_gaddr(0,nr,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,fsdsp&,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
IF BTST(a,2)=TRUE THEN
@setbutton(fsdevc&,1)
ELSE
@setbutton(fsdevc&,0)
ENDIF
'
flist=0
@clearfsel
@clearfsel2
fsl=15                     ! Anzahl der lines
fsz=0
fsz2=0
@getsel3
@getsel2
@fselslidset
REPEAT
REPEAT
obj=@rsc_do(nr,0,popup&)
~@xrsrc_gaddr(0,nr,zu%)
zuadr=zu%
UNTIL obj<>0 AND obj<>-1
buttadr=zuadr+24*obj
but=DPEEK(buttadr+6)
REPEAT
UNTIL @mousek=0
~@xrsrc_gaddr(1,obj,zu%)
objadr=zu%
objflag=DPEEK(objadr+8)
@readbutton(obj)
'
IF kdsp=FALSE THEN
IF obj=fsdsp& THEN
IF demo=FALSE THEN
a=XBIOS(xbs,416,-1)
IF BTST(a,1)=TRUE THEN
a=BCLR(a,1)
~XBIOS(xbs,416,a)
@setbutton(obj,0)
ELSE
a=BSET(a,1)
~XBIOS(xbs,416,a)
@setbutton(obj,1)
ENDIF
ELSE
@setbutton(obj,0)
ENDIF
ENDIF
ENDIF
IF obj=fsdevc& THEN
a=XBIOS(xbs,416,-1)
IF BTST(a,2)=TRUE THEN
a=BCLR(a,2)
~XBIOS(xbs,416,a)
@setbutton(obj,0)
ELSE
a=BSET(a,2)
~XBIOS(xbs,416,a)
@setbutton(obj,1)
ENDIF
ENDIF
IF obj=fssnd& THEN
IF demo=FALSE THEN
a=XBIOS(xbs,416,-1)
IF BTST(a,0)=TRUE THEN
a=BCLR(a,0)
~XBIOS(xbs,416,a)
@setbutton(obj,0)
kdsp=TRUE
@rsc_state(nr,fsdsp&,3,kdsp)
~@xrsrc_gaddr(0,nr,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,fsdsp&,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
a=BSET(a,0)
~XBIOS(xbs,416,a)
@setbutton(obj,1)
kdsp=FALSE
@rsc_state(nr,fsdsp&,3,kdsp)
~@xrsrc_gaddr(0,nr,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,fsdsp&,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
ELSE
@setbutton(obj,0)
ENDIF
ENDIF
'
IF obj=fsclip& THEN
IF flist>0 THEN
~SCRP_READ(a$)
IF a$<>"" THEN
a=FSFIRST(a$,16)
IF a=0 THEN
OPEN "O",#1,a$+"\STARSND.TXT"
PRINT #1,"StarTrack Analyser -> Aufgerufene Soundroutinen"
PRINT #1,"-----------------------------------------------"
PRINT #1
FOR i=1 TO flist
PRINT #1,dbank$(i)
NEXT i
CLOSE #1
ELSE
@alerts(7)
ENDIF
ELSE
@alerts(7)
ENDIF
ENDIF
@setbutton(obj,0)
ENDIF
IF obj=fsclear& THEN
IF demo=FALSE THEN
~XBIOS(xbs,415)
ENDIF
@setbutton(obj,0)
flist=0
@clearfsel
@clearfsel2
fsz=0
fsz2=0
@getsel3
@getsel2
@fselslidset
ENDIF
IF obj=fshelp& THEN
IF fsmplay=FALSE THEN
@helptxt("SOUNDCALL-ANALYSE")
ENDIF
ENDIF
'
IF obj=fssldup& THEN
IF fsz2>0 THEN
@slideup2(fsslide&,fssldbut&,fsmax,fsplus,fsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@fscalc
@getsel2
ENDIF
ENDIF
@setbutton(fssldup&,0)
ENDIF
IF obj=fsslddwn& THEN
IF fsz2+0.00001<(fsmax-fstep) THEN
@slidedwn2(fsslide&,fssldbut&,fsmax,fstep,fsplus,fsz2,slflg)
IF slflg=TRUE THEN
@clearfsel
@fscalc
@getsel2
ENDIF
ENDIF
@setbutton(fsslddwn&,0)
ENDIF
UNTIL obj=fsexit&
IF obj=fsexit& THEN
@setbutton(obj,0)
ENDIF
'
@rsc_back(nr)
nr=onr
'
RETURN
'
' ENDE
