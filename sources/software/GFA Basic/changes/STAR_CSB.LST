$m5000
$e$
'
'
gemvers=GEMDOS(48)
dreidim=TRUE
@initialize
'
language=2                ! Sprache 1=deutsch,2=englisch
xload=FALSE
windowda=FALSE
xbs=500                   ! my_xbios
' ON ERROR GOSUB fehler
'
' CBL-Reader zum STARTRACK-Sampler
'
CLIP OFF
startup=FALSE
compile=BYTE{ADD(BASEPAGE,256)}<>96
acc=({ADD(BASEPAGE,36)}=0)
INLINE m_busy%,592
m_adr%=m_busy%
xwidth=WORK_OUT(0)+1
ywidth=WORK_OUT(1)+1
bigfoot=FALSE
IF xwidth>=998 AND ywidth>=662 THEN
  bigfoot=TRUE
ENDIF
@busy_mouse
'
' ------------------------------------------------------------------------------
' ------------------------RSC-VARIABLEN-----------------------------------------
' ------------------------------------------------------------------------------
REM Resource Datei Indizes fÅr STAR_CSB
'
LET cbl&=0 ! Formular/Dialog
LET cblbox1&=0 ! BOX in Baum CBL
LET cblexit&=2 ! BUTTON in Baum CBL
LET cblhelp&=3 ! BOXTEXT in Baum CBL
LET cblbox2&=5 ! BOX in Baum CBL
LET byt15&=7 ! BOXTEXT in Baum CBL
LET channel&=8 ! BOXTEXT in Baum CBL
LET byt13&=10 ! BOXTEXT in Baum CBL
LET source&=11 ! BOXTEXT in Baum CBL
LET byt16&=12 ! BOXTEXT in Baum CBL
LET byt17&=13 ! BOXTEXT in Baum CBL
LET byt18&=14 ! BOXTEXT in Baum CBL
LET byt19&=15 ! BOXTEXT in Baum CBL
LET byt20&=16 ! BOXTEXT in Baum CBL
LET byt21&=17 ! BOXTEXT in Baum CBL
LET byt22&=18 ! BOXTEXT in Baum CBL
LET byt4&=19 ! BOXTEXT in Baum CBL
LET byt5&=20 ! BOXTEXT in Baum CBL
LET byt6&=21 ! BOXTEXT in Baum CBL
LET byt7&=22 ! BOXTEXT in Baum CBL
LET byt8&=23 ! BOXTEXT in Baum CBL
LET byt9&=24 ! BOXTEXT in Baum CBL
LET byt10&=25 ! BOXTEXT in Baum CBL
LET byt11&=26 ! BOXTEXT in Baum CBL
LET byt12&=27 ! BOXTEXT in Baum CBL
LET byt14&=28 ! BOXTEXT in Baum CBL
LET cblbox3&=29 ! BOX in Baum CBL
LET digital&=30 ! BUTTON in Baum CBL
LET nonaudio&=31 ! BUTTON in Baum CBL
LET cblbox4&=32 ! BOX in Baum CBL
LET cprot&=33 ! BUTTON in Baum CBL
LET cfree&=34 ! BUTTON in Baum CBL
LET cblbox5&=35 ! BOX in Baum CBL
LET orig&=36 ! BUTTON in Baum CBL
LET firstgen&=37 ! BUTTON in Baum CBL
LET cblbox6&=38 ! BOX in Baum CBL
LET channel2&=39 ! BUTTON in Baum CBL
LET channel4&=40 ! BUTTON in Baum CBL
LET cblbox7&=41 ! BOX in Baum CBL
LET hz32&=42 ! BUTTON in Baum CBL
LET hz44&=43 ! BUTTON in Baum CBL
LET hz48&=44 ! BUTTON in Baum CBL
LET cblbox15&=45 ! BOX in Baum CBL
LET ppm50&=46 ! BUTTON in Baum CBL
LET ppm1000&=47 ! BUTTON in Baum CBL
LET ppmvar&=48 ! BUTTON in Baum CBL
LET cblbox8&=49 ! BOX in Baum CBL
LET empha&=50 ! BUTTON in Baum CBL
LET digdat&=51 ! BUTTON in Baum CBL
LET cblbox9&=52 ! BOX in Baum CBL
LET general&=53 ! BUTTON in Baum CBL
LET experim&=54 ! BUTTON in Baum CBL
LET solid&=55 ! BUTTON in Baum CBL
LET broad&=56 ! BUTTON in Baum CBL
LET digconv&=57 ! BUTTON in Baum CBL
LET adwitho&=58 ! BUTTON in Baum CBL
LET adwith&=59 ! BUTTON in Baum CBL
LET laser&=60 ! BUTTON in Baum CBL
LET instrum&=61 ! BUTTON in Baum CBL
LET tape&=62 ! BUTTON in Baum CBL
LET categres&=63 ! BUTTON in Baum CBL
LET cblbox10&=64 ! BOX in Baum CBL
LET japan&=65 ! BUTTON in Baum CBL
LET usa&=66 ! BUTTON in Baum CBL
LET europe&=67 ! BUTTON in Baum CBL
LET soft&=68 ! BUTTON in Baum CBL
LET landres&=69 ! BUTTON in Baum CBL
LET cblbox11&=70 ! BOX in Baum CBL
LET pcm&=71 ! BUTTON in Baum CBL
LET sampler&=72 ! BUTTON in Baum CBL
LET mixer&=73 ! BUTTON in Baum CBL
LET srconv&=74 ! BUTTON in Baum CBL
LET convres&=75 ! BUTTON in Baum CBL
LET cblbox12&=76 ! BOX in Baum CBL
LET cd&=77 ! BUTTON in Baum CBL
LET magneto&=78 ! BUTTON in Baum CBL
LET cdres&=79 ! BUTTON in Baum CBL
LET cblbox13&=80 ! BOX in Baum CBL
LET synth&=81 ! BUTTON in Baum CBL
LET micro&=82 ! BUTTON in Baum CBL
LET instres&=83 ! BUTTON in Baum CBL
LET cblbox14&=84 ! BOX in Baum CBL
LET dat&=85 ! BUTTON in Baum CBL
LET vcr&=86 ! BUTTON in Baum CBL
LET taperes&=87 ! BUTTON in Baum CBL
LET byt23&=88 ! BOXTEXT in Baum CBL
'
LET alertbox&=1 ! Formular/Dialog
LET alertcol&=0 ! BOX in Baum ALERTBOX
'
OPTION BASE 0
IF compile=FALSE THEN
  RESERVE 200000
ENDIF
'
maxcol=WORK_OUT(13)
'
'
' ------------------------------------------------------------------------------
' ------------------------AUFLôSUNG ERFRAGEN------------------------------------
' ------------------------------------------------------------------------------
IF xwidth<728 OR ywidth<512 THEN
  @alerts(1)
  IF acc=TRUE THEN
    GOTO ende
  ELSE
    END
  ENDIF
ENDIF
'
' ------------------------------------------------------------------------------
' ------------------------RSC LADEN---------------------------------------------
' ------------------------------------------------------------------------------
DEFMOUSE 0
KEYPAD 0                    ! wg KompatibilitÑt (normale Tastatureinstellung)
'
btree=alertbox&                      ! Anzahl der BÑume-1
popup&=0
@rsc_init
'
mtype=INT(C:rsc_cookie%(L:CVL("_MCH"))/&H10000)          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
magicmac=INT(C:rsc_cookie%(L:CVL("MgMc")))          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
pci=INT(C:rsc_cookie%(L:CVL("_PCI")))          ! COOKIE-ABFRAGE Maschinentyp : 0,1=ST   2=TT,Medusa
IF mtype=2 THEN
  vme=&HFEFF0000
ELSE
  vme=&HDF0000
ENDIF
adr=vme+&H401
'
' ---------------------------.ACC-Abfrage---------------------------------------
IF acc=TRUE THEN
  ap_id&=APPL_INIT()
  IF ap_id&
    me_id&=MENU_REGISTER(ap_id&,"  SP/DIF-Status")
    DO
      ~EVNT_MESAG(0)
      IF MENU(1)=40
        accx=TRUE
        GOTO start
      ende:
      ENDIF
    LOOP
  ENDIF
ENDIF
'
start:
@loaddesk
@treiberload
IF rscda=TRUE THEN
  @cblconsumer
  IF acc=TRUE THEN
    GOTO ende
  ELSE
    END
  ENDIF
ELSE
  GEMSYS 109                                        ! Nur ab GEM 1.04!
  @goodbye
  IF acc=TRUE THEN
    GOTO ende
  ENDIF
ENDIF
IF away=TRUE THEN
  @alerts(3)
  IF acc=TRUE THEN
    GOTO ende
  ELSE
    END
  ENDIF
ENDIF
END
'
' ------------------------------------------------------------------------------
' ------------------------FLYDIALS--------------------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE key
  .| Glob. Var.: key&,edit_obj&,cont&,rsc_adr%,next_obj&,idx&,obj&,mrkhandle2#
  .|     v1#,v2#,v3#,ascii|,scan|,a#,shift&,title&,shcut#,nob#,nr#,keytab%,a&
  .|     a$,tree&,evnt&,mb&,mx&,my&
  .| Felder    : rsc_adr%()
  .| Ruft auf  : form_keybd,rsc_shortcut
  .| Aufruf in : rsc_do-1,
  LOCAL bs
  ' Mîchten Sie erweiterte Tastaturkommandos? Dann entREMen Sie
  ' diese Zeile und ersetzen die Prozedur durch:
  '  IF key& AND edit_obj&<>0     ! vorher so....
  IF (key& AND edit_obj&<>0) OR (((key& AND 255)=13) AND ((key& DIV 256)<>50))    ! jetzt so....
    cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  ENDIF
  '  cont&=@form_keybd(rsc_adr%,edit_obj&,key&,0,next_obj&,key&,idx&)
  '
  obj&=0
  ~WIND_GET(MENU(4),10,mrkhandle2,v1,v2,v3)
  '  ~WIND_GET(mrkhandle,10,mrkhandle2,v1,v2,v3)
  '
  ascii|=BYTE(key&)                                  ! ASCII-Code
  scan|=BYTE(SHR(key&,8))                            ! SCAN-Code
  shcut=FALSE
  '
  rsc_adr%=rsc_adr%(nr)
  IF ascii|=0                                        ! Kein ASCII-Code...
    '
    IF scan|=97 OR scan|=98                          ! UNDO/HELP...
      ascii|=ADD(SUB(scan|,97),14)
      mb&=0
      obj&=0
      '
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
      '
      IF BTST(OB_FLAGS(rsc_adr%,obj&),ascii|)
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE IF scan|>=59 AND scan|<=68                  ! F-Tasten...
      ascii|=SUB(scan|,58)
      obj&=0
      DO WHILE BTST(OB_FLAGS(rsc_adr%,obj&),5)=FALSE
        INC obj&
      LOOP UNTIL SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
      IF SHR&(OB_STATE(rsc_adr%,obj&),12)=ascii|
        cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
      ENDIF
      '
    ELSE                                             ! ALT+Buchstabe...
      '
      IF scan|>=120 AND scan|<=129                   ! Zahlen...
        SUB scan|,118
        keytab%={XBIOS(16,L:-1,L:-1,L:-1)}           ! ...ohne Shift
      ELSE                                           ! Alles andere...
        keytab%={ADD(XBIOS(16,L:-1,L:-1,L:-1),4)}    ! ...mit Shift
      ENDIF
      '
      ascii|=BYTE{ADD(keytab%,scan|)}                ! ASCII-Code holen
      IF ascii|<>0                                      ! Tastaturbedienbar...
        CLR a&,obj&
        '
        DO WHILE NOT BTST(OB_FLAGS(rsc_adr%,obj&),5) ! Nicht LASTOBJ
          INC obj&
          '
          scan|=BYTE(SHR(OB_TYPE(rsc_adr%,obj&),8))
          IF scan|=26 OR scan|=28                    ! Ein Button/String...
            a$=@rsc_text$(tree&,obj&)                ! ...Text
            '
            a&=INSTR(a$,"[")
            IF a&                                    ! Tastaturbedienbar...
              a&=ASC(MID$(a$,SUCC(a&),1))
              a&=(BCLR(a&,5)=ascii|) OR (a&>=48 AND a&<=57 AND a&=ascii|)
            ENDIF
            '                                        ! '[' vor Zeichen
          ENDIF
          '
        LOOP UNTIL a&                                ! ...gefunden
        '
        IF a&                                        ! Objekt gefunden...
          key&=0                                     ! ...keine Eingabe mehr
          mb&=0
          '                                          ! +SHIFT Circle-Butt?
          IF BTST(shift&,1) AND BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5) AND SHR(OB_TYPE(rsc_adr%,obj&+2),8)=27
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simulieren
            ~OBJC_OFFSET(rsc_adr%,obj&+2,mx&,my&)
            '                                        ! Ist es ein Popup...
          ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),6) AND BTST(OB_STATE(rsc_adr%,SUCC(obj&)),5)
            evnt&=BSET(evnt&,1)
            mb&=1                                    ! ...Mausklick simul.
            ~OBJC_OFFSET(rsc_adr%,obj&,mx&,my&)
          ELSE                                       ! ...Button bedienen
            cont&=FORM_BUTTON(rsc_adr%,obj&,1,next_obj&)
          ENDIF
        ENDIF
        '
      ENDIF
    ENDIF
    '
  ENDIF
  '
  IF next_obj&<>0 AND edit_obj&<>next_obj&
    ~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,3,idx&)  ! ...Eingabe
  ENDIF
  '  obj=obj&
  '
RETURN
> PROCEDURE message
  .| Glob. Var.: handle&,a&,rsc_trees&,accwindopen#,tree&,rsc_window&
  .|     next_obj&,edit_obj&,idx&,nr#,peak&,peakint#,mx#,my#,mz#,rsc_adr%,n#
  .|     butdirect#,butnr#,donr#,h#,a#,smpedit&,mnr#,cs#,ce#
  .| Felder    : rsc_handle%(),rsc_adr%()
  .| Ruft auf  : markhlp,rsc_message,mouse,button,rsc_redraw_obj,curve
  .|     markprod3
  .| Aufruf in : rsc_do-1,helptxt-2,
  LOCAL iz
  handle&=MENU(4)                                    ! ...Fenster-Handle
  '
  FOR a&=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
    EXIT IF handle&=rsc_handle%(a&)
  NEXT a&
  '
  '  IF handle&=rsc_handle%(a&) THEN
  '  mywindow=TRUE
  '  wind_active=a&
  ' ELSE
  '  mywindow=FALSE
  '  wind_active=0
  ' ENDIF
  '
  IF MENU(1)=&H4724 THEN
    accwindopen=TRUE
  ENDIF
  IF MENU(1)=41 OR (MENU(1)=22 AND tree&=a&)         ! AC_CLOSE/Closer...
    MUL rsc_window&,-(MENU(1)=22)
    '
    next_obj&=9999                                   ! ...Exit-Code
    '
    GOTO rsc_dox_ende                                ! ...rsc_do verlassen
    '
  ELSE IF a&>-1 AND NOT (MENU(1)=21 AND a&<>tree&)   ! Ein RSC-Fenster....
    rsc_message(a&,MENU(1),MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
    '
  ELSE IF MENU(1)=40 OR MENU(1)=21                   ! AC_OPEN/Anderes Fenster toppen...
    '
    IF a&<>-1 THEN
      IF handle&=rsc_handle%(a&) THEN
        tree&=a&
        nr=tree&
        @mouse(mx,my,mz)
        rsc_adr%=rsc_adr%(tree&)
        n=OBJC_FIND(rsc_adr%,0,100,mx,my)
        IF n<>0 AND n<>-1 THEN
          @button
          butdirect=TRUE
          butnr=donr
        ENDIF
      ENDIF
    ENDIF
    rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
  ELSE IF MENU(1)<>21 AND MENU(1)<>22                ! nicht toppen/schlieûen...
  ELSE                                               ! Nichts zu machen...
    ~BIOS(3,2,7)
  ENDIF
  IF MENU(1)=20 THEN
    h=MENU(4)                                    ! ...Fenster-Handle
    FOR a=rsc_trees& DOWNTO 0                         ! Ist es ein RSC?...
      EXIT IF h=rsc_handle%(a)
    NEXT a
    ha1=h
  ENDIF
rsc_dox_ende:
RETURN
> PROCEDURE button
  .| Glob. Var.: mrkhandle2#,mx&,my&,rsc_adr%,nr#,next_obj&,fsel&,fssldbut&
  .|     fsslide&,fsmax#,fsz#,slflg#,arranger&,arrslbut&,arrslide&,slmax#,pbz#
  .|     trakker&,trakxbut&,trakslid&,tmax#,trakkz#,trakybut&,trkvslid&,tymax#
  .|     trakkyz#,virtual&,vslbut&,vslider&,hbg#,hbz#,vhbldstrt#,smplen#,zu%
  .|     edit_obj&,idx&,vblkstrt&,a$,slr#,hbgm#,mt#,vslc#,lslide#,smpedit&
  .|     zoombutt&,mrz#,zoomp#,mrcs#,cs#,mrce#,ce#,zomslide&,zmax#,mrzoom#
  .|     scrlslde&,scrolbut&,scmax#,scrollp#,mrscroll#,scteil#,scrolm#,vmem#
  .|     cached#,scstep#,peak&,cont&,tree&,evnt&,obj&,ob_tail&,rsc_popup&,b$
  .|     popup&,rate&,digana#,mover&,input&,source&,dsp&,rate2&,smp16&
  .|     makerate&,arrmake&,make&,mb&,editfade&,peakmute&,arrm1&,arrm2&,arrm3&
  .|     arrm4&,arrclip&,leave#,v#,v2#,v3#,v4#
  .| Felder    : rsc_adr%(),rscx&(),rscy&(),rscw&(),rsch&()
  .| Ruft auf  : sliding,fsnrset,setbutton,slideupdate,arrnrset,timeline
  .|     blkart,slidelr,textbutt,zoomcalc,scrollinit,setslide,restaura
  .|     rsc_movedial,rsc_text,rsc_popup,rsc_set_cursor,edhandler2
  .| Aufruf in : message-1,rsc_do-2,
  LOCAL popok,dif
  leave=FALSE
  mrkhandle2=WIND_FIND(mx&,my&)
  '  IF mrkhandle=mrkhandle2 THEN
  '  v=WIND_GET(mrkhandle2,10,kenn,v1,v2,v3)
  '  IF v<>0 AND kenn=mrkhandle2 THEN
  rsc_adr%=rsc_adr%(nr)
  next_obj&=OBJC_FIND(rsc_adr%,0,100,mx&,my&)
  '
  '                                                  ! String vor Popup...
  IF next_obj&>0
    IF BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND SHR(OB_TYPE(rsc_adr%,next_obj&),8)=28 AND BTST(OB_STATE(rsc_adr%,SUCC(next_obj&)),5)
      ' (TOUCHEXIT, STRING, SUCC: SHADOWED)
      INC next_obj&
    ENDIF
  ENDIF
  '
  IF next_obj&=-1                                    ! Neben die Box...
    IF rsc_mtsk!=FALSE THEN
      SOUND 1,15,10,4,10
      SOUND 0,0,0,0,0
    ENDIF
    next_obj&=0
  ELSE
    '
    cont&=FORM_BUTTON(rsc_adr%,next_obj&,1,next_obj&)
    ' ------------------------------------------------ Flydial-Ecke
    IF BTST(OB_STATE(rsc_adr%,next_obj&),1)          ! (CROSSED)
      rsc_movedial(tree&,edit_obj&,idx&)             ! ...Dialog verschieben
      '
      next_obj&=0                                    ! Damit der Cursor..
      cont&=1                                        ! ..bleibt wo er ist
      ' ---------------------------------------------- Circle-Button...
    ELSE IF SHR(OB_TYPE(rsc_adr%,next_obj&),8)=27 AND BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),5) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,PRED(next_obj&))),3))
      ' (G_BOXCHAR, PRED: SHADOWED /NOT DISABLED)
      '
      popok2=TRUE
      IF popok2=TRUE THEN
        next_obj&=PRED(next_obj&)                      ! Objektnr. Button
        a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
        evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
        '
        obj&=1
        FOR ob_tail&=1 TO PRED(evnt&)
          obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
        NEXT ob_tail&
        '
        evnt&=SUCC(obj&)
        b$=@rsc_text$(rsc_popup&,evnt&)
        DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
          INC evnt&                                    ! Defaulteintrag
        LOOP
        '
        REPEAT
          INC evnt&                                    ! NÑchster Eintrag...
          IF evnt&>OB_TAIL(rsc_adr%(rsc_popup&),obj&)  ! ...gibt es nicht
            evnt&=SUCC(obj&)                           ! ...dann wieder 1.
          ENDIF
          '                                            ! bis nicht DISABLED
        UNTIL NOT BTST(OB_STATE(rsc_adr%(rsc_popup&),evnt&),3)
        '                                              ! Button Ñndern...
        rsc_text(tree&,next_obj&,@rsc_text$(rsc_popup&,evnt&))
        ~OBJC_DRAW(rsc_adr%,next_obj&,1,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
        popup&=SUB(evnt&,obj&)
        '          REPEAT
        '          ~GRAF_MKSTATE(v,v2,v3,v4)
        '        UNTIL v3=0
        ' ---------------------------------------------- Popup-Menue...
      ENDIF
    ELSE IF BTST(OB_STATE(rsc_adr%,next_obj&),5) AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6) AND (NOT BTST(OB_STATE(rsc_adr%,next_obj&),3))
      popok=FALSE
      IF popok=TRUE THEN
        ' (SHADOWED, TOUCHEXIT, NOT DISABLED)
        evnt&=SHR&(OB_TYPE(rsc_adr%,next_obj&),8)-30   ! Nr. des Popup-Baumes
        obj&=1
        FOR ob_tail&=1 TO PRED(evnt&)
          obj&=OB_NEXT(rsc_adr%(rsc_popup&),obj&)      ! Objektnr. des Popups
        NEXT ob_tail&
        ob_tail&=OB_TAIL(rsc_adr%(rsc_popup&),obj&)
        a$=@rsc_text$(tree&,next_obj&)                 ! Text des Buttons
        evnt&=SUCC(obj&)
        DO WHILE a$<>@rsc_text$(rsc_popup&,evnt&)
          INC evnt&                                    ! Ausrichtung ermitteln
        LOOP UNTIL evnt&>ob_tail&
        '
        IF evnt&<=ob_tail&                             ! Defaulteintrag...
          popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,SUB(evnt&,SUCC(obj&)))
        ELSE                                           ! Sonst ohne...
          IF tree&=smpedit& OR tree&=make& THEN
            popup&=@rsc_popup(FALSE,tree&,next_obj&,obj&,1)
          ENDIF
        ENDIF
        IF popup&=0                                    ! Abbruch...
          cont&=1                                      ! ...weiter geht's
          next_obj&=0                                  ! ...Cursor 'festhalten'
        ENDIF
      ENDIF
      ' ---------------------------------------------- Cursor positionieren
      ' Mîchten Sie den Cursor mit der Maus zeichengenau positionieren?
      ' Dann entREMen Sie diese Zeilen und laden diese Prozedur nach:
    ELSE IF BTST(OB_FLAGS(rsc_adr%,next_obj&),3)
      @rsc_set_cursor(rsc_adr%,mx&,my&,edit_obj&,next_obj&,idx&)
    ENDIF
    '
  ENDIF
  IF cont&=0 OR (next_obj&<>0 AND next_obj&<>edit_obj&)
    ~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)       ! Ggf. Cursor aus
  ENDIF
  ' ENDIF
  ' ENDIF
  REPEAT
    ~GRAF_MKSTATE(v,v2,v3,v4)        ! NEU !!!
  UNTIL v3=0 OR leave=TRUE
  IF next_obj&=0 THEN
    next_obj&=-1
  ENDIF
RETURN
> PROCEDURE rsc_init
  .| Glob. Var.: ap_id&,rsc_aes&,rsc_mtsk!,rsc_alert&,wchar&,hchar&,rsc_vh&
  .|     planes&,deskx&,desky&,deskw&,deskh&,rsc_flyd%,rsc_bitblt%,rsc_obspec%
  .|     rsc_cookie%
  .| Felder    : rsc_adr%()
  .| Aufruf in : HAUPTPROGRAMM-1,
  LOCAL a&
  '
  ' Initialisiert die von den RSC-Routinen benîtigten Variablen...
  '
  ap_id&=APPL_INIT()                         ! Applikations-ID
  '
  rsc_aes&=INT{{ADD(GB,4)}}                  ! AES-Version
  rsc_mtsk!=INT{ADD({ADD(GB,4)},2)}<>1       ! Multitasking?
  rsc_alert&=-1                              ! Noch keine fliegenden Alerts
  '
  CONTRL(6)=GRAF_HANDLE(wchar&,hchar&,a&,a&) ! AES-Handle, Zeichenbreite/Hîhe
  rsc_vh&=V_OPNVWK(1)                        ! Virt.Workst. fÅr Flydials îffnen
  IF rsc_vh&=0
    rsc_vh&=V~H                              ! ...Fehler, dann eben die alte
  ENDIF
  CONTRL(6)=V~H
  '
  INTIN(0)=1
  VDISYS 102,1,0
  planes&=INTOUT(4)                          ! Bitplanes
  '
  ~WIND_GET(0,7,deskx&,desky&,deskw&,deskh&) ! Hintergrundfenster
  ' ------------------------------------------------------ Inline vorbereiten
  INLINE rsc_flyd%,3090
  '
  rsc_bitblt%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,16)})      ! BITBLT-Routine
  rsc_obspec%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,18)})      ! OB_SPEC-Routine...
  rsc_cookie%=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,20)})      ! COOKIE-Routine...
  '
  {ADD(rsc_flyd%,22)}=ADD(GB,24)                         ! VDI-Parameterblock
  INT{ADD(rsc_flyd%,26)}=rsc_vh&                         ! Virt. Workstation
  INT{ADD(rsc_flyd%,28)}=wchar&                          ! Zeichenzellenbreite
  INT{ADD(rsc_flyd%,30)}=hchar&                          ! Zeichenzellenhîhe
  ' ------------------------------------------------------
  ' Berechnet den Speicherbedarf einer Bitmap-Grafik...
  DEFFN getsize(w&,h&)=SHL(SHR(ADD(MUL(MUL(SHR(ADD(w&,15),3),h&),planes&),255),8),8)
  '
  ' GegenstÅck zur Prozedur rsc_text: Universelles Objekt-Text auslesen...
  DEFFN rsc_text$(tree&,obj&)=CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}
  '
RETURN
> PROCEDURE rsc_exit
  .| Glob. Var.: rsc_vh&,popup_back%,rsc_userblk%
  .| Aufruf in : goodbye-1,
  '
  CONTRL(6)=rsc_vh&
  VDISYS 38,0,0                              ! vqt_attributes
  IF ABS(INTOUT(0))<>1                       ! Anderer AES-Zeichensatz (MTOS)...
    ~VST_UNLOAD_FONTS(0)                     ! ...freigeben
  ENDIF
  '
  IF rsc_vh&<>V~H                            ! Flydial-Workstation freigeben...
    ~V_CLSVWK()
  ENDIF
  '
  ' Die folgenden Zeilen sind nur im Interpreter relevant und kînnen im
  ' Compilat wegfallen. Tip: Mit dem ERGO!pro-PrÑprozessor ausblenden.
  '
  ~RSRC_FREE()                               ! Resource entfernen
  '
  IF popup_back%
    ~MFREE(popup_back%)                      ! Popup-Hintergrund freigeben
  ENDIF
  '
  IF rsc_userblk%
    ~MFREE(rsc_userblk%)                     ! Userblks freigeben
  ENDIF
  '
RETURN
> FUNCTION rsc_walk_tree(trees&)
$F%
.| Glob. Var.: rsc_userblk%,hchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_instal_userdef
.| Aufruf in : rsc_laden-1,
LOCAL a&,b&,userblk&,tree&,obj&,a%
'
' RSC-Baum durchgehen und userdefs installieren...
'
' ------------------------------------------------------ Userdefs ermitteln
FOR tree&=0 TO trees&
  '
  obj&=-1
  '
  REPEAT
    '
    INC obj&
    '
    a&=SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)           ! Es ist ein userdef...
    ADD userblk&,-AND(a&>=17,a&<=22)
    '
  UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! ...bis LAST_OBJ
  '
NEXT tree&
'
rsc_userblk%=@malloc(SHL(SUCC(userblk&),3),7)             ! Userblks(+1) anfordern (*8)
IF rsc_userblk%=0                                      ! Zu wenig Speicher...
  RETURN FALSE                                         ! ...Error!
ENDIF
a%=rsc_userblk%                                        ! Merken
' ------------------------------------------------------ ObjektbÑume modifiz.
FOR tree&=0 TO trees&
  '
  obj&=-1
  REPEAT
    '
    INC obj&
    '
    SELECT SHR&(OB_TYPE(rsc_adr%(tree&),obj&),8)       ! OB_TYPE
      ' ------------------------------------------------ Flydial-Ecke...
    CASE 17
      rsc_instal_userdef(tree&,obj&,5)
      ' ------------------------------------------------ Button/String...
    CASE 18
      '
      a&=OB_FLAGS(rsc_adr%(tree&),obj&)                ! OB_FLAGS
      b&=BYTE(OB_TYPE(rsc_adr%(tree&),obj&))           ! Alter OB_TYPE
      '
      IF BTST(a&,4)                                    ! Radiobutton...
        rsc_instal_userdef(tree&,obj&,1)
        '                                              ! BUTTON, nicht EXIT
      ELSE IF b&=26 AND (NOT BTST(a&,2))               ! Checkbutton...
        rsc_instal_userdef(tree&,obj&,2)
        '
      ELSE                                             ! Normale EXIT-Buttons...
        '
        IF b&<>28                                      ! Kein STRING...
          a&=SUCC(-BTST(a&,1)-BTST(a&,2)-BTST(a&,6))
          IF a&>1 !EXIT       DEFAULT    TOUCHEXIT
            OB_X(rsc_adr%(tree&),obj&)=SUB(OB_X(rsc_adr%(tree&),obj&),a&)
            OB_Y(rsc_adr%(tree&),obj&)=SUB(OB_Y(rsc_adr%(tree&),obj&),a&)
            OB_W(rsc_adr%(tree&),obj&)=ADD(OB_W(rsc_adr%(tree&),obj&),ADD(a&,a&))
            OB_H(rsc_adr%(tree&),obj&)=SUCC(ADD(OB_H(rsc_adr%(tree&),obj&),ADD(a&,a&)))
          ENDIF                                        ! ...fÅr Redraw grîûer
        ENDIF
        '
        rsc_instal_userdef(tree&,obj&,6)
        '
      ENDIF
      ' ------------------------------------------------ Unterstr. Text...
    CASE 19
      rsc_instal_userdef(tree&,obj&,4)
      OB_FLAGS(rsc_adr%(tree&),obj&)=BSET(OB_FLAGS(rsc_adr%(tree&),obj&),13)
      ' ...OB_FLAG 13 setzen, wird in 'rsc_draw' benîtigt
      ' ------------------------------------------------ Rahmen...
    CASE 20
      rsc_instal_userdef(tree&,obj&,3)
      ' ------------------------------------------------ Niceline...
    CASE 21
      rsc_instal_userdef(tree&,obj&,8)
      ' ------------------------------------------------ Circlebutton...
    CASE 22
      IF hchar&=8 OR hchar&=16                         ! ...nur wenn mîglich
        rsc_instal_userdef(tree&,obj&,7)               ! ...als Bitmap
      ELSE
        OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(27,8),BYTE(OB_TYPE(rsc_adr%(tree&),obj&)))
      ENDIF                                            ! ...sonst Pfeil lassen
      '
    ENDSELECT
    '
  UNTIL BTST(OB_FLAGS(rsc_adr%(tree&),obj&),5)         ! Bis LAST_OB gesetzt
  '
NEXT tree&
'
{rsc_userblk%}=0                                       ! FÅr Nullstrings
rsc_userblk%=a%                                        ! FÅr MFREE() am Ende
'
RETURN TRUE                                            ! Alles OK
ENDFUNC
> PROCEDURE rsc_instal_userdef(tree&,obj&,nr&)
.| Glob. Var.: rsc_userblk%,rsc_flyd%
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_walk_tree-8,
'
' Userdef-Objekt installieren...
'
' nr& bezeichnet eine der folgenden Ausgaberoutinen:
' 1  Radiobutton, rund
' 2  Check-Button
' 3  Rahmen
' 4  Unterstr. Text
' 5  Flydial
' 6  Button
' 7  Circlebutton
' 8  Niceline
'
{rsc_userblk%}=ADD(rsc_flyd%,INT{ADD(rsc_flyd%,SHL(PRED(nr&),1))})
{ADD(rsc_userblk%,4)}=OB_SPEC(rsc_adr%(tree&),obj&)
'
OB_SPEC(rsc_adr%(tree&),obj&)=rsc_userblk%             ! userdef und alter Typ
OB_TYPE(rsc_adr%(tree&),obj&)=OR(SHL&(BYTE(OB_TYPE(rsc_adr%(tree&),obj&)),8),24)
'                                                      ! im oberen Byte
ADD rsc_userblk%,8
'
RETURN
> PROCEDURE rsc_draw(tree&,flag%)
'  LOCAL fly&,title&,obj&,x&,y&,w&,h&,rx&,ry&,rb&,rh&,handle&,a%,rsc_adr%
'
' Stellt einen Dialog auf dem Bildschirm dar...
'
' tree&   : Index des Dialogbaumes
' flag%   : Bitbelegung
'           Bit 0 -> Fensterdialog
'           Bit 1 -> Schlieûfeld
'           Bit 2 -> Bei Fensterdialogen: Sofort zeichnen
'
'
IF flag%=0 THEN
  fly=TRUE
ELSE
  fly=FALSE
ENDIF
rsc_adr%=rsc_adr%(tree&)
' --------------------------------------------------- Titel & Flugecke suchen
DO WHILE NOT (fly&>0 AND title&>0)
  INC obj&
  IF BTST(OB_STATE(rsc_adr%,obj&),1)                ! Flugecke...
    fly&=obj&
  ELSE IF BTST(OB_FLAGS(rsc_adr%,obj&),13)          ! Dialogtitel...
    title&=obj&
  ENDIF
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
' --------------------------------------------------- Als Fenster-Dialog
IF BTST(flag%,0)
  x&=SUCC(rscx&(tree&))
  y&=ADD(ADD(rscy&(tree&),SHL(hchar&,1)),5)
  w&=SUB(rscw&(tree&),2)
  h&=SUB(SUB(rsch&(tree&),SHL(hchar&,1)),5)
  '
  IF fly&                                           ! Flugecke hidden...
    OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
  ENDIF
  '                                                 ! Rahmen: 1 Pixel auûen...
  OB_SPEC(rsc_adr%,0)=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
  '
  rx&=OR(&X1001,SHL(-BTST(flag%,1),1))              ! Ggf. Schlieûfeld
  handle&=WIND_CREATE(rx&,deskx&,desky&,deskw&,deskh&)
  '    ~WIND_SET(handle&,10,handle&,0,0,0)  ! Fenstertitel setzen
  IF handle&>0                                      ! Fenster vorhanden...
    '
    ~WIND_UPDATE(1)                                 ! BEG_UPDATE
    '
    INC rsc_window&                                 ! Anz. offene Fenster+1
    '      rsc_menu_ienable(FALSE)                         ! MenÅtitel disablen
    '
    IF title&                                       ! Dialogtitel existiert...
      a%=C:rsc_obspec%(L:rsc_adr%,title&)           ! ...Adresse des Titels
    ELSE
      a%=rsc_userblk%                               ! ...sonst Nullstring
    ENDIF
    ~WIND_SET(handle&,2,INT(SWAP(a%)),INT(a%),0,0)  ! Fenstertitel setzen
    mrkhandle=handle&
    '
    ~WIND_CALC(0,&X1001,x&,y&,w&,h&,rx&,ry&,rb&,rh&)! WC_BORDER
    ~WIND_OPEN(handle&,rx&,ry&,rb&,rh&)
    '
    rsc_handle%(tree&)=handle&
    '
    IF BTST(flag%,2)                                ! Sofort zeichnen...
      rsc_message(tree&,20,x&,y&,w&,h&,0,0)         ! ...redrawen
      REPEAT
        obj&=EVNT_MULTI(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1000)
        IF BTST(obj&,4) AND (MENU(4)<>rsc_handle%(tree&))
          '           message_auswerten(MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
        ENDIF
      UNTIL BTST(obj&,5)                            ! ...bis Timer-Event
    ENDIF
    '
    ~WIND_UPDATE(0)                                 ! END_UPDATE
    '
  ENDIF
ENDIF
' --------------------------------------------------- Als normaler Dialog
IF rsc_handle%(tree&)=0
  a%=AND(OB_SPEC(rsc_adr%,0),&X11111111000000001111111111111111)
  OB_SPEC(rsc_adr%,0)=OR(a%,SHL(2,16))              ! Rahmen: 2 Pixel innen
  '
  w&=rscw&(tree&)
  h&=rsch&(tree&)
  '                                                 ! Auûerhalb des Screens...
  IF rscy&(tree&)<desky& OR ADD(rscx&(tree&),PRED(w&))>ADD(deskx&,PRED(deskw&)) OR ADD(rscy&(tree&),PRED(h&))>ADD(desky&,PRED(deskh&))
    ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
  ENDIF                                             ! ...wieder in die Mitte
  '
  ~WIND_UPDATE(1)                                   ! BEG_UPDATE
  '
  rsc_list$=rsc_list$+MKI$(tree&)                   ! Dialog in die Liste aufnehmen
  '
  rsc_handle%(tree&)=@malloc(@getsize(w&,h&),7)
  IF rsc_handle%(tree&)                             ! Hintergrund retten...
    rsc_bitblt(0,0,0,rsc_handle%(tree&),w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
    '
  ENDIF
  '
  IF fly&>0 AND rsc_handle%(tree&)>0               ! Flugecke sichtbar...
    OB_FLAGS(rsc_adr%,fly&)=BCLR(OB_FLAGS(rsc_adr%,fly&),7)
  ELSE IF fly&                                     ! unsichtbar...
    OB_FLAGS(rsc_adr%,fly&)=BSET(OB_FLAGS(rsc_adr%,fly&),7)
  ENDIF
  '                                                ! Zeichnen...
  ~OBJC_DRAW(rsc_adr%,0,9,rscx&(tree&),rscy&(tree&),w&,h&)
ENDIF
'  mrkhandle=WIND_FIND(x&,y&)
RETURN
> FUNCTION rsc_holen(trees&,popup&,menu&,alert&)
$F%
.| Glob. Var.: popup_back%,rsc_trees&,rsc_popup&,rsc_menu&,rsc_alert&
.|     rsc_aes&,rsc_vh&,dreidim#,rsc_flyd%
.| Felder    : rsc_adr%(),rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&()
.| Ruft auf  : xrsrc_load,xrsrc_gaddr,rsc_walk_tree
.| Aufruf in : HAUPTPROGRAMM-2,
LOCAL tree&,obj&,font_h&,font_id&,color3d&,a%
popup_back%=0
'
' LÑdt die Resource und initialisiert einige globale Variablen...
' ------------------------------------------------------ RSC laden
' Wollen Sie das RSC-File direkt im Programmcode 'aufbewahren'?
' Dann entREMen Sie diese Zeilen und laden Sie die Funktion
' 'rsc_conv' aus EXTENDED.LST hinzu...
INLINE rsc%,4702
IF @rsrc_conv(rsc%)=0
~FORM_ALERT(1,"[3][ | Fehler beim Laden | der RSC-Datei! | ][Abbruch]")
RETURN FALSE
ENDIF
' ------------------------------------------------------
DIM rsc_adr%(trees&),rsc_handle%(trees&)
DIM rscx&(trees&),rscy&(trees&),rscw&(trees&),rsch&(trees&)
'
rsc_trees&=trees&                                      ! Anzahl ObjektbÑume-1
rsc_popup&=popup&                                      ! Popup-Baum
rsc_menu&=menu&                                        ! Dropdown-Baum
rsc_alert&=alert&                                      ! Alert-Baum
' ------------------------------------------------------ Adressen ermitteln
FOR tree&=0 TO trees&
'
~RSRC_GADDR(0,tree&,a%)  ! Kompatibel zu den XRSRC-Routinen
rsc_adr%(tree&)=a%
IF tree&<>menu& OR menu&=0 THEN
  ~FORM_CENTER(rsc_adr%(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF
'
NEXT tree&
' ------------------------------------------------------ Grîûtes Popup
IF popup&>-1
obj&=1
WHILE obj&>0
  popup_back%=MAX(popup_back%,@getsize(ADD(OB_W(rsc_adr%(popup&),obj&),21),OB_H(rsc_adr%(popup&),obj&)))
  obj&=OB_NEXT(rsc_adr%(popup&),obj&)
WEND
popup_back%=@malloc(popup_back%,7)                   ! Hintergrundpuffer...
IF popup_back%=0
  RETURN FALSE                                       ! ...nicht geklappt
ENDIF
ENDIF
' ------------------------------------------------------ Anderer Zeichensatz
IF rsc_aes&>=&H400 OR APPL_FIND("?API")=0              ! Hat APPL_GETINFO()...
'
GCONTRL(0)=130
GCONTRL(1)=1
GCONTRL(2)=5
GCONTRL(3)=0
GCONTRL(4)=0
GINTIN(0)=0
'
GEMSYS                                               ! APPL_GETINFO()
'
IF GINTOUT(0)=1                                      ! Hat geklappt...
  font_h&=GINTOUT(1)                                 ! AES-Font Hîhe
  font_id&=GINTOUT(2)                                ! AES-Font ID
  '
  IF ABS(font_id&)<>1 AND GDOS?<>0                   ! Anderer AES-Font...
    V~H=rsc_vh&
    ~VST_LOAD_FONTS(0)                               ! ...Fonts laden
    DEFTEXT ,,,,font_id&
    DEFTEXT ,,,font_h&                               ! ...und einstellen
    V~H=-1
  ENDIF
ENDIF
ENDIF
' ------------------------------------------------------ 3D-Darstellung
IF rsc_aes&>=&H340                                     ! Ab AES 3.40...
GCONTRL(0)=48
GCONTRL(1)=4
GCONTRL(2)=3
GCONTRL(3)=0
GCONTRL(4)=0
'
GINTIN(0)=0                                          ! Inquire
GINTIN(1)=5                                          ! Background
'
GEMSYS                                               ! OBJC_SYSVAR()
'
IF GINTOUT(0)>0                                      ! Hat geklappt...
  color3d&=GINTOUT(1)                                ! ...3D-Farbe
ENDIF
ENDIF
IF dreidim=0 OR maxcol=2 THEN
color3d&=0
ELSE
color3d&=8
ENDIF
' ------------------------------------------------------
INT{ADD(rsc_flyd%,32)}=color3d&>0                      ! 3D-Darstellung an/aus
INT{ADD(rsc_flyd%,34)}=color3d&                        ! 3D-Farbe
' ------------------------------------------------------
IF @rsc_walk_tree(trees&)
RETURN TRUE                                          ! alles ok
ENDIF
'
RETURN FALSE                                           ! Error!
ENDFUNC
> FUNCTION rsrc_conv(r_ra%)
$F%
'     r_ra%                            ! RSC INLINE Adresse
LOCAL r_buf!                           ! TRUE=RSC Daten puffern
LOCAL r_pa%                            ! Puffer-Adresse
LOCAL r_o&,r_t&                        ! Laufvar
LOCAL r_ob&                            ! Beginn des Objekt Feldes
LOCAL r_no&                            ! Anzahl OBJECTS
LOCAL r_nt&                            ! Anzahl TREES
LOCAL r_rs&                            ! LÑnge des INLINEs
LOCAL r_napt%                          ! neue TREE Table Adresse
LOCAL r_gb%                            ! Adresse des AES Global Feldes
LOCAL r_of%                            ! Objekt Feld
LOCAL r_ns&                            ! Anzahl der freien Strings
LOCAL r_ni&                            ! Anzahl der freien Images
LOCAL r_adr%,r_i&                      ! Hilfsvar, Laufvar
'
r_buf!=(BYTE{ADD(BASEPAGE,256)}=96)    ! Im Interpreter? ==>puffern
'
r_rs&=WORD{ADD(r_ra%,&H22)}            ! LÑnge des INLINEs
IF r_buf! AND DIM?(rsc_buf|())>0       ! Ist RSC Buf schon dimensioniert?...
r_rs&=0
ENDIF
'
IF r_rs&>0
'
IF r_buf!                            ! RSC Daten puffern (nur Interpreter)...
DIM rsc_buf|(r_rs&)
r_pa%=ADD({*rsc_buf|()},4)
BMOVE r_ra%,r_pa%,r_rs&
r_ra%=r_pa%
ENDIF
'
r_napt%=ADD(r_ra%,WORD{ADD(r_ra%,&H12)})       ! neue Adresse der Tree Tabelle
r_gb%={ADD(GB,4)}                    ! Adr. des AES-GLOBAL-Feldes
{ADD(r_gb%,10)}=r_napt%              ! GLOBAL(5/6): neue Tabellen Adr.
r_ob&=WORD{ADD(r_ra%,2)}             ! bisheriger Start Objekt Feld
r_of%=ADD(r_ra%,r_ob&)               ! Neue Startadr. Objekt Feld
r_no&=PRED(WORD{ADD(r_ra%,&H14)})    ! Anzahl der Objekte im File -1
r_nt&=PRED(WORD{ADD(r_ra%,&H16)})    ! Anzahl der Trees in File  -1
'
FOR r_o&=0 TO r_no&                  ! Alle Objekte durchgehen...
~RSRC_OBFIX(r_of%,r_o&)            ! ...Koordinaten umrechnen
'
SELECT BYTE(OB_TYPE(r_of%,r_o&))   ! Objekt-Typ...
  '
CASE 21,22,29,30,31                ! ...G_TEXT,G_BOXTEXT,G_FTEXT,G_FBOXTEXT,G_ICON
  OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
  {OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
  {ADD(OB_SPEC(r_of%,r_o&),4)}=ADD({ADD(OB_SPEC(r_of%,r_o&),4)},r_ra%)
  {ADD(OB_SPEC(r_of%,r_o&),8)}=ADD({ADD(OB_SPEC(r_of%,r_o&),8)},r_ra%)
  '
CASE 24                            ! ...G_USERDEF
  OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
  {OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
  {ADD(OB_SPEC(r_of%,r_o&),4)}=ADD({ADD(OB_SPEC(r_of%,r_o&),4)},r_ra%)
  '
CASE 23                            ! ...G_IMAGE
  OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
  {OB_SPEC(r_of%,r_o&)}=ADD({OB_SPEC(r_of%,r_o&)},r_ra%)
  '
CASE 26,28,32                      ! ...G_BUTTON,G_STRING,G_TITLE
  OB_SPEC(r_of%,r_o&)=ADD(OB_SPEC(r_of%,r_o&),r_ra%)
ENDSELECT
'
NEXT r_o&
'
FOR r_t&=0 TO r_nt&
{ADD(r_napt%,MUL(4,r_t&))}=ADD({ADD(r_napt%,MUL(4,r_t&))},r_ra%)
NEXT r_t&
'
r_ns&=PRED(WORD{ADD(r_ra%,&H1E)})
IF r_ns&>-1
r_adr%=ADD(r_ra%,WORD{ADD(r_ra%,&HA)})
FOR r_i&=0 TO r_ns&
  {ADD(r_adr%,MUL(4,r_i&))}=ADD({ADD(r_adr%,MUL(4,r_i&))},r_ra%)
NEXT r_i&
ENDIF
'
r_ni&=PRED(WORD{ADD(r_ra%,&H20)})
IF r_ni&>-1
r_adr%=ADD(r_ra%,WORD{ADD(r_ra%,&H10)})
'
FOR r_i&=0 TO r_ni&
  {ADD(r_adr%,MUL(4,r_i&))}=ADD({ADD(r_adr%,MUL(4,r_i&))},r_ra%)
  {{ADD(r_adr%,MUL(4,r_i&))}}=ADD({{ADD(r_adr%,MUL(4,r_i&))}},r_ra%)
NEXT r_i&
'
ENDIF
'
ENDIF
'
RETURN r_rs&
ENDFUNC
> PROCEDURE rsc_menu_ienable(stat!)
.| Glob. Var.: rsc_menu&,rsc_window&,rsc_aes&,rsc_mtsk!,ap_id&
.| Felder    : rsc_adr%(),rscw&()
.| Aufruf in : rsc_draw-1,rsc_back-1,main-1,windows-1,fade-1,arranger-1
.|     trakker-1,abackup-1,makeaback-1,smpedit-3,blkfunc-1,info-1
.|     loopwahl-1,dspwahl-1,
LOCAL obj&,title&,rsc_adr%
'
' Disabled/enabled alle MenÅ-Titel und den 'About...'-MenÅ-Eintrag...
'                                ! Gibt es ein MenÅ..
IF rsc_menu&>-1 AND rsc_window&=1! und ist es das 1. Fenster?
'
rsc_adr%=rsc_adr%(rsc_menu&)
'                              ! Objektbreite verÑndern...
IF stat!                       ! Enablen...
OB_W(rsc_adr%,2)=rscw&(rsc_menu&)
ELSE                           ! Disablen...
rscw&(rsc_menu&)=OB_W(rsc_adr%,2)
OB_W(rsc_adr%,2)=OB_W(rsc_adr%,3)
ENDIF
'
obj&=3                         ! Ersten MenÅtitel Åberspringen
'
REPEAT
INC obj&
'                            ! G_TITEL...
IF BYTE(OB_TYPE(rsc_adr%,obj&))=32
  '
  ~MENU_IENABLE(rsc_adr%,obj&,stat!)
  '
  title&=obj&                ! Wird fÅr 'About...' gebraucht
ENDIF
'
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)
'                              ! 'About...' dis/enablen
~MENU_IENABLE(rsc_adr%,ADD(title&,3),stat!)
'                              ! Unter MultiTOS...
IF (rsc_aes&>=&H400) AND rsc_mtsk!
' zzz=MENU_BAR(rsc_adr%,-1)
' IF ap_id&=zzz THEN
~MENU_BAR(rsc_adr%,1)      ! ...Menu nur neu anzeigen, wenn erlaubt
' ENDIF
ELSE                           ! Unter SingleTOS...
~MENU_BAR(rsc_adr%,1)        ! ...Menu immer neu anzeigen
ENDIF
'
ENDIF
'
RETURN
> FUNCTION rsc_do(tree&,next_obj&,VAR popup&)
$F%
.| Glob. Var.: obj#,donr#,nr#,edit_obj&,idx&,tim&,mx&,my&,mb&,shift&,c#
.|     shcut#,winh#,smp16&,peak&,editfade&,smpedit&,digana#,xd#,xm#,ce#,cs#
.|     stay1#,stay2#,show#,showdat#,tedart#,hz#,showbdat#,shw$,showxy&
.|     butdirect#,othernr#
.| Felder    : rsc_handle%(),rsc_adr%()
.| Ruft auf  : message,drop,button,key,drop2,edhandler,peakread,fadehandler
.|     maketime,edhandler3,textfeld
.| Aufruf in : rsc_alert-1,windows-1,normalize-1,fade-1,smptime-1
.|     movefrag-1,smpsave-1,blklfrag-1,newfsel-1,sampleinf-1,resample-1
.|     arrsmpr-1,arrdelay-1,arrmname-1,virtual-1,abackup-1,time_edit-1
.|     make-1,setupdat-1,conspace-1,midi-1,
LOCAL a&,handle&,a$,c
LOCAL cont&,ob_tail&,obj&,flags&,rsc_adr%,keytab%
LOCAL ascii|,scan|,evnt&,mc&,key&
'
' Dialog auswerten...
'
obj=0
donr=nr
'
~WIND_UPDATE(1)                                      ! ...BEG_UPDATE
~WIND_UPDATE(3)                                      ! ...BEG_MCTRL
flags&=&X100011                                      ! ...zus. MESSAGE-Events
'
rsc_adr%=rsc_adr%(tree&)
cont&=TRUE
' ------------------------------------------------------ Editierbares Objekt
DO WHILE (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3)) OR BTST(OB_STATE(rsc_adr%,next_obj&),3)
INC next_obj&
LOOP UNTIL BTST(OB_FLAGS(rsc_adr%,next_obj&),5)
IF BTST(OB_FLAGS(rsc_adr%,next_obj&),5) AND (NOT BTST(OB_FLAGS(rsc_adr%,next_obj&),3))
next_obj&=0
ENDIF
' ------------------------------------------------------
'
IF cont&<>0 AND (next_obj&<>0 AND edit_obj&<>next_obj&)             ! Ggf. Cursor setzen...
edit_obj&=next_obj&                                ! ...Exit-Code zurÅck
next_obj&=0                                        ! ...'rsc_do' verlassen
~OBJC_EDIT(rsc_adr%,edit_obj&,27,idx&,1,idx&)       ! ...Cursor ein
ENDIF
'
next_obj&=0
tim&=20   ! EVENT-TIMER in msec
REPEAT
c=0
evnt&=EVNT_MULTI(flags&,2,1,1,0,0,0,0,0,0,0,0,0,0,0,tim&,mx&,my&,mb&,shift&,key&,c)
'
IF BTST(evnt&,1) THEN
@button
ENDIF
IF BTST(evnt&,0) THEN
@key
IF obj&<>0 AND mb&=1 THEN
@button
ENDIF
ENDIF
'
IF nr=cbl& THEN
@cblread
@cblmake
ENDIF
'
IF mc&=2 AND BTST(OB_FLAGS(rsc_adr%,next_obj&),6)      ! Doppelklick auf
next_obj&=WORD(BSET(next_obj&,15))                   ! TOUCHEXIT...
ENDIF
UNTIL (next_obj&>0 OR donr<>nr)
IF rsc_handle%(tree&)>1000                             ! Normaler Dialog...
~WIND_UPDATE(0)                                      ! END_UPDATE
~WIND_UPDATE(2)                                      ! END_MCTRL
ENDIF
IF donr<>nr AND butdirect=FALSE THEN
next_obj&=0
ENDIF
othernr=FALSE
rsc_do_ende:
RETURN next_obj&
ENDFUNC
> FUNCTION rsc_popup(a!,tree&,button&,popup&,def&)
$F%
.| Glob. Var.: rsc_popup&,hchar&,popup_back%,rsc_vh&,wchar&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_text
.| Aufruf in : button-2,
LOCAL x&,y&,b&,h&,m!
LOCAL evnt&,mx&,my&,mb&,shift&,key&,mc&,ascii|,scan|
LOCAL obj&,old_obj&,first&,anz&
LOCAL rsc&,rsc_adr%
'
' Popup-MenÅ darstellen und auswerten...
'
' a!       : TRUE: Button verÑndern, FALSE: Nur Popup
' tree&    : Index des Dialogbaumes
' button&  : Objektnr. des betÑtigten Buttons
' popup&   : Index des Popups
' def&     : Default-Eintrag (1-x)
'
~WIND_UPDATE(1)                                   ! BEG_UPDATE
~WIND_UPDATE(3)                                   ! BEG_MCTRL
'
rsc_adr%=rsc_adr%(rsc_popup&)
'
first&=OB_HEAD(rsc_adr%,popup&)                   ! erster Eintrag
anz&=SUB(OB_TAIL(rsc_adr%,popup&),first&)         ! Anzahl EintrÑge-1
' ------------------------------------------------- Popup positionieren
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)
OB_X(rsc_adr%,0)=SUB(x&,OB_X(rsc_adr%,popup&))
OB_Y(rsc_adr%,0)=MAX(ADD(hchar&,4),MIN(SUB(WORK_OUT(1),4)-OB_H(rsc_adr%,popup&),SUB(y&,MUL(def&,hchar&))))-OB_Y(rsc_adr%,popup&)
'
x&=ADD(OB_X(rsc_adr%,0),PRED(OB_X(rsc_adr%,popup&)))
y&=ADD(OB_Y(rsc_adr%,0),PRED(OB_Y(rsc_adr%,popup&)))
b&=ADD(OB_W(rsc_adr%,popup&),4)
h&=ADD(OB_H(rsc_adr%,popup&),4)
' -------------------------------------------------
'
rsc_bitblt(0,0,0,popup_back%,b&,h&,x&,y&,b&,h&,0,0)
'
~OBJC_DRAW(rsc_adr%,0,7,x&,y&,b&,h&)              ! Popup zeichnen
'
IF a!                                             ! Button verÑndern...
'
~GRAF_MOUSE(256,0)                              ! Hidem
V~H=rsc_vh&                                     ! ...Default-Eintrag mit...
GRAPHMODE 2
'
INTIN(0)=8                                      ! ...HÑkchen versehen
PTSIN(0)=ADD(x&,DIV(wchar&,2))
PTSIN(1)=y&-DIV(hchar&,6)+MUL(SUCC(def&),hchar&)
VDISYS 8,1,1                                    ! ...v_gtext()
'
GRAPHMODE 1
V~H=-1
~GRAF_MOUSE(257,0)                              ! Showm
'
ENDIF
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)      ! Objekt unter der Maus...
'
IF obj&<=0                                        ! Daneben...
obj&=ADD(first&,def&)                           ! ...Default-Eintrag nehmen
ENDIF
'
old_obj&=obj&
IF (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))   ! Nicht disabled...
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
ENDIF                                             ! ...selektieren
'
~EVNT_TIMER(200)
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
IF mb&=1
m!=TRUE
evnt&=4
ENDIF
'
' --------------------------------------------------
DO
'
IF NOT m!
evnt&=EVNT_MULTI(&X111,1,1,1,1,mx&,my&,1,1,0,0,0,0,0,0,0,mx&,my&,mb&,shift&,key&,mc&)
ELSE
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
ENDIF
'
IF BTST(evnt&,0)                                 ! Tastaturereignis...
ascii|=BYTE(key&)
scan|=BYTE(SHR(key&,8))
'                                              ! Noch kein sel. Eintrag...
IF NOT (obj&>=first& AND obj&<=ADD(first&,anz&))
obj&=first&
'
ELSE IF scan|=80                               ! ...Cursor runter
INC obj&
IF obj&>ADD(first&,anz&)
obj&=first&
ENDIF
'
ELSE IF scan|=72                               ! ...Cursor runter
DEC obj&
IF obj&<first&
obj&=ADD(first&,anz&)
ENDIF
'
ENDIF
'
ENDIF
'
IF BTST(evnt&,2)                                 ! Mausereignis...
obj&=OBJC_FIND(rsc_adr%,popup&,anz&,mx&,my&)
ENDIF
'                                                ! Alten Eintrag deselekt...
IF obj&<>old_obj&
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),1)
ENDIF
'                                                ! Im MenÅ und nicht disabled...
IF (obj&>=first& AND obj&<=ADD(first&,anz&)) AND (NOT BTST(OB_STATE(rsc_adr%,MAX(0,obj&)),3))
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BSET(OB_STATE(rsc_adr%,obj&),0),1)
'                                              ! ...neuen selektieren
old_obj&=obj&
rsc&=SUB(obj&,first&)                          ! RÅckgabe
ENDIF
'
LOOP UNTIL BTST(evnt&,1) OR (mb&<>1 AND m!) OR ascii|=13 OR ascii|=27 OR scan|=97
' --------------------------------------------------
rsc_bitblt(popup_back%,b&,h&,0,0,0,0,0,b&,h&,x&,y&)! Hintergrund restaurieren
'
IF rsc&=SUB(obj&,first&) AND scan|<>97 AND ascii|<>27 ! Eintrag ausgewÑhlt...
'
~OBJC_CHANGE(rsc_adr%,obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,obj&),0),0)
'
IF a!                                            ! Button verÑndern...
'                                              ! Neuen Text eintragen:
rsc_text(tree&,button&,@rsc_text$(rsc_popup&,obj&))
'
~OBJC_OFFSET(rsc_adr%(tree&),button&,x&,y&)    ! Button zeichnen
~OBJC_DRAW(rsc_adr%(tree&),button&,1,x&,y&,OB_W(rsc_adr%(tree&),button&),OB_H(rsc_adr%(tree&),button&))
'
ENDIF
'
ELSE                                               ! Daneben => Abbruch...
~OBJC_CHANGE(rsc_adr%,old_obj&,0,x&,y&,b&,h&,BCLR(OB_STATE(rsc_adr%,old_obj&),0),0)
'
rsc&=-1                                          ! ...Abbruch markieren
'
ENDIF
'
REPEAT
~GRAF_MKSTATE(mx&,my&,mb&,shift&)                ! Mausknopf 'entprellen'
UNTIL mb&=0
'
~WIND_UPDATE(2)                                    ! END_MCTRL
~WIND_UPDATE(0)                                    ! END_UPDATE
'
RETURN SUCC(rsc&)
ENDFUNC
> PROCEDURE rsc_message(tree&,message&,x&,y&,w&,h&,edit_obj&,idx&)
.| Glob. Var.: wchar&,hchar&
.| Felder    : rsc_handle%(),rsc_adr%(),rscx&(),rscy&()
.| Ruft auf  : rsc_cursor
.| Aufruf in : maschruf3-1,maschruf3b-1,maschruf8b-1,message-2,rsc_draw-1
.|     rsc_back-1,rsc_redraw_obj-1,main-1,fade-1,arranger-1,trakker-1
.|     blkfunc-1,info-1,loopwahl-1,peak-1,
LOCAL a|,ax&,ay&,ab&,ah&,handle&,obj&,rsc_adr%,a%,a$
'
' Wertet ein innerhalb des 'rsc_do' eingetroffenes Message-Ereignis aus...
'
IF nr<>smpinf& AND nr<>fsel& THEN
handle&=rsc_handle%(tree&)                         ! Fensterhandle des Dialogs
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
SELECT message&
' --------------------------------------------------------------------------
CASE 20,21                                         ! WM_REDRAW/WM_TOPPED
IF message&=20                                   ! WM_REDRAW...
~GRAF_MOUSE(256,0)                           ! Hidem
~WIND_GET(handle&,11,ax&,ay&,ab&,ah&)          ! 1. Rechteck
'
REPEAT
'
IF RC_INTERSECT(x&,y&,w&,h&,ax&,ay&,ab&,ah&) ! ...redrawen
  ~OBJC_DRAW(rsc_adr%(tree&),0,7,ax&,ay&,ab&,ah&)
ENDIF
'
~WIND_GET(handle&,12,ax&,ay&,ab&,ah&)        ! NÑchstes Rechteck...
UNTIL ab&=0 AND ah&=0                          ! ...kein Redraw mehr nîtig
'
~GRAF_MOUSE(257,0)                           ! Showm
'
ELSE                                             ! WM_TOPPED...
~WIND_SET(handle&,10,0,0,0,0)                  ! ...toppen
ENDIF
'
~WIND_GET(0,10,ax&,ay&,ay&,ay&)                  ! Oberstes Fenster...
IF ax&=handle& AND edit_obj&>0                   ! Ist das unsrige...
' ---------------------------------------------- Cursor-Setz-Orgie...
rsc_adr%=rsc_adr%(tree&)
'
obj&=edit_obj&                                 ! Parent ermitteln...
'
REPEAT
obj&=OB_NEXT(rsc_adr%,obj&)
UNTIL obj&<edit_obj&
'
~OBJC_OFFSET(rsc_adr%,edit_obj&,ax&,ay&)       ! Koordinaten des Objekts
'
a$=CHAR{{ADD(OB_SPEC(rsc_adr%,edit_obj&),4)}}  ! Maske: "Eingabe:______"
ah&=1
WHILE MID$(a$,ah&,1)<>"_"                      ! LÑnge des Vortextes...
INC ah&
WEND                                           ! ...ermitteln
'
ADD ax&,MUL(wchar&,ADD(PRED(ah&),idx&))        ! Cursor-Position im Pixeln
ah&=ADD(OB_H(rsc_adr%,edit_obj&),6)            ! Cursor ist grîûer hchar&
'                                              ! Cursor lîschen...
~OBJC_DRAW(rsc_adr%,obj&,7,ax&,SUB(ay&,3),wchar&,ah&)
rsc_cursor(rsc_adr%,edit_obj&,idx&)            ! ...und setzen
'
ENDIF
' --------------------------------------------------------------------------
CASE 28                                            ! WM_MOVED
~WIND_CALC(1,&X1001,x&,y&,w&,h&,ax&,ay&,ab&,ah&)
'
rscx&(tree&)=PRED(ax&)
rscy&(tree&)=SUB(SUB(ay&,5),MUL(hchar&,2))
OB_X(rsc_adr%(tree&),0)=ADD(rscx&(tree&),3)
OB_Y(rsc_adr%(tree&),0)=ADD(rscy&(tree&),3)
'
~WIND_SET(handle&,5,x&,y&,w&,h&)
'
ENDSELECT
'
~WIND_UPDATE(0)                                    ! END_UPDATE
'
ENDIF
RETURN
> PROCEDURE rsc_back(tree&)
.| Glob. Var.: rsc_window&,nr#,smp16&,blkfunc&,peak&,loop&,editfade&
.|     arranger&,info&,trakker&,smpedit&,edit_obj&,idx&,rsc_list$
.| Felder    : rsc_handle%(),rscx&(),rscy&(),rscw&(),rsch&(),rsc_adr%()
.| Ruft auf  : rsc_menu_ienable,rsc_message,rsc_bitblt
.| Aufruf in : rsc_alert-1,goodbye-1,normalize-1,blklfrag-1,newfsel-4
.|     restaura2-1,restaura2b-1,sampleinf-1,resample-1,make-1,conspace-1
.|     memtovirt2-1,
'
' Entfernt den Dialog vom Bildschirm...
'
' ---------------------------------------------------- Als Fenster-Dialog
fly=FALSE
IF rsc_handle%(tree&)>0 AND rsc_handle%(tree&)<1000
'
~WIND_UPDATE(1)                                    ! BEG_UPDATE
'
rsc_menu_ienable(TRUE)                             ! ...MenÅ wieder wÑhlbar
'
IF rsc_window&                                     ! Fenster existiert...
'
~WIND_CLOSE(rsc_handle%(tree&))
~WIND_DELETE(rsc_handle%(tree&))                 ! ...schlieûen & abmelden
'
DEC rsc_window&                                  ! Anz. offene Fenster-1
'
ELSE                                               ! Sonst Redraw auslîsen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF
' -------------------------------------------------- Als normaler Dialog
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
IF rsc_window&>0 THEN
'      rsc_message(tree&,21,MENU(5),MENU(6),MENU(7),MENU(8),edit_obj&,idx&)
ENDIF
ELSE
rsc_list$=LEFT$(rsc_list$,SUB(LEN(rsc_list$),2))   ! Dialog aus der Liste entf.
'
IF rsc_handle%(tree&)                              ! Hintergrund gerettet...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~MFREE(rsc_handle%(tree&))
'
ELSE                                               ! Desktop redrawen...
~FORM_DIAL(3,0,0,0,0,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
IF rsc_list$<>""                                 ! Noch ein Dialog drunter...
~OBJC_DRAW(rsc_adr%(CVI(RIGHT$(rsc_list$,2))),0,7,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
ENDIF                                            ! ...diesen auch redrawen
ENDIF
rsc_handle%(tree&)=0
~WIND_UPDATE(0)                                      ! END_UPDATE
ENDIF
RETURN
> PROCEDURE rsc_text(tree&,obj&,a$)
.| Aufruf in : button-1,rsc_popup-1,rsc_alert-2,
'
' Universelle Objekt-Text Belegung...
'
CHAR{C:rsc_obspec%(L:rsc_adr%(tree&),obj&)}=a$
RETURN
> PROCEDURE rsc_bitblt(a%,w&,h&,b%,rb&,rh&,ax&,ay&,ab&,ah&,gx&,gy&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : rsc_draw-1,rsc_popup-2,rsc_back-1,rsc_movedial-3
.|     rsc_flipping-23,
'
' Universeller Raster-Kopierer (benutzt vro_cpyfm oder vrt_cpyfm)...
'
IF ab&>0 AND ah&>0                 ! Breite und Hîhe vorhanden...
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:a%,w&,h&,0,planes&,L:b%,rb&,rh&,0,planes&,ax&,ay&,ab&,ah&,gx&,gy&,1)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_cursor(rsc_adr%,edit_obj&,idx&)
.| Aufruf in : rsc_message-1,rsc_movedial-1,
LOCAL a|,a%
'
' Zeichengenaue Positionierung des Cursors...
'
a%=ADD({OB_SPEC(rsc_adr%,edit_obj&)},idx&)
'
a|=BYTE{a%}                                        ! Zeichen merken
BYTE{a%}=0                                         ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)       ! Cursor setzen
BYTE{a%}=a|                                        ! ...Zeichen restaurieren
'
RETURN
> PROCEDURE busy_mouse
.| Glob. Var.: m_adr%,m_busy%
.| Aufruf in : HAUPTPROGRAMM-1,maschruf-1,maschruf2-1,maschinit2b-1
.|     maschruf3-1,maschruf3b-1,maschruf5-1,maschinit5b-1,maschruf5c-1
.|     maschruf6-1,maschruf8-1,maschruf8b-1,maschruf9-1,maschruf10-1
.|     maschruf11-1,maschruf12-1,maschruf13-1,maschruf16-1,maschruf17-1
.|     maschruf18b-1,maschruf18c-1,maschruf28-1,maschruf29-1,maschruf30-1
.|     maschruf31b-1,maschruf32-1,maschruf33-1,maschruf34-1,maschruf35-1
.|     maschruf36-1,maschruf37-1,maschruf38-1,fade_it-7,smpkhlp-1,smpihlp-5
.|     smpcut-3,virtmove-7,virtcopy-2,virtins-4,putpix-3,edhandler2-7
.|     smpsave-2,ldhlp-1,sampleinf-1,trakload-1,arrinsert-1,arrdelete-1
.|     hardfs-1,hardproof2-2,rettmem-1,arrload-1,arrsave-1,make-3,trash-2
.|     setload-1,setsave-1,fseldef-1,conspace-1,coninsert-4,mono-3,negate-3
.|     lrchange-3,springart-1,
' Eine Busy-Maus in der Form eines kleines Balles...
'
IF m_adr%=ADD(m_busy%,518)
m_adr%=m_busy%
'
ELSE
ADD m_adr%,74
ENDIF
'
~GRAF_MOUSE(255,m_adr%)
'
RETURN
> FUNCTION malloc(b%,c%)
LOCAL g,a%
IF gemvers>=&H1900 THEN
a%=@mxalloc(b%,3)     ! Buffer anfordern
IF a%<=0 THEN
a%=MALLOC(b%)       ! Buffer anfordern
ENDIF
ELSE
a%=MALLOC(b%)         ! Buffer fÅr Trakker-Caches
ENDIF
IF a%<=0 THEN
IF (c% AND 3)=1 THEN
@alerts(3)
ENDIF
IF (c% AND 3)=2 THEN
@alerts(4)
ENDIF
IF (c% AND 7)=3 THEN
@alerts(5)
ENDIF
IF (c% AND 7)=7 THEN
@alerts(6)
ENDIF
IF (g=2 AND (c% AND 7)=7) OR (c% AND 4)=4 THEN
@goodbye
ENDIF
ENDIF
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION rsc_get(x&,y&,w&,h&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : fseldef-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%,b%,g
'
b%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
a%=@malloc(b%,1)         ! Buffer fÅr Trakker-Caches
'
IF a%>0 THEN                       ! Hat geklappt...
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
'                                ! Kopieren...
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> FUNCTION rsc_get2(x&,y&,w&,h&,md%)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-3,dragging2-1,
' GET/PUT-Ersatz auf Basis des im INLINE integrierten BITBLT
LOCAL a%
a%=md%                           ! Speicher anfordern
IF a%>0 THEN
INT{a%}=w&                       ! Breite eintragen
INT{ADD(a%,2)}=h&                ! Hîhe
~C:rsc_bitblt%(L:0,0,0,0,planes&,L:ADD(a%,4),w&,h&,0,planes&,x&,y&,w&,h&,0,0,1)
ENDIF
RETURN a%                          ! Adresse zurÅck
ENDFUNC
> PROCEDURE rsc_put(a%,x&,y&,m&)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&
'
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,0,0,w&,h&,x&,y&,m&)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> PROCEDURE rsc_put2(a%,x&,y&,m&,sx,bx)
.| Glob. Var.: rsc_bitblt%,planes&
.| Aufruf in : markhandl4-3,dragging1-4,dragging2-4,fseldef-1,
LOCAL w&,h&
'
IF a%>0 THEN                       ! Gibt's den Block Åberhaupt...
w&=INT{a%}                       ! Breite holen
h&=INT{ADD(a%,2)}                ! Hîhe
'
~GRAF_MOUSE(256,0)               ! Hidem
~C:rsc_bitblt%(L:ADD(a%,4),w&,h&,0,planes&,L:0,0,0,0,planes&,sx,0,bx,h&,x&,y&,m&)
~GRAF_MOUSE(257,0)               ! Showm
'
ENDIF
'
RETURN
> FUNCTION rsc_len(w&,h&)
LOCAL a%
'
a%=ADD(@getsize(w&,h&),4)          ! Speicherbedarf
'
RETURN a%                          ! Adresse zurÅck
ENDFUNC
' ------------------------------------------------------------------------------
' ------------------------ENHANCED-FLYDIALS-------------------------------------
' ------------------------------------------------------------------------------
DEFFN rsc_flags(tree&,obj&,bit&)=BTST(OB_FLAGS(rsc_adr%(tree&),obj&),bit&)
DEFFN rsc_state(tree&,obj&,bit&)=BTST(OB_STATE(rsc_adr%(tree&),obj&),bit&)
> FUNCTION form_keybd(rsc_adr%,edit_obj&,key&,a&,VAR next_obj&,key_back&,idx&)
.| Ruft auf  : form_search_flag
.| Aufruf in : key-1,
' ZusÑtzliche Tastaturkommandos...
' Einfach FORM_KEYBD in 'rsc_do' durch @form_keybd ersetzen.
$F%
LOCAL scan|,cont&
'
' Ersetzt FORM_KEYBD()...
'
key_back&=0
cont&=1
'
SELECT key&
'
' ------------------------------------------------- SHIFT right
CASE &H4D36
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
' ------------------------------------------------- SHIFT left
CASE &H4B34
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)
'
a&=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=0
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,1,idx&)
BYTE{{OB_SPEC(rsc_adr%,edit_obj&)}}=a&
'
' ------------------------------------------------- Cursor runter
CASE &H5000
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
' ------------------------------------------------- Cursor rauf
CASE &H4800
next_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,-1)
' ------------------------------------------------- SHIFT runter/HOME
CASE &H5032,&H4737                                  ! =>letztes Feld
REPEAT
next_obj&=edit_obj&
edit_obj&=@form_search_flag(rsc_adr%,edit_obj&,3,1)
UNTIL edit_obj&=0
' ------------------------------------------------- SHIFT rauf, HOME
CASE &H4838,&H4700                                  ! =>erstes Feld
next_obj&=@form_search_flag(rsc_adr%,0,3,1)
' ------------------------------------------------- HELP/UNDO
CASE &H6200,&H6100
key_back&=key&
' ------------------------------------------------- Alles andere
DEFAULT
scan|=BYTE(SHR(key&,8))                           ! SCAN-Code
'
IF BYTE(key&)>0 OR scan|=75 OR scan|=77           ! Cursor rauf/runter
cont&=FORM_KEYBD(rsc_adr%,edit_obj&,key&,0,next_obj&,key&)
'                                               ! Kein Ende&TAB u. EDITABLE
IF cont&>0 AND BYTE(key&)<>9 AND BTST(OB_FLAGS(rsc_adr%,edit_obj&),3)
'
scan|=BYTE{{OB_SPEC(rsc_adr%,edit_obj&)+8}+idx&}! Maske 'A' oder 'N'...
IF scan|=65 OR (scan|=78 AND (BYTE(key&)<48 OR BYTE(key&)>57))
key&=BCLR(key&,5)                             ! ...Groûschrift setzen
ENDIF
'
~OBJC_EDIT(rsc_adr%,edit_obj&,key&,idx&,2,idx&) ! ...Eingabe
ENDIF
'
ELSE
key_back&=key&
ENDIF
'
ENDSELECT
'
RETURN cont&
ENDFUNC
> FUNCTION form_search_flag(rsc_adr%,obj&,flag&,step&)
$F%
.| Aufruf in : form_keybd-4,
'
' Unterroutine fÅr form_keybd. Sucht das nÑchste/vorhergehende Objekt mit
' dem gesetzten Bit 'flag&' in OB_FLAGS...
'
' Sonderfall: Letztes Objekt ist edierbar, Cursor runter:
IF NOT (BTST(OB_FLAGS(rsc_adr%,obj&),5)=TRUE AND step&>0)
'
REPEAT
ADD obj&,step&
'
IF BTST(OB_FLAGS(rsc_adr%,obj&),flag&) AND (NOT BTST(OB_STATE(rsc_adr%,obj&),3))
RETURN obj&
ENDIF
UNTIL (obj&<=0) OR BTST(OB_FLAGS(rsc_adr%,obj&),5)
'
ENDIF
'
RETURN 0
ENDFUNC
> PROCEDURE rsc_movedial(tree&,edit_obj&,idx&)
.| Glob. Var.: deskx&,deskw&,desky&,deskh&
.| Felder    : rscw&(),rsch&(),rscx&(),rscy&(),rsc_handle%(),rsc_adr%()
.| Ruft auf  : rsc_bitblt,rsc_flipping,rsc_cursor
.| Aufruf in : button-1,
' SOLID Flydials...
' Einfach die Prozedur 'rsc_movedial' ersetzen.
LOCAL x&,y&,w&,h&,fx&,fy&,mx&,my&,mb&,shift&,rsc%
'
w&=rscw&(tree&)
h&=rsch&(tree&)
'
~GRAF_MKSTATE(mx&,my&,x&,y&)
' Nicht zusÑtzl. rechte Maustaste oder SHIFT/CONTROL/ALT...
IF NOT (x&=3 OR AND(y&,&X1111)>0)
rsc%=@malloc(@getsize(w&,h&),7)                    ! Dialog retten
ENDIF
IF rsc%                                           ! Hat geklappt...
rsc_bitblt(0,0,0,rsc%,w&,h&,rscx&(tree&),rscy&(tree&),w&,h&,0,0)
ENDIF
'
~GRAF_MOUSE(4,0)                                  ! FLAT_HAND
'
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
fx&=SUB(mx&,SUCC(rscx&(tree&)))                   ! Relativer Mausfaktor
fy&=SUB(my&,SUCC(rscy&(tree&)))
'
mx&=rscx&(tree&)
my&=rscy&(tree&)
' ------------------------------------------------- Bewegen
IF rsc%                                           ! SOLID...
REPEAT
'
~GRAF_MKSTATE(x&,y&,mb&,shift&)
'
x&=SUB(PRED(x&),fx&)
y&=SUB(PRED(y&),fy&)                          ! Clipping...
x&=MIN(MAX(x&,deskx&),SUB(ADD(deskx&,deskw&),w&))
y&=MIN(MAX(y&,desky&),SUB(ADD(desky&,deskh&),h&))
'
IF mx&<>x& OR my&<>y&
rsc_flipping(rsc_handle%(tree&),rsc%,mx&,my&,w&,h&,x&,y&)
mx&=x&
my&=y&
'
ENDIF
'
UNTIL mb&=0
'
~MFREE(rsc%)
'
ELSE                                              ! Nicht SOLID...
rsc_bitblt(rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),0,0,0,0,0,rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&))
~GRAF_DRAGBOX(rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),deskx&,desky&,deskw&,deskh&,x&,y&)
ENDIF
' ------------------------------------------------- Hinsetzen
rscx&(tree&)=x&
rscy&(tree&)=y&
OB_X(rsc_adr%(tree&),0)=ADD(x&,3)
OB_Y(rsc_adr%(tree&),0)=ADD(y&,3)
'
IF rsc%=0                                         ! Nicht SOLID...
rsc_bitblt(0,0,0,rsc_handle%(tree&),rscw&(tree&),rsch&(tree&),rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&),0,0)
~OBJC_DRAW(rsc_adr%(tree&),0,10,rscx&(tree&),rscy&(tree&),rscw&(tree&),rsch&(tree&))
'
IF edit_obj&
rsc_cursor(rsc_adr%(tree&),edit_obj&,idx&)    ! ...Cursor ein
ENDIF
ENDIF
'
~GRAF_MOUSE(0,0)
'
RETURN
> PROCEDURE rsc_flipping(rsc_back%,rsc%,ax&,ay&,w&,h&,x&,y&)
.| Ruft auf  : rsc_bitblt
.| Aufruf in : rsc_movedial-1,
LOCAL rb&,rh&,gw&,gh&
'
gw&=ABS(SUB(x&,ax&))         ! Verschiebbreite
gh&=ABS(SUB(y&,ay&))         ! Verschiebhîhe
rb&=SUB(w&,gw&)              ! Restbreite
rh&=SUB(h&,gh&)              ! Resthîhe
'
IF rb&<0 OR rh&<0            ! rsc% auûerhalb von rsc_back%
'
' Gesamten Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,h&,ax&,ay&)
'
' Gesamten Dialog aktualisieren -----
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,h&,0,0)
'
ELSE IF x&>ax&               ! nach rechts...
'
IF y&>ay&                  ! nach rechts-unten veschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,gh&,gw&,rh&,ax&,ADD(ay&,gh&))
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,w&,gh&,ax&,ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,gh&,rb&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),rb&,gh&,0,rh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ELSE                      ! nach rechts-oben / rechts verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,gw&,rh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,gw&,0,rb&,rh&,0,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,rb&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,ADD(x&,rb&),y&,gw&,h&,rb&,0)
'
ENDIF
'                         ! nach links / oben / unten...
ELSE IF y&>ay&              ! nach links-unten / unten verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,0,rb&,gh&,ax&,ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,h&,ADD(ax&,rb&),ay&)
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,gh&,rb&,rh&,gw&,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,gw&,rh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,rh&),w&,gh&,0,rh&)
'
ELSE                        ! nach links-oben / links / oben verschoben
'
' Hintergrund restaurieren -----
rsc_bitblt(rsc_back%,w&,h&,0,0,0,rb&,0,gw&,rh&,ADD(ax&,rb&),ay&)
rsc_bitblt(rsc_back%,w&,h&,0,0,0,0,rh&,w&,gh&,ax&,ADD(ay&,rh&))
'
' Dialog aktualisieren -----
rsc_bitblt(rsc_back%,w&,h&,rsc_back%,w&,h&,0,0,rb&,rh&,gw&,gh&)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,y&,w&,gh&,0,0)
rsc_bitblt(0,0,0,rsc_back%,w&,h&,x&,ADD(y&,gh&),gw&,rh&,0,gh&)
'
ENDIF
'
rsc_bitblt(rsc%,w&,h&,0,0,0,0,0,w&,h&,x&,y&)
'
RETURN
> PROCEDURE rsc_set_cursor(rsc_adr%,mx&,my&,VAR edit_obj&,next_obj&,idx&)
.| Glob. Var.: wchar&
.| Aufruf in : button-1,
' Zeichengenaues Cursor-Positionieren mit der Maus...
' Nur die entsprechenden 2 Zeilen in 'rsc_do' (ziemlich am Ende) entREMen.
LOCAL x&,a&,i&,ob_spec%,a$
'
ob_spec%=OB_SPEC(rsc_adr%,next_obj&)
'
~OBJC_OFFSET(rsc_adr%,next_obj&,x&,a&)          ! Absolute X-Position
'
x&=DIV(SUB(mx&+SHR(wchar&,2),x&),wchar&)        ! Spaltenposition
'
a$=CHAR{{ADD(ob_spec%,4)}}                      ! Maske lesen
'
FOR a&=1 TO x&                                  ! Pos. im Eingabefeld...
IF MID$(a$,a&,1)="_"
INC i&                                      ! ...nur relevante
ENDIF
NEXT a&
SUB x&,(x&-i&)
'
~OBJC_EDIT(rsc_adr%,edit_obj&,0,idx&,3,idx&)    ! Cursor aus
'
ob_spec%=ADD({ob_spec%},x&)
'
a&=BYTE{ob_spec%}                               ! Zeichen merken
BYTE{ob_spec%}=0                                ! ...und durch 0 ersetzen
'
~OBJC_EDIT(rsc_adr%,next_obj&,0,idx&,1,idx&)    ! Cursor setzen
BYTE{ob_spec%}=a&                               ! ...und Zeichen restaurieren
'
edit_obj&=next_obj&
'
RETURN
> FUNCTION rsc_shortcut(tree&,scan|,shift&,VAR title&)
.| Felder    : rsc_adr%()
.| Aufruf in : key-1,
' MenÅshortcut ermitteln...
$F%
LOCAL a&,obj&,rsc_adr%,s$,t$
'
' tree&      : Index des MenÅbaumes
' scan|      : SCAN-Code der gedrÅckten Taste
' shift&     : Status der tastaturumschalttasten
' VAR title& : Bei Erfolg Objektnummer des MenÅtitels
'
SELECT scan|
CASE 2 TO 10                                   ! 1-2...
s$=CHR$(ADD(47,scan|))
CASE 15                                        ! TAB...
s$="I"
shift&=BSET(shift&,2)                        ! ...entspricht "^I"
'
CASE 59 TO 68,84 TO 93                         ! Ftasten...
IF scan|<84
s$="F"+STR$(SUB(scan|,58))                 ! ...normal
ELSE
s$="F"+STR$(SUB(scan|,83))                 ! ...mit Shift
ENDIF
CASE 71                                        ! ClrHome...
s$="CLR"
CASE 83                                        ! DELETE...
s$="DEL"
CASE 97                                        ! UNDO...
s$="UNDO"
CASE 98                                        ! HELP...
s$="HELP"
DEFAULT                                        ! Alles andere...
rsc_adr%={XBIOS(16,L:-1,L:-1,L:-1)}
s$=CHR$(BCLR(BYTE{ADD(rsc_adr%,scan|)},5))
ENDSELECT
'
IF BTST(shift&,3)                              ! Alternate...
s$=CHR$(7)+s$
ENDIF
IF BTST(shift&,2)                              ! Control...
s$="^"+s$
ENDIF
IF BTST(shift&,0) OR BTST(shift&,1)            ! Shift...
s$=CHR$(1)+s$
ENDIF
'
title&=2                                       ! Position des Titels
obj&=5                                         ! Beginn der eigentl. MenÅs
rsc_adr%=rsc_adr%(tree&)                       ! öbersichtlicher
'
REPEAT                                         ! alle Objekte d. MenÅbaums
INC obj&
'
IF BYTE(OB_TYPE(rsc_adr%,obj&))=28           ! G_STRING...
IF NOT BTST(OB_STATE(rsc_adr%,obj&),3)     ! disabled ?
'
t$=TRIM$(CHAR{OB_SPEC(rsc_adr%,obj&)})   ! MenÅpunkt-Text
'
a&=RINSTR(t$," ")
IF a&                                    ! Shortcut vorhanden ?
'
IF MID$(t$,SUCC(a&))=s$                ! hier der vermutete Shortcut
RETURN obj&                          ! gefunden
ENDIF
'
ENDIF
ENDIF
'
ELSE IF BYTE(OB_TYPE(rsc_adr%,obj&))=20      ! G_STRING ?
INC title&
ENDIF
UNTIL BTST(OB_FLAGS(rsc_adr%,obj&),5)          ! LAST_OB ?
'
title&=0
RETURN 0                                       ! nicht gef. oder disabled
ENDFUNC
> FUNCTION rsc_alert(icon&,text$,def&,button$)
.| Glob. Var.: rsc_alert&,wchar&,hchar&
.| Felder    : rsc_adr%(),rscw&(),rsch&(),rscx&(),rscy&()
.| Ruft auf  : rsc_text,rsc_draw,rsc_do,rsc_back
.| Aufruf in : copytoarr-1,
' Fliegende ALERT-Box...
$F%
LOCAL a&,b&,h&,i&,l&,len&,w&,x&,y&,z&,ab&,ah&,rsc&,rsc_adr%,a$,knr,kobj,rdraw
'
' Alert-Box darstellen...
'
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
IF rsc_alert&>-1 AND rscda=TRUE AND exerr=FALSE THEN      ! Wenn's den Baum gibt:
rsc_adr%=rsc_adr%(rsc_alert&)                               ! rsc_alert=GLOBAL
'
text$=text$+"|"
button$=button$+"|"
' ---------------------------------------------------- Icon bestimmen
OB_FLAGS(rsc_adr%,2)=BSET(OB_FLAGS(rsc_adr%,2),7)    ! Hidden...
OB_FLAGS(rsc_adr%,3)=BSET(OB_FLAGS(rsc_adr%,3),7)
OB_FLAGS(rsc_adr%,4)=BSET(OB_FLAGS(rsc_adr%,4),7)
'
OB_FLAGS(rsc_adr%,SUCC(icon&))=BCLR(OB_FLAGS(rsc_adr%,SUCC(icon&)),7)
' ---------------------------------------------------- Buttons
OB_FLAGS(rsc_adr%,10)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,10)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,11)=OR(&X101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,11)))    ! EXIT+SELECTABLE
OB_FLAGS(rsc_adr%,12)=OR(&X100101,AND(&X1111111100000000,OB_FLAGS(rsc_adr%,12))) ! LAST_OB+EXIT+SELECT.
'                                                    ! Default-Button...
OB_FLAGS(rsc_adr%,9+def&)=BSET(OB_FLAGS(rsc_adr%,9+def&),1)
' ---------------------------------------------------- Textzeilen setzen
FOR i&=1 TO 5
a&=INSTR(text$,"|")
a$=LEFT$(text$,MIN(30,MAX(0,PRED(a&))))
IF LEN(a$)>0 THEN
a$=a$+" "
ENDIF
IF LEN(a$)>30 THEN
a$=LEFT$(a$,30)
ENDIF
text$=MID$(text$,SUCC(a&))
'
z&=MAX(z&,-i&*(a$<>""))                            ! Hîchste belegte Zeile
l&=MAX(l&,LEN(a$))                                 ! LÑngste Zeile
'
rsc_text(rsc_alert&,ADD(4,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Button-Texte setzen
FOR i&=1 TO 3
a&=INSTR(button$,"|")
a$=LEFT$(button$,MIN(10,MAX(0,PRED(a&))))
button$=MID$(button$,SUCC(a&))
'
ADD b&,-(a$<>"")                                   ! Anzahl Buttons
len&=MAX(len&,LEN(a$))                             ! LÑngster Button
'
rsc_text(rsc_alert&,ADD(9,i&),a$)                  ! Setzen
NEXT i&
' ---------------------------------------------------- Dialog-Breite Ñndern
l&=MAX(l&,MUL(10,b&))                                ! Minimal-Breite
'
w&=OB_W(rsc_adr%,3)+MUL(wchar&,ADD(l&,5))
OB_W(rsc_adr%,0)=w&                                  ! Neue Breite
'
OB_X(rsc_adr%,1)=w&-PRED(OB_W(rsc_adr%,1))           ! Flydial verschieben
rscw&(rsc_alert&)=ADD(w&,6)
' ---------------------------------------------------- Dialog-Hîhe Ñndern
h&=OB_H(rsc_adr%,10)+MUL(hchar&,ADD(z&,2))
OB_H(rsc_adr%,0)=h&                                  ! Neue Hîhe
rsch&(rsc_alert&)=ADD(h&,6)
' ---------------------------------------------------- Buttons plazieren
len&=MUL(wchar&,MAX(8,SUCC(len&)))
OB_W(rsc_adr%,10)=len&                               ! Breite anpassen..
OB_W(rsc_adr%,11)=len&
OB_W(rsc_adr%,12)=len&
'
good=TRUE
SELECT b&                                            ! Anzahl Buttons...
CASE 1
OB_FLAGS(rsc_adr%,11)=BSET(OB_FLAGS(rsc_adr%,11),7)! ...hidden
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
' OB_X(rsc_adr%,10)=SHR(SUB(w&,OB_W(rsc_adr%,10)),1)
OB_X(rsc_adr%,10)=SUB(w&,OB_W(rsc_adr%,10))-2*wchar&
'
CASE 2
OB_FLAGS(rsc_adr%,12)=BSET(OB_FLAGS(rsc_adr%,12),7)! ...hidden
x&=w&-OB_W(rsc_adr%,11)-2*wchar&
OB_X(rsc_adr%,11)=x&
OB_X(rsc_adr%,10)=x&-OB_W(rsc_adr%,10)-wchar&
'
CASE 3
x&=w&-OB_W(rsc_adr%,12)-SHL(wchar&,1)              ! ...Mitte
OB_X(rsc_adr%,12)=x&
OB_X(rsc_adr%,11)=x&-OB_W(rsc_adr%,10)-wchar&
OB_X(rsc_adr%,10)=OB_X(rsc_adr%,11)-OB_W(rsc_adr%,10)-wchar&
'
ENDSELECT
'
y&=h&-OB_H(rsc_adr%,10)-SHR(hchar&,1)
OB_Y(rsc_adr%,10)=y&
OB_Y(rsc_adr%,11)=y&
OB_Y(rsc_adr%,12)=y&
' ---------------------------------------------------- Anzeigen
~FORM_CENTER(rsc_adr%(rsc_alert&),rscx&(rsc_alert&),rscy&(rsc_alert&),rscw&(rsc_alert&),rsch&(rsc_alert&))
'
rdraw=FALSE
knr=nr
kobj=obj
nr=alertbox&
@rsc_draw(nr,0)
rsc&=@rsc_do(nr,0,popup&)
rsc_back(nr)
nr=knr
obj=kobj
'    IF rdraw=TRUE THEN
'    @rsc_draw(nr,0)
'  ENDIF
rdraw=FALSE
' ----------------------------------------------------
OB_STATE(rsc_adr%,rsc&)=BCLR(OB_STATE(rsc_adr%,rsc&),0)! SELECTED lîschen
'
RETURN SUB(rsc&,9)                                   ! Nummer des Buttons 1-3
ELSE
' Normaler Alert...
WHILE INSTR(button$,"[")>0
button$=LEFT$(button$,PRED(INSTR(button$,"[")))+MID$(button$,SUCC(INSTR(button$,"[")))
WEND                                                   ! ...'[' rausfiltern
RETURN FORM_ALERT(def&,"["+STR$(icon&)+"]["+text$+"]["+button$+"]")
ENDIF
ENDFUNC
> PROCEDURE rsc_state(tree&,obj&,bit&,stat!)
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_tristate-4,rsc_tristate2-4,
' Setzen und Abfragen einzelner Bits in OB_STATE und OB_FLAGS...
'
' tree& : Index des Objektbaumes
' obj&  : Objektnummer
' bit&  : Zu setzendes Bit
' stat! : TRUE =Bit setzen, FALSE =Bit lîschen
'
IF stat!
OB_STATE(rsc_adr%(tree&),obj&)=BSET(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ELSE
OB_STATE(rsc_adr%(tree&),obj&)=BCLR(OB_STATE(rsc_adr%(tree&),obj&),bit&)
ENDIF
'
RETURN
> PROCEDURE rsc_tristate(tree&,obj&)
.| Glob. Var.: tri#
.| Ruft auf  : rsc_state,rsc_draw_obj
.| Aufruf in : arrtristate-1,
' Behandlung eines Tristate-Buttons...
'
INC tri
IF tri=3 THEN
tri=0
ENDIF
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
RETURN
> PROCEDURE rsc_tristate2(tree&,obj&)
.| Glob. Var.: tri#
.| Ruft auf  : rsc_state,rsc_draw_obj
.| Aufruf in : arrnrset-4,arranger-4,arrdel-4,
IF tri=0 THEN
rsc_state(tree&,obj&,2,FALSE)
rsc_state(tree&,obj&,0,TRUE)             ! ...jetzt selektiert
ENDIF
IF tri=1 THEN
rsc_state(tree&,obj&,0,FALSE)            ! ...jetzt leer
ENDIF
IF tri=2 THEN
rsc_state(tree&,obj&,2,TRUE)             ! ...jetzt gefÅllt
ENDIF
rsc_draw_obj(tree&,obj&)                   ! Zeichnen
RETURN
> PROCEDURE rsc_draw_obj(tree&,obj&)
.| Felder    : rsc_adr%()
.| Aufruf in : rsc_tristate-1,rsc_tristate2-1,
' Zeichnen eines einzelnen Objektes...
LOCAL x&,y&
'
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
~OBJC_DRAW(rsc_adr%(tree&),obj&,8,x&,y&,OB_W(rsc_adr%(tree&),obj&),OB_H(rsc_adr%(tree&),obj&))
'
RETURN
> PROCEDURE rsc_redraw_obj(tree&,obj&)
.| Glob. Var.: edit_obj&,idx&
.| Felder    : rsc_adr%()
.| Ruft auf  : rsc_message
.| Aufruf in : message-1,fadehandler-1,clsfade-1,fadedel-1,restaura3-1
.|     trakload-1,trakforw-1,trkbackw-1,hardfs-1,mforw-1,mbackw-1
.|     time_edit-1,coninsert-1,record2-1,record3-1,
' Sauberer Redraw eines Objektes, nur fÅr Fensterdialoge!...
LOCAL x&,y&,w&,h&
'
' Sendet einen Redraw-Event fÅr ein Objekt
' --------------------------------------------------
~OBJC_OFFSET(rsc_adr%(tree&),obj&,x&,y&)
w&=OB_W(rsc_adr%(tree&),obj&)
h&=OB_H(rsc_adr%(tree&),obj&)
'
'  appl_write(ap_id&,20,rsc_handle%(tree&),x&-3,y&-3,w&+6,h&+6,"")   ! WM_REDRAW
rsc_message(tree&,20,x&-3,y&-3,w&+6,h&+6,edit_obj&,idx&)   ! WM_REDRAW
'
RETURN
> PROCEDURE appl_write(id&,msg&,handle&,x&,y&,w&,h&,a$)
.| Glob. Var.: msg%,ap_id&
.| Aufruf in : helptxt-2,
' LOCAL b$
'
' Sendet eine Message an ein Programm. Dabei kann es sich auch um
' das eigene Programm handeln (id&=ap_id&), siehe 'rsc_redraw_obj'
' --------------------------------------------------
INLINE msg%,256
'
INT{msg%}=msg&                                     ! 0 Message-ID
INT{msg%+2}=ap_id&                                 ! 1 Unsere ID
INT{msg%+4}=0                                      ! 2 Keine öberlÑnge
INT{msg%+6}=handle&                                ! 3
INT{msg%+8}=x&                                     ! 4 MenÅpunkt
INT{msg%+10}=y&                                    ! 5
INT{msg%+12}=w&                                    ! 6
INT{msg%+14}=h&                                    ! 7
'
'  IF x&=0                                            ! String (z.B. fÅr VA_START)...
CHAR{msg%+16}=LEFT$(a$,240)
{msg%+6}=msg%+16
' ENDIF
'
~APPL_WRITE(id&,16,msg%)                           ! Weg damit
'
RETURN
' ------------------------------------------------------------------------------
' ------------------------RCS-Zugriffs-Routinen---------------------------------
' ------------------------------------------------------------------------------
> PROCEDURE textfeld(txtname,txt$,versatz)
LOCAL a
~RSRC_GADDR(0,nr,zu%)
string=LPEEK(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,txtname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~FRE(0)
RETURN
'
> PROCEDURE textfeld2(txtname,txt$,versatz)
LOCAL a
~RSRC_GADDR(0,nr,zu%)
string=LPEEK(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
a=ASC(MID$(txt$,it,1))
POKE string+it-1+(versatz-1),a
EXIT IF a=0
NEXT it
RETURN
'
> PROCEDURE textbutt(parent,txtname,txt$,versatz)
~RSRC_GADDR(0,nr,zu%)
string=(LPEEK(zu%+24*txtname+12))
FOR it=1 TO LEN(txt$)
POKE string+it-1+(versatz-1),ASC(MID$(txt$,it,1))
NEXT it
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,parent,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
RETURN
'
> PROCEDURE setbutton(buttnr,buttflag)
IF buttnr<>0 THEN
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE setbutton2(buttnr,buttflag)
LOCAL buttadr,zu%
IF buttnr<>0 THEN
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
ENDIF
RETURN
'
> PROCEDURE drawbutton(buttnr)
IF buttnr<>0 THEN
~RSRC_GADDR(0,nr,zu%)
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE setbild(buttnr,buttflag)
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,buttflag
RETURN
'
> PROCEDURE hidetree(buttnr,buttflag,box)
LOCAL bf
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,buttnr,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,box,99,0,0,xwidth,ywidth)      ! neu zeichnen
~WIND_UPDATE(0)                                    ! BEG_UPDATE
ENDIF
RETURN
'
> PROCEDURE hidetree2(buttnr,buttflag)
LOCAL bf
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+10,0    ! setbutton lîschen
bf=(DPEEK(buttadr+8) AND &HFF7F)
IF buttflag=FALSE THEN
DPOKE buttadr+8,bf
ELSE
bf=bf+&H80
DPOKE buttadr+8,bf
ENDIF
RETURN
'
> PROCEDURE readbutton(buttnr)
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+10)
RETURN
'
> PROCEDURE flagbutton(buttnr,bfl)
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE (buttadr+8),bfl
RETURN
'
> PROCEDURE readflag(buttnr)
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
buttflag=DPEEK(buttadr+8)
RETURN
'
> PROCEDURE readpos(buttnr)
.| Glob. Var.: nr#,zu%,buttadr#,bx#,by#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : dragging1-1,dragging2-1,
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
bx=DPEEK(buttadr+16)
by=DPEEK(buttadr+18)
RETURN
'
> PROCEDURE setpos(buttnr,bx,by)
~RSRC_GADDR(0,nr,zu%)
buttadr=zu%+24*buttnr
DPOKE buttadr+16,bx
DPOKE buttadr+18,by
RETURN
'
> PROCEDURE colorbox(nrr,buttnr,col,fill)
.| Glob. Var.: zu%,buttadr#,colflag#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : HAUPTPROGRAMM-68,
~RSRC_GADDR(0,nrr,zu%)
buttadr=zu%+24*buttnr
colflag=DPEEK(buttadr+14)
colflag=(colflag AND &HFFF0)+col
colflag=(colflag AND &HFF8F)+fill*16
DPOKE buttadr+14,colflag
RETURN
'
> PROCEDURE textcolor(nrr,buttnr,col,rahmen,fill)
~RSRC_GADDR(0,nrr,zu%)
buttadr=LPEEK(zu%+24*buttnr+12)
colflag=DPEEK(buttadr+18)
colflag=(colflag AND &HF0)+col*256+rahmen*4096+fill
DPOKE buttadr+18,colflag
RETURN
'
> PROCEDURE editread(edread)
.| Glob. Var.: nr#,zu%,editadr#,erd#,a$,bv$
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-2,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkproof-1,tedproof-1,setupdat-1,setsave-1,
~RSRC_GADDR(0,nr,zu%)
editadr=zu%+24*edread+12
erd=LPEEK(LPEEK(editadr))
a$=""
WHILE PEEK(erd)<>0
bv$=CHR$(PEEK(erd))
a$=a$+bv$
erd=erd+1
WEND
RETURN
'
> PROCEDURE editfeld(edname,ed$)
.| Glob. Var.: edit_obj&,nr#,zu%,editadr#,edanf#,edz#,ef#,ap#,xwidth#
.|     ywidth#
.| Ruft auf  : xrsrc_gaddr
.| Aufruf in : sampleinf-8,resample-1,arrsmpr-1,arrdelay-1,delayr-1
.|     delayl-1,arrmname-1,blkart-1,tedart-2,setdat-1,
edit_obj&=0
~RSRC_GADDR(0,nr,zu%)
editadr=zu%+24*edname+12
edanf=LPEEK(LPEEK(editadr))
edz=LEN(ed$)
FOR ef=1 TO edz
ap=ASC(MID$(ed$,ef,1))
POKE edanf+ef-1,ap
NEXT ef
~WIND_UPDATE(1)                                    ! BEG_UPDATE
~OBJC_DRAW(zu%,edname,1,0,0,xwidth,ywidth)
~WIND_UPDATE(0)                                    ! BEG_UPDATE
~FRE(0)
RETURN
'
> PROCEDURE mouse(VAR mx,my,mk)
.| Aufruf in : message-1,normalize-1,fadehandler-2,markhandl4-1,arrsmpr-1
.|     dragging1-2,dragging2-2,arrmname-1,virtual-1,setupdat-1,midi-1
.|     do_peak-1,markhandler-1,
LOCAL void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx,my,mk,void&)
~WIND_UPDATE(2)
'
SUB mx,WORD{WINDTAB+64}
SUB my,WORD{WINDTAB+66}
RETURN
'
> FUNCTION mousek
$F%
.| Aufruf in : maschruf2-1,maschruf3-1,maschruf3b-1,maschruf4b-1
.|     maschruf5-1,maschruf5c-1,maschruf8b-1,fadehandler-1,fade-1,smptime-1
.|     movefrag-1,drawpix-2,edhandler2-3,smpsave-1,blklfrag-1,newfsel-1
.|     sampleinf-1,trkplay-1,dragging2-1,arrtristate-1,arrdelay-1,arrplay-1
.|     abackup-1,time_edit-1,make-1,smpsts-1,smpes-1,do_peak-1,peakwert-1
.|     markhandler-1,
LOCAL mk&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(void&,void&,mk&,void&)
~WIND_UPDATE(2)
'
RETURN mk&
'
ENDFUNC
'
> FUNCTION mousex
$F%
.| Aufruf in : markhandl4-1,do_peak-1,
LOCAL mx&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(mx&,void&,void&,void&)
~WIND_UPDATE(2)
SUB mx&,WORD{WINDTAB+64}
'
RETURN mx&
'
ENDFUNC
'
> FUNCTION mousey
$F%
.| Aufruf in : markhandl4-1,do_peak-1,
LOCAL my&,void&
'
~WIND_UPDATE(3)
~GRAF_MKSTATE(void&,my&,void&,void&)
~WIND_UPDATE(2)
SUB my&,WORD{WINDTAB+66}
'
RETURN my&
'
ENDFUNC
'
' ------------------------------------------------------------------------------
'          HardwareunabhÑngiger Teil - GEM
' ------------------------------------------------------------------------------
' ------------------------------------------------------------------------------
' ------------------------HAUPTPROGRAMM-----------------------------------------
' ------------------------------------------------------------------------------
'
> PROCEDURE loaddesk
IF lddesk=FALSE THEN
rscda=@rsc_holen(btree,0,0,btree)  ! File$,Trees,Popup,Menu,Alert
IF maxcol=2 AND rscda=TRUE THEN
@textcolor(cbl&,cblhelp&,1,1,0)
@textcolor(cbl&,source&,1,1,0)
@textcolor(cbl&,channel&,1,1,0)
@textcolor(cbl&,byt4&,1,1,0)
@textcolor(cbl&,byt5&,1,1,0)
@textcolor(cbl&,byt6&,1,1,0)
@textcolor(cbl&,byt7&,1,1,0)
@textcolor(cbl&,byt8&,1,1,0)
@textcolor(cbl&,byt9&,1,1,0)
@textcolor(cbl&,byt10&,1,1,0)
@textcolor(cbl&,byt11&,1,1,0)
@textcolor(cbl&,byt12&,1,1,0)
@textcolor(cbl&,byt13&,1,1,0)
@textcolor(cbl&,byt14&,1,1,0)
@textcolor(cbl&,byt15&,1,1,0)
@textcolor(cbl&,byt16&,1,1,0)
@textcolor(cbl&,byt17&,1,1,0)
@textcolor(cbl&,byt18&,1,1,0)
@textcolor(cbl&,byt19&,1,1,0)
@textcolor(cbl&,byt20&,1,1,0)
@textcolor(cbl&,byt21&,1,1,0)
@textcolor(cbl&,byt22&,1,1,0)
@textcolor(cbl&,byt23&,1,1,0)
@colorbox(cbl&,cblbox1&,0,7)
@colorbox(cbl&,cblbox2&,0,7)
@colorbox(cbl&,cblbox3&,0,7)
@colorbox(cbl&,cblbox4&,0,7)
@colorbox(cbl&,cblbox5&,0,7)
@colorbox(cbl&,cblbox6&,0,7)
@colorbox(cbl&,cblbox7&,0,7)
@colorbox(cbl&,cblbox8&,0,7)
@colorbox(cbl&,cblbox9&,0,7)
@colorbox(cbl&,cblbox10&,0,7)
@colorbox(cbl&,cblbox11&,0,7)
@colorbox(cbl&,cblbox12&,0,7)
@colorbox(cbl&,cblbox13&,0,7)
@colorbox(cbl&,cblbox14&,0,7)
@colorbox(cbl&,cblbox15&,0,7)
ENDIF
ENDIF
lddesk=TRUE
RETURN
'
> PROCEDURE helptxt(search$)        ! Hilfstexte von 1st Guide aktivieren
'
' Der Pfad der IDX-Datei muû vorher im 1stGuide Konfigurationsdialog eingegeben werden !!!
'
LOCAL g,hlpfound,t,a,hobj,vfly
msg_id=APPL_FIND("1STGUIDE")
IF msg_id<>-1 THEN
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=s$+"1STGUIDE.IDX"
ENDIF
IF hpath$="" OR EXIST(hpath$)=FALSE THEN
hpath$=op$+"1STGUIDE.IDX"
ENDIF
IF EXIST(hpath$)=FALSE THEN
hlpfound=FALSE
~GRAF_MOUSE(256,0)                              ! Hidem
ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
@fileselect(op$+"*.IDX","1STGUIDE.IDX","Search 1STGUIDE.IDX:")
@rsc_put(ab,rscx&(nr),rscy&(nr),1)
IF ordner$<>"" AND pret<>0 AND pbutt=1 THEN
hpath$=ordner$+"1STGUIDE.IDX"
IF EXIST(hpath$)=TRUE THEN
hlpfound=TRUE
ENDIF
ENDIF
ELSE
hlpfound=TRUE
ENDIF
IF hlpfound=TRUE THEN
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
normd=FALSE
IF rsc_handle%(nr)>1000                             ! Normaler Dialog...
normd=TRUE
ndnr=nr
@rsc_back(nr)
ENDIF
'
hpath$=hpath$+CHR$(0)
@appl_write(msg_id,&H4711,0,0,0,0,0,hpath$)    ! VA_START
accwindopen=FALSE
ON MENU MESSAGE GOSUB message
t=TIMER
REPEAT
ON MENU
UNTIL accwindopen=TRUE OR (TIMER-t)>400
search$=search$+CHR$(0)
a=1025
accwindopen=FALSE
@appl_write(msg_id,a,0,0,0,0,0,search$)                           ! AC_HELP
ON MENU MESSAGE GOSUB message
t=TIMER
REPEAT
ON MENU
UNTIL accwindopen=TRUE OR (TIMER-t)>400
IF normd=TRUE THEN                            ! Normaler Dialog...
nr=ndnr
@rsc_draw(nr,0)
ENDIF
ELSE
'
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
ENDIF
ELSE
'
edit_obj&=0
@readbutton(obj)
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
PAUSE 3
'
@readbutton(obj)
hobj=obj
vfly=fly
fly=TRUE
edit_obj&=0
@alerts(12)
fly=vfly
obj=hobj
buttflag=(buttflag AND &HFFFE)
PAUSE 3
@setbutton(obj,buttflag)
ENDIF
RETURN
'
> PROCEDURE fileselect(a$,b$,c$)
.| Glob. Var.: fs_iinpath%,fs_iinsel%,fs_iinlabel%,a#,ordner$,nam$,fil$
.| Ruft auf  : fsel_exinput
.| Aufruf in : fadesave-1,fadeload-1,smpsave-1,newfsel-3,ldhlp-1,trakload-1
.|     hardfs-1,arrload-1,arrsave-1,make-1,fseldef-1,coninsert-1,smpplay-1
.|     record3-1,
~GRAF_MOUSE(256,0)                              ! Hidem
'  ab=@rsc_get(rscx&(nr),rscy&(nr),rscw&(nr),rsch&(nr))
~GRAF_MOUSE(257,0)                              ! Showm
a$=a$+CHR$(0)+SPACE$(100)
fs_iinpath%=VARPTR(a$)
b$=b$+CHR$(0)+SPACE$(100)
fs_iinsel%=VARPTR(b$)
c$=c$+CHR$(0)+SPACE$(100)
fs_iinlabel%=VARPTR(c$)
@fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
a=INSTR(a$,CHR$(0))
a$=LEFT$(a$,a-1)
a=INSTR(b$,CHR$(0))
b$=LEFT$(b$,a-1)
a=RINSTR(a$,"\")
IF LEN(a$)=0 THEN
ordner$=""
ELSE
ordner$=LEFT$(a$,a)
ENDIF
IF LEN(b$)=0 THEN
nam$=""
fil$=""
ELSE
nam$=b$
fil$=ordner$+b$
ENDIF
RETURN
'
> PROCEDURE fsel_exinput(fs_iinpath%,fs_iinsel%,fs_iinlabel%)
.| Glob. Var.: pret#,pbutt#
.| Ruft auf  : ain
.| Aufruf in : fileselect-1,
LPOKE ADDRIN,fs_iinpath%
LPOKE ADDRIN+4,fs_iinsel%
LPOKE ADDRIN+8,fs_iinlabel%
@ain(91,0,2,3,0)
pret=GINTOUT(0)
pbutt=GINTOUT(1)
RETURN
'
> PROCEDURE ain(g0%,g2%,g4%,g6%,g8%)
.| Aufruf in : fsel_exinput-1,
DPOKE GCONTRL,g0%
DPOKE GCONTRL+2,g2%
DPOKE GCONTRL+4,g4%
DPOKE GCONTRL+6,g6%
DPOKE GCONTRL+8,g8%
GEMSYS
RETURN
'
> PROCEDURE errorcode
e$=ERR$(ERR)
e=INSTR(2,e$,"[")
e$=RIGHT$(e$,LEN(e$)-e)
e=INSTR(e$,"]")
e$=LEFT$(e$,e-1)
e=INSTR(e$,"|")
e2=FALSE
IF e<>0 THEN
e$=LEFT$(e$,e-1)
e2=TRUE
ENDIF
IF e2=FALSE AND LEN(e$)>28 THEN
e$=LEFT$(e$,25)+"..."
ENDIF
IF e2=TRUE THEN
IF LEN(e$)>25 THEN
e$=LEFT$(e$,25)+"..."
ELSE
e$=e$+"..."
ENDIF
ENDIF
RETURN
'
> PROCEDURE alerts(alert)
LOCAL aobj,afly
aobj=obj
afly=fly
fly=TRUE
edit_obj&=0
'  @wischwasch
SELECT language
CASE 1
SELECT alert
CASE 1
g=@rsc_alert(3,"Auflîsung ist zu gering|Mindestens 728x512 nîtig !",1,"E[XIT")
CASE 2
g=@rsc_alert(3,"RSC-File nicht gefunden !",1,"E[XIT")
CASE 3
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher !!!",1,"E[XIT")
CASE 4
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher !!!",1,"[OK")
CASE 5
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher !!!",2,"[OK|E[XIT")
CASE 6
g=@rsc_alert(3,"memory overrun !|Zu wenig freier Speicher|DANGER !!!",2,"[OK|E[XIT")
CASE 7
g=@rsc_alert(1,"Kein PLAY von|Memory-Samples !|Wegen virt. Bearbeitung|gesperrt.",1,"[OK")
CASE 8
g=@rsc_alert(3,"Audio-Treiber konnte|nicht geladen werden !",1,"E[XIT")
CASE 9
g=@rsc_alert(3,"Audio-Treiber fehlt !",1,"E[XIT")
CASE 10
g=@rsc_alert(3,"Falscher File-Extender !",1,"E[XIT")
CASE 11
g=@rsc_alert(1,"Alle Fenster belegt|Bitte ein Fenster|schlieûen !",1,"E[XIT")
CASE 12
g=@rsc_alert(1,"1stGuide|ist nicht installiert|daher keine Hilfe,sorry !!!",1,"[OK")
CASE 13
g=@rsc_alert(1,"Bereichsfehler !|Block definiert ?",1,"[OK")
CASE 14
g=@rsc_alert(2,"Kopieren ?",1,"[JA|[NEIN")
CASE 15
g=@rsc_alert(1,"Sorry, aber das macht|keinen Sinn !",1,"E[XIT")
CASE 16
g=@rsc_alert(1,"Kein Block markiert !",1,"[OK")
CASE 17
g=@rsc_alert(2,"EinfÅgen ?",1,"[JA|[NEIN")
CASE 18
g=@rsc_alert(1,"Sample-Auflîsungsgrenze|erreicht !",1,"[OK")
CASE 19
g=@rsc_alert(1,"Musicbox-SpeicherplÑtze|belegt !",1,"E[XIT")
CASE 20
g=@rsc_alert(2,"Sample lîschen ?",1,"[JA|[NEIN")
CASE 21
g=@rsc_alert(2,"Musicbox-SpeicherplÑtze|wirklich lîschen ?",1,"[JA|[NEIN")
CASE 22
g=@rsc_alert(1,"Ladefehler !",1,"E[XIT")
CASE 23
g=@rsc_alert(1,"Datei nicht gefunden !",1,"E[XIT")
CASE 24
g=@rsc_alert(1,"Sample in virtueller|Bearbeitung !|Sample mit Trash lîschen.",1,"[OK")
CASE 25
g=@rsc_alert(3,"Fehlerhafte|Blockmarkierung !",1,"E[XIT")
CASE 26
g=@rsc_alert(2,"Wirklich Midi-Arrangement|lîschen ?",1,"[OK|E[XIT")
CASE 27
g=@rsc_alert(3,"INF-File fehlt !",1,"E[XIT")
CASE 28
g=@rsc_alert(1,"Alle PlÑtze belegt !",1,"E[XIT")
CASE 29
g=@rsc_alert(1,"Alle Abspielpositionen|belegt !",1,"[Naja")
CASE 30
alrt$="Datei nicht gefunden:|"+alrt$
g=@rsc_alert(1,alrt$,1,"[OK")
CASE 31
g=@rsc_alert(2,"Wirklich Track lîschen ?",1,"[OK|E[XIT")
CASE 32
g=@rsc_alert(1,"Zuerst Spur auswÑhlen !",1,"E[XIT")
CASE 33
g=@rsc_alert(1,"Track-Curve-Memory belegt !",1,"E[XIT")
CASE 34
g=@rsc_alert(1,"Zuerst Sample laden !",1,"[OK")
CASE 35
g=@rsc_alert(1,"Ist doch genug Platz !",1,"[OK")
CASE 36
g=@rsc_alert(1,"Der letzte Platz ist belegt,|daher kein INSERT mîglich!",1,"[OK")
CASE 37
g=@rsc_alert(1,"unkorrekte Eingabe !",1,"[OK")
CASE 38
g=@rsc_alert(1,"Zuerst Platz auswÑhlen !",1,"[OK")
CASE 39
g=@rsc_alert(3,"Der Wert ist auûerhalb des|gÅltigen Bereichs !",1,"E[XIT")
CASE 40
g=@rsc_alert(2,"Sample retten ?",2,"[JA|[NEIN")
CASE 41
g=@rsc_alert(2,"Sample nochmal retten ?",2,"[JA|[NEIN")
CASE 42
g=@rsc_alert(1,"Unkorrekter Name !",1,"E[XIT")
CASE 43
g=@rsc_alert(2,"Virtuelles Sample|entfernen & Speicherinhalt|zurÅckholen ?",1,"[JA|[NEIN")
CASE 44
g=@rsc_alert(2,"Sample entfernen und|altes Sample zurÅckholen ?",1,"[JA|[NEIN")
CASE 45
g=@rsc_alert(2,"Sample entfernen ?",1,"[JA|[NEIN")
CASE 46
a=@rsc_alert(3,"Zu wenig Speicher !|Bitte Block verkleinern !",1,"[OK")
CASE 47
g=@rsc_alert(1,"Zu wenig Platz|auf dem Speichermedium !",1,"E[XIT")
CASE 48
frag=@rsc_alert(2,"AUFNAHME ?",1,"[JA|[NEIN")
CASE 49
g=@rsc_alert(0,"Aufnahme-Start",1,"[OK")
CASE 50
@errorcode
g=@rsc_alert(3,"Fehler aufgetaucht !!!|Fehlernummer:"+STR$(ERR)+"|"+e$+"|Weiter ?",2,"[JA|[NEIN")
CASE 51
g=@rsc_alert(1,"Trackliste ist inkonsistent",1,"[OK")
CASE 99
g=@rsc_alert(2,"Programm beenden",1,"[JA|[NEIN")
ENDSELECT
CASE 2
SELECT alert
CASE 1
g=@rsc_alert(3,"screen resolution too low|minimal 728x512 necessary !",1,"E[XIT")
CASE 2
g=@rsc_alert(3,"RSC-file not found !",1,"E[XIT")
CASE 3
g=@rsc_alert(3,"memory overrun !|too little memory-space !!!",1,"E[XIT")
CASE 4
g=@rsc_alert(3,"memory overrun !|too little memory-space !!!",1,"[OK")
CASE 5
g=@rsc_alert(3,"memory overrun !|too little memory-space !!!",2,"[OK|E[XIT")
CASE 6
g=@rsc_alert(3,"memory overrun !|too little memory-space|DANGER !!!",2,"[OK|E[XIT")
CASE 7
g=@rsc_alert(1,"no PLAY from|memory-samples !|because of virtual working|blocked up.",1,"[OK")
CASE 8
g=@rsc_alert(3,"audio-driver could|not get load !",1,"E[XIT")
CASE 9
g=@rsc_alert(3,"audio-driver|is missing !",1,"E[XIT")
CASE 10
g=@rsc_alert(3,"wrong file-extender !",1,"E[XIT")
CASE 11
g=@rsc_alert(1,"all windows used|please,close a window !",1,"E[XIT")
CASE 12
g=@rsc_alert(1,"1stGuide is not installed|therefore no help,sorry !!!",1,"[OK")
CASE 13
g=@rsc_alert(1,"block-error !|block undefined ?",1,"[OK")
CASE 14
g=@rsc_alert(2,"copy ?",1,"[YES|[NO")
CASE 15
g=@rsc_alert(1,"sorry, that have no sense !",1,"E[XIT")
CASE 16
g=@rsc_alert(1,"no block defined !",1,"[OK")
CASE 17
g=@rsc_alert(2,"insert ?",1,"[YES|[NO")
CASE 18
g=@rsc_alert(1,"sample-resolutionlimit|is reached !",1,"[OK")
CASE 19
g=@rsc_alert(1,"musicbox-memoryspace|is full !",1,"E[XIT")
CASE 20
g=@rsc_alert(2,"delete sample ?",1,"[YES|[NO")
CASE 21
g=@rsc_alert(2,"really delete|musicbox-memoryspace ?",1,"[YES|[NO")
CASE 22
g=@rsc_alert(1,"load-error !",1,"E[XIT")
CASE 23
g=@rsc_alert(1,"file not found !",1,"E[XIT")
CASE 24
g=@rsc_alert(1,"sample in|virtual working !|delete sample with trash.",1,"[OK")
CASE 25
g=@rsc_alert(3,"wrong blockmarking !",1,"E[XIT")
CASE 26
g=@rsc_alert(2,"really delete|midi-arrangement ?",1,"[OK|E[XIT")
CASE 27
g=@rsc_alert(3,"INF-file missing !",1,"E[XIT")
CASE 28
g=@rsc_alert(1,"all places full !",1,"E[XIT")
CASE 29
g=@rsc_alert(1,"all playpositions full !",1,"[shit")
CASE 30
alrt$="file not found:|"+alrt$
g=@rsc_alert(1,alrt$,1,"[OK")
CASE 31
g=@rsc_alert(2,"really delete track ?",1,"[OK|E[XIT")
CASE 32
g=@rsc_alert(1,"first select track !",1,"E[XIT")
CASE 33
g=@rsc_alert(1,"track-curve-memory full !",1,"E[XIT")
CASE 34
g=@rsc_alert(1,"first load sample !",1,"[OK")
CASE 35
g=@rsc_alert(1,"but it's enough space !",1,"[OK")
CASE 36
g=@rsc_alert(1,"all places full,|therefore no INSERT|is possible!",1,"[OK")
CASE 37
g=@rsc_alert(1,"uncorrect input !",1,"[OK")
CASE 38
g=@rsc_alert(1,"first select place !",1,"[OK")
CASE 39
g=@rsc_alert(3,"the value is outside the|legal area !",1,"E[XIT")
CASE 40
g=@rsc_alert(2,"save sample ?",2,"[YES|[NO")
CASE 41
g=@rsc_alert(2,"save sample again ?",2,"[YES|[NO")
CASE 42
g=@rsc_alert(1,"uncorrect name !",1,"E[XIT")
CASE 43
g=@rsc_alert(2,"remove virtual sample &|fetch back memory-contents ?",1,"[YES|[NO")
CASE 44
g=@rsc_alert(2,"remove sample and|fetch back old sample ?",1,"[YES|[NO")
CASE 45
g=@rsc_alert(2,"remove sample ?",1,"[YES|[NO")
CASE 46
a=@rsc_alert(3,"memory too low !|please reduce block !",1,"[OK")
CASE 47
g=@rsc_alert(1,"disk-media too low !",1,"E[XIT")
CASE 48
frag=@rsc_alert(2,"RECORD ?",1,"[YES|[NO")
CASE 49
g=@rsc_alert(0,"record-start",1,"[OK")
CASE 50
@errorcode
g=@rsc_alert(3,"error found !!!|error-number:"+STR$(ERR)+"|"+e$+"|continue ?",2,"[YES|[NO")
CASE 51
g=@rsc_alert(1,"tracklist is wrong !",1,"[SHIT")
CASE 99
g=@rsc_alert(2,"close program",1,"[YES|[NO")
ENDSELECT
ENDSELECT
obj=aobj
fly=afly
edit_obj&=0
RETURN
'
> PROCEDURE goodbye
@write_int(0)
proghere=FALSE
IF rscda=TRUE THEN
@rsc_back(cbl&)
ENDIF
'
IF acc=FALSE THEN
IF rscda=TRUE THEN
@rsc_exit
ENDIF
IF compile=FALSE THEN
RESERVE         ! Reservierung lîschen
ENDIF
ENDIF
exit=TRUE
IF demo=FALSE THEN
~XBIOS(xbs,25,0)
ENDIF
RETURN
'
> PROCEDURE language
SELECT language
CASE 1 ! deutsch
CASE 2 !englisch
ENDSELECT
RETURN
'
> PROCEDURE treiberload
IF XBIOS(xbs,1)<>&H71273800 THEN
'    IF EXIST(s$+"SOUND.PRG"+CHR$(0))=TRUE THEN
'    a=EXEC(0,s$+"SOUND.PRG"+CHR$(0),CHR$(0),CHR$(0))
'    IF a<>0 OR XBIOS(xbs,1)<>&H71273800 THEN
'    @alerts(8)
'    exit=TRUE
'  ENDIF
'  ELSE
@alerts(9)
exit=TRUE
'  ENDIF
ENDIF
RETURN
'
> FUNCTION mxalloc(giveme,art)
a=GEMDOS(68,L:giveme,art)
RETURN a
ENDFUNC
'
> PROCEDURE killhz
IF srate=44 THEN
@setbutton(hz44&,0)
ENDIF
IF srate=48 THEN
@setbutton(hz48&,0)
ENDIF
IF srate=32 THEN
@setbutton(hz32&,0)
ENDIF
RETURN
'
> PROCEDURE killppm
IF accur=1 THEN
@setbutton(ppmvar&,0)
ENDIF
IF accur=2 THEN
@setbutton(ppm1000&,0)
ENDIF
IF accur=3 THEN
@setbutton(ppm50&,0)
ENDIF
RETURN
'
> PROCEDURE killcateg
IF cat=0 THEN
@setbutton(general&,0)
ENDIF
IF cat=1 THEN
@setbutton(experim&,0)
ENDIF
IF cat=2 THEN
@setbutton(solid&,0)
ENDIF
IF cat=3 THEN
@setbutton(broad&,0)
ENDIF
IF cat=4 THEN
@setbutton(digconv&,0)
ENDIF
IF cat=5 THEN
@setbutton(adwitho&,0)
ENDIF
IF cat=6 THEN
@setbutton(adwith&,0)
ENDIF
IF cat=7 THEN
@setbutton(broad&,0)
ENDIF
IF cat=8 THEN
@setbutton(laser&,0)
ENDIF
IF cat=9 THEN
@setbutton(instrum&,0)
ENDIF
IF cat=10 THEN
@setbutton(tape&,0)
ENDIF
IF cat=99 THEN
@setbutton(categres&,0)
ENDIF
RETURN
'
> PROCEDURE killspeak
IF speak=0 THEN
@setbutton(japan&,0)
ENDIF
IF speak=1 THEN
@setbutton(usa&,0)
ENDIF
IF speak=2 THEN
@setbutton(europe&,0)
ENDIF
IF speak=3 THEN
@setbutton(soft&,0)
ENDIF
IF speak=99 THEN
@setbutton(landres&,0)
ENDIF
RETURN
'
> PROCEDURE killconv
IF conv=0 THEN
@setbutton(pcm&,0)
ENDIF
IF conv=1 THEN
@setbutton(sampler&,0)
ENDIF
IF conv=2 THEN
@setbutton(mixer&,0)
ENDIF
IF conv=3 THEN
@setbutton(srconv&,0)
ENDIF
IF conv=99 THEN
@setbutton(convres&,0)
ENDIF
RETURN
'
> PROCEDURE laserkill
IF laser=0 THEN
@setbutton(cd&,0)
ENDIF
IF laser=1 THEN
@setbutton(magneto&,0)
ENDIF
IF laser=99 THEN
@setbutton(cdres&,0)
ENDIF
RETURN
'
> PROCEDURE killinst
IF inst=0 THEN
@setbutton(synth&,0)
ENDIF
IF inst=1 THEN
@setbutton(micro&,0)
ENDIF
IF inst=99 THEN
@setbutton(instres&,0)
ENDIF
RETURN
'
> PROCEDURE killtape
IF tap=0 THEN
@setbutton(dat&,0)
ENDIF
IF tap=1 THEN
@setbutton(vcr&,0)
ENDIF
IF tap=99 THEN
@setbutton(taperes&,0)
ENDIF
RETURN
'
> PROCEDURE initialize
DIM cbl(23)
DIM vcbl(23)
RETURN
'
> PROCEDURE cblconsumer
nr=cbl&
@killcblc
digi=-1
cop=-1
genstat=-1
kanal=-1
srate=-1
accur=-1
emp=-1
dat=-1
cat=-1
speak=-1
laser=-1
inst=-1
tap=-1
conv=-1
'
demo=FALSE
IF (XBIOS(103)=3 AND snd=&H1F AND mch=&H30000 AND vdo=&H30000 AND XBIOS(xbs,10)=0) OR magicmac<>0 OR falconda=TRUE THEN
falcon=TRUE
demo=TRUE
ELSE
IF XBIOS(xbs,10)=0 THEN
demo=TRUE
ENDIF
ENDIF
'
IF proghere=FALSE THEN
nr=cbl&
vornr=nr
@rsc_draw(nr,0)
ENDIF
proghere=TRUE
IF demo=FALSE THEN
~XBIOS(xbs,25,1)
ENDIF
FOR i=0 TO 23
vcbl(i)=-1
NEXT i
@cblinit
REPEAT
obj=@rsc_do(nr,0,popup&)
IF obj=cblhelp& THEN
@helptxt("CBL-STATUS")
ENDIF
UNTIL obj=cblexit& OR obj=9999
@cblbye
@setbutton(cblexit&,0)
~GRAF_MOUSE(0,0)                                       ! Zur Sicherheit
obj=0
@goodbye
RETURN
'
> PROCEDURE killcblc
@setbutton2(digital&,0)
@setbutton2(nonaudio&,0)
@setbutton2(cprot&,0)
@setbutton2(cfree&,0)
@setbutton2(orig&,0)
@setbutton2(firstgen&,0)
@setbutton2(channel2&,0)
@setbutton2(channel4&,0)
@setbutton2(hz32&,0)
@setbutton2(hz44&,0)
@setbutton2(hz48&,0)
@setbutton2(ppm50&,0)
@setbutton2(ppm1000&,0)
@setbutton2(ppmvar&,0)
@setbutton2(empha&,0)
@setbutton2(digdat&,0)
@setbutton2(general&,0)
@setbutton2(experim&,0)
@setbutton2(solid&,0)
@setbutton2(broad&,0)
@setbutton2(digconv&,0)
@setbutton2(adwitho&,0)
@setbutton2(adwith&,0)
@setbutton2(laser&,0)
@setbutton2(instrum&,0)
@setbutton2(tape&,0)
@setbutton2(categres&,0)
@setbutton2(japan&,0)
@setbutton2(usa&,0)
@setbutton2(europe&,0)
@setbutton2(soft&,0)
@setbutton2(landres&,0)
@setbutton2(pcm&,0)
@setbutton2(sampler&,0)
@setbutton2(mixer&,0)
@setbutton2(srconv&,0)
@setbutton2(convres&,0)
@setbutton2(cd&,0)
@setbutton2(magneto&,0)
@setbutton2(cdres&,0)
@setbutton2(synth&,0)
@setbutton2(micro&,0)
@setbutton2(instres&,0)
@setbutton2(dat&,0)
@setbutton2(vcr&,0)
@setbutton2(taperes&,0)
RETURN
'
> PROCEDURE cblinit
IF demo=FALSE THEN
ret=XBIOS(xbs,43,1)
cbl=XBIOS(xbs,44)
PAUSE 5
@write_int(2)
ENDIF
RETURN
'
> PROCEDURE cblread
FOR i=0 TO 23
cbl(i)=(PEEK(cbl+i))
NEXT i
RETURN
'
> PROCEDURE cblbye
IF demo=FALSE THEN
@write_int(0)
ret2=XBIOS(xbs,43,0)
ENDIF
RETURN
'
> PROCEDURE killsub
@killspeak
@killconv
@laserkill
@killinst
@killtape
RETURN
'
> PROCEDURE cblmake
IF BTST(cbl(0),6)=FALSE THEN
IF digi<>0 THEN
@setbutton(nonaudio&,0)
@setbutton(digital&,1)
ENDIF
digi=0
ELSE
IF digi<>1 THEN
@setbutton(digital&,0)
@setbutton(nonaudio&,1)
ENDIF
digi=1
ENDIF
'
IF BTST(cbl(0),5)=FALSE THEN
IF cop<>0 THEN
@setbutton(cfree&,0)
@setbutton(cprot&,1)
ENDIF
cop=0
ELSE
IF cop<>1 THEN
@setbutton(cprot&,0)
@setbutton(cfree&,1)
ENDIF
cop=1
ENDIF
gen=FALSE
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=FALSE AND BTST(cbl(1),5)=TRUE
gen=TRUE
ENDIF
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=TRUE AND BTST(cbl(1),5)=TRUE AND BTST(cbl(1),4)=TRUE
gen=TRUE
ENDIF
IF BTST(cbl(1),7)=TRUE AND BTST(cbl(1),6)=FALSE AND BTST(cbl(1),5)=FALSE
gen=TRUE
ENDIF
IF gen=TRUE THEN
IF BTST(cbl(1),0)=FALSE THEN
IF genstat<>0 THEN
@setbutton(firstgen&,0)
@setbutton(orig&,1)
ENDIF
genstat=0
ELSE
IF genstat<>1 THEN
@setbutton(orig&,0)
@setbutton(firstgen&,1)
ENDIF
genstat=1
ENDIF
ELSE
IF BTST(cbl(1),0)=TRUE THEN
IF genstat<>0 THEN
@setbutton(firstgen&,0)
@setbutton(orig&,1)
ENDIF
genstat=0
ELSE
IF genstat<>1 THEN
@setbutton(orig&,0)
@setbutton(firstgen&,1)
ENDIF
genstat=1
ENDIF
ENDIF
IF BTST(cbl(0),2)=TRUE THEN
IF kanal<>1 THEN
@setbutton(channel2&,0)
@setbutton(channel4&,1)
ENDIF
kanal=1
ELSE
IF kanal<>0 THEN
@setbutton(channel4&,0)
@setbutton(channel2&,1)
ENDIF
kanal=0
ENDIF
'
IF BTST(cbl(3),7)=FALSE AND BTST(cbl(3),6)=FALSE THEN
IF srate<>44 THEN
@killhz
@setbutton(hz44&,1)
ENDIF
srate=44
ENDIF
IF BTST(cbl(3),7)=FALSE AND BTST(cbl(3),6)=TRUE THEN
IF srate<>48 THEN
@killhz
@setbutton(hz48&,1)
ENDIF
srate=48
ENDIF
IF BTST(cbl(3),7)=TRUE AND BTST(cbl(3),6)=TRUE THEN
IF srate<>32 THEN
@killhz
@setbutton(hz32&,1)
ENDIF
srate=32
ENDIF
'
IF BTST(cbl(3),3)=FALSE AND BTST(cbl(3),2)=FALSE THEN
IF accur<>2 THEN
@killppm
@setbutton(ppm1000&,1)
ENDIF
accur=2
ENDIF
IF BTST(cbl(3),3)=FALSE AND BTST(cbl(3),2)=TRUE THEN
IF accur<>3 THEN
@killppm
@setbutton(ppm50&,1)
ENDIF
accur=3
ENDIF
IF BTST(cbl(3),3)=TRUE AND BTST(cbl(3),2)=FALSE THEN
IF accur<>1 THEN
@killppm
@setbutton(ppmvar&,1)
ENDIF
accur=1
ENDIF
'
IF BTST(cbl(0),4)=FALSE AND BTST(cbl(0),3)=FALSE THEN
IF emp<>0 THEN
@setbutton(empha&,0)
ENDIF
emp=0
ELSE
IF emp<>1 THEN
@setbutton(empha&,1)
ENDIF
emp=1
ENDIF
'
IF BTST(cbl(0),6)=TRUE AND BTST(cbl(0),4)=FALSE AND BTST(cbl(0),3)=FALSE AND BTST(cbl(0),2)=FALSE THEN
IF dat<>1 THEN
@setbutton(digdat&,1)
ENDIF
dat=1
ELSE
IF dat<>0 THEN
@setbutton(digdat&,0)
ENDIF
dat=0
ENDIF
'
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=FALSE AND BTST(cbl(1),5)=FALSE AND BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
IF cat<>0 THEN
@killcateg
@setbutton(general&,1)
ENDIF
cat=0
ENDIF
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=FALSE AND BTST(cbl(1),5)=FALSE AND BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=TRUE THEN
IF cat<>1 THEN
@killcateg
@setbutton(experim&,1)
ENDIF
cat=1
ENDIF
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=FALSE AND BTST(cbl(1),5)=FALSE AND BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=TRUE THEN
IF cat<>99 THEN
@killcateg
@setbutton(categres&,1)
ENDIF
cat=99
ENDIF
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=FALSE AND BTST(cbl(1),5)=FALSE AND BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=TRUE THEN
IF cat<>99 THEN
@killcateg
@setbutton(categres&,1)
ENDIF
cat=99
ENDIF
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=FALSE AND BTST(cbl(1),5)=FALSE AND BTST(cbl(1),4)=TRUE THEN
IF cat<>2 THEN
@killcateg
@setbutton(solid&,1)
ENDIF
cat=2
ENDIF
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=FALSE AND BTST(cbl(1),5)=TRUE THEN
IF cat<>3 THEN
@killcateg
@setbutton(broad&,1)
ENDIF
cat=3
vspeak=0
IF BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vspeak=1
IF speak<>0 THEN
@killsub
@setbutton(japan&,1)
ENDIF
speak=0
ENDIF
IF BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=TRUE AND BTST(cbl(1),1)=TRUE THEN
vspeak=1
IF speak<>1 THEN
@killsub
@setbutton(usa&,1)
ENDIF
speak=1
ENDIF
IF BTST(cbl(1),4)=TRUE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vspeak=1
IF speak<>2 THEN
@killsub
@setbutton(europe&,1)
ENDIF
speak=2
ENDIF
IF BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=TRUE THEN
vspeak=1
IF speak<>3 THEN
@killsub
@setbutton(soft&,1)
ENDIF
speak=3
ENDIF
IF vspeak=0 THEN
IF speak<>99 THEN
@killsub
@setbutton(landres&,1)
ENDIF
speak=99
ENDIF
ENDIF
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=TRUE AND BTST(cbl(1),5)=FALSE THEN
IF cat<>4 THEN
@killcateg
@setbutton(digconv&,1)
ENDIF
cat=4
vconv=0
IF BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vconv=1
IF conv<>0 THEN
@killsub
@setbutton(pcm&,1)
ENDIF
conv=0
ENDIF
IF BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=TRUE AND BTST(cbl(1),1)=FALSE THEN
vconv=1
IF conv<>1 THEN
@killsub
@setbutton(sampler&,1)
ENDIF
conv=1
ENDIF
IF BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=TRUE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vconv=1
IF conv<>2 THEN
@killsub
@setbutton(mixer&,1)
ENDIF
conv=2
ENDIF
IF BTST(cbl(1),4)=TRUE AND BTST(cbl(1),3)=TRUE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vconv=1
IF conv<>3 THEN
@killsub
@setbutton(srconv&,1)
ENDIF
conv=3
ENDIF
IF vconv=0 THEN
IF conv<>99 THEN
@killsub
@setbutton(convres&,1)
ENDIF
conv=99
ENDIF
ENDIF
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=TRUE AND BTST(cbl(1),5)=TRUE AND BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE THEN
IF cat<>5 THEN
@killcateg
@setbutton(adwitho&,1)
ENDIF
cat=5
ENDIF
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=TRUE AND BTST(cbl(1),5)=TRUE AND BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=TRUE THEN
IF cat<>6 THEN
@killcateg
@setbutton(adwith&,1)
ENDIF
cat=6
ENDIF
IF BTST(cbl(1),7)=FALSE AND BTST(cbl(1),6)=TRUE AND BTST(cbl(1),5)=TRUE AND BTST(cbl(1),4)=TRUE THEN
IF cat<>7 THEN
@killcateg
@setbutton(broad&,1)
ENDIF
cat=7
ENDIF
IF BTST(cbl(1),7)=TRUE AND BTST(cbl(1),6)=FALSE AND BTST(cbl(1),5)=FALSE THEN
IF cat<>8 THEN
@killcateg
@setbutton(laser&,1)
ENDIF
cat=8
vlaser=0
IF BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vlaser=1
IF laser<>0 THEN
@killsub
@setbutton(cd&,1)
ENDIF
laser=0
ENDIF
IF BTST(cbl(1),4)=TRUE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vlaser=1
IF laser<>1 THEN
@killsub
@setbutton(magneto&,1)
ENDIF
laser=1
ENDIF
IF vlaser=0 THEN
IF laser<>99 THEN
@killsub
@setbutton(cdres&,1)
ENDIF
laser=99
ENDIF
ENDIF
IF BTST(cbl(1),7)=TRUE AND BTST(cbl(1),6)=FALSE AND BTST(cbl(1),5)=TRUE THEN
IF cat<>9 THEN
@killcateg
@setbutton(instrum&,1)
ENDIF
cat=9
vinst=0
IF BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vinst=1
IF inst<>0 THEN
@killsub
@setbutton(synth&,1)
ENDIF
inst=0
ENDIF
IF BTST(cbl(1),4)=TRUE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vinst=1
IF inst<>1 THEN
@killsub
@setbutton(micro&,1)
ENDIF
inst=1
ENDIF
IF vinst=0 THEN
IF inst<>99 THEN
@killsub
@setbutton(instres&,1)
ENDIF
inst=99
ENDIF
ENDIF
IF BTST(cbl(1),7)=TRUE AND BTST(cbl(1),6)=TRUE AND BTST(cbl(1),5)=FALSE THEN
IF cat<>10 THEN
@killcateg
@setbutton(tape&,1)
ENDIF
cat=10
vtap=0
IF BTST(cbl(1),4)=FALSE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vtap=1
IF tap<>0 THEN
@killsub
@setbutton(dat&,1)
ENDIF
tap=0
ENDIF
IF BTST(cbl(1),4)=TRUE AND BTST(cbl(1),3)=FALSE AND BTST(cbl(1),2)=FALSE AND BTST(cbl(1),1)=FALSE THEN
vtap=1
IF tap<>1 THEN
@killsub
@setbutton(vcr&,1)
ENDIF
tap=1
ENDIF
IF vtap=0 THEN
IF tap<>99 THEN
@killsub
@setbutton(taperes&,1)
ENDIF
tap=99
ENDIF
ENDIF
IF BTST(cbl(1),7)=TRUE AND BTST(cbl(1),6)=TRUE AND BTST(cbl(1),5)=TRUE THEN
IF cat<>99 THEN
@killcateg
@setbutton(categres&,1)
ENDIF
cat=99
ENDIF
'
@cbltext
RETURN
'
> PROCEDURE cbltext
IF vcbl(4)<>cbl(4) THEN
a$=RIGHT$("00000000"+BIN$(cbl(4)),8)+CHR$(0)
@textfeld(byt4&,a$,1)
vcbl(4)=cbl(4)
ENDIF
IF vcbl(5)<>cbl(5) THEN
a$=RIGHT$("00000000"+BIN$(cbl(5)),8)+CHR$(0)
@textfeld(byt5&,a$,1)
vcbl(5)=cbl(5)
ENDIF
IF vcbl(6)<>cbl(6) THEN
a$=RIGHT$("00000000"+BIN$(cbl(6)),8)+CHR$(0)
@textfeld(byt6&,a$,1)
vcbl(6)=cbl(6)
ENDIF
IF vcbl(7)<>cbl(7) THEN
a$=RIGHT$("00000000"+BIN$(cbl(7)),8)+CHR$(0)
@textfeld(byt7&,a$,1)
vcbl(7)=cbl(7)
ENDIF
IF vcbl(8)<>cbl(8) THEN
a$=RIGHT$("00000000"+BIN$(cbl(8)),8)+CHR$(0)
@textfeld(byt8&,a$,1)
vcbl(8)=cbl(8)
ENDIF
IF vcbl(9)<>cbl(9) THEN
a$=RIGHT$("00000000"+BIN$(cbl(9)),8)+CHR$(0)
@textfeld(byt9&,a$,1)
vcbl(9)=cbl(9)
ENDIF
IF vcbl(10)<>cbl(10) THEN
a$=RIGHT$("00000000"+BIN$(cbl(10)),8)+CHR$(0)
@textfeld(byt10&,a$,1)
vcbl(10)=cbl(10)
ENDIF
IF vcbl(11)<>cbl(11) THEN
a$=RIGHT$("00000000"+BIN$(cbl(11)),8)+CHR$(0)
@textfeld(byt11&,a$,1)
vcbl(11)=cbl(11)
ENDIF
IF vcbl(12)<>cbl(12) THEN
a$=RIGHT$("00000000"+BIN$(cbl(12)),8)+CHR$(0)
@textfeld(byt12&,a$,1)
vcbl(12)=cbl(12)
ENDIF
IF vcbl(13)<>cbl(13) THEN
a$=RIGHT$("00000000"+BIN$(cbl(13)),8)+CHR$(0)
@textfeld(byt13&,a$,1)
vcbl(13)=cbl(13)
ENDIF
IF vcbl(14)<>cbl(14) THEN
a$=RIGHT$("00000000"+BIN$(cbl(14)),8)+CHR$(0)
@textfeld(byt14&,a$,1)
vcbl(14)=cbl(14)
ENDIF
IF vcbl(15)<>cbl(15) THEN
a$=RIGHT$("00000000"+BIN$(cbl(15)),8)+CHR$(0)
@textfeld(byt15&,a$,1)
vcbl(15)=cbl(15)
ENDIF
IF vcbl(16)<>cbl(16) THEN
a$=RIGHT$("00000000"+BIN$(cbl(16)),8)+CHR$(0)
@textfeld(byt16&,a$,1)
vcbl(16)=cbl(16)
ENDIF
IF vcbl(17)<>cbl(17) THEN
a$=RIGHT$("00000000"+BIN$(cbl(17)),8)+CHR$(0)
@textfeld(byt17&,a$,1)
vcbl(17)=cbl(17)
ENDIF
IF vcbl(18)<>cbl(18) THEN
a$=RIGHT$("00000000"+BIN$(cbl(18)),8)+CHR$(0)
@textfeld(byt18&,a$,1)
vcbl(18)=cbl(18)
ENDIF
IF vcbl(19)<>cbl(19) THEN
a$=RIGHT$("00000000"+BIN$(cbl(19)),8)+CHR$(0)
@textfeld(byt19&,a$,1)
vcbl(19)=cbl(19)
ENDIF
IF vcbl(20)<>cbl(20) THEN
a$=RIGHT$("00000000"+BIN$(cbl(20)),8)+CHR$(0)
@textfeld(byt20&,a$,1)
vcbl(20)=cbl(20)
ENDIF
IF vcbl(21)<>cbl(21) THEN
a$=RIGHT$("00000000"+BIN$(cbl(21)),8)+CHR$(0)
@textfeld(byt21&,a$,1)
vcbl(21)=cbl(21)
ENDIF
a$=RIGHT$("00000000"+BIN$(cbl(22)),8)+CHR$(0)
IF vcbl(22)<>cbl(22) THEN
@textfeld(byt22&,a$,1)
vcbl(22)=cbl(22)
ENDIF
IF vcbl(23)<>cbl(23) THEN
a$=RIGHT$("00000000"+BIN$(cbl(23)),8)+CHR$(0)
@textfeld(byt23&,a$,1)
vcbl(23)=cbl(23)
ENDIF
'
IF vcbl(2)<>cbl(2) THEN
a=0
IF BTST(cbl(2),7)=TRUE THEN
a=a+1
ENDIF
IF BTST(cbl(2),6)=TRUE THEN
a=a+2
ENDIF
IF BTST(cbl(2),5)=TRUE THEN
a=a+4
ENDIF
IF BTST(cbl(2),4)=TRUE THEN
a=a+8
ENDIF
IF a=0 THEN
a$="-"+CHR$(0)
ELSE
a$=STR$(a)+CHR$(0)
ENDIF
@textfeld(source&,a$,1)
'
a=0
IF BTST(cbl(2),3)=TRUE THEN
a=a+1
ENDIF
IF BTST(cbl(2),2)=TRUE THEN
a=a+2
ENDIF
IF BTST(cbl(2),1)=TRUE THEN
a=a+4
ENDIF
IF BTST(cbl(2),0)=TRUE THEN
a=a+8
ENDIF
IF a=0 THEN
a$="-"+CHR$(0)
ELSE
a$=RIGHT$(CHR$(a+64)+CHR$(0))
ENDIF
@textfeld(channel&,a$,1)
vcbl(2)=cbl(2)
ENDIF
RETURN
'
> PROCEDURE write_int(a)
LOCAL b
IF demo=FALSE THEN
IF a>0 THEN
intnr=a
ENDIF
IF falcon=FALSE THEN
~XBIOS(xbs,54,a)
ELSE
b=0
IF a=1 OR a=3 THEN
b=b+1
ENDIF
IF a=2 OR a=3 THEN
b=b+4
ENDIF
~XBIOS(&H88,b)
ENDIF
ENDIF
RETURN
'
> PROCEDURE read_smp
.| Glob. Var.: demo#,rwert#,adr#
.| Aufruf in : peakwert-5,
IF demo=FALSE THEN
rwert=XBIOS(xbs,52)
ENDIF
RETURN
'
' ENDE
